(self.webpackChunkwams_ml_app=self.webpackChunkwams_ml_app||[]).push([[179],{52:(ge,E,$)=>{"use strict";var F={};$.r(F),$.d(F,{browserFiles:()=>bse,browserHTTPRequest:()=>Cse,concatenateArrayBuffers:()=>_v,copyModel:()=>jre,decodeWeights:()=>n3,encodeWeights:()=>fI,fromMemory:()=>Ese,fromMemorySync:()=>O3,getLoadHandlers:()=>kre,getModelArtifactsForJSON:()=>yI,getModelArtifactsForJSONSync:()=>a3,getModelArtifactsInfoForJSON:()=>Um,getSaveHandlers:()=>u3,getWeightSpecs:()=>l3,http:()=>PI,isHTTPScheme:()=>MI,listModels:()=>zre,loadWeights:()=>wse,moveModel:()=>Gre,registerLoadRouter:()=>Are,registerSaveRouter:()=>Dre,removeModel:()=>Ure,weightsLoaderFactory:()=>D3,withSaveHandler:()=>Dse,withSaveHandlerSync:()=>Ase});var N={};$.r(N),$.d(N,{assertParamsValid:()=>LI,computeFlatOffset:()=>zI,computeOutShape:()=>VI,getNormalizedAxes:()=>Ose,isSliceContinous:()=>BI,maskToAxes:()=>Nse,parseSliceParams:()=>Tv,sliceInfo:()=>UI,startForAxis:()=>V3,startIndicesWithElidedDims:()=>F3,stopForAxis:()=>B3,stopIndicesWithElidedDims:()=>$3,stridesForAxis:()=>L3,stridesWithElidedDims:()=>R3});var R={};$.r(R),$.d(R,{conv2d:()=>BV,depthwiseConv2d:()=>eue,matMul:()=>DE});var k={};$.r(k),$.d(k,{collectGatherOpShapeInfo:()=>rD,computeOutShape:()=>wB,segOpComputeOptimalWindowSize:()=>vB});var S={};$.r(S),$.d(S,{ERF_A1:()=>jE,ERF_A2:()=>GE,ERF_A3:()=>WE,ERF_A4:()=>HE,ERF_A5:()=>qE,ERF_P:()=>UE,PARALLELIZE_THRESHOLD:()=>$E,RowPartitionType:()=>dr,SELU_SCALE:()=>Yv,SELU_SCALEALPHA:()=>Xv,applyActivation:()=>Hv,assertAndGetBroadcastShape:()=>Ht,assertAxesAreInnerMostDims:()=>ws,assertParamsConsistent:()=>FE,assignToTypedArray:()=>sB,axesAreInnerMostDims:()=>QI,calculateShapes:()=>Ec,checkEinsumDimSizes:()=>QE,checkPadOnDimRoundingMode:()=>js,combineLocations:()=>fV,combineRaggedTensorToTensorShapes:()=>ZV,complexWithEvenIndex:()=>nB,complexWithOddIndex:()=>rB,computeConv2DInfo:()=>ls,computeConv3DInfo:()=>cu,computeDefaultPad:()=>GI,computeDilation2DInfo:()=>jm,computeOptimalWindowSize:()=>Kv,computeOutAndReduceShapes:()=>us,computeOutShape:()=>Ra,computePool2DInfo:()=>vo,computePool3DInfo:()=>pl,convertConv2DDataFormat:()=>fl,decodeEinsumEquation:()=>YE,eitherStridesOrDilationsAreOne:()=>vs,expandShapeToKeepDim:()=>kr,exponent:()=>oB,exponents:()=>iB,fromStringArrayToUint8:()=>xB,fromUint8ToStringArray:()=>yl,getAxesPermutation:()=>ur,getBroadcastDims:()=>wh,getComplexWithIndex:()=>KE,getEinsumComputePath:()=>JE,getEinsumPermutation:()=>ZE,getFusedBiasGradient:()=>Wv,getFusedDyActivation:()=>Gv,getImageCenter:()=>LE,getInnerMostAxes:()=>Nr,getPermuted:()=>sg,getRaggedRank:()=>JV,getReductionAxes:()=>Xr,getReshaped:()=>rg,getReshapedPermuted:()=>ig,getRowPartitionTypesHelper:()=>QV,getSliceBeginCoords:()=>VE,getSliceSize:()=>BE,getSparseFillEmptyRowsIndicesDenseShapeMismatch:()=>uB,getSparseFillEmptyRowsNegativeIndexErrorMessage:()=>cB,getSparseFillEmptyRowsOutOfRangeIndexErrorMessage:()=>dB,getSparseReshapeEmptyTensorZeroOutputDimErrorMessage:()=>fB,getSparseReshapeInputOutputMismatchErrorMessage:()=>gB,getSparseReshapeInputOutputMultipleErrorMessage:()=>mB,getSparseReshapeMultipleNegativeOneOutputDimErrorMessage:()=>hB,getSparseReshapeNegativeOutputDimErrorMessage:()=>pB,getSparseSegmentReductionIndicesOutOfRangeErrorMessage:()=>_B,getSparseSegmentReductionNegativeSegmentIdsErrorMessage:()=>nD,getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage:()=>yB,getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage:()=>bB,getUndoAxesPermutation:()=>pu,isIdentityPermutation:()=>eD,log:()=>Kne,mergeRealAndImagArrays:()=>gl,prepareAndValidate:()=>zE,prepareSplitSize:()=>tD,segment_util:()=>k,shouldFuse:()=>qv,slice_util:()=>N,splitRealAndImagArrays:()=>tB,stridesOrDilationsArePositive:()=>xc,tupleValuesAreOne:()=>du,upcastType:()=>Ti,validateDefaultValueShape:()=>eB,validateInput:()=>_E,validateUpdateShape:()=>RV,warn:()=>Ui});var C={};$.r(C),$.d(C,{json:()=>Lfe});var v={};$.r(v),$.d(v,{json:()=>Vfe});var g={};$.r(g),$.d(g,{json:()=>Bfe});var h={};$.r(h),$.d(h,{json:()=>zfe});var l={};$.r(l),$.d(l,{json:()=>Ufe});var d={};$.r(d),$.d(d,{json:()=>jfe});var f={};$.r(f),$.d(f,{json:()=>Gfe});var b={};$.r(b),$.d(b,{json:()=>Wfe});var x={};$.r(x),$.d(x,{json:()=>Hfe});var D={};$.r(D),$.d(D,{json:()=>qfe});var P={};$.r(P),$.d(P,{json:()=>Kfe});var L={};$.r(L),$.d(L,{json:()=>Xfe});var B={};$.r(B),$.d(B,{json:()=>Yfe});var U={};$.r(U),$.d(U,{json:()=>Zfe});var W={};$.r(W),$.d(W,{json:()=>Qfe});var H={};$.r(H),$.d(H,{json:()=>Jfe});var re={};$.r(re),$.d(re,{json:()=>eme});var ue={};$.r(ue),$.d(ue,{json:()=>tme});var te={};$.r(te),$.d(te,{json:()=>nme});var se={};$.r(se),$.d(se,{OP_SCOPE_SUFFIX:()=>t3,abs:()=>Kr,acos:()=>U3,acosh:()=>j3,add:()=>Ze,addN:()=>Lse,all:()=>jI,any:()=>Sv,argMax:()=>xh,argMin:()=>G3,asin:()=>W3,asinh:()=>H3,atan:()=>q3,atan2:()=>K3,atanh:()=>X3,avgPool:()=>Cv,avgPool3d:()=>Y3,basicLSTMCell:()=>aie,batchNorm:()=>Hm,batchNorm2d:()=>Z3,batchNorm3d:()=>Q3,batchNorm4d:()=>J3,batchToSpaceND:()=>Iv,bincount:()=>eV,bitwiseAnd:()=>gie,booleanMaskAsync:()=>Mle,broadcastArgs:()=>bie,broadcastTo:()=>Ch,buffer:()=>tn,cast:()=>pt,ceil:()=>tV,clipByValue:()=>Si,clone:()=>cl,complex:()=>iu,concat:()=>Vr,concat1d:()=>nV,concat2d:()=>rV,concat3d:()=>sV,concat4d:()=>iV,conv1d:()=>HI,conv2d:()=>hu,conv2dTranspose:()=>KI,conv3d:()=>oV,conv3dTranspose:()=>lV,cos:()=>Ev,cosh:()=>XI,cosineWindow:()=>CE,cumprod:()=>Dv,cumsum:()=>YI,denseBincount:()=>ZI,depthToSpace:()=>uV,depthwiseConv2d:()=>qm,diag:()=>zie,dilation2d:()=>cV,div:()=>At,divNoNan:()=>dV,dot:()=>hV,dropout:()=>LV,einsum:()=>Kie,elu:()=>Km,enclosingPowerOfTwo:()=>VV,ensureShape:()=>Zie,equal:()=>Zo,erf:()=>pV,euclideanNorm:()=>gV,exp:()=>ji,expandDims:()=>ii,expm1:()=>yV,eye:()=>JI,fft:()=>Uv,fill:()=>vh,floor:()=>Zm,floorDiv:()=>AI,fused:()=>R,gather:()=>Qm,gatherND:()=>Gle,greater:()=>Ci,greaterEqual:()=>fu,ifft:()=>ng,imag:()=>Av,image:()=>Oa,inTopKAsync:()=>Kle,irfft:()=>yE,isFinite:()=>bV,isInf:()=>_V,isNaN:()=>vV,leakyRelu:()=>kv,less:()=>Jm,lessEqual:()=>Tc,linalg:()=>XV,linspace:()=>voe,localResponseNormalization:()=>wV,log:()=>Gi,log1p:()=>Nv,logSigmoid:()=>xV,logSoftmax:()=>eE,logSumExp:()=>tE,logicalAnd:()=>ka,logicalNot:()=>Ov,logicalOr:()=>nE,logicalXor:()=>TV,losses:()=>kce,lowerBound:()=>Moe,matMul:()=>ln,max:()=>wo,maxPool:()=>Mv,maxPool3d:()=>SV,maxPoolWithArgmax:()=>Loe,maximum:()=>hl,mean:()=>wr,meshgrid:()=>Boe,min:()=>Xm,minimum:()=>Sc,mirrorPad:()=>CV,mod:()=>IV,moments:()=>Pv,movingAverage:()=>$le,mul:()=>me,multiRNNCell:()=>Hoe,multinomial:()=>Koe,neg:()=>Zn,norm:()=>Ym,notEqual:()=>Eh,oneHot:()=>sE,ones:()=>Wi,onesLike:()=>Hi,op:()=>he,outerProduct:()=>Joe,pad:()=>mu,pad1d:()=>nae,pad2d:()=>sae,pad3d:()=>oae,pad4d:()=>lae,pool:()=>EV,pow:()=>uu,prelu:()=>$v,print:()=>y3,prod:()=>DV,raggedGather:()=>gae,raggedRange:()=>bae,raggedTensorToTensor:()=>vae,rand:()=>xae,randomGamma:()=>Aae,randomNormal:()=>aE,randomStandardNormal:()=>Oae,randomUniform:()=>Cc,randomUniformInt:()=>Pae,range:()=>Dh,real:()=>eg,reciprocal:()=>AV,relu:()=>Na,relu6:()=>lE,reshape:()=>be,reverse:()=>To,reverse1d:()=>Uae,reverse2d:()=>Gae,reverse3d:()=>Hae,reverse4d:()=>Kae,rfft:()=>jv,round:()=>uE,rsqrt:()=>cE,scalar:()=>Rt,scatterND:()=>Vle,searchSorted:()=>rE,selu:()=>dE,separableConv2d:()=>hE,setdiff1dAsync:()=>ele,sigmoid:()=>Aa,sign:()=>kV,signal:()=>Ace,sin:()=>fE,sinh:()=>mE,slice:()=>gn,slice1d:()=>Vv,slice2d:()=>gE,slice3d:()=>Bv,slice4d:()=>tg,softmax:()=>zv,softplus:()=>Ih,spaceToBatchND:()=>Fv,sparse:()=>Nce,sparseToDense:()=>Ule,spectral:()=>Dce,split:()=>Ii,sqrt:()=>Ns,square:()=>zn,squaredDifference:()=>bE,squeeze:()=>Ic,stack:()=>qi,step:()=>Ah,stridedSlice:()=>NV,string:()=>Oce,sub:()=>vt,sum:()=>Tt,tan:()=>OV,tanh:()=>Sh,tensor:()=>Yo,tensor1d:()=>oi,tensor2d:()=>kh,tensor3d:()=>vle,tensor4d:()=>wle,tensor5d:()=>xle,tensor6d:()=>Tle,tensorScatterUpdate:()=>Cle,tile:()=>xo,topk:()=>MV,transpose:()=>yn,truncatedNormal:()=>vE,unique:()=>PV,unsortedSegmentSum:()=>wE,unstack:()=>So,upperBound:()=>Nle,variable:()=>FV,where:()=>Os,whereAsync:()=>$V,zeros:()=>Yr,zerosLike:()=>mn});var Y={};function X(n){return"function"==typeof n}function we(n){const e=n(r=>{Error.call(r),r.stack=(new Error).stack});return e.prototype=Object.create(Error.prototype),e.prototype.constructor=e,e}$.r(Y),$.d(Y,{addImpl:()=>Rz,bincountImpl:()=>yA,bincountReduceImpl:()=>Vz,castImpl:()=>Oz,ceilImpl:()=>Bz,concatImpl:()=>zz,equalImpl:()=>Gz,expImpl:()=>Hz,expm1Impl:()=>Kz,floorImpl:()=>Zz,gatherNdImpl:()=>Qz,gatherV2Impl:()=>Jz,greaterEqualImpl:()=>tU,greaterImpl:()=>eU,lessEqualImpl:()=>rU,lessImpl:()=>nU,linSpaceImpl:()=>sU,logImpl:()=>iU,maxImpl:()=>oU,maximumImpl:()=>lU,minimumImpl:()=>uU,multiplyImpl:()=>bA,negImpl:()=>dU,notEqualImpl:()=>hU,prodImpl:()=>gU,raggedGatherImpl:()=>bU,raggedRangeImpl:()=>vU,raggedTensorToTensorImpl:()=>TU,rangeImpl:()=>SU,rsqrtImpl:()=>CU,scatterImpl:()=>Lc,sigmoidImpl:()=>Ege,simpleAbsImpl:()=>Pz,sliceImpl:()=>Lz,sparseFillEmptyRowsImpl:()=>EU,sparseReshapeImpl:()=>DU,sparseSegmentReductionImpl:()=>SA,sqrtImpl:()=>J0e,staticRegexReplaceImpl:()=>AU,stridedSliceImpl:()=>kU,stringNGramsImpl:()=>NU,stringSplitImpl:()=>OU,stringToHashBucketFastImpl:()=>RU,subImpl:()=>Xz,tileImpl:()=>MU,topKImpl:()=>FU,transposeImpl:()=>mA,uniqueImpl:()=>LU});const K=we(n=>function(e){n(this),this.message=e?`${e.length} errors occurred during unsubscription:\n${e.map((r,s)=>`${s+1}) ${r.toString()}`).join("\n  ")}`:"",this.name="UnsubscriptionError",this.errors=e});function ie(n,t){if(n){const e=n.indexOf(t);0<=e&&n.splice(e,1)}}class ce{constructor(t){this.initialTeardown=t,this.closed=!1,this._parentage=null,this._finalizers=null}unsubscribe(){let t;if(!this.closed){this.closed=!0;const{_parentage:e}=this;if(e)if(this._parentage=null,Array.isArray(e))for(const i of e)i.remove(this);else e.remove(this);const{initialTeardown:r}=this;if(X(r))try{r()}catch(i){t=i instanceof K?i.errors:[i]}const{_finalizers:s}=this;if(s){this._finalizers=null;for(const i of s)try{at(i)}catch(o){t=t??[],o instanceof K?t=[...t,...o.errors]:t.push(o)}}if(t)throw new K(t)}}add(t){var e;if(t&&t!==this)if(this.closed)at(t);else{if(t instanceof ce){if(t.closed||t._hasParent(this))return;t._addParent(this)}(this._finalizers=null!==(e=this._finalizers)&&void 0!==e?e:[]).push(t)}}_hasParent(t){const{_parentage:e}=this;return e===t||Array.isArray(e)&&e.includes(t)}_addParent(t){const{_parentage:e}=this;this._parentage=Array.isArray(e)?(e.push(t),e):e?[e,t]:t}_removeParent(t){const{_parentage:e}=this;e===t?this._parentage=null:Array.isArray(e)&&ie(e,t)}remove(t){const{_finalizers:e}=this;e&&ie(e,t),t instanceof ce&&t._removeParent(this)}}ce.EMPTY=(()=>{const n=new ce;return n.closed=!0,n})();const qe=ce.EMPTY;function Be(n){return n instanceof ce||n&&"closed"in n&&X(n.remove)&&X(n.add)&&X(n.unsubscribe)}function at(n){X(n)?n():n.unsubscribe()}const rt={onUnhandledError:null,onStoppedNotification:null,Promise:void 0,useDeprecatedSynchronousErrorHandling:!1,useDeprecatedNextContext:!1},ot={setTimeout(n,t,...e){const{delegate:r}=ot;return r?.setTimeout?r.setTimeout(n,t,...e):setTimeout(n,t,...e)},clearTimeout(n){const{delegate:t}=ot;return(t?.clearTimeout||clearTimeout)(n)},delegate:void 0};function bt(n){ot.setTimeout(()=>{const{onUnhandledError:t}=rt;if(!t)throw n;t(n)})}function wt(){}const Mt=or("C",void 0,void 0);function or(n,t,e){return{kind:n,value:t,error:e}}let Tr=null;function Cs(n){if(rt.useDeprecatedSynchronousErrorHandling){const t=!Tr;if(t&&(Tr={errorThrown:!1,error:null}),n(),t){const{errorThrown:e,error:r}=Tr;if(Tr=null,e)throw r}}else n()}class Br extends ce{constructor(t){super(),this.isStopped=!1,t?(this.destination=t,Be(t)&&t.add(this)):this.destination=Ms}static create(t,e,r){return new Pr(t,e,r)}next(t){this.isStopped?Oi(function _n(n){return or("N",n,void 0)}(t),this):this._next(t)}error(t){this.isStopped?Oi(function un(n){return or("E",void 0,n)}(t),this):(this.isStopped=!0,this._error(t))}complete(){this.isStopped?Oi(Mt,this):(this.isStopped=!0,this._complete())}unsubscribe(){this.closed||(this.isStopped=!0,super.unsubscribe(),this.destination=null)}_next(t){this.destination.next(t)}_error(t){try{this.destination.error(t)}finally{this.unsubscribe()}}_complete(){try{this.destination.complete()}finally{this.unsubscribe()}}}const Ni=Function.prototype.bind;function Cn(n,t){return Ni.call(n,t)}class Is{constructor(t){this.partialObserver=t}next(t){const{partialObserver:e}=this;if(e.next)try{e.next(t)}catch(r){zr(r)}}error(t){const{partialObserver:e}=this;if(e.error)try{e.error(t)}catch(r){zr(r)}else zr(t)}complete(){const{partialObserver:t}=this;if(t.complete)try{t.complete()}catch(e){zr(e)}}}class Pr extends Br{constructor(t,e,r){let s;if(super(),X(t)||!t)s={next:t??void 0,error:e??void 0,complete:r??void 0};else{let i;this&&rt.useDeprecatedNextContext?(i=Object.create(t),i.unsubscribe=()=>this.unsubscribe(),s={next:t.next&&Cn(t.next,i),error:t.error&&Cn(t.error,i),complete:t.complete&&Cn(t.complete,i)}):s=t}this.destination=new Is(s)}}function zr(n){rt.useDeprecatedSynchronousErrorHandling?function ki(n){rt.useDeprecatedSynchronousErrorHandling&&Tr&&(Tr.errorThrown=!0,Tr.error=n)}(n):bt(n)}function Oi(n,t){const{onStoppedNotification:e}=rt;e&&ot.setTimeout(()=>e(n,t))}const Ms={closed:!0,next:wt,error:function Es(n){throw n},complete:wt},no="function"==typeof Symbol&&Symbol.observable||"@@observable";function Ur(n){return n}function Wa(n){return 0===n.length?Ur:1===n.length?n[0]:function(e){return n.reduce((r,s)=>s(r),e)}}let Dn=(()=>{class n{constructor(e){e&&(this._subscribe=e)}lift(e){const r=new n;return r.source=this,r.operator=e,r}subscribe(e,r,s){const i=function El(n){return n&&n instanceof Br||function Ha(n){return n&&X(n.next)&&X(n.error)&&X(n.complete)}(n)&&Be(n)}(e)?e:new Pr(e,r,s);return Cs(()=>{const{operator:o,source:a}=this;i.add(o?o.call(i,a):a?this._subscribe(i):this._trySubscribe(i))}),i}_trySubscribe(e){try{return this._subscribe(e)}catch(r){e.error(r)}}forEach(e,r){return new(r=zu(r))((s,i)=>{const o=new Pr({next:a=>{try{e(a)}catch(u){i(u),o.unsubscribe()}},error:i,complete:s});this.subscribe(o)})}_subscribe(e){var r;return null===(r=this.source)||void 0===r?void 0:r.subscribe(e)}[no](){return this}pipe(...e){return Wa(e)(this)}toPromise(e){return new(e=zu(e))((r,s)=>{let i;this.subscribe(o=>i=o,o=>s(o),()=>r(i))})}}return n.create=t=>new n(t),n})();function zu(n){var t;return null!==(t=n??rt.Promise)&&void 0!==t?t:Promise}const Uu=we(n=>function(){n(this),this.name="ObjectUnsubscribedError",this.message="object unsubscribed"});let vn=(()=>{class n extends Dn{constructor(){super(),this.closed=!1,this.currentObservers=null,this.observers=[],this.isStopped=!1,this.hasError=!1,this.thrownError=null}lift(e){const r=new ju(this,this);return r.operator=e,r}_throwIfClosed(){if(this.closed)throw new Uu}next(e){Cs(()=>{if(this._throwIfClosed(),!this.isStopped){this.currentObservers||(this.currentObservers=Array.from(this.observers));for(const r of this.currentObservers)r.next(e)}})}error(e){Cs(()=>{if(this._throwIfClosed(),!this.isStopped){this.hasError=this.isStopped=!0,this.thrownError=e;const{observers:r}=this;for(;r.length;)r.shift().error(e)}})}complete(){Cs(()=>{if(this._throwIfClosed(),!this.isStopped){this.isStopped=!0;const{observers:e}=this;for(;e.length;)e.shift().complete()}})}unsubscribe(){this.isStopped=this.closed=!0,this.observers=this.currentObservers=null}get observed(){var e;return(null===(e=this.observers)||void 0===e?void 0:e.length)>0}_trySubscribe(e){return this._throwIfClosed(),super._trySubscribe(e)}_subscribe(e){return this._throwIfClosed(),this._checkFinalizedStatuses(e),this._innerSubscribe(e)}_innerSubscribe(e){const{hasError:r,isStopped:s,observers:i}=this;return r||s?qe:(this.currentObservers=null,i.push(e),new ce(()=>{this.currentObservers=null,ie(i,e)}))}_checkFinalizedStatuses(e){const{hasError:r,thrownError:s,isStopped:i}=this;r?e.error(s):i&&e.complete()}asObservable(){const e=new Dn;return e.source=this,e}}return n.create=(t,e)=>new ju(t,e),n})();class ju extends vn{constructor(t,e){super(),this.destination=t,this.source=e}next(t){var e,r;null===(r=null===(e=this.destination)||void 0===e?void 0:e.next)||void 0===r||r.call(e,t)}error(t){var e,r;null===(r=null===(e=this.destination)||void 0===e?void 0:e.error)||void 0===r||r.call(e,t)}complete(){var t,e;null===(e=null===(t=this.destination)||void 0===t?void 0:t.complete)||void 0===e||e.call(t)}_subscribe(t){var e,r;return null!==(r=null===(e=this.source)||void 0===e?void 0:e.subscribe(t))&&void 0!==r?r:qe}}function Dl(n){return X(n?.lift)}function An(n){return t=>{if(Dl(t))return t.lift(function(e){try{return n(e,this)}catch(r){this.error(r)}});throw new TypeError("Unable to lift unknown Observable type")}}function Pn(n,t,e,r,s){return new Al(n,t,e,r,s)}class Al extends Br{constructor(t,e,r,s,i,o){super(t),this.onFinalize=i,this.shouldUnsubscribe=o,this._next=e?function(a){try{e(a)}catch(u){t.error(u)}}:super._next,this._error=s?function(a){try{s(a)}catch(u){t.error(u)}finally{this.unsubscribe()}}:super._error,this._complete=r?function(){try{r()}catch(a){t.error(a)}finally{this.unsubscribe()}}:super._complete}unsubscribe(){var t;if(!this.shouldUnsubscribe||this.shouldUnsubscribe()){const{closed:e}=this;super.unsubscribe(),!e&&(null===(t=this.onFinalize)||void 0===t||t.call(this))}}}function ct(n,t){return An((e,r)=>{let s=0;e.subscribe(Pn(r,i=>{r.next(n.call(t,i,s++))}))})}function aa(n){return this instanceof aa?(this.v=n,this):new aa(n)}function ap(n){if(!Symbol.asyncIterator)throw new TypeError("Symbol.asyncIterator is not defined.");var e,t=n[Symbol.asyncIterator];return t?t.call(n):(n=function Ue(n){var t="function"==typeof Symbol&&Symbol.iterator,e=t&&n[t],r=0;if(e)return e.call(n);if(n&&"number"==typeof n.length)return{next:function(){return n&&r>=n.length&&(n=void 0),{value:n&&n[r++],done:!n}}};throw new TypeError(t?"Object is not iterable.":"Symbol.iterator is not defined.")}(n),e={},r("next"),r("throw"),r("return"),e[Symbol.asyncIterator]=function(){return this},e);function r(i){e[i]=n[i]&&function(o){return new Promise(function(a,u){!function s(i,o,a,u){Promise.resolve(u).then(function(c){i({value:c,done:a})},o)}(a,u,(o=n[i](o)).done,o.value)})}}}const up=n=>n&&"number"==typeof n.length&&"function"!=typeof n;function jn(n){return X(n?.then)}function rd(n){return X(n[no])}function sd(n){return Symbol.asyncIterator&&X(n?.[Symbol.asyncIterator])}function id(n){return new TypeError(`You provided ${null!==n&&"object"==typeof n?"an invalid object":`'${n}'`} where a stream was expected. You can provide an Observable, Promise, ReadableStream, Array, AsyncIterable, or Iterable.`)}const cp=function Zg(){return"function"==typeof Symbol&&Symbol.iterator?Symbol.iterator:"@@iterator"}();function dp(n){return X(n?.[cp])}function hp(n){return function Yg(n,t,e){if(!Symbol.asyncIterator)throw new TypeError("Symbol.asyncIterator is not defined.");var s,r=e.apply(n,t||[]),i=[];return s={},o("next"),o("throw"),o("return"),s[Symbol.asyncIterator]=function(){return this},s;function o(y){r[y]&&(s[y]=function(_){return new Promise(function(w,T){i.push([y,_,w,T])>1||a(y,_)})})}function a(y,_){try{!function u(y){y.value instanceof aa?Promise.resolve(y.value.v).then(c,p):m(i[0][2],y)}(r[y](_))}catch(w){m(i[0][3],w)}}function c(y){a("next",y)}function p(y){a("throw",y)}function m(y,_){y(_),i.shift(),i.length&&a(i[0][0],i[0][1])}}(this,arguments,function*(){const e=n.getReader();try{for(;;){const{value:r,done:s}=yield aa(e.read());if(s)return yield aa(void 0);yield yield aa(r)}}finally{e.releaseLock()}})}function pp(n){return X(n?.getReader)}function fs(n){if(n instanceof Dn)return n;if(null!=n){if(rd(n))return function qw(n){return new Dn(t=>{const e=n[no]();if(X(e.subscribe))return e.subscribe(t);throw new TypeError("Provided object does not correctly implement Symbol.observable")})}(n);if(up(n))return function Qg(n){return new Dn(t=>{for(let e=0;e<n.length&&!t.closed;e++)t.next(n[e]);t.complete()})}(n);if(jn(n))return function Jg(n){return new Dn(t=>{n.then(e=>{t.closed||(t.next(e),t.complete())},e=>t.error(e)).then(null,bt)})}(n);if(sd(n))return fp(n);if(dp(n))return function ey(n){return new Dn(t=>{for(const e of n)if(t.next(e),t.closed)return;t.complete()})}(n);if(pp(n))return function Kw(n){return fp(hp(n))}(n)}throw id(n)}function fp(n){return new Dn(t=>{(function ty(n,t){var e,r,s,i;return function hs(n,t,e,r){return new(e||(e=Promise))(function(i,o){function a(p){try{c(r.next(p))}catch(m){o(m)}}function u(p){try{c(r.throw(p))}catch(m){o(m)}}function c(p){p.done?i(p.value):function s(i){return i instanceof e?i:new e(function(o){o(i)})}(p.value).then(a,u)}c((r=r.apply(n,t||[])).next())})}(this,void 0,void 0,function*(){try{for(e=ap(n);!(r=yield e.next()).done;)if(t.next(r.value),t.closed)return}catch(o){s={error:o}}finally{try{r&&!r.done&&(i=e.return)&&(yield i.call(e))}finally{if(s)throw s.error}}t.complete()})})(n,t).catch(e=>t.error(e))})}function $o(n,t,e,r=0,s=!1){const i=t.schedule(function(){e(),s?n.add(this.schedule(null,r)):this.unsubscribe()},r);if(n.add(i),!s)return i}function fr(n,t,e=1/0){return X(t)?fr((r,s)=>ct((i,o)=>t(r,i,s,o))(fs(n(r,s))),e):("number"==typeof t&&(e=t),An((r,s)=>function Xw(n,t,e,r,s,i,o,a){const u=[];let c=0,p=0,m=!1;const y=()=>{m&&!u.length&&!c&&t.complete()},_=T=>c<r?w(T):u.push(T),w=T=>{i&&t.next(T),c++;let I=!1;fs(e(T,p++)).subscribe(Pn(t,O=>{s?.(O),i?_(O):t.next(O)},()=>{I=!0},void 0,()=>{if(I)try{for(c--;u.length&&c<r;){const O=u.shift();o?$o(t,o,()=>w(O)):w(O)}y()}catch(O){t.error(O)}}))};return n.subscribe(Pn(t,_,()=>{m=!0,y()})),()=>{a?.()}}(r,s,n,e)))}function qa(n=1/0){return fr(Ur,n)}const Ri=new Dn(n=>n.complete());function od(n){return n&&X(n.schedule)}function Gu(n){return n[n.length-1]}function gp(n){return X(Gu(n))?n.pop():void 0}function Ol(n){return od(Gu(n))?n.pop():void 0}function ad(n,t=0){return An((e,r)=>{e.subscribe(Pn(r,s=>$o(r,n,()=>r.next(s),t),()=>$o(r,n,()=>r.complete(),t),s=>$o(r,n,()=>r.error(s),t)))})}function Wu(n,t=0){return An((e,r)=>{r.add(n.schedule(()=>e.subscribe(r),t))})}function ye(n,t){if(!n)throw new Error("Iterable cannot be null");return new Dn(e=>{$o(e,t,()=>{const r=n[Symbol.asyncIterator]();$o(e,t,()=>{r.next().then(s=>{s.done?e.complete():e.next(s.value)})},0,!0)})})}function nt(n,t){return t?function ze(n,t){if(null!=n){if(rd(n))return function yp(n,t){return fs(n).pipe(Wu(t),ad(t))}(n,t);if(up(n))return function q(n,t){return new Dn(e=>{let r=0;return t.schedule(function(){r===n.length?e.complete():(e.next(n[r++]),e.closed||this.schedule())})})}(n,t);if(jn(n))return function sy(n,t){return fs(n).pipe(Wu(t),ad(t))}(n,t);if(sd(n))return ye(n,t);if(dp(n))return function ae(n,t){return new Dn(e=>{let r;return $o(e,t,()=>{r=n[cp](),$o(e,t,()=>{let s,i;try{({value:s,done:i}=r.next())}catch(o){return void e.error(o)}i?e.complete():e.next(s)},0,!0)}),()=>X(r?.return)&&r.return()})}(n,t);if(pp(n))return function Ne(n,t){return ye(hp(n),t)}(n,t)}throw id(n)}(n,t):fs(n)}function Dt(...n){const t=Ol(n),e=function ry(n,t){return"number"==typeof Gu(n)?n.pop():t}(n,1/0),r=n;return r.length?1===r.length?fs(r[0]):qa(e)(nt(r,t)):Ri}function Ps(n,t,...e){if(!0===t)return void n();if(!1===t)return;const r=new Pr({next:()=>{r.unsubscribe(),n()}});return fs(t(...e)).subscribe(r)}function Ut(n){for(let t in n)if(n[t]===Ut)return t;throw Error("Could not find renamed property on target object.")}function ms(n,t){for(const e in t)t.hasOwnProperty(e)&&!n.hasOwnProperty(e)&&(n[e]=t[e])}function Sr(n){if("string"==typeof n)return n;if(Array.isArray(n))return"["+n.map(Sr).join(", ")+"]";if(null==n)return""+n;if(n.overriddenName)return`${n.overriddenName}`;if(n.name)return`${n.name}`;const t=n.toString();if(null==t)return""+t;const e=t.indexOf("\n");return-1===e?t:t.substring(0,e)}function ld(n,t){return null==n||""===n?null===t?"":t:null==t||""===t?n:n+" "+t}const Ge=Ut({__forward_ref__:Ut});function Et(n){return n.__forward_ref__=Et,n.toString=function(){return Sr(this())},n}function _t(n){return Lo(n)?n():n}function Lo(n){return"function"==typeof n&&n.hasOwnProperty(Ge)&&n.__forward_ref__===Et}function ud(n){return n&&!!n.\u0275providers}const nN="https://g.co/ng/security#xss";class je extends Error{constructor(t,e){super(function Yw(n,t){return`NG0${Math.abs(n)}${t?": "+t:""}`}(t,e)),this.code=t}}function Wt(n){return"string"==typeof n?n:null==n?"":String(n)}function iy(n,t){throw new je(-201,!1)}function ro(n,t){null==n&&function Nn(n,t,e,r){throw new Error(`ASSERTION ERROR: ${n}`+(null==r?"":` [Expected=> ${e} ${r} ${t} <=Actual]`))}(t,n,null,"!=")}function ht(n){return{token:n.token,providedIn:n.providedIn||null,factory:n.factory,value:void 0}}function Jn(n){return{providers:n.providers||[],imports:n.imports||[]}}function oy(n){return rN(n,ay)||rN(n,iN)}function rN(n,t){return n.hasOwnProperty(t)?n[t]:null}function sN(n){return n&&(n.hasOwnProperty(Zw)||n.hasOwnProperty(mH))?n[Zw]:null}const ay=Ut({\u0275prov:Ut}),Zw=Ut({\u0275inj:Ut}),iN=Ut({ngInjectableDef:Ut}),mH=Ut({ngInjectorDef:Ut});var $t=(()=>(($t=$t||{})[$t.Default=0]="Default",$t[$t.Host=1]="Host",$t[$t.Self=2]="Self",$t[$t.SkipSelf=4]="SkipSelf",$t[$t.Optional=8]="Optional",$t))();let Qw;function hi(n){const t=Qw;return Qw=n,t}function aN(n,t,e){const r=oy(n);return r&&"root"==r.providedIn?void 0===r.value?r.value=r.factory():r.value:e&$t.Optional?null:void 0!==t?t:void iy(Sr(n))}const Xn=(()=>typeof globalThis<"u"&&globalThis||typeof global<"u"&&global||typeof window<"u"&&window||typeof self<"u"&&typeof WorkerGlobalScope<"u"&&self instanceof WorkerGlobalScope&&self)(),bp={},Jw="__NG_DI_FLAG__",ly="ngTempTokenPath",yH=/\n/gm,lN="__source";let cd;function Ml(n){const t=cd;return cd=n,t}function vH(n,t=$t.Default){if(void 0===cd)throw new je(-203,!1);return null===cd?aN(n,void 0,t):cd.get(n,t&$t.Optional?null:void 0,t)}function Le(n,t=$t.Default){return(function oN(){return Qw}()||vH)(_t(n),t)}function Ct(n,t=$t.Default){return Le(n,uy(t))}function uy(n){return typeof n>"u"||"number"==typeof n?n:0|(n.optional&&8)|(n.host&&1)|(n.self&&2)|(n.skipSelf&&4)}function ex(n){const t=[];for(let e=0;e<n.length;e++){const r=_t(n[e]);if(Array.isArray(r)){if(0===r.length)throw new je(900,!1);let s,i=$t.Default;for(let o=0;o<r.length;o++){const a=r[o],u=wH(a);"number"==typeof u?-1===u?s=a.token:i|=u:s=a}t.push(Le(s,i))}else t.push(Le(r))}return t}function _p(n,t){return n[Jw]=t,n.prototype[Jw]=t,n}function wH(n){return n[Jw]}function Ka(n){return{toString:n}.toString()}var la=(()=>((la=la||{})[la.OnPush=0]="OnPush",la[la.Default=1]="Default",la))(),pi=(()=>{return(n=pi||(pi={}))[n.Emulated=0]="Emulated",n[n.None=2]="None",n[n.ShadowDom=3]="ShadowDom",pi;var n})();const Xa={},In=[],cy=Ut({\u0275cmp:Ut}),tx=Ut({\u0275dir:Ut}),nx=Ut({\u0275pipe:Ut}),cN=Ut({\u0275mod:Ut}),Ya=Ut({\u0275fac:Ut}),vp=Ut({__NG_ELEMENT_ID__:Ut}),dN=Ut({__NG_ENV_ID__:Ut});function hN(n,t,e){let r=n.length;for(;;){const s=n.indexOf(t,e);if(-1===s)return s;if(0===s||n.charCodeAt(s-1)<=32){const i=t.length;if(s+i===r||n.charCodeAt(s+i)<=32)return s}e=s+1}}function rx(n,t,e){let r=0;for(;r<e.length;){const s=e[r];if("number"==typeof s){if(0!==s)break;r++;const i=e[r++],o=e[r++],a=e[r++];n.setAttribute(t,o,a,i)}else{const i=s,o=e[++r];fN(i)?n.setProperty(t,i,o):n.setAttribute(t,i,o),r++}}return r}function pN(n){return 3===n||4===n||6===n}function fN(n){return 64===n.charCodeAt(0)}function wp(n,t){if(null!==t&&0!==t.length)if(null===n||0===n.length)n=t.slice();else{let e=-1;for(let r=0;r<t.length;r++){const s=t[r];"number"==typeof s?e=s:0===e||mN(n,e,s,null,-1===e||2===e?t[++r]:null)}}return n}function mN(n,t,e,r,s){let i=0,o=n.length;if(-1===t)o=-1;else for(;i<n.length;){const a=n[i++];if("number"==typeof a){if(a===t){o=-1;break}if(a>t){o=i-1;break}}}for(;i<n.length;){const a=n[i];if("number"==typeof a)break;if(a===e){if(null===r)return void(null!==s&&(n[i+1]=s));if(r===n[i+1])return void(n[i+2]=s)}i++,null!==r&&i++,null!==s&&i++}-1!==o&&(n.splice(o,0,t),i=o+1),n.splice(i++,0,e),null!==r&&n.splice(i++,0,r),null!==s&&n.splice(i++,0,s)}const gN="ng-template";function SH(n,t,e){let r=0,s=!0;for(;r<n.length;){let i=n[r++];if("string"==typeof i&&s){const o=n[r++];if(e&&"class"===i&&-1!==hN(o.toLowerCase(),t,0))return!0}else{if(1===i){for(;r<n.length&&"string"==typeof(i=n[r++]);)if(i.toLowerCase()===t)return!0;return!1}"number"==typeof i&&(s=!1)}}return!1}function yN(n){return 4===n.type&&n.value!==gN}function CH(n,t,e){return t===(4!==n.type||e?n.value:gN)}function IH(n,t,e){let r=4;const s=n.attrs||[],i=function AH(n){for(let t=0;t<n.length;t++)if(pN(n[t]))return t;return n.length}(s);let o=!1;for(let a=0;a<t.length;a++){const u=t[a];if("number"!=typeof u){if(!o)if(4&r){if(r=2|1&r,""!==u&&!CH(n,u,e)||""===u&&1===t.length){if(Vo(r))return!1;o=!0}}else{const c=8&r?u:t[++a];if(8&r&&null!==n.attrs){if(!SH(n.attrs,c,e)){if(Vo(r))return!1;o=!0}continue}const m=EH(8&r?"class":u,s,yN(n),e);if(-1===m){if(Vo(r))return!1;o=!0;continue}if(""!==c){let y;y=m>i?"":s[m+1].toLowerCase();const _=8&r?y:null;if(_&&-1!==hN(_,c,0)||2&r&&c!==y){if(Vo(r))return!1;o=!0}}}}else{if(!o&&!Vo(r)&&!Vo(u))return!1;if(o&&Vo(u))continue;o=!1,r=u|1&r}}return Vo(r)||o}function Vo(n){return 0==(1&n)}function EH(n,t,e,r){if(null===t)return-1;let s=0;if(r||!e){let i=!1;for(;s<t.length;){const o=t[s];if(o===n)return s;if(3===o||6===o)i=!0;else{if(1===o||2===o){let a=t[++s];for(;"string"==typeof a;)a=t[++s];continue}if(4===o)break;if(0===o){s+=4;continue}}s+=i?1:2}return-1}return function kH(n,t){let e=n.indexOf(4);if(e>-1)for(e++;e<n.length;){const r=n[e];if("number"==typeof r)return-1;if(r===t)return e;e++}return-1}(t,n)}function bN(n,t,e=!1){for(let r=0;r<t.length;r++)if(IH(n,t[r],e))return!0;return!1}function NH(n,t){e:for(let e=0;e<t.length;e++){const r=t[e];if(n.length===r.length){for(let s=0;s<n.length;s++)if(n[s]!==r[s])continue e;return!0}}return!1}function _N(n,t){return n?":not("+t.trim()+")":t}function OH(n){let t=n[0],e=1,r=2,s="",i=!1;for(;e<n.length;){let o=n[e];if("string"==typeof o)if(2&r){const a=n[++e];s+="["+o+(a.length>0?'="'+a+'"':"")+"]"}else 8&r?s+="."+o:4&r&&(s+=" "+o);else""!==s&&!Vo(o)&&(t+=_N(i,s),s=""),r=o,i=i||!Vo(r);e++}return""!==s&&(t+=_N(i,s)),t}function Bo(n){return Ka(()=>{const t=wN(n),e={...t,decls:n.decls,vars:n.vars,template:n.template,consts:n.consts||null,ngContentSelectors:n.ngContentSelectors,onPush:n.changeDetection===la.OnPush,directiveDefs:null,pipeDefs:null,dependencies:t.standalone&&n.dependencies||null,getStandaloneInjector:null,data:n.data||{},encapsulation:n.encapsulation||pi.Emulated,styles:n.styles||In,_:null,schemas:n.schemas||null,tView:null,id:""};xN(e);const r=n.dependencies;return e.directiveDefs=dy(r,!1),e.pipeDefs=dy(r,!0),e.id=function BH(n){let t=0;const e=[n.selectors,n.ngContentSelectors,n.hostVars,n.hostAttrs,n.consts,n.vars,n.decls,n.encapsulation,n.standalone,Object.getOwnPropertyNames(n.type.prototype),!!n.contentQueries,!!n.viewQuery].join("|");for(const s of e)t=Math.imul(31,t)+s.charCodeAt(0)<<0;return t+=2147483648,"c"+t}(e),e})}function FH(n){return En(n)||Fs(n)}function $H(n){return null!==n}function ar(n){return Ka(()=>({type:n.type,bootstrap:n.bootstrap||In,declarations:n.declarations||In,imports:n.imports||In,exports:n.exports||In,transitiveCompileScopes:null,schemas:n.schemas||null,id:n.id||null}))}function vN(n,t){if(null==n)return Xa;const e={};for(const r in n)if(n.hasOwnProperty(r)){let s=n[r],i=s;Array.isArray(s)&&(i=s[1],s=s[0]),e[s]=r,t&&(t[s]=i)}return e}function Pt(n){return Ka(()=>{const t=wN(n);return xN(t),t})}function fi(n){return{type:n.type,name:n.name,factory:null,pure:!1!==n.pure,standalone:!0===n.standalone,onDestroy:n.type.prototype.ngOnDestroy||null}}function En(n){return n[cy]||null}function Fs(n){return n[tx]||null}function mi(n){return n[nx]||null}function Pi(n,t){const e=n[cN]||null;if(!e&&!0===t)throw new Error(`Type ${Sr(n)} does not have '\u0275mod' property.`);return e}function wN(n){const t={};return{type:n.type,providersResolver:null,factory:null,hostBindings:n.hostBindings||null,hostVars:n.hostVars||0,hostAttrs:n.hostAttrs||null,contentQueries:n.contentQueries||null,declaredInputs:t,exportAs:n.exportAs||null,standalone:!0===n.standalone,selectors:n.selectors||In,viewQuery:n.viewQuery||null,features:n.features||null,setInput:null,findHostDirectiveDefs:null,hostDirectives:null,inputs:vN(n.inputs,t),outputs:vN(n.outputs)}}function xN(n){n.features?.forEach(t=>t(n))}function dy(n,t){if(!n)return null;const e=t?mi:FH;return()=>("function"==typeof n?n():n).map(r=>e(r)).filter($H)}const gs=0,mt=1,Jt=2,gr=3,zo=4,Hu=5,$s=6,hd=7,Cr=8,pd=9,qu=10,Kt=11,xp=12,TN=13,fd=14,jr=15,Tp=16,md=17,ua=18,Sp=19,SN=20,Pl=21,Za=22,hy=23,py=24,fn=25,sx=1,CN=2,ca=7,fy=8,gd=9,Ds=11;function Fi(n){return Array.isArray(n)&&"object"==typeof n[sx]}function $i(n){return Array.isArray(n)&&!0===n[sx]}function ix(n){return 0!=(4&n.flags)}function Ku(n){return n.componentOffset>-1}function my(n){return 1==(1&n.flags)}function Uo(n){return!!n.template}function ox(n){return 0!=(512&n[Jt])}function Xu(n,t){return n.hasOwnProperty(Ya)?n[Ya]:null}let WH=Xn.WeakRef??class GH{constructor(t){this.ref=t}deref(){return this.ref}},qH=0,da=null,gy=!1;function ys(n){const t=da;return da=n,t}class kN{constructor(){this.id=qH++,this.ref=function HH(n){return new WH(n)}(this),this.producers=new Map,this.consumers=new Map,this.trackingVersion=0,this.valueVersion=0}consumerPollProducersForChange(){for(const[t,e]of this.producers){const r=e.producerNode.deref();if(void 0!==r&&e.atTrackingVersion===this.trackingVersion){if(r.producerPollStatus(e.seenValueVersion))return!0}else this.producers.delete(t),r?.consumers.delete(this.id)}return!1}producerMayHaveChanged(){const t=gy;gy=!0;try{for(const[e,r]of this.consumers){const s=r.consumerNode.deref();void 0!==s&&s.trackingVersion===r.atTrackingVersion?s.onConsumerDependencyMayHaveChanged():(this.consumers.delete(e),s?.producers.delete(this.id))}}finally{gy=t}}producerAccessed(){if(gy)throw new Error("");if(null===da)return;let t=da.producers.get(this.id);void 0===t?(t={consumerNode:da.ref,producerNode:this.ref,seenValueVersion:this.valueVersion,atTrackingVersion:da.trackingVersion},da.producers.set(this.id,t),this.consumers.set(da.id,t)):(t.seenValueVersion=this.valueVersion,t.atTrackingVersion=da.trackingVersion)}get hasProducers(){return this.producers.size>0}get producerUpdatesAllowed(){return!1!==da?.consumerAllowSignalWrites}producerPollStatus(t){return this.valueVersion!==t||(this.onProducerUpdateValueVersion(),this.valueVersion!==t)}}let NN=null;const ON=()=>{};class ZH extends kN{constructor(t,e,r){super(),this.watch=t,this.schedule=e,this.dirty=!1,this.cleanupFn=ON,this.registerOnCleanup=s=>{this.cleanupFn=s},this.consumerAllowSignalWrites=r}notify(){this.dirty||this.schedule(this),this.dirty=!0}onConsumerDependencyMayHaveChanged(){this.notify()}onProducerUpdateValueVersion(){}run(){if(this.dirty=!1,0!==this.trackingVersion&&!this.consumerPollProducersForChange())return;const t=ys(this);this.trackingVersion++;try{this.cleanupFn(),this.cleanupFn=ON,this.watch(this.registerOnCleanup)}finally{ys(t)}}cleanup(){this.cleanupFn()}}class QH{constructor(t,e,r){this.previousValue=t,this.currentValue=e,this.firstChange=r}isFirstChange(){return this.firstChange}}function so(){return RN}function RN(n){return n.type.prototype.ngOnChanges&&(n.setInput=e5),JH}function JH(){const n=PN(this),t=n?.current;if(t){const e=n.previous;if(e===Xa)n.previous=t;else for(let r in t)e[r]=t[r];n.current=null,this.ngOnChanges(t)}}function e5(n,t,e,r){const s=this.declaredInputs[e],i=PN(n)||function t5(n,t){return n[MN]=t}(n,{previous:Xa,current:null}),o=i.current||(i.current={}),a=i.previous,u=a[s];o[s]=new QH(u&&u.currentValue,t,a===Xa),n[r]=t}so.ngInherit=!0;const MN="__ngSimpleChanges__";function PN(n){return n[MN]||null}const ha=function(n,t,e){};function er(n){for(;Array.isArray(n);)n=n[gs];return n}function _y(n,t){return er(t[n])}function gi(n,t){return er(t[n.index])}function LN(n,t){return n.data[t]}function yi(n,t){const e=t[n];return Fi(e)?e:e[gs]}function vy(n){return 128==(128&n[Jt])}function Fl(n,t){return null==t?null:n[t]}function VN(n){n[md]=0}function l5(n){1024&n[Jt]||(n[Jt]|=1024,zN(n,1))}function BN(n){1024&n[Jt]&&(n[Jt]&=-1025,zN(n,-1))}function zN(n,t){let e=n[gr];if(null===e)return;e[Hu]+=t;let r=e;for(e=e[gr];null!==e&&(1===t&&1===r[Hu]||-1===t&&0===r[Hu]);)e[Hu]+=t,r=e,e=e[gr]}const Bt={lFrame:e2(null),bindingsEnabled:!0,skipHydrationRootTNode:null};function GN(){return Bt.bindingsEnabled}function Xe(){return Bt.lFrame.lView}function wn(){return Bt.lFrame.tView}function As(){let n=qN();for(;null!==n&&64===n.type;)n=n.parent;return n}function qN(){return Bt.lFrame.currentTNode}function pa(n,t){const e=Bt.lFrame;e.currentTNode=n,e.isParent=t}function hx(){return Bt.lFrame.isParent}function px(){Bt.lFrame.isParent=!1}function Xs(){const n=Bt.lFrame;let t=n.bindingRootIndex;return-1===t&&(t=n.bindingRootIndex=n.tView.bindingStartIndex),t}function bd(){return Bt.lFrame.bindingIndex++}function Ja(n){const t=Bt.lFrame,e=t.bindingIndex;return t.bindingIndex=t.bindingIndex+n,e}function v5(n,t){const e=Bt.lFrame;e.bindingIndex=e.bindingRootIndex=n,fx(t)}function fx(n){Bt.lFrame.currentDirectiveIndex=n}function ZN(){return Bt.lFrame.currentQueryIndex}function gx(n){Bt.lFrame.currentQueryIndex=n}function x5(n){const t=n[mt];return 2===t.type?t.declTNode:1===t.type?n[$s]:null}function QN(n,t,e){if(e&$t.SkipSelf){let s=t,i=n;for(;!(s=s.parent,null!==s||e&$t.Host||(s=x5(i),null===s||(i=i[fd],10&s.type))););if(null===s)return!1;t=s,n=i}const r=Bt.lFrame=JN();return r.currentTNode=t,r.lView=n,!0}function yx(n){const t=JN(),e=n[mt];Bt.lFrame=t,t.currentTNode=e.firstChild,t.lView=n,t.tView=e,t.contextLView=n,t.bindingIndex=e.bindingStartIndex,t.inI18n=!1}function JN(){const n=Bt.lFrame,t=null===n?null:n.child;return null===t?e2(n):t}function e2(n){const t={currentTNode:null,isParent:!0,lView:null,tView:null,selectedIndex:-1,contextLView:null,elementDepthCount:0,currentNamespace:null,currentDirectiveIndex:-1,bindingRootIndex:-1,bindingIndex:-1,currentQueryIndex:0,parent:n,child:null,inI18n:!1};return null!==n&&(n.child=t),t}function t2(){const n=Bt.lFrame;return Bt.lFrame=n.parent,n.currentTNode=null,n.lView=null,n}const n2=t2;function bx(){const n=t2();n.isParent=!0,n.tView=null,n.selectedIndex=-1,n.contextLView=null,n.elementDepthCount=0,n.currentDirectiveIndex=-1,n.currentNamespace=null,n.bindingRootIndex=-1,n.bindingIndex=-1,n.currentQueryIndex=0}function Ys(){return Bt.lFrame.selectedIndex}function Yu(n){Bt.lFrame.selectedIndex=n}function yr(){const n=Bt.lFrame;return LN(n.tView,n.selectedIndex)}let s2=!0;function wy(){return s2}function $l(n){s2=n}function xy(n,t){for(let e=t.directiveStart,r=t.directiveEnd;e<r;e++){const i=n.data[e].type.prototype,{ngAfterContentInit:o,ngAfterContentChecked:a,ngAfterViewInit:u,ngAfterViewChecked:c,ngOnDestroy:p}=i;o&&(n.contentHooks??=[]).push(-e,o),a&&((n.contentHooks??=[]).push(e,a),(n.contentCheckHooks??=[]).push(e,a)),u&&(n.viewHooks??=[]).push(-e,u),c&&((n.viewHooks??=[]).push(e,c),(n.viewCheckHooks??=[]).push(e,c)),null!=p&&(n.destroyHooks??=[]).push(e,p)}}function Ty(n,t,e){o2(n,t,3,e)}function Sy(n,t,e,r){(3&n[Jt])===e&&o2(n,t,e,r)}function _x(n,t){let e=n[Jt];(3&e)===t&&(e&=4095,e+=1,n[Jt]=e)}function o2(n,t,e,r){const i=r??-1,o=t.length-1;let a=0;for(let u=void 0!==r?65535&n[md]:0;u<o;u++)if("number"==typeof t[u+1]){if(a=t[u],null!=r&&a>=r)break}else t[u]<0&&(n[md]+=65536),(a<i||-1==i)&&(k5(n,e,t,u),n[md]=(4294901760&n[md])+u+2),u++}function a2(n,t){ha(4,n,t);const e=ys(null);try{t.call(n)}finally{ys(e),ha(5,n,t)}}function k5(n,t,e,r){const s=e[r]<0,i=e[r+1],a=n[s?-e[r]:e[r]];s?n[Jt]>>12<n[md]>>16&&(3&n[Jt])===t&&(n[Jt]+=4096,a2(a,i)):a2(a,i)}const _d=-1;class Dp{constructor(t,e,r){this.factory=t,this.resolving=!1,this.canSeeViewProviders=e,this.injectImpl=r}}function l2(n){return n!==_d}function Cy(n){return 32767&n}function Iy(n,t){let e=function M5(n){return n>>16}(n),r=t;for(;e>0;)r=r[fd],e--;return r}let wx=!0;function Ey(n){const t=wx;return wx=n,t}const u2=255,c2=5;let P5=0;const fa={};function Dy(n,t){const e=d2(n,t);if(-1!==e)return e;const r=t[mt];r.firstCreatePass&&(n.injectorIndex=t.length,xx(r.data,n),xx(t,null),xx(r.blueprint,null));const s=Tx(n,t),i=n.injectorIndex;if(l2(s)){const o=Cy(s),a=Iy(s,t),u=a[mt].data;for(let c=0;c<8;c++)t[i+c]=a[o+c]|u[o+c]}return t[i+8]=s,i}function xx(n,t){n.push(0,0,0,0,0,0,0,0,t)}function d2(n,t){return-1===n.injectorIndex||n.parent&&n.parent.injectorIndex===n.injectorIndex||null===t[n.injectorIndex+8]?-1:n.injectorIndex}function Tx(n,t){if(n.parent&&-1!==n.parent.injectorIndex)return n.parent.injectorIndex;let e=0,r=null,s=t;for(;null!==s;){if(r=b2(s),null===r)return _d;if(e++,s=s[fd],-1!==r.injectorIndex)return r.injectorIndex|e<<16}return _d}function Sx(n,t,e){!function F5(n,t,e){let r;"string"==typeof e?r=e.charCodeAt(0)||0:e.hasOwnProperty(vp)&&(r=e[vp]),null==r&&(r=e[vp]=P5++);const s=r&u2;t.data[n+(s>>c2)]|=1<<s}(n,t,e)}function h2(n,t,e){if(e&$t.Optional||void 0!==n)return n;iy()}function p2(n,t,e,r){if(e&$t.Optional&&void 0===r&&(r=null),!(e&($t.Self|$t.Host))){const s=n[pd],i=hi(void 0);try{return s?s.get(t,r,e&$t.Optional):aN(t,r,e&$t.Optional)}finally{hi(i)}}return h2(r,0,e)}function f2(n,t,e,r=$t.Default,s){if(null!==n){if(2048&t[Jt]){const o=function z5(n,t,e,r,s){let i=n,o=t;for(;null!==i&&null!==o&&2048&o[Jt]&&!(512&o[Jt]);){const a=m2(i,o,e,r|$t.Self,fa);if(a!==fa)return a;let u=i.parent;if(!u){const c=o[SN];if(c){const p=c.get(e,fa,r);if(p!==fa)return p}u=b2(o),o=o[fd]}i=u}return s}(n,t,e,r,fa);if(o!==fa)return o}const i=m2(n,t,e,r,fa);if(i!==fa)return i}return p2(t,e,r,s)}function m2(n,t,e,r,s){const i=function V5(n){if("string"==typeof n)return n.charCodeAt(0)||0;const t=n.hasOwnProperty(vp)?n[vp]:void 0;return"number"==typeof t?t>=0?t&u2:B5:t}(e);if("function"==typeof i){if(!QN(t,n,r))return r&$t.Host?h2(s,0,r):p2(t,e,r,s);try{const o=i(r);if(null!=o||r&$t.Optional)return o;iy()}finally{n2()}}else if("number"==typeof i){let o=null,a=d2(n,t),u=_d,c=r&$t.Host?t[jr][$s]:null;for((-1===a||r&$t.SkipSelf)&&(u=-1===a?Tx(n,t):t[a+8],u!==_d&&y2(r,!1)?(o=t[mt],a=Cy(u),t=Iy(u,t)):a=-1);-1!==a;){const p=t[mt];if(g2(i,a,p.data)){const m=L5(a,t,e,o,r,c);if(m!==fa)return m}u=t[a+8],u!==_d&&y2(r,t[mt].data[a+8]===c)&&g2(i,a,t)?(o=p,a=Cy(u),t=Iy(u,t)):a=-1}}return s}function L5(n,t,e,r,s,i){const o=t[mt],a=o.data[n+8],p=Ay(a,o,e,null==r?Ku(a)&&wx:r!=o&&0!=(3&a.type),s&$t.Host&&i===a);return null!==p?Zu(t,o,p,a):fa}function Ay(n,t,e,r,s){const i=n.providerIndexes,o=t.data,a=1048575&i,u=n.directiveStart,p=i>>20,y=s?a+p:n.directiveEnd;for(let _=r?a:a+p;_<y;_++){const w=o[_];if(_<u&&e===w||_>=u&&w.type===e)return _}if(s){const _=o[u];if(_&&Uo(_)&&_.type===e)return u}return null}function Zu(n,t,e,r){let s=n[e];const i=t.data;if(function N5(n){return n instanceof Dp}(s)){const o=s;o.resolving&&function lH(n,t){const e=t?`. Dependency path: ${t.join(" > ")} > ${n}`:"";throw new je(-200,`Circular dependency in DI detected for ${n}${e}`)}(function kn(n){return"function"==typeof n?n.name||n.toString():"object"==typeof n&&null!=n&&"function"==typeof n.type?n.type.name||n.type.toString():Wt(n)}(i[e]));const a=Ey(o.canSeeViewProviders);o.resolving=!0;const u=o.injectImpl?hi(o.injectImpl):null;QN(n,r,$t.Default);try{s=n[e]=o.factory(void 0,i,n,r),t.firstCreatePass&&e>=r.directiveStart&&function A5(n,t,e){const{ngOnChanges:r,ngOnInit:s,ngDoCheck:i}=t.type.prototype;if(r){const o=RN(t);(e.preOrderHooks??=[]).push(n,o),(e.preOrderCheckHooks??=[]).push(n,o)}s&&(e.preOrderHooks??=[]).push(0-n,s),i&&((e.preOrderHooks??=[]).push(n,i),(e.preOrderCheckHooks??=[]).push(n,i))}(e,i[e],t)}finally{null!==u&&hi(u),Ey(a),o.resolving=!1,n2()}}return s}function g2(n,t,e){return!!(e[t+(n>>c2)]&1<<n)}function y2(n,t){return!(n&$t.Self||n&$t.Host&&t)}class vd{constructor(t,e){this._tNode=t,this._lView=e}get(t,e,r){return f2(this._tNode,this._lView,t,uy(r),e)}}function B5(){return new vd(As(),Xe())}function Cx(n){return Lo(n)?()=>{const t=Cx(_t(n));return t&&t()}:Xu(n)}function b2(n){const t=n[mt],e=t.type;return 2===e?t.declTNode:1===e?n[$s]:null}const xd="__parameters__";function Sd(n,t,e){return Ka(()=>{const r=function Ix(n){return function(...e){if(n){const r=n(...e);for(const s in r)this[s]=r[s]}}}(t);function s(...i){if(this instanceof s)return r.apply(this,i),this;const o=new s(...i);return a.annotation=o,a;function a(u,c,p){const m=u.hasOwnProperty(xd)?u[xd]:Object.defineProperty(u,xd,{value:[]})[xd];for(;m.length<=p;)m.push(null);return(m[p]=m[p]||[]).push(o),u}}return e&&(s.prototype=Object.create(e.prototype)),s.prototype.ngMetadataName=n,s.annotationCls=s,s})}function Op(n,t){n.forEach(e=>Array.isArray(e)?Op(e,t):t(e))}function v2(n,t,e){t>=n.length?n.push(e):n.splice(t,0,e)}function ky(n,t){return t>=n.length-1?n.pop():n.splice(t,1)[0]}function Rp(n,t){const e=[];for(let r=0;r<n;r++)e.push(t);return e}function Li(n,t,e){let r=Cd(n,t);return r>=0?n[1|r]=e:(r=~r,function H5(n,t,e,r){let s=n.length;if(s==t)n.push(e,r);else if(1===s)n.push(r,n[0]),n[0]=e;else{for(s--,n.push(n[s-1],n[s]);s>t;)n[s]=n[s-2],s--;n[t]=e,n[t+1]=r}}(n,r,t,e)),r}function Ex(n,t){const e=Cd(n,t);if(e>=0)return n[1|e]}function Cd(n,t){return function w2(n,t,e){let r=0,s=n.length>>e;for(;s!==r;){const i=r+(s-r>>1),o=n[i<<e];if(t===o)return i<<e;o>t?s=i:r=i+1}return~(s<<e)}(n,t,1)}const Oy=_p(Sd("Optional"),8),Ry=_p(Sd("SkipSelf"),4);var bi=(()=>((bi=bi||{})[bi.Important=1]="Important",bi[bi.DashCase=2]="DashCase",bi))();const p8=/^>|^->|<!--|-->|--!>|<!-$/g,f8=/(<|>)/,m8="\u200b$1\u200b";const Mx=new Map;let g8=0;const Fx="__ngContext__";function Ls(n,t){Fi(t)?(n[Fx]=t[Sp],function b8(n){Mx.set(n[Sp],n)}(t)):n[Fx]=t}let $x;function Lx(n,t){return $x(n,t)}function Fp(n){const t=n[gr];return $i(t)?t[gr]:t}function Vx(n){return V2(n[xp])}function Bx(n){return V2(n[zo])}function V2(n){for(;null!==n&&!$i(n);)n=n[zo];return n}function Ed(n,t,e,r,s){if(null!=r){let i,o=!1;$i(r)?i=r:Fi(r)&&(o=!0,r=r[gs]);const a=er(r);0===n&&null!==e?null==s?G2(t,e,a):Qu(t,e,a,s||null,!0):1===n&&null!==e?Qu(t,e,a,s||null,!0):2===n?function By(n,t,e){const r=Ly(n,t);r&&function $8(n,t,e,r){n.removeChild(t,e,r)}(n,r,t,e)}(t,a,o):3===n&&t.destroyNode(a),null!=i&&function B8(n,t,e,r,s){const i=e[ca];i!==er(e)&&Ed(t,n,r,i,s);for(let a=Ds;a<e.length;a++){const u=e[a];Lp(u[mt],u,n,t,r,i)}}(t,n,i,e,s)}}function zx(n,t){return n.createComment(function N2(n){return n.replace(p8,t=>t.replace(f8,m8))}(t))}function $y(n,t,e){return n.createElement(t,e)}function z2(n,t){const e=n[gd],r=e.indexOf(t);BN(t),e.splice(r,1)}function Ux(n,t){if(n.length<=Ds)return;const e=Ds+t,r=n[e];if(r){const s=r[Tp];null!==s&&s!==n&&z2(s,r),t>0&&(n[e-1][zo]=r[zo]);const i=ky(n,Ds+t);!function A8(n,t){Lp(n,t,t[Kt],2,null,null),t[gs]=null,t[$s]=null}(r[mt],r);const o=i[ua];null!==o&&o.detachView(i[mt]),r[gr]=null,r[zo]=null,r[Jt]&=-129}return r}function U2(n,t){if(!(256&t[Jt])){const e=t[Kt];t[hy]?.destroy(),t[py]?.destroy(),e.destroyNode&&Lp(n,t,e,3,null,null),function O8(n){let t=n[xp];if(!t)return jx(n[mt],n);for(;t;){let e=null;if(Fi(t))e=t[xp];else{const r=t[Ds];r&&(e=r)}if(!e){for(;t&&!t[zo]&&t!==n;)Fi(t)&&jx(t[mt],t),t=t[gr];null===t&&(t=n),Fi(t)&&jx(t[mt],t),e=t&&t[zo]}t=e}}(t)}}function jx(n,t){if(!(256&t[Jt])){t[Jt]&=-129,t[Jt]|=256,function F8(n,t){let e;if(null!=n&&null!=(e=n.destroyHooks))for(let r=0;r<e.length;r+=2){const s=t[e[r]];if(!(s instanceof Dp)){const i=e[r+1];if(Array.isArray(i))for(let o=0;o<i.length;o+=2){const a=s[i[o]],u=i[o+1];ha(4,a,u);try{u.call(a)}finally{ha(5,a,u)}}else{ha(4,s,i);try{i.call(s)}finally{ha(5,s,i)}}}}}(n,t),function P8(n,t){const e=n.cleanup,r=t[hd];if(null!==e)for(let i=0;i<e.length-1;i+=2)if("string"==typeof e[i]){const o=e[i+3];o>=0?r[o]():r[-o].unsubscribe(),i+=2}else e[i].call(r[e[i+1]]);null!==r&&(t[hd]=null);const s=t[Pl];if(null!==s){for(let i=0;i<s.length;i++)(0,s[i])();t[Pl]=null}}(n,t),1===t[mt].type&&t[Kt].destroy();const e=t[Tp];if(null!==e&&$i(t[gr])){e!==t[gr]&&z2(e,t);const r=t[ua];null!==r&&r.detachView(n)}!function _8(n){Mx.delete(n[Sp])}(t)}}function Gx(n,t,e){return function j2(n,t,e){let r=t;for(;null!==r&&40&r.type;)r=(t=r).parent;if(null===r)return e[gs];{const{componentOffset:s}=r;if(s>-1){const{encapsulation:i}=n.data[r.directiveStart+s];if(i===pi.None||i===pi.Emulated)return null}return gi(r,e)}}(n,t.parent,e)}function Qu(n,t,e,r,s){n.insertBefore(t,e,r,s)}function G2(n,t,e){n.appendChild(t,e)}function W2(n,t,e,r,s){null!==r?Qu(n,t,e,r,s):G2(n,t,e)}function Ly(n,t){return n.parentNode(t)}function H2(n,t,e){return K2(n,t,e)}let Wx,Xx,K2=function q2(n,t,e){return 40&n.type?gi(n,e):null};function Vy(n,t,e,r){const s=Gx(n,r,t),i=t[Kt],a=H2(r.parent||t[$s],r,t);if(null!=s)if(Array.isArray(e))for(let u=0;u<e.length;u++)W2(i,s,e[u],a,!1);else W2(i,s,e,a,!1);void 0!==Wx&&Wx(i,r,t,e,s)}function $p(n,t){if(null!==t){const e=t.type;if(3&e)return gi(t,n);if(4&e)return Hx(-1,n[t.index]);if(8&e){const r=t.child;if(null!==r)return $p(n,r);{const s=n[t.index];return $i(s)?Hx(-1,s):er(s)}}if(32&e)return Lx(t,n)()||er(n[t.index]);{const r=Y2(n,t);return null!==r?Array.isArray(r)?r[0]:$p(Fp(n[jr]),r):$p(n,t.next)}}return null}function Y2(n,t){return null!==t?n[jr][$s].projection[t.projection]:null}function Hx(n,t){const e=Ds+n+1;if(e<t.length){const r=t[e],s=r[mt].firstChild;if(null!==s)return $p(r,s)}return t[ca]}function qx(n,t,e,r,s,i,o){for(;null!=e;){const a=r[e.index],u=e.type;if(o&&0===t&&(a&&Ls(er(a),r),e.flags|=2),32!=(32&e.flags))if(8&u)qx(n,t,e.child,r,s,i,!1),Ed(t,n,s,a,i);else if(32&u){const c=Lx(e,r);let p;for(;p=c();)Ed(t,n,s,p,i);Ed(t,n,s,a,i)}else 16&u?Q2(n,t,r,e,s,i):Ed(t,n,s,a,i);e=o?e.projectionNext:e.next}}function Lp(n,t,e,r,s,i){qx(e,r,n.firstChild,t,s,i,!1)}function Q2(n,t,e,r,s,i){const o=e[jr],u=o[$s].projection[r.projection];if(Array.isArray(u))for(let c=0;c<u.length;c++)Ed(t,n,s,u[c],i);else qx(n,t,u,o[gr],s,i,!0)}function J2(n,t,e){""===e?n.removeAttribute(t,"class"):n.setAttribute(t,"class",e)}function eO(n,t,e){const{mergedAttrs:r,classes:s,styles:i}=e;null!==r&&rx(n,t,r),null!==s&&J2(n,t,s),null!==i&&function U8(n,t,e){n.setAttribute(t,"style",e)}(n,t,i)}class sO{constructor(t){this.changingThisBreaksApplicationSecurity=t}toString(){return`SafeValue must use [property]=binding: ${this.changingThisBreaksApplicationSecurity} (see ${nN})`}}function Ll(n){return n instanceof sO?n.changingThisBreaksApplicationSecurity:n}const nq=/^(?!javascript:)(?:[a-z0-9+.-]+:|[^&:\/?#]*(?:[\/?#]|$))/i;var Gr=(()=>((Gr=Gr||{})[Gr.NONE=0]="NONE",Gr[Gr.HTML=1]="HTML",Gr[Gr.STYLE=2]="STYLE",Gr[Gr.SCRIPT=3]="SCRIPT",Gr[Gr.URL=4]="URL",Gr[Gr.RESOURCE_URL=5]="RESOURCE_URL",Gr))();function tT(n){const t=function Up(){const n=Xe();return n&&n[qu].sanitizer}();return t?t.sanitize(Gr.URL,n)||"":function Bp(n,t){const e=function Q8(n){return n instanceof sO&&n.getTypeName()||null}(n);if(null!=e&&e!==t){if("ResourceURL"===e&&"URL"===t)return!0;throw new Error(`Required a safe ${t}, got a ${e} (see ${nN})`)}return e===t}(n,"URL")?Ll(n):function Zx(n){return(n=String(n)).match(nq)?n:"unsafe:"+n}(Wt(n))}class st{constructor(t,e){this._desc=t,this.ngMetadataName="InjectionToken",this.\u0275prov=void 0,"number"==typeof e?this.__NG_ELEMENT_ID__=e:void 0!==e&&(this.\u0275prov=ht({token:this,providedIn:e.providedIn||"root",factory:e.factory}))}get multi(){return this}toString(){return`InjectionToken ${this._desc}`}}const jp=new st("ENVIRONMENT_INITIALIZER"),pO=new st("INJECTOR",-1),fO=new st("INJECTOR_DEF_TYPES");class mO{get(t,e=bp){if(e===bp){const r=new Error(`NullInjectorError: No provider for ${Sr(t)}!`);throw r.name="NullInjectorError",r}return e}}function mq(...n){return{\u0275providers:yO(0,n),\u0275fromNgModule:!0}}function yO(n,...t){const e=[],r=new Set;let s;return Op(t,i=>{const o=i;nT(o,e,[],r)&&(s||=[],s.push(o))}),void 0!==s&&bO(s,e),e}function bO(n,t){for(let e=0;e<n.length;e++){const{providers:s}=n[e];rT(s,i=>{t.push(i)})}}function nT(n,t,e,r){if(!(n=_t(n)))return!1;let s=null,i=sN(n);const o=!i&&En(n);if(i||o){if(o&&!o.standalone)return!1;s=n}else{const u=n.ngModule;if(i=sN(u),!i)return!1;s=u}const a=r.has(s);if(o){if(a)return!1;if(r.add(s),o.dependencies){const u="function"==typeof o.dependencies?o.dependencies():o.dependencies;for(const c of u)nT(c,t,e,r)}}else{if(!i)return!1;{if(null!=i.imports&&!a){let c;r.add(s);try{Op(i.imports,p=>{nT(p,t,e,r)&&(c||=[],c.push(p))})}finally{}void 0!==c&&bO(c,t)}if(!a){const c=Xu(s)||(()=>new s);t.push({provide:s,useFactory:c,deps:In},{provide:fO,useValue:s,multi:!0},{provide:jp,useValue:()=>Le(s),multi:!0})}const u=i.providers;null==u||a||rT(u,p=>{t.push(p)})}}return s!==n&&void 0!==n.providers}function rT(n,t){for(let e of n)ud(e)&&(e=e.\u0275providers),Array.isArray(e)?rT(e,t):t(e)}const gq=Ut({provide:String,useValue:Ut});function sT(n){return null!==n&&"object"==typeof n&&gq in n}function Ju(n){return"function"==typeof n}const iT=new st("Set Injector scope."),Gy={},bq={};let oT;function Wy(){return void 0===oT&&(oT=new mO),oT}class tl{}class aT extends tl{get destroyed(){return this._destroyed}constructor(t,e,r,s){super(),this.parent=e,this.source=r,this.scopes=s,this.records=new Map,this._ngOnDestroyHooks=new Set,this._onDestroyHooks=[],this._destroyed=!1,uT(t,o=>this.processProvider(o)),this.records.set(pO,Ad(void 0,this)),s.has("environment")&&this.records.set(tl,Ad(void 0,this));const i=this.records.get(iT);null!=i&&"string"==typeof i.value&&this.scopes.add(i.value),this.injectorDefTypes=new Set(this.get(fO.multi,In,$t.Self))}destroy(){this.assertNotDestroyed(),this._destroyed=!0;try{for(const t of this._ngOnDestroyHooks)t.ngOnDestroy();for(const t of this._onDestroyHooks)t()}finally{this.records.clear(),this._ngOnDestroyHooks.clear(),this.injectorDefTypes.clear(),this._onDestroyHooks.length=0}}onDestroy(t){return this.assertNotDestroyed(),this._onDestroyHooks.push(t),()=>this.removeOnDestroy(t)}runInContext(t){this.assertNotDestroyed();const e=Ml(this),r=hi(void 0);try{return t()}finally{Ml(e),hi(r)}}get(t,e=bp,r=$t.Default){if(this.assertNotDestroyed(),t.hasOwnProperty(dN))return t[dN](this);r=uy(r);const s=Ml(this),i=hi(void 0);try{if(!(r&$t.SkipSelf)){let a=this.records.get(t);if(void 0===a){const u=function Tq(n){return"function"==typeof n||"object"==typeof n&&n instanceof st}(t)&&oy(t);a=u&&this.injectableDefInScope(u)?Ad(lT(t),Gy):null,this.records.set(t,a)}if(null!=a)return this.hydrate(t,a)}return(r&$t.Self?Wy():this.parent).get(t,e=r&$t.Optional&&e===bp?null:e)}catch(o){if("NullInjectorError"===o.name){if((o[ly]=o[ly]||[]).unshift(Sr(t)),s)throw o;return function xH(n,t,e,r){const s=n[ly];throw t[lN]&&s.unshift(t[lN]),n.message=function TH(n,t,e,r=null){n=n&&"\n"===n.charAt(0)&&"\u0275"==n.charAt(1)?n.slice(2):n;let s=Sr(t);if(Array.isArray(t))s=t.map(Sr).join(" -> ");else if("object"==typeof t){let i=[];for(let o in t)if(t.hasOwnProperty(o)){let a=t[o];i.push(o+":"+("string"==typeof a?JSON.stringify(a):Sr(a)))}s=`{${i.join(", ")}}`}return`${e}${r?"("+r+")":""}[${s}]: ${n.replace(yH,"\n  ")}`}("\n"+n.message,s,e,r),n.ngTokenPath=s,n[ly]=null,n}(o,t,"R3InjectorError",this.source)}throw o}finally{hi(i),Ml(s)}}resolveInjectorInitializers(){const t=Ml(this),e=hi(void 0);try{const r=this.get(jp.multi,In,$t.Self);for(const s of r)s()}finally{Ml(t),hi(e)}}toString(){const t=[],e=this.records;for(const r of e.keys())t.push(Sr(r));return`R3Injector[${t.join(", ")}]`}assertNotDestroyed(){if(this._destroyed)throw new je(205,!1)}processProvider(t){let e=Ju(t=_t(t))?t:_t(t&&t.provide);const r=function vq(n){return sT(n)?Ad(void 0,n.useValue):Ad(wO(n),Gy)}(t);if(Ju(t)||!0!==t.multi)this.records.get(e);else{let s=this.records.get(e);s||(s=Ad(void 0,Gy,!0),s.factory=()=>ex(s.multi),this.records.set(e,s)),e=t,s.multi.push(t)}this.records.set(e,r)}hydrate(t,e){return e.value===Gy&&(e.value=bq,e.value=e.factory()),"object"==typeof e.value&&e.value&&function xq(n){return null!==n&&"object"==typeof n&&"function"==typeof n.ngOnDestroy}(e.value)&&this._ngOnDestroyHooks.add(e.value),e.value}injectableDefInScope(t){if(!t.providedIn)return!1;const e=_t(t.providedIn);return"string"==typeof e?"any"===e||this.scopes.has(e):this.injectorDefTypes.has(e)}removeOnDestroy(t){const e=this._onDestroyHooks.indexOf(t);-1!==e&&this._onDestroyHooks.splice(e,1)}}function lT(n){const t=oy(n),e=null!==t?t.factory:Xu(n);if(null!==e)return e;if(n instanceof st)throw new je(204,!1);if(n instanceof Function)return function _q(n){const t=n.length;if(t>0)throw Rp(t,"?"),new je(204,!1);const e=function fH(n){return n&&(n[ay]||n[iN])||null}(n);return null!==e?()=>e.factory(n):()=>new n}(n);throw new je(204,!1)}function wO(n,t,e){let r;if(Ju(n)){const s=_t(n);return Xu(s)||lT(s)}if(sT(n))r=()=>_t(n.useValue);else if(function vO(n){return!(!n||!n.useFactory)}(n))r=()=>n.useFactory(...ex(n.deps||[]));else if(function _O(n){return!(!n||!n.useExisting)}(n))r=()=>Le(_t(n.useExisting));else{const s=_t(n&&(n.useClass||n.provide));if(!function wq(n){return!!n.deps}(n))return Xu(s)||lT(s);r=()=>new s(...ex(n.deps))}return r}function Ad(n,t,e=!1){return{factory:n,value:t,multi:e?[]:void 0}}function uT(n,t){for(const e of n)Array.isArray(e)?uT(e,t):e&&ud(e)?uT(e.\u0275providers,t):t(e)}const Hy=new st("AppId",{providedIn:"root",factory:()=>Sq}),Sq="ng",xO=new st("Platform Initializer"),kd=new st("Platform ID",{providedIn:"platform",factory:()=>"unknown"}),Vl=new st("AnimationModuleType"),cT=new st("CSP nonce",{providedIn:"root",factory:()=>function Vp(){return void 0!==Xx?Xx:typeof document<"u"?document:void 0}().body?.querySelector("[ngCspNonce]")?.getAttribute("ngCspNonce")||null});let SO=(n,t)=>null;function CO(n,t){return SO(n,t)}class Mq{}class DO{}class Fq{resolveComponentFactory(t){throw function Pq(n){const t=Error(`No component factory found for ${Sr(n)}.`);return t.ngComponent=n,t}(t)}}let Nd=(()=>{class n{}return n.NULL=new Fq,n})();function $q(){return Od(As(),Xe())}function Od(n,t){return new tr(gi(n,t))}let tr=(()=>{class n{constructor(e){this.nativeElement=e}}return n.__NG_ELEMENT_ID__=$q,n})();function Lq(n){return n instanceof tr?n.nativeElement:n}class qp{}let nl=(()=>{class n{}return n.__NG_ELEMENT_ID__=()=>function Vq(){const n=Xe(),e=yi(As().index,n);return(Fi(e)?e:n)[Kt]}(),n})(),Bq=(()=>{class n{}return n.\u0275prov=ht({token:n,providedIn:"root",factory:()=>null}),n})();class ec{constructor(t){this.full=t,this.major=t.split(".")[0],this.minor=t.split(".")[1],this.patch=t.split(".").slice(2).join(".")}}const zq=new ec("16.0.0"),wT={};function Kp(n){for(;n;){n[Jt]|=64;const t=Fp(n);if(ox(n)&&!t)return n;n=t}return null}function xT(n){return n.ngOriginalError}class tc{constructor(){this._console=console}handleError(t){const e=this._findOriginalError(t);this._console.error("ERROR",t),e&&this._console.error("ORIGINAL ERROR",e)}_findOriginalError(t){let e=t&&xT(t);for(;e&&xT(e);)e=xT(e);return e||null}}const RO=new st("",{providedIn:"root",factory:()=>!1});function rl(n){return n instanceof Function?n():n}class FO extends kN{constructor(){super(...arguments),this.consumerAllowSignalWrites=!1,this._lView=null}set lView(t){this._lView=t}onConsumerDependencyMayHaveChanged(){Kp(this._lView)}onProducerUpdateValueVersion(){}get hasReadASignal(){return this.hasProducers}runInContext(t,e,r){const s=ys(this);this.trackingVersion++;try{t(e,r)}finally{ys(s)}}destroy(){this.trackingVersion++}}let Jy=null;function $O(){return Jy??=new FO,Jy}function LO(n,t){return n[t]??$O()}function VO(n,t){const e=$O();e.hasReadASignal&&(n[t]=Jy,e.lView=n,Jy=new FO)}const Xt={};function Sn(n){BO(wn(),Xe(),Ys()+n,!1)}function BO(n,t,e,r){if(!r)if(3==(3&t[Jt])){const i=n.preOrderCheckHooks;null!==i&&Ty(t,i,e)}else{const i=n.preOrderHooks;null!==i&&Sy(t,i,0,e)}Yu(e)}function GO(n,t=null,e=null,r){const s=WO(n,t,e,r);return s.resolveInjectorInitializers(),s}function WO(n,t=null,e=null,r,s=new Set){const i=[e||In,mq(n)];return r=r||("object"==typeof n?void 0:Sr(n)),new aT(i,t||Wy(),r||null,s)}let Vs=(()=>{class n{static create(e,r){if(Array.isArray(e))return GO({name:""},r,e,"");{const s=e.name??"";return GO({name:s},e.parent,e.providers,s)}}}return n.THROW_IF_NOT_FOUND=bp,n.NULL=new mO,n.\u0275prov=ht({token:n,providedIn:"any",factory:()=>Le(pO)}),n.__NG_ELEMENT_ID__=-1,n})();function Ee(n,t=$t.Default){const e=Xe();return null===e?Le(n,t):f2(As(),e,_t(n),t)}function eb(){throw new Error("invalid")}function tb(n,t,e,r,s,i,o,a,u,c,p){const m=t.blueprint.slice();return m[gs]=s,m[Jt]=140|r,(null!==c||n&&2048&n[Jt])&&(m[Jt]|=2048),VN(m),m[gr]=m[fd]=n,m[Cr]=e,m[qu]=o||n&&n[qu],m[Kt]=a||n&&n[Kt],m[pd]=u||n&&n[pd]||null,m[$s]=i,m[Sp]=function y8(){return g8++}(),m[Za]=p,m[SN]=c,m[jr]=2==t.type?n[jr]:m,m}function Pd(n,t,e,r,s){let i=n.data[t];if(null===i)i=function TT(n,t,e,r,s){const i=qN(),o=hx(),u=n.data[t]=function l7(n,t,e,r,s,i){return{type:e,index:r,insertBeforeIndex:null,injectorIndex:t?t.injectorIndex:-1,directiveStart:-1,directiveEnd:-1,directiveStylingLast:-1,componentOffset:-1,propertyBindings:null,flags:0,providerIndexes:0,value:s,attrs:i,mergedAttrs:null,localNames:null,initialInputs:void 0,inputs:null,outputs:null,tView:null,next:null,prev:null,projectionNext:null,child:null,parent:t,projection:null,styles:null,stylesWithoutHost:null,residualStyles:void 0,classes:null,classesWithoutHost:null,residualClasses:void 0,classBindings:0,styleBindings:0}}(0,o?i:i&&i.parent,e,t,r,s);return null===n.firstChild&&(n.firstChild=u),null!==i&&(o?null==i.child&&null!==u.parent&&(i.child=u):null===i.next&&(i.next=u,u.prev=i)),u}(n,t,e,r,s),function _5(){return Bt.lFrame.inI18n}()&&(i.flags|=32);else if(64&i.type){i.type=e,i.value=r,i.attrs=s;const o=function Ep(){const n=Bt.lFrame,t=n.currentTNode;return n.isParent?t:t.parent}();i.injectorIndex=null===o?-1:o.injectorIndex}return pa(i,!0),i}function Xp(n,t,e,r){if(0===e)return-1;const s=t.length;for(let i=0;i<e;i++)t.push(r),n.blueprint.push(r),n.data.push(null);return s}function HO(n,t,e,r,s){const i=LO(t,hy),o=Ys(),a=2&r;try{if(Yu(-1),a&&t.length>fn&&BO(n,t,fn,!1),ha(a?2:0,s),a)i.runInContext(e,r,s);else{const c=ys(null);try{e(r,s)}finally{ys(c)}}}finally{a&&null===t[hy]&&VO(t,hy),Yu(o),ha(a?3:1,s)}}function ST(n,t,e){if(ix(t)){const r=ys(null);try{const i=t.directiveEnd;for(let o=t.directiveStart;o<i;o++){const a=n.data[o];a.contentQueries&&a.contentQueries(1,e[o],o)}}finally{ys(r)}}}function CT(n,t,e){GN()&&(function m7(n,t,e,r){const s=e.directiveStart,i=e.directiveEnd;Ku(e)&&function x7(n,t,e){const r=gi(t,n),o=nb(n,tb(n,qO(e),null,e.onPush?64:16,r,t,null,n[qu].rendererFactory.createRenderer(r,e),null,null,null));n[t.index]=o}(t,e,n.data[s+e.componentOffset]),n.firstCreatePass||Dy(e,t),Ls(r,t);const o=e.initialInputs;for(let a=s;a<i;a++){const u=n.data[a],c=Zu(t,n,a,e);Ls(c,t),null!==o&&T7(0,a-s,c,u,0,o),Uo(u)&&(yi(e.index,t)[Cr]=Zu(t,n,a,e))}}(n,t,e,gi(e,t)),64==(64&e.flags)&&QO(n,t,e))}function IT(n,t,e=gi){const r=t.localNames;if(null!==r){let s=t.index+1;for(let i=0;i<r.length;i+=2){const o=r[i+1],a=-1===o?e(t,n):n[o];n[s++]=a}}}function qO(n){const t=n.tView;return null===t||t.incompleteFirstPass?n.tView=ET(1,null,n.template,n.decls,n.vars,n.directiveDefs,n.pipeDefs,n.viewQuery,n.schemas,n.consts,n.id):t}function ET(n,t,e,r,s,i,o,a,u,c,p){const m=fn+r,y=m+s,_=function n7(n,t){const e=[];for(let r=0;r<t;r++)e.push(r<n?null:Xt);return e}(m,y),w="function"==typeof c?c():c;return _[mt]={type:n,blueprint:_,template:e,queries:null,viewQuery:a,declTNode:t,data:_.slice().fill(null,m),bindingStartIndex:m,expandoStartIndex:y,hostBindingOpCodes:null,firstCreatePass:!0,firstUpdatePass:!0,staticViewQueries:!1,staticContentQueries:!1,preOrderHooks:null,preOrderCheckHooks:null,contentHooks:null,contentCheckHooks:null,viewHooks:null,viewCheckHooks:null,destroyHooks:null,cleanup:null,contentQueries:null,components:null,directiveRegistry:"function"==typeof i?i():i,pipeRegistry:"function"==typeof o?o():o,firstChild:null,schemas:u,consts:w,incompleteFirstPass:!1,ssrId:p}}let KO=n=>null;function XO(n,t,e,r){for(let s in n)if(n.hasOwnProperty(s)){e=null===e?{}:e;const i=n[s];null===r?YO(e,t,s,i):r.hasOwnProperty(s)&&YO(e,t,r[s],i)}return e}function YO(n,t,e,r){n.hasOwnProperty(e)?n[e].push(t,r):n[e]=[t,r]}function Vi(n,t,e,r,s,i,o,a){const u=gi(t,e);let p,c=t.inputs;!a&&null!=c&&(p=c[r])?(OT(n,e,p,r,s),Ku(t)&&function d7(n,t){const e=yi(t,n);16&e[Jt]||(e[Jt]|=64)}(e,t.index)):3&t.type&&(r=function c7(n){return"class"===n?"className":"for"===n?"htmlFor":"formaction"===n?"formAction":"innerHtml"===n?"innerHTML":"readonly"===n?"readOnly":"tabindex"===n?"tabIndex":n}(r),s=null!=o?o(s,t.value||"",r):s,i.setProperty(u,r,s))}function DT(n,t,e,r){if(GN()){const s=null===r?null:{"":-1},i=function y7(n,t){const e=n.directiveRegistry;let r=null,s=null;if(e)for(let i=0;i<e.length;i++){const o=e[i];if(bN(t,o.selectors,!1))if(r||(r=[]),Uo(o))if(null!==o.findHostDirectiveDefs){const a=[];s=s||new Map,o.findHostDirectiveDefs(o,a,s),r.unshift(...a,o),AT(n,t,a.length)}else r.unshift(o),AT(n,t,0);else s=s||new Map,o.findHostDirectiveDefs?.(o,r,s),r.push(o)}return null===r?null:[r,s]}(n,e);let o,a;null===i?o=a=null:[o,a]=i,null!==o&&ZO(n,t,e,o,s,a),s&&function b7(n,t,e){if(t){const r=n.localNames=[];for(let s=0;s<t.length;s+=2){const i=e[t[s+1]];if(null==i)throw new je(-301,!1);r.push(t[s],i)}}}(e,r,s)}e.mergedAttrs=wp(e.mergedAttrs,e.attrs)}function ZO(n,t,e,r,s,i){for(let c=0;c<r.length;c++)Sx(Dy(e,t),n,r[c].type);!function v7(n,t,e){n.flags|=1,n.directiveStart=t,n.directiveEnd=t+e,n.providerIndexes=t}(e,n.data.length,r.length);for(let c=0;c<r.length;c++){const p=r[c];p.providersResolver&&p.providersResolver(p)}let o=!1,a=!1,u=Xp(n,t,r.length,null);for(let c=0;c<r.length;c++){const p=r[c];e.mergedAttrs=wp(e.mergedAttrs,p.hostAttrs),w7(n,e,t,u,p),_7(u,p,s),null!==p.contentQueries&&(e.flags|=4),(null!==p.hostBindings||null!==p.hostAttrs||0!==p.hostVars)&&(e.flags|=64);const m=p.type.prototype;!o&&(m.ngOnChanges||m.ngOnInit||m.ngDoCheck)&&((n.preOrderHooks??=[]).push(e.index),o=!0),!a&&(m.ngOnChanges||m.ngDoCheck)&&((n.preOrderCheckHooks??=[]).push(e.index),a=!0),u++}!function u7(n,t,e){const s=t.directiveEnd,i=n.data,o=t.attrs,a=[];let u=null,c=null;for(let p=t.directiveStart;p<s;p++){const m=i[p],y=e?e.get(m):null,w=y?y.outputs:null;u=XO(m.inputs,p,u,y?y.inputs:null),c=XO(m.outputs,p,c,w);const T=null===u||null===o||yN(t)?null:S7(u,p,o);a.push(T)}null!==u&&(u.hasOwnProperty("class")&&(t.flags|=8),u.hasOwnProperty("style")&&(t.flags|=16)),t.initialInputs=a,t.inputs=u,t.outputs=c}(n,e,i)}function QO(n,t,e){const r=e.directiveStart,s=e.directiveEnd,i=e.index,o=function w5(){return Bt.lFrame.currentDirectiveIndex}();try{Yu(i);for(let a=r;a<s;a++){const u=n.data[a],c=t[a];fx(a),(null!==u.hostBindings||0!==u.hostVars||null!==u.hostAttrs)&&g7(u,c)}}finally{Yu(-1),fx(o)}}function g7(n,t){null!==n.hostBindings&&n.hostBindings(1,t)}function AT(n,t,e){t.componentOffset=e,(n.components??=[]).push(t.index)}function _7(n,t,e){if(e){if(t.exportAs)for(let r=0;r<t.exportAs.length;r++)e[t.exportAs[r]]=n;Uo(t)&&(e[""]=n)}}function w7(n,t,e,r,s){n.data[r]=s;const i=s.factory||(s.factory=Xu(s.type)),o=new Dp(i,Uo(s),Ee);n.blueprint[r]=o,e[r]=o,function p7(n,t,e,r,s){const i=s.hostBindings;if(i){let o=n.hostBindingOpCodes;null===o&&(o=n.hostBindingOpCodes=[]);const a=~t.index;(function f7(n){let t=n.length;for(;t>0;){const e=n[--t];if("number"==typeof e&&e<0)return e}return 0})(o)!=a&&o.push(a),o.push(e,r,i)}}(n,t,r,Xp(n,e,s.hostVars,Xt),s)}function ma(n,t,e,r,s,i){const o=gi(n,t);!function kT(n,t,e,r,s,i,o){if(null==i)n.removeAttribute(t,s,e);else{const a=null==o?Wt(i):o(i,r||"",s);n.setAttribute(t,s,a,e)}}(t[Kt],o,i,n.value,e,r,s)}function T7(n,t,e,r,s,i){const o=i[t];if(null!==o)for(let a=0;a<o.length;)JO(r,e,o[a++],o[a++],o[a++])}function JO(n,t,e,r,s){const i=ys(null);try{null!==n.setInput?n.setInput(t,s,e,r):t[r]=s}finally{ys(i)}}function S7(n,t,e){let r=null,s=0;for(;s<e.length;){const i=e[s];if(0!==i)if(5!==i){if("number"==typeof i)break;if(n.hasOwnProperty(i)){null===r&&(r=[]);const o=n[i];for(let a=0;a<o.length;a+=2)if(o[a]===t){r.push(i,o[a+1],e[s+1]);break}}s+=2}else s+=2;else s+=4}return r}function eR(n,t,e,r){return[n,!0,!1,t,null,0,r,e,null,null,null]}function tR(n,t){const e=n.contentQueries;if(null!==e)for(let r=0;r<e.length;r+=2){const i=e[r+1];if(-1!==i){const o=n.data[i];gx(e[r]),o.contentQueries(2,t[i],i)}}}function nb(n,t){return n[xp]?n[TN][zo]=t:n[xp]=t,n[TN]=t,t}function NT(n,t,e){gx(0);const r=ys(null);try{t(n,e)}finally{ys(r)}}function nR(n){return n[hd]||(n[hd]=[])}function rR(n){return n.cleanup||(n.cleanup=[])}function iR(n,t){const e=n[pd],r=e?e.get(tc,null):null;r&&r.handleError(t)}function OT(n,t,e,r,s){for(let i=0;i<e.length;){const o=e[i++],a=e[i++];JO(n.data[o],t[o],r,a,s)}}function sl(n,t,e){const r=_y(t,n);!function B2(n,t,e){n.setValue(t,e)}(n[Kt],r,e)}function C7(n,t){const e=yi(t,n),r=e[mt];!function I7(n,t){for(let e=t.length;e<n.blueprint.length;e++)t.push(n.blueprint[e])}(r,e);const s=e[gs];null!==s&&null===e[Za]&&(e[Za]=CO(s,e[pd])),RT(r,e,e[Cr])}function RT(n,t,e){yx(t);try{const r=n.viewQuery;null!==r&&NT(1,r,e);const s=n.template;null!==s&&HO(n,t,s,1,e),n.firstCreatePass&&(n.firstCreatePass=!1),n.staticContentQueries&&tR(n,t),n.staticViewQueries&&NT(2,n.viewQuery,e);const i=n.components;null!==i&&function E7(n,t){for(let e=0;e<t.length;e++)C7(n,t[e])}(t,i)}catch(r){throw n.firstCreatePass&&(n.incompleteFirstPass=!0,n.firstCreatePass=!1),r}finally{t[Jt]&=-5,bx()}}let oR=(()=>{class n{constructor(){this.all=new Set,this.queue=new Map}create(e,r,s){const i=typeof Zone>"u"?null:Zone.current,o=new ZH(e,c=>{this.all.has(c)&&this.queue.set(c,i)},s);let a;this.all.add(o),o.notify();const u=()=>{o.cleanup(),a?.(),this.all.delete(o),this.queue.delete(o)};return a=r?.onDestroy(u),{destroy:u}}flush(){if(0!==this.queue.size)for(const[e,r]of this.queue)this.queue.delete(e),r?r.run(()=>e.run()):e.run()}get isQueueEmpty(){return 0===this.queue.size}}return n.\u0275prov=ht({token:n,providedIn:"root",factory:()=>new n}),n})();function rb(n,t,e){let r=e?n.styles:null,s=e?n.classes:null,i=0;if(null!==t)for(let o=0;o<t.length;o++){const a=t[o];"number"==typeof a?i=a:1==i?s=ld(s,a):2==i&&(r=ld(r,a+": "+t[++o]+";"))}e?n.styles=r:n.stylesWithoutHost=r,e?n.classes=s:n.classesWithoutHost=s}function Yp(n,t,e,r,s=!1){for(;null!==e;){const i=t[e.index];if(null!==i&&r.push(er(i)),$i(i)){for(let a=Ds;a<i.length;a++){const u=i[a],c=u[mt].firstChild;null!==c&&Yp(u[mt],u,c,r)}i[ca]!==i[gs]&&r.push(i[ca])}const o=e.type;if(8&o)Yp(n,t,e.child,r);else if(32&o){const a=Lx(e,t);let u;for(;u=a();)r.push(u)}else if(16&o){const a=Y2(t,e);if(Array.isArray(a))r.push(...a);else{const u=Fp(t[jr]);Yp(u[mt],u,a,r,!0)}}e=s?e.projectionNext:e.next}return r}function sb(n,t,e,r=!0){const s=t[qu].rendererFactory;s.begin&&s.begin();try{ib(n,t,n.template,e)}catch(o){throw r&&iR(t,o),o}finally{s.end&&s.end(),t[qu].effectManager?.flush()}}function ib(n,t,e,r){const s=t[Jt];if(256!=(256&s)){t[qu].effectManager?.flush(),yx(t);try{VN(t),function XN(n){return Bt.lFrame.bindingIndex=n}(n.bindingStartIndex),null!==e&&HO(n,t,e,2,r);const o=3==(3&s);if(o){const c=n.preOrderCheckHooks;null!==c&&Ty(t,c,null)}else{const c=n.preOrderHooks;null!==c&&Sy(t,c,0,null),_x(t,0)}if(function R7(n){for(let t=Vx(n);null!==t;t=Bx(t)){if(!t[CN])continue;const e=t[gd];for(let r=0;r<e.length;r++){l5(e[r])}}}(t),function O7(n){for(let t=Vx(n);null!==t;t=Bx(t))for(let e=Ds;e<t.length;e++){const r=t[e],s=r[mt];vy(r)&&ib(s,r,s.template,r[Cr])}}(t),null!==n.contentQueries&&tR(n,t),o){const c=n.contentCheckHooks;null!==c&&Ty(t,c)}else{const c=n.contentHooks;null!==c&&Sy(t,c,1),_x(t,1)}!function t7(n,t){const e=n.hostBindingOpCodes;if(null===e)return;const r=LO(t,py);try{for(let s=0;s<e.length;s++){const i=e[s];if(i<0)Yu(~i);else{const o=i,a=e[++s],u=e[++s];v5(a,o),r.runInContext(u,2,t[o])}}}finally{null===t[py]&&VO(t,py),Yu(-1)}}(n,t);const a=n.components;null!==a&&function P7(n,t){for(let e=0;e<t.length;e++)M7(n,t[e])}(t,a);const u=n.viewQuery;if(null!==u&&NT(2,u,r),o){const c=n.viewCheckHooks;null!==c&&Ty(t,c)}else{const c=n.viewHooks;null!==c&&Sy(t,c,2),_x(t,2)}!0===n.firstUpdatePass&&(n.firstUpdatePass=!1),t[Jt]&=-73,BN(t)}finally{bx()}}}function M7(n,t){const e=yi(t,n);if(vy(e)){const r=e[mt];80&e[Jt]?ib(r,e,r.template,e[Cr]):e[Hu]>0&&MT(e)}}function MT(n){for(let r=Vx(n);null!==r;r=Bx(r))for(let s=Ds;s<r.length;s++){const i=r[s];if(vy(i))if(1024&i[Jt]){const o=i[mt];ib(o,i,o.template,i[Cr])}else i[Hu]>0&&MT(i)}const e=n[mt].components;if(null!==e)for(let r=0;r<e.length;r++){const s=yi(e[r],n);vy(s)&&s[Hu]>0&&MT(s)}}class Zp{get rootNodes(){const t=this._lView,e=t[mt];return Yp(e,t,e.firstChild,[])}constructor(t,e){this._lView=t,this._cdRefInjectingView=e,this._appRef=null,this._attachedToViewContainer=!1}get context(){return this._lView[Cr]}set context(t){this._lView[Cr]=t}get destroyed(){return 256==(256&this._lView[Jt])}destroy(){if(this._appRef)this._appRef.detachView(this);else if(this._attachedToViewContainer){const t=this._lView[gr];if($i(t)){const e=t[fy],r=e?e.indexOf(this):-1;r>-1&&(Ux(t,r),ky(e,r))}this._attachedToViewContainer=!1}U2(this._lView[mt],this._lView)}onDestroy(t){!function UN(n,t){if(256==(256&n[Jt]))throw new je(911,!1);null===n[Pl]&&(n[Pl]=[]),n[Pl].push(t)}(this._lView,t)}markForCheck(){Kp(this._cdRefInjectingView||this._lView)}detach(){this._lView[Jt]&=-129}reattach(){this._lView[Jt]|=128}detectChanges(){sb(this._lView[mt],this._lView,this.context)}checkNoChanges(){}attachToViewContainerRef(){if(this._appRef)throw new je(902,!1);this._attachedToViewContainer=!0}detachFromAppRef(){this._appRef=null,function N8(n,t){Lp(n,t,t[Kt],2,null,null)}(this._lView[mt],this._lView)}attachToAppRef(t){if(this._attachedToViewContainer)throw new je(902,!1);this._appRef=t}}class F7 extends Zp{constructor(t){super(t),this._view=t}detectChanges(){const t=this._view;sb(t[mt],t,t[Cr],!1)}checkNoChanges(){}get context(){return null}}class aR extends Nd{constructor(t){super(),this.ngModule=t}resolveComponentFactory(t){const e=En(t);return new Qp(e,this.ngModule)}}function lR(n){const t=[];for(let e in n)n.hasOwnProperty(e)&&t.push({propName:n[e],templateName:e});return t}class L7{constructor(t,e){this.injector=t,this.parentInjector=e}get(t,e,r){r=uy(r);const s=this.injector.get(t,wT,r);return s!==wT||e===wT?s:this.parentInjector.get(t,e,r)}}class Qp extends DO{get inputs(){return lR(this.componentDef.inputs)}get outputs(){return lR(this.componentDef.outputs)}constructor(t,e){super(),this.componentDef=t,this.ngModule=e,this.componentType=t.type,this.selector=function RH(n){return n.map(OH).join(",")}(t.selectors),this.ngContentSelectors=t.ngContentSelectors?t.ngContentSelectors:[],this.isBoundToModule=!!e}create(t,e,r,s){let i=(s=s||this.ngModule)instanceof tl?s:s?.injector;i&&null!==this.componentDef.getStandaloneInjector&&(i=this.componentDef.getStandaloneInjector(i)||i);const o=i?new L7(t,i):t,a=o.get(qp,null);if(null===a)throw new je(407,!1);const p={rendererFactory:a,sanitizer:o.get(Bq,null),effectManager:o.get(oR,null)},m=a.createRenderer(null,this.componentDef),y=this.componentDef.selectors[0][0]||"div",_=r?function r7(n,t,e,r){const i=r.get(RO,!1)||e===pi.ShadowDom,o=n.selectRootElement(t,i);return function s7(n){KO(n)}(o),o}(m,r,this.componentDef.encapsulation,o):$y(m,y,function $7(n){const t=n.toLowerCase();return"svg"===t?"svg":"math"===t?"math":null}(y)),w=this.componentDef.onPush?576:528,T=ET(0,null,null,1,0,null,null,null,null,null,null),I=tb(null,T,null,w,null,null,p,m,o,null,null);let O,M;yx(I);try{const V=this.componentDef;let z,G=null;V.findHostDirectiveDefs?(z=[],G=new Map,V.findHostDirectiveDefs(V,z,G),z.push(V)):z=[V];const Q=function B7(n,t){const e=n[mt],r=fn;return n[r]=t,Pd(e,r,2,"#host",null)}(I,_),ne=function z7(n,t,e,r,s,i,o){const a=s[mt];!function U7(n,t,e,r){for(const s of n)t.mergedAttrs=wp(t.mergedAttrs,s.hostAttrs);null!==t.mergedAttrs&&(rb(t,t.mergedAttrs,!0),null!==e&&eO(r,e,t))}(r,n,t,o);let u=null;null!==t&&(u=CO(t,s[pd]));const c=i.rendererFactory.createRenderer(t,e),p=tb(s,qO(e),null,e.onPush?64:16,s[n.index],n,i,c,null,null,u);return a.firstCreatePass&&AT(a,n,r.length-1),nb(s,p),s[n.index]=p}(Q,_,V,z,I,p,m);M=LN(T,fn),_&&function G7(n,t,e,r){if(r)rx(n,e,["ng-version",zq.full]);else{const{attrs:s,classes:i}=function MH(n){const t=[],e=[];let r=1,s=2;for(;r<n.length;){let i=n[r];if("string"==typeof i)2===s?""!==i&&t.push(i,n[++r]):8===s&&e.push(i);else{if(!Vo(s))break;s=i}r++}return{attrs:t,classes:e}}(t.selectors[0]);s&&rx(n,e,s),i&&i.length>0&&J2(n,e,i.join(" "))}}(m,V,_,r),void 0!==e&&function W7(n,t,e){const r=n.projection=[];for(let s=0;s<t.length;s++){const i=e[s];r.push(null!=i?Array.from(i):null)}}(M,this.ngContentSelectors,e),O=function j7(n,t,e,r,s,i){const o=As(),a=s[mt],u=gi(o,s);ZO(a,s,o,e,null,r);for(let p=0;p<e.length;p++)Ls(Zu(s,a,o.directiveStart+p,o),s);QO(a,s,o),u&&Ls(u,s);const c=Zu(s,a,o.directiveStart+o.componentOffset,o);if(n[Cr]=s[Cr]=c,null!==i)for(const p of i)p(c,t);return ST(a,o,n),c}(ne,V,z,G,I,[H7]),RT(T,I,null)}finally{bx()}return new V7(this.componentType,O,Od(M,I),I,M)}}class V7 extends Mq{constructor(t,e,r,s,i){super(),this.location=r,this._rootLView=s,this._tNode=i,this.previousInputValues=null,this.instance=e,this.hostView=this.changeDetectorRef=new F7(s),this.componentType=t}setInput(t,e){const r=this._tNode.inputs;let s;if(null!==r&&(s=r[t])){if(this.previousInputValues??=new Map,this.previousInputValues.has(t)&&Object.is(this.previousInputValues.get(t),e))return;const i=this._rootLView;OT(i[mt],i,s,t,e),this.previousInputValues.set(t,e),Kp(yi(this._tNode.index,i))}}get injector(){return new vd(this._tNode,this._rootLView)}destroy(){this.hostView.destroy()}onDestroy(t){this.hostView.onDestroy(t)}}function H7(){const n=As();xy(Xe()[mt],n)}function cn(n){let t=function uR(n){return Object.getPrototypeOf(n.prototype).constructor}(n.type),e=!0;const r=[n];for(;t;){let s;if(Uo(n))s=t.\u0275cmp||t.\u0275dir;else{if(t.\u0275cmp)throw new je(903,!1);s=t.\u0275dir}if(s){if(e){r.push(s);const o=n;o.inputs=PT(n.inputs),o.declaredInputs=PT(n.declaredInputs),o.outputs=PT(n.outputs);const a=s.hostBindings;a&&Y7(n,a);const u=s.viewQuery,c=s.contentQueries;if(u&&K7(n,u),c&&X7(n,c),ms(n.inputs,s.inputs),ms(n.declaredInputs,s.declaredInputs),ms(n.outputs,s.outputs),Uo(s)&&s.data.animation){const p=n.data;p.animation=(p.animation||[]).concat(s.data.animation)}}const i=s.features;if(i)for(let o=0;o<i.length;o++){const a=i[o];a&&a.ngInherit&&a(n),a===cn&&(e=!1)}}t=Object.getPrototypeOf(t)}!function q7(n){let t=0,e=null;for(let r=n.length-1;r>=0;r--){const s=n[r];s.hostVars=t+=s.hostVars,s.hostAttrs=wp(s.hostAttrs,e=wp(e,s.hostAttrs))}}(r)}function PT(n){return n===Xa?{}:n===In?[]:n}function K7(n,t){const e=n.viewQuery;n.viewQuery=e?(r,s)=>{t(r,s),e(r,s)}:t}function X7(n,t){const e=n.contentQueries;n.contentQueries=e?(r,s,i)=>{t(r,s,i),e(r,s,i)}:t}function Y7(n,t){const e=n.hostBindings;n.hostBindings=e?(r,s)=>{t(r,s),e(r,s)}:t}function ob(n){return!!FT(n)&&(Array.isArray(n)||!(n instanceof Map)&&Symbol.iterator in n)}function FT(n){return null!==n&&("function"==typeof n||"object"==typeof n)}function ga(n,t,e){return n[t]=e}function Bs(n,t,e){return!Object.is(n[t],e)&&(n[t]=e,!0)}function nc(n,t,e,r){const s=Bs(n,t,e);return Bs(n,t+1,r)||s}function Zs(n,t,e,r){const s=Xe();return Bs(s,bd(),t)&&(wn(),ma(yr(),s,n,t,e,r)),Zs}function $d(n,t,e,r){return Bs(n,bd(),e)?t+Wt(e)+r:Xt}function Ld(n,t,e,r,s,i){const a=nc(n,function Qa(){return Bt.lFrame.bindingIndex}(),e,s);return Ja(2),a?t+Wt(e)+r+Wt(s)+i:Xt}function ya(n,t,e,r,s,i,o,a){const u=Xe(),c=wn(),p=n+fn,m=c.firstCreatePass?function w9(n,t,e,r,s,i,o,a,u){const c=t.consts,p=Pd(t,n,4,o||null,Fl(c,a));DT(t,e,p,Fl(c,u)),xy(t,p);const m=p.tView=ET(2,p,r,s,i,t.directiveRegistry,t.pipeRegistry,null,t.schemas,c,null);return null!==t.queries&&(t.queries.template(t,p),m.queries=t.queries.embeddedTView(p)),p}(p,c,u,t,e,r,s,i,o):c.data[p];pa(m,!1);const y=CR(c,u,m,n);wy()&&Vy(c,u,y,m),Ls(y,u),nb(u,u[p]=eR(y,u,y,m)),my(m)&&CT(c,u,m),null!=o&&IT(u,m,a)}let CR=function IR(n,t,e,r){return $l(!0),t[Kt].createComment("")};function Ir(n,t,e){const r=Xe();return Bs(r,bd(),t)&&Vi(wn(),yr(),r,n,t,r[Kt],e,!1),Ir}function UT(n,t,e,r,s){const o=s?"class":"style";OT(n,e,t.inputs[o],o,r)}function nn(n,t,e,r){const s=Xe(),i=wn(),o=fn+n,a=s[Kt],u=i.firstCreatePass?function C9(n,t,e,r,s,i){const o=t.consts,u=Pd(t,n,2,r,Fl(o,s));return DT(t,e,u,Fl(o,i)),null!==u.attrs&&rb(u,u.attrs,!1),null!==u.mergedAttrs&&rb(u,u.mergedAttrs,!0),null!==t.queries&&t.queries.elementStart(t,u),u}(o,i,s,t,e,r):i.data[o],c=DR(i,s,u,a,t,n);s[o]=c;const p=my(u);return pa(u,!0),eO(a,c,u),32!=(32&u.flags)&&wy()&&Vy(i,s,c,u),0===function c5(){return Bt.lFrame.elementDepthCount}()&&Ls(c,s),function d5(){Bt.lFrame.elementDepthCount++}(),p&&(CT(i,s,u),ST(i,u,s)),null!==r&&IT(s,u),nn}function Yt(){let n=As();hx()?px():(n=n.parent,pa(n,!1));const t=n;(function p5(n){return Bt.skipHydrationRootTNode===n})(t)&&function y5(){Bt.skipHydrationRootTNode=null}(),function h5(){Bt.lFrame.elementDepthCount--}();const e=wn();return e.firstCreatePass&&(xy(e,n),ix(n)&&e.queries.elementEnd(n)),null!=t.classesWithoutHost&&function O5(n){return 0!=(8&n.flags)}(t)&&UT(e,t,Xe(),t.classesWithoutHost,!0),null!=t.stylesWithoutHost&&function R5(n){return 0!=(16&n.flags)}(t)&&UT(e,t,Xe(),t.stylesWithoutHost,!1),Yt}function Qs(n,t,e,r){return nn(n,t,e,r),Yt(),Qs}let DR=(n,t,e,r,s,i)=>($l(!0),$y(r,s,function r2(){return Bt.lFrame.currentNamespace}()));function db(n,t,e){const r=Xe(),s=wn(),i=n+fn,o=s.firstCreatePass?function D9(n,t,e,r,s){const i=t.consts,o=Fl(i,r),a=Pd(t,n,8,"ng-container",o);return null!==o&&rb(a,o,!0),DT(t,e,a,Fl(i,s)),null!==t.queries&&t.queries.elementStart(t,a),a}(i,s,r,t,e):s.data[i];pa(o,!0);const a=kR(s,r,o,n);return r[i]=a,wy()&&Vy(s,r,a,o),Ls(a,r),my(o)&&(CT(s,r,o),ST(s,o,r)),null!=e&&IT(r,o),db}function hb(){let n=As();const t=wn();return hx()?px():(n=n.parent,pa(n,!1)),t.firstCreatePass&&(xy(t,n),ix(n)&&t.queries.elementEnd(n)),hb}let kR=(n,t,e,r)=>($l(!0),zx(t[Kt],""));function sf(n){return!!n&&"function"==typeof n.then}function OR(n){return!!n&&"function"==typeof n.subscribe}function br(n,t,e,r){const s=Xe(),i=wn(),o=As();return function MR(n,t,e,r,s,i,o){const a=my(r),c=n.firstCreatePass&&rR(n),p=t[Cr],m=nR(t);let y=!0;if(3&r.type||o){const T=gi(r,t),I=o?o(T):T,O=m.length,M=o?z=>o(er(z[r.index])):r.index;let V=null;if(!o&&a&&(V=function N9(n,t,e,r){const s=n.cleanup;if(null!=s)for(let i=0;i<s.length-1;i+=2){const o=s[i];if(o===e&&s[i+1]===r){const a=t[hd],u=s[i+2];return a.length>u?a[u]:null}"string"==typeof o&&(i+=2)}return null}(n,t,s,r.index)),null!==V)(V.__ngLastListenerFn__||V).__ngNextListenerFn__=i,V.__ngLastListenerFn__=i,y=!1;else{i=FR(r,t,p,i,!1);const z=e.listen(I,s,i);m.push(i,z),c&&c.push(s,M,O,O+1)}}else i=FR(r,t,p,i,!1);const _=r.outputs;let w;if(y&&null!==_&&(w=_[s])){const T=w.length;if(T)for(let I=0;I<T;I+=2){const G=t[w[I]][w[I+1]].subscribe(i),Q=m.length;m.push(i,G),c&&c.push(s,r.index,Q,-(Q+1))}}}(i,s,s[Kt],o,n,t,r),br}function PR(n,t,e,r){try{return ha(6,t,e),!1!==e(r)}catch(s){return iR(n,s),!1}finally{ha(7,t,e)}}function FR(n,t,e,r,s){return function i(o){if(o===Function)return r;Kp(n.componentOffset>-1?yi(n.index,t):t);let u=PR(t,e,r,o),c=i.__ngNextListenerFn__;for(;c;)u=PR(t,e,c,o)&&u,c=c.__ngNextListenerFn__;return s&&!1===u&&(o.preventDefault(),o.returnValue=!1),u}}function Bl(n=1){return function T5(n){return(Bt.lFrame.contextLView=function S5(n,t){for(;n>0;)t=t[fd],n--;return t}(n,Bt.lFrame.contextLView))[Cr]}(n)}function O9(n,t){let e=null;const r=function DH(n){const t=n.attrs;if(null!=t){const e=t.indexOf(5);if(!(1&e))return t[e+1]}return null}(n);for(let s=0;s<t.length;s++){const i=t[s];if("*"!==i){if(null===r?bN(n,i,!0):NH(r,i))return s}else e=s}return e}function GT(n,t=0,e){const r=Xe(),s=wn(),i=Pd(s,fn+n,16,null,e||null);null===i.projection&&(i.projection=t),px(),(!r[Za]||function Ip(){return null!==Bt.skipHydrationRootTNode}())&&32!=(32&i.flags)&&function V8(n,t,e){Q2(t[Kt],0,t,e,Gx(n,e,t),H2(e.parent||t[$s],e,t))}(s,r,i)}function af(n,t,e){return WT(n,"",t,"",e),af}function WT(n,t,e,r,s){const i=Xe(),o=$d(i,t,e,r);return o!==Xt&&Vi(wn(),yr(),i,n,o,i[Kt],s,!1),WT}function pb(n,t){return n<<17|t<<2}function zl(n){return n>>17&32767}function HT(n){return 2|n}function rc(n){return(131068&n)>>2}function qT(n,t){return-131069&n|t<<2}function KT(n){return 1|n}function WR(n,t,e,r,s){const i=n[e+1],o=null===t;let a=r?zl(i):rc(i),u=!1;for(;0!==a&&(!1===u||o);){const p=n[a+1];L9(n[a],t)&&(u=!0,n[a+1]=r?KT(p):HT(p)),a=r?zl(p):rc(p)}u&&(n[e+1]=r?HT(i):KT(i))}function L9(n,t){return null===n||null==t||(Array.isArray(n)?n[1]:n)===t||!(!Array.isArray(n)||"string"!=typeof t)&&Cd(n,t)>=0}const ss={textEnd:0,key:0,keyEnd:0,value:0,valueEnd:0};function HR(n){return n.substring(ss.key,ss.keyEnd)}function qR(n,t){const e=ss.textEnd;return e===t?-1:(t=ss.keyEnd=function U9(n,t,e){for(;t<e&&n.charCodeAt(t)>32;)t++;return t}(n,ss.key=t,e),Wd(n,t,e))}function Wd(n,t,e){for(;t<e&&n.charCodeAt(t)<=32;)t++;return t}function XT(n,t,e){return jo(n,t,e,!1),XT}function ba(n,t){return jo(n,t,null,!0),ba}function QR(n){!function Go(n,t,e,r){const s=wn(),i=Ja(2);s.firstUpdatePass&&eM(s,null,i,r);const o=Xe();if(e!==Xt&&Bs(o,i,e)){const a=s.data[Ys()];if(sM(a,r)&&!JR(s,i)){let u=r?a.classesWithoutHost:a.stylesWithoutHost;null!==u&&(e=ld(u,e||"")),UT(s,a,o,e,r)}else!function Q9(n,t,e,r,s,i,o,a){s===Xt&&(s=In);let u=0,c=0,p=0<s.length?s[0]:null,m=0<i.length?i[0]:null;for(;null!==p||null!==m;){const y=u<s.length?s[u+1]:void 0,_=c<i.length?i[c+1]:void 0;let T,w=null;p===m?(u+=2,c+=2,y!==_&&(w=m,T=_)):null===m||null!==p&&p<m?(u+=2,w=p):(c+=2,w=m,T=_),null!==w&&nM(n,t,e,r,w,T,o,a),p=u<s.length?s[u]:null,m=c<i.length?i[c]:null}}(s,a,o,o[Kt],o[i+1],o[i+1]=function Y9(n,t,e){if(null==e||""===e)return In;const r=[],s=Ll(e);if(Array.isArray(s))for(let i=0;i<s.length;i++)n(r,s[i],!0);else if("object"==typeof s)for(const i in s)s.hasOwnProperty(i)&&n(r,i,s[i]);else"string"==typeof s&&t(r,s);return r}(n,t,e),r,i)}}(Z9,va,n,!0)}function va(n,t){for(let e=function B9(n){return function XR(n){ss.key=0,ss.keyEnd=0,ss.value=0,ss.valueEnd=0,ss.textEnd=n.length}(n),qR(n,Wd(n,0,ss.textEnd))}(t);e>=0;e=qR(t,e))Li(n,HR(t),!0)}function jo(n,t,e,r){const s=Xe(),i=wn(),o=Ja(2);i.firstUpdatePass&&eM(i,n,o,r),t!==Xt&&Bs(s,o,t)&&nM(i,i.data[Ys()],s,s[Kt],n,s[o+1]=function J9(n,t){return null==n||""===n||("string"==typeof t?n+=t:"object"==typeof n&&(n=Sr(Ll(n)))),n}(t,e),r,o)}function JR(n,t){return t>=n.expandoStartIndex}function eM(n,t,e,r){const s=n.data;if(null===s[e+1]){const i=s[Ys()],o=JR(n,e);sM(i,r)&&null===t&&!o&&(t=!1),t=function H9(n,t,e,r){const s=function mx(n){const t=Bt.lFrame.currentDirectiveIndex;return-1===t?null:n[t]}(n);let i=r?t.residualClasses:t.residualStyles;if(null===s)0===(r?t.classBindings:t.styleBindings)&&(e=lf(e=YT(null,n,t,e,r),t.attrs,r),i=null);else{const o=t.directiveStylingLast;if(-1===o||n[o]!==s)if(e=YT(s,n,t,e,r),null===i){let u=function q9(n,t,e){const r=e?t.classBindings:t.styleBindings;if(0!==rc(r))return n[zl(r)]}(n,t,r);void 0!==u&&Array.isArray(u)&&(u=YT(null,n,t,u[1],r),u=lf(u,t.attrs,r),function K9(n,t,e,r){n[zl(e?t.classBindings:t.styleBindings)]=r}(n,t,r,u))}else i=function X9(n,t,e){let r;const s=t.directiveEnd;for(let i=1+t.directiveStylingLast;i<s;i++)r=lf(r,n[i].hostAttrs,e);return lf(r,t.attrs,e)}(n,t,r)}return void 0!==i&&(r?t.residualClasses=i:t.residualStyles=i),e}(s,i,t,r),function F9(n,t,e,r,s,i){let o=i?t.classBindings:t.styleBindings,a=zl(o),u=rc(o);n[r]=e;let p,c=!1;if(Array.isArray(e)?(p=e[1],(null===p||Cd(e,p)>0)&&(c=!0)):p=e,s)if(0!==u){const y=zl(n[a+1]);n[r+1]=pb(y,a),0!==y&&(n[y+1]=qT(n[y+1],r)),n[a+1]=function M9(n,t){return 131071&n|t<<17}(n[a+1],r)}else n[r+1]=pb(a,0),0!==a&&(n[a+1]=qT(n[a+1],r)),a=r;else n[r+1]=pb(u,0),0===a?a=r:n[u+1]=qT(n[u+1],r),u=r;c&&(n[r+1]=HT(n[r+1])),WR(n,p,r,!0),WR(n,p,r,!1),function $9(n,t,e,r,s){const i=s?n.residualClasses:n.residualStyles;null!=i&&"string"==typeof t&&Cd(i,t)>=0&&(e[r+1]=KT(e[r+1]))}(t,p,n,r,i),o=pb(a,u),i?t.classBindings=o:t.styleBindings=o}(s,i,t,e,o,r)}}function YT(n,t,e,r,s){let i=null;const o=e.directiveEnd;let a=e.directiveStylingLast;for(-1===a?a=e.directiveStart:a++;a<o&&(i=t[a],r=lf(r,i.hostAttrs,s),i!==n);)a++;return null!==n&&(e.directiveStylingLast=a),r}function lf(n,t,e){const r=e?1:2;let s=-1;if(null!==t)for(let i=0;i<t.length;i++){const o=t[i];"number"==typeof o?s=o:s===r&&(Array.isArray(n)||(n=void 0===n?[]:["",n]),Li(n,o,!!e||t[++i]))}return void 0===n?null:n}function Z9(n,t,e){const r=String(t);""!==r&&!r.includes(" ")&&Li(n,r,e)}function nM(n,t,e,r,s,i,o,a){if(!(3&t.type))return;const u=n.data,c=u[a+1],p=function P9(n){return 1==(1&n)}(c)?rM(u,t,e,s,rc(c),o):void 0;fb(p)||(fb(i)||function R9(n){return 2==(2&n)}(c)&&(i=rM(u,null,e,s,a,o)),function z8(n,t,e,r,s){if(t)s?n.addClass(e,r):n.removeClass(e,r);else{let i=-1===r.indexOf("-")?void 0:bi.DashCase;null==s?n.removeStyle(e,r,i):("string"==typeof s&&s.endsWith("!important")&&(s=s.slice(0,-10),i|=bi.Important),n.setStyle(e,r,s,i))}}(r,o,_y(Ys(),e),s,i))}function rM(n,t,e,r,s,i){const o=null===t;let a;for(;s>0;){const u=n[s],c=Array.isArray(u),p=c?u[1]:u,m=null===p;let y=e[s+1];y===Xt&&(y=m?In:void 0);let _=m?Ex(y,r):p===r?y:void 0;if(c&&!fb(_)&&(_=Ex(u,r)),fb(_)&&(a=_,o))return a;const w=n[s+1];s=o?zl(w):rc(w)}if(null!==t){let u=i?t.residualClasses:t.residualStyles;null!=u&&(a=Ex(u,r))}return a}function fb(n){return void 0!==n}function sM(n,t){return 0!=(n.flags&(t?8:16))}function Er(n,t=""){const e=Xe(),r=wn(),s=n+fn,i=r.firstCreatePass?Pd(r,s,1,t,null):r.data[s],o=iM(r,e,i,t,n);e[s]=o,wy()&&Vy(r,e,o,i),pa(i,!1)}let iM=(n,t,e,r,s)=>($l(!0),function Fy(n,t){return n.createText(t)}(t[Kt],r));function sc(n){return ic("",n,""),sc}function ic(n,t,e){const r=Xe(),s=$d(r,n,t,e);return s!==Xt&&sl(r,Ys(),s),ic}function ZT(n,t,e,r,s){const i=Xe(),o=Ld(i,n,t,e,r,s);return o!==Xt&&sl(i,Ys(),o),ZT}function QT(n,t,e){const r=Xe();return Bs(r,bd(),t)&&Vi(wn(),yr(),r,n,t,r[Kt],e,!0),QT}const oc=void 0;var wK=["en",[["a","p"],["AM","PM"],oc],[["AM","PM"],oc,oc],[["S","M","T","W","T","F","S"],["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],["Su","Mo","Tu","We","Th","Fr","Sa"]],oc,[["J","F","M","A","M","J","J","A","S","O","N","D"],["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],["January","February","March","April","May","June","July","August","September","October","November","December"]],oc,[["B","A"],["BC","AD"],["Before Christ","Anno Domini"]],0,[6,0],["M/d/yy","MMM d, y","MMMM d, y","EEEE, MMMM d, y"],["h:mm a","h:mm:ss a","h:mm:ss a z","h:mm:ss a zzzz"],["{1}, {0}",oc,"{1} 'at' {0}",oc],[".",",",";","%","+","-","E","\xd7","\u2030","\u221e","NaN",":"],["#,##0.###","#,##0%","\xa4#,##0.00","#E0"],"USD","$","US Dollar",{},"ltr",function vK(n){const e=Math.floor(Math.abs(n)),r=n.toString().replace(/^[^.]*\.?/,"").length;return 1===e&&0===r?1:5}];let Hd={};function Js(n){const t=function xK(n){return n.toLowerCase().replace(/_/g,"-")}(n);let e=SM(t);if(e)return e;const r=t.split("-")[0];if(e=SM(r),e)return e;if("en"===r)return wK;throw new je(701,!1)}function SM(n){return n in Hd||(Hd[n]=Xn.ng&&Xn.ng.common&&Xn.ng.common.locales&&Xn.ng.common.locales[n]),Hd[n]}var gt=(()=>((gt=gt||{})[gt.LocaleId=0]="LocaleId",gt[gt.DayPeriodsFormat=1]="DayPeriodsFormat",gt[gt.DayPeriodsStandalone=2]="DayPeriodsStandalone",gt[gt.DaysFormat=3]="DaysFormat",gt[gt.DaysStandalone=4]="DaysStandalone",gt[gt.MonthsFormat=5]="MonthsFormat",gt[gt.MonthsStandalone=6]="MonthsStandalone",gt[gt.Eras=7]="Eras",gt[gt.FirstDayOfWeek=8]="FirstDayOfWeek",gt[gt.WeekendRange=9]="WeekendRange",gt[gt.DateFormat=10]="DateFormat",gt[gt.TimeFormat=11]="TimeFormat",gt[gt.DateTimeFormat=12]="DateTimeFormat",gt[gt.NumberSymbols=13]="NumberSymbols",gt[gt.NumberFormats=14]="NumberFormats",gt[gt.CurrencyCode=15]="CurrencyCode",gt[gt.CurrencySymbol=16]="CurrencySymbol",gt[gt.CurrencyName=17]="CurrencyName",gt[gt.Currencies=18]="Currencies",gt[gt.Directionality=19]="Directionality",gt[gt.PluralCase=20]="PluralCase",gt[gt.ExtraData=21]="ExtraData",gt))();const qd="en-US";let CM=qd;function tS(n,t,e,r,s){if(n=_t(n),Array.isArray(n))for(let i=0;i<n.length;i++)tS(n[i],t,e,r,s);else{const i=wn(),o=Xe();let a=Ju(n)?n:_t(n.provide),u=wO(n);const c=As(),p=1048575&c.providerIndexes,m=c.directiveStart,y=c.providerIndexes>>20;if(Ju(n)||!n.multi){const _=new Dp(u,s,Ee),w=rS(a,t,s?p:p+y,m);-1===w?(Sx(Dy(c,o),i,a),nS(i,n,t.length),t.push(a),c.directiveStart++,c.directiveEnd++,s&&(c.providerIndexes+=1048576),e.push(_),o.push(_)):(e[w]=_,o[w]=_)}else{const _=rS(a,t,p+y,m),w=rS(a,t,p,p+y),I=w>=0&&e[w];if(s&&!I||!s&&!(_>=0&&e[_])){Sx(Dy(c,o),i,a);const O=function _X(n,t,e,r,s){const i=new Dp(n,e,Ee);return i.multi=[],i.index=t,i.componentProviders=0,YM(i,s,r&&!e),i}(s?bX:yX,e.length,s,r,u);!s&&I&&(e[w].providerFactory=O),nS(i,n,t.length,0),t.push(a),c.directiveStart++,c.directiveEnd++,s&&(c.providerIndexes+=1048576),e.push(O),o.push(O)}else nS(i,n,_>-1?_:w,YM(e[s?w:_],u,!s&&r));!s&&r&&I&&e[w].componentProviders++}}}function nS(n,t,e,r){const s=Ju(t),i=function yq(n){return!!n.useClass}(t);if(s||i){const u=(i?_t(t.useClass):t).prototype.ngOnDestroy;if(u){const c=n.destroyHooks||(n.destroyHooks=[]);if(!s&&t.multi){const p=c.indexOf(e);-1===p?c.push(e,[r,u]):c[p+1].push(r,u)}else c.push(e,u)}}}function YM(n,t,e){return e&&n.componentProviders++,n.multi.push(t)-1}function rS(n,t,e,r){for(let s=e;s<r;s++)if(t[s]===n)return s;return-1}function yX(n,t,e,r){return sS(this.multi,[])}function bX(n,t,e,r){const s=this.multi;let i;if(this.providerFactory){const o=this.providerFactory.componentProviders,a=Zu(e,e[mt],this.providerFactory.index,r);i=a.slice(0,o),sS(s,i);for(let u=o;u<a.length;u++)i.push(a[u])}else i=[],sS(s,i);return i}function sS(n,t){for(let e=0;e<n.length;e++)t.push((0,n[e])());return t}function Fn(n,t=[]){return e=>{e.providersResolver=(r,s)=>function gX(n,t,e){const r=wn();if(r.firstCreatePass){const s=Uo(n);tS(e,r.data,r.blueprint,s,!0),tS(t,r.data,r.blueprint,s,!1)}}(r,s?s(n):n,t)}}class Kd{}class ZM{}class iS extends Kd{constructor(t,e,r){super(),this._parent=e,this._bootstrapComponents=[],this.destroyCbs=[],this.componentFactoryResolver=new aR(this);const s=Pi(t);this._bootstrapComponents=rl(s.bootstrap),this._r3Injector=WO(t,e,[{provide:Kd,useValue:this},{provide:Nd,useValue:this.componentFactoryResolver},...r],Sr(t),new Set(["environment"])),this._r3Injector.resolveInjectorInitializers(),this.instance=this._r3Injector.get(t)}get injector(){return this._r3Injector}destroy(){const t=this._r3Injector;!t.destroyed&&t.destroy(),this.destroyCbs.forEach(e=>e()),this.destroyCbs=null}onDestroy(t){this.destroyCbs.push(t)}}class oS extends ZM{constructor(t){super(),this.moduleType=t}create(t){return new iS(this.moduleType,t,[])}}class QM extends Kd{constructor(t){super(),this.componentFactoryResolver=new aR(this),this.instance=null;const e=new aT([...t.providers,{provide:Kd,useValue:this},{provide:Nd,useValue:this.componentFactoryResolver}],t.parent||Wy(),t.debugName,new Set(["environment"]));this.injector=e,t.runEnvironmentInitializers&&e.resolveInjectorInitializers()}destroy(){this.injector.destroy()}onDestroy(t){this.injector.onDestroy(t)}}function aS(n,t,e=null){return new QM({providers:n,parent:t,debugName:e,runEnvironmentInitializers:!0}).injector}let xX=(()=>{class n{constructor(e){this._injector=e,this.cachedInjectors=new Map}getOrCreateStandaloneInjector(e){if(!e.standalone)return null;if(!this.cachedInjectors.has(e.id)){const r=yO(0,e.type),s=r.length>0?aS([r],this._injector,`Standalone[${e.type.name}]`):null;this.cachedInjectors.set(e.id,s)}return this.cachedInjectors.get(e.id)}ngOnDestroy(){try{for(const e of this.cachedInjectors.values())null!==e&&e.destroy()}finally{this.cachedInjectors.clear()}}}return n.\u0275prov=ht({token:n,providedIn:"environment",factory:()=>new n(Le(tl))}),n})();function JM(n){n.getStandaloneInjector=t=>t.get(xX).getOrCreateStandaloneInjector(n)}function uS(n,t,e,r,s,i){return function lP(n,t,e,r,s,i,o,a){const u=t+e;return function ab(n,t,e,r,s){const i=nc(n,t,e,r);return Bs(n,t+2,s)||i}(n,u,s,i,o)?ga(n,u+3,a?r.call(a,s,i,o):r(s,i,o)):ff(n,u+3)}(Xe(),Xs(),n,t,e,r,s,i)}function ff(n,t){const e=n[t];return e===Xt?void 0:e}function mf(n,t){const e=wn();let r;const s=n+fn;e.firstCreatePass?(r=function BX(n,t){if(t)for(let e=t.length-1;e>=0;e--){const r=t[e];if(n===r.name)return r}}(t,e.pipeRegistry),e.data[s]=r,r.onDestroy&&(e.destroyHooks??=[]).push(s,r.onDestroy)):r=e.data[s];const i=r.factory||(r.factory=Xu(r.type)),o=hi(Ee);try{const a=Ey(!1),u=i();return Ey(a),function S9(n,t,e,r){e>=n.data.length&&(n.data[e]=null,n.blueprint[e]=null),t[e]=r}(e,Xe(),s,u),u}finally{hi(o)}}function gf(n,t,e,r){const s=n+fn,i=Xe(),o=function yd(n,t){return n[t]}(i,s);return function yf(n,t){return n[mt].data[t].pure}(i,s)?function aP(n,t,e,r,s,i,o){const a=t+e;return nc(n,a,s,i)?ga(n,a+2,o?r.call(o,s,i):r(s,i)):ff(n,a+2)}(i,Xs(),t,o.transform,e,r,o):o.transform(e,r)}function cS(n){return t=>{setTimeout(n,void 0,t)}}const On=class WX extends vn{constructor(t=!1){super(),this.__isAsync=t}emit(t){super.next(t)}subscribe(t,e,r){let s=t,i=e||(()=>null),o=r;if(t&&"object"==typeof t){const u=t;s=u.next?.bind(u),i=u.error?.bind(u),o=u.complete?.bind(u)}this.__isAsync&&(i=cS(i),s&&(s=cS(s)),o&&(o=cS(o)));const a=super.subscribe({next:s,error:i,complete:o});return t instanceof ce&&t.add(a),a}};function HX(){return this._results[Symbol.iterator]()}class dS{get changes(){return this._changes||(this._changes=new On)}constructor(t=!1){this._emitDistinctChangesOnly=t,this.dirty=!0,this._results=[],this._changesDetected=!1,this._changes=null,this.length=0,this.first=void 0,this.last=void 0;const e=dS.prototype;e[Symbol.iterator]||(e[Symbol.iterator]=HX)}get(t){return this._results[t]}map(t){return this._results.map(t)}filter(t){return this._results.filter(t)}find(t){return this._results.find(t)}reduce(t,e){return this._results.reduce(t,e)}forEach(t){this._results.forEach(t)}some(t){return this._results.some(t)}toArray(){return this._results.slice()}toString(){return this._results.toString()}reset(t,e){const r=this;r.dirty=!1;const s=function oo(n){return n.flat(Number.POSITIVE_INFINITY)}(t);(this._changesDetected=!function G5(n,t,e){if(n.length!==t.length)return!1;for(let r=0;r<n.length;r++){let s=n[r],i=t[r];if(e&&(s=e(s),i=e(i)),i!==s)return!1}return!0}(r._results,s,e))&&(r._results=s,r.length=s.length,r.last=s[this.length-1],r.first=s[0])}notifyOnChanges(){this._changes&&(this._changesDetected||!this._emitDistinctChangesOnly)&&this._changes.emit(this)}setDirty(){this.dirty=!0}destroy(){this.changes.complete(),this.changes.unsubscribe()}}let wa=(()=>{class n{}return n.__NG_ELEMENT_ID__=XX,n})();const qX=wa,KX=class extends qX{constructor(t,e,r){super(),this._declarationLView=t,this._declarationTContainer=e,this.elementRef=r}get ssrId(){return this._declarationTContainer.tView?.ssrId||null}createEmbeddedView(t,e){return this.createEmbeddedViewImpl(t,e,null)}createEmbeddedViewImpl(t,e,r){const s=this._declarationTContainer.tView,i=tb(this._declarationLView,s,t,16,null,s.declTNode,null,null,null,e||null,r||null);i[Tp]=this._declarationLView[this._declarationTContainer.index];const a=this._declarationLView[ua];return null!==a&&(i[ua]=a.createEmbeddedView(s)),RT(s,i,t),new Zp(i)}};function XX(){return _b(As(),Xe())}function _b(n,t){return 4&n.type?new KX(t,n,Od(n,t)):null}let lo=(()=>{class n{}return n.__NG_ELEMENT_ID__=nY,n})();function nY(){return gP(As(),Xe())}const rY=lo,fP=class extends rY{constructor(t,e,r){super(),this._lContainer=t,this._hostTNode=e,this._hostLView=r}get element(){return Od(this._hostTNode,this._hostLView)}get injector(){return new vd(this._hostTNode,this._hostLView)}get parentInjector(){const t=Tx(this._hostTNode,this._hostLView);if(l2(t)){const e=Iy(t,this._hostLView),r=Cy(t);return new vd(e[mt].data[r+8],e)}return new vd(null,this._hostLView)}clear(){for(;this.length>0;)this.remove(this.length-1)}get(t){const e=mP(this._lContainer);return null!==e&&e[t]||null}get length(){return this._lContainer.length-Ds}createEmbeddedView(t,e,r){let s,i;"number"==typeof r?s=r:null!=r&&(s=r.index,i=r.injector);const a=t.createEmbeddedViewImpl(e||{},i,null);return this.insertImpl(a,s,!1),a}createComponent(t,e,r,s,i){const o=t&&!function Np(n){return"function"==typeof n}(t);let a;if(o)a=e;else{const w=e||{};a=w.index,r=w.injector,s=w.projectableNodes,i=w.environmentInjector||w.ngModuleRef}const u=o?t:new Qp(En(t)),c=r||this.parentInjector;if(!i&&null==u.ngModule){const T=(o?c:this.parentInjector).get(tl,null);T&&(i=T)}En(u.componentType??{});const _=u.create(c,s,null,i);return this.insertImpl(_.hostView,a,!1),_}insert(t,e){return this.insertImpl(t,e,!1)}insertImpl(t,e,r){const s=t._lView,i=s[mt];if(function a5(n){return $i(n[gr])}(s)){const u=this.indexOf(t);if(-1!==u)this.detach(u);else{const c=s[gr],p=new fP(c,c[$s],c[gr]);p.detach(p.indexOf(t))}}const o=this._adjustIndex(e),a=this._lContainer;if(function R8(n,t,e,r){const s=Ds+r,i=e.length;r>0&&(e[s-1][zo]=t),r<i-Ds?(t[zo]=e[s],v2(e,Ds+r,t)):(e.push(t),t[zo]=null),t[gr]=e;const o=t[Tp];null!==o&&e!==o&&function M8(n,t){const e=n[gd];t[jr]!==t[gr][gr][jr]&&(n[CN]=!0),null===e?n[gd]=[t]:e.push(t)}(o,t);const a=t[ua];null!==a&&a.insertView(n),t[Jt]|=128}(i,s,a,o),!r){const u=Hx(o,a),c=s[Kt],p=Ly(c,a[ca]);null!==p&&function k8(n,t,e,r,s,i){r[gs]=s,r[$s]=t,Lp(n,r,e,1,s,i)}(i,a[$s],c,s,p,u)}return t.attachToViewContainerRef(),v2(pS(a),o,t),t}move(t,e){return this.insert(t,e)}indexOf(t){const e=mP(this._lContainer);return null!==e?e.indexOf(t):-1}remove(t){const e=this._adjustIndex(t,-1),r=Ux(this._lContainer,e);r&&(ky(pS(this._lContainer),e),U2(r[mt],r))}detach(t){const e=this._adjustIndex(t,-1),r=Ux(this._lContainer,e);return r&&null!=ky(pS(this._lContainer),e)?new Zp(r):null}_adjustIndex(t,e=0){return t??this.length+e}};function mP(n){return n[fy]}function pS(n){return n[fy]||(n[fy]=[])}function gP(n,t){let e;const r=t[n.index];return $i(r)?e=r:(e=eR(r,t,null,n),t[n.index]=e,nb(t,e)),yP(e,t,n,r),new fP(e,n,t)}let yP=function bP(n,t,e,r){if(n[ca])return;let s;s=8&e.type?er(r):function sY(n,t){const e=n[Kt],r=e.createComment(""),s=gi(t,n);return Qu(e,Ly(e,s),r,function L8(n,t){return n.nextSibling(t)}(e,s),!1),r}(t,e),n[ca]=s};class fS{constructor(t){this.queryList=t,this.matches=null}clone(){return new fS(this.queryList)}setDirty(){this.queryList.setDirty()}}class mS{constructor(t=[]){this.queries=t}createEmbeddedView(t){const e=t.queries;if(null!==e){const r=null!==t.contentQueries?t.contentQueries[0]:e.length,s=[];for(let i=0;i<r;i++){const o=e.getByIndex(i);s.push(this.queries[o.indexInDeclarationView].clone())}return new mS(s)}return null}insertView(t){this.dirtyQueriesWithMatches(t)}detachView(t){this.dirtyQueriesWithMatches(t)}dirtyQueriesWithMatches(t){for(let e=0;e<this.queries.length;e++)null!==TP(t,e).matches&&this.queries[e].setDirty()}}class _P{constructor(t,e,r=null){this.predicate=t,this.flags=e,this.read=r}}class gS{constructor(t=[]){this.queries=t}elementStart(t,e){for(let r=0;r<this.queries.length;r++)this.queries[r].elementStart(t,e)}elementEnd(t){for(let e=0;e<this.queries.length;e++)this.queries[e].elementEnd(t)}embeddedTView(t){let e=null;for(let r=0;r<this.length;r++){const s=null!==e?e.length:0,i=this.getByIndex(r).embeddedTView(t,s);i&&(i.indexInDeclarationView=r,null!==e?e.push(i):e=[i])}return null!==e?new gS(e):null}template(t,e){for(let r=0;r<this.queries.length;r++)this.queries[r].template(t,e)}getByIndex(t){return this.queries[t]}get length(){return this.queries.length}track(t){this.queries.push(t)}}class yS{constructor(t,e=-1){this.metadata=t,this.matches=null,this.indexInDeclarationView=-1,this.crossesNgTemplate=!1,this._appliesToNextNode=!0,this._declarationNodeIndex=e}elementStart(t,e){this.isApplyingToNode(e)&&this.matchTNode(t,e)}elementEnd(t){this._declarationNodeIndex===t.index&&(this._appliesToNextNode=!1)}template(t,e){this.elementStart(t,e)}embeddedTView(t,e){return this.isApplyingToNode(t)?(this.crossesNgTemplate=!0,this.addMatch(-t.index,e),new yS(this.metadata)):null}isApplyingToNode(t){if(this._appliesToNextNode&&1!=(1&this.metadata.flags)){const e=this._declarationNodeIndex;let r=t.parent;for(;null!==r&&8&r.type&&r.index!==e;)r=r.parent;return e===(null!==r?r.index:-1)}return this._appliesToNextNode}matchTNode(t,e){const r=this.metadata.predicate;if(Array.isArray(r))for(let s=0;s<r.length;s++){const i=r[s];this.matchTNodeWithReadOption(t,e,aY(e,i)),this.matchTNodeWithReadOption(t,e,Ay(e,t,i,!1,!1))}else r===wa?4&e.type&&this.matchTNodeWithReadOption(t,e,-1):this.matchTNodeWithReadOption(t,e,Ay(e,t,r,!1,!1))}matchTNodeWithReadOption(t,e,r){if(null!==r){const s=this.metadata.read;if(null!==s)if(s===tr||s===lo||s===wa&&4&e.type)this.addMatch(e.index,-2);else{const i=Ay(e,t,s,!1,!1);null!==i&&this.addMatch(e.index,i)}else this.addMatch(e.index,r)}}addMatch(t,e){null===this.matches?this.matches=[t,e]:this.matches.push(t,e)}}function aY(n,t){const e=n.localNames;if(null!==e)for(let r=0;r<e.length;r+=2)if(e[r]===t)return e[r+1];return null}function uY(n,t,e,r){return-1===e?function lY(n,t){return 11&n.type?Od(n,t):4&n.type?_b(n,t):null}(t,n):-2===e?function cY(n,t,e){return e===tr?Od(t,n):e===wa?_b(t,n):e===lo?gP(t,n):void 0}(n,t,r):Zu(n,n[mt],e,t)}function vP(n,t,e,r){const s=t[ua].queries[r];if(null===s.matches){const i=n.data,o=e.matches,a=[];for(let u=0;u<o.length;u+=2){const c=o[u];a.push(c<0?null:uY(t,i[c],o[u+1],e.metadata.read))}s.matches=a}return s.matches}function bS(n,t,e,r){const s=n.queries.getByIndex(e),i=s.matches;if(null!==i){const o=vP(n,t,s,e);for(let a=0;a<i.length;a+=2){const u=i[a];if(u>0)r.push(o[a/2]);else{const c=i[a+1],p=t[-u];for(let m=Ds;m<p.length;m++){const y=p[m];y[Tp]===y[gr]&&bS(y[mt],y,c,r)}if(null!==p[gd]){const m=p[gd];for(let y=0;y<m.length;y++){const _=m[y];bS(_[mt],_,c,r)}}}}}return r}function uo(n){const t=Xe(),e=wn(),r=ZN();gx(r+1);const s=TP(e,r);if(n.dirty&&function o5(n){return 4==(4&n[Jt])}(t)===(2==(2&s.metadata.flags))){if(null===s.matches)n.reset([]);else{const i=s.crossesNgTemplate?bS(e,t,r,[]):vP(e,t,s,r);n.reset(i,Lq),n.notifyOnChanges()}return!0}return!1}function Ul(n,t,e){const r=wn();r.firstCreatePass&&(xP(r,new _P(n,t,e),-1),2==(2&t)&&(r.staticViewQueries=!0)),wP(r,Xe(),t)}function bf(n,t,e,r){const s=wn();if(s.firstCreatePass){const i=As();xP(s,new _P(t,e,r),i.index),function hY(n,t){const e=n.contentQueries||(n.contentQueries=[]);t!==(e.length?e[e.length-1]:-1)&&e.push(n.queries.length-1,t)}(s,n),2==(2&e)&&(s.staticContentQueries=!0)}wP(s,Xe(),e)}function co(){return function dY(n,t){return n[ua].queries[t].queryList}(Xe(),ZN())}function wP(n,t,e){const r=new dS(4==(4&e));(function a7(n,t,e,r){const s=nR(t);s.push(e),n.firstCreatePass&&rR(n).push(r,s.length-1)})(n,t,r,r.destroy),null===t[ua]&&(t[ua]=new mS),t[ua].queries.push(new fS(r))}function xP(n,t,e){null===n.queries&&(n.queries=new gS),n.queries.track(new yS(t,e))}function TP(n,t){return n.queries.getByIndex(t)}const SS=new st("Application Initializer");let CS=(()=>{class n{constructor(){this.initialized=!1,this.done=!1,this.donePromise=new Promise((e,r)=>{this.resolve=e,this.reject=r}),this.appInits=Ct(SS,{optional:!0})??[]}runInitializers(){if(this.initialized)return;const e=[];for(const s of this.appInits){const i=s();if(sf(i))e.push(i);else if(OR(i)){const o=new Promise((a,u)=>{i.subscribe({complete:a,error:u})});e.push(o)}}const r=()=>{this.done=!0,this.resolve()};Promise.all(e).then(()=>{r()}).catch(s=>{this.reject(s)}),0===e.length&&r(),this.initialized=!0}}return n.\u0275fac=function(e){return new(e||n)},n.\u0275prov=ht({token:n,factory:n.\u0275fac,providedIn:"root"}),n})(),BP=(()=>{class n{log(e){console.log(e)}warn(e){console.warn(e)}}return n.\u0275fac=function(e){return new(e||n)},n.\u0275prov=ht({token:n,factory:n.\u0275fac,providedIn:"platform"}),n})();const xa=new st("LocaleId",{providedIn:"root",factory:()=>Ct(xa,$t.Optional|$t.SkipSelf)||function MY(){return typeof $localize<"u"&&$localize.locale||qd}()});class FY{constructor(t,e){this.ngModuleFactory=t,this.componentFactories=e}}let zP=(()=>{class n{compileModuleSync(e){return new oS(e)}compileModuleAsync(e){return Promise.resolve(this.compileModuleSync(e))}compileModuleAndAllComponentsSync(e){const r=this.compileModuleSync(e),i=rl(Pi(e).declarations).reduce((o,a)=>{const u=En(a);return u&&o.push(new Qp(u)),o},[]);return new FY(r,i)}compileModuleAndAllComponentsAsync(e){return Promise.resolve(this.compileModuleAndAllComponentsSync(e))}clearCache(){}clearCacheFor(e){}getModuleId(e){}}return n.\u0275fac=function(e){return new(e||n)},n.\u0275prov=ht({token:n,factory:n.\u0275fac,providedIn:"root"}),n})();const VY=(()=>Promise.resolve(0))();function IS(n){typeof Zone>"u"?VY.then(()=>{n&&n.apply(null,null)}):Zone.current.scheduleMicroTask("scheduleMicrotask",n)}function GP(...n){}class Zt{constructor({enableLongStackTrace:t=!1,shouldCoalesceEventChangeDetection:e=!1,shouldCoalesceRunChangeDetection:r=!1}){if(this.hasPendingMacrotasks=!1,this.hasPendingMicrotasks=!1,this.isStable=!0,this.onUnstable=new On(!1),this.onMicrotaskEmpty=new On(!1),this.onStable=new On(!1),this.onError=new On(!1),typeof Zone>"u")throw new je(908,!1);Zone.assertZonePatched();const s=this;s._nesting=0,s._outer=s._inner=Zone.current,Zone.TaskTrackingZoneSpec&&(s._inner=s._inner.fork(new Zone.TaskTrackingZoneSpec)),t&&Zone.longStackTraceZoneSpec&&(s._inner=s._inner.fork(Zone.longStackTraceZoneSpec)),s.shouldCoalesceEventChangeDetection=!r&&e,s.shouldCoalesceRunChangeDetection=r,s.lastRequestAnimationFrameId=-1,s.nativeRequestAnimationFrame=function BY(){let n=Xn.requestAnimationFrame,t=Xn.cancelAnimationFrame;if(typeof Zone<"u"&&n&&t){const e=n[Zone.__symbol__("OriginalDelegate")];e&&(n=e);const r=t[Zone.__symbol__("OriginalDelegate")];r&&(t=r)}return{nativeRequestAnimationFrame:n,nativeCancelAnimationFrame:t}}().nativeRequestAnimationFrame,function jY(n){const t=()=>{!function UY(n){n.isCheckStableRunning||-1!==n.lastRequestAnimationFrameId||(n.lastRequestAnimationFrameId=n.nativeRequestAnimationFrame.call(Xn,()=>{n.fakeTopEventTask||(n.fakeTopEventTask=Zone.root.scheduleEventTask("fakeTopEventTask",()=>{n.lastRequestAnimationFrameId=-1,DS(n),n.isCheckStableRunning=!0,ES(n),n.isCheckStableRunning=!1},void 0,()=>{},()=>{})),n.fakeTopEventTask.invoke()}),DS(n))}(n)};n._inner=n._inner.fork({name:"angular",properties:{isAngularZone:!0},onInvokeTask:(e,r,s,i,o,a)=>{try{return WP(n),e.invokeTask(s,i,o,a)}finally{(n.shouldCoalesceEventChangeDetection&&"eventTask"===i.type||n.shouldCoalesceRunChangeDetection)&&t(),HP(n)}},onInvoke:(e,r,s,i,o,a,u)=>{try{return WP(n),e.invoke(s,i,o,a,u)}finally{n.shouldCoalesceRunChangeDetection&&t(),HP(n)}},onHasTask:(e,r,s,i)=>{e.hasTask(s,i),r===s&&("microTask"==i.change?(n._hasPendingMicrotasks=i.microTask,DS(n),ES(n)):"macroTask"==i.change&&(n.hasPendingMacrotasks=i.macroTask))},onHandleError:(e,r,s,i)=>(e.handleError(s,i),n.runOutsideAngular(()=>n.onError.emit(i)),!1)})}(s)}static isInAngularZone(){return typeof Zone<"u"&&!0===Zone.current.get("isAngularZone")}static assertInAngularZone(){if(!Zt.isInAngularZone())throw new je(909,!1)}static assertNotInAngularZone(){if(Zt.isInAngularZone())throw new je(909,!1)}run(t,e,r){return this._inner.run(t,e,r)}runTask(t,e,r,s){const i=this._inner,o=i.scheduleEventTask("NgZoneEvent: "+s,t,zY,GP,GP);try{return i.runTask(o,e,r)}finally{i.cancelTask(o)}}runGuarded(t,e,r){return this._inner.runGuarded(t,e,r)}runOutsideAngular(t){return this._outer.run(t)}}const zY={};function ES(n){if(0==n._nesting&&!n.hasPendingMicrotasks&&!n.isStable)try{n._nesting++,n.onMicrotaskEmpty.emit(null)}finally{if(n._nesting--,!n.hasPendingMicrotasks)try{n.runOutsideAngular(()=>n.onStable.emit(null))}finally{n.isStable=!0}}}function DS(n){n.hasPendingMicrotasks=!!(n._hasPendingMicrotasks||(n.shouldCoalesceEventChangeDetection||n.shouldCoalesceRunChangeDetection)&&-1!==n.lastRequestAnimationFrameId)}function WP(n){n._nesting++,n.isStable&&(n.isStable=!1,n.onUnstable.emit(null))}function HP(n){n._nesting--,ES(n)}class GY{constructor(){this.hasPendingMicrotasks=!1,this.hasPendingMacrotasks=!1,this.isStable=!0,this.onUnstable=new On,this.onMicrotaskEmpty=new On,this.onStable=new On,this.onError=new On}run(t,e,r){return t.apply(e,r)}runGuarded(t,e,r){return t.apply(e,r)}runOutsideAngular(t){return t()}runTask(t,e,r,s){return t.apply(e,r)}}const qP=new st("",{providedIn:"root",factory:KP});function KP(){const n=Ct(Zt);let t=!0;return Dt(new Dn(s=>{t=n.isStable&&!n.hasPendingMacrotasks&&!n.hasPendingMicrotasks,n.runOutsideAngular(()=>{s.next(t),s.complete()})}),new Dn(s=>{let i;n.runOutsideAngular(()=>{i=n.onStable.subscribe(()=>{Zt.assertNotInAngularZone(),IS(()=>{!t&&!n.hasPendingMacrotasks&&!n.hasPendingMicrotasks&&(t=!0,s.next(!0))})})});const o=n.onUnstable.subscribe(()=>{Zt.assertInAngularZone(),t&&(t=!1,n.runOutsideAngular(()=>{s.next(!1)}))});return()=>{i.unsubscribe(),o.unsubscribe()}}).pipe(function mr(n={}){const{connector:t=(()=>new vn),resetOnError:e=!0,resetOnComplete:r=!0,resetOnRefCountZero:s=!0}=n;return i=>{let o,a,u,c=0,p=!1,m=!1;const y=()=>{a?.unsubscribe(),a=void 0},_=()=>{y(),o=u=void 0,p=m=!1},w=()=>{const T=o;_(),T?.unsubscribe()};return An((T,I)=>{c++,!m&&!p&&y();const O=u=u??t();I.add(()=>{c--,0===c&&!m&&!p&&(a=Ps(w,s))}),O.subscribe(I),!o&&c>0&&(o=new Pr({next:M=>O.next(M),error:M=>{m=!0,y(),a=Ps(_,e,M),O.error(M)},complete:()=>{p=!0,y(),a=Ps(_,r),O.complete()}}),fs(T).subscribe(o))})(i)}}()))}const XP=new st(""),wb=new st("");let NS,AS=(()=>{class n{constructor(e,r,s){this._ngZone=e,this.registry=r,this._pendingCount=0,this._isZoneStable=!0,this._didWork=!1,this._callbacks=[],this.taskTrackingZone=null,NS||(function WY(n){NS=n}(s),s.addToWindow(r)),this._watchAngularEvents(),e.run(()=>{this.taskTrackingZone=typeof Zone>"u"?null:Zone.current.get("TaskTrackingZone")})}_watchAngularEvents(){this._ngZone.onUnstable.subscribe({next:()=>{this._didWork=!0,this._isZoneStable=!1}}),this._ngZone.runOutsideAngular(()=>{this._ngZone.onStable.subscribe({next:()=>{Zt.assertNotInAngularZone(),IS(()=>{this._isZoneStable=!0,this._runCallbacksIfReady()})}})})}increasePendingRequestCount(){return this._pendingCount+=1,this._didWork=!0,this._pendingCount}decreasePendingRequestCount(){if(this._pendingCount-=1,this._pendingCount<0)throw new Error("pending async requests below zero");return this._runCallbacksIfReady(),this._pendingCount}isStable(){return this._isZoneStable&&0===this._pendingCount&&!this._ngZone.hasPendingMacrotasks}_runCallbacksIfReady(){if(this.isStable())IS(()=>{for(;0!==this._callbacks.length;){let e=this._callbacks.pop();clearTimeout(e.timeoutId),e.doneCb(this._didWork)}this._didWork=!1});else{let e=this.getPendingTasks();this._callbacks=this._callbacks.filter(r=>!r.updateCb||!r.updateCb(e)||(clearTimeout(r.timeoutId),!1)),this._didWork=!0}}getPendingTasks(){return this.taskTrackingZone?this.taskTrackingZone.macroTasks.map(e=>({source:e.source,creationLocation:e.creationLocation,data:e.data})):[]}addCallback(e,r,s){let i=-1;r&&r>0&&(i=setTimeout(()=>{this._callbacks=this._callbacks.filter(o=>o.timeoutId!==i),e(this._didWork,this.getPendingTasks())},r)),this._callbacks.push({doneCb:e,timeoutId:i,updateCb:s})}whenStable(e,r,s){if(s&&!this.taskTrackingZone)throw new Error('Task tracking zone is required when passing an update callback to whenStable(). Is "zone.js/plugins/task-tracking" loaded?');this.addCallback(e,r,s),this._runCallbacksIfReady()}getPendingRequestCount(){return this._pendingCount}registerApplication(e){this.registry.registerApplication(e,this)}unregisterApplication(e){this.registry.unregisterApplication(e)}findProviders(e,r,s){return[]}}return n.\u0275fac=function(e){return new(e||n)(Le(Zt),Le(kS),Le(wb))},n.\u0275prov=ht({token:n,factory:n.\u0275fac}),n})(),kS=(()=>{class n{constructor(){this._applications=new Map}registerApplication(e,r){this._applications.set(e,r)}unregisterApplication(e){this._applications.delete(e)}unregisterAllApplications(){this._applications.clear()}getTestability(e){return this._applications.get(e)||null}getAllTestabilities(){return Array.from(this._applications.values())}getAllRootElements(){return Array.from(this._applications.keys())}findTestabilityInTree(e,r=!0){return NS?.findTestabilityInTree(this,e,r)??null}}return n.\u0275fac=function(e){return new(e||n)},n.\u0275prov=ht({token:n,factory:n.\u0275fac,providedIn:"platform"}),n})(),jl=null;const YP=new st("AllowMultipleToken"),OS=new st("PlatformDestroyListeners"),RS=new st("appBootstrapListener");class QP{constructor(t,e){this.name=t,this.token=e}}function eF(n,t,e=[]){const r=`Platform: ${t}`,s=new st(r);return(i=[])=>{let o=MS();if(!o||o.injector.get(YP,!1)){const a=[...e,...i,{provide:s,useValue:!0}];n?n(a):function KY(n){if(jl&&!jl.get(YP,!1))throw new je(400,!1);(function ZP(){!function XH(n){NN=n}(()=>{throw new je(600,!1)})})(),jl=n;const t=n.get(nF);(function JP(n){n.get(xO,null)?.forEach(e=>e())})(n)}(function tF(n=[],t){return Vs.create({name:t,providers:[{provide:iT,useValue:"platform"},{provide:OS,useValue:new Set([()=>jl=null])},...n]})}(a,r))}return function YY(n){const t=MS();if(!t)throw new je(401,!1);return t}()}}function MS(){return jl?.get(nF)??null}let nF=(()=>{class n{constructor(e){this._injector=e,this._modules=[],this._destroyListeners=[],this._destroyed=!1}bootstrapModuleFactory(e,r){const s=function ZY(n="zone.js",t){return"noop"===n?new GY:"zone.js"===n?new Zt(t):n}(r?.ngZone,function rF(n){return{enableLongStackTrace:!1,shouldCoalesceEventChangeDetection:n?.eventCoalescing??!1,shouldCoalesceRunChangeDetection:n?.runCoalescing??!1}}({eventCoalescing:r?.ngZoneEventCoalescing,runCoalescing:r?.ngZoneRunCoalescing}));return s.run(()=>{const i=function wX(n,t,e){return new iS(n,t,e)}(e.moduleType,this.injector,function lF(n){return[{provide:Zt,useFactory:n},{provide:jp,multi:!0,useFactory:()=>{const t=Ct(JY,{optional:!0});return()=>t.initialize()}},{provide:aF,useFactory:QY},{provide:qP,useFactory:KP}]}(()=>s)),o=i.injector.get(tc,null);return s.runOutsideAngular(()=>{const a=s.onError.subscribe({next:u=>{o.handleError(u)}});i.onDestroy(()=>{xb(this._modules,i),a.unsubscribe()})}),function sF(n,t,e){try{const r=e();return sf(r)?r.catch(s=>{throw t.runOutsideAngular(()=>n.handleError(s)),s}):r}catch(r){throw t.runOutsideAngular(()=>n.handleError(r)),r}}(o,s,()=>{const a=i.injector.get(CS);return a.runInitializers(),a.donePromise.then(()=>(function IM(n){ro(n,"Expected localeId to be defined"),"string"==typeof n&&(CM=n.toLowerCase().replace(/_/g,"-"))}(i.injector.get(xa,qd)||qd),this._moduleDoBootstrap(i),i))})})}bootstrapModule(e,r=[]){const s=iF({},r);return function HY(n,t,e){const r=new oS(e);return Promise.resolve(r)}(0,0,e).then(i=>this.bootstrapModuleFactory(i,s))}_moduleDoBootstrap(e){const r=e.injector.get(Gl);if(e._bootstrapComponents.length>0)e._bootstrapComponents.forEach(s=>r.bootstrap(s));else{if(!e.instance.ngDoBootstrap)throw new je(-403,!1);e.instance.ngDoBootstrap(r)}this._modules.push(e)}onDestroy(e){this._destroyListeners.push(e)}get injector(){return this._injector}destroy(){if(this._destroyed)throw new je(404,!1);this._modules.slice().forEach(r=>r.destroy()),this._destroyListeners.forEach(r=>r());const e=this._injector.get(OS,null);e&&(e.forEach(r=>r()),e.clear()),this._destroyed=!0}get destroyed(){return this._destroyed}}return n.\u0275fac=function(e){return new(e||n)(Le(Vs))},n.\u0275prov=ht({token:n,factory:n.\u0275fac,providedIn:"platform"}),n})();function iF(n,t){return Array.isArray(t)?t.reduce(iF,n):{...n,...t}}let Gl=(()=>{class n{constructor(){this._bootstrapListeners=[],this._runningTick=!1,this._destroyed=!1,this._destroyListeners=[],this._views=[],this.internalErrorHandler=Ct(aF),this.componentTypes=[],this.components=[],this.isStable=Ct(qP),this._injector=Ct(tl)}get destroyed(){return this._destroyed}get injector(){return this._injector}bootstrap(e,r){const s=e instanceof DO;if(!this._injector.get(CS).done)throw!s&&function dd(n){const t=En(n)||Fs(n)||mi(n);return null!==t&&t.standalone}(e),new je(405,!1);let o;o=s?e:this._injector.get(Nd).resolveComponentFactory(e),this.componentTypes.push(o.componentType);const a=function qY(n){return n.isBoundToModule}(o)?void 0:this._injector.get(Kd),c=o.create(Vs.NULL,[],r||o.selector,a),p=c.location.nativeElement,m=c.injector.get(XP,null);return m?.registerApplication(p),c.onDestroy(()=>{this.detachView(c.hostView),xb(this.components,c),m?.unregisterApplication(p)}),this._loadComponent(c),c}tick(){if(this._runningTick)throw new je(101,!1);try{this._runningTick=!0;for(let e of this._views)e.detectChanges()}catch(e){this.internalErrorHandler(e)}finally{this._runningTick=!1}}attachView(e){const r=e;this._views.push(r),r.attachToAppRef(this)}detachView(e){const r=e;xb(this._views,r),r.detachFromAppRef()}_loadComponent(e){this.attachView(e.hostView),this.tick(),this.components.push(e);const r=this._injector.get(RS,[]);r.push(...this._bootstrapListeners),r.forEach(s=>s(e))}ngOnDestroy(){if(!this._destroyed)try{this._destroyListeners.forEach(e=>e()),this._views.slice().forEach(e=>e.destroy())}finally{this._destroyed=!0,this._views=[],this._bootstrapListeners=[],this._destroyListeners=[]}}onDestroy(e){return this._destroyListeners.push(e),()=>xb(this._destroyListeners,e)}destroy(){if(this._destroyed)throw new je(406,!1);const e=this._injector;e.destroy&&!e.destroyed&&e.destroy()}get viewCount(){return this._views.length}warnIfDestroyed(){}}return n.\u0275fac=function(e){return new(e||n)},n.\u0275prov=ht({token:n,factory:n.\u0275fac,providedIn:"root"}),n})();function xb(n,t){const e=n.indexOf(t);e>-1&&n.splice(e,1)}const aF=new st("",{providedIn:"root",factory:()=>Ct(tc).handleError.bind(void 0)});function QY(){const n=Ct(Zt),t=Ct(tc);return e=>n.runOutsideAngular(()=>t.handleError(e))}let JY=(()=>{class n{constructor(){this.zone=Ct(Zt),this.applicationRef=Ct(Gl)}initialize(){this._onMicrotaskEmptySubscription||(this._onMicrotaskEmptySubscription=this.zone.onMicrotaskEmpty.subscribe({next:()=>{this.zone.run(()=>{this.applicationRef.tick()})}}))}ngOnDestroy(){this._onMicrotaskEmptySubscription?.unsubscribe()}}return n.\u0275fac=function(e){return new(e||n)},n.\u0275prov=ht({token:n,factory:n.\u0275fac,providedIn:"root"}),n})();let Ta=(()=>{class n{}return n.__NG_ELEMENT_ID__=tZ,n})();function tZ(n){return function nZ(n,t,e){if(Ku(n)&&!e){const r=yi(n.index,t);return new Zp(r,r)}return 47&n.type?new Zp(t[jr],t):null}(As(),Xe(),16==(16&n))}class hF{constructor(){}supports(t){return ob(t)}create(t){return new lZ(t)}}const aZ=(n,t)=>t;class lZ{constructor(t){this.length=0,this._linkedRecords=null,this._unlinkedRecords=null,this._previousItHead=null,this._itHead=null,this._itTail=null,this._additionsHead=null,this._additionsTail=null,this._movesHead=null,this._movesTail=null,this._removalsHead=null,this._removalsTail=null,this._identityChangesHead=null,this._identityChangesTail=null,this._trackByFn=t||aZ}forEachItem(t){let e;for(e=this._itHead;null!==e;e=e._next)t(e)}forEachOperation(t){let e=this._itHead,r=this._removalsHead,s=0,i=null;for(;e||r;){const o=!r||e&&e.currentIndex<fF(r,s,i)?e:r,a=fF(o,s,i),u=o.currentIndex;if(o===r)s--,r=r._nextRemoved;else if(e=e._next,null==o.previousIndex)s++;else{i||(i=[]);const c=a-s,p=u-s;if(c!=p){for(let y=0;y<c;y++){const _=y<i.length?i[y]:i[y]=0,w=_+y;p<=w&&w<c&&(i[y]=_+1)}i[o.previousIndex]=p-c}}a!==u&&t(o,a,u)}}forEachPreviousItem(t){let e;for(e=this._previousItHead;null!==e;e=e._nextPrevious)t(e)}forEachAddedItem(t){let e;for(e=this._additionsHead;null!==e;e=e._nextAdded)t(e)}forEachMovedItem(t){let e;for(e=this._movesHead;null!==e;e=e._nextMoved)t(e)}forEachRemovedItem(t){let e;for(e=this._removalsHead;null!==e;e=e._nextRemoved)t(e)}forEachIdentityChange(t){let e;for(e=this._identityChangesHead;null!==e;e=e._nextIdentityChange)t(e)}diff(t){if(null==t&&(t=[]),!ob(t))throw new je(900,!1);return this.check(t)?this:null}onDestroy(){}check(t){this._reset();let s,i,o,e=this._itHead,r=!1;if(Array.isArray(t)){this.length=t.length;for(let a=0;a<this.length;a++)i=t[a],o=this._trackByFn(a,i),null!==e&&Object.is(e.trackById,o)?(r&&(e=this._verifyReinsertion(e,i,o,a)),Object.is(e.item,i)||this._addIdentityChange(e,i)):(e=this._mismatch(e,i,o,a),r=!0),e=e._next}else s=0,function r9(n,t){if(Array.isArray(n))for(let e=0;e<n.length;e++)t(n[e]);else{const e=n[Symbol.iterator]();let r;for(;!(r=e.next()).done;)t(r.value)}}(t,a=>{o=this._trackByFn(s,a),null!==e&&Object.is(e.trackById,o)?(r&&(e=this._verifyReinsertion(e,a,o,s)),Object.is(e.item,a)||this._addIdentityChange(e,a)):(e=this._mismatch(e,a,o,s),r=!0),e=e._next,s++}),this.length=s;return this._truncate(e),this.collection=t,this.isDirty}get isDirty(){return null!==this._additionsHead||null!==this._movesHead||null!==this._removalsHead||null!==this._identityChangesHead}_reset(){if(this.isDirty){let t;for(t=this._previousItHead=this._itHead;null!==t;t=t._next)t._nextPrevious=t._next;for(t=this._additionsHead;null!==t;t=t._nextAdded)t.previousIndex=t.currentIndex;for(this._additionsHead=this._additionsTail=null,t=this._movesHead;null!==t;t=t._nextMoved)t.previousIndex=t.currentIndex;this._movesHead=this._movesTail=null,this._removalsHead=this._removalsTail=null,this._identityChangesHead=this._identityChangesTail=null}}_mismatch(t,e,r,s){let i;return null===t?i=this._itTail:(i=t._prev,this._remove(t)),null!==(t=null===this._unlinkedRecords?null:this._unlinkedRecords.get(r,null))?(Object.is(t.item,e)||this._addIdentityChange(t,e),this._reinsertAfter(t,i,s)):null!==(t=null===this._linkedRecords?null:this._linkedRecords.get(r,s))?(Object.is(t.item,e)||this._addIdentityChange(t,e),this._moveAfter(t,i,s)):t=this._addAfter(new uZ(e,r),i,s),t}_verifyReinsertion(t,e,r,s){let i=null===this._unlinkedRecords?null:this._unlinkedRecords.get(r,null);return null!==i?t=this._reinsertAfter(i,t._prev,s):t.currentIndex!=s&&(t.currentIndex=s,this._addToMoves(t,s)),t}_truncate(t){for(;null!==t;){const e=t._next;this._addToRemovals(this._unlink(t)),t=e}null!==this._unlinkedRecords&&this._unlinkedRecords.clear(),null!==this._additionsTail&&(this._additionsTail._nextAdded=null),null!==this._movesTail&&(this._movesTail._nextMoved=null),null!==this._itTail&&(this._itTail._next=null),null!==this._removalsTail&&(this._removalsTail._nextRemoved=null),null!==this._identityChangesTail&&(this._identityChangesTail._nextIdentityChange=null)}_reinsertAfter(t,e,r){null!==this._unlinkedRecords&&this._unlinkedRecords.remove(t);const s=t._prevRemoved,i=t._nextRemoved;return null===s?this._removalsHead=i:s._nextRemoved=i,null===i?this._removalsTail=s:i._prevRemoved=s,this._insertAfter(t,e,r),this._addToMoves(t,r),t}_moveAfter(t,e,r){return this._unlink(t),this._insertAfter(t,e,r),this._addToMoves(t,r),t}_addAfter(t,e,r){return this._insertAfter(t,e,r),this._additionsTail=null===this._additionsTail?this._additionsHead=t:this._additionsTail._nextAdded=t,t}_insertAfter(t,e,r){const s=null===e?this._itHead:e._next;return t._next=s,t._prev=e,null===s?this._itTail=t:s._prev=t,null===e?this._itHead=t:e._next=t,null===this._linkedRecords&&(this._linkedRecords=new pF),this._linkedRecords.put(t),t.currentIndex=r,t}_remove(t){return this._addToRemovals(this._unlink(t))}_unlink(t){null!==this._linkedRecords&&this._linkedRecords.remove(t);const e=t._prev,r=t._next;return null===e?this._itHead=r:e._next=r,null===r?this._itTail=e:r._prev=e,t}_addToMoves(t,e){return t.previousIndex===e||(this._movesTail=null===this._movesTail?this._movesHead=t:this._movesTail._nextMoved=t),t}_addToRemovals(t){return null===this._unlinkedRecords&&(this._unlinkedRecords=new pF),this._unlinkedRecords.put(t),t.currentIndex=null,t._nextRemoved=null,null===this._removalsTail?(this._removalsTail=this._removalsHead=t,t._prevRemoved=null):(t._prevRemoved=this._removalsTail,this._removalsTail=this._removalsTail._nextRemoved=t),t}_addIdentityChange(t,e){return t.item=e,this._identityChangesTail=null===this._identityChangesTail?this._identityChangesHead=t:this._identityChangesTail._nextIdentityChange=t,t}}class uZ{constructor(t,e){this.item=t,this.trackById=e,this.currentIndex=null,this.previousIndex=null,this._nextPrevious=null,this._prev=null,this._next=null,this._prevDup=null,this._nextDup=null,this._prevRemoved=null,this._nextRemoved=null,this._nextAdded=null,this._nextMoved=null,this._nextIdentityChange=null}}class cZ{constructor(){this._head=null,this._tail=null}add(t){null===this._head?(this._head=this._tail=t,t._nextDup=null,t._prevDup=null):(this._tail._nextDup=t,t._prevDup=this._tail,t._nextDup=null,this._tail=t)}get(t,e){let r;for(r=this._head;null!==r;r=r._nextDup)if((null===e||e<=r.currentIndex)&&Object.is(r.trackById,t))return r;return null}remove(t){const e=t._prevDup,r=t._nextDup;return null===e?this._head=r:e._nextDup=r,null===r?this._tail=e:r._prevDup=e,null===this._head}}class pF{constructor(){this.map=new Map}put(t){const e=t.trackById;let r=this.map.get(e);r||(r=new cZ,this.map.set(e,r)),r.add(t)}get(t,e){const s=this.map.get(t);return s?s.get(t,e):null}remove(t){const e=t.trackById;return this.map.get(e).remove(t)&&this.map.delete(e),t}get isEmpty(){return 0===this.map.size}clear(){this.map.clear()}}function fF(n,t,e){const r=n.previousIndex;if(null===r)return r;let s=0;return e&&r<e.length&&(s=e[r]),r+t+s}class mF{constructor(){}supports(t){return t instanceof Map||FT(t)}create(){return new dZ}}class dZ{constructor(){this._records=new Map,this._mapHead=null,this._appendAfter=null,this._previousMapHead=null,this._changesHead=null,this._changesTail=null,this._additionsHead=null,this._additionsTail=null,this._removalsHead=null,this._removalsTail=null}get isDirty(){return null!==this._additionsHead||null!==this._changesHead||null!==this._removalsHead}forEachItem(t){let e;for(e=this._mapHead;null!==e;e=e._next)t(e)}forEachPreviousItem(t){let e;for(e=this._previousMapHead;null!==e;e=e._nextPrevious)t(e)}forEachChangedItem(t){let e;for(e=this._changesHead;null!==e;e=e._nextChanged)t(e)}forEachAddedItem(t){let e;for(e=this._additionsHead;null!==e;e=e._nextAdded)t(e)}forEachRemovedItem(t){let e;for(e=this._removalsHead;null!==e;e=e._nextRemoved)t(e)}diff(t){if(t){if(!(t instanceof Map||FT(t)))throw new je(900,!1)}else t=new Map;return this.check(t)?this:null}onDestroy(){}check(t){this._reset();let e=this._mapHead;if(this._appendAfter=null,this._forEach(t,(r,s)=>{if(e&&e.key===s)this._maybeAddToChanges(e,r),this._appendAfter=e,e=e._next;else{const i=this._getOrCreateRecordForKey(s,r);e=this._insertBeforeOrAppend(e,i)}}),e){e._prev&&(e._prev._next=null),this._removalsHead=e;for(let r=e;null!==r;r=r._nextRemoved)r===this._mapHead&&(this._mapHead=null),this._records.delete(r.key),r._nextRemoved=r._next,r.previousValue=r.currentValue,r.currentValue=null,r._prev=null,r._next=null}return this._changesTail&&(this._changesTail._nextChanged=null),this._additionsTail&&(this._additionsTail._nextAdded=null),this.isDirty}_insertBeforeOrAppend(t,e){if(t){const r=t._prev;return e._next=t,e._prev=r,t._prev=e,r&&(r._next=e),t===this._mapHead&&(this._mapHead=e),this._appendAfter=t,t}return this._appendAfter?(this._appendAfter._next=e,e._prev=this._appendAfter):this._mapHead=e,this._appendAfter=e,null}_getOrCreateRecordForKey(t,e){if(this._records.has(t)){const s=this._records.get(t);this._maybeAddToChanges(s,e);const i=s._prev,o=s._next;return i&&(i._next=o),o&&(o._prev=i),s._next=null,s._prev=null,s}const r=new hZ(t);return this._records.set(t,r),r.currentValue=e,this._addToAdditions(r),r}_reset(){if(this.isDirty){let t;for(this._previousMapHead=this._mapHead,t=this._previousMapHead;null!==t;t=t._next)t._nextPrevious=t._next;for(t=this._changesHead;null!==t;t=t._nextChanged)t.previousValue=t.currentValue;for(t=this._additionsHead;null!=t;t=t._nextAdded)t.previousValue=t.currentValue;this._changesHead=this._changesTail=null,this._additionsHead=this._additionsTail=null,this._removalsHead=null}}_maybeAddToChanges(t,e){Object.is(e,t.currentValue)||(t.previousValue=t.currentValue,t.currentValue=e,this._addToChanges(t))}_addToAdditions(t){null===this._additionsHead?this._additionsHead=this._additionsTail=t:(this._additionsTail._nextAdded=t,this._additionsTail=t)}_addToChanges(t){null===this._changesHead?this._changesHead=this._changesTail=t:(this._changesTail._nextChanged=t,this._changesTail=t)}_forEach(t,e){t instanceof Map?t.forEach(e):Object.keys(t).forEach(r=>e(t[r],r))}}class hZ{constructor(t){this.key=t,this.previousValue=null,this.currentValue=null,this._nextPrevious=null,this._next=null,this._prev=null,this._nextAdded=null,this._nextRemoved=null,this._nextChanged=null}}function gF(){return new Cb([new hF])}let Cb=(()=>{class n{constructor(e){this.factories=e}static create(e,r){if(null!=r){const s=r.factories.slice();e=e.concat(s)}return new n(e)}static extend(e){return{provide:n,useFactory:r=>n.create(e,r||gF()),deps:[[n,new Ry,new Oy]]}}find(e){const r=this.factories.find(s=>s.supports(e));if(null!=r)return r;throw new je(901,!1)}}return n.\u0275prov=ht({token:n,providedIn:"root",factory:gF}),n})();function yF(){return new vf([new mF])}let vf=(()=>{class n{constructor(e){this.factories=e}static create(e,r){if(r){const s=r.factories.slice();e=e.concat(s)}return new n(e)}static extend(e){return{provide:n,useFactory:r=>n.create(e,r||yF()),deps:[[n,new Ry,new Oy]]}}find(e){const r=this.factories.find(s=>s.supports(e));if(r)return r;throw new je(901,!1)}}return n.\u0275prov=ht({token:n,providedIn:"root",factory:yF}),n})();const mZ=eF(null,"core",[]);let gZ=(()=>{class n{constructor(e){}}return n.\u0275fac=function(e){return new(e||n)(Le(Gl))},n.\u0275mod=ar({type:n}),n.\u0275inj=Jn({}),n})(),TF=(()=>{class n{get whenAllTasksComplete(){return 0===this.collection.size&&this.complete(),this.promise}constructor(){this.taskId=0,this.collection=new Set,this.ngZone=Ct(Zt),this.completed=!1,this.ngZone.runOutsideAngular(()=>{this.promise=new Promise(e=>{this.resolve=e})})}add(){if(this.completed)return-1;const e=this.taskId++;return this.collection.add(e),e}remove(e){this.completed||(this.collection.delete(e),0===this.collection.size&&this.complete())}ngOnDestroy(){this.complete(),this.collection.clear()}complete(){this.completed=!0,this.resolve()}}return n.\u0275fac=function(e){return new(e||n)},n.\u0275prov=ht({token:n,factory:n.\u0275fac,providedIn:"root"}),n})(),zS=null;function Wl(){return zS}class DZ{}const xn=new st("DocumentToken");let US=(()=>{class n{historyGo(e){throw new Error("Not implemented")}}return n.\u0275fac=function(e){return new(e||n)},n.\u0275prov=ht({token:n,factory:function(){return function AZ(){return Le(CF)}()},providedIn:"platform"}),n})();const kZ=new st("Location Initialized");let CF=(()=>{class n extends US{constructor(e){super(),this._doc=e,this._location=window.location,this._history=window.history}getBaseHrefFromDOM(){return Wl().getBaseHref(this._doc)}onPopState(e){const r=Wl().getGlobalEventTarget(this._doc,"window");return r.addEventListener("popstate",e,!1),()=>r.removeEventListener("popstate",e)}onHashChange(e){const r=Wl().getGlobalEventTarget(this._doc,"window");return r.addEventListener("hashchange",e,!1),()=>r.removeEventListener("hashchange",e)}get href(){return this._location.href}get protocol(){return this._location.protocol}get hostname(){return this._location.hostname}get port(){return this._location.port}get pathname(){return this._location.pathname}get search(){return this._location.search}get hash(){return this._location.hash}set pathname(e){this._location.pathname=e}pushState(e,r,s){IF()?this._history.pushState(e,r,s):this._location.hash=s}replaceState(e,r,s){IF()?this._history.replaceState(e,r,s):this._location.hash=s}forward(){this._history.forward()}back(){this._history.back()}historyGo(e=0){this._history.go(e)}getState(){return this._history.state}}return n.\u0275fac=function(e){return new(e||n)(Le(xn))},n.\u0275prov=ht({token:n,factory:function(){return function NZ(){return new CF(Le(xn))}()},providedIn:"platform"}),n})();function IF(){return!!window.history.pushState}function jS(n,t){if(0==n.length)return t;if(0==t.length)return n;let e=0;return n.endsWith("/")&&e++,t.startsWith("/")&&e++,2==e?n+t.substring(1):1==e?n+t:n+"/"+t}function EF(n){const t=n.match(/#|\?|$/),e=t&&t.index||n.length;return n.slice(0,e-("/"===n[e-1]?1:0))+n.slice(e)}function il(n){return n&&"?"!==n[0]?"?"+n:n}let lc=(()=>{class n{historyGo(e){throw new Error("Not implemented")}}return n.\u0275fac=function(e){return new(e||n)},n.\u0275prov=ht({token:n,factory:function(){return Ct(AF)},providedIn:"root"}),n})();const DF=new st("appBaseHref");let AF=(()=>{class n extends lc{constructor(e,r){super(),this._platformLocation=e,this._removeListenerFns=[],this._baseHref=r??this._platformLocation.getBaseHrefFromDOM()??Ct(xn).location?.origin??""}ngOnDestroy(){for(;this._removeListenerFns.length;)this._removeListenerFns.pop()()}onPopState(e){this._removeListenerFns.push(this._platformLocation.onPopState(e),this._platformLocation.onHashChange(e))}getBaseHref(){return this._baseHref}prepareExternalUrl(e){return jS(this._baseHref,e)}path(e=!1){const r=this._platformLocation.pathname+il(this._platformLocation.search),s=this._platformLocation.hash;return s&&e?`${r}${s}`:r}pushState(e,r,s,i){const o=this.prepareExternalUrl(s+il(i));this._platformLocation.pushState(e,r,o)}replaceState(e,r,s,i){const o=this.prepareExternalUrl(s+il(i));this._platformLocation.replaceState(e,r,o)}forward(){this._platformLocation.forward()}back(){this._platformLocation.back()}getState(){return this._platformLocation.getState()}historyGo(e=0){this._platformLocation.historyGo?.(e)}}return n.\u0275fac=function(e){return new(e||n)(Le(US),Le(DF,8))},n.\u0275prov=ht({token:n,factory:n.\u0275fac,providedIn:"root"}),n})(),OZ=(()=>{class n extends lc{constructor(e,r){super(),this._platformLocation=e,this._baseHref="",this._removeListenerFns=[],null!=r&&(this._baseHref=r)}ngOnDestroy(){for(;this._removeListenerFns.length;)this._removeListenerFns.pop()()}onPopState(e){this._removeListenerFns.push(this._platformLocation.onPopState(e),this._platformLocation.onHashChange(e))}getBaseHref(){return this._baseHref}path(e=!1){let r=this._platformLocation.hash;return null==r&&(r="#"),r.length>0?r.substring(1):r}prepareExternalUrl(e){const r=jS(this._baseHref,e);return r.length>0?"#"+r:r}pushState(e,r,s,i){let o=this.prepareExternalUrl(s+il(i));0==o.length&&(o=this._platformLocation.pathname),this._platformLocation.pushState(e,r,o)}replaceState(e,r,s,i){let o=this.prepareExternalUrl(s+il(i));0==o.length&&(o=this._platformLocation.pathname),this._platformLocation.replaceState(e,r,o)}forward(){this._platformLocation.forward()}back(){this._platformLocation.back()}getState(){return this._platformLocation.getState()}historyGo(e=0){this._platformLocation.historyGo?.(e)}}return n.\u0275fac=function(e){return new(e||n)(Le(US),Le(DF,8))},n.\u0275prov=ht({token:n,factory:n.\u0275fac}),n})(),wf=(()=>{class n{constructor(e){this._subject=new On,this._urlChangeListeners=[],this._urlChangeSubscription=null,this._locationStrategy=e;const r=this._locationStrategy.getBaseHref();this._basePath=function PZ(n){if(new RegExp("^(https?:)?//").test(n)){const[,e]=n.split(/\/\/[^\/]+/);return e}return n}(EF(kF(r))),this._locationStrategy.onPopState(s=>{this._subject.emit({url:this.path(!0),pop:!0,state:s.state,type:s.type})})}ngOnDestroy(){this._urlChangeSubscription?.unsubscribe(),this._urlChangeListeners=[]}path(e=!1){return this.normalize(this._locationStrategy.path(e))}getState(){return this._locationStrategy.getState()}isCurrentPathEqualTo(e,r=""){return this.path()==this.normalize(e+il(r))}normalize(e){return n.stripTrailingSlash(function MZ(n,t){if(!n||!t.startsWith(n))return t;const e=t.substring(n.length);return""===e||["/",";","?","#"].includes(e[0])?e:t}(this._basePath,kF(e)))}prepareExternalUrl(e){return e&&"/"!==e[0]&&(e="/"+e),this._locationStrategy.prepareExternalUrl(e)}go(e,r="",s=null){this._locationStrategy.pushState(s,"",e,r),this._notifyUrlChangeListeners(this.prepareExternalUrl(e+il(r)),s)}replaceState(e,r="",s=null){this._locationStrategy.replaceState(s,"",e,r),this._notifyUrlChangeListeners(this.prepareExternalUrl(e+il(r)),s)}forward(){this._locationStrategy.forward()}back(){this._locationStrategy.back()}historyGo(e=0){this._locationStrategy.historyGo?.(e)}onUrlChange(e){return this._urlChangeListeners.push(e),this._urlChangeSubscription||(this._urlChangeSubscription=this.subscribe(r=>{this._notifyUrlChangeListeners(r.url,r.state)})),()=>{const r=this._urlChangeListeners.indexOf(e);this._urlChangeListeners.splice(r,1),0===this._urlChangeListeners.length&&(this._urlChangeSubscription?.unsubscribe(),this._urlChangeSubscription=null)}}_notifyUrlChangeListeners(e="",r){this._urlChangeListeners.forEach(s=>s(e,r))}subscribe(e,r,s){return this._subject.subscribe({next:e,error:r,complete:s})}}return n.normalizeQueryParams=il,n.joinWithSlash=jS,n.stripTrailingSlash=EF,n.\u0275fac=function(e){return new(e||n)(Le(lc))},n.\u0275prov=ht({token:n,factory:function(){return function RZ(){return new wf(Le(lc))}()},providedIn:"root"}),n})();function kF(n){return n.replace(/\/index.html$/,"")}var vi=(()=>((vi=vi||{})[vi.Decimal=0]="Decimal",vi[vi.Percent=1]="Percent",vi[vi.Currency=2]="Currency",vi[vi.Scientific=3]="Scientific",vi))(),Ft=(()=>((Ft=Ft||{})[Ft.Decimal=0]="Decimal",Ft[Ft.Group=1]="Group",Ft[Ft.List=2]="List",Ft[Ft.PercentSign=3]="PercentSign",Ft[Ft.PlusSign=4]="PlusSign",Ft[Ft.MinusSign=5]="MinusSign",Ft[Ft.Exponential=6]="Exponential",Ft[Ft.SuperscriptingExponent=7]="SuperscriptingExponent",Ft[Ft.PerMille=8]="PerMille",Ft[Ft.Infinity=9]="Infinity",Ft[Ft.NaN=10]="NaN",Ft[Ft.TimeSeparator=11]="TimeSeparator",Ft[Ft.CurrencyDecimal=12]="CurrencyDecimal",Ft[Ft.CurrencyGroup=13]="CurrencyGroup",Ft))();function ho(n,t){const e=Js(n),r=e[gt.NumberSymbols][t];if(typeof r>"u"){if(t===Ft.CurrencyDecimal)return e[gt.NumberSymbols][Ft.Decimal];if(t===Ft.CurrencyGroup)return e[gt.NumberSymbols][Ft.Group]}return r}const aQ=/^(\d+)?\.((\d+)(-(\d+))?)?$/;function ZS(n){const t=parseInt(n);if(isNaN(t))throw new Error("Invalid integer literal when parsing "+n);return t}const JS=/\s+/,VF=[];let BF=(()=>{class n{constructor(e,r,s,i){this._iterableDiffers=e,this._keyValueDiffers=r,this._ngEl=s,this._renderer=i,this.initialClasses=VF,this.stateMap=new Map}set klass(e){this.initialClasses=null!=e?e.trim().split(JS):VF}set ngClass(e){this.rawClass="string"==typeof e?e.trim().split(JS):e}ngDoCheck(){for(const r of this.initialClasses)this._updateState(r,!0);const e=this.rawClass;if(Array.isArray(e)||e instanceof Set)for(const r of e)this._updateState(r,!0);else if(null!=e)for(const r of Object.keys(e))this._updateState(r,!!e[r]);this._applyStateDiff()}_updateState(e,r){const s=this.stateMap.get(e);void 0!==s?(s.enabled!==r&&(s.changed=!0,s.enabled=r),s.touched=!0):this.stateMap.set(e,{enabled:r,changed:!0,touched:!0})}_applyStateDiff(){for(const e of this.stateMap){const r=e[0],s=e[1];s.changed?(this._toggleClass(r,s.enabled),s.changed=!1):s.touched||(s.enabled&&this._toggleClass(r,!1),this.stateMap.delete(r)),s.touched=!1}}_toggleClass(e,r){(e=e.trim()).length>0&&e.split(JS).forEach(s=>{r?this._renderer.addClass(this._ngEl.nativeElement,s):this._renderer.removeClass(this._ngEl.nativeElement,s)})}}return n.\u0275fac=function(e){return new(e||n)(Ee(Cb),Ee(vf),Ee(tr),Ee(nl))},n.\u0275dir=Pt({type:n,selectors:[["","ngClass",""]],inputs:{klass:["class","klass"],ngClass:"ngClass"},standalone:!0}),n})();class vQ{constructor(t,e,r,s){this.$implicit=t,this.ngForOf=e,this.index=r,this.count=s}get first(){return 0===this.index}get last(){return this.index===this.count-1}get even(){return this.index%2==0}get odd(){return!this.even}}let e1=(()=>{class n{set ngForOf(e){this._ngForOf=e,this._ngForOfDirty=!0}set ngForTrackBy(e){this._trackByFn=e}get ngForTrackBy(){return this._trackByFn}constructor(e,r,s){this._viewContainer=e,this._template=r,this._differs=s,this._ngForOf=null,this._ngForOfDirty=!0,this._differ=null}set ngForTemplate(e){e&&(this._template=e)}ngDoCheck(){if(this._ngForOfDirty){this._ngForOfDirty=!1;const e=this._ngForOf;!this._differ&&e&&(this._differ=this._differs.find(e).create(this.ngForTrackBy))}if(this._differ){const e=this._differ.diff(this._ngForOf);e&&this._applyChanges(e)}}_applyChanges(e){const r=this._viewContainer;e.forEachOperation((s,i,o)=>{if(null==s.previousIndex)r.createEmbeddedView(this._template,new vQ(s.item,this._ngForOf,-1,-1),null===o?void 0:o);else if(null==o)r.remove(null===i?void 0:i);else if(null!==i){const a=r.get(i);r.move(a,o),UF(a,s)}});for(let s=0,i=r.length;s<i;s++){const a=r.get(s).context;a.index=s,a.count=i,a.ngForOf=this._ngForOf}e.forEachIdentityChange(s=>{UF(r.get(s.currentIndex),s)})}static ngTemplateContextGuard(e,r){return!0}}return n.\u0275fac=function(e){return new(e||n)(Ee(lo),Ee(wa),Ee(Cb))},n.\u0275dir=Pt({type:n,selectors:[["","ngFor","","ngForOf",""]],inputs:{ngForOf:"ngForOf",ngForTrackBy:"ngForTrackBy",ngForTemplate:"ngForTemplate"},standalone:!0}),n})();function UF(n,t){n.context.$implicit=t.item}let Fb=(()=>{class n{constructor(e,r){this._viewContainer=e,this._context=new wQ,this._thenTemplateRef=null,this._elseTemplateRef=null,this._thenViewRef=null,this._elseViewRef=null,this._thenTemplateRef=r}set ngIf(e){this._context.$implicit=this._context.ngIf=e,this._updateView()}set ngIfThen(e){jF("ngIfThen",e),this._thenTemplateRef=e,this._thenViewRef=null,this._updateView()}set ngIfElse(e){jF("ngIfElse",e),this._elseTemplateRef=e,this._elseViewRef=null,this._updateView()}_updateView(){this._context.$implicit?this._thenViewRef||(this._viewContainer.clear(),this._elseViewRef=null,this._thenTemplateRef&&(this._thenViewRef=this._viewContainer.createEmbeddedView(this._thenTemplateRef,this._context))):this._elseViewRef||(this._viewContainer.clear(),this._thenViewRef=null,this._elseTemplateRef&&(this._elseViewRef=this._viewContainer.createEmbeddedView(this._elseTemplateRef,this._context)))}static ngTemplateContextGuard(e,r){return!0}}return n.\u0275fac=function(e){return new(e||n)(Ee(lo),Ee(wa))},n.\u0275dir=Pt({type:n,selectors:[["","ngIf",""]],inputs:{ngIf:"ngIf",ngIfThen:"ngIfThen",ngIfElse:"ngIfElse"},standalone:!0}),n})();class wQ{constructor(){this.$implicit=null,this.ngIf=null}}function jF(n,t){if(t&&!t.createEmbeddedView)throw new Error(`${n} must be a TemplateRef, but received '${Sr(t)}'.`)}let HF=(()=>{class n{constructor(e){this._locale=e}transform(e,r,s){if(!function r1(n){return!(null==n||""===n||n!=n)}(e))return null;s=s||this._locale;try{return function pQ(n,t,e){return function XS(n,t,e,r,s,i,o=!1){let a="",u=!1;if(isFinite(n)){let c=function mQ(n){let r,s,i,o,a,t=Math.abs(n)+"",e=0;for((s=t.indexOf("."))>-1&&(t=t.replace(".","")),(i=t.search(/e/i))>0?(s<0&&(s=i),s+=+t.slice(i+1),t=t.substring(0,i)):s<0&&(s=t.length),i=0;"0"===t.charAt(i);i++);if(i===(a=t.length))r=[0],s=1;else{for(a--;"0"===t.charAt(a);)a--;for(s-=i,r=[],o=0;i<=a;i++,o++)r[o]=Number(t.charAt(i))}return s>22&&(r=r.splice(0,21),e=s-1,s=1),{digits:r,exponent:e,integerLen:s}}(n);o&&(c=function fQ(n){if(0===n.digits[0])return n;const t=n.digits.length-n.integerLen;return n.exponent?n.exponent+=2:(0===t?n.digits.push(0,0):1===t&&n.digits.push(0),n.integerLen+=2),n}(c));let p=t.minInt,m=t.minFrac,y=t.maxFrac;if(i){const M=i.match(aQ);if(null===M)throw new Error(`${i} is not a valid digit info`);const V=M[1],z=M[3],G=M[5];null!=V&&(p=ZS(V)),null!=z&&(m=ZS(z)),null!=G?y=ZS(G):null!=z&&m>y&&(y=m)}!function gQ(n,t,e){if(t>e)throw new Error(`The minimum number of digits after fraction (${t}) is higher than the maximum (${e}).`);let r=n.digits,s=r.length-n.integerLen;const i=Math.min(Math.max(t,s),e);let o=i+n.integerLen,a=r[o];if(o>0){r.splice(Math.max(n.integerLen,o));for(let m=o;m<r.length;m++)r[m]=0}else{s=Math.max(0,s),n.integerLen=1,r.length=Math.max(1,o=i+1),r[0]=0;for(let m=1;m<o;m++)r[m]=0}if(a>=5)if(o-1<0){for(let m=0;m>o;m--)r.unshift(0),n.integerLen++;r.unshift(1),n.integerLen++}else r[o-1]++;for(;s<Math.max(0,i);s++)r.push(0);let u=0!==i;const c=t+n.integerLen,p=r.reduceRight(function(m,y,_,w){return w[_]=(y+=m)<10?y:y-10,u&&(0===w[_]&&_>=c?w.pop():u=!1),y>=10?1:0},0);p&&(r.unshift(p),n.integerLen++)}(c,m,y);let _=c.digits,w=c.integerLen;const T=c.exponent;let I=[];for(u=_.every(M=>!M);w<p;w++)_.unshift(0);for(;w<0;w++)_.unshift(0);w>0?I=_.splice(w,_.length):(I=_,_=[0]);const O=[];for(_.length>=t.lgSize&&O.unshift(_.splice(-t.lgSize,_.length).join(""));_.length>t.gSize;)O.unshift(_.splice(-t.gSize,_.length).join(""));_.length&&O.unshift(_.join("")),a=O.join(ho(e,r)),I.length&&(a+=ho(e,s)+I.join("")),T&&(a+=ho(e,Ft.Exponential)+"+"+T)}else a=ho(e,Ft.Infinity);return a=n<0&&!u?t.negPre+a+t.negSuf:t.posPre+a+t.posSuf,a}(n,function YS(n,t="-"){const e={minInt:1,minFrac:0,maxFrac:0,posPre:"",posSuf:"",negPre:"",negSuf:"",gSize:0,lgSize:0},r=n.split(";"),s=r[0],i=r[1],o=-1!==s.indexOf(".")?s.split("."):[s.substring(0,s.lastIndexOf("0")+1),s.substring(s.lastIndexOf("0")+1)],a=o[0],u=o[1]||"";e.posPre=a.substring(0,a.indexOf("#"));for(let p=0;p<u.length;p++){const m=u.charAt(p);"0"===m?e.minFrac=e.maxFrac=p+1:"#"===m?e.maxFrac=p+1:e.posSuf+=m}const c=a.split(",");if(e.gSize=c[1]?c[1].length:0,e.lgSize=c[2]||c[1]?(c[2]||c[1]).length:0,i){const p=s.length-e.posPre.length-e.posSuf.length,m=i.indexOf("#");e.negPre=i.substring(0,m).replace(/'/g,""),e.negSuf=i.slice(m+p).replace(/'/g,"")}else e.negPre=t+e.posPre,e.negSuf=e.posSuf;return e}(function GS(n,t){return Js(n)[gt.NumberFormats][t]}(t,vi.Decimal),ho(t,Ft.MinusSign)),t,Ft.Group,Ft.Decimal,e)}(function s1(n){if("string"==typeof n&&!isNaN(Number(n)-parseFloat(n)))return Number(n);if("number"!=typeof n)throw new Error(`${n} is not a number`);return n}(e),s,r)}catch(i){throw function qo(n,t){return new je(2100,!1)}()}}}return n.\u0275fac=function(e){return new(e||n)(Ee(xa,16))},n.\u0275pipe=fi({name:"number",type:n,pure:!0,standalone:!0}),n})();let o1=(()=>{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275mod=ar({type:n}),n.\u0275inj=Jn({}),n})();const qF="browser";function KF(n){return"server"===n}let XQ=(()=>{class n{}return n.\u0275prov=ht({token:n,providedIn:"root",factory:()=>new YQ(Le(xn),window)}),n})();class YQ{constructor(t,e){this.document=t,this.window=e,this.offset=()=>[0,0]}setOffset(t){this.offset=Array.isArray(t)?()=>t:t}getScrollPosition(){return this.supportsScrolling()?[this.window.pageXOffset,this.window.pageYOffset]:[0,0]}scrollToPosition(t){this.supportsScrolling()&&this.window.scrollTo(t[0],t[1])}scrollToAnchor(t){if(!this.supportsScrolling())return;const e=function ZQ(n,t){const e=n.getElementById(t)||n.getElementsByName(t)[0];if(e)return e;if("function"==typeof n.createTreeWalker&&n.body&&"function"==typeof n.body.attachShadow){const r=n.createTreeWalker(n.body,NodeFilter.SHOW_ELEMENT);let s=r.currentNode;for(;s;){const i=s.shadowRoot;if(i){const o=i.getElementById(t)||i.querySelector(`[name="${t}"]`);if(o)return o}s=r.nextNode()}}return null}(this.document,t);e&&(this.scrollToElement(e),e.focus())}setHistoryScrollRestoration(t){if(this.supportScrollRestoration()){const e=this.window.history;e&&e.scrollRestoration&&(e.scrollRestoration=t)}}scrollToElement(t){const e=t.getBoundingClientRect(),r=e.left+this.window.pageXOffset,s=e.top+this.window.pageYOffset,i=this.offset();this.window.scrollTo(r-i[0],s-i[1])}supportScrollRestoration(){try{if(!this.supportsScrolling())return!1;const t=XF(this.window.history)||XF(Object.getPrototypeOf(this.window.history));return!(!t||!t.writable&&!t.set)}catch{return!1}}supportsScrolling(){try{return!!this.window&&!!this.window.scrollTo&&"pageXOffset"in this.window}catch{return!1}}}function XF(n){return Object.getOwnPropertyDescriptor(n,"scrollRestoration")}class CJ extends DZ{constructor(){super(...arguments),this.supportsDOMEvents=!0}}class u1 extends CJ{static makeCurrent(){!function EZ(n){zS||(zS=n)}(new u1)}onAndCancel(t,e,r){return t.addEventListener(e,r),()=>{t.removeEventListener(e,r)}}dispatchEvent(t,e){t.dispatchEvent(e)}remove(t){t.parentNode&&t.parentNode.removeChild(t)}createElement(t,e){return(e=e||this.getDefaultDocument()).createElement(t)}createHtmlDocument(){return document.implementation.createHTMLDocument("fakeTitle")}getDefaultDocument(){return document}isElementNode(t){return t.nodeType===Node.ELEMENT_NODE}isShadowRoot(t){return t instanceof DocumentFragment}getGlobalEventTarget(t,e){return"window"===e?window:"document"===e?t:"body"===e?t.body:null}getBaseHref(t){const e=function IJ(){return Cf=Cf||document.querySelector("base"),Cf?Cf.getAttribute("href"):null}();return null==e?null:function EJ(n){Vb=Vb||document.createElement("a"),Vb.setAttribute("href",n);const t=Vb.pathname;return"/"===t.charAt(0)?t:`/${t}`}(e)}resetBaseElement(){Cf=null}getUserAgent(){return window.navigator.userAgent}getCookie(t){return function bQ(n,t){t=encodeURIComponent(t);for(const e of n.split(";")){const r=e.indexOf("="),[s,i]=-1==r?[e,""]:[e.slice(0,r),e.slice(r+1)];if(s.trim()===t)return decodeURIComponent(i)}return null}(document.cookie,t)}}let Vb,Cf=null,AJ=(()=>{class n{build(){return new XMLHttpRequest}}return n.\u0275fac=function(e){return new(e||n)},n.\u0275prov=ht({token:n,factory:n.\u0275fac}),n})();const c1=new st("EventManagerPlugins");let e$=(()=>{class n{constructor(e,r){this._zone=r,this._eventNameToPlugin=new Map,e.forEach(s=>{s.manager=this}),this._plugins=e.slice().reverse()}addEventListener(e,r,s){return this._findPluginFor(r).addEventListener(e,r,s)}getZone(){return this._zone}_findPluginFor(e){const r=this._eventNameToPlugin.get(e);if(r)return r;const s=this._plugins;for(let i=0;i<s.length;i++){const o=s[i];if(o.supports(e))return this._eventNameToPlugin.set(e,o),o}throw new Error(`No event manager plugin found for event ${e}`)}}return n.\u0275fac=function(e){return new(e||n)(Le(c1),Le(Zt))},n.\u0275prov=ht({token:n,factory:n.\u0275fac}),n})();class t${constructor(t){this._doc=t}}const d1="ng-app-id";let n$=(()=>{class n{constructor(e,r,s,i={}){this.doc=e,this.appId=r,this.nonce=s,this.platformId=i,this.styleRef=new Map,this.hostNodes=new Set,this.styleNodesInDOM=this.collectServerRenderedStyles(),this.platformIsServer=KF(i),this.resetHostNodes()}addStyles(e){for(const r of e)1===this.changeUsageCount(r,1)&&this.onStyleAdded(r)}removeStyles(e){for(const r of e)this.changeUsageCount(r,-1)<=0&&this.onStyleRemoved(r)}ngOnDestroy(){const e=this.styleNodesInDOM;e&&(e.forEach(r=>r.remove()),e.clear());for(const r of this.getAllStyles())this.onStyleRemoved(r);this.resetHostNodes()}addHost(e){this.hostNodes.add(e);for(const r of this.getAllStyles())this.addStyleToHost(e,r)}removeHost(e){this.hostNodes.delete(e)}getAllStyles(){return this.styleRef.keys()}onStyleAdded(e){for(const r of this.hostNodes)this.addStyleToHost(r,e)}onStyleRemoved(e){const r=this.styleRef;r.get(e)?.elements?.forEach(s=>s.remove()),r.delete(e)}collectServerRenderedStyles(){const e=this.doc.head?.querySelectorAll(`style[${d1}="${this.appId}"]`);if(e?.length){const r=new Map;return e.forEach(s=>{null!=s.textContent&&r.set(s.textContent,s)}),r}return null}changeUsageCount(e,r){const s=this.styleRef;if(s.has(e)){const i=s.get(e);return i.usage+=r,i.usage}return s.set(e,{usage:r,elements:[]}),r}getStyleElement(e,r){const s=this.styleNodesInDOM,i=s?.get(r);if(i?.parentNode===e)return s.delete(r),i.removeAttribute(d1),i;{const o=this.doc.createElement("style");return this.nonce&&o.setAttribute("nonce",this.nonce),o.textContent=r,this.platformIsServer&&o.setAttribute(d1,this.appId),o}}addStyleToHost(e,r){const s=this.getStyleElement(e,r);e.appendChild(s);const i=this.styleRef,o=i.get(r)?.elements;o?o.push(s):i.set(r,{elements:[s],usage:1})}resetHostNodes(){const e=this.hostNodes;e.clear(),e.add(this.doc.head)}}return n.\u0275fac=function(e){return new(e||n)(Le(xn),Le(Hy),Le(cT,8),Le(kd))},n.\u0275prov=ht({token:n,factory:n.\u0275fac}),n})();const h1={svg:"http://www.w3.org/2000/svg",xhtml:"http://www.w3.org/1999/xhtml",xlink:"http://www.w3.org/1999/xlink",xml:"http://www.w3.org/XML/1998/namespace",xmlns:"http://www.w3.org/2000/xmlns/",math:"http://www.w3.org/1998/MathML/"},p1=/%COMP%/g,RJ=new st("RemoveStylesOnCompDestory",{providedIn:"root",factory:()=>!1});function s$(n,t){return t.map(e=>e.replace(p1,n))}let f1=(()=>{class n{constructor(e,r,s,i,o,a,u,c=null){this.eventManager=e,this.sharedStylesHost=r,this.appId=s,this.removeStylesOnCompDestory=i,this.doc=o,this.platformId=a,this.ngZone=u,this.nonce=c,this.rendererByCompId=new Map,this.platformIsServer=KF(a),this.defaultRenderer=new m1(e,o,u,this.platformIsServer)}createRenderer(e,r){if(!e||!r)return this.defaultRenderer;this.platformIsServer&&r.encapsulation===pi.ShadowDom&&(r={...r,encapsulation:pi.Emulated});const s=this.getOrCreateRenderer(e,r);return s instanceof o$?s.applyToHost(e):s instanceof g1&&s.applyStyles(),s}getOrCreateRenderer(e,r){const s=this.rendererByCompId;let i=s.get(r.id);if(!i){const o=this.doc,a=this.ngZone,u=this.eventManager,c=this.sharedStylesHost,p=this.removeStylesOnCompDestory,m=this.platformIsServer;switch(r.encapsulation){case pi.Emulated:i=new o$(u,c,r,this.appId,p,o,a,m);break;case pi.ShadowDom:return new $J(u,c,e,r,o,a,this.nonce,m);default:i=new g1(u,c,r,p,o,a,m)}i.onDestroy=()=>s.delete(r.id),s.set(r.id,i)}return i}ngOnDestroy(){this.rendererByCompId.clear()}}return n.\u0275fac=function(e){return new(e||n)(Le(e$),Le(n$),Le(Hy),Le(RJ),Le(xn),Le(kd),Le(Zt),Le(cT))},n.\u0275prov=ht({token:n,factory:n.\u0275fac}),n})();class m1{constructor(t,e,r,s){this.eventManager=t,this.doc=e,this.ngZone=r,this.platformIsServer=s,this.data=Object.create(null),this.destroyNode=null}destroy(){}createElement(t,e){return e?this.doc.createElementNS(h1[e]||e,t):this.doc.createElement(t)}createComment(t){return this.doc.createComment(t)}createText(t){return this.doc.createTextNode(t)}appendChild(t,e){(i$(t)?t.content:t).appendChild(e)}insertBefore(t,e,r){t&&(i$(t)?t.content:t).insertBefore(e,r)}removeChild(t,e){t&&t.removeChild(e)}selectRootElement(t,e){let r="string"==typeof t?this.doc.querySelector(t):t;if(!r)throw new Error(`The selector "${t}" did not match any elements`);return e||(r.textContent=""),r}parentNode(t){return t.parentNode}nextSibling(t){return t.nextSibling}setAttribute(t,e,r,s){if(s){e=s+":"+e;const i=h1[s];i?t.setAttributeNS(i,e,r):t.setAttribute(e,r)}else t.setAttribute(e,r)}removeAttribute(t,e,r){if(r){const s=h1[r];s?t.removeAttributeNS(s,e):t.removeAttribute(`${r}:${e}`)}else t.removeAttribute(e)}addClass(t,e){t.classList.add(e)}removeClass(t,e){t.classList.remove(e)}setStyle(t,e,r,s){s&(bi.DashCase|bi.Important)?t.style.setProperty(e,r,s&bi.Important?"important":""):t.style[e]=r}removeStyle(t,e,r){r&bi.DashCase?t.style.removeProperty(e):t.style[e]=""}setProperty(t,e,r){t[e]=r}setValue(t,e){t.nodeValue=e}listen(t,e,r){if("string"==typeof t&&!(t=Wl().getGlobalEventTarget(this.doc,t)))throw new Error(`Unsupported event target ${t} for event ${e}`);return this.eventManager.addEventListener(t,e,this.decoratePreventDefault(r))}decoratePreventDefault(t){return e=>{if("__ngUnwrap__"===e)return t;!1===(this.platformIsServer?this.ngZone.runGuarded(()=>t(e)):t(e))&&(e.preventDefault(),e.returnValue=!1)}}}function i$(n){return"TEMPLATE"===n.tagName&&void 0!==n.content}class $J extends m1{constructor(t,e,r,s,i,o,a,u){super(t,i,o,u),this.sharedStylesHost=e,this.hostEl=r,this.shadowRoot=r.attachShadow({mode:"open"}),this.sharedStylesHost.addHost(this.shadowRoot);const c=s$(s.id,s.styles);for(const p of c){const m=document.createElement("style");a&&m.setAttribute("nonce",a),m.textContent=p,this.shadowRoot.appendChild(m)}}nodeOrShadowRoot(t){return t===this.hostEl?this.shadowRoot:t}appendChild(t,e){return super.appendChild(this.nodeOrShadowRoot(t),e)}insertBefore(t,e,r){return super.insertBefore(this.nodeOrShadowRoot(t),e,r)}removeChild(t,e){return super.removeChild(this.nodeOrShadowRoot(t),e)}parentNode(t){return this.nodeOrShadowRoot(super.parentNode(this.nodeOrShadowRoot(t)))}destroy(){this.sharedStylesHost.removeHost(this.shadowRoot)}}class g1 extends m1{constructor(t,e,r,s,i,o,a,u){super(t,i,o,a),this.sharedStylesHost=e,this.removeStylesOnCompDestory=s,this.rendererUsageCount=0,this.styles=u?s$(u,r.styles):r.styles}applyStyles(){this.sharedStylesHost.addStyles(this.styles),this.rendererUsageCount++}destroy(){this.removeStylesOnCompDestory&&(this.sharedStylesHost.removeStyles(this.styles),this.rendererUsageCount--,0===this.rendererUsageCount&&this.onDestroy?.())}}class o$ extends g1{constructor(t,e,r,s,i,o,a,u){const c=s+"-"+r.id;super(t,e,r,i,o,a,u,c),this.contentAttr=function MJ(n){return"_ngcontent-%COMP%".replace(p1,n)}(c),this.hostAttr=function PJ(n){return"_nghost-%COMP%".replace(p1,n)}(c)}applyToHost(t){this.applyStyles(),this.setAttribute(t,this.hostAttr,"")}createElement(t,e){const r=super.createElement(t,e);return super.setAttribute(r,this.contentAttr,""),r}}let LJ=(()=>{class n extends t${constructor(e){super(e)}supports(e){return!0}addEventListener(e,r,s){return e.addEventListener(r,s,!1),()=>this.removeEventListener(e,r,s)}removeEventListener(e,r,s){return e.removeEventListener(r,s)}}return n.\u0275fac=function(e){return new(e||n)(Le(xn))},n.\u0275prov=ht({token:n,factory:n.\u0275fac}),n})();const a$=["alt","control","meta","shift"],VJ={"\b":"Backspace","\t":"Tab","\x7f":"Delete","\x1b":"Escape",Del:"Delete",Esc:"Escape",Left:"ArrowLeft",Right:"ArrowRight",Up:"ArrowUp",Down:"ArrowDown",Menu:"ContextMenu",Scroll:"ScrollLock",Win:"OS"},BJ={alt:n=>n.altKey,control:n=>n.ctrlKey,meta:n=>n.metaKey,shift:n=>n.shiftKey};let zJ=(()=>{class n extends t${constructor(e){super(e)}supports(e){return null!=n.parseEventName(e)}addEventListener(e,r,s){const i=n.parseEventName(r),o=n.eventCallback(i.fullKey,s,this.manager.getZone());return this.manager.getZone().runOutsideAngular(()=>Wl().onAndCancel(e,i.domEventName,o))}static parseEventName(e){const r=e.toLowerCase().split("."),s=r.shift();if(0===r.length||"keydown"!==s&&"keyup"!==s)return null;const i=n._normalizeKey(r.pop());let o="",a=r.indexOf("code");if(a>-1&&(r.splice(a,1),o="code."),a$.forEach(c=>{const p=r.indexOf(c);p>-1&&(r.splice(p,1),o+=c+".")}),o+=i,0!=r.length||0===i.length)return null;const u={};return u.domEventName=s,u.fullKey=o,u}static matchEventFullKeyCode(e,r){let s=VJ[e.key]||e.key,i="";return r.indexOf("code.")>-1&&(s=e.code,i="code."),!(null==s||!s)&&(s=s.toLowerCase()," "===s?s="space":"."===s&&(s="dot"),a$.forEach(o=>{o!==s&&(0,BJ[o])(e)&&(i+=o+".")}),i+=s,i===r)}static eventCallback(e,r,s){return i=>{n.matchEventFullKeyCode(i,e)&&s.runGuarded(()=>r(i))}}static _normalizeKey(e){return"esc"===e?"escape":e}}return n.\u0275fac=function(e){return new(e||n)(Le(xn))},n.\u0275prov=ht({token:n,factory:n.\u0275fac}),n})();const WJ=eF(mZ,"browser",[{provide:kd,useValue:qF},{provide:xO,useValue:function UJ(){u1.makeCurrent()},multi:!0},{provide:xn,useFactory:function GJ(){return function H8(n){Xx=n}(document),document},deps:[]}]),HJ=new st(""),c$=[{provide:wb,useClass:class DJ{addToWindow(t){Xn.getAngularTestability=(r,s=!0)=>{const i=t.findTestabilityInTree(r,s);if(null==i)throw new Error("Could not find testability for element.");return i},Xn.getAllAngularTestabilities=()=>t.getAllTestabilities(),Xn.getAllAngularRootElements=()=>t.getAllRootElements(),Xn.frameworkStabilizers||(Xn.frameworkStabilizers=[]),Xn.frameworkStabilizers.push(r=>{const s=Xn.getAllAngularTestabilities();let i=s.length,o=!1;const a=function(u){o=o||u,i--,0==i&&r(o)};s.forEach(function(u){u.whenStable(a)})})}findTestabilityInTree(t,e,r){return null==e?null:t.getTestability(e)??(r?Wl().isShadowRoot(e)?this.findTestabilityInTree(t,e.host,!0):this.findTestabilityInTree(t,e.parentElement,!0):null)}},deps:[]},{provide:XP,useClass:AS,deps:[Zt,kS,wb]},{provide:AS,useClass:AS,deps:[Zt,kS,wb]}],d$=[{provide:iT,useValue:"root"},{provide:tc,useFactory:function jJ(){return new tc},deps:[]},{provide:c1,useClass:LJ,multi:!0,deps:[xn,Zt,kd]},{provide:c1,useClass:zJ,multi:!0,deps:[xn]},f1,n$,e$,{provide:qp,useExisting:f1},{provide:class QQ{},useClass:AJ,deps:[]},[]];let h$=(()=>{class n{constructor(e){}static withServerTransition(e){return{ngModule:n,providers:[{provide:Hy,useValue:e.appId}]}}}return n.\u0275fac=function(e){return new(e||n)(Le(HJ,12))},n.\u0275mod=ar({type:n}),n.\u0275inj=Jn({providers:[...d$,...c$],imports:[o1,gZ]}),n})(),p$=(()=>{class n{constructor(e){this._doc=e}getTitle(){return this._doc.title}setTitle(e){this._doc.title=e||""}}return n.\u0275fac=function(e){return new(e||n)(Le(xn))},n.\u0275prov=ht({token:n,factory:function(e){let r=null;return r=e?new e:function KJ(){return new p$(Le(xn))}(),r},providedIn:"root"}),n})();function zt(...n){return nt(n,Ol(n))}typeof window<"u"&&window;class fo extends vn{constructor(t){super(),this._value=t}get value(){return this.getValue()}_subscribe(t){const e=super._subscribe(t);return!e.closed&&t.next(this._value),e}getValue(){const{hasError:t,thrownError:e,_value:r}=this;if(t)throw e;return this._throwIfClosed(),r}next(t){super.next(this._value=t)}}const{isArray:eee}=Array,{getPrototypeOf:tee,prototype:nee,keys:ree}=Object;function y$(n){if(1===n.length){const t=n[0];if(eee(t))return{args:t,keys:null};if(function see(n){return n&&"object"==typeof n&&tee(n)===nee}(t)){const e=ree(t);return{args:e.map(r=>t[r]),keys:e}}}return{args:n,keys:null}}const{isArray:iee}=Array;function b1(n){return ct(t=>function oee(n,t){return iee(t)?n(...t):n(t)}(n,t))}function b$(n,t){return n.reduce((e,r,s)=>(e[r]=t[s],e),{})}function Bb(...n){const t=Ol(n),e=gp(n),{args:r,keys:s}=y$(n);if(0===r.length)return nt([],t);const i=new Dn(function aee(n,t,e=Ur){return r=>{_$(t,()=>{const{length:s}=n,i=new Array(s);let o=s,a=s;for(let u=0;u<s;u++)_$(t,()=>{const c=nt(n[u],t);let p=!1;c.subscribe(Pn(r,m=>{i[u]=m,p||(p=!0,a--),a||r.next(e(i.slice()))},()=>{--o||r.complete()}))},r)},r)}}(r,t,s?o=>b$(s,o):Ur));return e?i.pipe(b1(e)):i}function _$(n,t,e){n?$o(e,n,t):t()}const zb=we(n=>function(){n(this),this.name="EmptyError",this.message="no elements in sequence"});function Ub(...n){return function lee(){return qa(1)}()(nt(n,Ol(n)))}function jb(n){return new Dn(t=>{fs(n()).subscribe(t)})}function If(n,t){const e=X(n)?n:()=>n,r=s=>s.error(e());return new Dn(t?s=>t.schedule(r,0,s):r)}function _1(){return An((n,t)=>{let e=null;n._refCount++;const r=Pn(t,void 0,void 0,void 0,()=>{if(!n||n._refCount<=0||0<--n._refCount)return void(e=null);const s=n._connection,i=e;e=null,s&&(!i||s===i)&&s.unsubscribe(),t.unsubscribe()});n.subscribe(r),r.closed||(e=n.connect())})}class v$ extends Dn{constructor(t,e){super(),this.source=t,this.subjectFactory=e,this._subject=null,this._refCount=0,this._connection=null,Dl(t)&&(this.lift=t.lift)}_subscribe(t){return this.getSubject().subscribe(t)}getSubject(){const t=this._subject;return(!t||t.isStopped)&&(this._subject=this.subjectFactory()),this._subject}_teardown(){this._refCount=0;const{_connection:t}=this;this._subject=this._connection=null,t?.unsubscribe()}connect(){let t=this._connection;if(!t){t=this._connection=new ce;const e=this.getSubject();t.add(this.source.subscribe(Pn(e,void 0,()=>{this._teardown(),e.complete()},r=>{this._teardown(),e.error(r)},()=>this._teardown()))),t.closed&&(this._connection=null,t=ce.EMPTY)}return t}refCount(){return _1()(this)}}function al(n,t){return An((e,r)=>{let s=null,i=0,o=!1;const a=()=>o&&!s&&r.complete();e.subscribe(Pn(r,u=>{s?.unsubscribe();let c=0;const p=i++;fs(n(u,p)).subscribe(s=Pn(r,m=>r.next(t?t(u,m,p,c++):m),()=>{s=null,a()}))},()=>{o=!0,a()}))})}function mo(n){return n<=0?()=>Ri:An((t,e)=>{let r=0;t.subscribe(Pn(e,s=>{++r<=n&&(e.next(s),n<=r&&e.complete())}))})}function Gb(...n){const t=Ol(n);return An((e,r)=>{(t?Ub(n,e,t):Ub(n,e)).subscribe(r)})}function ti(n,t){return An((e,r)=>{let s=0;e.subscribe(Pn(r,i=>n.call(t,i,s++)&&r.next(i)))})}function Wb(n){return An((t,e)=>{let r=!1;t.subscribe(Pn(e,s=>{r=!0,e.next(s)},()=>{r||e.next(n),e.complete()}))})}function w$(n=uee){return An((t,e)=>{let r=!1;t.subscribe(Pn(e,s=>{r=!0,e.next(s)},()=>r?e.complete():e.error(n())))})}function uee(){return new zb}function uc(n,t){const e=arguments.length>=2;return r=>r.pipe(n?ti((s,i)=>n(s,i,r)):Ur,mo(1),e?Wb(t):w$(()=>new zb))}function Ef(n,t){return X(t)?fr(n,t,1):fr(n,1)}function ni(n,t,e){const r=X(n)||t||e?{next:n,error:t,complete:e}:n;return r?An((s,i)=>{var o;null===(o=r.subscribe)||void 0===o||o.call(r);let a=!0;s.subscribe(Pn(i,u=>{var c;null===(c=r.next)||void 0===c||c.call(r,u),i.next(u)},()=>{var u;a=!1,null===(u=r.complete)||void 0===u||u.call(r),i.complete()},u=>{var c;a=!1,null===(c=r.error)||void 0===c||c.call(r,u),i.error(u)},()=>{var u,c;a&&(null===(u=r.unsubscribe)||void 0===u||u.call(r)),null===(c=r.finalize)||void 0===c||c.call(r)}))}):Ur}function cc(n){return An((t,e)=>{let i,r=null,s=!1;r=t.subscribe(Pn(e,void 0,void 0,o=>{i=fs(n(o,cc(n)(t))),r?(r.unsubscribe(),r=null,i.subscribe(e)):s=!0})),s&&(r.unsubscribe(),r=null,i.subscribe(e))})}function v1(n){return n<=0?()=>Ri:An((t,e)=>{let r=[];t.subscribe(Pn(e,s=>{r.push(s),n<r.length&&r.shift()},()=>{for(const s of r)e.next(s);e.complete()},void 0,()=>{r=null}))})}function w1(n){return An((t,e)=>{try{t.subscribe(e)}finally{e.add(n)}})}const en="primary",Df=Symbol("RouteTitle");class fee{constructor(t){this.params=t||{}}has(t){return Object.prototype.hasOwnProperty.call(this.params,t)}get(t){if(this.has(t)){const e=this.params[t];return Array.isArray(e)?e[0]:e}return null}getAll(t){if(this.has(t)){const e=this.params[t];return Array.isArray(e)?e:[e]}return[]}get keys(){return Object.keys(this.params)}}function Qd(n){return new fee(n)}function mee(n,t,e){const r=e.path.split("/");if(r.length>n.length||"full"===e.pathMatch&&(t.hasChildren()||r.length<n.length))return null;const s={};for(let i=0;i<r.length;i++){const o=r[i],a=n[i];if(o.startsWith(":"))s[o.substring(1)]=a;else if(o!==a.path)return null}return{consumed:n.slice(0,r.length),posParams:s}}function Sa(n,t){const e=n?Object.keys(n):void 0,r=t?Object.keys(t):void 0;if(!e||!r||e.length!=r.length)return!1;let s;for(let i=0;i<e.length;i++)if(s=e[i],!x$(n[s],t[s]))return!1;return!0}function x$(n,t){if(Array.isArray(n)&&Array.isArray(t)){if(n.length!==t.length)return!1;const e=[...n].sort(),r=[...t].sort();return e.every((s,i)=>r[i]===s)}return n===t}function T$(n){return n.length>0?n[n.length-1]:null}function ql(n){return function JJ(n){return!!n&&(n instanceof Dn||X(n.lift)&&X(n.subscribe))}(n)?n:sf(n)?nt(Promise.resolve(n)):zt(n)}const yee={exact:function I$(n,t,e){if(!dc(n.segments,t.segments)||!Hb(n.segments,t.segments,e)||n.numberOfChildren!==t.numberOfChildren)return!1;for(const r in t.children)if(!n.children[r]||!I$(n.children[r],t.children[r],e))return!1;return!0},subset:E$},S$={exact:function bee(n,t){return Sa(n,t)},subset:function _ee(n,t){return Object.keys(t).length<=Object.keys(n).length&&Object.keys(t).every(e=>x$(n[e],t[e]))},ignored:()=>!0};function C$(n,t,e){return yee[e.paths](n.root,t.root,e.matrixParams)&&S$[e.queryParams](n.queryParams,t.queryParams)&&!("exact"===e.fragment&&n.fragment!==t.fragment)}function E$(n,t,e){return D$(n,t,t.segments,e)}function D$(n,t,e,r){if(n.segments.length>e.length){const s=n.segments.slice(0,e.length);return!(!dc(s,e)||t.hasChildren()||!Hb(s,e,r))}if(n.segments.length===e.length){if(!dc(n.segments,e)||!Hb(n.segments,e,r))return!1;for(const s in t.children)if(!n.children[s]||!E$(n.children[s],t.children[s],r))return!1;return!0}{const s=e.slice(0,n.segments.length),i=e.slice(n.segments.length);return!!(dc(n.segments,s)&&Hb(n.segments,s,r)&&n.children[en])&&D$(n.children[en],t,i,r)}}function Hb(n,t,e){return t.every((r,s)=>S$[e](n[s].parameters,r.parameters))}class Jd{constructor(t=new $n([],{}),e={},r=null){this.root=t,this.queryParams=e,this.fragment=r}get queryParamMap(){return this._queryParamMap||(this._queryParamMap=Qd(this.queryParams)),this._queryParamMap}toString(){return xee.serialize(this)}}class $n{constructor(t,e){this.segments=t,this.children=e,this.parent=null,Object.values(e).forEach(r=>r.parent=this)}hasChildren(){return this.numberOfChildren>0}get numberOfChildren(){return Object.keys(this.children).length}toString(){return qb(this)}}class Af{constructor(t,e){this.path=t,this.parameters=e}get parameterMap(){return this._parameterMap||(this._parameterMap=Qd(this.parameters)),this._parameterMap}toString(){return N$(this)}}function dc(n,t){return n.length===t.length&&n.every((e,r)=>e.path===t[r].path)}let kf=(()=>{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275prov=ht({token:n,factory:function(){return new x1},providedIn:"root"}),n})();class x1{parse(t){const e=new Ree(t);return new Jd(e.parseRootSegment(),e.parseQueryParams(),e.parseFragment())}serialize(t){const e=`/${Nf(t.root,!0)}`,r=function Cee(n){const t=Object.keys(n).map(e=>{const r=n[e];return Array.isArray(r)?r.map(s=>`${Kb(e)}=${Kb(s)}`).join("&"):`${Kb(e)}=${Kb(r)}`}).filter(e=>!!e);return t.length?`?${t.join("&")}`:""}(t.queryParams);return`${e}${r}${"string"==typeof t.fragment?`#${function Tee(n){return encodeURI(n)}(t.fragment)}`:""}`}}const xee=new x1;function qb(n){return n.segments.map(t=>N$(t)).join("/")}function Nf(n,t){if(!n.hasChildren())return qb(n);if(t){const e=n.children[en]?Nf(n.children[en],!1):"",r=[];return Object.entries(n.children).forEach(([s,i])=>{s!==en&&r.push(`${s}:${Nf(i,!1)}`)}),r.length>0?`${e}(${r.join("//")})`:e}{const e=function wee(n,t){let e=[];return Object.entries(n.children).forEach(([r,s])=>{r===en&&(e=e.concat(t(s,r)))}),Object.entries(n.children).forEach(([r,s])=>{r!==en&&(e=e.concat(t(s,r)))}),e}(n,(r,s)=>s===en?[Nf(n.children[en],!1)]:[`${s}:${Nf(r,!1)}`]);return 1===Object.keys(n.children).length&&null!=n.children[en]?`${qb(n)}/${e[0]}`:`${qb(n)}/(${e.join("//")})`}}function A$(n){return encodeURIComponent(n).replace(/%40/g,"@").replace(/%3A/gi,":").replace(/%24/g,"$").replace(/%2C/gi,",")}function Kb(n){return A$(n).replace(/%3B/gi,";")}function T1(n){return A$(n).replace(/\(/g,"%28").replace(/\)/g,"%29").replace(/%26/gi,"&")}function Xb(n){return decodeURIComponent(n)}function k$(n){return Xb(n.replace(/\+/g,"%20"))}function N$(n){return`${T1(n.path)}${function See(n){return Object.keys(n).map(t=>`;${T1(t)}=${T1(n[t])}`).join("")}(n.parameters)}`}const Iee=/^[^\/()?;#]+/;function S1(n){const t=n.match(Iee);return t?t[0]:""}const Eee=/^[^\/()?;=#]+/,Aee=/^[^=?&#]+/,Nee=/^[^&#]+/;class Ree{constructor(t){this.url=t,this.remaining=t}parseRootSegment(){return this.consumeOptional("/"),""===this.remaining||this.peekStartsWith("?")||this.peekStartsWith("#")?new $n([],{}):new $n([],this.parseChildren())}parseQueryParams(){const t={};if(this.consumeOptional("?"))do{this.parseQueryParam(t)}while(this.consumeOptional("&"));return t}parseFragment(){return this.consumeOptional("#")?decodeURIComponent(this.remaining):null}parseChildren(){if(""===this.remaining)return{};this.consumeOptional("/");const t=[];for(this.peekStartsWith("(")||t.push(this.parseSegment());this.peekStartsWith("/")&&!this.peekStartsWith("//")&&!this.peekStartsWith("/(");)this.capture("/"),t.push(this.parseSegment());let e={};this.peekStartsWith("/(")&&(this.capture("/"),e=this.parseParens(!0));let r={};return this.peekStartsWith("(")&&(r=this.parseParens(!1)),(t.length>0||Object.keys(e).length>0)&&(r[en]=new $n(t,e)),r}parseSegment(){const t=S1(this.remaining);if(""===t&&this.peekStartsWith(";"))throw new je(4009,!1);return this.capture(t),new Af(Xb(t),this.parseMatrixParams())}parseMatrixParams(){const t={};for(;this.consumeOptional(";");)this.parseParam(t);return t}parseParam(t){const e=function Dee(n){const t=n.match(Eee);return t?t[0]:""}(this.remaining);if(!e)return;this.capture(e);let r="";if(this.consumeOptional("=")){const s=S1(this.remaining);s&&(r=s,this.capture(r))}t[Xb(e)]=Xb(r)}parseQueryParam(t){const e=function kee(n){const t=n.match(Aee);return t?t[0]:""}(this.remaining);if(!e)return;this.capture(e);let r="";if(this.consumeOptional("=")){const o=function Oee(n){const t=n.match(Nee);return t?t[0]:""}(this.remaining);o&&(r=o,this.capture(r))}const s=k$(e),i=k$(r);if(t.hasOwnProperty(s)){let o=t[s];Array.isArray(o)||(o=[o],t[s]=o),o.push(i)}else t[s]=i}parseParens(t){const e={};for(this.capture("(");!this.consumeOptional(")")&&this.remaining.length>0;){const r=S1(this.remaining),s=this.remaining[r.length];if("/"!==s&&")"!==s&&";"!==s)throw new je(4010,!1);let i;r.indexOf(":")>-1?(i=r.slice(0,r.indexOf(":")),this.capture(i),this.capture(":")):t&&(i=en);const o=this.parseChildren();e[i]=1===Object.keys(o).length?o[en]:new $n([],o),this.consumeOptional("//")}return e}peekStartsWith(t){return this.remaining.startsWith(t)}consumeOptional(t){return!!this.peekStartsWith(t)&&(this.remaining=this.remaining.substring(t.length),!0)}capture(t){if(!this.consumeOptional(t))throw new je(4011,!1)}}function O$(n){return n.segments.length>0?new $n([],{[en]:n}):n}function R$(n){const t={};for(const r of Object.keys(n.children)){const i=R$(n.children[r]);if(r===en&&0===i.segments.length&&i.hasChildren())for(const[o,a]of Object.entries(i.children))t[o]=a;else(i.segments.length>0||i.hasChildren())&&(t[r]=i)}return function Mee(n){if(1===n.numberOfChildren&&n.children[en]){const t=n.children[en];return new $n(n.segments.concat(t.segments),t.children)}return n}(new $n(n.segments,t))}function hc(n){return n instanceof Jd}function M$(n){let t;const s=O$(function e(i){const o={};for(const u of i.children){const c=e(u);o[u.outlet]=c}const a=new $n(i.url,o);return i===n&&(t=a),a}(n.root));return t??s}function P$(n,t,e,r){let s=n;for(;s.parent;)s=s.parent;if(0===t.length)return C1(s,s,s,e,r);const i=function Fee(n){if("string"==typeof n[0]&&1===n.length&&"/"===n[0])return new $$(!0,0,n);let t=0,e=!1;const r=n.reduce((s,i,o)=>{if("object"==typeof i&&null!=i){if(i.outlets){const a={};return Object.entries(i.outlets).forEach(([u,c])=>{a[u]="string"==typeof c?c.split("/"):c}),[...s,{outlets:a}]}if(i.segmentPath)return[...s,i.segmentPath]}return"string"!=typeof i?[...s,i]:0===o?(i.split("/").forEach((a,u)=>{0==u&&"."===a||(0==u&&""===a?e=!0:".."===a?t++:""!=a&&s.push(a))}),s):[...s,i]},[]);return new $$(e,t,r)}(t);if(i.toRoot())return C1(s,s,new $n([],{}),e,r);const o=function $ee(n,t,e){if(n.isAbsolute)return new Zb(t,!0,0);if(!e)return new Zb(t,!1,NaN);if(null===e.parent)return new Zb(e,!0,0);const r=Yb(n.commands[0])?0:1;return function Lee(n,t,e){let r=n,s=t,i=e;for(;i>s;){if(i-=s,r=r.parent,!r)throw new je(4005,!1);s=r.segments.length}return new Zb(r,!1,s-i)}(e,e.segments.length-1+r,n.numberOfDoubleDots)}(i,s,n),a=o.processChildren?Rf(o.segmentGroup,o.index,i.commands):L$(o.segmentGroup,o.index,i.commands);return C1(s,o.segmentGroup,a,e,r)}function Yb(n){return"object"==typeof n&&null!=n&&!n.outlets&&!n.segmentPath}function Of(n){return"object"==typeof n&&null!=n&&n.outlets}function C1(n,t,e,r,s){let o,i={};r&&Object.entries(r).forEach(([u,c])=>{i[u]=Array.isArray(c)?c.map(p=>`${p}`):`${c}`}),o=n===t?e:F$(n,t,e);const a=O$(R$(o));return new Jd(a,i,s)}function F$(n,t,e){const r={};return Object.entries(n.children).forEach(([s,i])=>{r[s]=i===t?e:F$(i,t,e)}),new $n(n.segments,r)}class $${constructor(t,e,r){if(this.isAbsolute=t,this.numberOfDoubleDots=e,this.commands=r,t&&r.length>0&&Yb(r[0]))throw new je(4003,!1);const s=r.find(Of);if(s&&s!==T$(r))throw new je(4004,!1)}toRoot(){return this.isAbsolute&&1===this.commands.length&&"/"==this.commands[0]}}class Zb{constructor(t,e,r){this.segmentGroup=t,this.processChildren=e,this.index=r}}function L$(n,t,e){if(n||(n=new $n([],{})),0===n.segments.length&&n.hasChildren())return Rf(n,t,e);const r=function Bee(n,t,e){let r=0,s=t;const i={match:!1,pathIndex:0,commandIndex:0};for(;s<n.segments.length;){if(r>=e.length)return i;const o=n.segments[s],a=e[r];if(Of(a))break;const u=`${a}`,c=r<e.length-1?e[r+1]:null;if(s>0&&void 0===u)break;if(u&&c&&"object"==typeof c&&void 0===c.outlets){if(!B$(u,c,o))return i;r+=2}else{if(!B$(u,{},o))return i;r++}s++}return{match:!0,pathIndex:s,commandIndex:r}}(n,t,e),s=e.slice(r.commandIndex);if(r.match&&r.pathIndex<n.segments.length){const i=new $n(n.segments.slice(0,r.pathIndex),{});return i.children[en]=new $n(n.segments.slice(r.pathIndex),n.children),Rf(i,0,s)}return r.match&&0===s.length?new $n(n.segments,{}):r.match&&!n.hasChildren()?I1(n,t,e):r.match?Rf(n,0,s):I1(n,t,e)}function Rf(n,t,e){if(0===e.length)return new $n(n.segments,{});{const r=function Vee(n){return Of(n[0])?n[0].outlets:{[en]:n}}(e),s={};if(!r[en]&&n.children[en]&&1===n.numberOfChildren&&0===n.children[en].segments.length){const i=Rf(n.children[en],t,e);return new $n(n.segments,i.children)}return Object.entries(r).forEach(([i,o])=>{"string"==typeof o&&(o=[o]),null!==o&&(s[i]=L$(n.children[i],t,o))}),Object.entries(n.children).forEach(([i,o])=>{void 0===r[i]&&(s[i]=o)}),new $n(n.segments,s)}}function I1(n,t,e){const r=n.segments.slice(0,t);let s=0;for(;s<e.length;){const i=e[s];if(Of(i)){const u=zee(i.outlets);return new $n(r,u)}if(0===s&&Yb(e[0])){r.push(new Af(n.segments[t].path,V$(e[0]))),s++;continue}const o=Of(i)?i.outlets[en]:`${i}`,a=s<e.length-1?e[s+1]:null;o&&a&&Yb(a)?(r.push(new Af(o,V$(a))),s+=2):(r.push(new Af(o,{})),s++)}return new $n(r,{})}function zee(n){const t={};return Object.entries(n).forEach(([e,r])=>{"string"==typeof r&&(r=[r]),null!==r&&(t[e]=I1(new $n([],{}),0,r))}),t}function V$(n){const t={};return Object.entries(n).forEach(([e,r])=>t[e]=`${r}`),t}function B$(n,t,e){return n==e.path&&Sa(t,e.parameters)}const Mf="imperative";class Ca{constructor(t,e){this.id=t,this.url=e}}class E1 extends Ca{constructor(t,e,r="imperative",s=null){super(t,e),this.type=0,this.navigationTrigger=r,this.restoredState=s}toString(){return`NavigationStart(id: ${this.id}, url: '${this.url}')`}}class pc extends Ca{constructor(t,e,r){super(t,e),this.urlAfterRedirects=r,this.type=1}toString(){return`NavigationEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}')`}}class Qb extends Ca{constructor(t,e,r,s){super(t,e),this.reason=r,this.code=s,this.type=2}toString(){return`NavigationCancel(id: ${this.id}, url: '${this.url}')`}}class Pf extends Ca{constructor(t,e,r,s){super(t,e),this.reason=r,this.code=s,this.type=16}}class D1 extends Ca{constructor(t,e,r,s){super(t,e),this.error=r,this.target=s,this.type=3}toString(){return`NavigationError(id: ${this.id}, url: '${this.url}', error: ${this.error})`}}class Uee extends Ca{constructor(t,e,r,s){super(t,e),this.urlAfterRedirects=r,this.state=s,this.type=4}toString(){return`RoutesRecognized(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`}}class jee extends Ca{constructor(t,e,r,s){super(t,e),this.urlAfterRedirects=r,this.state=s,this.type=7}toString(){return`GuardsCheckStart(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`}}class Gee extends Ca{constructor(t,e,r,s,i){super(t,e),this.urlAfterRedirects=r,this.state=s,this.shouldActivate=i,this.type=8}toString(){return`GuardsCheckEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state}, shouldActivate: ${this.shouldActivate})`}}class Wee extends Ca{constructor(t,e,r,s){super(t,e),this.urlAfterRedirects=r,this.state=s,this.type=5}toString(){return`ResolveStart(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`}}class Hee extends Ca{constructor(t,e,r,s){super(t,e),this.urlAfterRedirects=r,this.state=s,this.type=6}toString(){return`ResolveEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`}}class qee{constructor(t){this.route=t,this.type=9}toString(){return`RouteConfigLoadStart(path: ${this.route.path})`}}class Kee{constructor(t){this.route=t,this.type=10}toString(){return`RouteConfigLoadEnd(path: ${this.route.path})`}}class Xee{constructor(t){this.snapshot=t,this.type=11}toString(){return`ChildActivationStart(path: '${this.snapshot.routeConfig&&this.snapshot.routeConfig.path||""}')`}}class Yee{constructor(t){this.snapshot=t,this.type=12}toString(){return`ChildActivationEnd(path: '${this.snapshot.routeConfig&&this.snapshot.routeConfig.path||""}')`}}class Zee{constructor(t){this.snapshot=t,this.type=13}toString(){return`ActivationStart(path: '${this.snapshot.routeConfig&&this.snapshot.routeConfig.path||""}')`}}class Qee{constructor(t){this.snapshot=t,this.type=14}toString(){return`ActivationEnd(path: '${this.snapshot.routeConfig&&this.snapshot.routeConfig.path||""}')`}}class z${constructor(t,e,r){this.routerEvent=t,this.position=e,this.anchor=r,this.type=15}toString(){return`Scroll(anchor: '${this.anchor}', position: '${this.position?`${this.position[0]}, ${this.position[1]}`:null}')`}}class Jee{constructor(){this.outlet=null,this.route=null,this.injector=null,this.children=new Ff,this.attachRef=null}}let Ff=(()=>{class n{constructor(){this.contexts=new Map}onChildOutletCreated(e,r){const s=this.getOrCreateContext(e);s.outlet=r,this.contexts.set(e,s)}onChildOutletDestroyed(e){const r=this.getContext(e);r&&(r.outlet=null,r.attachRef=null)}onOutletDeactivated(){const e=this.contexts;return this.contexts=new Map,e}onOutletReAttached(e){this.contexts=e}getOrCreateContext(e){let r=this.getContext(e);return r||(r=new Jee,this.contexts.set(e,r)),r}getContext(e){return this.contexts.get(e)||null}}return n.\u0275fac=function(e){return new(e||n)},n.\u0275prov=ht({token:n,factory:n.\u0275fac,providedIn:"root"}),n})();class U${constructor(t){this._root=t}get root(){return this._root.value}parent(t){const e=this.pathFromRoot(t);return e.length>1?e[e.length-2]:null}children(t){const e=A1(t,this._root);return e?e.children.map(r=>r.value):[]}firstChild(t){const e=A1(t,this._root);return e&&e.children.length>0?e.children[0].value:null}siblings(t){const e=k1(t,this._root);return e.length<2?[]:e[e.length-2].children.map(s=>s.value).filter(s=>s!==t)}pathFromRoot(t){return k1(t,this._root).map(e=>e.value)}}function A1(n,t){if(n===t.value)return t;for(const e of t.children){const r=A1(n,e);if(r)return r}return null}function k1(n,t){if(n===t.value)return[t];for(const e of t.children){const r=k1(n,e);if(r.length)return r.unshift(t),r}return[]}class ll{constructor(t,e){this.value=t,this.children=e}toString(){return`TreeNode(${this.value})`}}function eh(n){const t={};return n&&n.children.forEach(e=>t[e.value.outlet]=e),t}class j$ extends U${constructor(t,e){super(t),this.snapshot=e,N1(this,t)}toString(){return this.snapshot.toString()}}function G$(n,t){const e=function ete(n,t){const o=new Jb([],{},{},"",{},en,t,null,{});return new H$("",new ll(o,[]))}(0,t),r=new fo([new Af("",{})]),s=new fo({}),i=new fo({}),o=new fo({}),a=new fo(""),u=new th(r,s,o,a,i,en,t,e.root);return u.snapshot=e.root,new j$(new ll(u,[]),e)}class th{constructor(t,e,r,s,i,o,a,u){this.urlSubject=t,this.paramsSubject=e,this.queryParamsSubject=r,this.fragmentSubject=s,this.dataSubject=i,this.outlet=o,this.component=a,this._futureSnapshot=u,this.title=this.dataSubject?.pipe(ct(c=>c[Df]))??zt(void 0),this.url=t,this.params=e,this.queryParams=r,this.fragment=s,this.data=i}get routeConfig(){return this._futureSnapshot.routeConfig}get root(){return this._routerState.root}get parent(){return this._routerState.parent(this)}get firstChild(){return this._routerState.firstChild(this)}get children(){return this._routerState.children(this)}get pathFromRoot(){return this._routerState.pathFromRoot(this)}get paramMap(){return this._paramMap||(this._paramMap=this.params.pipe(ct(t=>Qd(t)))),this._paramMap}get queryParamMap(){return this._queryParamMap||(this._queryParamMap=this.queryParams.pipe(ct(t=>Qd(t)))),this._queryParamMap}toString(){return this.snapshot?this.snapshot.toString():`Future(${this._futureSnapshot})`}}function W$(n,t="emptyOnly"){const e=n.pathFromRoot;let r=0;if("always"!==t)for(r=e.length-1;r>=1;){const s=e[r],i=e[r-1];if(s.routeConfig&&""===s.routeConfig.path)r--;else{if(i.component)break;r--}}return function tte(n){return n.reduce((t,e)=>({params:{...t.params,...e.params},data:{...t.data,...e.data},resolve:{...e.data,...t.resolve,...e.routeConfig?.data,...e._resolvedData}}),{params:{},data:{},resolve:{}})}(e.slice(r))}class Jb{get title(){return this.data?.[Df]}constructor(t,e,r,s,i,o,a,u,c){this.url=t,this.params=e,this.queryParams=r,this.fragment=s,this.data=i,this.outlet=o,this.component=a,this.routeConfig=u,this._resolve=c}get root(){return this._routerState.root}get parent(){return this._routerState.parent(this)}get firstChild(){return this._routerState.firstChild(this)}get children(){return this._routerState.children(this)}get pathFromRoot(){return this._routerState.pathFromRoot(this)}get paramMap(){return this._paramMap||(this._paramMap=Qd(this.params)),this._paramMap}get queryParamMap(){return this._queryParamMap||(this._queryParamMap=Qd(this.queryParams)),this._queryParamMap}toString(){return`Route(url:'${this.url.map(r=>r.toString()).join("/")}', path:'${this.routeConfig?this.routeConfig.path:""}')`}}class H$ extends U${constructor(t,e){super(e),this.url=t,N1(this,e)}toString(){return q$(this._root)}}function N1(n,t){t.value._routerState=n,t.children.forEach(e=>N1(n,e))}function q$(n){const t=n.children.length>0?` { ${n.children.map(q$).join(", ")} } `:"";return`${n.value}${t}`}function O1(n){if(n.snapshot){const t=n.snapshot,e=n._futureSnapshot;n.snapshot=e,Sa(t.queryParams,e.queryParams)||n.queryParamsSubject.next(e.queryParams),t.fragment!==e.fragment&&n.fragmentSubject.next(e.fragment),Sa(t.params,e.params)||n.paramsSubject.next(e.params),function gee(n,t){if(n.length!==t.length)return!1;for(let e=0;e<n.length;++e)if(!Sa(n[e],t[e]))return!1;return!0}(t.url,e.url)||n.urlSubject.next(e.url),Sa(t.data,e.data)||n.dataSubject.next(e.data)}else n.snapshot=n._futureSnapshot,n.dataSubject.next(n._futureSnapshot.data)}function R1(n,t){const e=Sa(n.params,t.params)&&function vee(n,t){return dc(n,t)&&n.every((e,r)=>Sa(e.parameters,t[r].parameters))}(n.url,t.url);return e&&!(!n.parent!=!t.parent)&&(!n.parent||R1(n.parent,t.parent))}let K$=(()=>{class n{constructor(){this.activated=null,this._activatedRoute=null,this.name=en,this.activateEvents=new On,this.deactivateEvents=new On,this.attachEvents=new On,this.detachEvents=new On,this.parentContexts=Ct(Ff),this.location=Ct(lo),this.changeDetector=Ct(Ta),this.environmentInjector=Ct(tl),this.inputBinder=Ct(e_,{optional:!0}),this.supportsBindingToComponentInputs=!0}get activatedComponentRef(){return this.activated}ngOnChanges(e){if(e.name){const{firstChange:r,previousValue:s}=e.name;if(r)return;this.isTrackedInParentContexts(s)&&(this.deactivate(),this.parentContexts.onChildOutletDestroyed(s)),this.initializeOutletWithName()}}ngOnDestroy(){this.isTrackedInParentContexts(this.name)&&this.parentContexts.onChildOutletDestroyed(this.name),this.inputBinder?.unsubscribeFromRouteData(this)}isTrackedInParentContexts(e){return this.parentContexts.getContext(e)?.outlet===this}ngOnInit(){this.initializeOutletWithName()}initializeOutletWithName(){if(this.parentContexts.onChildOutletCreated(this.name,this),this.activated)return;const e=this.parentContexts.getContext(this.name);e?.route&&(e.attachRef?this.attach(e.attachRef,e.route):this.activateWith(e.route,e.injector))}get isActivated(){return!!this.activated}get component(){if(!this.activated)throw new je(4012,!1);return this.activated.instance}get activatedRoute(){if(!this.activated)throw new je(4012,!1);return this._activatedRoute}get activatedRouteData(){return this._activatedRoute?this._activatedRoute.snapshot.data:{}}detach(){if(!this.activated)throw new je(4012,!1);this.location.detach();const e=this.activated;return this.activated=null,this._activatedRoute=null,this.detachEvents.emit(e.instance),e}attach(e,r){this.activated=e,this._activatedRoute=r,this.location.insert(e.hostView),this.inputBinder?.bindActivatedRouteToOutletComponent(this),this.attachEvents.emit(e.instance)}deactivate(){if(this.activated){const e=this.component;this.activated.destroy(),this.activated=null,this._activatedRoute=null,this.deactivateEvents.emit(e)}}activateWith(e,r){if(this.isActivated)throw new je(4013,!1);this._activatedRoute=e;const s=this.location,o=e.snapshot.component,a=this.parentContexts.getOrCreateContext(this.name).children,u=new nte(e,a,s.injector);this.activated=s.createComponent(o,{index:s.length,injector:u,environmentInjector:r??this.environmentInjector}),this.changeDetector.markForCheck(),this.inputBinder?.bindActivatedRouteToOutletComponent(this),this.activateEvents.emit(this.activated.instance)}}return n.\u0275fac=function(e){return new(e||n)},n.\u0275dir=Pt({type:n,selectors:[["router-outlet"]],inputs:{name:"name"},outputs:{activateEvents:"activate",deactivateEvents:"deactivate",attachEvents:"attach",detachEvents:"detach"},exportAs:["outlet"],standalone:!0,features:[so]}),n})();class nte{constructor(t,e,r){this.route=t,this.childContexts=e,this.parent=r}get(t,e){return t===th?this.route:t===Ff?this.childContexts:this.parent.get(t,e)}}const e_=new st("");let X$=(()=>{class n{constructor(){this.outletDataSubscriptions=new Map}bindActivatedRouteToOutletComponent(e){this.unsubscribeFromRouteData(e),this.subscribeToRouteData(e)}unsubscribeFromRouteData(e){this.outletDataSubscriptions.get(e)?.unsubscribe(),this.outletDataSubscriptions.delete(e)}subscribeToRouteData(e){const{activatedRoute:r}=e,s=Bb([r.queryParams,r.params,r.data]).pipe(al(([i,o,a],u)=>(a={...i,...o,...a},0===u?zt(a):Promise.resolve(a)))).subscribe(i=>{if(!e.isActivated||!e.activatedComponentRef||e.activatedRoute!==r||null===r.component)return void this.unsubscribeFromRouteData(e);const o=function IZ(n){const t=En(n);if(!t)return null;const e=new Qp(t);return{get selector(){return e.selector},get type(){return e.componentType},get inputs(){return e.inputs},get outputs(){return e.outputs},get ngContentSelectors(){return e.ngContentSelectors},get isStandalone(){return t.standalone}}}(r.component);if(o)for(const{templateName:a}of o.inputs)e.activatedComponentRef.setInput(a,i[a]);else this.unsubscribeFromRouteData(e)});this.outletDataSubscriptions.set(e,s)}}return n.\u0275fac=function(e){return new(e||n)},n.\u0275prov=ht({token:n,factory:n.\u0275fac}),n})();function $f(n,t,e){if(e&&n.shouldReuseRoute(t.value,e.value.snapshot)){const r=e.value;r._futureSnapshot=t.value;const s=function ste(n,t,e){return t.children.map(r=>{for(const s of e.children)if(n.shouldReuseRoute(r.value,s.value.snapshot))return $f(n,r,s);return $f(n,r)})}(n,t,e);return new ll(r,s)}{if(n.shouldAttach(t.value)){const i=n.retrieve(t.value);if(null!==i){const o=i.route;return o.value._futureSnapshot=t.value,o.children=t.children.map(a=>$f(n,a)),o}}const r=function ite(n){return new th(new fo(n.url),new fo(n.params),new fo(n.queryParams),new fo(n.fragment),new fo(n.data),n.outlet,n.component,n)}(t.value),s=t.children.map(i=>$f(n,i));return new ll(r,s)}}const M1="ngNavigationCancelingError";function Y$(n,t){const{redirectTo:e,navigationBehaviorOptions:r}=hc(t)?{redirectTo:t,navigationBehaviorOptions:void 0}:t,s=Z$(!1,0,t);return s.url=e,s.navigationBehaviorOptions=r,s}function Z$(n,t,e){const r=new Error("NavigationCancelingError: "+(n||""));return r[M1]=!0,r.cancellationCode=t,e&&(r.url=e),r}function Q$(n){return J$(n)&&hc(n.url)}function J$(n){return n&&n[M1]}let eL=(()=>{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275cmp=Bo({type:n,selectors:[["ng-component"]],standalone:!0,features:[JM],decls:1,vars:0,template:function(e,r){1&e&&Qs(0,"router-outlet")},dependencies:[K$],encapsulation:2}),n})();function P1(n){const t=n.children&&n.children.map(P1),e=t?{...n,children:t}:{...n};return!e.component&&!e.loadComponent&&(t||e.loadChildren)&&e.outlet&&e.outlet!==en&&(e.component=eL),e}function Ko(n){return n.outlet||en}function Lf(n){if(!n)return null;if(n.routeConfig?._injector)return n.routeConfig._injector;for(let t=n.parent;t;t=t.parent){const e=t.routeConfig;if(e?._loadedInjector)return e._loadedInjector;if(e?._injector)return e._injector}return null}class hte{constructor(t,e,r,s,i){this.routeReuseStrategy=t,this.futureState=e,this.currState=r,this.forwardEvent=s,this.inputBindingEnabled=i}activate(t){const e=this.futureState._root,r=this.currState?this.currState._root:null;this.deactivateChildRoutes(e,r,t),O1(this.futureState.root),this.activateChildRoutes(e,r,t)}deactivateChildRoutes(t,e,r){const s=eh(e);t.children.forEach(i=>{const o=i.value.outlet;this.deactivateRoutes(i,s[o],r),delete s[o]}),Object.values(s).forEach(i=>{this.deactivateRouteAndItsChildren(i,r)})}deactivateRoutes(t,e,r){const s=t.value,i=e?e.value:null;if(s===i)if(s.component){const o=r.getContext(s.outlet);o&&this.deactivateChildRoutes(t,e,o.children)}else this.deactivateChildRoutes(t,e,r);else i&&this.deactivateRouteAndItsChildren(e,r)}deactivateRouteAndItsChildren(t,e){t.value.component&&this.routeReuseStrategy.shouldDetach(t.value.snapshot)?this.detachAndStoreRouteSubtree(t,e):this.deactivateRouteAndOutlet(t,e)}detachAndStoreRouteSubtree(t,e){const r=e.getContext(t.value.outlet),s=r&&t.value.component?r.children:e,i=eh(t);for(const o of Object.keys(i))this.deactivateRouteAndItsChildren(i[o],s);if(r&&r.outlet){const o=r.outlet.detach(),a=r.children.onOutletDeactivated();this.routeReuseStrategy.store(t.value.snapshot,{componentRef:o,route:t,contexts:a})}}deactivateRouteAndOutlet(t,e){const r=e.getContext(t.value.outlet),s=r&&t.value.component?r.children:e,i=eh(t);for(const o of Object.keys(i))this.deactivateRouteAndItsChildren(i[o],s);r&&(r.outlet&&(r.outlet.deactivate(),r.children.onOutletDeactivated()),r.attachRef=null,r.route=null)}activateChildRoutes(t,e,r){const s=eh(e);t.children.forEach(i=>{this.activateRoutes(i,s[i.value.outlet],r),this.forwardEvent(new Qee(i.value.snapshot))}),t.children.length&&this.forwardEvent(new Yee(t.value.snapshot))}activateRoutes(t,e,r){const s=t.value,i=e?e.value:null;if(O1(s),s===i)if(s.component){const o=r.getOrCreateContext(s.outlet);this.activateChildRoutes(t,e,o.children)}else this.activateChildRoutes(t,e,r);else if(s.component){const o=r.getOrCreateContext(s.outlet);if(this.routeReuseStrategy.shouldAttach(s.snapshot)){const a=this.routeReuseStrategy.retrieve(s.snapshot);this.routeReuseStrategy.store(s.snapshot,null),o.children.onOutletReAttached(a.contexts),o.attachRef=a.componentRef,o.route=a.route.value,o.outlet&&o.outlet.attach(a.componentRef,a.route.value),O1(a.route.value),this.activateChildRoutes(t,null,o.children)}else{const a=Lf(s.snapshot);o.attachRef=null,o.route=s,o.injector=a,o.outlet&&o.outlet.activateWith(s,o.injector),this.activateChildRoutes(t,null,o.children)}}else this.activateChildRoutes(t,null,r)}}class tL{constructor(t){this.path=t,this.route=this.path[this.path.length-1]}}class t_{constructor(t,e){this.component=t,this.route=e}}function pte(n,t,e){const r=n._root;return Vf(r,t?t._root:null,e,[r.value])}function nh(n,t){const e=Symbol(),r=t.get(n,e);return r===e?"function"!=typeof n||function pH(n){return null!==oy(n)}(n)?t.get(n):n:r}function Vf(n,t,e,r,s={canDeactivateChecks:[],canActivateChecks:[]}){const i=eh(t);return n.children.forEach(o=>{(function mte(n,t,e,r,s={canDeactivateChecks:[],canActivateChecks:[]}){const i=n.value,o=t?t.value:null,a=e?e.getContext(n.value.outlet):null;if(o&&i.routeConfig===o.routeConfig){const u=function gte(n,t,e){if("function"==typeof e)return e(n,t);switch(e){case"pathParamsChange":return!dc(n.url,t.url);case"pathParamsOrQueryParamsChange":return!dc(n.url,t.url)||!Sa(n.queryParams,t.queryParams);case"always":return!0;case"paramsOrQueryParamsChange":return!R1(n,t)||!Sa(n.queryParams,t.queryParams);default:return!R1(n,t)}}(o,i,i.routeConfig.runGuardsAndResolvers);u?s.canActivateChecks.push(new tL(r)):(i.data=o.data,i._resolvedData=o._resolvedData),Vf(n,t,i.component?a?a.children:null:e,r,s),u&&a&&a.outlet&&a.outlet.isActivated&&s.canDeactivateChecks.push(new t_(a.outlet.component,o))}else o&&Bf(t,a,s),s.canActivateChecks.push(new tL(r)),Vf(n,null,i.component?a?a.children:null:e,r,s)})(o,i[o.value.outlet],e,r.concat([o.value]),s),delete i[o.value.outlet]}),Object.entries(i).forEach(([o,a])=>Bf(a,e.getContext(o),s)),s}function Bf(n,t,e){const r=eh(n),s=n.value;Object.entries(r).forEach(([i,o])=>{Bf(o,s.component?t?t.children.getContext(i):null:t,e)}),e.canDeactivateChecks.push(new t_(s.component&&t&&t.outlet&&t.outlet.isActivated?t.outlet.component:null,s))}function zf(n){return"function"==typeof n}function nL(n){return n instanceof zb||"EmptyError"===n?.name}const n_=Symbol("INITIAL_VALUE");function rh(){return al(n=>Bb(n.map(t=>t.pipe(mo(1),Gb(n_)))).pipe(ct(t=>{for(const e of t)if(!0!==e){if(e===n_)return n_;if(!1===e||e instanceof Jd)return e}return!0}),ti(t=>t!==n_),mo(1)))}function rL(n){return function Ks(...n){return Wa(n)}(ni(t=>{if(hc(t))throw Y$(0,t)}),ct(t=>!0===t))}class r_{constructor(t){this.segmentGroup=t||null}}class sL{constructor(t){this.urlTree=t}}function sh(n){return If(new r_(n))}function iL(n){return If(new sL(n))}class Fte{constructor(t,e){this.urlSerializer=t,this.urlTree=e}noMatchError(t){return new je(4002,!1)}lineralizeSegments(t,e){let r=[],s=e.root;for(;;){if(r=r.concat(s.segments),0===s.numberOfChildren)return zt(r);if(s.numberOfChildren>1||!s.children[en])return If(new je(4e3,!1));s=s.children[en]}}applyRedirectCommands(t,e,r){return this.applyRedirectCreateUrlTree(e,this.urlSerializer.parse(e),t,r)}applyRedirectCreateUrlTree(t,e,r,s){const i=this.createSegmentGroup(t,e.root,r,s);return new Jd(i,this.createQueryParams(e.queryParams,this.urlTree.queryParams),e.fragment)}createQueryParams(t,e){const r={};return Object.entries(t).forEach(([s,i])=>{if("string"==typeof i&&i.startsWith(":")){const a=i.substring(1);r[s]=e[a]}else r[s]=i}),r}createSegmentGroup(t,e,r,s){const i=this.createSegments(t,e.segments,r,s);let o={};return Object.entries(e.children).forEach(([a,u])=>{o[a]=this.createSegmentGroup(t,u,r,s)}),new $n(i,o)}createSegments(t,e,r,s){return e.map(i=>i.path.startsWith(":")?this.findPosParam(t,i,s):this.findOrReturn(i,r))}findPosParam(t,e,r){const s=r[e.path.substring(1)];if(!s)throw new je(4001,!1);return s}findOrReturn(t,e){let r=0;for(const s of e){if(s.path===t.path)return e.splice(r),s;r++}return t}}const F1={matched:!1,consumedSegments:[],remainingSegments:[],parameters:{},positionalParamSegments:{}};function $te(n,t,e,r,s){const i=$1(n,t,e);return i.matched?(r=function ote(n,t){return n.providers&&!n._injector&&(n._injector=aS(n.providers,t,`Route: ${n.path}`)),n._injector??t}(t,r),function Rte(n,t,e,r){const s=t.canMatch;return s&&0!==s.length?zt(s.map(o=>{const a=nh(o,n);return ql(function xte(n){return n&&zf(n.canMatch)}(a)?a.canMatch(t,e):n.runInContext(()=>a(t,e)))})).pipe(rh(),rL()):zt(!0)}(r,t,e).pipe(ct(o=>!0===o?i:{...F1}))):zt(i)}function $1(n,t,e){if(""===t.path)return"full"===t.pathMatch&&(n.hasChildren()||e.length>0)?{...F1}:{matched:!0,consumedSegments:[],remainingSegments:e,parameters:{},positionalParamSegments:{}};const s=(t.matcher||mee)(e,n,t);if(!s)return{...F1};const i={};Object.entries(s.posParams??{}).forEach(([a,u])=>{i[a]=u.path});const o=s.consumed.length>0?{...i,...s.consumed[s.consumed.length-1].parameters}:i;return{matched:!0,consumedSegments:s.consumed,remainingSegments:e.slice(s.consumed.length),parameters:o,positionalParamSegments:s.posParams??{}}}function oL(n,t,e,r){return e.length>0&&function Bte(n,t,e){return e.some(r=>s_(n,t,r)&&Ko(r)!==en)}(n,e,r)?{segmentGroup:new $n(t,Vte(r,new $n(e,n.children))),slicedSegments:[]}:0===e.length&&function zte(n,t,e){return e.some(r=>s_(n,t,r))}(n,e,r)?{segmentGroup:new $n(n.segments,Lte(n,0,e,r,n.children)),slicedSegments:e}:{segmentGroup:new $n(n.segments,n.children),slicedSegments:e}}function Lte(n,t,e,r,s){const i={};for(const o of r)if(s_(n,e,o)&&!s[Ko(o)]){const a=new $n([],{});i[Ko(o)]=a}return{...s,...i}}function Vte(n,t){const e={};e[en]=t;for(const r of n)if(""===r.path&&Ko(r)!==en){const s=new $n([],{});e[Ko(r)]=s}return e}function s_(n,t,e){return(!(n.hasChildren()||t.length>0)||"full"!==e.pathMatch)&&""===e.path}class Wte{constructor(t,e,r,s,i,o,a){this.injector=t,this.configLoader=e,this.rootComponentType=r,this.config=s,this.urlTree=i,this.paramsInheritanceStrategy=o,this.urlSerializer=a,this.allowRedirects=!0,this.applyRedirects=new Fte(this.urlSerializer,this.urlTree)}noMatchError(t){return new je(4002,!1)}recognize(){const t=oL(this.urlTree.root,[],[],this.config).segmentGroup;return this.processSegmentGroup(this.injector,this.config,t,en).pipe(cc(e=>{if(e instanceof sL)return this.allowRedirects=!1,this.urlTree=e.urlTree,this.match(e.urlTree);throw e instanceof r_?this.noMatchError(e):e}),ct(e=>{const r=new Jb([],Object.freeze({}),Object.freeze({...this.urlTree.queryParams}),this.urlTree.fragment,{},en,this.rootComponentType,null,{}),s=new ll(r,e),i=new H$("",s),o=function Pee(n,t,e=null,r=null){return P$(M$(n),t,e,r)}(r,[],this.urlTree.queryParams,this.urlTree.fragment);return o.queryParams=this.urlTree.queryParams,i.url=this.urlSerializer.serialize(o),this.inheritParamsAndData(i._root),{state:i,tree:o}}))}match(t){return this.processSegmentGroup(this.injector,this.config,t.root,en).pipe(cc(r=>{throw r instanceof r_?this.noMatchError(r):r}))}inheritParamsAndData(t){const e=t.value,r=W$(e,this.paramsInheritanceStrategy);e.params=Object.freeze(r.params),e.data=Object.freeze(r.data),t.children.forEach(s=>this.inheritParamsAndData(s))}processSegmentGroup(t,e,r,s){return 0===r.segments.length&&r.hasChildren()?this.processChildren(t,e,r):this.processSegment(t,e,r,r.segments,s,!0)}processChildren(t,e,r){const s=[];for(const i of Object.keys(r.children))"primary"===i?s.unshift(i):s.push(i);return nt(s).pipe(Ef(i=>{const o=r.children[i],a=function cte(n,t){const e=n.filter(r=>Ko(r)===t);return e.push(...n.filter(r=>Ko(r)!==t)),e}(e,i);return this.processSegmentGroup(t,a,o,i)}),function dee(n,t){return An(function cee(n,t,e,r,s){return(i,o)=>{let a=e,u=t,c=0;i.subscribe(Pn(o,p=>{const m=c++;u=a?n(u,p,m):(a=!0,p),r&&o.next(u)},s&&(()=>{a&&o.next(u),o.complete()})))}}(n,t,arguments.length>=2,!0))}((i,o)=>(i.push(...o),i)),Wb(null),function hee(n,t){const e=arguments.length>=2;return r=>r.pipe(n?ti((s,i)=>n(s,i,r)):Ur,v1(1),e?Wb(t):w$(()=>new zb))}(),fr(i=>{if(null===i)return sh(r);const o=aL(i);return function Hte(n){n.sort((t,e)=>t.value.outlet===en?-1:e.value.outlet===en?1:t.value.outlet.localeCompare(e.value.outlet))}(o),zt(o)}))}processSegment(t,e,r,s,i,o){return nt(e).pipe(Ef(a=>this.processSegmentAgainstRoute(a._injector??t,e,a,r,s,i,o).pipe(cc(u=>{if(u instanceof r_)return zt(null);throw u}))),uc(a=>!!a),cc(a=>{if(nL(a))return function jte(n,t,e){return 0===t.length&&!n.children[e]}(r,s,i)?zt([]):sh(r);throw a}))}processSegmentAgainstRoute(t,e,r,s,i,o,a){return function Ute(n,t,e,r){return!!(Ko(n)===r||r!==en&&s_(t,e,n))&&("**"===n.path||$1(t,n,e).matched)}(r,s,i,o)?void 0===r.redirectTo?this.matchSegmentAgainstRoute(t,s,r,i,o,a):a&&this.allowRedirects?this.expandSegmentAgainstRouteUsingRedirect(t,s,e,r,i,o):sh(s):sh(s)}expandSegmentAgainstRouteUsingRedirect(t,e,r,s,i,o){return"**"===s.path?this.expandWildCardWithParamsAgainstRouteUsingRedirect(t,r,s,o):this.expandRegularSegmentAgainstRouteUsingRedirect(t,e,r,s,i,o)}expandWildCardWithParamsAgainstRouteUsingRedirect(t,e,r,s){const i=this.applyRedirects.applyRedirectCommands([],r.redirectTo,{});return r.redirectTo.startsWith("/")?iL(i):this.applyRedirects.lineralizeSegments(r,i).pipe(fr(o=>{const a=new $n(o,{});return this.processSegment(t,e,a,o,s,!1)}))}expandRegularSegmentAgainstRouteUsingRedirect(t,e,r,s,i,o){const{matched:a,consumedSegments:u,remainingSegments:c,positionalParamSegments:p}=$1(e,s,i);if(!a)return sh(e);const m=this.applyRedirects.applyRedirectCommands(u,s.redirectTo,p);return s.redirectTo.startsWith("/")?iL(m):this.applyRedirects.lineralizeSegments(s,m).pipe(fr(y=>this.processSegment(t,r,e,y.concat(c),o,!1)))}matchSegmentAgainstRoute(t,e,r,s,i,o){let a;if("**"===r.path){const u=s.length>0?T$(s).parameters:{};a=zt({snapshot:new Jb(s,u,Object.freeze({...this.urlTree.queryParams}),this.urlTree.fragment,lL(r),Ko(r),r.component??r._loadedComponent??null,r,uL(r)),consumedSegments:[],remainingSegments:[]}),e.children={}}else a=$te(e,r,s,t).pipe(ct(({matched:u,consumedSegments:c,remainingSegments:p,parameters:m})=>u?{snapshot:new Jb(c,m,Object.freeze({...this.urlTree.queryParams}),this.urlTree.fragment,lL(r),Ko(r),r.component??r._loadedComponent??null,r,uL(r)),consumedSegments:c,remainingSegments:p}:null));return a.pipe(al(u=>null===u?sh(e):this.getChildConfig(t=r._injector??t,r,s).pipe(al(({routes:c})=>{const p=r._loadedInjector??t,{snapshot:m,consumedSegments:y,remainingSegments:_}=u,{segmentGroup:w,slicedSegments:T}=oL(e,y,_,c);if(0===T.length&&w.hasChildren())return this.processChildren(p,c,w).pipe(ct(O=>null===O?null:[new ll(m,O)]));if(0===c.length&&0===T.length)return zt([new ll(m,[])]);const I=Ko(r)===i;return this.processSegment(p,c,w,T,I?en:i,!0).pipe(ct(O=>[new ll(m,O)]))}))))}getChildConfig(t,e,r){return e.children?zt({routes:e.children,injector:t}):e.loadChildren?void 0!==e._loadedRoutes?zt({routes:e._loadedRoutes,injector:e._loadedInjector}):function Ote(n,t,e,r){const s=t.canLoad;return void 0===s||0===s.length?zt(!0):zt(s.map(o=>{const a=nh(o,n);return ql(function bte(n){return n&&zf(n.canLoad)}(a)?a.canLoad(t,e):n.runInContext(()=>a(t,e)))})).pipe(rh(),rL())}(t,e,r).pipe(fr(s=>s?this.configLoader.loadChildren(t,e).pipe(ni(i=>{e._loadedRoutes=i.routes,e._loadedInjector=i.injector})):function Pte(n){return If(Z$(!1,3))}())):zt({routes:[],injector:t})}}function qte(n){const t=n.value.routeConfig;return t&&""===t.path}function aL(n){const t=[],e=new Set;for(const r of n){if(!qte(r)){t.push(r);continue}const s=t.find(i=>r.value.routeConfig===i.value.routeConfig);void 0!==s?(s.children.push(...r.children),e.add(s)):t.push(r)}for(const r of e){const s=aL(r.children);t.push(new ll(r.value,s))}return t.filter(r=>!e.has(r))}function lL(n){return n.data||{}}function uL(n){return n.resolve||{}}function cL(n){return"string"==typeof n.title||null===n.title}function L1(n){return al(t=>{const e=n(t);return e?nt(e).pipe(ct(()=>t)):zt(t)})}const ih=new st("ROUTES");let V1=(()=>{class n{constructor(){this.componentLoaders=new WeakMap,this.childrenLoaders=new WeakMap,this.compiler=Ct(zP)}loadComponent(e){if(this.componentLoaders.get(e))return this.componentLoaders.get(e);if(e._loadedComponent)return zt(e._loadedComponent);this.onLoadStartListener&&this.onLoadStartListener(e);const r=ql(e.loadComponent()).pipe(ct(dL),ni(i=>{this.onLoadEndListener&&this.onLoadEndListener(e),e._loadedComponent=i}),w1(()=>{this.componentLoaders.delete(e)})),s=new v$(r,()=>new vn).pipe(_1());return this.componentLoaders.set(e,s),s}loadChildren(e,r){if(this.childrenLoaders.get(r))return this.childrenLoaders.get(r);if(r._loadedRoutes)return zt({routes:r._loadedRoutes,injector:r._loadedInjector});this.onLoadStartListener&&this.onLoadStartListener(r);const i=this.loadModuleFactoryOrRoutes(r.loadChildren).pipe(ct(a=>{this.onLoadEndListener&&this.onLoadEndListener(r);let u,c;return Array.isArray(a)?c=a:(u=a.create(e).injector,c=u.get(ih,[],$t.Self|$t.Optional).flat()),{routes:c.map(P1),injector:u}}),w1(()=>{this.childrenLoaders.delete(r)})),o=new v$(i,()=>new vn).pipe(_1());return this.childrenLoaders.set(r,o),o}loadModuleFactoryOrRoutes(e){return ql(e()).pipe(ct(dL),fr(r=>r instanceof ZM||Array.isArray(r)?zt(r):nt(this.compiler.compileModuleAsync(r))))}}return n.\u0275fac=function(e){return new(e||n)},n.\u0275prov=ht({token:n,factory:n.\u0275fac,providedIn:"root"}),n})();function dL(n){return function ene(n){return n&&"object"==typeof n&&"default"in n}(n)?n.default:n}let i_=(()=>{class n{get hasRequestedNavigation(){return 0!==this.navigationId}constructor(){this.currentNavigation=null,this.lastSuccessfulNavigation=null,this.events=new vn,this.configLoader=Ct(V1),this.environmentInjector=Ct(tl),this.urlSerializer=Ct(kf),this.rootContexts=Ct(Ff),this.inputBindingEnabled=null!==Ct(e_,{optional:!0}),this.navigationId=0,this.afterPreactivation=()=>zt(void 0),this.rootComponentType=null,this.configLoader.onLoadEndListener=s=>this.events.next(new Kee(s)),this.configLoader.onLoadStartListener=s=>this.events.next(new qee(s))}complete(){this.transitions?.complete()}handleNavigationRequest(e){const r=++this.navigationId;this.transitions?.next({...this.transitions.value,...e,id:r})}setupNavigations(e){return this.transitions=new fo({id:0,currentUrlTree:e.currentUrlTree,currentRawUrl:e.currentUrlTree,extractedUrl:e.urlHandlingStrategy.extract(e.currentUrlTree),urlAfterRedirects:e.urlHandlingStrategy.extract(e.currentUrlTree),rawUrl:e.currentUrlTree,extras:{},resolve:null,reject:null,promise:Promise.resolve(!0),source:Mf,restoredState:null,currentSnapshot:e.routerState.snapshot,targetSnapshot:null,currentRouterState:e.routerState,targetRouterState:null,guards:{canActivateChecks:[],canDeactivateChecks:[]},guardsResult:null}),this.transitions.pipe(ti(r=>0!==r.id),ct(r=>({...r,extractedUrl:e.urlHandlingStrategy.extract(r.rawUrl)})),al(r=>{let s=!1,i=!1;return zt(r).pipe(ni(o=>{this.currentNavigation={id:o.id,initialUrl:o.rawUrl,extractedUrl:o.extractedUrl,trigger:o.source,extras:o.extras,previousNavigation:this.lastSuccessfulNavigation?{...this.lastSuccessfulNavigation,previousNavigation:null}:null}}),al(o=>{const a=e.browserUrlTree.toString(),u=!e.navigated||o.extractedUrl.toString()!==a||a!==e.currentUrlTree.toString();if(!u&&"reload"!==(o.extras.onSameUrlNavigation??e.onSameUrlNavigation)){const p="";return this.events.next(new Pf(o.id,e.serializeUrl(r.rawUrl),p,0)),e.rawUrlTree=o.rawUrl,o.resolve(null),Ri}if(e.urlHandlingStrategy.shouldProcessUrl(o.rawUrl))return hL(o.source)&&(e.browserUrlTree=o.extractedUrl),zt(o).pipe(al(p=>{const m=this.transitions?.getValue();return this.events.next(new E1(p.id,this.urlSerializer.serialize(p.extractedUrl),p.source,p.restoredState)),m!==this.transitions?.getValue()?Ri:Promise.resolve(p)}),function Kte(n,t,e,r,s,i){return fr(o=>function Gte(n,t,e,r,s,i,o="emptyOnly"){return new Wte(n,t,e,r,s,o,i).recognize()}(n,t,e,r,o.extractedUrl,s,i).pipe(ct(({state:a,tree:u})=>({...o,targetSnapshot:a,urlAfterRedirects:u}))))}(this.environmentInjector,this.configLoader,this.rootComponentType,e.config,this.urlSerializer,e.paramsInheritanceStrategy),ni(p=>{if(r.targetSnapshot=p.targetSnapshot,r.urlAfterRedirects=p.urlAfterRedirects,this.currentNavigation={...this.currentNavigation,finalUrl:p.urlAfterRedirects},"eager"===e.urlUpdateStrategy){if(!p.extras.skipLocationChange){const y=e.urlHandlingStrategy.merge(p.urlAfterRedirects,p.rawUrl);e.setBrowserUrl(y,p)}e.browserUrlTree=p.urlAfterRedirects}const m=new Uee(p.id,this.urlSerializer.serialize(p.extractedUrl),this.urlSerializer.serialize(p.urlAfterRedirects),p.targetSnapshot);this.events.next(m)}));if(u&&e.urlHandlingStrategy.shouldProcessUrl(e.rawUrlTree)){const{id:p,extractedUrl:m,source:y,restoredState:_,extras:w}=o,T=new E1(p,this.urlSerializer.serialize(m),y,_);this.events.next(T);const I=G$(0,this.rootComponentType).snapshot;return zt(r={...o,targetSnapshot:I,urlAfterRedirects:m,extras:{...w,skipLocationChange:!1,replaceUrl:!1}})}{const p="";return this.events.next(new Pf(o.id,e.serializeUrl(r.extractedUrl),p,1)),e.rawUrlTree=o.rawUrl,o.resolve(null),Ri}}),ni(o=>{const a=new jee(o.id,this.urlSerializer.serialize(o.extractedUrl),this.urlSerializer.serialize(o.urlAfterRedirects),o.targetSnapshot);this.events.next(a)}),ct(o=>r={...o,guards:pte(o.targetSnapshot,o.currentSnapshot,this.rootContexts)}),function Ste(n,t){return fr(e=>{const{targetSnapshot:r,currentSnapshot:s,guards:{canActivateChecks:i,canDeactivateChecks:o}}=e;return 0===o.length&&0===i.length?zt({...e,guardsResult:!0}):function Cte(n,t,e,r){return nt(n).pipe(fr(s=>function Nte(n,t,e,r,s){const i=t&&t.routeConfig?t.routeConfig.canDeactivate:null;return i&&0!==i.length?zt(i.map(a=>{const u=Lf(t)??s,c=nh(a,u);return ql(function wte(n){return n&&zf(n.canDeactivate)}(c)?c.canDeactivate(n,t,e,r):u.runInContext(()=>c(n,t,e,r))).pipe(uc())})).pipe(rh()):zt(!0)}(s.component,s.route,e,t,r)),uc(s=>!0!==s,!0))}(o,r,s,n).pipe(fr(a=>a&&function yte(n){return"boolean"==typeof n}(a)?function Ite(n,t,e,r){return nt(t).pipe(Ef(s=>Ub(function Dte(n,t){return null!==n&&t&&t(new Xee(n)),zt(!0)}(s.route.parent,r),function Ete(n,t){return null!==n&&t&&t(new Zee(n)),zt(!0)}(s.route,r),function kte(n,t,e){const r=t[t.length-1],i=t.slice(0,t.length-1).reverse().map(o=>function fte(n){const t=n.routeConfig?n.routeConfig.canActivateChild:null;return t&&0!==t.length?{node:n,guards:t}:null}(o)).filter(o=>null!==o).map(o=>jb(()=>zt(o.guards.map(u=>{const c=Lf(o.node)??e,p=nh(u,c);return ql(function vte(n){return n&&zf(n.canActivateChild)}(p)?p.canActivateChild(r,n):c.runInContext(()=>p(r,n))).pipe(uc())})).pipe(rh())));return zt(i).pipe(rh())}(n,s.path,e),function Ate(n,t,e){const r=t.routeConfig?t.routeConfig.canActivate:null;if(!r||0===r.length)return zt(!0);const s=r.map(i=>jb(()=>{const o=Lf(t)??e,a=nh(i,o);return ql(function _te(n){return n&&zf(n.canActivate)}(a)?a.canActivate(t,n):o.runInContext(()=>a(t,n))).pipe(uc())}));return zt(s).pipe(rh())}(n,s.route,e))),uc(s=>!0!==s,!0))}(r,i,n,t):zt(a)),ct(a=>({...e,guardsResult:a})))})}(this.environmentInjector,o=>this.events.next(o)),ni(o=>{if(r.guardsResult=o.guardsResult,hc(o.guardsResult))throw Y$(0,o.guardsResult);const a=new Gee(o.id,this.urlSerializer.serialize(o.extractedUrl),this.urlSerializer.serialize(o.urlAfterRedirects),o.targetSnapshot,!!o.guardsResult);this.events.next(a)}),ti(o=>!!o.guardsResult||(e.restoreHistory(o),this.cancelNavigationTransition(o,"",3),!1)),L1(o=>{if(o.guards.canActivateChecks.length)return zt(o).pipe(ni(a=>{const u=new Wee(a.id,this.urlSerializer.serialize(a.extractedUrl),this.urlSerializer.serialize(a.urlAfterRedirects),a.targetSnapshot);this.events.next(u)}),al(a=>{let u=!1;return zt(a).pipe(function Xte(n,t){return fr(e=>{const{targetSnapshot:r,guards:{canActivateChecks:s}}=e;if(!s.length)return zt(e);let i=0;return nt(s).pipe(Ef(o=>function Yte(n,t,e,r){const s=n.routeConfig,i=n._resolve;return void 0!==s?.title&&!cL(s)&&(i[Df]=s.title),function Zte(n,t,e,r){const s=function Qte(n){return[...Object.keys(n),...Object.getOwnPropertySymbols(n)]}(n);if(0===s.length)return zt({});const i={};return nt(s).pipe(fr(o=>function Jte(n,t,e,r){const s=Lf(t)??r,i=nh(n,s);return ql(i.resolve?i.resolve(t,e):s.runInContext(()=>i(t,e)))}(n[o],t,e,r).pipe(uc(),ni(a=>{i[o]=a}))),v1(1),function pee(n){return ct(()=>n)}(i),cc(o=>nL(o)?Ri:If(o)))}(i,n,t,r).pipe(ct(o=>(n._resolvedData=o,n.data=W$(n,e).resolve,s&&cL(s)&&(n.data[Df]=s.title),null)))}(o.route,r,n,t)),ni(()=>i++),v1(1),fr(o=>i===s.length?zt(e):Ri))})}(e.paramsInheritanceStrategy,this.environmentInjector),ni({next:()=>u=!0,complete:()=>{u||(e.restoreHistory(a),this.cancelNavigationTransition(a,"",2))}}))}),ni(a=>{const u=new Hee(a.id,this.urlSerializer.serialize(a.extractedUrl),this.urlSerializer.serialize(a.urlAfterRedirects),a.targetSnapshot);this.events.next(u)}))}),L1(o=>{const a=u=>{const c=[];u.routeConfig?.loadComponent&&!u.routeConfig._loadedComponent&&c.push(this.configLoader.loadComponent(u.routeConfig).pipe(ni(p=>{u.component=p}),ct(()=>{})));for(const p of u.children)c.push(...a(p));return c};return Bb(a(o.targetSnapshot.root)).pipe(Wb(),mo(1))}),L1(()=>this.afterPreactivation()),ct(o=>{const a=function rte(n,t,e){const r=$f(n,t._root,e?e._root:void 0);return new j$(r,t)}(e.routeReuseStrategy,o.targetSnapshot,o.currentRouterState);return r={...o,targetRouterState:a}}),ni(o=>{e.currentUrlTree=o.urlAfterRedirects,e.rawUrlTree=e.urlHandlingStrategy.merge(o.urlAfterRedirects,o.rawUrl),e.routerState=o.targetRouterState,"deferred"===e.urlUpdateStrategy&&(o.extras.skipLocationChange||e.setBrowserUrl(e.rawUrlTree,o),e.browserUrlTree=o.urlAfterRedirects)}),((n,t,e,r)=>ct(s=>(new hte(t,s.targetRouterState,s.currentRouterState,e,r).activate(n),s)))(this.rootContexts,e.routeReuseStrategy,o=>this.events.next(o),this.inputBindingEnabled),mo(1),ni({next:o=>{s=!0,this.lastSuccessfulNavigation=this.currentNavigation,e.navigated=!0,this.events.next(new pc(o.id,this.urlSerializer.serialize(o.extractedUrl),this.urlSerializer.serialize(e.currentUrlTree))),e.titleStrategy?.updateTitle(o.targetRouterState.snapshot),o.resolve(!0)},complete:()=>{s=!0}}),w1(()=>{s||i||this.cancelNavigationTransition(r,"",1),this.currentNavigation?.id===r.id&&(this.currentNavigation=null)}),cc(o=>{if(i=!0,J$(o)){Q$(o)||(e.navigated=!0,e.restoreHistory(r,!0));const a=new Qb(r.id,this.urlSerializer.serialize(r.extractedUrl),o.message,o.cancellationCode);if(this.events.next(a),Q$(o)){const u=e.urlHandlingStrategy.merge(o.url,e.rawUrlTree),c={skipLocationChange:r.extras.skipLocationChange,replaceUrl:"eager"===e.urlUpdateStrategy||hL(r.source)};e.scheduleNavigation(u,Mf,null,c,{resolve:r.resolve,reject:r.reject,promise:r.promise})}else r.resolve(!1)}else{e.restoreHistory(r,!0);const a=new D1(r.id,this.urlSerializer.serialize(r.extractedUrl),o,r.targetSnapshot??void 0);this.events.next(a);try{r.resolve(e.errorHandler(o))}catch(u){r.reject(u)}}return Ri}))}))}cancelNavigationTransition(e,r,s){const i=new Qb(e.id,this.urlSerializer.serialize(e.extractedUrl),r,s);this.events.next(i),e.resolve(!1)}}return n.\u0275fac=function(e){return new(e||n)},n.\u0275prov=ht({token:n,factory:n.\u0275fac,providedIn:"root"}),n})();function hL(n){return n!==Mf}let pL=(()=>{class n{buildTitle(e){let r,s=e.root;for(;void 0!==s;)r=this.getResolvedTitleForRoute(s)??r,s=s.children.find(i=>i.outlet===en);return r}getResolvedTitleForRoute(e){return e.data[Df]}}return n.\u0275fac=function(e){return new(e||n)},n.\u0275prov=ht({token:n,factory:function(){return Ct(tne)},providedIn:"root"}),n})(),tne=(()=>{class n extends pL{constructor(e){super(),this.title=e}updateTitle(e){const r=this.buildTitle(e);void 0!==r&&this.title.setTitle(r)}}return n.\u0275fac=function(e){return new(e||n)(Le(p$))},n.\u0275prov=ht({token:n,factory:n.\u0275fac,providedIn:"root"}),n})(),nne=(()=>{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275prov=ht({token:n,factory:function(){return Ct(sne)},providedIn:"root"}),n})();class rne{shouldDetach(t){return!1}store(t,e){}shouldAttach(t){return!1}retrieve(t){return null}shouldReuseRoute(t,e){return t.routeConfig===e.routeConfig}}let sne=(()=>{class n extends rne{}return n.\u0275fac=function(){let t;return function(r){return(t||(t=function bs(n){return Ka(()=>{const t=n.prototype.constructor,e=t[Ya]||Cx(t),r=Object.prototype;let s=Object.getPrototypeOf(n.prototype).constructor;for(;s&&s!==r;){const i=s[Ya]||Cx(s);if(i&&i!==e)return i;s=Object.getPrototypeOf(s)}return i=>new i})}(n)))(r||n)}}(),n.\u0275prov=ht({token:n,factory:n.\u0275fac,providedIn:"root"}),n})();const o_=new st("",{providedIn:"root",factory:()=>({})});let ine=(()=>{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275prov=ht({token:n,factory:function(){return Ct(one)},providedIn:"root"}),n})(),one=(()=>{class n{shouldProcessUrl(e){return!0}extract(e){return e}merge(e,r){return e}}return n.\u0275fac=function(e){return new(e||n)},n.\u0275prov=ht({token:n,factory:n.\u0275fac,providedIn:"root"}),n})();var Bi=(()=>((Bi=Bi||{})[Bi.COMPLETE=0]="COMPLETE",Bi[Bi.FAILED=1]="FAILED",Bi[Bi.REDIRECTING=2]="REDIRECTING",Bi))();function fL(n,t){n.events.pipe(ti(e=>e instanceof pc||e instanceof Qb||e instanceof D1||e instanceof Pf),ct(e=>e instanceof pc||e instanceof Pf?Bi.COMPLETE:e instanceof Qb&&(0===e.code||1===e.code)?Bi.REDIRECTING:Bi.FAILED),ti(e=>e!==Bi.REDIRECTING),mo(1)).subscribe(()=>{t()})}function ane(n){throw n}function lne(n,t,e){return t.parse("/")}const une={paths:"exact",fragment:"ignored",matrixParams:"ignored",queryParams:"exact"},cne={paths:"subset",fragment:"ignored",matrixParams:"ignored",queryParams:"subset"};let go=(()=>{class n{get navigationId(){return this.navigationTransitions.navigationId}get browserPageId(){if("computed"===this.canceledNavigationResolution)return this.location.getState()?.\u0275routerPageId}get events(){return this.navigationTransitions.events}constructor(){this.disposed=!1,this.currentPageId=0,this.console=Ct(BP),this.isNgZoneEnabled=!1,this.options=Ct(o_,{optional:!0})||{},this.pendingTasks=Ct(TF),this.errorHandler=this.options.errorHandler||ane,this.malformedUriErrorHandler=this.options.malformedUriErrorHandler||lne,this.navigated=!1,this.lastSuccessfulId=-1,this.urlHandlingStrategy=Ct(ine),this.routeReuseStrategy=Ct(nne),this.titleStrategy=Ct(pL),this.onSameUrlNavigation=this.options.onSameUrlNavigation||"ignore",this.paramsInheritanceStrategy=this.options.paramsInheritanceStrategy||"emptyOnly",this.urlUpdateStrategy=this.options.urlUpdateStrategy||"deferred",this.canceledNavigationResolution=this.options.canceledNavigationResolution||"replace",this.config=Ct(ih,{optional:!0})?.flat()??[],this.navigationTransitions=Ct(i_),this.urlSerializer=Ct(kf),this.location=Ct(wf),this.componentInputBindingEnabled=!!Ct(e_,{optional:!0}),this.isNgZoneEnabled=Ct(Zt)instanceof Zt&&Zt.isInAngularZone(),this.resetConfig(this.config),this.currentUrlTree=new Jd,this.rawUrlTree=this.currentUrlTree,this.browserUrlTree=this.currentUrlTree,this.routerState=G$(0,null),this.navigationTransitions.setupNavigations(this).subscribe(e=>{this.lastSuccessfulId=e.id,this.currentPageId=this.browserPageId??0},e=>{this.console.warn(`Unhandled Navigation Error: ${e}`)})}resetRootComponentType(e){this.routerState.root.component=e,this.navigationTransitions.rootComponentType=e}initialNavigation(){if(this.setUpLocationChangeListener(),!this.navigationTransitions.hasRequestedNavigation){const e=this.location.getState();this.navigateToSyncWithBrowser(this.location.path(!0),Mf,e)}}setUpLocationChangeListener(){this.locationSubscription||(this.locationSubscription=this.location.subscribe(e=>{const r="popstate"===e.type?"popstate":"hashchange";"popstate"===r&&setTimeout(()=>{this.navigateToSyncWithBrowser(e.url,r,e.state)},0)}))}navigateToSyncWithBrowser(e,r,s){const i={replaceUrl:!0},o=s?.navigationId?s:null;if(s){const u={...s};delete u.navigationId,delete u.\u0275routerPageId,0!==Object.keys(u).length&&(i.state=u)}const a=this.parseUrl(e);this.scheduleNavigation(a,r,o,i)}get url(){return this.serializeUrl(this.currentUrlTree)}getCurrentNavigation(){return this.navigationTransitions.currentNavigation}get lastSuccessfulNavigation(){return this.navigationTransitions.lastSuccessfulNavigation}resetConfig(e){this.config=e.map(P1),this.navigated=!1,this.lastSuccessfulId=-1}ngOnDestroy(){this.dispose()}dispose(){this.navigationTransitions.complete(),this.locationSubscription&&(this.locationSubscription.unsubscribe(),this.locationSubscription=void 0),this.disposed=!0}createUrlTree(e,r={}){const{relativeTo:s,queryParams:i,fragment:o,queryParamsHandling:a,preserveFragment:u}=r,c=u?this.currentUrlTree.fragment:o;let m,p=null;switch(a){case"merge":p={...this.currentUrlTree.queryParams,...i};break;case"preserve":p=this.currentUrlTree.queryParams;break;default:p=i||null}null!==p&&(p=this.removeEmptyProps(p));try{m=M$(s?s.snapshot:this.routerState.snapshot.root)}catch{("string"!=typeof e[0]||!e[0].startsWith("/"))&&(e=[]),m=this.currentUrlTree.root}return P$(m,e,p,c??null)}navigateByUrl(e,r={skipLocationChange:!1}){const s=hc(e)?e:this.parseUrl(e),i=this.urlHandlingStrategy.merge(s,this.rawUrlTree);return this.scheduleNavigation(i,Mf,null,r)}navigate(e,r={skipLocationChange:!1}){return function dne(n){for(let t=0;t<n.length;t++)if(null==n[t])throw new je(4008,!1)}(e),this.navigateByUrl(this.createUrlTree(e,r),r)}serializeUrl(e){return this.urlSerializer.serialize(e)}parseUrl(e){let r;try{r=this.urlSerializer.parse(e)}catch(s){r=this.malformedUriErrorHandler(s,this.urlSerializer,e)}return r}isActive(e,r){let s;if(s=!0===r?{...une}:!1===r?{...cne}:r,hc(e))return C$(this.currentUrlTree,e,s);const i=this.parseUrl(e);return C$(this.currentUrlTree,i,s)}removeEmptyProps(e){return Object.keys(e).reduce((r,s)=>{const i=e[s];return null!=i&&(r[s]=i),r},{})}scheduleNavigation(e,r,s,i,o){if(this.disposed)return Promise.resolve(!1);let a,u,c;o?(a=o.resolve,u=o.reject,c=o.promise):c=new Promise((m,y)=>{a=m,u=y});const p=this.pendingTasks.add();return fL(this,()=>{Promise.resolve().then(()=>this.pendingTasks.remove(p))}),this.navigationTransitions.handleNavigationRequest({source:r,restoredState:s,currentUrlTree:this.currentUrlTree,currentRawUrl:this.currentUrlTree,rawUrl:e,extras:i,resolve:a,reject:u,promise:c,currentSnapshot:this.routerState.snapshot,currentRouterState:this.routerState}),c.catch(m=>Promise.reject(m))}setBrowserUrl(e,r){const s=this.urlSerializer.serialize(e);if(this.location.isCurrentPathEqualTo(s)||r.extras.replaceUrl){const o={...r.extras.state,...this.generateNgRouterState(r.id,this.browserPageId)};this.location.replaceState(s,"",o)}else{const i={...r.extras.state,...this.generateNgRouterState(r.id,(this.browserPageId??0)+1)};this.location.go(s,"",i)}}restoreHistory(e,r=!1){if("computed"===this.canceledNavigationResolution){const i=this.currentPageId-(this.browserPageId??this.currentPageId);0!==i?this.location.historyGo(i):this.currentUrlTree===this.getCurrentNavigation()?.finalUrl&&0===i&&(this.resetState(e),this.browserUrlTree=e.currentUrlTree,this.resetUrlToCurrentUrlTree())}else"replace"===this.canceledNavigationResolution&&(r&&this.resetState(e),this.resetUrlToCurrentUrlTree())}resetState(e){this.routerState=e.currentRouterState,this.currentUrlTree=e.currentUrlTree,this.rawUrlTree=this.urlHandlingStrategy.merge(this.currentUrlTree,e.rawUrl)}resetUrlToCurrentUrlTree(){this.location.replaceState(this.urlSerializer.serialize(this.rawUrlTree),"",this.generateNgRouterState(this.lastSuccessfulId,this.currentPageId))}generateNgRouterState(e,r){return"computed"===this.canceledNavigationResolution?{navigationId:e,\u0275routerPageId:r}:{navigationId:e}}}return n.\u0275fac=function(e){return new(e||n)},n.\u0275prov=ht({token:n,factory:n.\u0275fac,providedIn:"root"}),n})();class mL{}let fne=(()=>{class n{constructor(e,r,s,i,o){this.router=e,this.injector=s,this.preloadingStrategy=i,this.loader=o}setUpPreloading(){this.subscription=this.router.events.pipe(ti(e=>e instanceof pc),Ef(()=>this.preload())).subscribe(()=>{})}preload(){return this.processRoutes(this.injector,this.router.config)}ngOnDestroy(){this.subscription&&this.subscription.unsubscribe()}processRoutes(e,r){const s=[];for(const i of r){i.providers&&!i._injector&&(i._injector=aS(i.providers,e,`Route: ${i.path}`));const o=i._injector??e,a=i._loadedInjector??o;(i.loadChildren&&!i._loadedRoutes&&void 0===i.canLoad||i.loadComponent&&!i._loadedComponent)&&s.push(this.preloadConfig(o,i)),(i.children||i._loadedRoutes)&&s.push(this.processRoutes(a,i.children??i._loadedRoutes))}return nt(s).pipe(qa())}preloadConfig(e,r){return this.preloadingStrategy.preload(r,()=>{let s;s=r.loadChildren&&void 0===r.canLoad?this.loader.loadChildren(e,r):zt(null);const i=s.pipe(fr(o=>null===o?zt(void 0):(r._loadedRoutes=o.routes,r._loadedInjector=o.injector,this.processRoutes(o.injector??e,o.routes))));return r.loadComponent&&!r._loadedComponent?nt([i,this.loader.loadComponent(r)]).pipe(qa()):i})}}return n.\u0275fac=function(e){return new(e||n)(Le(go),Le(zP),Le(tl),Le(mL),Le(V1))},n.\u0275prov=ht({token:n,factory:n.\u0275fac,providedIn:"root"}),n})();const z1=new st("");let gL=(()=>{class n{constructor(e,r,s,i,o={}){this.urlSerializer=e,this.transitions=r,this.viewportScroller=s,this.zone=i,this.options=o,this.lastId=0,this.lastSource="imperative",this.restoredId=0,this.store={},o.scrollPositionRestoration=o.scrollPositionRestoration||"disabled",o.anchorScrolling=o.anchorScrolling||"disabled"}init(){"disabled"!==this.options.scrollPositionRestoration&&this.viewportScroller.setHistoryScrollRestoration("manual"),this.routerEventsSubscription=this.createScrollEvents(),this.scrollEventsSubscription=this.consumeScrollEvents()}createScrollEvents(){return this.transitions.events.subscribe(e=>{e instanceof E1?(this.store[this.lastId]=this.viewportScroller.getScrollPosition(),this.lastSource=e.navigationTrigger,this.restoredId=e.restoredState?e.restoredState.navigationId:0):e instanceof pc?(this.lastId=e.id,this.scheduleScrollEvent(e,this.urlSerializer.parse(e.urlAfterRedirects).fragment)):e instanceof Pf&&0===e.code&&(this.lastSource=void 0,this.restoredId=0,this.scheduleScrollEvent(e,this.urlSerializer.parse(e.url).fragment))})}consumeScrollEvents(){return this.transitions.events.subscribe(e=>{e instanceof z$&&(e.position?"top"===this.options.scrollPositionRestoration?this.viewportScroller.scrollToPosition([0,0]):"enabled"===this.options.scrollPositionRestoration&&this.viewportScroller.scrollToPosition(e.position):e.anchor&&"enabled"===this.options.anchorScrolling?this.viewportScroller.scrollToAnchor(e.anchor):"disabled"!==this.options.scrollPositionRestoration&&this.viewportScroller.scrollToPosition([0,0]))})}scheduleScrollEvent(e,r){this.zone.runOutsideAngular(()=>{setTimeout(()=>{this.zone.run(()=>{this.transitions.events.next(new z$(e,"popstate"===this.lastSource?this.store[this.restoredId]:null,r))})},0)})}ngOnDestroy(){this.routerEventsSubscription?.unsubscribe(),this.scrollEventsSubscription?.unsubscribe()}}return n.\u0275fac=function(e){eb()},n.\u0275prov=ht({token:n,factory:n.\u0275fac}),n})();function ul(n,t){return{\u0275kind:n,\u0275providers:t}}function bL(){const n=Ct(Vs);return t=>{const e=n.get(Gl);if(t!==e.components[0])return;const r=n.get(go),s=n.get(_L);1===n.get(U1)&&r.initialNavigation(),n.get(vL,null,$t.Optional)?.setUpPreloading(),n.get(z1,null,$t.Optional)?.init(),r.resetRootComponentType(e.componentTypes[0]),s.closed||(s.next(),s.complete(),s.unsubscribe())}}const _L=new st("",{factory:()=>new vn}),U1=new st("",{providedIn:"root",factory:()=>1}),vL=new st("");function bne(n){return ul(0,[{provide:vL,useExisting:fne},{provide:mL,useExisting:n}])}const wL=new st("ROUTER_FORROOT_GUARD"),vne=[wf,{provide:kf,useClass:x1},go,Ff,{provide:th,useFactory:function yL(n){return n.routerState.root},deps:[go]},V1,[]];function wne(){return new QP("Router",go)}let xL=(()=>{class n{constructor(e){}static forRoot(e,r){return{ngModule:n,providers:[vne,[],{provide:ih,multi:!0,useValue:e},{provide:wL,useFactory:Cne,deps:[[go,new Oy,new Ry]]},{provide:o_,useValue:r||{}},r?.useHash?{provide:lc,useClass:OZ}:{provide:lc,useClass:AF},{provide:z1,useFactory:()=>{const n=Ct(XQ),t=Ct(Zt),e=Ct(o_),r=Ct(i_),s=Ct(kf);return e.scrollOffset&&n.setOffset(e.scrollOffset),new gL(s,r,n,t,e)}},r?.preloadingStrategy?bne(r.preloadingStrategy).\u0275providers:[],{provide:QP,multi:!0,useFactory:wne},r?.initialNavigation?Ine(r):[],r?.bindToComponentInputs?ul(8,[X$,{provide:e_,useExisting:X$}]).\u0275providers:[],[{provide:TL,useFactory:bL},{provide:RS,multi:!0,useExisting:TL}]]}}static forChild(e){return{ngModule:n,providers:[{provide:ih,multi:!0,useValue:e}]}}}return n.\u0275fac=function(e){return new(e||n)(Le(wL,8))},n.\u0275mod=ar({type:n}),n.\u0275inj=Jn({}),n})();function Cne(n){return"guarded"}function Ine(n){return["disabled"===n.initialNavigation?ul(3,[{provide:SS,multi:!0,useFactory:()=>{const t=Ct(go);return()=>{t.setUpLocationChangeListener()}}},{provide:U1,useValue:2}]).\u0275providers:[],"enabledBlocking"===n.initialNavigation?ul(2,[{provide:U1,useValue:0},{provide:SS,multi:!0,deps:[Vs],useFactory:t=>{const e=t.get(kZ,Promise.resolve());return()=>e.then(()=>new Promise(r=>{const s=t.get(go),i=t.get(_L);fL(s,()=>{r(!0)}),t.get(i_).afterPreactivation=()=>(r(!0),i.closed?zt(void 0):i),s.initialNavigation()}))}}]).\u0275providers:[]]}const TL=new st(""),Dne=[];let Ane=(()=>{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275mod=ar({type:n}),n.\u0275inj=Jn({imports:[xL.forRoot(Dne),xL]}),n})();function SL(n,t,e,r,s,i,o){try{var a=n[i](o),u=a.value}catch(c){return void e(c)}a.done?t(u):Promise.resolve(u).then(r,s)}function Ve(n){return function(){var t=this,e=arguments;return new Promise(function(r,s){var i=n.apply(t,e);function o(u){SL(i,r,s,o,a,"next",u)}function a(u){SL(i,r,s,o,a,"throw",u)}o(void 0)})}}class CL{constructor(t,e){this.backend=t,this.dataMover=e,this.data=new WeakMap,this.dataIdsCount=0}get(t){return this.data.has(t)||this.dataMover.moveData(this.backend,t),this.data.get(t)}set(t,e){this.dataIdsCount++,this.data.set(t,e)}has(t){return this.data.has(t)}delete(t){return this.dataIdsCount--,this.data.delete(t)}numDataIds(){return this.dataIdsCount}}class j1{refCount(t){return wi("refCount")}incRef(t){return wi("incRef")}timerAvailable(){return!0}time(t){return wi("time")}read(t){return wi("read")}readSync(t){return wi("readSync")}readToGPU(t,e){return wi("readToGPU")}numDataIds(){return wi("numDataIds")}disposeData(t,e){return wi("disposeData")}write(t,e,r){return wi("write")}move(t,e,r,s,i){return wi("move")}createTensorFromGPUData(t,e,r){return wi("createTensorFromGPUData")}memory(){return wi("memory")}floatPrecision(){return wi("floatPrecision")}epsilon(){return 32===this.floatPrecision()?1e-7:1e-4}dispose(){return wi("dispose")}}function wi(n){throw new Error(`'${n}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`)}function IL(n){let t=n.length,e=0;for(;t>0;)e=Math.random()*t|0,t--,Kl(n,t,e)}function fc(n,t,e){return Math.max(n,Math.min(t,e))}function G1(n){return n%2==0?n:n+1}function Kl(n,t,e){const r=n[t];n[t]=n[e],n[e]=r}function J(n,t){if(!n)throw new Error("string"==typeof t?t:t())}function xi(n,t,e=""){J(hn(n,t),()=>e+` Shapes ${n} and ${t} must match`)}function oh(n){J(null!=n,()=>"The input to the tensor constructor must be a non-null value.")}function Fe(n){if(0===n.length)return 1;let t=n[0];for(let e=1;e<n.length;e++)t*=n[e];return t}function hn(n,t){if(n===t)return!0;if(null==n||null==t||n.length!==t.length)return!1;for(let e=0;e<n.length;e++)if(n[e]!==t[e])return!1;return!0}function ah(n){return n%1==0}function W1(n){const t=Math.ceil(Math.sqrt(n));return[t,Math.ceil(n/t)]}function lh(n,t){return t<=n.length?n:n+" ".repeat(t-n.length)}function EL(n,t=(s=>0),e,r){return new Promise((s,i)=>{let o=0;const a=()=>{if(n())return void s();o++;const u=t(o);null!=e&&o>=e?i():null!=r?r(a,u):setTimeout(a,u)};a()})}function DL(n,t){let e=1,r=-1;for(let i=0;i<n.length;++i)if(n[i]>=0)e*=n[i];else if(-1===n[i]){if(-1!==r)throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${r} and dim ${i}`);r=i}else if(n[i]<0)throw Error(`Shapes can not be < 0. Found ${n[i]} at dim ${i}`);if(-1===r){if(t>0&&t!==e)throw Error(`Size(${t}) must match the product of shape ${n}`);return n}if(0===e)throw Error(`Cannot infer the missing size in [${n}] when there are 0 elements`);if(t%e!=0)throw Error(`The implicit shape can't be a fractional number. Got ${t} / ${e}`);const s=n.slice();return s[r]=t/e,s}function sn(n,t){const e=t.length;return J((n=null==n?t.map((r,s)=>s):[].concat(n)).every(r=>r>=-e&&r<e),()=>`All values in axis param must be in range [-${e}, ${e}) but got axis ${n}`),J(n.every(r=>ah(r)),()=>`All values in axis param must be integers but got axis ${n}`),n.map(r=>r<0?e+r:r)}function Xl(n,t){const e=[],r=[],s=null!=t&&Array.isArray(t)&&0===t.length,i=null==t||s?null:sn(t,n).sort();let o=0;for(let a=0;a<n.length;++a){if(null!=i){if(i[o]===a&&1!==n[a])throw new Error(`Can't squeeze axis ${a} since its dim '${n[a]}' is not 1`);(null==i[o]||i[o]>a)&&1===n[a]&&(e.push(n[a]),r.push(a)),i[o]<=a&&o++}1!==n[a]&&(e.push(n[a]),r.push(a))}return{newShape:e,keptDims:r}}function _s(n,t){return Ar(n,t)}function Ar(n,t){let e=null;if(null==n||"float32"===n)e=new Float32Array(t);else if("int32"===n)e=new Int32Array(t);else if("bool"===n)e=new Uint8Array(t);else{if("string"!==n)throw new Error(`Unknown data type ${n}`);e=new Array(t)}return e}function AL(n,t){return!("complex64"===t||"float32"===t&&"complex64"!==n||"int32"===t&&"float32"!==n&&"complex64"!==n||"bool"===t&&"bool"===n)}function a_(n){if("float32"===n||"int32"===n)return 4;if("complex64"===n)return 8;if("bool"===n)return 1;throw new Error(`Unknown dtype ${n}`)}function Uf(n){return"string"==typeof n||n instanceof String}function H1(n){return"number"==typeof n}function uh(n){return Array.isArray(n)?uh(n[0]):n instanceof Float32Array?"float32":n instanceof Int32Array||n instanceof Uint8Array||n instanceof Uint8ClampedArray?"int32":H1(n)?"float32":Uf(n)?"string":function $ne(n){return"boolean"==typeof n}(n)?"bool":"float32"}function q1(n){return!!(n&&n.constructor&&n.call&&n.apply)}function K1(n,t){for(let e=t;e<n;++e)if(n%e==0)return e;return n}function Nt(n){const t=n.length;if(t<2)return[];const e=new Array(t-1);e[t-2]=n[t-1];for(let r=t-3;r>=0;--r)e[r]=e[r+1]*n[r+1];return e}function kL(n,t,e,r=!1){const s=new Array;if(1===t.length){const i=t[0]*(r?2:1);for(let o=0;o<i;o++)s[o]=e[n+o]}else{const i=t[0],o=t.slice(1),a=o.reduce((u,c)=>u*c)*(r?2:1);for(let u=0;u<i;u++)s[u]=kL(n+u*a,o,e,r)}return s}function yo(n,t,e=!1){if(0===n.length)return t[0];const r=n.reduce((s,i)=>s*i)*(e?2:1);if(0===r)return[];if(r!==t.length)throw new Error(`[${n}] does not match the input size ${t.length}${e?" for a complex tensor":""}.`);return kL(0,n,t,e)}function X1(n,t){const e=ks(n,t);for(let r=0;r<e.length;r++)e[r]=1;return e}function ks(n,t){if(null==t||"float32"===t||"complex64"===t)return new Float32Array(n);if("int32"===t)return new Int32Array(n);if("bool"===t)return new Uint8Array(n);throw new Error(`Unknown data type ${t}`)}function NL(n,t){const e=n.reduce((r,s)=>r*s,1);if(null==t||"float32"===t)return yo(n,new Float32Array(e));if("int32"===t)return yo(n,new Int32Array(e));if("bool"===t)return yo(n,new Uint8Array(e));throw new Error(`Unknown data type ${t}`)}function zi(n){n.forEach(t=>{J(Number.isInteger(t)&&t>=0,()=>`Tensor must have a shape comprised of positive integers but got shape [${n}].`)})}function Ia(n,t,e){if(0===t)return 0;if(1===t)return n[0];let r=n[n.length-1];for(let s=0;s<n.length-1;++s)r+=e[s]*n[s];return r}function ch(n,t,e){if(0===t)return[];if(1===t)return[n];const r=new Array(t);for(let s=0;s<r.length-1;++s)r[s]=Math.floor(n/e[s]),n-=r[s]*e[s];return r[r.length-1]=n,r}function mc(n){return n&&n.then&&"function"==typeof n.then}const OL="tfjsflags";class Vne{constructor(t){this.global=t,this.flags={},this.flagRegistry={},this.urlFlags={},this.getQueryParams=Bne,this.populateURLFlags()}setPlatform(t,e){null!=this.platform&&(De().getBool("IS_TEST")||De().getBool("PROD")||console.warn(`Platform ${this.platformName} has already been set. Overwriting the platform with ${t}.`)),this.platformName=t,this.platform=e}registerFlag(t,e,r){if(this.flagRegistry[t]={evaluationFn:e,setHook:r},null!=this.urlFlags[t]){const s=this.urlFlags[t];De().getBool("IS_TEST")||De().getBool("PROD")||console.warn(`Setting feature override from URL ${t}: ${s}.`),this.set(t,s)}}getAsync(t){var e=this;return Ve(function*(){return t in e.flags||(e.flags[t]=yield e.evaluateFlag(t)),e.flags[t]})()}get(t){if(t in this.flags)return this.flags[t];const e=this.evaluateFlag(t);if(mc(e))throw new Error(`Flag ${t} cannot be synchronously evaluated. Please use getAsync() instead.`);return this.flags[t]=e,this.flags[t]}getNumber(t){return this.get(t)}getBool(t){return this.get(t)}getString(t){return this.get(t)}getFlags(){return this.flags}get features(){return this.flags}set(t,e){if(null==this.flagRegistry[t])throw new Error(`Cannot set flag ${t} as it has not been registered.`);this.flags[t]=e,null!=this.flagRegistry[t].setHook&&this.flagRegistry[t].setHook(e)}evaluateFlag(t){if(null==this.flagRegistry[t])throw new Error(`Cannot evaluate flag '${t}': no evaluation function found.`);return this.flagRegistry[t].evaluationFn()}setFlags(t){this.flags=Object.assign({},t)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if(typeof this.global>"u"||typeof this.global.location>"u"||typeof this.global.location.search>"u")return;const t=this.getQueryParams(this.global.location.search);OL in t&&t[OL].split(",").forEach(r=>{const[s,i]=r.split(":");this.urlFlags[s]=function Une(n,t){const e=t.toLowerCase();return"true"===e||"false"===e?"true"===e:""+ +e===e?+e:t}(0,i)})}}function Bne(n){const t={};return n.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,(e,...r)=>(function zne(n,t,e){n[decodeURIComponent(t)]=decodeURIComponent(e||"")}(t,r[0],r[1]),r.join("="))),t}function De(){return RL}let Y1,RL=null;function ML(){if(null==Y1){let n;if(typeof window<"u")n=window;else if(typeof global<"u")n=global;else if(typeof process<"u")n=process;else{if(!(typeof self<"u"))throw new Error("Could not find a global object");n=self}Y1=n}return Y1}function Z1(n,t){const e=function Gne(){const n=ML();return null==n._tfGlobals&&(n._tfGlobals=new Map),n._tfGlobals}();if(e.has(n))return e.get(n);{const r=t();return e.set(n,r),e.get(n)}}const l_="Abs",jf="Acos",Gf="Acosh",dh="Add",u_="AddN",c_="ArgMax",d_="ArgMin",Wf="Asin",Hf="Asinh",qf="Atan",Kf="Atanh",Xf="Atan2",h_="AvgPool",eC="AvgPoolGrad",p_="AvgPool3D",tC="AvgPool3DGrad",f_="BatchMatMul",m_="BatchToSpaceND",nC="Bincount",rC="BitwiseAnd",sC="BroadcastArgs",Yf="Cast",Zf="Ceil",Qf="ClipByValue",iC="Complex",g_="ComplexAbs",y_="Concat",b_="Conv2D",oC="Conv2DBackpropFilter",__="Conv2DBackpropInput",v_="Conv3D",aC="Conv3DBackpropFilterV2",lC="Conv3DBackpropInputV2",Jf="Cos",em="Cosh",uC="Cumprod",w_="Cumsum",cC="CropAndResize",dC="DenseBincount",hC="DepthToSpace",x_="DepthwiseConv2dNative",pC="DepthwiseConv2dNativeBackpropFilter",fC="DepthwiseConv2dNativeBackpropInput",mC="Diag",T_="Dilation2D",gC="Dilation2DBackpropInput",yC="Dilation2DBackpropFilter",tm="RealDiv",bC="Einsum",nm="Elu",_C="EluGrad",rm="Erf",S_="Equal",sm="Exp",C_="ExpandDims",im="Expm1",wC="Fill",xC="FlipLeftRight",om="Floor",am="FloorDiv",I_="FusedBatchNorm",E_="GatherV2",TC="GatherNd",D_="Greater",lm="GreaterEqual",um="Identity",SC="IFFT",CC="Imag",cm="IsFinite",dm="IsInf",hm="IsNan",A_="LeakyRelu",k_="Less",N_="LessEqual",IC="LinSpace",pm="Log",fm="Log1p",O_="LogicalAnd",R_="LogicalNot",M_="LogicalOr",P_="LRN",EC="LRNGrad",F_="Max",mm="Maximum",$_="MaxPool",DC="MaxPoolGrad",L_="MaxPool3D",AC="MaxPool3DGrad",kC="MaxPoolWithArgmax",V_="Mean",B_="Min",gm="Minimum",z_="MirrorPad",ym="Mod",NC="Multinomial",bm="Multiply",U_="Neg",j_="NotEqual",OC="NonMaxSuppressionV3",RC="NonMaxSuppressionV4",MC="NonMaxSuppressionV5",G_="OnesLike",W_="OneHot",H_="Pack",q_="PadV2",_m="Pow",K_="Prelu",X_="Prod",PC="RaggedGather",FC="RaggedRange",$C="RaggedTensorToTensor",LC="Range",VC="Real",vm="Reciprocal",wm="Relu",Y_="Reshape",Z_="ResizeNearestNeighbor",BC="ResizeNearestNeighborGrad",Q_="ResizeBilinear",zC="ResizeBilinearGrad",xm="Relu6",J_="Reverse",Tm="Round",Sm="Rsqrt",UC="ScatterNd",jC="TensorScatterUpdate",GC="SearchSorted",ev="Select",Cm="Selu",tv="Slice",Im="Sin",Em="Sinh",Dm="Sign",Am="Sigmoid",km="Softplus",Nm="Sqrt",nv="Sum",rv="SpaceToBatchND",sv="SplitV",iv="Softmax",WC="SparseFillEmptyRows",HC="SparseReshape",qC="SparseSegmentMean",KC="SparseSegmentSum",XC="SparseToDense",Om="SquaredDifference",YC="Square",ov="StaticRegexReplace",ZC="StridedSlice",QC="StringNGrams",JC="StringSplit",eI="StringToHashBucketFast",Rm="Sub",Mm="Tan",Pm="Tanh",Fm="Tile",tI="TopK",nI="Transform",hh="Transpose",rI="Unique",av="Unpack",lv="UnsortedSegmentSum",uv="ZerosLike",$m="Step",sI="RotateWithOffset",cv="_FusedMatMul",dv="FusedConv2D",hv="FusedDepthwiseConv2D";function Ui(...n){De().getBool("IS_TEST")||De().getBool("PROD")||console.warn(...n)}function Kne(...n){De().getBool("IS_TEST")||De().getBool("PROD")||console.log(...n)}const ph=Z1("kernelRegistry",()=>new Map),Lm=Z1("gradRegistry",()=>new Map);function PL(n,t){const e=aI(n,t);return ph.get(e)}function FL(n){return Lm.get(n)}function iI(n){const t=ph.entries(),e=[];for(;;){const{done:r,value:s}=t.next();if(r)break;const[i,o]=s,[a]=i.split("_");a===n&&e.push(o)}return e}function oI(n){const{kernelName:t,backendName:e}=n,r=aI(t,e);ph.has(r)&&Ui(`The kernel '${t}' for backend '${e}' is already registered`),ph.set(r,n)}function Xne(n){const{kernelName:t}=n;Lm.has(t)&&De().getBool("DEBUG")&&Ui(`Overriding the gradient for '${t}'`),Lm.set(t,n)}function aI(n,t){return`${t}_${n}`}function $L(n){return n instanceof Float32Array||n instanceof Int32Array||n instanceof Uint8Array||n instanceof Uint8ClampedArray}var LL=$(658);const gc=$.n(LL)()||LL;function pv(n){return gc.fromString(n,!0,16)}const VL=pv("c3a5c85c97cb3127"),yc=pv("b492b66fbe98f273"),zs=pv("9ae16a3b2f90404f");function lI(n){return n.xor(n.shru(47))}function BL(n,t,e){const r=n.slice(t,t+e);return gc.fromBytes(Array.from(r),!0,!0)}function Gn(n,t){return BL(n,t,8)}function zL(n,t){return BL(n,t,4)}function os(n,t){return 0===t?n:n.shru(t).or(n.shl(64-t))}function Yl(n,t,e=pv("9ddfea08eb382d69")){let r=n.xor(t).mul(e);r=r.xor(r.shru(47));let s=t.xor(r).mul(e);return s=s.xor(s.shru(47)),s=s.mul(e),s}function fv(n,t,e,r){return function Zne(n,t,e,r,s,i){s=s.add(n),i=os(i.add(s).add(r),21);const o=s;return s=(s=s.add(t)).add(e),i=i.add(os(s,44)),[s.add(r),i.add(o)]}(Gn(n,t),Gn(n,t+8),Gn(n,t+16),Gn(n,t+24),e,r)}function tre(n,t=n.length){const e=gc.fromNumber(81,!0);if(t<=32)return t<=16?function Qne(n,t=n.length){if(t>=8){const e=zs.add(2*t),r=Gn(n,0).add(zs),s=Gn(n,t-8);return Yl(os(s,37).mul(e).add(r),os(r,25).add(s).mul(e),e)}if(t>=4){const e=zs.add(2*t);return Yl(zL(n,0).shl(3).add(t),zL(n,t-4),e)}if(t>0){const o=t+(n[t-1]<<2);return lI(zs.mul(n[0]+(n[t>>1]<<8)).xor(VL.mul(o))).mul(zs)}return zs}(n,t):function Jne(n,t=n.length){const e=zs.add(2*t),r=Gn(n,0).mul(yc),s=Gn(n,8),i=Gn(n,t-8).mul(e),o=Gn(n,t-16).mul(zs);return Yl(os(r.add(s),43).add(os(i,30)).add(o),r.add(os(s.add(zs),18)).add(i),e)}(n,t);if(t<=64)return function ere(n,t=n.length){const e=zs.add(2*t),r=Gn(n,0).mul(zs),s=Gn(n,8),i=Gn(n,t-8).mul(e),o=Gn(n,t-16).mul(zs),a=os(r.add(s),43).add(os(i,30)).add(o),u=Yl(a,r.add(os(s.add(zs),18)).add(i),e),c=Gn(n,16).mul(e),p=Gn(n,24),m=a.add(Gn(n,t-32)).mul(e),y=u.add(Gn(n,t-24)).mul(e);return Yl(os(c.add(p),43).add(os(m,30)).add(y),c.add(os(p.add(r),18)).add(m),e)}(n,t);let r=e,s=e.mul(yc).add(113),i=lI(s.mul(zs).add(113)).mul(zs),o=[gc.UZERO,gc.UZERO],a=[gc.UZERO,gc.UZERO];r=r.mul(zs).add(Gn(n,0));let u=0;const c=64*(t-1>>6),p=c+(t-1&63)-63;do{r=os(r.add(s).add(o[0]).add(Gn(n,u+8)),37).mul(yc),s=os(s.add(o[1]).add(Gn(n,u+48)),42).mul(yc),r=r.xor(a[1]),s=s.add(o[0]).add(Gn(n,u+40)),i=os(i.add(a[0]),33).mul(yc),o=fv(n,u,o[1].mul(yc),r.add(a[0])),a=fv(n,u+32,i.add(a[1]),s.add(Gn(n,u+16))),[i,r]=[r,i],u+=64}while(u!==c);const m=yc.add(i.and(255).shl(1));return u=p,a[0]=a[0].add(t-1&63),o[0]=o[0].add(a[0]),a[0]=a[0].add(o[0]),r=os(r.add(s).add(o[0]).add(Gn(n,u+8)),37).mul(m),s=os(s.add(o[1]).add(Gn(n,u+48)),42).mul(m),r=r.xor(a[1].mul(9)),s=s.add(o[0].mul(9).add(Gn(n,u+40))),i=os(i.add(a[0]),33).mul(m),o=fv(n,u,o[1].mul(m),r.add(a[0])),a=fv(n,u+32,i.add(a[1]),s.add(Gn(n,u+16))),[i,r]=[r,i],Yl(Yl(o[0],a[0],m).add(lI(s).mul(VL)).add(i),Yl(o[1],a[1],m).add(r),m)}function Zl(n,t){return"string"===t?Ql(n):bc([n],t)}function bc(n,t){if("string"===t)throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(n)&&(n=_c(n)),De().getBool("DEBUG")&&function Mne(n,t){for(let e=0;e<n.length;e++){const r=n[e];if(isNaN(r)||!isFinite(r))throw Error(`A tensor of type ${t} being uploaded contains ${r}.`)}}(n,t),function nre(n,t){return n instanceof Float32Array&&"float32"===t||n instanceof Int32Array&&"int32"===t||n instanceof Uint8Array&&"bool"===t}(n,t))return n;if(null==t||"float32"===t||"complex64"===t)return new Float32Array(n);if("int32"===t)return new Int32Array(n);if("bool"===t){const e=new Uint8Array(n.length);for(let r=0;r<e.length;++r)0!==Math.round(n[r])&&(e[r]=1);return e}throw new Error(`Unknown data type ${t}`)}function ri(){return De().platform.now()}function Ql(n,t="utf-8"){return t=t||"utf-8",De().platform.encode(n,t)}function Jl(n,t="utf-8"){return t=t||"utf-8",De().platform.decode(n,t)}function bo(n){return null!=De().platform.isTypedArray?De().platform.isTypedArray(n):$L(n)}function _c(n,t=[],e=!1){if(null==t&&(t=[]),"boolean"==typeof n||"number"==typeof n||"string"==typeof n||mc(n)||null==n||bo(n)&&e)t.push(n);else if(Array.isArray(n)||bo(n))for(let r=0;r<n.length;++r)_c(n[r],t,e);else{let r=-1;for(const s of Object.keys(n))/^([1-9]+[0-9]*|0)$/.test(s)&&(r=Math.max(r,Number(s)));for(let s=0;s<=r;s++)_c(n[s],t,e)}return t}class rre{constructor(t,e){this.backendTimer=t,this.logger=e,null==e&&(this.logger=new ire)}profileKernel(t,e,r){let s;const i=()=>{s=r()};let o;const a=ri();if(this.backendTimer.timerAvailable())o=this.backendTimer.time(i);else{i();for(const c of s)c.dataSync();o=Promise.resolve({kernelMs:ri()-a})}if(De().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let c=0;c<s.length;c++){const p=s[c];p.data().then(m=>{sre(m,p.dtype,t)})}return{kernelName:t,outputs:s,inputs:e,timeMs:o.then(c=>c.kernelMs),extraInfo:o.then(c=>null!=c.getExtraProfileInfo?c.getExtraProfileInfo():"")}}logKernelProfile(t){const{kernelName:e,outputs:r,timeMs:s,inputs:i,extraInfo:o}=t;r.forEach(a=>{Promise.all([a.data(),s,o]).then(u=>{this.logger.logKernelProfile(e,a,u[0],u[1],i,u[2])})})}}function sre(n,t,e){if("float32"!==t)return!1;for(let r=0;r<n.length;r++){const s=n[r];if(isNaN(s)||!isFinite(s))return console.warn(`Found ${s} in the result of '${e}'`),!0}return!1}class ire{logKernelProfile(t,e,r,s,i,o){const a="number"==typeof s?lh(`${s}ms`,9):s.error,u=lh(t,25),c=e.rank,p=e.size,m=lh(e.shape.toString(),14);let y="";for(const _ in i){const w=i[_];if(null!=w){const T=w.shape||e.shape,I=T.length;y+=`${_}: ${I}D ${I>0?T:""} `}}console.log(`%c${u}\t%c${a}\t%c${c}D ${m}\t%c${p}\t%c${y}\t%c${o}`,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}}const UL=20,Vm=3,uI=7;function lre(n,t,e,r){const s=Nt(t),i=function ure(n,t,e,r){const s=Fe(t),i=r[r.length-1],o=new Array(i).fill(0),a=t.length,u="complex64"===e?zm(n):n;if(a>1)for(let c=0;c<s/i;c++){const p=c*i;for(let m=0;m<i;m++)o[m]=Math.max(o[m],Bm(u[p+m],0,e).length)}return o}(n,t,e,s),o=t.length,a=mv(n,t,e,s,i),u=["Tensor"];return r&&(u.push(`  dtype: ${e}`),u.push(`  rank: ${o}`),u.push(`  shape: [${t}]`),u.push("  values:")),u.push(a.map(c=>"    "+c).join("\n")),u.join("\n")}function Bm(n,t,e){let r;return r=Array.isArray(n)?`${parseFloat(n[0].toFixed(uI))} + ${parseFloat(n[1].toFixed(uI))}j`:Uf(n)?`'${n}'`:"bool"===e?jL(n):parseFloat(n.toFixed(uI)).toString(),lh(r,t)}function jL(n){return 0===n?"false":"true"}function mv(n,t,e,r,s,i=!0){const o="complex64"===e?2:1,a=t[0],u=t.length;if(0===u)return"complex64"===e?[Bm(zm(n)[0],0,e)]:"bool"===e?[jL(n[0])]:[n[0].toString()];if(1===u){if(a>UL){let O=Array.from(n.slice(0,Vm*o)),M=Array.from(n.slice((a-Vm)*o,a*o));return"complex64"===e&&(O=zm(O),M=zm(M)),["["+O.map((V,z)=>Bm(V,s[z],e)).join(", ")+", ..., "+M.map((V,z)=>Bm(V,s[a-Vm+z],e)).join(", ")+"]"]}return["["+("complex64"===e?zm(n):Array.from(n)).map((I,O)=>Bm(I,s[O],e)).join(", ")+"]"]}const c=t.slice(1),p=r.slice(1),m=r[0]*o,y=[];if(a>UL){for(let T=0;T<Vm;T++){const I=T*m;y.push(...mv(n.slice(I,I+m),c,e,p,s,!1))}y.push("...");for(let T=a-Vm;T<a;T++){const I=T*m;y.push(...mv(n.slice(I,I+m),c,e,p,s,T===a-1))}}else for(let T=0;T<a;T++){const I=T*m;y.push(...mv(n.slice(I,I+m),c,e,p,s,T===a-1))}const _=2===u?",":"";y[0]="["+(a>0?y[0]+_:"");for(let T=1;T<y.length-1;T++)y[T]=" "+y[T]+_;let w=",\n";for(let T=2;T<u;T++)w+="\n";return y[y.length-1]=" "+y[y.length-1]+"]"+(i?"":w),y}function zm(n){const t=[];for(let e=0;e<n.length;e+=2)t.push([n[e],n[e+1]]);return t}class qr{constructor(t,e,r){if(this.dtype=e,this.shape=t.slice(),this.size=Fe(t),null!=r){const s=r.length;J(s===this.size,()=>`Length of values '${s}' does not match the size inferred by the shape '${this.size}'.`)}if("complex64"===e)throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=r||Ar(e,this.size),this.strides=Nt(t)}set(t,...e){0===e.length&&(e=[0]),J(e.length===this.rank,()=>`The number of provided coordinates (${e.length}) must match the rank (${this.rank})`);const r=this.locToIndex(e);this.values[r]=t}get(...t){0===t.length&&(t=[0]);let e=0;for(const s of t){if(s<0||s>=this.shape[e])throw new Error(`Requested out of range element at ${t}.   Buffer shape=${this.shape}`);e++}let r=t[t.length-1];for(let s=0;s<t.length-1;++s)r+=this.strides[s]*t[s];return this.values[r]}locToIndex(t){if(0===this.rank)return 0;if(1===this.rank)return t[0];let e=t[t.length-1];for(let r=0;r<t.length-1;++r)e+=this.strides[r]*t[r];return e}indexToLoc(t){if(0===this.rank)return[];if(1===this.rank)return[t];const e=new Array(this.shape.length);for(let r=0;r<e.length-1;++r)e[r]=Math.floor(t/this.strides[r]),t-=e[r]*this.strides[r];return e[e.length-1]=t,e}get rank(){return this.shape.length}toTensor(){return Xo().makeTensor(this.values,this.shape,this.dtype)}}let Xo=null,fh=null,GL=null;class nr{constructor(t,e,r,s){this.kept=!1,this.isDisposedInternal=!1,this.shape=t.slice(),this.dtype=e||"float32",this.size=Fe(t),this.strides=Nt(t),this.dataId=r,this.id=s,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}buffer(){var t=this;return Ve(function*(){const e=yield t.data();return fh.buffer(t.shape,t.dtype,e)})()}bufferSync(){return fh.buffer(this.shape,this.dtype,this.dataSync())}array(){var t=this;return Ve(function*(){const e=yield t.data();return yo(t.shape,e,"complex64"===t.dtype)})()}arraySync(){return yo(this.shape,this.dataSync(),"complex64"===this.dtype)}data(){var t=this;return Ve(function*(){t.throwIfDisposed();const e=Xo().read(t.dataId);if("string"===t.dtype){const r=yield e;try{return r.map(s=>Jl(s))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return e})()}dataToGPU(t){return this.throwIfDisposed(),Xo().readToGPU(this.dataId,t)}dataSync(){this.throwIfDisposed();const t=Xo().readSync(this.dataId);if("string"===this.dtype)try{return t.map(e=>Jl(e))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return t}bytes(){var t=this;return Ve(function*(){t.throwIfDisposed();const e=yield Xo().read(t.dataId);return"string"===t.dtype?e:new Uint8Array(e.buffer)})()}dispose(){this.isDisposed||(Xo().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(t=!1){return fh.print(this,t)}clone(){return this.throwIfDisposed(),fh.clone(this)}toString(t=!1){return lre(this.dataSync(),this.shape,this.dtype,t)}cast(t){return this.throwIfDisposed(),fh.cast(this,t)}variable(t=!0,e,r){return this.throwIfDisposed(),Xo().makeVariable(this,t,e,r)}}function $e(){return Z1("Tensor",()=>nr)}Object.defineProperty(nr,Symbol.hasInstance,{value:n=>!!n&&null!=n.data&&null!=n.dataSync&&null!=n.throwIfDisposed}),$e();class gv extends nr{constructor(t,e,r,s){super(t.shape,t.dtype,t.dataId,s),this.trainable=e,this.name=r}assign(t){if(t.dtype!==this.dtype)throw new Error(`dtype of the new value (${t.dtype}) and previous value (${this.dtype}) must match`);if(!hn(t.shape,this.shape))throw new Error(`shape of the new value (${t.shape}) and previous value (${this.shape}) must match`);Xo().disposeTensor(this),this.dataId=t.dataId,Xo().incRef(this,null)}dispose(){Xo().disposeVariable(this),this.isDisposedInternal=!0}}Object.defineProperty(gv,Symbol.hasInstance,{value:n=>n instanceof nr&&null!=n.assign&&n.assign instanceof Function});var eu=(()=>((eu=eu||{}).float32="float32",eu.int32="int32",eu.bool="int32",eu.complex64="complex64",eu))(),tu=(()=>((tu=tu||{}).float32="float32",tu.int32="int32",tu.bool="bool",tu.complex64="complex64",tu))(),nu=(()=>((nu=nu||{}).float32="float32",nu.int32="float32",nu.bool="float32",nu.complex64="complex64",nu))(),ru=(()=>((ru=ru||{}).float32="complex64",ru.int32="complex64",ru.bool="complex64",ru.complex64="complex64",ru))();const pre={float32:nu,int32:eu,bool:tu,complex64:ru};function Ti(n,t){if("string"===n||"string"===t){if("string"===n&&"string"===t)return"string";throw new Error(`Can not upcast ${n} with ${t}`)}return pre[n][t]}function cI(n){return Ti(n,"int32")}function WL(n){return null!=n&&"object"==typeof n&&"texture"in n&&n.texture instanceof WebGLTexture}function HL(n){return typeof GPUBuffer<"u"&&null!=n&&"object"==typeof n&&"buffer"in n&&n.buffer instanceof GPUBuffer}function vr(n,t){if(n.dtype===t.dtype)return[n,t];const e=Ti(n.dtype,t.dtype);return[n.cast(e),t.cast(e)]}function qL(n){const t=[];return KL(n,t,new Set),t}function KL(n,t,e){if(null==n)return;if(n instanceof nr)return void t.push(n);if(!function mre(n){return Array.isArray(n)||"object"==typeof n}(n))return;const r=n;for(const s in r){const i=r[s];e.has(i)||(e.add(i),KL(i,t,e))}}function dI(n){return null!=n.kernelName}class XL{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map(t=>t.name)))}}}dispose(){for(const t in this.registeredVariables)this.registeredVariables[t].dispose()}}let gre=(()=>{class n{constructor(e){this.ENV=e,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new XL}ready(){var e=this;return Ve(function*(){if(null!=e.pendingBackendInit)return e.pendingBackendInit.then(()=>{});if(null!=e.backendInstance)return;const r=e.getSortedBackends();for(let s=0;s<r.length;s++){const i=r[s];if(yield e.initializeBackend(i).success)return void(yield e.setBackend(i))}throw new Error("Could not initialize any backends, all backend initializations failed.")})()}get backend(){if(null!=this.pendingBackendInit)throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);if(null==this.backendInstance){const{name:e,asyncInit:r}=this.initializeBackendsAndReturnBest();if(r)throw new Error(`The highest priority backend '${e}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);this.setBackend(e)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(e){if(!(e in this.registry)){if(!(e in this.registryFactory))return null;{const{asyncInit:r}=this.initializeBackend(e);if(r)return null}}return this.registry[e]}findBackendFactory(e){return e in this.registryFactory?this.registryFactory[e].factory:null}registerBackend(e,r,s=1){return e in this.registryFactory?(Ui(`${e} backend was already registered. Reusing existing backend factory.`),!1):(this.registryFactory[e]={factory:r,priority:s},!0)}setBackend(e){var r=this;return Ve(function*(){if(null==r.registryFactory[e])throw new Error(`Backend name '${e}' not found in registry`);if(r.backendName=e,null==r.registry[e]){r.backendInstance=null;const{success:s,asyncInit:i}=r.initializeBackend(e);if(!(i?yield s:s))return!1}return r.backendInstance=r.registry[e],r.setupRegisteredKernels(),r.profiler=new rre(r.backendInstance),!0})()}setupRegisteredKernels(){iI(this.backendName).forEach(r=>{null!=r.setupFunc&&r.setupFunc(this.backendInstance)})}disposeRegisteredKernels(e){iI(e).forEach(s=>{null!=s.disposeFunc&&s.disposeFunc(this.registry[e])})}initializeBackend(e){const r=this.registryFactory[e];if(null==r)throw new Error(`Cannot initialize backend ${e}, no registration found.`);try{const s=r.factory();if(!s||s instanceof j1||"function"!=typeof s.then)return this.registry[e]=s,{success:!0,asyncInit:!1};{const i=++this.pendingBackendInitId,o=s.then(a=>!(i<this.pendingBackendInitId||(this.registry[e]=a,this.pendingBackendInit=null,0))).catch(a=>(i<this.pendingBackendInitId||(this.pendingBackendInit=null,Ui(`Initialization of backend ${e} failed`),Ui(a.stack||a.message)),!1));return this.pendingBackendInit=o,{success:o,asyncInit:!0}}}catch(s){return Ui(`Initialization of backend ${e} failed`),Ui(s.stack||s.message),{success:!1,asyncInit:!1}}}removeBackend(e){if(!(e in this.registryFactory))throw new Error(`${e} backend not found in registry`);this.backendName===e&&null!=this.pendingBackendInit&&this.pendingBackendInitId++,e in this.registry&&(this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e]),delete this.registryFactory[e],this.backendName===e&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(0===Object.keys(this.registryFactory).length)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort((e,r)=>this.registryFactory[r].priority-this.registryFactory[e].priority)}initializeBackendsAndReturnBest(){const e=this.getSortedBackends();for(let r=0;r<e.length;r++){const s=e[r],{success:i,asyncInit:o}=this.initializeBackend(s);if(o||i)return{name:s,asyncInit:o}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(e,r){const s=this.state.tensorInfo.get(r),i=s.backend,o=this.readSync(r),a=i.refCount(r);i.disposeData(r,!0),s.backend=e,e.move(r,o,s.shape,s.dtype,a),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(e,r){let i,s=null;if(null==r){if("function"!=typeof e)throw new Error("Please provide a function to tidy()");r=e}else{if("string"!=typeof e&&!(e instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if("function"!=typeof r)throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");s=e}return this.scopedRun(()=>this.startScope(s),()=>this.endScope(i),()=>(i=r(),i instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),i))}scopedRun(e,r,s){e();try{const i=s();return r(),i}catch(i){throw r(),i}}nextTensorId(){return n.nextTensorId++}nextVariableId(){return n.nextVariableId++}clone(e){const r=fe.runKernel(um,{x:e});return this.addTapeNode(this.state.activeScope.name,{x:e},[r],a=>({x:()=>fe.runKernel(Yf,{x:a},{dtype:"float32"})}),[],{}),r}runKernel(e,r,s){if(null==PL(e,this.backendName))throw new Error(`Kernel '${e}' not registered for backend '${this.backendName}'`);return this.runKernelFunc({kernelName:e,inputs:r,attrs:s})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(e,r,s){const i=this.backend.numDataIds();let o=0;s.forEach(c=>{o+="complex64"===c.dtype?3:1});const u=i-r-o-this.state.numDataMovesStack[this.state.numDataMovesStack.length-1];if(u>0)throw new Error(`Backend '${this.backendName}' has an internal memory leak (${u} data ids) after running '${e}'`)}runKernelFunc(e){let r,s=[];const i=this.isTapeOn(),o=this.state.numBytes,a=this.state.numTensors;let u,c;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0);const p=dI(e)?e.kernelName:null!=this.state.activeScope?this.state.activeScope.name:"";if(dI(e)){const{kernelName:T,inputs:I,attrs:O}=e,M=PL(T,this.backendName);J(null!=M,()=>`Cannot find registered kernel '${T}' for backend '${this.backendName}'`),u=()=>{const V=this.backend.numDataIds();c=M.kernelFunc({inputs:I,attrs:O,backend:this.backend});const z=Array.isArray(c)?c:[c];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(T,V,z);const G=z.map(Q=>null!=Q.rank?Q:this.makeTensorFromTensorInfo(Q));if(i){const Q=this.getTensorsForGradient(T,I,G);s=this.saveTensorsForBackwardMode(Q)}return G}}else{const{forwardFunc:T}=e,I=O=>{i&&(s=O.map(M=>this.keep(this.clone(M))))};u=()=>{const O=this.backend.numDataIds();c=this.tidy(()=>T(this.backend,I));const M=Array.isArray(c)?c:[c];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(p,O,M),M}}const{inputs:m,attrs:y}=e,_=dI(e)?null:e.backwardsFunc;let w;return this.scopedRun(()=>this.state.kernelDepth++,()=>this.state.kernelDepth--,()=>{this.ENV.getBool("DEBUG")||this.state.profiling?(w=this.profiler.profileKernel(p,m,()=>u()),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(w),r=w.outputs):r=u()}),i&&this.addTapeNode(p,m,r,_,s,y),this.state.profiling&&this.state.activeProfile.kernels.push({name:p,bytesAdded:this.state.numBytes-o,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-a,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(m).map(T=>null!=m[T]?m[T].shape:null),outputShapes:r.map(T=>T.shape),kernelTimeMs:w.timeMs,extraInfo:w.extraInfo}),Array.isArray(c)?r:r[0]}saveTensorsForBackwardMode(e){return e.map(s=>this.keep(this.clone(s)))}getTensorsForGradient(e,r,s){const i=FL(e);if(null!=i){const o=i.inputsToSave||[],a=i.outputsToSave||[];let u;i.saveAllInputs?(J(Array.isArray(r),()=>"saveAllInputs is true, expected inputs to be an array."),u=Object.keys(r).map(p=>r[p])):u=o.map(p=>r[p]);const c=s.filter((p,m)=>a[m]);return u.concat(c)}return[]}makeTensor(e,r,s,i){if(null==e)throw new Error("Values passed to engine.makeTensor() are null");i=i||this.backend;let o=e;"string"===(s=s||"float32")&&Uf(e[0])&&(o=e.map(c=>Ql(c)));const a=i.write(o,r,s),u=new nr(r,s,a,this.nextTensorId());if(this.trackTensor(u,i),"string"===s){const c=this.state.tensorInfo.get(a),p=function Fne(n){if(null==n)return 0;let t=0;return n.forEach(e=>t+=e.length),t}(o);this.state.numBytes+=p-c.bytes,c.bytes=p}return u}makeTensorFromDataId(e,r,s,i){return this.makeTensorFromTensorInfo({dataId:e,shape:r,dtype:s=s||"float32"},i)}makeTensorFromTensorInfo(e,r){const{dataId:s,shape:i,dtype:o}=e,a=new nr(i,o,s,this.nextTensorId());return this.trackTensor(a,r),a}makeVariable(e,r=!0,s,i){s=s||this.nextVariableId().toString(),null!=i&&i!==e.dtype&&(e=e.cast(i));const o=new gv(e,r,s,this.nextTensorId());if(null!=this.state.registeredVariables[o.name])throw new Error(`Variable with name ${o.name} was already registered`);return this.state.registeredVariables[o.name]=o,this.incRef(o,this.backend),o}trackTensor(e,r){this.state.numTensors++,"string"===e.dtype&&this.state.numStringTensors++;let s=0;"complex64"!==e.dtype&&"string"!==e.dtype&&(s=e.size*a_(e.dtype)),this.state.numBytes+=s,this.state.tensorInfo.has(e.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(e.dataId,{backend:r||this.backend,dtype:e.dtype,shape:e.shape,bytes:s})),e instanceof gv||this.track(e)}incRef(e,r){this.trackTensor(e,r),this.backend.incRef(e.dataId)}removeDataId(e,r){this.state.tensorInfo.has(e)&&this.state.tensorInfo.get(e).backend===r&&(this.state.tensorInfo.delete(e),this.state.numDataBuffers--)}disposeTensor(e){if(!this.state.tensorInfo.has(e.dataId))return;const r=this.state.tensorInfo.get(e.dataId);if(this.state.numTensors--,"string"===e.dtype&&(this.state.numStringTensors--,this.state.numBytes-=r.bytes),"complex64"!==e.dtype&&"string"!==e.dtype){const s=e.size*a_(e.dtype);this.state.numBytes-=s}r.backend.disposeData(e.dataId)&&this.removeDataId(e.dataId,r.backend)}disposeVariables(){for(const e in this.state.registeredVariables)this.disposeVariable(this.state.registeredVariables[e])}disposeVariable(e){this.disposeTensor(e),null!=this.state.registeredVariables[e.name]&&delete this.state.registeredVariables[e.name]}memory(){const e=this.backend.memory();return e.numTensors=this.state.numTensors,e.numDataBuffers=this.state.numDataBuffers,e.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(e.unreliable=!0,null==e.reasons&&(e.reasons=[]),e.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),e}profile(e){var r=this;return Ve(function*(){r.state.profiling=!0;const s=r.state.numBytes,i=r.state.numTensors;r.state.activeProfile.kernels=[],r.state.activeProfile.result=yield e(),r.state.profiling=!1,r.state.activeProfile.peakBytes=Math.max(...r.state.activeProfile.kernels.map(o=>o.totalBytesSnapshot)),r.state.activeProfile.newBytes=r.state.numBytes-s,r.state.activeProfile.newTensors=r.state.numTensors-i;for(const o of r.state.activeProfile.kernels)o.kernelTimeMs=yield o.kernelTimeMs,o.extraInfo=yield o.extraInfo;return r.state.activeProfile})()}isTapeOn(){return this.state.gradientDepth>0&&0===this.state.kernelDepth}addTapeNode(e,r,s,i,o,a){const u={id:this.state.nextTapeNodeId++,kernelName:e,inputs:r,outputs:s,saved:o},c=FL(e);null!=c&&(i=c.gradFunc),null!=i&&(u.gradient=p=>(p=p.map((m,y)=>{if(null==m){const _=s[y],w=ks(_.size,_.dtype);return this.makeTensor(w,_.shape,_.dtype)}return m}),i(p.length>1?p:p[0],o,a))),this.state.activeTape.push(u)}keep(e){return e.kept=!0,e}startTape(){0===this.state.gradientDepth&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(e){const r={track:[],name:"unnamed scope",id:this.state.nextScopeId++};e&&(r.name=e),this.state.scopeStack.push(r),this.state.activeScope=r}endScope(e){const r=qL(e),s=new Set(r.map(o=>o.id));for(let o=0;o<this.state.activeScope.track.length;o++){const a=this.state.activeScope.track[o];!a.kept&&!s.has(a.id)&&a.dispose()}const i=this.state.scopeStack.pop();this.state.activeScope=0===this.state.scopeStack.length?null:this.state.scopeStack[this.state.scopeStack.length-1],r.forEach(o=>{!o.kept&&o.scopeId===i.id&&this.track(o)})}gradients(e,r,s,i=!1){if(J(r.length>0,()=>"gradients() received an empty list of xs."),null!=s&&"float32"!==s.dtype)throw new Error(`dy must have 'float32' dtype, but has '${s.dtype}'`);const o=this.scopedRun(()=>this.startTape(),()=>this.endTape(),()=>this.tidy("forward",e));J(o instanceof nr,()=>"The result y returned by f() must be a tensor.");const a=function ore(n,t,e){const r={},s={};for(let u=0;u<t.length;u++)r[t[u].id]=!0;for(let u=0;u<n.length;u++){const c=n[u],p=c.inputs;for(const m in p){const y=p[m];let _=!1;for(let w=0;w<t.length;w++)if(r[y.id]){c.outputs.forEach(T=>r[T.id]=!0),_=!0,s[c.id]=!0;break}if(_)break}}const i={};i[e.id]=!0;const o={};for(let u=n.length-1;u>=0;u--){const c=n[u],p=c.inputs;for(let m=0;m<c.outputs.length;m++)if(i[c.outputs[m].id]){for(const y in p)i[p[y].id]=!0,o[c.id]=!0;break}}const a=[];for(let u=0;u<n.length;u++){const c=n[u];if(s[c.id]&&o[c.id]){const p={};for(const y in c.inputs){const _=c.inputs[y];r[_.id]&&(p[y]=_)}const m=Object.assign({},c);m.inputs=p,m.outputs=c.outputs,a.push(m)}}return a}(this.state.activeTape,r,o);if(!i&&0===a.length&&r.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",()=>{const u={};u[o.id]=s??function yre(n){const t=X1(Fe(n),"float32");return fe.makeTensor(t,n,"float32")}(o.shape),function are(n,t,e,r){for(let s=t.length-1;s>=0;s--){const i=t[s],o=[];if(i.outputs.forEach(u=>{const c=n[u.id];o.push(null!=c?c:null)}),null==i.gradient)throw new Error(`Cannot compute gradient: gradient function not found for ${i.kernelName}.`);const a=i.gradient(o);for(const u in i.inputs){if(!(u in a))throw new Error(`Cannot backprop through input ${u}. Available gradients found: ${Object.keys(a)}.`);const c=e(()=>a[u]());if("float32"!==c.dtype)throw new Error(`Error in gradient for op ${i.kernelName}. The gradient of input ${u} must have 'float32' dtype, but has '${c.dtype}'`);const p=i.inputs[u];if(!hn(c.shape,p.shape))throw new Error(`Error in gradient for op ${i.kernelName}. The gradient of input '${u}' has shape '${c.shape}', which does not match the shape of the input '${p.shape}'`);if(null==n[p.id])n[p.id]=c;else{const m=n[p.id];n[p.id]=r(m,c),m.dispose()}}}}(u,a,p=>this.tidy(p),bre);const c=r.map(p=>u[p.id]);return 0===this.state.gradientDepth&&(this.state.activeTape.forEach(p=>{for(const m of p.saved)m.dispose()}),this.state.activeTape=null),{value:o,grads:c}})}customGrad(e){return J(q1(e),()=>"The f passed in customGrad(f) must be a function."),(...r)=>{let s;J(r.every(u=>u instanceof nr),()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors");const i={};return r.forEach((u,c)=>{i[c]=u}),this.runKernelFunc({forwardFunc:(u,c)=>(s=e(...r,c),J(s.value instanceof nr,()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor"),J(q1(s.gradFunc),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function."),s.value),backwardsFunc:(u,c)=>{const p=s.gradFunc(u,c),m=Array.isArray(p)?p:[p];J(m.length===r.length,()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...)."),J(m.every(_=>_ instanceof nr),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.");const y={};return m.forEach((_,w)=>{y[w]=()=>_}),y},inputs:i})}}readSync(e){return this.state.tensorInfo.get(e).backend.readSync(e)}read(e){return this.state.tensorInfo.get(e).backend.read(e)}readToGPU(e,r){return this.state.tensorInfo.get(e).backend.readToGPU(e,r)}time(e){var r=this;return Ve(function*(){const s=ri(),i=yield r.backend.time(e);return i.wallMs=ri()-s,i})()}track(e){return null!=this.state.activeScope&&(e.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(e)),e}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new XL;for(const e in this.registry)this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}}return n.nextTensorId=0,n.nextVariableId=0,n})();function YL(){const n=ML();if(null==n._tfengine){const t=new Vne(n);n._tfengine=new gre(t)}return function jne(n){RL=n}(n._tfengine.ENV),function cre(n){Xo=n}(()=>n._tfengine),n._tfengine}const fe=YL();function bre(n,t){return fe.runKernel(dh,{a:n,b:t})}function ZL(n){if(n||function _re(){return typeof navigator<"u"&&null!=navigator}()){if(n||(n=navigator),"ReactNative"===n.product)return!0;const t=n.userAgent||n.vendor||(typeof window<"u"?window.opera:"");return t?/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(t)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(t.substr(0,4)):n.userAgentData&&n.userAgentData.mobile}return!1}function QL(){return typeof window<"u"&&null!=window.document||typeof WorkerGlobalScope<"u"}const si=De();function su(n,t){let e=n;if(bo(n))return"string"===t?[]:[n.length];if(WL(n))return[n.height,n.width*(n.channels||"RGBA").length];if(HL(n))return[n.buffer.size/(null==t?4:a_(t))];if(!Array.isArray(n))return[];const r=[];for(;Array.isArray(e)||bo(e)&&"string"!==t;)r.push(e.length),e=e[0];return Array.isArray(n)&&De().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&JL(n,r,[]),r}function JL(n,t,e){if(e=e||[],!Array.isArray(n)&&!bo(n))return void J(0===t.length,()=>`Element arr[${e.join("][")}] is a primitive, but should be an array/TypedArray of ${t[0]} elements`);J(t.length>0,()=>`Element arr[${e.join("][")}] should be a primitive, but is an array of ${n.length} elements`),J(n.length===t[0],()=>`Element arr[${e.join("][")}] should have ${t[0]} elements, but has ${n.length} elements`);const r=t.slice(1);for(let s=0;s<n.length;++s)JL(n[s],r,e.concat(s))}function e3(n,t,e,r){if("string_or_numeric"!==n){if(null==n)throw new Error("Expected dtype cannot be null.");if("numeric"!==n&&n!==t||"numeric"===n&&"string"===t)throw new Error(`Argument '${e}' passed to '${r}' must be ${n} tensor, but got ${t} tensor`)}}function ee(n,t,e,r="numeric"){if(n instanceof nr)return e3(r,n.dtype,t,e),n;let s=uh(n);if("string"!==s&&["bool","int32","float32"].indexOf(r)>=0&&(s=r),e3(r,s,t,e),null==n||!bo(n)&&!Array.isArray(n)&&"number"!=typeof n&&"boolean"!=typeof n&&"string"!=typeof n)throw new Error(`Argument '${t}' passed to '${e}' must be a Tensor or TensorLike, but got '${null==n?"null":n.constructor.name}'`);const i=su(n,s);!bo(n)&&!Array.isArray(n)&&(n=[n]);const a="string"!==s?bc(n,s):_c(n,[],!0);return fe.makeTensor(a,i,s)}function yv(n,t,e,r="numeric"){if(!Array.isArray(n))throw new Error(`Argument ${t} passed to ${e} must be a \`Tensor[]\` or \`TensorLike[]\``);return n.map((i,o)=>ee(i,`${t}[${o}]`,e,r))}si.registerFlag("DEBUG",()=>!1,n=>{n&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")}),si.registerFlag("IS_BROWSER",()=>QL()),si.registerFlag("IS_NODE",()=>typeof process<"u"&&typeof process.versions<"u"&&typeof process.versions.node<"u"),si.registerFlag("IS_CHROME",()=>typeof navigator<"u"&&null!=navigator&&null!=navigator.userAgent&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor)),si.registerFlag("IS_SAFARI",()=>typeof navigator<"u"&&null!=navigator&&null!=navigator.userAgent&&/Safari/.test(navigator.userAgent)&&/Apple/.test(navigator.vendor)),si.registerFlag("PROD",()=>!1),si.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",()=>si.getBool("DEBUG")),si.registerFlag("DEPRECATION_WARNINGS_ENABLED",()=>!0),si.registerFlag("IS_TEST",()=>!1),si.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",()=>si.getBool("DEBUG")),si.registerFlag("WRAP_TO_IMAGEBITMAP",()=>!1),si.registerFlag("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU",()=>!1),si.registerFlag("USE_SETTIMEOUTCUSTOM",()=>!1);const t3="__op";function he(n){const t=Object.keys(n);if(1!==t.length)throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${t.length} keys.`);let e=t[0];const r=n[e];e.endsWith("_")&&(e=e.substring(0,e.length-1)),e+=t3;const s=(...i)=>{fe.startScope(e);try{const o=r(...i);return mc(o)&&console.error("Cannot return a Promise inside of tidy."),fe.endScope(o),o}catch(o){throw fe.endScope(null),o}};return Object.defineProperty(s,"name",{value:e,configurable:!0}),s}const iu=he({complex_:function vre(n,t){const e=ee(n,"real","complex"),r=ee(t,"imag","complex");return xi(e.shape,r.shape,`real and imag shapes, ${e.shape} and ${r.shape}, must match in call to tf.complex().`),fe.runKernel(iC,{real:e,imag:r})}});function ou(n,t,e,r){if(null==r)r=uh(n);else if("complex64"===r)throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(HL(n)||WL(n)){if("float32"!==r&&"int32"!==r)throw new Error(`Creating tensor from GPU data only supports 'float32'|'int32' dtype, while the dtype is ${r}.`);return fe.backend.createTensorFromGPUData(n,t||e,r)}if(!bo(n)&&!Array.isArray(n)&&"number"!=typeof n&&"boolean"!=typeof n&&"string"!=typeof n)throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(null!=t){zi(t);const s=Fe(t),i=Fe(e);J(s===i,()=>`Based on the provided shape, [${t}], the tensor should have ${s} values but has ${i}`);for(let o=0;o<e.length;++o){const u=o!==e.length-1||e[o]!==Fe(t.slice(o));J(e[o]===t[o]||!u,()=>`Error creating a new Tensor. Inferred shape (${e}) does not match the provided shape (${t}). `)}}return!bo(n)&&!Array.isArray(n)&&(n=[n]),t=t||e,n="string"!==r?bc(n,r):_c(n,[],!0),fe.makeTensor(n,t,r)}function Yo(n,t,e){return ou(n,t,su(n,e),e)}const pI={float32:4,float16:2,int32:4,uint16:2,uint8:1,bool:1,complex64:8},bv=4;function fI(n,t){return mI.apply(this,arguments)}function mI(){return mI=Ve(function*(n,t){const e=[],r=[],s=Array.isArray(n)?n.map(o=>o.name):Object.keys(n);for(let o=0;o<s.length;++o){const a=s[o],u=Array.isArray(n)?n[o].tensor:n[a];if("float32"!==u.dtype&&"int32"!==u.dtype&&"bool"!==u.dtype&&"string"!==u.dtype&&"complex64"!==u.dtype)throw new Error(`Unsupported dtype in weight '${a}': ${u.dtype}`);const c={name:a,shape:u.shape,dtype:u.dtype};if("string"===u.dtype){const p=new Promise(function(){var m=Ve(function*(y){const _=yield u.bytes(),w=_.reduce((O,M)=>O+M.length,0)+bv*_.length,T=new Uint8Array(w);let I=0;for(let O=0;O<_.length;O++){const M=_[O],V=new Uint8Array(new Uint32Array([M.length]).buffer);T.set(V,I),I+=bv,T.set(M,I),I+=M.length}y(T)});return function(y){return m.apply(this,arguments)}}());r.push(p)}else r.push(u.data());null!=t&&(c.group=t),e.push(c)}return{data:wre(yield Promise.all(r)),specs:e}}),mI.apply(this,arguments)}function n3(n,t){const e={};let r,s=0;for(const i of t){const o=i.name,a=i.dtype,u=i.shape,c=Fe(u);let p;if("quantization"in i){const m=i.quantization;if("uint8"===m.dtype||"uint16"===m.dtype){if(!("min"in m)||!("scale"in m))throw new Error(`Weight ${i.name} with quantization ${m.dtype} doesn't have corresponding metadata min and scale.`)}else{if("float16"!==m.dtype)throw new Error(`Weight ${i.name} has unknown quantization dtype ${m.dtype}. Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'.`);if("float32"!==a)throw new Error(`Weight ${i.name} is quantized with ${m.dtype} which only supports weights of type float32 not ${a}.`)}const y=pI[m.dtype],_=n.slice(s,s+c*y),w="uint8"===m.dtype?new Uint8Array(_):new Uint16Array(_);if("float32"===a)if("uint8"===m.dtype||"uint16"===m.dtype){p=new Float32Array(w.length);for(let T=0;T<w.length;T++)p[T]=w[T]*m.scale+m.min}else{if("float16"!==m.dtype)throw new Error(`Unsupported quantization type ${m.dtype} for weight type float32.`);void 0===r&&(r=Ere()),p=r(w)}else{if("int32"!==a)throw new Error(`Unsupported dtype in weight '${o}': ${a}`);if("uint8"!==m.dtype&&"uint16"!==m.dtype)throw new Error(`Unsupported quantization type ${m.dtype} for weight type int32.`);p=new Int32Array(w.length);for(let T=0;T<w.length;T++)p[T]=Math.round(w[T]*m.scale+m.min)}s+=c*y}else if("string"===a){const m=Fe(i.shape);p=[];for(let y=0;y<m;y++){const _=new Uint32Array(n.slice(s,s+bv))[0];s+=bv;const w=new Uint8Array(n.slice(s,s+_));p.push(w),s+=_}}else{const m=pI[a],y=n.slice(s,s+c*m);if("float32"===a)p=new Float32Array(y);else if("int32"===a)p=new Int32Array(y);else if("bool"===a)p=new Uint8Array(y);else{if("complex64"!==a)throw new Error(`Unsupported dtype in weight '${o}': ${a}`);{p=new Float32Array(y);const _=new Float32Array(p.length/2),w=new Float32Array(p.length/2);for(let O=0;O<_.length;O++)_[O]=p[2*O],w[O]=p[2*O+1];const T=Yo(_,u,"float32"),I=Yo(w,u,"float32");e[o]=iu(T,I),T.dispose(),I.dispose()}}s+=c*m}"complex64"!==a&&(e[o]=Yo(p,u,a))}return e}function wre(n){if(null===n)throw new Error(`Invalid input value: ${JSON.stringify(n)}`);let t=0;const e=[];n.forEach(i=>{if(t+=i.byteLength,e.push(i.byteLength===i.buffer.byteLength?i:new i.constructor(i)),!(i instanceof Float32Array||i instanceof Int32Array||i instanceof Uint8Array))throw new Error(`Unsupported TypedArray subtype: ${i.constructor.name}`)});const r=new Uint8Array(t);let s=0;return e.forEach(i=>{r.set(new Uint8Array(i.buffer),s),s+=i.byteLength}),r.buffer}const gI=typeof Buffer<"u"&&(typeof Blob>"u"||typeof atob>"u"||typeof btoa>"u");function r3(n){return gI?Buffer.byteLength(n):new Blob([n]).size}function _v(n){if(1===n.length)return n[0];let t=0;n.forEach(s=>{t+=s.byteLength});const e=new Uint8Array(t);let r=0;return n.forEach(s=>{e.set(new Uint8Array(s),r),r+=s.byteLength}),e.buffer}function s3(n){for(n=n.trim();n.endsWith("/");)n=n.slice(0,n.length-1);const e=n.split("/");return e[e.length-1]}function o3(n,t){const e={modelTopology:n.modelTopology,format:n.format,generatedBy:n.generatedBy,convertedBy:n.convertedBy,weightsManifest:t};return null!=n.signature&&(e.signature=n.signature),null!=n.userDefinedMetadata&&(e.userDefinedMetadata=n.userDefinedMetadata),null!=n.modelInitializer&&(e.modelInitializer=n.modelInitializer),null!=n.initializerSignature&&(e.initializerSignature=n.initializerSignature),null!=n.trainingConfig&&(e.trainingConfig=n.trainingConfig),e}function a3(n,t,e){const r={modelTopology:n.modelTopology,format:n.format,generatedBy:n.generatedBy,convertedBy:n.convertedBy};if(null!=n.trainingConfig&&(r.trainingConfig=n.trainingConfig),null!=n.weightsManifest){if(!t)throw new Error("modelJSON has weightsManifest but weightSpecs is null");if(!e)throw new Error("modelJSON has weightsManifest but weightData is null");r.weightSpecs=t,r.weightData=e}return null!=n.signature&&(r.signature=n.signature),null!=n.userDefinedMetadata&&(r.userDefinedMetadata=n.userDefinedMetadata),null!=n.modelInitializer&&(r.modelInitializer=n.modelInitializer),null!=n.initializerSignature&&(r.initializerSignature=n.initializerSignature),r}function yI(n,t){return bI.apply(this,arguments)}function bI(){return(bI=Ve(function*(n,t){let e,r;return null!=n.weightsManifest&&([e,r]=yield t(n.weightsManifest)),a3(n,e,r)})).apply(this,arguments)}function Um(n){if(n.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:null==n.modelTopology?0:r3(JSON.stringify(n.modelTopology)),weightSpecsBytes:null==n.weightSpecs?0:r3(JSON.stringify(n.weightSpecs)),weightDataBytes:null==n.weightData?0:n.weightData.byteLength}}function l3(n){const t=[];for(const e of n)t.push(...e.weights);return t}function Ere(){const n=function Sre(){const n=e=>{let r=e<<13,s=0;for(;!(8388608&r);)s-=8388608,r<<=1;return r&=-8388609,s+=947912704,r|s},t=new Uint32Array(2048);t[0]=0;for(let e=1;e<1024;e++)t[e]=n(e);for(let e=1024;e<2048;e++)t[e]=939524096+(e-1024<<13);return t}(),t=function Cre(){const n=new Uint32Array(64);n[0]=0,n[31]=1199570944,n[32]=2147483648,n[63]=3347054592;for(let t=1;t<31;t++)n[t]=t<<23;for(let t=33;t<63;t++)n[t]=2147483648+(t-32<<23);return n}(),e=function Ire(){const n=new Uint32Array(64);for(let t=0;t<64;t++)n[t]=1024;return n[0]=n[32]=0,n}();return r=>{const s=new ArrayBuffer(4*r.length),i=new Uint32Array(s);for(let o=0;o<r.length;o++){const a=r[o];i[o]=n[e[a>>10]+(1023&a)]+t[a>>10]}return new Float32Array(s)}}class lr{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return null==lr.instance&&(lr.instance=new lr),lr.instance}static registerSaveRouter(t){lr.getInstance().saveRouters.push(t)}static registerLoadRouter(t){lr.getInstance().loadRouters.push(t)}static getSaveHandlers(t){return lr.getHandlers(t,"save")}static getLoadHandlers(t,e){return lr.getHandlers(t,"load",e)}static getHandlers(t,e,r){const s=[];return("load"===e?lr.getInstance().loadRouters:lr.getInstance().saveRouters).forEach(o=>{const a=o(t,r);null!==a&&s.push(a)}),s}}const Dre=n=>lr.registerSaveRouter(n),Are=n=>lr.registerLoadRouter(n),u3=n=>lr.getSaveHandlers(n),kre=(n,t)=>lr.getLoadHandlers(n,t),vv="tensorflowjs",vc="models_store",au="model_info_store";function wI(){if(!De().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");const n=typeof window>"u"?self:window,t=n.indexedDB||n.mozIndexedDB||n.webkitIndexedDB||n.msIndexedDB||n.shimIndexedDB;if(null==t)throw new Error("The current browser does not appear to support IndexedDB.");return t}function xI(n){const t=n.result;t.createObjectStore(vc,{keyPath:"modelPath"}),t.createObjectStore(au,{keyPath:"modelPath"})}let mh=(()=>{class n{constructor(e){if(this.indexedDB=wI(),null==e||!e)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=e}save(e){var r=this;return Ve(function*(){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return r.databaseAction(r.modelPath,e)})()}load(){var e=this;return Ve(function*(){return e.databaseAction(e.modelPath)})()}databaseAction(e,r){return new Promise((s,i)=>{const o=this.indexedDB.open(vv,1);o.onupgradeneeded=()=>xI(o),o.onsuccess=()=>{const a=o.result;if(null==r){const u=a.transaction(vc,"readonly"),p=u.objectStore(vc).get(this.modelPath);p.onsuccess=()=>{if(null==p.result)return a.close(),i(new Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));s(p.result.modelArtifacts)},p.onerror=m=>(a.close(),i(p.error)),u.oncomplete=()=>a.close()}else{const u=Um(r),c=a.transaction(au,"readwrite");let m,y,p=c.objectStore(au);try{m=p.put({modelPath:this.modelPath,modelArtifactsInfo:u})}catch(_){return i(_)}m.onsuccess=()=>{y=a.transaction(vc,"readwrite");const _=y.objectStore(vc);let w;try{w=_.put({modelPath:this.modelPath,modelArtifacts:r,modelArtifactsInfo:u})}catch(T){return i(T)}w.onsuccess=()=>s({modelArtifactsInfo:u}),w.onerror=T=>{p=c.objectStore(au);const I=p.delete(this.modelPath);I.onsuccess=()=>(a.close(),i(w.error)),I.onerror=O=>(a.close(),i(w.error))}},m.onerror=_=>(a.close(),i(m.error)),c.oncomplete=()=>{null==y?a.close():y.oncomplete=()=>a.close()}}},o.onerror=a=>i(o.error)})}}return n.URL_SCHEME="indexeddb://",n})();const c3=n=>De().getBool("IS_BROWSER")&&!Array.isArray(n)&&n.startsWith(mh.URL_SCHEME)?function Nre(n){return new mh(n)}(n.slice(mh.URL_SCHEME.length)):null;lr.registerSaveRouter(c3),lr.registerLoadRouter(c3);class Rre{constructor(){this.indexedDB=wI()}listModels(){var t=this;return Ve(function*(){return new Promise((e,r)=>{const s=t.indexedDB.open(vv,1);s.onupgradeneeded=()=>xI(s),s.onsuccess=()=>{const i=s.result,o=i.transaction(au,"readonly"),u=o.objectStore(au).getAll();u.onsuccess=()=>{const c={};for(const p of u.result)c[p.modelPath]=p.modelArtifactsInfo;e(c)},u.onerror=c=>(i.close(),r(u.error)),o.oncomplete=()=>i.close()},s.onerror=i=>r(s.error)})})()}removeModel(t){var e=this;return Ve(function*(){return t=function Ore(n){return n.startsWith(mh.URL_SCHEME)?n.slice(mh.URL_SCHEME.length):n}(t),new Promise((r,s)=>{const i=e.indexedDB.open(vv,1);i.onupgradeneeded=()=>xI(i),i.onsuccess=()=>{const o=i.result,a=o.transaction(au,"readwrite"),u=a.objectStore(au),c=u.get(t);let p;c.onsuccess=()=>{if(null==c.result)return o.close(),s(new Error(`Cannot find model with path '${t}' in IndexedDB.`));{const m=u.delete(t),y=()=>{p=o.transaction(vc,"readwrite");const w=p.objectStore(vc).delete(t);w.onsuccess=()=>r(c.result.modelArtifactsInfo),w.onerror=T=>s(c.error)};m.onsuccess=y,m.onerror=_=>(y(),o.close(),s(c.error))}},c.onerror=m=>(o.close(),s(c.error)),a.oncomplete=()=>{null==p?o.close():p.oncomplete=()=>o.close()}},i.onerror=o=>s(i.error)})})()}}const Ea="/",wc="tensorflowjs_models",d3="info",Mre="model_topology",Pre="weight_specs",Fre="weight_data",$re="model_metadata";function h3(n){return{info:[wc,n,d3].join(Ea),topology:[wc,n,Mre].join(Ea),weightSpecs:[wc,n,Pre].join(Ea),weightData:[wc,n,Fre].join(Ea),modelMetadata:[wc,n,$re].join(Ea)}}function p3(n){for(const t of Object.values(n))window.localStorage.removeItem(t)}function f3(n){const t=n.split(Ea);if(t.length<3)throw new Error(`Invalid key format: ${n}`);return t.slice(1,t.length-1).join(Ea)}let gh=(()=>{class n{constructor(e){if(!De().getBool("IS_BROWSER")||typeof window>"u"||typeof window.localStorage>"u")throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,null==e||!e)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=e,this.keys=h3(this.modelPath)}save(e){var r=this;return Ve(function*(){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{const s=JSON.stringify(e.modelTopology),i=JSON.stringify(e.weightSpecs),o=Um(e);try{return r.LS.setItem(r.keys.info,JSON.stringify(o)),r.LS.setItem(r.keys.topology,s),r.LS.setItem(r.keys.weightSpecs,i),r.LS.setItem(r.keys.weightData,function xre(n){if(gI)return Buffer.from(n).toString("base64");const t=new Uint8Array(n);let e="";for(let r=0,s=t.length;r<s;r++)e+=String.fromCharCode(t[r]);return btoa(e)}(e.weightData)),r.LS.setItem(r.keys.modelMetadata,JSON.stringify({format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,signature:null!=e.signature?e.signature:void 0,userDefinedMetadata:null!=e.userDefinedMetadata?e.userDefinedMetadata:void 0,modelInitializer:null!=e.modelInitializer?e.modelInitializer:void 0,initializerSignature:null!=e.initializerSignature?e.initializerSignature:void 0,trainingConfig:null!=e.trainingConfig?e.trainingConfig:void 0})),{modelArtifactsInfo:o}}catch{throw p3(r.keys),new Error(`Failed to save model '${r.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${o.modelTopologyBytes}, weightSpecsBytes=${o.weightSpecsBytes}, weightDataBytes=${o.weightDataBytes}.`)}}})()}load(){var e=this;return Ve(function*(){const r=JSON.parse(e.LS.getItem(e.keys.info));if(null==r)throw new Error(`In local storage, there is no model with name '${e.modelPath}'`);if("JSON"!==r.modelTopologyType)throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");const s={},i=JSON.parse(e.LS.getItem(e.keys.topology));if(null==i)throw new Error(`In local storage, the topology of model '${e.modelPath}' is missing.`);s.modelTopology=i;const o=JSON.parse(e.LS.getItem(e.keys.weightSpecs));if(null==o)throw new Error(`In local storage, the weight specs of model '${e.modelPath}' are missing.`);s.weightSpecs=o;const a=e.LS.getItem(e.keys.modelMetadata);if(null!=a){const c=JSON.parse(a);s.format=c.format,s.generatedBy=c.generatedBy,s.convertedBy=c.convertedBy,null!=c.signature&&(s.signature=c.signature),null!=c.userDefinedMetadata&&(s.userDefinedMetadata=c.userDefinedMetadata),null!=c.modelInitializer&&(s.modelInitializer=c.modelInitializer),null!=c.initializerSignature&&(s.initializerSignature=c.initializerSignature),null!=c.trainingConfig&&(s.trainingConfig=c.trainingConfig)}const u=e.LS.getItem(e.keys.weightData);if(null==u)throw new Error(`In local storage, the binary weight values of model '${e.modelPath}' are missing.`);return s.weightData=function Tre(n){if(gI){const r=Buffer.from(n,"base64");return r.buffer.slice(r.byteOffset,r.byteOffset+r.byteLength)}const t=atob(n),e=new Uint8Array(t.length);for(let r=0;r<t.length;++r)e.set([t.charCodeAt(r)],r);return e.buffer}(u),s})()}}return n.URL_SCHEME="localstorage://",n})();const m3=n=>De().getBool("IS_BROWSER")&&!Array.isArray(n)&&n.startsWith(gh.URL_SCHEME)?function Vre(n){return new gh(n)}(n.slice(gh.URL_SCHEME.length)):null;lr.registerSaveRouter(m3),lr.registerLoadRouter(m3);class Bre{constructor(){J(De().getBool("IS_BROWSER"),()=>"Current environment is not a web browser"),J(typeof window>"u"||typeof window.localStorage<"u",()=>"Current browser does not appear to support localStorage"),this.LS=window.localStorage}listModels(){var t=this;return Ve(function*(){const e={},r=wc+Ea,s=Ea+d3;for(let i=0;i<t.LS.length;++i){const o=t.LS.key(i);o.startsWith(r)&&o.endsWith(s)&&(e[f3(o)]=JSON.parse(t.LS.getItem(o)))}return e})()}removeModel(t){var e=this;return Ve(function*(){const r=h3(t=function Lre(n){return n.startsWith(gh.URL_SCHEME)?n.slice(gh.URL_SCHEME.length):n}(t));if(null==e.LS.getItem(r.info))throw new Error(`Cannot find model at path '${t}'`);const s=JSON.parse(e.LS.getItem(r.info));return p3(r),s})()}}const yh="://";class Us{constructor(){this.managers={}}static getInstance(){return null==Us.instance&&(Us.instance=new Us),Us.instance}static registerManager(t,e){J(null!=t,()=>"scheme must not be undefined or null."),t.endsWith(yh)&&(t=t.slice(0,t.indexOf(yh))),J(t.length>0,()=>"scheme must not be an empty string.");const r=Us.getInstance();J(null==r.managers[t],()=>`A model store manager is already registered for scheme '${t}'.`),r.managers[t]=e}static getManager(t){const e=Us.getInstance().managers[t];if(null==e)throw new Error(`Cannot find model manager for scheme '${t}'`);return e}static getSchemes(){return Object.keys(Us.getInstance().managers)}}function wv(n){if(-1===n.indexOf(yh))throw new Error(`The url string provided does not contain a scheme. Supported schemes are: ${Us.getSchemes().join(",")}`);return{scheme:n.split(yh)[0],path:n.split(yh)[1]}}function g3(n,t){return TI.apply(this,arguments)}function TI(){return(TI=Ve(function*(n,t,e=!1){J(n!==t,()=>`Old path and new path are the same: '${n}'`);const r=lr.getLoadHandlers(n);J(r.length>0,()=>`Copying failed because no load handler is found for source URL ${n}.`),J(r.length<2,()=>`Copying failed because more than one (${r.length}) load handlers for source URL ${n}.`);const s=r[0],i=lr.getSaveHandlers(t);J(i.length>0,()=>`Copying failed because no save handler is found for destination URL ${t}.`),J(i.length<2,()=>`Copying failed because more than one (${r.length}) save handlers for destination URL ${t}.`);const o=i[0],a=wv(n).scheme,u=wv(n).path,c=a===wv(n).scheme,p=yield s.load();e&&c&&(yield Us.getManager(a).removeModel(u));const m=yield o.save(p);return e&&!c&&(yield Us.getManager(a).removeModel(u)),m.modelArtifactsInfo})).apply(this,arguments)}function zre(){return SI.apply(this,arguments)}function SI(){return(SI=Ve(function*(){const n=Us.getSchemes(),t={};for(const e of n){const r=yield Us.getManager(e).listModels();for(const s in r)t[e+yh+s]=r[s]}return t})).apply(this,arguments)}function Ure(n){return CI.apply(this,arguments)}function CI(){return(CI=Ve(function*(n){const t=wv(n);return Us.getManager(t.scheme).removeModel(t.path)})).apply(this,arguments)}function jre(n,t){return II.apply(this,arguments)}function II(){return(II=Ve(function*(n,t){return g3(n,t,!1)})).apply(this,arguments)}function Gre(n,t){return EI.apply(this,arguments)}function EI(){return(EI=Ve(function*(n,t){return g3(n,t,!0)})).apply(this,arguments)}class Wre{constructor(){this.messageName="setTimeoutCustom",this.functionRefs=[],this.handledMessageCount=0,this.hasEventListener=!1}fetch(t,e){return fetch(t,e)}now(){return performance.now()}encode(t,e){if("utf-8"!==e&&"utf8"!==e)throw new Error(`Browser's encoder only supports utf-8, but got ${e}`);return null==this.textEncoder&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(t)}decode(t,e){return new TextDecoder(e).decode(t)}setTimeoutCustom(t,e){typeof window>"u"||!De().getBool("USE_SETTIMEOUTCUSTOM")?setTimeout(t,e):(this.functionRefs.push(t),setTimeout(()=>{window.postMessage({name:this.messageName,index:this.functionRefs.length-1},"*")},e),this.hasEventListener||(this.hasEventListener=!0,window.addEventListener("message",r=>{r.source===window&&r.data.name===this.messageName&&(r.stopPropagation(),(0,this.functionRefs[r.data.index])(),this.handledMessageCount++,this.handledMessageCount===this.functionRefs.length&&(this.functionRefs=[],this.handledMessageCount=0))},!0)))}isTypedArray(t){return $L(t)}}if(De().get("IS_BROWSER")){De().setPlatform("browser",new Wre);try{Us.registerManager(gh.URL_SCHEME,new Bre)}catch{}try{Us.registerManager(mh.URL_SCHEME,new Rre)}catch{}}let bh;function tn(n,t="float32",e){return t=t||"float32",zi(n),new qr(n,t,e)}De().get("IS_NODE")&&!De().get("IS_BROWSER")&&De().setPlatform("node",new class qre{constructor(){this.util=$(628),this.textEncoder=new this.util.TextEncoder}fetch(t,e){return null!=De().global.fetch?De().global.fetch(t,e):(null==bh&&(bh=$(410)),bh(t,e))}now(){const t=process.hrtime();return 1e3*t[0]+t[1]/1e6}encode(t,e){if("utf-8"!==e&&"utf8"!==e)throw new Error(`Node built-in encoder only supports utf-8, but got ${e}`);return this.textEncoder.encode(t)}decode(t,e){return 0===t.length?"":new this.util.TextDecoder(e).decode(t)}isTypedArray(t){return this.util.types.isFloat32Array(t)||this.util.types.isInt32Array(t)||this.util.types.isUint8Array(t)||this.util.types.isUint8ClampedArray(t)}});const pt=he({cast_:function Kre(n,t){const e=ee(n,"x","cast");if(!function Pne(n){return"bool"===n||"complex64"===n||"float32"===n||"int32"===n||"string"===n}(t))throw new Error(`Failed to cast to unknown dtype ${t}`);if("string"===t&&"string"!==e.dtype||"string"!==t&&"string"===e.dtype)throw new Error("Only strings can be casted to strings");return fe.runKernel(Yf,{x:e},{dtype:t})}}),cl=he({clone_:function Xre(n){const e={x:ee(n,"x","clone","string_or_numeric")};return fe.runKernel(um,e)}});function y3(n,t=!1){console.log(n.toString(t))}function Da(){return fe}function DI(){return fe.memory()}function Ce(n,t){return fe.tidy(n,t)}function on(n){qL(n).forEach(e=>e.dispose())}function as(n){return fe.keep(n)}function b3(n,t,e=1){return fe.registerBackend(n,t,e)}YL(),function dre(n){fh=n}({buffer:tn,cast:pt,clone:cl,print:y3}),function hre(n){GL=n}(function Yre(n){De().getBool("DEPRECATION_WARNINGS_ENABLED")&&console.warn(n+" You can disable deprecation warnings with tf.disableDeprecationWarnings().")});const Ze=he({add_:function Qre(n,t){let e=ee(n,"a","add"),r=ee(t,"b","add");return[e,r]=vr(e,r),fe.runKernel(dh,{a:e,b:r})}}),AI=he({floorDiv_:function Jre(n,t){let e=ee(n,"a","floorDiv"),r=ee(t,"b","floorDiv");return[e,r]=vr(e,r),fe.runKernel(am,{a:e,b:r})}}),At=he({div_:function ese(n,t){let e=ee(n,"a","div"),r=ee(t,"b","div");return[e,r]=vr(e,r),"int32"===e.dtype&&"int32"===r.dtype?AI(e,r):fe.runKernel(tm,{a:e,b:r},{})}}),me=he({mul_:function tse(n,t){let e=ee(n,"a","mul"),r=ee(t,"b","mul");return[e,r]=vr(e,r),fe.runKernel(bm,{a:e,b:r})}}),Ns=he({sqrt_:function nse(n){const e={x:ee(n,"x","sqrt","float32")};return fe.runKernel(Nm,e)}}),zn=he({square_:function rse(n){const t=ee(n,"x","square");return fe.runKernel("Square",{x:t},{})}}),mn=he({zerosLike_:function sse(n){const e={x:ee(n,"x","zerosLike")};return fe.runKernel(uv,e)}});function dl(n){return fe.customGrad(n)}function Rt(n,t){if((bo(n)&&"string"!==t||Array.isArray(n))&&"complex64"!==t)throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if("string"===t&&bo(n)&&!(n instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return ou(n,[],[],t)}class _h{getClassName(){return this.constructor.className}static fromConfig(t,e){return new t(e)}}class _o{constructor(){this.classNameMap={}}static getMap(){return null==_o.instance&&(_o.instance=new _o),_o.instance}static register(t){_o.getMap().classNameMap[t.className]=[t,t.fromConfig]}}function Qe(n){J(null!=n.className,()=>"Class being registered does not have the static className property defined."),J("string"==typeof n.className,()=>"className is required to be a string, but got type "+typeof n.className),J(n.className.length>0,()=>"Class being registered has an empty-string as its className, which is disallowed."),_o.register(n)}class lu extends _h{minimize(t,e=!1,r){const{value:s,grads:i}=this.computeGradients(t,r);if(null!=r){const o=r.map(a=>({name:a.name,tensor:i[a.name]}));this.applyGradients(o)}else this.applyGradients(i);return on(i),e?s:(s.dispose(),null)}get iterations(){return null==this.iterations_&&(this.iterations_=0),this.iterations_}incrementIterations(){this.iterations_=this.iterations+1}computeGradients(t,e){return function ise(n,t){J(q1(n),()=>"The f passed in variableGrads(f) must be a function"),J(null==t||Array.isArray(t)&&t.every(c=>c instanceof gv),()=>"The varList passed in variableGrads(f, varList) must be an array of variables");const e=null!=t;if(!e){t=[];for(const c in fe.registeredVariables)t.push(fe.registeredVariables[c])}const r=e?t.filter(c=>!c.trainable):null,s=t.length;J((t=t.filter(c=>c.trainable)).length>0,()=>`variableGrads() expects at least one of the input variables to be trainable, but none of the ${s} variables is trainable.`);const{value:o,grads:a}=fe.gradients(n,t,null,!0);J(a.some(c=>null!=c),()=>"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize()."),J(0===o.rank,()=>`The f passed in variableGrads(f) must return a scalar, but it returned a rank-${o.rank} tensor`);const u={};return t.forEach((c,p)=>{null!=a[p]&&(u[c.name]=a[p])}),r?.forEach(c=>u[c.name]=null),{value:o,grads:u}}(t,e)}dispose(){null!=this.iterations_&&on(this.iterations_)}saveIterations(){var t=this;return Ve(function*(){return null==t.iterations_&&(t.iterations_=0),{name:"iter",tensor:Rt(t.iterations_,"int32")}})()}getWeights(){return Ve(function*(){throw new Error("getWeights() is not implemented for this optimizer yet.")})()}setWeights(t){var e=this;return Ve(function*(){throw new Error(`setWeights() is not implemented for this optimizer class ${e.getClassName()}`)})()}extractIterations(t){var e=this;return Ve(function*(){return e.iterations_=(yield t[0].tensor.data())[0],t.slice(1)})()}}Object.defineProperty(lu,Symbol.hasInstance,{value:n=>null!=n.minimize&&null!=n.computeGradients&&null!=n.applyGradients});class _3 extends lu{static get className(){return"Adadelta"}constructor(t,e,r=null){super(),this.learningRate=t,this.rho=e,this.epsilon=r,this.accumulatedGrads=[],this.accumulatedUpdates=[],null==r&&(this.epsilon=fe.backend.epsilon())}applyGradients(t){(Array.isArray(t)?t.map(r=>r.name):Object.keys(t)).forEach((r,s)=>{const i=fe.registeredVariables[r];null==this.accumulatedGrads[s]&&(this.accumulatedGrads[s]={originalName:`${r}/accum_grad`,variable:Ce(()=>mn(i).variable(!1))}),null==this.accumulatedUpdates[s]&&(this.accumulatedUpdates[s]={originalName:`${r}/accum_var`,variable:Ce(()=>mn(i).variable(!1))});const a=Array.isArray(t)?t[s].tensor:t[r];if(null==a)return;const u=this.accumulatedGrads[s].variable,c=this.accumulatedUpdates[s].variable;Ce(()=>{const p=Ze(me(u,this.rho),me(zn(a),1-this.rho)),m=me(At(Ns(Ze(c,this.epsilon)),Ns(Ze(u,this.epsilon))),a),y=Ze(me(c,this.rho),me(zn(m),1-this.rho));u.assign(p),c.assign(y);const _=Ze(me(m,-this.learningRate),i);i.assign(_)})}),this.incrementIterations()}dispose(){null!=this.accumulatedUpdates&&(on(this.accumulatedGrads.map(t=>t.variable)),on(this.accumulatedUpdates.map(t=>t.variable)))}getWeights(){var t=this;return Ve(function*(){const e=[...t.accumulatedGrads,...t.accumulatedUpdates];return[yield t.saveIterations()].concat(e.map(r=>({name:r.originalName,tensor:r.variable})))})()}setWeights(t){var e=this;return Ve(function*(){const r=(t=yield e.extractIterations(t)).length/2;e.accumulatedGrads=t.slice(0,r).map(i=>({originalName:i.name,variable:i.tensor.variable(!1)})),e.accumulatedUpdates=t.slice(r,2*r).map(i=>({originalName:i.name,variable:i.tensor.variable(!1)}))})()}getConfig(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}}static fromConfig(t,e){return new t(e.learningRate,e.rho,e.epsilon)}}function vh(n,t,e){return zi(n),e=e||uh(t),fe.runKernel(wC,{},{shape:n,value:t,dtype:e})}class v3 extends lu{static get className(){return"Adagrad"}constructor(t,e=.1){super(),this.learningRate=t,this.initialAccumulatorValue=e,this.accumulatedGrads=[]}applyGradients(t){(Array.isArray(t)?t.map(r=>r.name):Object.keys(t)).forEach((r,s)=>{const i=fe.registeredVariables[r];null==this.accumulatedGrads[s]&&(this.accumulatedGrads[s]={originalName:`${r}/accumulator`,variable:Ce(()=>vh(i.shape,this.initialAccumulatorValue).variable(!1))});const o=Array.isArray(t)?t[s].tensor:t[r];if(null==o)return;const a=this.accumulatedGrads[s].variable;Ce(()=>{const u=Ze(a,zn(o));a.assign(u);const c=Ze(me(At(o,Ns(Ze(u,fe.backend.epsilon()))),-this.learningRate),i);i.assign(c)})}),this.incrementIterations()}dispose(){null!=this.accumulatedGrads&&on(this.accumulatedGrads.map(t=>t.variable))}getWeights(){var t=this;return Ve(function*(){return[yield t.saveIterations()].concat(t.accumulatedGrads.map(e=>({name:e.originalName,tensor:e.variable})))})()}setWeights(t){var e=this;return Ve(function*(){t=yield e.extractIterations(t),e.accumulatedGrads=t.map(s=>({originalName:s.name,variable:s.tensor.variable(!1)}))})()}getConfig(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}}static fromConfig(t,e){return new t(e.learningRate,e.initialAccumulatorValue)}}const uu=he({pow_:function ose(n,t){let e=ee(n,"base","pow"),r=ee(t,"exp","pow");return[e,r]=vr(e,r),fe.runKernel(_m,{a:e,b:r})}}),vt=he({sub_:function ase(n,t){let e=ee(n,"a","sub"),r=ee(t,"b","sub");return[e,r]=vr(e,r),fe.runKernel(Rm,{a:e,b:r})}});class w3 extends lu{static get className(){return"Adam"}constructor(t,e,r,s=null){super(),this.learningRate=t,this.beta1=e,this.beta2=r,this.epsilon=s,this.accumulatedFirstMoment=[],this.accumulatedSecondMoment=[],Ce(()=>{this.accBeta1=Rt(e).variable(),this.accBeta2=Rt(r).variable()}),null==s&&(this.epsilon=fe.backend.epsilon())}applyGradients(t){const e=Array.isArray(t)?t.map(r=>r.name):Object.keys(t);Ce(()=>{const r=vt(1,this.accBeta1),s=vt(1,this.accBeta2);e.forEach((i,o)=>{const a=fe.registeredVariables[i];null==this.accumulatedFirstMoment[o]&&(this.accumulatedFirstMoment[o]={originalName:`${i}/m`,variable:Ce(()=>mn(a).variable(!1))}),null==this.accumulatedSecondMoment[o]&&(this.accumulatedSecondMoment[o]={originalName:`${i}/v`,variable:Ce(()=>mn(a).variable(!1))});const c=Array.isArray(t)?t[o].tensor:t[i];if(null==c)return;const p=this.accumulatedFirstMoment[o].variable,m=this.accumulatedSecondMoment[o].variable,y=Ze(me(p,this.beta1),me(c,1-this.beta1)),_=Ze(me(m,this.beta2),me(zn(c),1-this.beta2)),w=At(y,r),T=At(_,s);p.assign(y),m.assign(_);const I=Ze(me(At(w,Ze(Ns(T),this.epsilon)),-this.learningRate),a);a.assign(I)}),this.accBeta1.assign(me(this.accBeta1,this.beta1)),this.accBeta2.assign(me(this.accBeta2,this.beta2))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.accBeta2.dispose(),null!=this.accumulatedFirstMoment&&on(this.accumulatedFirstMoment.map(t=>t.variable)),null!=this.accumulatedSecondMoment&&on(this.accumulatedSecondMoment.map(t=>t.variable))}getWeights(){var t=this;return Ve(function*(){const e=[...t.accumulatedFirstMoment,...t.accumulatedSecondMoment];return[yield t.saveIterations()].concat(e.map(r=>({name:r.originalName,tensor:r.variable})))})()}setWeights(t){var e=this;return Ve(function*(){t=yield e.extractIterations(t),Ce(()=>{e.accBeta1.assign(uu(e.beta1,e.iterations_+1)),e.accBeta2.assign(uu(e.beta2,e.iterations_+1))});const r=t.length/2;e.accumulatedFirstMoment=t.slice(0,r).map(i=>({originalName:i.name,variable:i.tensor.variable(!1)})),e.accumulatedSecondMoment=t.slice(r,2*r).map(i=>({originalName:i.name,variable:i.tensor.variable(!1)}))})()}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}}static fromConfig(t,e){return new t(e.learningRate,e.beta1,e.beta2,e.epsilon)}}const Kr=he({abs_:function lse(n){const t=ee(n,"x","abs");return fe.runKernel("complex64"===t.dtype?g_:l_,{x:t})}});function wh(n,t){const e=n.length,r=[];for(let s=0;s<e;s++){const i=e-1-s;(t[t.length-1-s]||1)>1&&1===(n[i]||1)&&r.unshift(i)}return r}function Xr(n,t){const e=[];for(let r=0;r<t.length;r++){const s=n[n.length-r-1],i=t.length-r-1;(null==s||1===s&&t[i]>1)&&e.unshift(i)}return e}function Ht(n,t){const e=Math.max(n.length,t.length),r=new Array(e);for(let s=0;s<e;s++){let i=n[n.length-s-1];null==i&&(i=1);let o=t[t.length-s-1];if(null==o&&(o=1),1===i)r[e-s-1]=o;else if(1===o)r[e-s-1]=i;else{if(i!==o)throw Error(`Operands could not be broadcast together with shapes ${n} and ${t}.`);r[e-s-1]=i}}return r}const hl=he({maximum_:function use(n,t){let e=ee(n,"a","maximum"),r=ee(t,"b","maximum");return[e,r]=vr(e,r),"bool"===e.dtype&&(e=pt(e,"int32"),r=pt(r,"int32")),Ht(e.shape,r.shape),fe.runKernel(mm,{a:e,b:r})}});class x3 extends lu{static get className(){return"Adamax"}constructor(t,e,r,s=null,i=0){super(),this.learningRate=t,this.beta1=e,this.beta2=r,this.epsilon=s,this.decay=i,this.accumulatedFirstMoment=[],this.accumulatedWeightedInfNorm=[],Ce(()=>{this.iteration=Rt(0).variable(),this.accBeta1=Rt(e).variable()}),null==s&&(this.epsilon=fe.backend.epsilon())}applyGradients(t){const e=Array.isArray(t)?t.map(r=>r.name):Object.keys(t);Ce(()=>{const r=vt(1,this.accBeta1),s=At(-this.learningRate,Ze(me(this.iteration,this.decay),1));e.forEach((i,o)=>{const a=fe.registeredVariables[i];null==this.accumulatedFirstMoment[o]&&(this.accumulatedFirstMoment[o]={originalName:`${i}/m`,variable:mn(a).variable(!1)}),null==this.accumulatedWeightedInfNorm[o]&&(this.accumulatedWeightedInfNorm[o]={originalName:`${i}/v`,variable:mn(a).variable(!1)});const c=Array.isArray(t)?t[o].tensor:t[i];if(null==c)return;const p=this.accumulatedFirstMoment[o].variable,m=this.accumulatedWeightedInfNorm[o].variable,y=Ze(me(p,this.beta1),me(c,1-this.beta1)),_=me(m,this.beta2),w=Kr(c),T=hl(_,w);p.assign(y),m.assign(T);const I=Ze(me(At(s,r),At(y,Ze(T,this.epsilon))),a);a.assign(I)}),this.iteration.assign(Ze(this.iteration,1)),this.accBeta1.assign(me(this.accBeta1,this.beta1))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.iteration.dispose(),null!=this.accumulatedFirstMoment&&on(this.accumulatedFirstMoment.map(t=>t.variable)),null!=this.accumulatedWeightedInfNorm&&on(this.accumulatedWeightedInfNorm.map(t=>t.variable))}getWeights(){return Ve(function*(){throw new Error("getWeights() is not implemented for Adamax yet.")})()}setWeights(t){return Ve(function*(){throw new Error("setWeights() is not implemented for Adamax yet.")})()}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}}static fromConfig(t,e){return new t(e.learningRate,e.beta1,e.beta2,e.epsilon,e.decay)}}class kI extends lu{static get className(){return"SGD"}constructor(t){super(),this.learningRate=t,this.setLearningRate(t)}applyGradients(t){(Array.isArray(t)?t.map(r=>r.name):Object.keys(t)).forEach((r,s)=>{const i=Array.isArray(t)?t[s].tensor:t[r];if(null==i)return;const o=fe.registeredVariables[r];Ce(()=>{const a=Ze(me(this.c,i),o);o.assign(a)})}),this.incrementIterations()}setLearningRate(t){this.learningRate=t,null!=this.c&&this.c.dispose(),this.c=as(Rt(-t))}dispose(){this.c.dispose()}getWeights(){var t=this;return Ve(function*(){return[yield t.saveIterations()]})()}setWeights(t){var e=this;return Ve(function*(){if(0!==(t=yield e.extractIterations(t)).length)throw new Error("SGD optimizer does not have settable weights.")})()}getConfig(){return{learningRate:this.learningRate}}static fromConfig(t,e){return new t(e.learningRate)}}class T3 extends kI{static get className(){return"Momentum"}constructor(t,e,r=!1){super(t),this.learningRate=t,this.momentum=e,this.useNesterov=r,this.accumulations=[],this.m=Rt(this.momentum)}applyGradients(t){(Array.isArray(t)?t.map(r=>r.name):Object.keys(t)).forEach((r,s)=>{const i=fe.registeredVariables[r];null==this.accumulations[s]&&(this.accumulations[s]={originalName:`${r}/momentum`,variable:Ce(()=>mn(i).variable(!1))});const o=this.accumulations[s].variable,a=Array.isArray(t)?t[s].tensor:t[r];null!=a&&Ce(()=>{let u;const c=Ze(me(this.m,o),a);u=Ze(me(this.c,this.useNesterov?Ze(a,me(c,this.m)):c),i),o.assign(c),i.assign(u)})}),this.incrementIterations()}dispose(){this.m.dispose(),null!=this.accumulations&&on(this.accumulations.map(t=>t.variable))}setMomentum(t){this.momentum=t}getWeights(){var t=this;return Ve(function*(){return[yield t.saveIterations()].concat(t.accumulations.map(e=>({name:e.originalName,tensor:e.variable})))})()}setWeights(t){var e=this;return Ve(function*(){t=yield e.extractIterations(t),e.accumulations=t.map(s=>({originalName:s.name,variable:s.tensor.variable(!1)}))})()}getConfig(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}}static fromConfig(t,e){return new t(e.learningRate,e.momentum,e.useNesterov)}}class S3 extends lu{static get className(){return"RMSProp"}constructor(t,e=.9,r=0,s=null,i=!1){if(super(),this.learningRate=t,this.decay=e,this.momentum=r,this.epsilon=s,this.accumulatedMeanSquares=[],this.accumulatedMoments=[],this.accumulatedMeanGrads=[],this.centered=i,null==s&&(this.epsilon=fe.backend.epsilon()),null==t)throw new Error("learningRate for RMSPropOptimizer must be defined.")}applyGradients(t){(Array.isArray(t)?t.map(r=>r.name):Object.keys(t)).forEach((r,s)=>{const i=fe.registeredVariables[r],o=!1;null==this.accumulatedMeanSquares[s]&&(this.accumulatedMeanSquares[s]={originalName:`${r}/rms`,variable:Ce(()=>mn(i).variable(o))}),null==this.accumulatedMoments[s]&&(this.accumulatedMoments[s]={originalName:`${r}/momentum`,variable:Ce(()=>mn(i).variable(o))}),null==this.accumulatedMeanGrads[s]&&this.centered&&(this.accumulatedMeanGrads[s]={originalName:`${r}/mg`,variable:Ce(()=>mn(i).variable(o))});const a=Array.isArray(t)?t[s].tensor:t[r];if(null==a)return;const u=this.accumulatedMeanSquares[s].variable,c=this.accumulatedMoments[s].variable;Ce(()=>{const p=Ze(me(u,this.decay),me(zn(a),1-this.decay));if(this.centered){const m=this.accumulatedMeanGrads[s].variable,y=Ze(me(m,this.decay),me(a,1-this.decay)),_=At(me(a,this.learningRate),Ns(vt(p,Ze(zn(y),this.epsilon)))),w=Ze(me(c,this.momentum),_);u.assign(p),m.assign(y),c.assign(w);const T=vt(i,w);i.assign(T)}else{const m=Ze(me(u,this.decay),me(zn(a),1-this.decay)),y=Ze(me(c,this.momentum),At(me(a,this.learningRate),Ns(Ze(m,this.epsilon))));u.assign(m),c.assign(y);const _=vt(i,y);i.assign(_)}})}),this.incrementIterations()}dispose(){null!=this.accumulatedMeanSquares&&on(this.accumulatedMeanSquares.map(t=>t.variable)),null!=this.accumulatedMeanGrads&&this.centered&&on(this.accumulatedMeanGrads.map(t=>t.variable)),null!=this.accumulatedMoments&&on(this.accumulatedMoments.map(t=>t.variable))}getWeights(){var t=this;return Ve(function*(){const e=[...t.accumulatedMeanSquares,...t.accumulatedMoments];return t.centered&&e.push(...t.accumulatedMeanGrads),[yield t.saveIterations()].concat(e.map(r=>({name:r.originalName,tensor:r.variable})))})()}setWeights(t){var e=this;return Ve(function*(){t=yield e.extractIterations(t);const r=e.centered?t.length/3:t.length/2,s=!1;e.accumulatedMeanSquares=t.slice(0,r).map(i=>({originalName:i.name,variable:i.tensor.variable(s)})),e.accumulatedMoments=t.slice(r,2*r).map(i=>({originalName:i.name,variable:i.tensor.variable(s)})),e.centered&&(e.accumulatedMeanGrads=t.slice(2*r,3*r).map(i=>({originalName:i.name,variable:i.tensor.variable(s)})))})()}getConfig(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}}static fromConfig(t,e){return new t(e.learningRate,e.decay,e.momentum,e.epsilon,e.centered)}}const cse=[_3,v3,w3,x3,T3,S3,kI];function C3(n){return new Promise(t=>setTimeout(t)).then(n)}let NI=(()=>{class n{constructor(e){if(!De().getBool("IS_BROWSER"))throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");e.startsWith(n.URL_SCHEME)&&(e=e.slice(n.URL_SCHEME.length)),(null==e||0===e.length)&&(e="model"),this.modelJsonFileName=e+".json",this.weightDataFileName=e+".weights.bin"}save(e){var r=this;return Ve(function*(){if(typeof document>"u")throw new Error("Browser downloads are not supported in this environment since `document` is not present");const s=window.URL.createObjectURL(new Blob([e.weightData],{type:"application/octet-stream"}));if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");{const o=o3(e,[{paths:["./"+r.weightDataFileName],weights:e.weightSpecs}]),a=window.URL.createObjectURL(new Blob([JSON.stringify(o)],{type:"application/json"})),u=null==r.modelJsonAnchor?document.createElement("a"):r.modelJsonAnchor;if(u.download=r.modelJsonFileName,u.href=a,yield C3(()=>u.dispatchEvent(new MouseEvent("click"))),null!=e.weightData){const c=null==r.weightDataAnchor?document.createElement("a"):r.weightDataAnchor;c.download=r.weightDataFileName,c.href=s,yield C3(()=>c.dispatchEvent(new MouseEvent("click")))}return{modelArtifactsInfo:Um(e)}}})()}}return n.URL_SCHEME="downloads://",n})();class mse{constructor(t){if(null==t||t.length<1)throw new Error(`When calling browserFiles, at least 1 file is required, but received ${t}`);this.jsonFile=t[0],this.weightsFiles=t.slice(1)}load(){var t=this;return Ve(function*(){return new Promise((e,r)=>{const s=new FileReader;s.onload=i=>{const o=JSON.parse(i.target.result),a=o.modelTopology;if(null==a)return void r(new Error(`modelTopology field is missing from file ${t.jsonFile.name}`));if(null==o.weightsManifest)return void r(new Error(`weightManifest field is missing from file ${t.jsonFile.name}`));if(0===t.weightsFiles.length)return void e({modelTopology:a});const c=yI(o,p=>t.loadWeights(p));e(c)},s.onerror=i=>r(`Failed to read model topology and weights manifest JSON from file '${t.jsonFile.name}'. BrowserFiles supports loading Keras-style tf.Model artifacts only.`),s.readAsText(t.jsonFile)})})()}loadWeights(t){const e=[],r=[];for(const o of t)e.push(...o.weights),r.push(...o.paths);const s=this.checkManifestAndWeightFiles(t),i=r.map(o=>this.loadWeightsFile(o,s[o]));return Promise.all(i).then(o=>[e,_v(o)])}loadWeightsFile(t,e){return new Promise((r,s)=>{const i=new FileReader;i.onload=o=>{r(o.target.result)},i.onerror=o=>s(`Failed to weights data from file of path '${t}'.`),i.readAsArrayBuffer(e)})}checkManifestAndWeightFiles(t){const e=[],r=this.weightsFiles.map(i=>s3(i.name)),s={};for(const i of t)i.paths.forEach(o=>{const a=s3(o);if(-1!==e.indexOf(a))throw new Error(`Duplicate file basename found in weights manifest: '${a}'`);if(e.push(a),-1===r.indexOf(a))throw new Error(`Weight file with basename '${a}' is not provided.`);s[o]=this.weightsFiles[r.indexOf(a)]});if(e.length!==this.weightsFiles.length)throw new Error(`Mismatch in the number of files in weights manifest (${e.length}) and the number of weight files provided (${this.weightsFiles.length}).`);return s}}function bse(n){return new mse(n)}lr.registerSaveRouter(n=>De().getBool("IS_BROWSER")&&!Array.isArray(n)&&n.startsWith(NI.URL_SCHEME)?function yse(n="model"){return new NI(n)}(n.slice(NI.URL_SCHEME.length)):null);class _se{constructor(t){if(this.shards=[],this.previousShardIndex=0,t instanceof Array||(t=[t]),0===(t=t.map(r=>bo(r)?r.buffer:r)).length)return;this.bufferUniformSize=t[0].byteLength;let e=0;for(let r=0;r<t.length;r++){const s=t[r];r!==t.length-1&&s.byteLength!==this.bufferUniformSize&&(this.bufferUniformSize=void 0);const i=e+s.byteLength;this.shards.push({buffer:s,start:e,end:i}),e=i}0===this.shards.length&&(this.byteLength=0),this.byteLength=this.shards[this.shards.length-1].end}slice(t=0,e=this.byteLength){if(t=isNaN(Number(t))?0:t,e=isNaN(Number(e))?0:e,t=Math.max(0,t),(e=Math.min(this.byteLength,e))<=t)return new ArrayBuffer(0);const r=this.findShardForByte(t);if(-1===r)throw new Error(`Could not find start shard for byte ${t}`);const i=new ArrayBuffer(e-t),o=new Uint8Array(i);let a=0;for(let u=r;u<this.shards.length;u++){const c=this.shards[u],m=t+a-c.start,y=a,w=Math.min(e,c.end)-c.start,T=new Uint8Array(c.buffer.slice(m,w));if(o.set(T,y),a+=T.length,e<c.end)break}return i}findShardForByte(t){if(0===this.shards.length||t<0||t>=this.byteLength)return-1;if(null!=this.bufferUniformSize)return this.previousShardIndex=Math.floor(t/this.bufferUniformSize),this.previousShardIndex;function e(s){return t<s.start?-1:t>=s.end?1:0}if(0===e(this.shards[this.previousShardIndex]))return this.previousShardIndex;const r=function vse(n,t){let e=0,r=n.length;for(;e<=r;){const s=Math.floor((r-e)/2)+e,i=t(n[s]);if(0===i)return s;i<0?r=s:e=s+1}return-1}(this.shards,e);return-1===r?-1:(this.previousShardIndex=r,this.previousShardIndex)}}function I3(n,t,e,r){(function o(u){J(null!=u&&Array.isArray(u)&&u.length>0,()=>"promises must be a none empty array")})(n),function a(u,c){J(u>=0&&u<=1,()=>`Progress fraction must be in range [0, 1], but got startFraction ${u}`),J(c>=0&&c<=1,()=>`Progress fraction must be in range [0, 1], but got endFraction ${c}`),J(c>=u,()=>`startFraction must be no more than endFraction, but got startFraction ${u} and endFraction ${c}`)}(e=e??0,r=r??1);let s=0;return Promise.all(n.map(u=>(u.then(c=>{const p=e+ ++s/n.length*(r-e);return t(p),c}),u)))}function E3(n,t){return OI.apply(this,arguments)}function OI(){return(OI=Ve(function*(n,t){null==t&&(t={});const e=null==t.fetchFunc?De().platform.fetch:t.fetchFunc,r=n.map(m=>e(m,t.requestInit,{isBinary:!0})),a=(null==t.onProgress?yield Promise.all(r):yield I3(r,t.onProgress,0,.5)).map(m=>m.arrayBuffer());return null==t.onProgress?yield Promise.all(a):yield I3(a,t.onProgress,.5,1)})).apply(this,arguments)}function wse(n){return RI.apply(this,arguments)}function RI(){return(RI=Ve(function*(n,t="",e,r){return D3(o=>E3(o,{requestInit:r}))(n,t,e)})).apply(this,arguments)}function D3(n){return function(){var t=Ve(function*(e,r="",s){const i=e.map(()=>!1),o={},a=null!=s?s.map(()=>!1):[],u=[];if(e.forEach((w,T)=>{let I=0;w.weights.forEach(O=>{const V=pI["quantization"in O?O.quantization.dtype:O.dtype]*Fe(O.shape),z=()=>{i[T]=!0,null==o[T]&&(o[T]=[]),o[T].push({manifestEntry:O,groupOffset:I,sizeBytes:V})};null!=s?s.forEach((G,Q)=>{G===O.name&&(z(),a[Q]=!0)}):z(),u.push(O.name),I+=V})}),!a.every(w=>w)){const w=s.filter((T,I)=>!a[I]);throw new Error(`Could not find weights in manifest with names: ${w.join(", ")}. \nManifest JSON has weights with names: ${u.join(", ")}.`)}const c=i.reduce((w,T,I)=>(T&&w.push(I),w),[]),p=[];c.forEach(w=>{e[w].paths.forEach(T=>{const I=r+(r.endsWith("/")?"":"/")+T;p.push(I)})});const m=yield n(p),y={};let _=0;return c.forEach(w=>{const T=e[w].paths.length,I=new _se(m.slice(_,_+T));o[w].forEach(M=>{const z=n3(I.slice(M.groupOffset,M.groupOffset+M.sizeBytes),[M.manifestEntry]);for(const G in z)y[G]=z[G]}),_+=T}),y});return function(e){return t.apply(this,arguments)}}()}let A3=(()=>{class n{constructor(e,r){if(this.DEFAULT_METHOD="POST",null==r&&(r={}),this.weightPathPrefix=r.weightPathPrefix,this.onProgress=r.onProgress,this.weightUrlConverter=r.weightUrlConverter,null!=r.fetchFunc?(J("function"==typeof r.fetchFunc,()=>"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)"),this.fetch=r.fetchFunc):this.fetch=De().platform.fetch,J(null!=e&&e.length>0,()=>"URL path for http must not be null, undefined or empty."),Array.isArray(e)&&J(2===e.length,()=>`URL paths for http must have a length of 2, (actual length is ${e.length}).`),this.path=e,null!=r.requestInit&&null!=r.requestInit.body)throw new Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=r.requestInit||{}}save(e){var r=this;return Ve(function*(){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");const s=Object.assign({method:r.DEFAULT_METHOD},r.requestInit);s.body=new FormData;const o=o3(e,[{paths:["./model.weights.bin"],weights:e.weightSpecs}]);s.body.append("model.json",new Blob([JSON.stringify(o)],{type:"application/json"}),"model.json"),null!=e.weightData&&s.body.append("model.weights.bin",new Blob([e.weightData],{type:"application/octet-stream"}),"model.weights.bin");const a=yield r.fetch(r.path,s);if(a.ok)return{modelArtifactsInfo:Um(e),responses:[a]};throw new Error(`BrowserHTTPRequest.save() failed due to HTTP response status ${a.status}.`)})()}load(){var e=this;return Ve(function*(){const r=yield e.fetch(e.path,e.requestInit);if(!r.ok)throw new Error(`Request to ${e.path} failed with status code ${r.status}. Please verify this URL points to the model JSON of the model to load.`);let s;try{s=yield r.json()}catch{let u=`Failed to parse model JSON of response from ${e.path}.`;throw e.path.endsWith(".pb")?u+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":u+=" Please make sure the server is serving valid JSON for this request.",new Error(u)}if(null==s.modelTopology&&null==s.weightsManifest)throw new Error(`The JSON from HTTP path ${e.path} contains neither model topology or manifest for weights.`);return yI(s,a=>e.loadWeights(a))})()}loadWeights(e){var r=this;return Ve(function*(){const s=Array.isArray(r.path)?r.path[1]:r.path,[i,o]=function Sse(n){const t=n.lastIndexOf("/"),e=n.lastIndexOf("?");return[n.substring(0,t)+"/",e>t?n.substring(e):""]}(s),a=r.weightPathPrefix||i,u=l3(e),c=[],p=[];for(const y of e)for(const _ of y.paths)null!=r.weightUrlConverter?p.push(r.weightUrlConverter(_)):c.push(a+_+o);return r.weightUrlConverter&&c.push(...yield Promise.all(p)),[u,_v(yield E3(c,{requestInit:r.requestInit,fetchFunc:r.fetch,onProgress:r.onProgress}))]})()}}return n.URL_SCHEME_REGEX=/^https?:\/\//,n})();function MI(n){return null!=n.match(A3.URL_SCHEME_REGEX)}const k3=(n,t)=>{if(typeof fetch>"u"&&(null==t||null==t.fetchFunc))return null;{let e=!0;if(e=Array.isArray(n)?n.every(r=>MI(r)):MI(n),e)return PI(n,t)}return null};function PI(n,t){return new A3(n,t)}function Cse(n,t){return PI(n,t)}lr.registerSaveRouter(k3),lr.registerLoadRouter(k3);class FI{constructor(t){this.modelArtifacts=t}load(){return this.modelArtifacts}}class N3{constructor(t){this.saveHandler=t}save(t){return this.saveHandler(t)}}class Ise{constructor(t){t.load&&(this.load=()=>Promise.resolve(t.load())),t.save&&(this.save=e=>Promise.resolve(t.save(e)))}}function Ese(n,t,e,r){return new Ise(O3(...arguments))}function O3(n,t,e,r){return 1===arguments.length?null!=n.modelTopology||null!=n.weightSpecs?new FI(n):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new FI({modelTopology:n})):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new FI({modelTopology:n,weightSpecs:t,weightData:e,trainingConfig:r}))}function Dse(n){return new N3(n)}function Ase(n){return new N3(n)}const $I=-2,kse=-1;function LI(n,t,e){const r=n.shape.length;J(r===t.length,()=>`Error in slice${r}D: Length of begin ${t} must match the rank of the array (${r}).`),J(r===e.length,()=>`Error in slice${r}D: Length of size ${e} must match the rank of the array (${r}).`);for(let s=0;s<r;++s)J(t[s]+e[s]<=n.shape[s],()=>`Error in slice${r}D: begin[${s}] + size[${s}] (${t[s]+e[s]}) would overflow input.shape[${s}] (${n.shape[s]})`)}function Nse(n){const t=[];let e=0;for(;n>0;)1&n&&t.push(e),n/=2,e++;return t}function VI(n,t,e){const r=[];for(let s=0;s<n.length;s++)r[s]=Math.ceil((t[s]-n[s])/e[s]);return r}function R3(n,t,e,r){const s=[...n];for(let i=s.length;i<r.length;i++)s.push(1);for(let i=0;i<e;i++)0===i?s[t]=1:(s.splice(t,0,1),s.pop());return s}function M3(n,t,e){return e<=n?e:e-(t-1)}function P3(n,t){const e=[];for(let r=0;r<n;r++)e.push(t+r);return e}function Ose(n,t,e,r,s,i,o,a,u){const c=n.length;let p=new Array(c),m=new Array(c),y=new Array(c);if(t.length&&e>0){const _=t[0],w=e+1;p=F3(o,_,w,r,n),m=$3(a,_,w,s,n),y=R3(i,_,w,n)}else for(let _=0;_<c;_++)p[_]=V3(o,r,i,n,_,u),m[_]=B3(a,s,i,n,_,u),y[_]=L3(i,_,u);return{begin:p,end:m,strides:y}}function F3(n,t,e,r,s){const i=[...s],o=P3(e,t);for(let a=0;a<i.length;a++)if(o.indexOf(a)>-1)i[a]=0;else{const u=M3(t,e,a);let c=r[u];n&1<<u&&(c=0),i[a]=c}return i}function $3(n,t,e,r,s){const i=[...s],o=P3(e,t);for(let a=0;a<i.length;a++)if(o.indexOf(a)>-1)i[a]=Number.MAX_SAFE_INTEGER;else{const u=M3(t,e,a);let c=r[u];n&1<<u&&(c=Number.MAX_SAFE_INTEGER),i[a]=c}for(let a=0;a<i.length;a++)i[a]<0&&(i[a]+=s[a]),i[a]=fc(0,i[a],s[a]);return i}function L3(n,t,e){let r=n[t];return(e&1<<t||null==r)&&(r=1),r}function V3(n,t,e,r,s,i){let o=t[s];(n&1<<s||i&1<<s||null==o)&&(o=(e[s]||1)>0?Number.MIN_SAFE_INTEGER:Number.MAX_SAFE_INTEGER);const u=r[s];return o<0&&(o+=u),o=fc(0,o,u-1),o}function B3(n,t,e,r,s,i){let o=t[s];const a=e[s]||1;(n&1<<s||i&1<<s||null==o)&&(o=a>0?Number.MAX_SAFE_INTEGER:Number.MIN_SAFE_INTEGER);const u=r[s];return o<0&&(o+=u),o=a>0?fc(0,o,u):fc(-1,o,u-1),o}function BI(n,t,e){let r=e.length;for(let s=0;s<e.length;s++)if(e[s]>1){r=s;break}for(let s=r+1;s<e.length;s++)if(t[s]>0||e[s]!==n[s])return!1;return!0}function zI(n,t){let e=n.length>0?n[n.length-1]:1;for(let r=0;r<n.length-1;r++)e+=n[r]*t[r];return e}function Tv(n,t,e){let r;const s=n.shape.length;let i;return r="number"==typeof t?[t,...new Array(s-1).fill(0)]:t.length<s?t.concat(new Array(s-t.length).fill(0)):t.slice(),r.forEach(o=>{J(-1!==o,()=>"slice() does not support negative begin indexing.")}),i=null==e?new Array(s).fill(-1):"number"==typeof e?[e,...new Array(s-1).fill(-1)]:e.length<s?e.concat(new Array(s-e.length).fill(-1)):e,i=i.map((o,a)=>o>=0?o:(J(-1===o,()=>`Negative size values should be exactly -1 but got ${o} for the slice() size at index ${a}.`),n.shape[a]-r[a])),[r,i]}function UI(n,t,e,r,s,i,o,a,u){let c;if(null==r?(c=new Array(t.length),c.fill(1)):c=r,null!=o&&o&o-1)throw new Error("Multiple ellipses in slice is not allowed.");let p=!1;const m={dims:c.length,numAddAxisAfterEllipsis:0,begin:t.slice(),end:e.slice(),strides:c.slice(),beginMask:s,endMask:i,ellipsisMask:o,newAxisMask:a,shrinkAxisMask:u};for(let V=0;V<m.dims;V++)p&&1<<V&a&&m.numAddAxisAfterEllipsis++,1<<V&o&&(p=!0);p||(m.ellipsisMask|=1<<m.dims,m.dims++);const y={dims:n.length,beginMask:0,endMask:0,beginValid:!1,endValid:!1};!function Rse(n,t){t.beginMask=0,t.endMask=0,t.shrinkAxisMask=0;let e=0;t.beginValid=null!=n.begin,t.endValid=null!=n.end,t.begin=new Array(t.dims),t.end=new Array(t.dims),t.strides=new Array(t.dims),t.finalShapeGatherIndices=[],t.finalShapeGatherIndicesSparse=[],t.inputShapeGatherIndicesSparse=new Array(t.dims);for(let r=0;r<n.dims;r++)if(1<<r&n.ellipsisMask){const s=Math.min(t.dims-(n.dims-r)+1+n.numAddAxisAfterEllipsis,t.dims);for(;e<s;e++)t.begin[e]=0,t.end[e]=0,t.strides[e]=1,t.beginMask|=1<<e,t.endMask|=1<<e,t.finalShapeGatherIndices.push(e),t.finalShapeGatherIndicesSparse.push(-1),t.inputShapeGatherIndicesSparse[e]=r}else if(1<<r&n.newAxisMask)t.finalShapeGatherIndices.push($I),t.finalShapeGatherIndicesSparse.push(-1);else{if(e===t.begin.length)throw Error(`Index out of range using input dim ${e}; input has only ${t.dims} dims, ${t.begin.length}.`);null!=n.begin&&(t.begin[e]=n.begin[r]),null!=n.end&&(t.end[e]=n.end[r]),t.strides[e]=n.strides[r],n.beginMask&1<<r&&(t.beginMask|=1<<e),n.endMask&1<<r&&(t.endMask|=1<<e),n.shrinkAxisMask&1<<r?(t.finalShapeGatherIndices.push(kse),t.finalShapeGatherIndicesSparse.push(-1),t.shrinkAxisMask|=1<<e):(t.finalShapeGatherIndices.push(e),t.finalShapeGatherIndicesSparse.push(r)),t.inputShapeGatherIndicesSparse[e]=r,e++}}(m,y);let _=!0,w=!0,T=!0;const I=[],O=[];for(let V=0;V<n.length;++V){if(0===y.strides[V])throw Error(`strides[${V}] must be non-zero`);const z=!!(y.shrinkAxisMask&1<<V),G=n[V];if(-1===G){I.push(z?1:-1);continue}const Q=[y.beginMask&1<<V,y.endMask&1<<V],ne=[y.strides[V]>0?0:-1,y.strides[V]>0?G:G-1];if(z&&y.strides[V]<=0)throw Error("only stride 1 allowed on non-range indexing.");T=T&&1===y.strides[V];const oe=!!(y.beginMask&1<<V&&y.endMask&1<<V);if(y.beginValid&&y.endValid){if(z){const Ae=y.begin[V]<0?G+y.begin[V]:y.begin[V];if(y.begin[V]=Ae,y.end[V]=y.begin[V]+1,Ae<0||Ae>=G)throw Error(`slice index ${y.begin[V]} of dimension ${V} out of bounds.`)}else y.begin[V]=z3(y.begin[V],0,y.strides[V],G,Q,ne),y.end[V]=z3(y.end[V],1,y.strides[V],G,Q,ne);const Te=1===y.strides[V]&&0===y.begin[V]&&y.end[V]===G;_=_&&Te,w=w&&(0===V&&1===y.strides[V]||Te)}else _=_&&1===y.strides[V]&&oe,w=w&&(0===V&&1===y.strides[V]||oe);let de,pe=!1;if(y.beginValid&&y.endValid?(de=y.end[V]-y.begin[V],pe=!0):z?(de=1,pe=!0):oe&&G>=0&&(de=y.strides[V]<0?-G:G,pe=!0),pe){let Te;Te=0===de||de<0!=y.strides[V]<0?0:Math.trunc(de/y.strides[V])+(de%y.strides[V]!=0?1:0),I.push(Te)}else I.push(-1)}for(let V=0;V<y.finalShapeGatherIndices.length;++V){const z=y.finalShapeGatherIndices[V];z>=0?O.push(I[z]):z===$I&&O.push(1)}return{finalShapeSparse:O.filter((V,z)=>y.finalShapeGatherIndices[z]!==$I),finalShape:O,isIdentity:_,sliceDim0:w,isSimpleSlice:T,begin:y.begin,end:y.end,strides:y.strides}}function z3(n,t,e,r,s,i){if(s[t])return e>0?i[t]:i[t+1&1];{const o=n<0?r+n:n;return o<i[0]?i[0]:o>i[1]?i[1]:o}}const U3=he({acos_:function Pse(n){const e={x:ee(n,"x","acos")};return fe.runKernel(jf,e)}}),j3=he({acosh_:function Fse(n){const e={x:ee(n,"x","acosh")};return fe.runKernel(Gf,e)}}),Lse=he({addN_:function $se(n){J(Array.isArray(n),()=>"The argument passed to tf.addN() must be a list of tensors"),J(n.length>=1,()=>`Must pass at least one tensor to tf.addN(), but got ${n.length}`);const t=n.map((s,i)=>ee(s,`tensors${i}`,"addN")),e=t[0];return t.forEach(s=>{if(s.dtype!==e.dtype)throw new Error("All tensors passed to tf.addN() must have the same dtype")}),t.forEach(s=>{if(!hn(s.shape,e.shape))throw new Error("All tensors passed to tf.addN() must have the same shape")}),fe.runKernel(u_,t)}}),jI=he({all_:function Vse(n,t=null,e=!1){const s={x:ee(n,"x","all","bool")};return fe.runKernel("All",s,{axis:t,keepDims:e})}}),Sv=he({any_:function Bse(n,t=null,e=!1){const s={x:ee(n,"x","any","bool")};return fe.runKernel("Any",s,{axis:t,keepDims:e})}}),xh=he({argMax_:function zse(n,t=0){const r={x:ee(n,"x","argMax")};return fe.runKernel(c_,r,{axis:t})}}),G3=he({argMin_:function Use(n,t=0){const r={x:ee(n,"x","argMin")};return fe.runKernel(d_,r,{axis:t})}}),W3=he({asin_:function jse(n){const e={x:ee(n,"x","asin")};return fe.runKernel(Wf,e)}}),H3=he({asinh_:function Gse(n){const e={x:ee(n,"x","asinh")};return fe.runKernel(Hf,e)}}),q3=he({atan_:function Wse(n){const e={x:ee(n,"x","atan")};return fe.runKernel(qf,e)}}),K3=he({atan2_:function Hse(n,t){let e=ee(n,"a","atan2"),r=ee(t,"b","atan2");return[e,r]=vr(e,r),fe.runKernel(Xf,{a:e,b:r})}}),X3=he({atanh_:function qse(n){const e={x:ee(n,"x","atanh")};return fe.runKernel(Kf,e)}});function jm(n,t,e,r,s="NHWC",i){return ls(n,[...t,n[3]],e,i,r,null,null,fl(s))}function vo(n,t,e,r,s,i,o="channelsLast"){const[a,u]=Gm(t);let c;if("channelsLast"===o)c=[a,u,n[3],n[3]];else{if("channelsFirst"!==o)throw new Error(`Unknown dataFormat ${o}`);c=[a,u,n[1],n[1]]}return ls(n,c,e,r,s,i,!1,o)}function pl(n,t,e,r,s,i,o="NDHWC"){const[a,u,c]=WI(t);let p,m;if("NDHWC"===o)m="channelsLast",p=[a,u,c,n[4],n[4]];else{if("NCDHW"!==o)throw new Error(`Unknown dataFormat ${o}`);m="channelsFirst",p=[a,u,c,n[1],n[1]]}return cu(n,p,e,r,s,!1,m,i)}function ls(n,t,e,r,s,i,o=!1,a="channelsLast"){let[u,c,p,m]=[-1,-1,-1,-1];if("channelsLast"===a)[u,c,p,m]=n;else{if("channelsFirst"!==a)throw new Error(`Unknown dataFormat ${a}`);[u,m,c,p]=n}const[y,_,,w]=t,[T,I]=Gm(e),[O,M]=Gm(r),V=Th(y,O),z=Th(_,M),{padInfo:G,outHeight:Q,outWidth:ne}=function Yse(n,t,e,r,s,i,o,a,u){let c,p,m;if("number"==typeof n){c={top:n,bottom:n,left:n,right:n,type:0===n?"VALID":"NUMBER"};const _=function Kse(n,t,e,r,s){null==r&&(r=GI(n,t,e));const o=n[1];return[Wm((n[0]-t+2*r)/e+1,s),Wm((o-t+2*r)/e+1,s)]}([t,e],i,r,n,a);p=_[0],m=_[1]}else if("same"===n){p=Math.ceil(t/r),m=Math.ceil(e/s);const y=Math.max(0,(p-1)*r+i-t),_=Math.max(0,(m-1)*s+o-e),w=Math.floor(y/2),T=y-w,I=Math.floor(_/2);c={top:w,bottom:T,left:I,right:_-I,type:"SAME"}}else if("valid"===n)c={top:0,bottom:0,left:0,right:0,type:"VALID"},p=Math.ceil((t-i+1)/r),m=Math.ceil((e-o+1)/s);else{if("object"!=typeof n)throw Error(`Unknown padding parameter: ${n}`);{const y="channelsLast"===u?n[1][0]:n[2][0],_="channelsLast"===u?n[1][1]:n[2][1],w="channelsLast"===u?n[2][0]:n[3][0],T="channelsLast"===u?n[2][1]:n[3][1];c={top:y,bottom:_,left:w,right:T,type:0===y&&0===_&&0===w&&0===T?"VALID":"EXPLICIT"},p=Wm((t-i+y+_)/r+1,a),m=Wm((e-o+w+T)/s+1,a)}}return{padInfo:c,outHeight:p,outWidth:m}}(s,c,p,T,I,V,z,i,a),oe=o?w*m:w;let de;return"channelsFirst"===a?de=[u,oe,Q,ne]:"channelsLast"===a&&(de=[u,Q,ne,oe]),{batchSize:u,dataFormat:a,inHeight:c,inWidth:p,inChannels:m,outHeight:Q,outWidth:ne,outChannels:oe,padInfo:G,strideHeight:T,strideWidth:I,filterHeight:y,filterWidth:_,effectiveFilterHeight:V,effectiveFilterWidth:z,dilationHeight:O,dilationWidth:M,inShape:n,outShape:de,filterShape:t}}function cu(n,t,e,r,s,i=!1,o="channelsLast",a){let[u,c,p,m,y]=[-1,-1,-1,-1,-1];if("channelsLast"===o)[u,c,p,m,y]=n;else{if("channelsFirst"!==o)throw new Error(`Unknown dataFormat ${o}`);[u,y,c,p,m]=n}const[_,w,T,,I]=t,[O,M,V]=WI(e),[z,G,Q]=WI(r),ne=Th(_,z),oe=Th(w,G),de=Th(T,Q),{padInfo:pe,outDepth:Te,outHeight:Ae,outWidth:Oe}=function Zse(n,t,e,r,s,i,o,a,u,c,p){let m,y,_,w;if("valid"===n&&(n=0),"number"==typeof n){m={top:n,bottom:n,left:n,right:n,front:n,back:n,type:0===n?"VALID":"NUMBER"};const I=function Xse(n,t,e,r,s,i){null==s&&(s=GI(n,t[0],r[0]));const o=[0,0,0,e];for(let a=0;a<3;a++)n[a]+2*s>=t[a]&&(o[a]=Wm((n[a]-t[a]+2*s)/r[a]+1,i));return o}([t,e,r,1],[a,u,c],1,[s,i,o],n,p);y=I[0],_=I[1],w=I[2]}else{if("same"!==n)throw Error(`Unknown padding parameter: ${n}`);{y=Math.ceil(t/s),_=Math.ceil(e/i),w=Math.ceil(r/o);const T=(y-1)*s+a-t,I=(_-1)*i+u-e,O=(w-1)*o+c-r,M=Math.floor(T/2),V=T-M,z=Math.floor(I/2),G=I-z,Q=Math.floor(O/2);m={top:z,bottom:G,left:Q,right:O-Q,front:M,back:V,type:"SAME"}}}return{padInfo:m,outDepth:y,outHeight:_,outWidth:w}}(s,c,p,m,O,M,V,ne,oe,de,a),Me=i?I*y:I;let Pe;return"channelsFirst"===o?Pe=[u,Me,Te,Ae,Oe]:"channelsLast"===o&&(Pe=[u,Te,Ae,Oe,Me]),{batchSize:u,dataFormat:o,inDepth:c,inHeight:p,inWidth:m,inChannels:y,outDepth:Te,outHeight:Ae,outWidth:Oe,outChannels:Me,padInfo:pe,strideDepth:O,strideHeight:M,strideWidth:V,filterDepth:_,filterHeight:w,filterWidth:T,effectiveFilterDepth:ne,effectiveFilterHeight:oe,effectiveFilterWidth:de,dilationDepth:z,dilationHeight:G,dilationWidth:Q,inShape:n,outShape:Pe,filterShape:t}}function GI(n,t,e,r=1){const s=Th(t,r);return Math.floor((n[0]*(e-1)-e+s)/2)}function Gm(n){return"number"==typeof n?[n,n,n]:2===n.length?[n[0],n[1],1]:n}function WI(n){return"number"==typeof n?[n,n,n]:n}function Th(n,t){return t<=1?n:n+(n-1)*(t-1)}function Wm(n,t){if(!t)return Math.trunc(n);switch(t){case"round":return Math.round(n);case"ceil":return Math.ceil(n);case"floor":return Math.floor(n);default:throw new Error(`Unknown roundingMode ${t}`)}}function du(n){const[t,e,r]=Gm(n);return 1===t&&1===e&&1===r}function vs(n,t){return du(n)||du(t)}function xc(n){return Gm(n).every(t=>t>0)}function fl(n){if("NHWC"===n)return"channelsLast";if("NCHW"===n)return"channelsFirst";throw new Error(`Unknown dataFormat ${n}`)}function js(n,t,e){if(null!=e){if("string"==typeof t)throw Error(`Error in ${n}: pad must be an integer when using dimRoundingMode ${e} but got pad ${t}.`);if("number"==typeof t)J(ah(t),()=>`Error in ${n}: pad must be an integer when using dimRoundingMode ${e} but got pad ${t}.`);else{if("object"!=typeof t)throw Error(`Error in ${n}: Unknown padding parameter: ${t}`);t.forEach(r=>{r.forEach(s=>{J(ah(s),()=>`Error in ${n}: pad must be an integer when using dimRoundingMode ${e} but got pad ${s}.`)})})}}}const be=he({reshape_:function Qse(n,t){const r={x:ee(n,"x","reshape","string_or_numeric")};return fe.runKernel(Y_,r,{shape:t})}}),Cv=he({avgPool_:function Jse(n,t,e,r,s){const i=ee(n,"x","avgPool","float32");J(vs(e,1),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${e} and dilations '1'`);let a=i,u=!1;3===i.rank&&(u=!0,a=be(i,[1,i.shape[0],i.shape[1],i.shape[2]])),J(4===a.rank,()=>`Error in avgPool: x must be rank 4 but got rank ${a.rank}.`),js("avgPool",r,s);let m=fe.runKernel(h_,{x:a},{filterSize:t,strides:e,pad:r,dimRoundingMode:s});return m=pt(m,i.dtype),u?be(m,[m.shape[1],m.shape[2],m.shape[3]]):m}}),Y3=he({avgPool3d_:function eie(n,t,e,r,s,i="NDHWC"){const o=ee(n,"x","avgPool3d","float32");let a=o,u=!1;4===o.rank&&(u=!0,a=be(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),J(5===a.rank,()=>`Error in avgPool3d: x must be rank 5 but got rank ${a.rank}.`),J("NDHWC"===i,()=>`Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of ${i}`),J("number"==typeof e&&e>0||Array.isArray(e)&&e[0]>0&&e[1]>0&&e[2]>0,()=>`Error in avgPool3d: Stride must be > 0, but got '${e}'`),js("avgPool3d",r,s);let m=fe.runKernel(p_,{x:a},{filterSize:t,strides:e,pad:r,dimRoundingMode:s,dataFormat:i});return m=pt(m,a.dtype),u?be(m,[m.shape[1],m.shape[2],m.shape[3],m.shape[4]]):m}}),Vr=he({concat_:function tie(n,t=0){J(n.length>=1,()=>"Pass at least one tensor to concat");const e=yv(n,"tensors","concat","string_or_numeric");return"complex64"===e[0].dtype&&e.forEach(i=>{if("complex64"!==i.dtype)throw new Error(`Cannot concatenate complex64 tensors with a tensor\n          with dtype ${i.dtype}. `)}),1===e.length?cl(e[0]):fe.runKernel(y_,e,{axis:t})}}),ln=he({matMul_:function nie(n,t,e=!1,r=!1){let s=ee(n,"a","matMul"),i=ee(t,"b","matMul");return[s,i]=vr(s,i),fe.runKernel(f_,{a:s,b:i},{transposeA:e,transposeB:r})}}),Aa=he({sigmoid_:function rie(n){const e={x:ee(n,"x","sigmoid","float32")};return fe.runKernel(Am,e)}}),gn=he({slice_:function sie(n,t,e){const r=ee(n,"x","slice","string_or_numeric");if(0===r.rank)throw new Error("Slicing scalar is not possible");return fe.runKernel(tv,{x:r},{begin:t,size:e})}}),Sh=he({tanh_:function iie(n){const e={x:ee(n,"x","tanh","float32")};return fe.runKernel(Pm,e)}}),aie=he({basicLSTMCell_:function oie(n,t,e,r,s,i){const o=ee(n,"forgetBias","basicLSTMCell"),a=ee(t,"lstmKernel","basicLSTMCell"),u=ee(e,"lstmBias","basicLSTMCell"),c=ee(r,"data","basicLSTMCell"),p=ee(s,"c","basicLSTMCell"),m=ee(i,"h","basicLSTMCell"),y=Vr([c,m],1),_=ln(y,a),w=Ze(_,u),I=w.shape[1]/4,O=[w.shape[0],I],M=gn(w,[0,0],O),V=gn(w,[0,I],O),z=gn(w,[0,2*I],O),G=gn(w,[0,3*I],O),Q=Ze(me(Aa(M),Sh(V)),me(p,Aa(Ze(o,z))));return[Q,me(Sh(Q),Aa(G))]}}),Iv=he({batchToSpaceND_:function lie(n,t,e){const r=ee(n,"x","batchToSpaceND"),s=t.reduce((a,u)=>a*u);return J(r.rank>=1+t.length,()=>`input rank is ${r.rank} but should be > than blockShape.length ${t.length}`),J(e.length===t.length,()=>`crops.length is ${e.length} but should be equal to blockShape.length  ${t.length}`),J(r.shape[0]%s==0,()=>`input tensor batch is ${r.shape[0]} but is not divisible by the product of the elements of blockShape ${t.join(" * ")} === ${s}`),fe.runKernel(m_,{x:r},{blockShape:t,crops:e})}});function uie(n){let t;return t=0===n.rank||1===n.rank?be(n,[1,1,1,n.size]):2===n.rank?be(n,[1,1,n.shape[0],n.shape[1]]):3===n.rank?be(n,[1,n.shape[0],n.shape[1],n.shape[2]]):n,t}const Hm=he({batchNorm_:function cie(n,t,e,r,s,i){null==i&&(i=.001);const o=ee(n,"x","batchNorm"),a=ee(t,"mean","batchNorm"),u=ee(e,"variance","batchNorm");let c,p;null!=s&&(c=ee(s,"scale","batchNorm")),null!=r&&(p=ee(r,"offset","batchNorm")),J(a.rank===u.rank,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),J(null==p||a.rank===p.rank,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),J(null==c||a.rank===c.rank,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");const y={x:uie(o),scale:c,offset:p,mean:a,variance:u},w=fe.runKernel(I_,y,{varianceEpsilon:i});return be(w,o.shape)}}),Z3=he({batchNorm2d_:function die(n,t,e,r,s,i){const o=ee(n,"x","batchNorm"),a=ee(t,"mean","batchNorm"),u=ee(e,"variance","batchNorm");let c,p;return null!=s&&(c=ee(s,"scale","batchNorm")),null!=r&&(p=ee(r,"offset","batchNorm")),J(2===o.rank,()=>`Error in batchNorm2D: x must be rank 2 but got rank ${o.rank}.`),J(2===a.rank||1===a.rank,()=>`Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank ${a.rank}.`),J(2===u.rank||1===u.rank,()=>`Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank ${u.rank}.`),null!=c&&J(2===c.rank||1===c.rank,()=>`Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank ${c.rank}.`),null!=p&&J(2===p.rank||1===p.rank,()=>`Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank ${p.rank}.`),Hm(o,a,u,p,c,i)}}),Q3=he({batchNorm3d_:function hie(n,t,e,r,s,i){const o=ee(n,"x","batchNorm"),a=ee(t,"mean","batchNorm"),u=ee(e,"variance","batchNorm");let c,p;return null!=s&&(c=ee(s,"scale","batchNorm")),null!=r&&(p=ee(r,"offset","batchNorm")),J(3===o.rank,()=>`Error in batchNorm3D: x must be rank 3 but got rank ${o.rank}.`),J(3===a.rank||1===a.rank,()=>`Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank ${a.rank}.`),J(3===u.rank||1===u.rank,()=>`Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank ${u.rank}.`),null!=c&&J(3===c.rank||1===c.rank,()=>`Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank ${c.rank}.`),null!=p&&J(3===p.rank||1===p.rank,()=>`Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank ${p.rank}.`),Hm(o,a,u,p,c,i)}}),J3=he({batchNorm4d_:function pie(n,t,e,r,s,i){const o=ee(n,"x","batchNorm"),a=ee(t,"mean","batchNorm"),u=ee(e,"variance","batchNorm");let c,p;return null!=s&&(c=ee(s,"scale","batchNorm")),null!=r&&(p=ee(r,"offset","batchNorm")),J(4===o.rank,()=>`Error in batchNorm4D: x must be rank 4 but got rank ${o.rank}.`),J(4===a.rank||1===a.rank,()=>`Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank ${a.rank}.`),J(4===u.rank||1===u.rank,()=>`Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank ${u.rank}.`),null!=c&&J(4===c.rank||1===c.rank,()=>`Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank ${c.rank}.`),null!=p&&J(4===p.rank||1===p.rank,()=>`Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank ${p.rank}.`),Hm(o,a,u,p,c,i)}}),eV=he({bincount_:function fie(n,t,e){const r=ee(n,"x","bincount"),s=ee(t,"weights","bincount");return J("int32"===r.dtype,()=>`Error in bincount: input dtype must be int32, but got ${r.dtype}`),J(e>=0,()=>`size must be non-negative, but got ${e}.`),J(s.size===r.size||0===s.size,()=>`Error in bincount: weights must have the same size as input or0-length, but got input shape: ${r.shape}, weights shape: ${s.shape}.`),fe.runKernel(nC,{x:r,weights:s},{size:e})}}),gie=he({bitwiseAnd_:function mie(n,t){const e=ee(n,"x","bitwiseAnd"),r=ee(t,"y","bitwiseAnd");if(!hn(e.shape,r.shape))throw new Error(`BitwiseAnd: Tensors must have the same shape. x: ${e.shape}, y: ${r.shape}`);if("int32"!==e.dtype||"int32"!==r.dtype)throw new Error(`BitwiseAnd: Only supports 'int32' values in tensor, found type of x: ${e.dtype} and type of y: ${r.dtype}`);return fe.runKernel(rC,{a:e,b:r})}}),bie=he({broadcastArgs_:function yie(n,t){const e=ee(n,"s0","broadcastArgs","int32"),r=ee(t,"s1","broadcastArgs","int32");if(1!==e.rank)throw new Error(`broadcastArgs(): first input must be a vector (rank=1). Has rank ${e.rank}`);if(1!==r.rank)throw new Error(`broadcastArgs(): second input must be a vector (rank=1). Has rank ${r.rank}`);return fe.runKernel(sC,{s0:e,s1:r})}}),Ch=he({broadcastTo_:function _ie(n,t){let e=ee(n,"broadcastTo","x");const r=e.shape;if(zi(t),t.length<e.rank)throw new Error(`broadcastTo(): shape.length=${t.length} < input.rank=${e.rank}.`);if(t.length>e.rank){const c=e.shape.slice();for(;c.length<t.length;)c.unshift(1);e=be(e,c)}const s=e.shape,i=Array.from(t);for(let c=t.length-1;c>=0;c--)if(s[c]===t[c])i[c]=1;else if(1!==e.shape[c])throw new Error(`broadcastTo(): [${r}] cannot be broadcast to [${t}].`);return 0===i.map((c,p)=>c>1?p:-1).filter(c=>c>=0).length?cl(e):fe.runKernel(Fm,{x:e},{reps:i})}}),tV=he({ceil_:function vie(n){const e={x:ee(n,"x","ceil","float32")};return fe.runKernel(Zf,e)}}),Si=he({clipByValue_:function wie(n,t,e){const r=ee(n,"x","clipByValue");return J(t<=e,()=>`Error in clip: min (${t}) must be less than or equal to max (${e}).`),t===e?vh(r.shape,t,r.dtype):fe.runKernel(Qf,{x:r},{clipValueMin:t,clipValueMax:e})}}),nV=he({concat1d_:function xie(n){return Vr(n,0)}}),rV=he({concat2d_:function Tie(n,t){return Vr(n,t)}}),sV=he({concat3d_:function Sie(n,t){return Vr(n,t)}}),iV=he({concat4d_:function Cie(n,t){return Vr(n,t)}}),hu=he({conv2d_:function Iie(n,t,e,r,s="NHWC",i=[1,1],o){const a=ee(n,"x","conv2d","float32"),u=ee(t,"filter","conv2d","float32");let c=a,p=!1;3===a.rank&&(p=!0,c=be(a,[1,a.shape[0],a.shape[1],a.shape[2]])),J(4===c.rank,()=>`Error in conv2d: input must be rank 4, but got rank ${c.rank}.`),J(4===u.rank,()=>`Error in conv2d: filter must be rank 4, but got rank ${u.rank}.`),js("conv2d",r,o);const m="NHWC"===s?c.shape[3]:c.shape[1];J(m===u.shape[2],()=>`Error in conv2d: depth of input (${m}) must match input depth for filter ${u.shape[2]}.`),J(vs(e,i),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${e} and dilations '${i}'`),J(xc(i),()=>"Error in conv2D: Dilated rates should be larger than 0."),J(xc(e),()=>"Error in conv2D: Strides should be larger than 0.");const w=fe.runKernel(b_,{x:c,filter:u},{strides:e,pad:r,dataFormat:s,dilations:i,dimRoundingMode:o});return p?be(w,[w.shape[1],w.shape[2],w.shape[3]]):w}}),HI=he({conv1d_:function Eie(n,t,e,r,s="NWC",i=1,o){const a=ee(n,"x","conv1d"),u=ee(t,"filter","conv1d");let c=a,p=!1;2===a.rank&&(p=!0,c=be(a,[1,a.shape[0],a.shape[1]])),J(3===c.rank,()=>`Error in conv1d: input must be rank 3, but got rank ${c.rank}.`),J(3===u.rank,()=>`Error in conv1d: filter must be rank 3, but got rank ${u.rank}.`),js("conv1d",r,o),J(c.shape[2]===u.shape[1],()=>`Error in conv1d: depth of input (${c.shape[2]}) must match input depth for filter ${u.shape[1]}.`),J(vs(e,i),()=>`Error in conv1D: Either stride or dilation must be 1. Got stride ${e} and dilation '${i}'`),J(xc(i),()=>"Error in conv1D: Dilated rates should be larger than 0."),J(xc(e),()=>"Error in conv1D: Stride should be larger than 0."),J("NWC"===s,()=>`Error in conv1d: got dataFormat of ${s} but only NWC is currently supported.`);const m=be(u,[1,u.shape[0],u.shape[1],u.shape[2]]),y=be(c,[c.shape[0],1,c.shape[1],c.shape[2]]),I=hu(y,m,[1,e],r,"NHWC",[1,i],o);return be(I,p?[I.shape[2],I.shape[3]]:[I.shape[0],I.shape[2],I.shape[3]])}}),qI=he({conv2DBackpropInput_:function Die(n,t,e,r,s,i="NHWC",o){J(n.length===t.rank,()=>`Length of inShape (${n.length}) and rank of dy (${t.rank}) must match`);let a=n,u=t,c=!1;3===t.rank&&(c=!0,u=be(t,[1,t.shape[0],t.shape[1],t.shape[2]]),a=[1,n[0],n[1],n[2]]),J(4===a.length,()=>`Error in conv2dDerInput: inShape must be length 4, but got length ${a.length}.`),J(4===u.rank,()=>`Error in conv2dDerInput: dy must be rank 4, but got rank ${u.rank}`),J(4===e.rank,()=>`Error in conv2dDerInput: filter must be rank 4, but got rank ${e.rank}`);const p="NHWC"===i?a[3]:a[1],m="NHWC"===i?u.shape[3]:u.shape[1];J(p===e.shape[2],()=>`Error in conv2dDerInput: depth of input (${p}) must match input depth for filter ${e.shape[2]}.`),J(m===e.shape[3],()=>`Error in conv2dDerInput: depth of output (${m}) must match output depth for filter ${e.shape[3]}.`),js("conv2dDerInput",s,o);const w=fe.runKernel(__,{dy:u,filter:e},{strides:r,pad:s,dataFormat:i,dimRoundingMode:o,inputShape:a});return c?be(w,[w.shape[1],w.shape[2],w.shape[3]]):w}}),KI=he({conv2dTranspose_:function Aie(n,t,e,r,s,i){const o=ee(n,"x","conv2dTranspose"),a=ee(t,"filter","conv2dTranspose");return qI(e,o,a,r,s,"NHWC",i)}}),oV=he({conv3d_:function kie(n,t,e,r,s="NDHWC",i=[1,1,1]){const o=ee(n,"x","conv3d"),a=ee(t,"filter","conv3d");let u=o,c=!1;4===o.rank&&(c=!0,u=be(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),J(5===u.rank,()=>`Error in conv3d: input must be rank 5, but got rank ${u.rank}.`),J(5===a.rank,()=>`Error in conv3d: filter must be rank 5, but got rank ${a.rank}.`),J(u.shape[4]===a.shape[3],()=>`Error in conv3d: depth of input (${u.shape[4]}) must match input depth for filter ${a.shape[3]}.`),J(vs(e,i),()=>`Error in conv3D: Either strides or dilations must be 1. Got strides ${e} and dilations '${i}'`),J("NDHWC"===s,()=>`Error in conv3d: got dataFormat of ${s} but only NDHWC is currently supported.`),J(xc(i),()=>"Error in conv3D: Dilated rates should be larger than 0."),J(xc(e),()=>"Error in conv3D: Strides should be larger than 0.");const y=fe.runKernel(v_,{x:u,filter:a},{strides:e,pad:r,dataFormat:s,dilations:i});return c?be(y,[y.shape[1],y.shape[2],y.shape[3],y.shape[4]]):y}}),aV=he({conv3DBackpropInput_:function Nie(n,t,e,r,s){J(n.length===t.rank,()=>`Length of inShape (${n.length}) and rank of dy (${t.rank}) must match`);let i=n,o=t,a=!1;4===t.rank&&(a=!0,o=be(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]]),i=[1,n[0],n[1],n[2],n[3]]);const u=i[4],c=o.shape[4];J(5===i.length,()=>`Error in conv3dDerInput: inShape must be length 5, but got length ${i.length}.`),J(5===o.rank,()=>`Error in conv3dDerInput: dy must be rank 5, but got rank ${o.rank}`),J(5===e.rank,()=>`Error in conv3dDerInput: filter must be rank 5, but got rank ${e.rank}`),J(u===e.shape[3],()=>`Error in conv3dDerInput: depth of input (${u}) must match input depth for filter ${e.shape[3]}.`),J(c===e.shape[4],()=>`Error in conv3dDerInput: depth of output (${c}) must match output depth for filter ${e.shape[4]}.`);const y=fe.runKernel(lC,{dy:o,filter:e},{pad:s,strides:r,inputShape:i});return a?be(y,[y.shape[1],y.shape[2],y.shape[3],y.shape[4]]):y}}),lV=he({conv3dTranspose_:function Oie(n,t,e,r,s){const i=ee(n,"x","conv3dTranspose"),o=ee(t,"filter","conv3dTranspose");return aV(e,i,o,r,s)}}),Ev=he({cos_:function Rie(n){const e={x:ee(n,"x","cos","float32")};return fe.runKernel(Jf,e)}}),XI=he({cosh_:function Mie(n){const e={x:ee(n,"x","cosh","float32")};return fe.runKernel(em,e)}}),Dv=he({cumprod_:function Pie(n,t=0,e=!1,r=!1){const i={x:ee(n,"x","cumprod")};return fe.runKernel(uC,i,{axis:t,exclusive:e,reverse:r})}}),YI=he({cumsum_:function Fie(n,t=0,e=!1,r=!1){const i={x:ee(n,"x","cumsum")};return fe.runKernel(w_,i,{axis:t,exclusive:e,reverse:r})}}),ZI=he({denseBincount_:function $ie(n,t,e,r=!1){const s=ee(n,"x","denseBincount"),i=ee(t,"weights","denseBincount");return J("int32"===s.dtype,()=>`Error in denseBincount: input dtype must be int32, but got ${s.dtype}`),J(s.rank<=2,()=>`Error in denseBincount: input must be at most rank 2, but got rank ${s.rank}.`),J(e>=0,()=>`size must be non-negative, but got ${e}.`),J(i.size===s.size||0===i.size,()=>`Error in denseBincount: weights must have the same shape as x or 0-length, but got x shape: ${s.shape}, weights shape: ${i.shape}.`),fe.runKernel(dC,{x:s,weights:i},{size:e,binaryOutput:r})}}),uV=he({depthToSpace_:function Lie(n,t,e="NHWC"){const r=ee(n,"x","depthToSpace","float32"),s="NHWC"===e?r.shape[1]:r.shape[2],i="NHWC"===e?r.shape[2]:r.shape[3],o="NHWC"===e?r.shape[3]:r.shape[1];return J(t>1,()=>`blockSize should be > 1 for depthToSpace, but was: ${t}`),J(s*t>=0,()=>`Negative dimension size caused by overflow when multiplying\n    ${s} and ${t}  for depthToSpace with input shape\n    ${r.shape}`),J(i*t>=0,()=>`Negative dimension size caused by overflow when multiplying\n    ${i} and ${t} for depthToSpace with input shape\n        ${r.shape}`),J(o%(t*t)==0,()=>`Dimension size must be evenly divisible by ${t*t} but is ${o} for depthToSpace with input shape ${r.shape}`),fe.runKernel(hC,{x:r},{blockSize:t,dataFormat:e})}}),qm=he({depthwiseConv2d_:function Vie(n,t,e,r,s="NHWC",i=[1,1],o){const a=ee(n,"x","depthwiseConv2d","float32"),u=ee(t,"filter","depthwiseConv2d","float32");let c=a,p=!1;3===a.rank&&(p=!0,c=be(a,[1,a.shape[0],a.shape[1],a.shape[2]])),J(4===c.rank,()=>`Error in depthwiseConv2d: input must be rank 4, but got rank ${c.rank}.`),J(4===u.rank,()=>`Error in depthwiseConv2d: filter must be rank 4, but got rank ${u.rank}.`);const m="NHWC"===s?c.shape[3]:c.shape[1];J(m===u.shape[2],()=>`Error in depthwiseConv2d: number of input channels (${m}) must match the inChannels dimension in filter ${u.shape[2]}.`),js("depthwiseConv2d",r,o);const w=fe.runKernel(x_,{x:c,filter:u},{strides:e,pad:r,dataFormat:s,dilations:i,dimRoundingMode:o});return p?be(w,[w.shape[1],w.shape[2],w.shape[3]]):w}}),zie=he({diag_:function Bie(n){const e={x:ee(n,"x","diag")};return fe.runKernel(mC,e)}}),cV=he({dilation2d_:function Uie(n,t,e,r,s=[1,1],i="NHWC"){const o=ee(n,"x","dilation2d"),a=ee(t,"filter","dilation2d");J(3===o.rank||4===o.rank,()=>`Error in dilation2d: input must be rank 3 or 4, but got rank ${o.rank}.`),J(3===a.rank,()=>`Error in dilation2d: filter must be rank 3, but got rank ${a.rank}.`),J("NHWC"===i,()=>`Error in dilation2d: Only NHWC is currently supported, but got dataFormat of ${i}`);let u=o,c=!1;3===o.rank&&(u=be(o,[1,o.shape[0],o.shape[1],o.shape[2]]),c=!0),J(u.shape[3]===a.shape[2],()=>`Error in dilation2d:  input and filter must have the same depth: ${u.shape[3]} vs ${a.shape[2]}`);const y=fe.runKernel(T_,{x:u,filter:a},{strides:e,pad:r,dilations:s});return c?be(y,[y.shape[1],y.shape[2],y.shape[3]]):y}}),Zo=he({equal_:function jie(n,t){let e=ee(n,"a","equal","string_or_numeric"),r=ee(t,"b","equal","string_or_numeric");return[e,r]=vr(e,r),Ht(e.shape,r.shape),fe.runKernel(S_,{a:e,b:r})}}),Os=he({where_:function Gie(n,t,e){const r=ee(t,"a","where"),s=ee(e,"b","where"),i=ee(n,"condition","where","bool"),o=Ht(Ht(i.shape,r.shape),s.shape),a=Ch(i,o),u=Ch(r,o),c=Ch(s,o);return fe.runKernel(ev,{condition:a,t:u,e:c})}}),dV=he({divNoNan_:function Wie(n,t){let e=ee(n,"a","div"),r=ee(t,"b","div");[e,r]=vr(e,r);const s=At(e,r),i=mn(s),o=Zo(r,i);return Os(o,i,s)}}),hV=he({dot_:function Hie(n,t){const e=ee(n,"t1","dot"),r=ee(t,"t2","dot");J(!(1!==e.rank&&2!==e.rank||1!==r.rank&&2!==r.rank),()=>`Error in dot: inputs must all be rank 1 or 2, but got ranks ${e.rank} and ${r.rank}.`);const s=1===e.rank?e.size:e.shape[1],i=1===r.rank?r.size:r.shape[0];if(J(s===i,()=>`Error in dot: inner dimensions of inputs must match, but got ${s} and ${i}.`),1===e.rank&&1===r.rank){const o=be(e,[1,-1]),a=be(r,[-1,1]),u=ln(o,a);return be(u,[])}if(1===e.rank&&2===r.rank){const o=be(e,[1,-1]),a=be(r,[r.shape[0],r.shape[1]]),u=ln(o,a);return be(u,[u.size])}if(2===e.rank&&1===r.rank){const o=be(r,[-1,1]),a=ln(e,o);return be(a,[a.size])}{const o=be(r,[r.shape[0],r.shape[1]]);return ln(e,o)}}}),Kie=he({einsum_:function qie(n,...t){const e=t.map((s,i)=>ee(s,`tensors${i}`,"einsum"));return fe.runKernel(bC,e,{equation:n})}}),Km=he({elu_:function Xie(n){const e={x:ee(n,"x","elu","float32")};return fe.runKernel(nm,e)}}),Zie=he({ensureShape_:function Yie(n,t){const e=ee(n,"x","ensureShape","string_or_numeric");if(!function Rne(n,t){if(n===t)return!0;if(null==n||null==t||n.length!==t.length)return!1;for(let e=0;e<n.length;e++)if(null!==n[e]&&null!==t[e]&&n[e]!==t[e])return!1;return!0}(e.shape,t))throw new Error(`EnsureShape: Shape of tensor ${e.shape} is not compatible with expected shape ${t}`);return n}}),pV=he({erf_:function Qie(n){let t=ee(n,"x","erf");return J("int32"===t.dtype||"float32"===t.dtype,()=>"Input dtype must be `int32` or `float32`."),"int32"===t.dtype&&(t=pt(t,"float32")),fe.runKernel(rm,{x:t})}});function QI(n,t){for(let e=0;e<n.length;++e)if(n[n.length-e-1]!==t-1-e)return!1;return!0}function fV(n,t,e){const r=n.length+t.length,s=[];let i=0,o=0;for(let a=0;a<r;a++)-1===e.indexOf(a)?s.push(n[i++]):s.push(t[o++]);return s}function us(n,t){const e=[],r=n.length;for(let i=0;i<r;i++)-1===t.indexOf(i)&&e.push(n[i]);return[e,t.map(i=>n[i])]}function kr(n,t){return fV(n,t.map(r=>1),t)}function ws(n,t,e){J(QI(t,e),()=>`${n} supports only inner-most axes for now. Got axes ${t} and rank-${e} input.`)}function ur(n,t){if(QI(n,t))return null;const e=[];for(let r=0;r<t;++r)-1===n.indexOf(r)&&e.push(r);return n.forEach(r=>e.push(r)),e}function pu(n){return n.map((t,e)=>[e,t]).sort((t,e)=>t[1]-e[1]).map(t=>t[0])}function Nr(n,t){const e=[];for(let r=t-n;r<t;++r)e.push(r);return e}const wo=he({max_:function Jie(n,t=null,e=!1){const s={x:ee(n,"x","max")};return fe.runKernel(F_,s,{reductionIndices:t,keepDims:e})}}),Xm=he({min_:function eoe(n,t=null,e=!1){const s={x:ee(n,"x","min")};return fe.runKernel(B_,s,{axis:t,keepDims:e})}}),Tt=he({sum_:function toe(n,t=null,e=!1){let r=ee(n,"x","sum");return"bool"===r.dtype&&(r=pt(r,"int32")),fe.runKernel(nv,{x:r},{axis:t,keepDims:e})}});function mV(n,t,e=null){if(0===n.rank)return Kr(n);if(1!==n.rank&&null===e)return mV(be(n,[-1]),t,e);if(1===n.rank||"number"==typeof e||Array.isArray(e)&&1===e.length){if(1===t)return Tt(Kr(n),e);if(t===1/0)return wo(Kr(n),e);if(t===-1/0)return Xm(Kr(n),e);if("euclidean"===t||2===t)return Ns(Tt(uu(Kr(n),Rt(2,"int32")),e));throw new Error(`Error in norm: invalid ord value: ${t}`)}if(Array.isArray(e)&&2===e.length){if(1===t)return wo(Tt(Kr(n),e[0]),e[1]-1);if(t===1/0)return wo(Tt(Kr(n),e[1]),e[0]);if(t===-1/0)return Xm(Tt(Kr(n),e[1]),e[0]);if("fro"===t||"euclidean"===t)return Ns(Tt(zn(n),e));throw new Error(`Error in norm: invalid ord value: ${t}`)}throw new Error(`Error in norm: invalid axis: ${e}`)}const Ym=he({norm_:function noe(n,t="euclidean",e=null,r=!1){const s=mV(n=ee(n,"x","norm"),t,e);let i=s.shape;if(r){const o=sn(e,n.shape);i=kr(s.shape,o)}return be(s,i)}}),gV=he({euclideanNorm_:function roe(n,t=null,e=!1){return Ym(n,"euclidean",t,e)}}),ji=he({exp_:function soe(n){const e={x:ee(n,"x","exp")};return fe.runKernel(sm,e)}}),ii=he({expandDims_:function ioe(n,t=0){const e=ee(n,"x","expandDims","string_or_numeric");return J(t<=e.rank,()=>"Axis must be <= rank of the tensor"),fe.runKernel(C_,{input:e},{dim:t})}}),yV=he({expm1_:function ooe(n){const e={x:ee(n,"x","expm1")};return fe.runKernel(im,e)}}),xo=he({tile_:function aoe(n,t){const e=ee(n,"x","tile","string_or_numeric");return J(e.rank===t.length,()=>`Error in transpose: rank of input ${e.rank} must match length of reps ${t}.`),fe.runKernel(Fm,{x:e},{reps:t})}}),JI=he({eye_:function loe(n,t,e,r="float32"){null==t&&(t=n);const s=tn([n,t],r),i=n<=t?n:t;for(let a=0;a<i;++a)s.set(1,a,a);const o=be(s.toTensor(),[n,t]);if(null==e)return o;if(1===e.length)return xo(ii(o,0),[e[0],1,1]);if(2===e.length)return xo(ii(ii(o,0),0),[e[0],e[1],1,1]);if(3===e.length)return xo(ii(ii(ii(o,0),0),0),[e[0],e[1],e[2],1,1]);throw new Error(`eye() currently supports only 1D and 2D batchShapes, but received ${e.length}D.`)}}),Zm=he({floor_:function uoe(n){const e={x:ee(n,"x","floor","float32")};return fe.runKernel(om,e)}}),Qm=he({gather_:function coe(n,t,e=0,r=0){const s=ee(n,"x","gather"),i=ee(t,"indices","gather","int32");return fe.runKernel(E_,{x:s,indices:i},{axis:e,batchDims:r})}}),Ci=he({greater_:function doe(n,t){let e=ee(n,"a","greater","string_or_numeric"),r=ee(t,"b","greater","string_or_numeric");return[e,r]=vr(e,r),Ht(e.shape,r.shape),fe.runKernel(D_,{a:e,b:r})}}),fu=he({greaterEqual_:function hoe(n,t){let e=ee(n,"a","greaterEqual","string_or_numeric"),r=ee(t,"b","greaterEqual","string_or_numeric");return[e,r]=vr(e,r),Ht(e.shape,r.shape),fe.runKernel(lm,{a:e,b:r})}}),Av=he({imag_:function poe(n){const e={input:ee(n,"input","imag")};return fe.runKernel(CC,e)}}),bV=he({isFinite_:function foe(n){const e={x:ee(n,"x","isFinite")};return fe.runKernel(cm,e)}}),_V=he({isInf_:function moe(n){const e={x:ee(n,"x","isInf")};return fe.runKernel(dm,e)}}),vV=he({isNaN_:function goe(n){const e={x:ee(n,"x","isNaN")};return fe.runKernel(hm,e)}}),kv=he({leakyRelu_:function yoe(n,t=.2){const r={x:ee(n,"x","leakyRelu")};return fe.runKernel(A_,r,{alpha:t})}}),Jm=he({less_:function boe(n,t){let e=ee(n,"a","less","string_or_numeric"),r=ee(t,"b","less","string_or_numeric");return[e,r]=vr(e,r),Ht(e.shape,r.shape),fe.runKernel(k_,{a:e,b:r})}}),Tc=he({lessEqual_:function _oe(n,t){let e=ee(n,"a","lessEqual","string_or_numeric"),r=ee(t,"b","lessEqual","string_or_numeric");return[e,r]=vr(e,r),Ht(e.shape,r.shape),fe.runKernel(N_,{a:e,b:r})}});function voe(n,t,e){if(e<=0)throw new Error("The number of values should be positive.");return fe.runKernel(IC,{},{start:n,stop:t,num:e})}const wV=he({localResponseNormalization_:function woe(n,t=5,e=1,r=1,s=.5){const i=ee(n,"x","localResponseNormalization");J(4===i.rank||3===i.rank,()=>`Error in localResponseNormalization: x must be rank 3 or 4 but got\n               rank ${i.rank}.`),J(ah(t),()=>`Error in localResponseNormalization: depthRadius must be an integer but got depthRadius ${t}.`);let o=i,a=!1;3===i.rank&&(a=!0,o=be(i,[1,i.shape[0],i.shape[1],i.shape[2]]));const p=fe.runKernel(P_,{x:o},{depthRadius:t,bias:e,alpha:r,beta:s});return a?be(p,[p.shape[1],p.shape[2],p.shape[3]]):p}}),Gi=he({log_:function xoe(n){const e={x:ee(n,"x","log","float32")};return fe.runKernel(pm,e)}}),Nv=he({log1p_:function Toe(n){const e={x:ee(n,"x","log1p")};return fe.runKernel(fm,e)}}),Zn=he({neg_:function Soe(n){const e={x:ee(n,"x","neg")};return fe.runKernel(U_,e)}}),Ih=he({softplus_:function Coe(n){const e={x:ee(n,"x","softplus")};return fe.runKernel(km,e)}}),xV=he({logSigmoid_:function Ioe(n){const t=ee(n,"x","logSigmoid");return dl(r=>({value:Zn(Ih(Zn(r))),gradFunc:o=>me(o,Aa(Zn(r)))}))(t)}}),eE=he({logSoftmax_:function Eoe(n,t=-1){const e=ee(n,"logits","logSoftmax");if(-1===t&&(t=e.rank-1),t!==e.rank-1)throw Error(`Log Softmax along a non-last dimension is not yet supported. Logits was rank ${e.rank} and axis was ${t}`);return dl((s,i)=>{const a=wo(s,t,!0),u=vt(s,a),c=vt(pt(u,"float32"),Gi(Tt(ji(u),t,!0)));return i([c]),{value:c,gradFunc:(m,y)=>{const[_]=y,T=ji(_);return vt(m,me(Tt(m,t,!0),T))}}})(e)}}),tE=he({logSumExp_:function Doe(n,t=null,e=!1){const r=ee(n,"x","logSumExp"),s=sn(t,r.shape),i=wo(r,s,!0),o=vt(r,i),a=ji(o),u=Tt(a,s),c=Gi(u),p=Ze(be(i,c.shape),c);if(e){const m=kr(p.shape,s);return be(p,m)}return p}}),ka=he({logicalAnd_:function Aoe(n,t){const e=ee(n,"a","logicalAnd","bool"),r=ee(t,"b","logicalAnd","bool");return Ht(e.shape,r.shape),fe.runKernel(O_,{a:e,b:r})}}),Ov=he({logicalNot_:function koe(n){const e={x:ee(n,"x","logicalNot","bool")};return fe.runKernel(R_,e)}}),nE=he({logicalOr_:function Noe(n,t){const e=ee(n,"a","logicalOr","bool"),r=ee(t,"b","logicalOr","bool");return Ht(e.shape,r.shape),fe.runKernel(M_,{a:e,b:r})}}),TV=he({logicalXor_:function Ooe(n,t){const e=ee(n,"a","logicalXor","bool"),r=ee(t,"b","logicalXor","bool");return Ht(e.shape,r.shape),ka(nE(n,t),Ov(ka(n,t)))}}),Rv=2147483648,rE=he({searchSorted_:function Roe(n,t,e="left"){const r=ee(n,"sortedSequence","searchSorted"),s=ee(t,"values","searchSorted"),o=s.shape[s.shape.length-1],a=be(r,[-1,r.shape[r.shape.length-1]]),u=be(s,[-1,o]);if(a.rank<2)throw new Error("Sorted input argument must be at least 2-dimensional");if(a.shape[0]!==u.shape[0])throw new Error("Leading dimension of 'sortedSequence' and 'values' must match.");if(Fe(u.shape)>=Rv)throw new Error(`values tensor size must less than ${Rv}`);if(a.shape[1]>=Rv)throw new Error(`trailing dim_size must less than ${Rv} for int32 output type, was ${a.shape[1]}`);return fe.runKernel(GC,{sortedSequence:a,values:u},{side:e})}});function Moe(n,t){return rE(n,t,"left")}const Mv=he({maxPool_:function Poe(n,t,e,r,s){const i=ee(n,"x","maxPool");let a=i,u=!1;3===i.rank&&(u=!0,a=be(i,[1,i.shape[0],i.shape[1],i.shape[2]])),J(4===a.rank,()=>`Error in maxPool: input must be rank 4 but got rank ${a.rank}.`),J(vs(e,1),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${e} and dilations '1'`),js("maxPool",r,s);const m=fe.runKernel($_,{x:a},{filterSize:t,strides:e,pad:r,dimRoundingMode:s});return u?be(m,[m.shape[1],m.shape[2],m.shape[3]]):m}}),SV=he({maxPool3d_:function Foe(n,t=[1,1,1],e,r,s,i="NDHWC"){const o=ee(n,"x","maxPool3d");let a=o,u=!1;4===o.rank&&(u=!0,a=be(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),J(5===a.rank,()=>`Error in maxPool3d: x must be rank 5 but got rank ${a.rank}.`),J("NDHWC"===i,()=>`Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of ${i}`),js("maxPool3d",r,s);const m=fe.runKernel(L_,{x:a},{filterSize:t,strides:e,pad:r,dimRoundingMode:s,dataFormat:i});return u?be(m,[m.shape[1],m.shape[2],m.shape[3],m.shape[4]]):m}}),Loe=he({maxPoolWithArgmax_:function $oe(n,t,e,r,s=!1){const o={x:ee(n,"x","maxPoolWithArgmax")},u=fe.runKernel(kC,o,{filterSize:t,strides:e,pad:r,includeBatchInIndex:s});return{result:u[0],indexes:u[1]}}}),wr=he({mean_:function Voe(n,t=null,e=!1){const s={x:ee(n,"x","mean")};return fe.runKernel(V_,s,{axis:t,keepDims:e})}});function Yr(n,t="float32"){if(zi(n),"complex64"===t){const r=Yr(n,"float32"),s=Yr(n,"float32");return iu(r,s)}const e=ks(Fe(n),t);return fe.makeTensor(e,n,t)}function Wi(n,t="float32"){if(zi(n),"complex64"===t){const r=Wi(n,"float32"),s=Yr(n,"float32");return iu(r,s)}const e=X1(Fe(n),t);return fe.makeTensor(e,n,t)}function Boe(n,t,{indexing:e="xy"}={}){if("xy"!==e&&"ij"!==e)throw new TypeError(`${e} is not a valid third argument to meshgrid`);if(void 0===n)return[];let r=ee(n,"x","meshgrid",n instanceof nr?n.dtype:"float32");if(void 0===t)return[r];let s=ee(t,"y","meshgrid",t instanceof nr?t.dtype:"float32");const i=Fe(r.shape),o=Fe(s.shape);return"xy"===e?(r=be(r,[1,-1]),s=be(s,[-1,1]),[ln(Wi([o,1],r.dtype),r),ln(s,Wi([1,i],s.dtype))]):(r=be(r,[-1,1]),s=be(s,[1,-1]),[ln(r,Wi([1,o],r.dtype)),ln(Wi([i,1],s.dtype),s)])}const Sc=he({minimum_:function zoe(n,t){let e=ee(n,"a","minimum"),r=ee(t,"b","minimum");return[e,r]=vr(e,r),"bool"===e.dtype&&(e=pt(e,"int32"),r=pt(r,"int32")),Ht(e.shape,r.shape),fe.runKernel(gm,{a:e,b:r})}}),CV=he({mirrorPad_:function Uoe(n,t,e){J("reflect"===e||"symmetric"===e,()=>`Invalid mode. Mode must be either reflect or symmetric. Got ${e}.`);const r=ee(n,"x","mirrorPad");if(0===r.rank)throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");J(t.length===r.rank,()=>`Padding doesn't match input. Must be ${r.rank}. Got ${t.length}.`);const s="reflect"===e?1:0;for(let a=0;a<r.rank;a++)J(2===t[a].length,()=>"Invalid number of paddings. Must be length of 2 each."),J(t[a][0]>=0&&t[a][0]<=r.shape[a]-s&&t[a][1]>=0&&t[a][1]<=r.shape[a]-s,()=>`Padding in dimension ${a} cannot be greater than or equal to ${r.shape[a]-s} or less than 0 for input of shape ${r.shape}`);return fe.runKernel(z_,{x:r},{paddings:t,mode:e})}}),IV=he({mod_:function joe(n,t){let e=ee(n,"a","mod"),r=ee(t,"b","mod");return[e,r]=vr(e,r),fe.runKernel(ym,{a:e,b:r})}}),Pv=he({moments_:function Goe(n,t=null,e=!1){const r=sn(t,(n=ee(n,"x","moments")).shape),s=wr(n,r,e);let i=s.shape;e||(i=kr(s.shape,r));const o=zn(vt(pt(n,"float32"),be(s,i)));return{mean:s,variance:wr(o,r,e)}}}),Hoe=he({multiRNNCell_:function Woe(n,t,e,r){const s=ee(t,"data","multiRNNCell"),i=yv(e,"c","multiRNNCell"),o=yv(r,"h","multiRNNCell");let a=s;const u=[];for(let m=0;m<n.length;m++){const y=n[m](a,i[m],o[m]);u.push(y[0]),u.push(y[1]),a=y[1]}const c=[],p=[];for(let m=0;m<u.length;m+=2)c.push(u[m]),p.push(u[m+1]);return[c,p]}}),Koe=he({multinomial_:function qoe(n,t,e,r=!1){const s=ee(n,"logits","multinomial"),i=s.size,o=s.rank;if(i<2)throw new Error(`Error in multinomial: you need at least 2 outcomes, but got ${i}.`);if(o>2)throw new Error(`Rank of probabilities must be 1 or 2, but is ${o}`);e=e||Math.random();const u={logits:1===o?be(s,[1,-1]):s},p=fe.runKernel(NC,u,{numSamples:t,seed:e,normalized:r});return 1===o?be(p,[p.size]):p}}),Eh=he({notEqual_:function Xoe(n,t){let e=ee(n,"a","notEqual","string_or_numeric"),r=ee(t,"b","notEqual","string_or_numeric");return[e,r]=vr(e,r),Ht(e.shape,r.shape),fe.runKernel(j_,{a:e,b:r})}}),sE=he({oneHot_:function Yoe(n,t,e=1,r=0,s="int32"){if(t<2)throw new Error(`Error in oneHot: depth must be >=2, but it is ${t}`);const o={indices:ee(n,"indices","oneHot","int32")};return fe.runKernel(W_,o,{dtype:s,depth:t,onValue:e,offValue:r})}}),Hi=he({onesLike_:function Zoe(n){const e={x:ee(n,"x","onesLike")};return fe.runKernel(G_,e)}}),Joe=he({outerProduct_:function Qoe(n,t){const e=ee(n,"v1","outerProduct"),r=ee(t,"v2","outerProduct");J(1===e.rank&&1===r.rank,()=>`Error in outerProduct: inputs must be rank 1, but got ranks ${e.rank} and ${r.rank}.`);const s=be(e,[-1,1]),i=be(r,[1,-1]);return ln(s,i)}}),mu=he({pad_:function eae(n,t,e=0){const r=ee(n,"x","pad");if(0===r.rank)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");return fe.runKernel(q_,{x:r},{paddings:t,constantValue:e})}}),nae=he({pad1d_:function tae(n,t,e=0){return J(2===t.length,()=>"Invalid number of paddings. Must be length of 2."),mu(n,[t],e)}}),sae=he({pad2d_:function rae(n,t,e=0){return J(2===t.length&&2===t[0].length&&2===t[1].length,()=>"Invalid number of paddings. Must be length of 2 each."),mu(n,t,e)}}),oae=he({pad3d_:function iae(n,t,e=0){return J(3===t.length&&2===t[0].length&&2===t[1].length&&2===t[2].length,()=>"Invalid number of paddings. Must be length of 2 each."),mu(n,t,e)}}),lae=he({pad4d_:function aae(n,t,e=0){return J(4===t.length&&2===t[0].length&&2===t[1].length&&2===t[2].length&&2===t[3].length,()=>"Invalid number of paddings. Must be length of 2 each."),mu(n,t,e)}}),Fv=he({spaceToBatchND_:function uae(n,t,e){const r=ee(n,"x","spaceToBatchND");return J(r.rank>=1+t.length,()=>`input rank ${r.rank} should be > than [blockShape] ${t.length}`),J(e.length===t.length,()=>`paddings.shape[0] ${e.length} must be equal to [blockShape] ${t.length}`),J(r.shape.reduce((o,a,u)=>u>0&&u<=t.length?o&&(a+e[u-1][0]+e[u-1][1])%t[u-1]==0:o,!0),()=>`input spatial dimensions ${r.shape.slice(1)} with paddings ${e.toString()} must be divisible by blockShapes ${t.toString()}`),fe.runKernel(rv,{x:r},{blockShape:t,paddings:e})}}),EV=he({pool_:function cae(n,t,e,r,s,i,o){null==s&&(s=[1,1]),null==i&&(i=1),0===r&&(r="valid");const a=ee(n,"x","maxPool");let u=a,c=!1;3===a.rank&&(c=!0,u=be(a,[1,a.shape[0],a.shape[1],a.shape[2]])),J(vs(i,s),()=>`Error in pool: Either strides or dilations must be 1. Got strides ${i} and dilations '${s}'`);const p=vo(u.shape,t,i,s,r),m=[p.dilationHeight,p.dilationWidth];let y;y="same"===r?function hae(n,t){const r=n.map((o,a)=>o+(o-1)*(t[a]-1)).map(o=>o-1),s=r.map(o=>Math.floor(o/2)),i=r.map((o,a)=>o-s[a]);return r.map((o,a)=>[s[a],i[a]])}([p.filterHeight,p.filterWidth],m):[[0,0],[0,0]];const _=1===m[0]&&1===m[1],[w,T]=function dae(n,t,e){const r=e.map(p=>p[0]),s=e.map(p=>p[1]),i=n.concat(r,s),o=t.map((p,m)=>(p-i[m]%p)%p),a=s.map((p,m)=>p+o[m]),u=t.map((p,m)=>[r[m],a[m]]),c=t.map((p,m)=>[0,o[m]]);return[u,c]}([p.inHeight,p.inWidth],m,y),I=_?r:"valid",O=_?u:Fv(u,m,w),V=("avg"===e?()=>Cv(O,t,i,I,o):()=>Mv(O,t,i,I,o))(),z=_?V:Iv(V,m,T);return c?be(z,[z.shape[1],z.shape[2],z.shape[3]]):z}}),$v=he({prelu_:function pae(n,t){const e=ee(n,"x","prelu"),r=ee(t,"alpha","prelu");return fe.runKernel(K_,{x:e,alpha:r})}}),DV=he({prod_:function fae(n,t=null,e=!1){let r=ee(n,"x","prod");return"bool"===r.dtype&&(r=pt(r,"int32")),fe.runKernel(X_,{x:r},{axis:t,keepDims:e})}}),gae=he({raggedGather_:function mae(n,t,e,r){const s=n.map((p,m)=>ee(p,`tensors${m}`,"raggedGather","int32")),i=ee(t,"paramsDenseValues","raggedGather"),o=ee(e,"indices","raggedGather","int32"),c=fe.runKernel(PC,{paramsNestedSplits:s,paramsDenseValues:i,indices:o},{outputRaggedRank:r});return{outputNestedSplits:c.slice(0,c.length-1),outputDenseValues:c[c.length-1]}}}),bae=he({raggedRange_:function yae(n,t,e){const r=ee(n,"starts","raggedRange"),s=ee(t,"limits","raggedRange",r.dtype),i=ee(e,"deltas","raggedRange",r.dtype),a=fe.runKernel(FC,{starts:r,limits:s,deltas:i});return{rtNestedSplits:a[0],rtDenseValues:a[1]}}}),vae=he({raggedTensorToTensor_:function _ae(n,t,e,r,s){const i=ee(n,"shape","raggedTensorToTensor","int32"),o=ee(t,"values","raggedTensorToTensor"),a=ee(e,"defaultValue","raggedTensorToTensor",o.dtype),u=r.map((m,y)=>ee(m,`tensors${y}`,"raggedTensorToTensor","int32"));return fe.runKernel($C,{shape:i,values:o,defaultValue:a,rowPartitionTensors:u},{rowPartitionTypes:s})}}),xae=he({rand_:function wae(n,t,e){zi(n);const r=Fe(n);let s=null;if(null==e||"float32"===e)s=new Float32Array(r);else if("int32"===e)s=new Int32Array(r);else{if("bool"!==e)throw new Error(`Unknown data type ${e}`);s=new Uint8Array(r)}for(let i=0;i<r;i++)s[i]=t();return fe.makeTensor(s,n,e)}});var Lv=$(340);class iE{constructor(t,e,r,s,i){this.mean=t,this.stdDev=e,this.dtype=r,this.nextVal=NaN,this.truncated=s,this.truncated&&(this.upper=this.mean+2*this.stdDev,this.lower=this.mean-2*this.stdDev);const o=i||Math.random();this.random=Lv.alea(o.toString())}nextValue(){if(!isNaN(this.nextVal)){const s=this.nextVal;return this.nextVal=NaN,s}let t,e,r=!1;for(;!r;){let s,i,o;do{s=2*this.random()-1,i=2*this.random()-1,o=s*s+i*i}while(o>=1||0===o);const a=Math.sqrt(-2*Math.log(o)/o);t=this.mean+this.stdDev*s*a,e=this.mean+this.stdDev*i*a,(!this.truncated||this.isValidTruncated(t))&&(r=!0)}return(!this.truncated||this.isValidTruncated(e))&&(this.nextVal=this.convertValue(e)),this.convertValue(t)}convertValue(t){return null==this.dtype||"float32"===this.dtype?t:Math.round(t)}isValidTruncated(t){return t<=this.upper&&t>=this.lower}}class Tae{constructor(t,e,r,s){this.alpha=t,this.beta=1/e,this.dtype=r;const i=s||Math.random();this.randu=Lv.alea(i.toString()),this.randn=new iE(0,1,r,!1,this.randu()),this.d=t<1?t+2/3:t-1/3,this.c=1/Math.sqrt(9*this.d)}nextValue(){let t,e,r,s,i,o;for(;;){do{s=this.randn.nextValue(),o=1+this.c*s}while(o<=0);if(o*=o*o,t=s*s,e=1-.331*t*t,r=.5*t+this.d*(1-o+Math.log(o)),i=this.randu(),i<e||Math.log(i)<r)break}return o*=1/this.beta*this.d,this.alpha<1&&(o*=Math.pow(this.randu(),1/this.alpha)),this.convertValue(o)}convertValue(t){return"float32"===this.dtype?t:Math.round(t)}}class Sae{constructor(t=0,e=1,r,s){if(this.canReturnFloat=()=>null==this.dtype||"float32"===this.dtype,this.min=t,this.range=e-t,this.dtype=r,null==s&&(s=Math.random()),"number"==typeof s&&(s=s.toString()),!this.canReturnFloat()&&this.range<=1)throw new Error(`The difference between ${t} - ${e} <= 1 and dtype is not float`);this.random=Lv.alea(s)}convertValue(t){return this.canReturnFloat()?t:Math.round(t)}nextValue(){return this.convertValue(this.min+this.range*this.random())}}const Aae=he({randomGamma_:function Dae(n,t,e=1,r="float32",s){if(zi(n),null==e&&(e=1),null==r&&(r="float32"),"float32"!==r&&"int32"!==r)throw new Error(`Unsupported data type ${r}`);const i=new Tae(t,e,r,s),o=tn(n,r);for(let a=0;a<o.values.length;a++)o.values[a]=i.nextValue();return o.toTensor()}}),aE=he({randomNormal_:function kae(n,t=0,e=1,r,s){if(zi(n),null!=r&&"bool"===r)throw new Error(`Unsupported data type ${r}`);const i=new iE(t,e,r,!1,s),o=tn(n,r);for(let a=0;a<o.values.length;a++)o.values[a]=i.nextValue();return o.toTensor()}}),Oae=he({randomStandardNormal_:function Nae(n,t,e){if(null!=t&&"bool"===t)throw new Error(`Unsupported data type ${t}`);return aE(n,0,1,t,e)}}),Cc=he({randomUniform_:function Rae(n,t=0,e=1,r="float32",s){zi(n);const i=tn(n,r),o=new Sae(t,e,null,s);for(let a=0;a<i.values.length;a++)i.values[a]=o.nextValue();return i.toTensor()}}),Pae=he({randomUniformInt_:function Mae(n,t,e,r){return Cc(n,t,e,"int32",r)}});function Dh(n,t,e=1,r="float32"){if(0===e)throw new Error("Cannot have a step of zero");return fe.runKernel(LC,{},{start:n,stop:t,step:e,dtype:r})}const eg=he({real_:function Fae(n){const e={input:ee(n,"input","real")};return fe.runKernel(VC,e)}}),AV=he({reciprocal_:function $ae(n){const e={x:ee(n,"x","reciprocal")};return fe.runKernel(vm,e)}}),Na=he({relu_:function Lae(n){const e={x:ee(n,"x","relu")};return fe.runKernel(wm,e)}}),lE=he({relu6_:function Vae(n){const e={x:ee(n,"x","relu6")};return fe.runKernel(xm,e)}}),To=he({reverse_:function Bae(n,t){const r={x:ee(n,"x","reverse")};return fe.runKernel(J_,r,{dims:t})}}),Uae=he({reverse1d_:function zae(n){const t=ee(n,"x","reverse");return J(1===t.rank,()=>`Error in reverse1D: x must be rank 1 but got rank ${t.rank}.`),To(t,0)}}),Gae=he({reverse2d_:function jae(n,t){const e=ee(n,"x","reverse");return J(2===e.rank,()=>`Error in reverse2D: x must be rank 2 but got rank ${e.rank}.`),To(e,t)}}),Hae=he({reverse3d_:function Wae(n,t){const e=ee(n,"x","reverse");return J(3===e.rank,()=>`Error in reverse3D: x must be rank 3 but got rank ${e.rank}.`),To(e,t)}}),Kae=he({reverse4d_:function qae(n,t){const e=ee(n,"x","reverse");return J(4===e.rank,()=>`Error in reverse4D: x must be rank 4 but got rank ${e.rank}.`),To(e,t)}}),uE=he({round_:function Xae(n){const e={x:ee(n,"x","round")};return fe.runKernel(Tm,e)}}),cE=he({rsqrt_:function Yae(n){const e={x:ee(n,"x","rsqrt","float32")};return fe.runKernel(Sm,e)}}),dE=he({selu_:function Zae(n){const e={x:ee(n,"x","selu")};return fe.runKernel(Cm,e)}}),hE=he({separableConv2d_:function Qae(n,t,e,r,s,i=[1,1],o="NHWC"){const a=ee(n,"x","separableConv2d"),u=ee(t,"depthwiseFilter","separableConv2d"),c=ee(e,"pointwiseFilter","separableConv2d");let p=a,m=!1;if(3===a.rank&&(m=!0,p=be(a,[1,a.shape[0],a.shape[1],a.shape[2]])),"NCHW"===o)throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");J(4===p.rank,()=>`Error in separableConv2d: input must be rank 4, but got rank ${p.rank}.`),J(4===u.rank,()=>`Error in separableConv2d: depthwise filter must be rank 4, but got rank ${u.rank}.`),J(4===c.rank,()=>`Error in separableConv2d: pointwise filter must be rank 4, but got rank ${u.rank}.`),J(1===c.shape[0],()=>`Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got ${c.shape[0]}.`),J(1===c.shape[1],()=>`Error in separableConv2d: the second dimension of pointwise filter must be 1, but got ${c.shape[1]}.`);const y=u.shape[2],_=u.shape[3];J(c.shape[2]===y*_,()=>`Error in separableConv2d: the third dimension of pointwise filter must be ${y*_}, but got ${c.shape[2]}.`);const w=qm(p,u,r,s,o,i),I=hu(w,c,1,"valid",o);return m?be(I,[I.shape[1],I.shape[2],I.shape[3]]):I}});function pE(){return(pE=Ve(function*(n,t){const e=ee(n,"x","setdiff1d"),r=ee(t,"y","setdiff1d");J(e.dtype===r.dtype,()=>`x and y should have the same dtype, but got x (${e.dtype}) and y (${r.dtype}).`),J(1===e.rank,()=>`x should be 1D tensor, but got x (${e.shape}).`),J(1===r.rank,()=>`y should be 1D tensor, but got y (${r.shape}).`);const s=yield e.data(),i=yield r.data(),o=new Set(i);let a=0;for(let p=0;p<s.length;p++)o.has(s[p])||a++;const u=new qr([a],e.dtype),c=new qr([a],"int32");for(let p=0,m=0;p<s.length;p++)o.has(s[p])||(u.values[m]=s[p],c.values[m]=p,m++);return[u.toTensor(),c.toTensor()]})).apply(this,arguments)}const ele=function Jae(n,t){return pE.apply(this,arguments)},kV=he({sign_:function tle(n){const e={x:ee(n,"x","sign")};return fe.runKernel(Dm,e)}}),fE=he({sin_:function nle(n){const e={x:ee(n,"x","sin","float32")};return fe.runKernel(Im,e)}}),mE=he({sinh_:function rle(n){const e={x:ee(n,"x","sinh")};return fe.runKernel(Em,e)}}),Vv=he({slice1d_:function sle(n,t,e){const r=ee(n,"x","slice1d");return J(1===r.rank,()=>`slice1d expects a rank-1 tensor, but got a rank-${r.rank} tensor`),gn(r,[t],[e])}}),gE=he({slice2d_:function ile(n,t,e){const r=ee(n,"x","slice2d");return J(2===r.rank,()=>`slice2d expects a rank-2 tensor, but got a rank-${r.rank} tensor`),gn(r,t,e)}}),Bv=he({slice3d_:function ole(n,t,e){const r=ee(n,"x","slice3d");return J(3===r.rank,()=>`slice3d expects a rank-3 tensor, but got a rank-${r.rank} tensor`),gn(r,t,e)}}),tg=he({slice4d_:function ale(n,t,e){const r=ee(n,"x","slice4d");return J(4===r.rank,()=>`slice4d expects a rank-4 tensor, but got a rank-${r.rank} tensor`),gn(r,t,e)}}),zv=he({softmax_:function lle(n,t=-1){const e=ee(n,"logits","softmax","float32");if(-1===t&&(t=e.rank-1),t!==e.rank-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${e.rank} and dim was ${t}`);return fe.runKernel(iv,{logits:e},{dim:t})}}),Uv=he({fft_:function ule(n){return J("complex64"===n.dtype,()=>`The dtype for tf.spectral.fft() must be complex64 but got ${n.dtype}.`),fe.runKernel("FFT",{input:n})}}),ng=he({ifft_:function cle(n){return J("complex64"===n.dtype,()=>`The dtype for tf.spectral.ifft() must be complex64 but got ${n.dtype}.`),fe.runKernel(SC,{input:n})}}),yE=he({irfft_:function dle(n){const t=n.shape[n.shape.length-1],e=n.size/t;let r;if(t<=2){const s=be(n,[e,t]);r=ng(s)}else{const s=[e,2*(t-1)],i=be(eg(n),[e,t]),o=be(Av(n),[e,t]),a=To(gn(i,[0,1],[e,t-2]),1),u=me(To(gn(o,[0,1],[e,t-2]),1),Rt(-1)),c=Vr([i,a],1),p=Vr([o,u],1),m=be(iu(c,p),[s[0],s[1]]);r=ng(m)}if(r=eg(r),3===n.rank&&0!==n.shape[0]){const s=r,i=n.shape[0];r=be(r,[i,r.shape[0]/i,r.shape[1]]),s.dispose()}return r}}),Ii=he({split_:function hle(n,t,e=0){const s={x:ee(n,"x","split")};return fe.runKernel(sv,s,{numOrSizeSplits:t,axis:e})}}),jv=he({rfft_:function ple(n,t){J("float32"===n.dtype,()=>`The dtype for rfft() must be real value but got ${n.dtype}`);let e=n.shape[n.shape.length-1];const r=n.size/e;let s;if(null!=t&&t<e){const w=n.shape.map(I=>0),T=n.shape.map(I=>I);T[n.shape.length-1]=t,s=gn(n,w,T),e=t}else if(null!=t&&t>e){const w=n.shape.map(T=>T);w[n.shape.length-1]=t-e,s=Vr([n,Yr(w)],n.shape.length-1),e=t}else s=n;const i=mn(s),o=be(iu(s,i),[r,e]),a=Uv(o),u=Math.floor(e/2)+1,c=eg(a),p=Av(a),m=Ii(c,[u,e-u],c.shape.length-1),y=Ii(p,[u,e-u],p.shape.length-1),_=s.shape.slice();return _[s.shape.length-1]=u,be(iu(m[0],y[0]),_)}}),bE=he({squaredDifference_:function fle(n,t){let e=ee(n,"a","squaredDifference"),r=ee(t,"b","squaredDifference");return[e,r]=vr(e,r),Ht(e.shape,r.shape),fe.runKernel(Om,{a:e,b:r},{})}}),Ic=he({squeeze_:function mle(n,t){const e=ee(n,"x","squeeze","string_or_numeric");return be(e,Xl(e.shape,t).newShape)}}),qi=he({stack_:function gle(n,t=0){const e=yv(n,"tensors","stack","string_or_numeric");return J(e.length>=1,()=>"Pass at least one tensor to tf.stack"),e.length>0&&J(t<=e[0].rank,()=>"Axis must be <= rank of the tensor"),fe.runKernel(H_,e,{axis:t})}}),Ah=he({step_:function yle(n,t=0){const r={x:ee(n,"x","step")};return fe.runKernel($m,r,{alpha:t})}}),NV=he({stridedSlice_:function ble(n,t,e,r,s=0,i=0,o=0,a=0,u=0){const p={x:ee(n,"x","stridedSlice","string_or_numeric")};return fe.runKernel(ZC,p,{begin:t,end:e,strides:r,beginMask:s,endMask:i,ellipsisMask:o,newAxisMask:a,shrinkAxisMask:u})}}),OV=he({tan_:function _le(n){const e={x:ee(n,"x","tan","float32")};return fe.runKernel(Mm,e)}});function oi(n,t){oh(n);const e=su(n,t);if(1!==e.length)throw new Error("tensor1d() requires values to be a flat/TypedArray");return ou(n,null,e,t)}function kh(n,t,e){if(oh(n),null!=t&&2!==t.length)throw new Error("tensor2d() requires shape to have two numbers");const r=su(n,e);if(2!==r.length&&1!==r.length)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(1===r.length&&null==t)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return ou(n,t,r,e)}function vle(n,t,e){if(oh(n),null!=t&&3!==t.length)throw new Error("tensor3d() requires shape to have three numbers");const r=su(n,e);if(3!==r.length&&1!==r.length)throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");if(1===r.length&&null==t)throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");return ou(n,t,r,e)}function wle(n,t,e){if(oh(n),null!=t&&4!==t.length)throw new Error("tensor4d() requires shape to have four numbers");const r=su(n,e);if(4!==r.length&&1!==r.length)throw new Error("tensor4d() requires values to be number[][][][] or flat/TypedArray");if(1===r.length&&null==t)throw new Error("tensor4d() requires shape to be provided when `values` are a flat array");return ou(n,t,r,e)}function xle(n,t,e){if(oh(n),null!=t&&5!==t.length)throw new Error("tensor5d() requires shape to have five numbers");const r=su(n,e);if(5!==r.length&&1!==r.length)throw new Error("tensor5d() requires values to be number[][][][][] or flat/TypedArray");if(1===r.length&&null==t)throw new Error("tensor5d() requires shape to be provided when `values` are a flat array");return ou(n,t,r,e)}function Tle(n,t,e){if(oh(n),null!=t&&6!==t.length)throw new Error("tensor6d() requires shape to have six numbers");const r=su(n,e);if(6!==r.length&&1!==r.length)throw new Error("tensor6d() requires values to be number[][][][][][] or flat/TypedArray");if(1===r.length&&null==t)throw new Error("tensor6d() requires shape to be provided when `values` are a flat array");return ou(n,t=t||r,r,e)}function RV(n,t,e){const r=t.rank>1?t.shape[t.rank-1]:1,s=t.rank>1?t.rank-1:1,i=`Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${e.shape}, indices.shape: ${t.shape}, shape: ${n}, sliceDim: ${r}, and batchDim: ${s}.`;if(e.rank<s)throw new Error(i+` update.rank < ${s}. `);if(n.length<r+(e.rank-s))throw new Error(i+` Output shape length < ${r+(e.rank-s)}`);if(e.rank!==s+n.length-r)throw new Error(i+" update.rank != "+(s+n.length-r));for(let o=0;o<s;++o)if(e.shape[o]!==t.shape[o])throw new Error(i+` updates.shape[${o}] (${e.shape[o]}) != indices.shape[${o}] (${t.shape[o]}).`);for(let o=0;o<e.rank-s;++o)if(e.shape[o+s]!==n[o+r])throw new Error(i+` updates.shape[${o+s}] (${e.shape[o+s]}) != shape[${o+s}] (${n[o+s]})`)}function _E(n,t,e){if(t.rank<1)throw new Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${t.rank}.`);if(n.rank<1)throw new Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${n.rank}.`);if("int32"!==t.dtype)throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${t.dtype}`);if(e.length<1)throw new Error(`Output rank must be greater or equal to 1, but got shape: ${e}`);if(0===e.length){if(0===t.size)throw new Error(`Indices specified for empty output. indices shape: ${t.shape}`);if(0===n.size)throw new Error(`Updates specified for empty output. updates shape: ${n.shape}`)}RV(e,t,n)}function Ec(n,t,e){const r=t.shape.length,s=r>1?t.shape[r-1]:1,i=e.length;let o=1;for(let m=s;m<i;++m)o*=e[m];const a=s<1?1:s;return{sliceRank:s,numUpdates:Fe(t.shape)/a,sliceSize:o,strides:[...Nt(e.slice(0,s)),1],outputSize:Fe(e)}}const Cle=he({tensorScatterUpdate_:function Sle(n,t,e){const r=ee(n,"tensor","tensorScatterupdate"),s=ee(t,"indices","tensorScatterupdate","int32"),i=ee(e,"updates","tensorScatterupdate");if(_E(i,s,r.shape),r.dtype!==i.dtype)throw new Error(`tensor and updates must have the same dtype, instead they are ${r.dtype} and ${i.dtype}.`);return fe.runKernel(jC,{tensor:r,indices:s,updates:i},{})}}),MV=he({topk_:function Ile(n,t=1,e=!0){const r=ee(n,"x","topk");if(0===r.rank)throw new Error("topk() expects the input to be of rank 1 or higher");const s=r.shape[r.shape.length-1];if(t<0)throw new Error(`'k' passed to topk() must be >= 0 but got ${t}`);if(t>s)throw new Error(`'k' passed to topk() must be <= the last dimension (${s}) but got ${t}`);const i={x:r},o={k:t,sorted:e},[a,u]=fe.runKernel(tI,i,o);return{values:a,indices:u}}}),vE=he({truncatedNormal_:function Ele(n,t=0,e=1,r,s){if(zi(n),null!=r&&"bool"===r)throw new Error("Unsupported data type $ { dtype }");const i=new iE(t,e,r,!0,s),o=tn(n,r);for(let a=0;a<o.values.length;a++)o.values[a]=i.nextValue();return o.toTensor()}}),PV=he({unique_:function Dle(n,t=0){const e=ee(n,"x","unique","string_or_numeric");J(e.rank>0,()=>"The input tensor must be at least 1D");const r={x:e},s={axis:t},[i,o]=fe.runKernel(rI,r,s);return{values:i,indices:o}}}),wE=he({unsortedSegmentSum_:function Ale(n,t,e){const r=ee(n,"x","unsortedSegmentSum"),s=ee(t,"segmentIds","unsortedSegmentSum","int32");return J(ah(e),()=>"numSegments must be of dtype int"),fe.runKernel(lv,{x:r,segmentIds:s},{numSegments:e})}}),So=he({unstack_:function kle(n,t=0){const e=ee(n,"x","unstack","string_or_numeric");return J(t>=-e.shape.length&&t<e.shape.length,()=>`Axis = ${t} is not in [-${e.shape.length}, ${e.shape.length})`),fe.runKernel(av,{value:e},{axis:t})}});function Nle(n,t){return rE(n,t,"right")}function FV(n,t=!0,e,r){return fe.makeVariable(n,t,e,r)}function xE(n,t){const e=[];for(let i=0;i<t.length;i++)t[i]&&e.push(i);const r=tn(n,"int32"),s=tn([e.length,n.length],"int32");for(let i=0;i<e.length;i++){const o=r.indexToLoc(e[i]);s.values.set(o,i*n.length)}return s.toTensor()}function TE(){return(TE=Ve(function*(n){const t=ee(n,"condition","whereAsync","bool"),e=yield t.data(),r=xE(t.shape,e);return n!==t&&t.dispose(),r})).apply(this,arguments)}const $V=function Ole(n){return TE.apply(this,arguments)};function SE(){return(SE=Ve(function*(n,t,e){const r=ee(n,"tensor","boolMask"),s=ee(t,"mask","boolMask","bool"),i=e??0,o=s.rank,a=r.shape;J(o>0,()=>"mask cannot be scalar"),xi(a.slice(i,i+o),s.shape,"mask's shape must match the first K dimensions of tensor's shape,");let u=1;for(let T=i;T<i+o;T++)u*=a[T];const c=a.slice(0,i).concat([u],a.slice(i+o)),p=be(r,c),m=be(s,[-1]),y=yield $V(m),_=Ic(y,[1]),w=Qm(p,_,i);return n!==r&&r.dispose(),t!==s&&s.dispose(),_.dispose(),p.dispose(),m.dispose(),y.dispose(),w})).apply(this,arguments)}const Mle=function Rle(n,t,e){return SE.apply(this,arguments)},yn=he({transpose_:function Ple(n,t,e){const r=ee(n,"x","transpose");if(null==t&&(t=r.shape.map((o,a)=>a).reverse()),J(r.rank===t.length,()=>`Error in transpose: rank of input ${r.rank} must match length of perm ${t}.`),t.forEach(o=>{J(o>=0&&o<r.rank,()=>`All entries in 'perm' must be between 0 and ${r.rank-1} but got ${t}`)}),r.rank<=1)return r.clone();const s={x:r},i={perm:t};return"complex64"===r.dtype?Ce(()=>{let o=eg(r),a=Av(r);return o=fe.runKernel(hh,{x:o},i),a=fe.runKernel(hh,{x:a},i),e&&(a=Zn(a)),iu(o,a)}):fe.runKernel(hh,s,i)}}),$le=he({movingAverage_:function Fle(n,t,e,r,s=!0){const i=ee(n,"v","movingAverage"),o=ee(t,"x","movingAverage"),a=ee(e,"decay","movingAverage");(function fre(n,t){J(n.dtype===t.dtype,()=>`The dtypes of the first(${n.dtype}) and second(${t.dtype}) input must match`)})(i,o),J(hn(i.shape,o.shape),()=>"Shape mismatch in v and x");const u=Rt(1),c=vt(u,a);let p=me(vt(o,i),c);if(s){J(null!=r,()=>"When using zeroDebias: true, step is required.");const m=ee(r,"step","movingAverage");p=At(p,vt(u,uu(a,m)))}return Ze(i,p)}}),Vle=he({scatterND_:function Lle(n,t,e){zi(e);const r=ee(n,"indices","scatterND","int32"),s=ee(t,"updates","scatterND");return _E(s,r,e),fe.runKernel(UC,{indices:r,updates:s},{shape:e})}}),Ule=he({sparseToDense_:function zle(n,t,e,r=0){zi(e);const s=ee(n,"sparseIndices","sparseToDense","int32"),i=ee(t,"sparseValues","sparseToDense","string_or_numeric"),o=ee(r,"defaultValue","sparseToDense",i.dtype);return function Ble(n,t,e,r){if("int32"!==n.dtype)throw new Error(`tf.sparseToDense() expects the indices to be int32 type, but the dtype was ${n.dtype}.`);if(n.rank>2)throw new Error(`sparseIndices should be a scalar, vector, or matrix, but got shape ${n.shape}.`);const s=n.rank>0?n.shape[0]:1,i=n.rank>1?n.shape[1]:1;if(e.length!==i)throw new Error(`outputShape has incorrect number of elements:, ${e.length}, should be: ${i}.`);if(0!==t.rank&&(1!==t.rank||t.size!==s))throw new Error(`sparseValues has incorrect shape ${t.shape}, should be [] or [${s}]`);if(t.dtype!==r.dtype)throw new Error("sparseValues.dtype must match defaultValues.dtype")}(s,i,e,o),fe.runKernel(XC,{sparseIndices:s,sparseValues:i,defaultValue:o},{outputShape:e})}}),Gle=he({gatherND_:function jle(n,t){const e=ee(t,"indices","gatherND","int32"),s={params:ee(n,"x","gatherND","string_or_numeric"),indices:e};return fe.runKernel(TC,s)}}),LV=he({dropout_:function Hle(n,t,e,r){const s=ee(n,"x","dropout");if(J("float32"===s.dtype,()=>`x has to be a floating point tensor since it's going to be scaled, but got a ${s.dtype} tensor instead.`),J(t>=0&&t<1,()=>`rate must be a float in the range [0, 1), but got ${t}.`),0===t)return n instanceof nr?s.clone():s;const i=function Wle(n,t){if(null==t)return n.shape.slice();if(hn(n.shape,t))return t;if(n.shape.length===t.length){const e=[];for(let r=0;r<n.shape.length;r++)e.push(null==t[r]&&null!=n.shape[r]?n.shape[r]:t[r]);return e}return t}(s,e),o=1-t,a=At(Zm(Ze(Cc(i,0,1,"float32",r),o)),o);return me(s,a)}});function VV(n){return Math.floor(Math.pow(2,Math.ceil(Math.log(n)/Math.log(2))))}function CE(n,t,e){const r=1-n%2,s=new Float32Array(n);for(let i=0;i<n;++i){const o=2*Math.PI*i/(n+r-1);s[i]=t-e*Math.cos(o)}return oi(s,"float32")}function IE(){return(IE=Ve(function*(n,t,e=1){const r=ee(n,"predictions","inTopK"),s=ee(t,"targets","inTopK");J(r.rank>1,()=>`inTopK() expects the predictions to be of rank 2 or higher, but got ${r.rank}`),J(r.rank-1===s.rank,()=>`predictions rank should be 1 larger than targets rank, but got predictions rank ${r.rank} and targets rank ${s.rank}`),xi(r.shape.slice(0,r.shape.length-1),s.shape,"predictions's shape should be align with the targets' shape, except the last dimension.");const i=r.shape[r.shape.length-1];J(e>0&&e<=i,()=>`'k' passed to inTopK() must be > 0 && <= the predictions last dimension (${i}), but got ${e}`);const o=yield r.data(),a=yield s.data(),[u,c]=[o.length/i,i],p=_s("bool",u);for(let m=0;m<u;m++){const y=m*c,_=o.subarray(y,y+c),w=[];for(let T=0;T<_.length;T++)w.push({value:_[T],index:T});w.sort((T,I)=>I.value-T.value),p[m]=0;for(let T=0;T<e;T++)if(w[T].index===a[m]){p[m]=1;break}}return n!==r&&r.dispose(),t!==s&&s.dispose(),Yo(p,s.shape,"bool")})).apply(this,arguments)}const Kle=function qle(n,t){return IE.apply(this,arguments)},EE=he({conv2DBackpropFilter_:function Xle(n,t,e,r,s,i="NHWC",o){let a=n;3===n.rank&&(a=be(n,[1,n.shape[0],n.shape[1],n.shape[2]]));let u=t;3===u.rank&&(u=be(t,[1,t.shape[0],t.shape[1],t.shape[2]])),J(4===a.rank,()=>`Error in conv2dDerFilter: input must be rank 4, but got shape ${a.shape}.`),J(4===u.rank,()=>`Error in conv2dDerFilter: dy must be rank 4, but got shape ${u.shape}.`),J(4===e.length,()=>`Error in conv2dDerFilter: filterShape must be length 4, but got ${e}.`);const c="NHWC"===i?a.shape[3]:a.shape[1],p="NHWC"===i?u.shape[3]:u.shape[1];return J(c===e[2],()=>`Error in conv2dDerFilter: depth of input ${c}) must match input depth in filter (${e[2]}.`),J(p===e[3],()=>`Error in conv2dDerFilter: depth of dy (${p}) must match output depth for filter (${e[3]}).`),js("conv2dDerFilter",s,o),fe.runKernel(oC,{x:a,dy:u},{strides:r,pad:s,dataFormat:i,dimRoundingMode:o,filterShape:e})}});function Gv(n,t,e){if(null==e||"linear"===e)return n;if("relu"===e)return me(n,Ah(t));throw new Error(`Cannot compute gradient for fused activation ${e}.`)}function Wv(n,t){let e=t;const r=Xr(n.shape,t.shape);return r.length>0&&(e=Tt(e,r)),be(e,n.shape)}function Hv(n,t,e,r){if("linear"===t)return n;if("relu"===t)return Na(n);if("elu"===t)return Km(n);if("relu6"===t)return lE(n);if("prelu"===t)return $v(n,e);if("leakyrelu"===t)return kv(n,r);if("sigmoid"===t)return Aa(n);throw new Error(`Unknown fused activation ${t}.`)}const qv=(n,t)=>!(n>0)||"linear"===t,BV=he({fusedConv2d_:function Yle({x:n,filter:t,strides:e,pad:r,dataFormat:s="NHWC",dilations:i=[1,1],dimRoundingMode:o,bias:a,activation:u="linear",preluActivationWeights:c,leakyreluAlpha:p}){if(!1===qv(fe.state.gradientDepth,u=u||"linear")){J("NHWC"===s,()=>`Error in fused conv2d: got dataFormat of ${s} but only NHWC is currently supported for the case of gradient depth is 0 and the activation is not linear.`);let Q=hu(n,t,e,r,s,i,o);return null!=a&&(Q=Ze(Q,a)),Hv(Q,u,c,p)}const m=ee(n,"x","conv2d","float32"),y=ee(t,"filter","conv2d","float32");let _=m,w=!1;3===m.rank&&(w=!0,_=be(m,[1,m.shape[0],m.shape[1],m.shape[2]])),J(4===_.rank,()=>`Error in fused conv2d: input must be rank 4, but got rank ${_.rank}.`),J(4===y.rank,()=>`Error in fused conv2d: filter must be rank 4, but got rank ${y.rank}.`),js("fused conv2d",r,o);const T="NHWC"===s?_.shape[3]:_.shape[1];J(y.shape[2]===T,()=>`Error in conv2d: depth of input (${T}) must match input depth for filter ${y.shape[2]}.`),J(vs(e,i),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${e} and dilations '${i}'`);const I=ls(_.shape,y.shape,e,i,r,o);let O,M;if(null!=a&&(O=ee(a,"bias","fused conv2d"),[O]=vr(O,m),"NHWC"===s?Ht(I.outShape,O.shape):(J(O.shape.length<=1,()=>`Error in fused conv2d: only supports scalar or 1-D Tensor bias for NCHW format but got the bias of rank-${O.shape.length}.`),J(0===O.shape.length||O.shape[0]===I.outChannels||1===O.shape[0],()=>`Error in fused conv2d: bias shape (${O.shape}) is not compatible with the number of output channels (${I.outChannels})`))),null!=c){const Q=c.shape;if(J(Q.length<=1||3===Q.length,()=>`Error in fused conv2d: only supports scalar, 1-D Tensor or 3-D Tensor PReLU activation weights but got a tensor of rank-${Q.length}.`),1===Q.length)J(1===Q[0]||Q[0]===I.outChannels,()=>`Error in fused conv2d: PReLU activation weights (${Q}) is not compatible with the number of output channels (${I.outChannels}).`);else if(3===Q.length)try{Ht(Q,I.outShape)}catch{throw Error(`Error in fused conv2d: PReLU activation weights (${Q}) is not compatible with the output shape of the conv2d (${I.outShape}).`)}M=ee(c,"prelu weights","fused conv2d")}const V=(Q,ne)=>{J("NHWC"===s,()=>`Error in gradient of fused conv2D: got dataFormat of ${s} but only NHWC is currently supported.`);const[oe,de,pe,Te]=ne,Ae=Gv(Q,pe,u);J(du(i),()=>`Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${i}'`);const Pe=[qI(de.shape,Ae,oe,e,r),EE(de,Ae,oe.shape,e,r)];if(null!=Te){const ve=Wv(Te,Ae);Pe.push(ve)}return Pe},z={x:_,filter:y,bias:O,preluActivationWeights:M},G={strides:e,pad:r,dataFormat:s,dilations:i,dimRoundingMode:o,activation:u,leakyreluAlpha:p};return null==a?dl((ne,oe,de)=>{let pe=fe.runKernel(dv,z,G);return de([oe,ne,pe]),w&&(pe=be(pe,[pe.shape[1],pe.shape[2],pe.shape[3]])),{value:pe,gradFunc:V}})(_,y):dl((ne,oe,de,pe)=>{let Te=fe.runKernel(dv,z,G);return pe([oe,ne,Te,de]),w&&(Te=be(Te,[Te.shape[1],Te.shape[2],Te.shape[3]])),{value:Te,gradFunc:V}})(_,y,O)}}),zV=he({depthwiseConv2dNativeBackpropFilter_:function Zle(n,t,e,r,s,i=[1,1],o){let a=n;3===n.rank&&(a=be(n,[1,n.shape[0],n.shape[1],n.shape[2]]));let u=t;return 3===u.rank&&(u=be(t,[1,t.shape[0],t.shape[1],t.shape[2]])),fe.runKernel(pC,{x:a,dy:u},{strides:r,pad:s,dimRoundingMode:o,dilations:i,filterShape:e})}}),UV=he({depthwiseConv2dNativeBackpropInput_:function Qle(n,t,e,r,s,i=[1,1],o){let a=t,u=!1;3===t.rank&&(u=!0,a=be(t,[1,t.shape[0],t.shape[1],t.shape[2]]));const m=fe.runKernel(fC,{dy:a,filter:e},{strides:r,pad:s,dimRoundingMode:o,dilations:i,inputShape:n});return u?be(m,[m.shape[1],m.shape[2],m.shape[3]]):m}}),eue=he({fusedDepthwiseConv2d_:function Jle({x:n,filter:t,strides:e,pad:r,dataFormat:s="NHWC",dilations:i=[1,1],dimRoundingMode:o,bias:a,activation:u="linear",preluActivationWeights:c,leakyreluAlpha:p}){if(!1===qv(fe.state.gradientDepth,u)){let G=qm(n,t,e,r,s,i,o);return null!=a&&(G=Ze(G,a)),Hv(G,u,c,p)}const m=ee(n,"x","depthwiseConv2d","float32"),y=ee(t,"filter","depthwiseConv2d","float32");let _=m,w=!1;3===m.rank&&(w=!0,_=be(m,[1,m.shape[0],m.shape[1],m.shape[2]])),J(4===_.rank,()=>`Error in fused depthwiseConv2d: input must be rank 4, but got rank ${_.rank}.`),J(4===y.rank,()=>`Error in fused depthwiseConv2d: filter must be rank 4, but got rank ${y.rank}.`),J(_.shape[3]===y.shape[2],()=>`Error in fused depthwiseConv2d: number of input channels (${_.shape[3]}) must match the inChannels dimension in filter ${y.shape[2]}.`),null==i&&(i=[1,1]),J(vs(e,i),()=>`Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides ${e} and dilations '${i}'`),js("fused depthwiseConv2d",r,o);const T=ls(_.shape,y.shape,e,i,r,o,!0);let I,O;null!=a&&(I=ee(a,"bias","fused conv2d"),[I]=vr(I,m),Ht(T.outShape,I.shape)),null!=c&&(O=ee(c,"prelu weights","fused depthwiseConv2d"));const M=(G,Q)=>{J(du(i),()=>`Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '${i}'`);const[ne,oe,de,pe]=Q,Te=Gv(G,de,u),Ae=UV(oe.shape,Te,ne,e,r,i,o),Oe=zV(oe,Te,ne.shape,e,r,i,o);return null!=pe?[Ae,Oe,Wv(I,Te)]:[Ae,Oe]},V={x:_,filter:y,bias:I,preluActivationWeights:O},z={strides:e,pad:r,dataFormat:s,dilations:i,dimRoundingMode:o,activation:u,leakyreluAlpha:p};return null==a?dl((Q,ne,oe)=>{let de=fe.runKernel(hv,V,z);return oe([ne,Q,de]),w&&(de=be(de,[de.shape[1],de.shape[2],de.shape[3]])),{value:de,gradFunc:M}})(_,y):dl((Q,ne,oe,de)=>{let pe=fe.runKernel(hv,V,z);return de([ne,Q,pe,oe]),w&&(pe=be(pe,[pe.shape[1],pe.shape[2],pe.shape[3]])),{value:pe,gradFunc:M}})(_,y,I)}}),DE=he({fusedMatMul_:function tue({a:n,b:t,transposeA:e=!1,transposeB:r=!1,bias:s,activation:i="linear",preluActivationWeights:o,leakyreluAlpha:a=.2}){if(!1===qv(fe.state.gradientDepth,i)){let Te=ln(n,t,e,r);return null!=s&&(Te=Ze(Te,s)),Hv(Te,i,o,a)}let u=ee(n,"a","fused matMul"),c=ee(t,"b","fused matMul");[u,c]=vr(u,c);const p=e?u.shape[u.rank-2]:u.shape[u.rank-1],m=r?c.shape[c.rank-1]:c.shape[c.rank-2],y=e?u.shape[u.rank-1]:u.shape[u.rank-2],_=r?c.shape[c.rank-2]:c.shape[c.rank-1],w=u.shape.slice(0,-2),T=c.shape.slice(0,-2),I=Fe(w),O=Fe(T);J(p===m,()=>`Error in fused matMul: inner shapes (${p}) and (${m}) of Tensors with shapes ${u.shape} and ${c.shape} and transposeA=${e} and transposeB=${r} must match.`);const V=Ht(u.shape.slice(0,-2),c.shape.slice(0,-2)).concat([y,_]),z=be(u,e?[I,p,y]:[I,y,p]),G=be(c,r?[O,_,m]:[O,m,_]);let Q,ne;null!=s&&(Q=ee(s,"bias","fused matMul"),[Q]=vr(Q,u),Ht(V,Q.shape)),null!=o&&(ne=ee(o,"prelu weights","fused matMul"));const oe=(Te,Ae)=>{const[Oe,Me,Pe,ve]=Ae,Se=Gv(be(Te,Pe.shape),Pe,i);let xe,ke;return e||r?!e&&r?(xe=ln(Se,Me,!1,!1),ke=ln(Se,Oe,!0,!1)):e&&!r?(xe=ln(Me,Se,!1,!0),ke=ln(Oe,Se,!1,!1)):(xe=ln(Me,Se,!0,!0),ke=ln(Se,Oe,!0,!0)):(xe=ln(Se,Me,!1,!0),ke=ln(Oe,Se,!0,!1)),null!=s?[xe,ke,Wv(ve,Se)]:[xe,ke]},de={a:z,b:G,bias:Q,preluActivationWeights:ne},pe={transposeA:e,transposeB:r,activation:i,leakyreluAlpha:a};return null==s?dl((Ae,Oe,Me)=>{const Pe=fe.runKernel(cv,de,pe);return Me([Ae,Oe,Pe]),{value:be(Pe,V),gradFunc:oe}})(z,G):dl((Ae,Oe,Me,Pe)=>{const ve=fe.runKernel(cv,de,pe);return Pe([Ae,Oe,ve,Me]),{value:be(ve,V),gradFunc:oe}})(z,G,Q)}}),rue=he({hammingWindow_:function nue(n){return CE(n,.54,.46)}}),jV=he({hannWindow_:function sue(n){return CE(n,.5,.5)}}),GV=he({frame_:function iue(n,t,e,r=!1,s=0){let i=0;const o=[];for(;i+t<=n.size;)o.push(gn(n,i,t)),i+=e;if(r)for(;i<n.size;){const a=i+t-n.size,u=Vr([gn(n,i,t-a),vh([a],s)]);o.push(u),i+=e}return 0===o.length?kh([],[0,t]):be(Vr(o),[o.length,t])}}),aue=he({stft_:function oue(n,t,e,r,s=jV){null==r&&(r=VV(t));const i=GV(n,t,e),o=me(i,s(t));return jv(o,r)}}),uue=he({cropAndResize_:function lue(n,t,e,r,s="bilinear",i=0){const o=ee(n,"image","cropAndResize"),a=ee(t,"boxes","cropAndResize","float32"),u=ee(e,"boxInd","cropAndResize","int32"),c=a.shape[0];return J(4===o.rank,()=>`Error in cropAndResize: image must be rank 4,but got rank ${o.rank}.`),J(2===a.rank&&4===a.shape[1],()=>`Error in cropAndResize: boxes must be have size [${c},4] but had shape ${a.shape}.`),J(1===u.rank&&u.shape[0]===c,()=>`Error in cropAndResize: boxInd must be have size [${c}] but had shape ${a.shape}.`),J(2===r.length,()=>`Error in cropAndResize: cropSize must be of length 2, but got length ${r.length}.`),J(r[0]>=1&&r[1]>=1,()=>`cropSize must be atleast [1,1], but was ${r}`),J("bilinear"===s||"nearest"===s,()=>`method must be bilinear or nearest, but was ${s}`),fe.runKernel(cC,{image:o,boxes:a,boxInd:u},{method:s,extrapolationValue:i,cropSize:r})}}),due=he({flipLeftRight_:function cue(n){const t=ee(n,"image","flipLeftRight","float32");return J(4===t.rank,()=>`Error in flipLeftRight: image must be rank 4,but got rank ${t.rank}.`),fe.runKernel(xC,{image:t},{})}}),pue=he({grayscaleToRGB_:function hue(n){const t=ee(n,"image","grayscaleToRGB"),e=t.rank-1,r=t.shape[e];J(t.rank>=2,()=>`Error in grayscaleToRGB: images must be at least rank 2, but got rank ${t.rank}.`),J(1===r,()=>`Error in grayscaleToRGB: last dimension of a grayscale image should be size 1, but got size ${r}.`);const s=new Array(t.rank);return s.fill(1,0,e),s[e]=3,xo(t,s)}}),mue=he({rotateWithOffset_:function fue(n,t,e=0,r=.5){const s=ee(n,"image","rotateWithOffset","float32");return J(4===s.rank,()=>`Error in rotateWithOffset: image must be rank 4,but got rank ${s.rank}.`),fe.runKernel(sI,{image:s},{radians:t,fillValue:e,center:r})}});function Nh(n,t,e,r,s,i){null==r&&(r=.5),null==s&&(s=Number.NEGATIVE_INFINITY),null==i&&(i=0);const o=n.shape[0];return e=Math.min(e,o),J(0<=r&&r<=1,()=>`iouThreshold must be in [0, 1], but was '${r}'`),J(2===n.rank,()=>`boxes must be a 2D tensor, but was of rank '${n.rank}'`),J(4===n.shape[1],()=>`boxes must have 4 columns, but 2nd dimension was ${n.shape[1]}`),J(1===t.rank,()=>"scores must be a 1D tensor"),J(t.shape[0]===o,()=>`scores has incompatible shape with boxes. Expected ${o}, but was ${t.shape[0]}`),J(0<=i&&i<=1,()=>`softNmsSigma must be in [0, 1], but was '${i}'`),{maxOutputSize:e,iouThreshold:r,scoreThreshold:s,softNmsSigma:i}}const yue=he({nonMaxSuppression_:function gue(n,t,e,r=.5,s=Number.NEGATIVE_INFINITY){const i=ee(n,"boxes","nonMaxSuppression","float32"),o=ee(t,"scores","nonMaxSuppression","float32"),a=Nh(i,o,e,r,s);return fe.runKernel(OC,{boxes:i,scores:o},{maxOutputSize:e=a.maxOutputSize,iouThreshold:r=a.iouThreshold,scoreThreshold:s=a.scoreThreshold})}});function bue(n,t,e){const r=function _ue(n,t,e){return function wue(n,t,e){let r=0,s=n.length,i=0,o=!1;for(;r<s;){i=r+(s-r>>>1);const a=e(t,n[i]);a>0?r=i+1:(s=i,o=!a)}return o?r:-r-1}(n,t,e||vue)}(n,t,e);n.splice(r<0?-(r+1):r,0,t)}function vue(n,t){return n>t?1:n<t?-1:0}function AE(n,t,e,r,s){return OE(n,t,e,r,s,0)}function kE(n,t,e,r,s,i){return OE(n,t,e,r,s,0,!1,i,!0)}function NE(n,t,e,r,s,i){return OE(n,t,e,r,s,i,!0)}function OE(n,t,e,r,s,i,o=!1,a=!1,u=!1){const c=[];for(let I=0;I<t.length;I++)t[I]>s&&c.push({score:t[I],boxIndex:I,suppressBeginIndex:0});c.sort(WV);const p=i>0?-.5/i:0,m=[],y=[];for(;m.length<e&&c.length>0;){const I=c.pop(),{score:O,boxIndex:M,suppressBeginIndex:V}=I;if(O<s)break;let z=!1;for(let G=m.length-1;G>=V;--G){const Q=xue(n,M,m[G]);if(Q>=r){z=!0;break}if(I.score=I.score*Tue(r,p,Q),I.score<=s)break}I.suppressBeginIndex=m.length,z||(I.score===O?(m.push(M),y.push(I.score)):I.score>s&&bue(c,I,WV))}const _=m.length,w=e-_;a&&w>0&&(m.push(...new Array(w).fill(0)),y.push(...new Array(w).fill(0)));const T={selectedIndices:m};return o&&(T.selectedScores=y),u&&(T.validOutputs=_),T}function xue(n,t,e){const r=n.subarray(4*t,4*t+4),s=n.subarray(4*e,4*e+4),i=Math.min(r[0],r[2]),o=Math.min(r[1],r[3]),a=Math.max(r[0],r[2]),u=Math.max(r[1],r[3]),c=Math.min(s[0],s[2]),p=Math.min(s[1],s[3]),m=Math.max(s[0],s[2]),y=Math.max(s[1],s[3]),_=(a-i)*(u-o),w=(m-c)*(y-p);if(_<=0||w<=0)return 0;const T=Math.max(i,c),I=Math.max(o,p),O=Math.min(a,m),M=Math.min(u,y),V=Math.max(O-T,0)*Math.max(M-I,0);return V/(_+w-V)}function Tue(n,t,e){const r=Math.exp(t*e*e);return e<=n?r:0}function WV(n,t){return n.score-t.score||n.score===t.score&&t.boxIndex-n.boxIndex}function RE(){return(RE=Ve(function*(n,t,e,r=.5,s=Number.NEGATIVE_INFINITY){const i=ee(n,"boxes","nonMaxSuppressionAsync"),o=ee(t,"scores","nonMaxSuppressionAsync"),a=Nh(i,o,e,r,s);e=a.maxOutputSize,r=a.iouThreshold,s=a.scoreThreshold;const u=yield Promise.all([i.data(),o.data()]),c=u[0],p=u[1],{selectedIndices:m}=AE(c,p,e,r,s);return i!==n&&i.dispose(),o!==t&&o.dispose(),oi(m,"int32")})).apply(this,arguments)}const Eue=he({nonMaxSuppressionWithScore_:function Iue(n,t,e,r=.5,s=Number.NEGATIVE_INFINITY,i=0){const o=ee(n,"boxes","nonMaxSuppression"),a=ee(t,"scores","nonMaxSuppression"),u=Nh(o,a,e,r,s,i),m=fe.runKernel(MC,{boxes:o,scores:a},{maxOutputSize:e=u.maxOutputSize,iouThreshold:r=u.iouThreshold,scoreThreshold:s=u.scoreThreshold,softNmsSigma:i=u.softNmsSigma});return{selectedIndices:m[0],selectedScores:m[1]}}});function ME(){return(ME=Ve(function*(n,t,e,r=.5,s=Number.NEGATIVE_INFINITY,i=0){const o=ee(n,"boxes","nonMaxSuppressionAsync"),a=ee(t,"scores","nonMaxSuppressionAsync"),u=Nh(o,a,e,r,s,i);e=u.maxOutputSize,r=u.iouThreshold,s=u.scoreThreshold,i=u.softNmsSigma;const c=yield Promise.all([o.data(),a.data()]),p=c[0],m=c[1],{selectedIndices:y,selectedScores:_}=NE(p,m,e,r,s,i);return o!==n&&o.dispose(),a!==t&&a.dispose(),{selectedIndices:oi(y,"int32"),selectedScores:oi(_)}})).apply(this,arguments)}const Nue=he({nonMaxSuppressionPadded_:function kue(n,t,e,r=.5,s=Number.NEGATIVE_INFINITY,i=!1){const o=ee(n,"boxes","nonMaxSuppression"),a=ee(t,"scores","nonMaxSuppression"),u=Nh(o,a,e,r,s,null),w=fe.runKernel(RC,{boxes:o,scores:a},{maxOutputSize:u.maxOutputSize,iouThreshold:u.iouThreshold,scoreThreshold:u.scoreThreshold,padToMaxOutputSize:i});return{selectedIndices:w[0],validOutputs:w[1]}}});function PE(){return(PE=Ve(function*(n,t,e,r=.5,s=Number.NEGATIVE_INFINITY,i=!1){const o=ee(n,"boxes","nonMaxSuppressionAsync"),a=ee(t,"scores","nonMaxSuppressionAsync"),u=Nh(o,a,e,r,s,null),c=u.maxOutputSize,p=u.iouThreshold,m=u.scoreThreshold,[y,_]=yield Promise.all([o.data(),a.data()]),{selectedIndices:w,validOutputs:T}=kE(y,_,c,p,m,i);return o!==n&&o.dispose(),a!==t&&a.dispose(),{selectedIndices:oi(w,"int32"),validOutputs:Rt(T,"int32")}})).apply(this,arguments)}const HV=he({resizeBilinear_:function Mue(n,t,e=!1,r=!1){const s=ee(n,"images","resizeBilinear");J(3===s.rank||4===s.rank,()=>`Error in resizeBilinear: x must be rank 3 or 4, but got rank ${s.rank}.`),J(2===t.length,()=>`Error in resizeBilinear: new shape must 2D, but got shape ${t}.`),J(!1===r||!1===e,()=>"Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false.");let i=s,o=!1;3===s.rank&&(o=!0,i=be(s,[1,s.shape[0],s.shape[1],s.shape[2]]));const[]=t,c=fe.runKernel(Q_,{images:i},{alignCorners:e,halfPixelCenters:r,size:t});return o?be(c,[c.shape[1],c.shape[2],c.shape[3]]):c}}),qV=he({resizeNearestNeighbor_:function Pue(n,t,e=!1,r=!1){const s=ee(n,"images","resizeNearestNeighbor");J(3===s.rank||4===s.rank,()=>`Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ${s.rank}.`),J(2===t.length,()=>`Error in resizeNearestNeighbor: new shape must 2D, but got shape ${t}.`),J("float32"===s.dtype||"int32"===s.dtype,()=>"`images` must have `int32` or `float32` as dtype"),J(!1===r||!1===e,()=>"Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false.");let i=s,o=!1;3===s.rank&&(o=!0,i=be(s,[1,s.shape[0],s.shape[1],s.shape[2]]));const[]=t,c=fe.runKernel(Z_,{images:i},{alignCorners:e,halfPixelCenters:r,size:t});return o?be(c,[c.shape[1],c.shape[2],c.shape[3]]):c}}),Lue=he({threshold_:function Fue(n,t="binary",e=!1,r=.5){const s=ee(n,"image","threshold"),u=s.shape[0]*s.shape[1];let p,m,y,_,c=me(oi([r]),255);if(J(3===s.rank,()=>`Error in threshold: image must be rank 3,but got rank ${s.rank}.`),J(3===s.shape[2]||1===s.shape[2],()=>`Error in threshold: image color channel must be equal to 3 or 1but got ${s.shape[2]}.`),J("int32"===s.dtype||"float32"===s.dtype,()=>`Error in dtype: image dtype must be int32 or float32,but got dtype ${s.dtype}.`),J("otsu"===t||"binary"===t,()=>`Method must be binary or otsu, but was ${t}`),3===s.shape[2]){[p,m,y]=Ii(s,[1,1,1],-1);const I=me(p,.2989),O=me(m,.587),M=me(y,.114);_=Ze(Ze(I,O),M)}else _=n;"otsu"===t&&(c=function $ue(n,t){let i,o,a,u,c,p,e=oi([-1]),r=oi([0]),s=oi([0]);for(let m=0;m<n.size-1;m++){i=gn(n,0,m+1),o=gn(n,m+1),c=At(Tt(i),t),p=At(Tt(o),t);const y=Tt(me(i,Dh(0,i.size)));a=At(y,Tt(i));const _=vh(o.shape,i.size),w=Ze(Dh(0,o.size),_),T=me(o,w);u=At(Tt(T),Tt(o));const I=vt(a,u),O=vt(a,u),M=me(c,p);s=me(me(M,I),O);const V=Ci(s,r);r=Os(V,s,r),e=Os(V,oi([m]),e)}return e}(eV(pt(uE(_),"int32"),Yo([]),256),u));const w=e?Tc(_,c):Ci(_,c);return pt(me(w,255),"int32")}}),Bue=he({transform_:function Vue(n,t,e="nearest",r="constant",s=0,i){const o=ee(n,"image","transform","float32"),a=ee(t,"transforms","transform","float32");return J(4===o.rank,()=>`Error in transform: image must be rank 4,but got rank ${o.rank}.`),J(2===a.rank&&(a.shape[0]===o.shape[0]||1===a.shape[0])&&8===a.shape[1],()=>"Error in transform: Input transform should be batch x 8 or 1 x 8"),J(null==i||2===i.length,()=>`Error in transform: outputShape must be [height, width] or null, but got ${i}.`),fe.runKernel(nI,{image:o,transforms:a},{interpolation:e,fillMode:r,fillValue:s,outputShape:i})}}),Uue=he({bandPart_:function zue(n,t,e){const r=ee(n,"a","bandPart");J(r.rank>=2,()=>`bandPart(): Rank must be at least 2, got ${r.rank}.`);const s=r.shape,[i,o]=r.shape.slice(-2);let a,u;"number"==typeof t?(J(t%1==0,()=>`bandPart(): numLower must be an integer, got ${t}.`),J(t<=i,()=>`bandPart(): numLower (${t}) must not be greater than the number of rows (${i}).`),a=ee(t<0?i:t,"numLower","bandPart")):(J("int32"===t.dtype,()=>"bandPart(): numLower's dtype must be an int32."),a=Os(Jm(t,0),i,Sc(t,i))),"number"==typeof e?(J(e%1==0,()=>`bandPart(): numUpper must be an integer, got ${e}.`),J(e<=o,()=>`bandPart(): numUpper (${e}) must not be greater than the number of columns (${o}).`),u=ee(e<0?o:e,"numUpper","bandPart")):(J("int32"===e.dtype,()=>"bandPart(): numUpper's dtype must be an int32."),u=Os(Jm(e,0),o,Sc(e,o)));const c=be(Dh(0,i,1,"int32"),[-1,1]),p=Dh(0,o,1,"int32"),m=vt(c,p),y=ka(Tc(m,a),fu(m,Zn(u))),_=Yr([i,o],r.dtype);return be(qi(So(be(r,[-1,i,o])).map(w=>Os(y,w,_))),s)}}),Gue=he({gramSchmidt_:function jue(n){let t;if(Array.isArray(n)){t=!1,J(null!=n&&n.length>0,()=>"Gram-Schmidt process: input must not be null, undefined, or empty");const s=n[0].shape[0];for(let i=1;i<n.length;++i)J(n[i].shape[0]===s,()=>`Gram-Schmidt: Non-unique lengths found in the input vectors: (${n[i].shape[0]} vs. ${s})`)}else t=!0,n=Ii(n,n.shape[0],0).map(s=>Ic(s,[0]));J(n.length<=n[0].shape[0],()=>`Gram-Schmidt: Number of vectors (${n.length}) exceeds number of dimensions (${n[0].shape[0]}).`);const e=[],r=n;for(let s=0;s<n.length;++s)e.push(fe.tidy(()=>{let i=r[s];if(s>0)for(let o=0;o<s;++o){const a=me(Tt(me(e[o],i)),e[o]);i=vt(i,a)}return At(i,Ym(i,"euclidean"))}));return t?qi(e,0):e}});function KV(n,t=!1){return fe.tidy(()=>{J(2===n.shape.length,()=>`qr2d() requires a 2D Tensor, but got a ${n.shape.length}D Tensor.`);const e=n.shape[0],r=n.shape[1];let s=JI(e),i=cl(n);const o=kh([[1]],[1,1]);let a=cl(o);const u=e>=r?r:e;for(let c=0;c<u;++c){const p=i,m=a,y=s;[a,i,s]=fe.tidy(()=>{const _=gn(i,[c,c],[e-c,1]),w=Ym(_),T=gn(i,[c,c],[1,1]),I=Os(Ci(T,0),kh([[-1]]),kh([[1]])),O=vt(T,me(I,w)),M=At(_,O);a=1===M.shape[0]?cl(o):Vr([o,gn(M,[1,0],[M.shape[0]-1,M.shape[1]])],0);const V=Zn(At(ln(I,O),w)),z=gn(i,[c,0],[e-c,r]),G=me(V,a),Q=yn(a);if(0===c)i=vt(z,ln(G,ln(Q,z)));else{const de=vt(z,ln(G,ln(Q,z)));i=Vr([gn(i,[0,0],[c,r]),de],0)}const ne=yn(G),oe=gn(s,[0,c],[e,s.shape[1]-c]);if(0===c)s=vt(oe,ln(ln(oe,a),ne));else{const de=vt(oe,ln(ln(oe,a),ne));s=Vr([gn(s,[0,0],[e,c]),de],1)}return[a,i,s]}),on([p,m,y])}return!t&&e>r&&(s=gn(s,[0,0],[e,r]),i=gn(i,[0,0],[r,r])),[s,i]})}const Hue=he({qr_:function Wue(n,t=!1){if(J(n.rank>=2,()=>`qr() requires input tensor to have a rank >= 2, but got rank ${n.rank}`),2===n.rank)return KV(n,t);{const e=n.shape.slice(0,n.shape.length-2).reduce((u,c)=>u*c),r=So(be(n,[e,n.shape[n.shape.length-2],n.shape[n.shape.length-1]]),0),s=[],i=[];return r.forEach(u=>{const[c,p]=KV(u,t);s.push(c),i.push(p)}),[be(qi(s,0),n.shape),be(qi(i,0),n.shape)]}}});var cr=(()=>((cr=cr||{})[cr.NONE=0]="NONE",cr[cr.MEAN=1]="MEAN",cr[cr.SUM=2]="SUM",cr[cr.SUM_BY_NONZERO_WEIGHTS=3]="SUM_BY_NONZERO_WEIGHTS",cr))();const ml=he({computeWeightedLoss_:function que(n,t,e=cr.SUM_BY_NONZERO_WEIGHTS){const r=ee(n,"losses","computeWeightedLoss");let s=null;null!=t&&(s=ee(t,"weights","computeWeightedLoss"));const i=null==s?r:me(r,s);if(e===cr.NONE)return i;if(e===cr.SUM)return Tt(i);if(e===cr.MEAN){if(null==s)return wr(i);{const o=r.size/s.size,a=At(Tt(i),Tt(s));return o>1?At(a,Rt(o)):a}}if(e===cr.SUM_BY_NONZERO_WEIGHTS){if(null==s)return At(Tt(i),Rt(r.size));{const o=me(s,Wi(r.shape)),a=pt(Tt(Eh(o,Rt(0))),"float32");return At(Tt(i),a)}}throw Error(`Unknown reduction: ${e}`)}}),Xue=he({absoluteDifference_:function Kue(n,t,e,r=cr.SUM_BY_NONZERO_WEIGHTS){const s=ee(n,"labels","absoluteDifference"),i=ee(t,"predictions","absoluteDifference");let o=null;null!=e&&(o=ee(e,"weights","absoluteDifference")),xi(s.shape,i.shape,"Error in absoluteDifference: ");const a=Kr(vt(s,i));return ml(a,o,r)}}),Zue=he({cosineDistance_:function Yue(n,t,e,r,s=cr.SUM_BY_NONZERO_WEIGHTS){const i=ee(n,"labels","cosineDistance"),o=ee(t,"predictions","cosineDistance");let a=null;null!=r&&(a=ee(r,"weights","cosineDistance")),xi(i.shape,o.shape,"Error in cosineDistance: ");const u=Rt(1),c=vt(u,Tt(me(i,o),e,!0));return ml(c,a,s)}}),Jue=he({hingeLoss_:function Que(n,t,e,r=cr.SUM_BY_NONZERO_WEIGHTS){let s=ee(n,"labels","hingeLoss");const i=ee(t,"predictions","hingeLoss");let o=null;null!=e&&(o=ee(e,"weights","hingeLoss")),xi(s.shape,i.shape,"Error in hingeLoss: ");const a=Rt(1);s=vt(me(Rt(2),s),a);const u=Na(vt(a,me(s,i)));return ml(u,o,r)}}),tce=he({huberLoss_:function ece(n,t,e,r=1,s=cr.SUM_BY_NONZERO_WEIGHTS){const i=ee(n,"labels","huberLoss"),o=ee(t,"predictions","huberLoss");let a=null;null!=e&&(a=ee(e,"weights","huberLoss")),xi(i.shape,o.shape,"Error in huberLoss: ");const u=Rt(r),c=Kr(vt(o,i)),p=Sc(c,u),m=vt(c,p),y=Ze(me(Rt(.5),zn(p)),me(u,m));return ml(y,a,s)}}),rce=he({logLoss_:function nce(n,t,e,r=1e-7,s=cr.SUM_BY_NONZERO_WEIGHTS){const i=ee(n,"labels","logLoss"),o=ee(t,"predictions","logLoss");let a=null;null!=e&&(a=ee(e,"weights","logLoss")),xi(i.shape,o.shape,"Error in logLoss: ");const u=Rt(1),c=Rt(r),p=Zn(me(i,Gi(Ze(o,c)))),m=me(vt(u,i),Gi(Ze(vt(u,o),c))),y=vt(p,m);return ml(y,a,s)}}),ice=he({meanSquaredError_:function sce(n,t,e,r=cr.SUM_BY_NONZERO_WEIGHTS){const s=ee(n,"labels","meanSquaredError"),i=ee(t,"predictions","meanSquaredError");let o=null;null!=e&&(o=ee(e,"weights","meanSquaredError")),xi(s.shape,i.shape,"Error in meanSquaredError: ");const a=bE(s,i);return ml(a,o,r)}}),lce=he({sigmoidCrossEntropy_:function ace(n,t,e,r=0,s=cr.SUM_BY_NONZERO_WEIGHTS){let i=ee(n,"multiClassLabels","sigmoidCrossEntropy");const o=ee(t,"logits","sigmoidCrossEntropy");let a=null;if(null!=e&&(a=ee(e,"weights","sigmoidCrossEntropy")),xi(i.shape,o.shape,"Error in sigmoidCrossEntropy: "),r>0){const c=Rt(r),p=Rt(1),m=Rt(.5);i=Ze(me(i,vt(p,c)),me(m,c))}const u=function oce(n,t){const e=ee(n,"labels","sigmoidCrossEntropyWithLogits"),r=ee(t,"logits","sigmoidCrossEntropyWithLogits");xi(e.shape,r.shape,"Error in sigmoidCrossEntropyWithLogits: ");const s=Na(r),i=me(r,e),o=Nv(ji(Zn(Kr(r))));return Ze(vt(s,i),o)}(i,o);return ml(u,a,s)}}),dce=he({softmaxCrossEntropy_:function cce(n,t,e,r=0,s=cr.SUM_BY_NONZERO_WEIGHTS){let i=ee(n,"onehotLabels","softmaxCrossEntropy");const o=ee(t,"logits","softmaxCrossEntropy");let a=null;if(null!=e&&(a=ee(e,"weights","softmaxCrossEntropy")),xi(i.shape,o.shape,"Error in softmaxCrossEntropy: "),r>0){const c=Rt(r),p=Rt(1),m=Rt(i.shape[1]);i=Ze(me(i,vt(p,c)),At(c,m))}const u=function uce(n,t,e=-1){if(-1===e&&(e=t.rank-1),e!==t.rank-1)throw Error(`Softmax cross entropy along a non-last dimension is not yet supported. Labels / logits was rank ${t.rank} and dim was ${e}`);return dl((s,i,o)=>{const u=tE(i,[e],!0),c=vt(pt(i,"float32"),u);o([s,c]);const p=Zn(me(c,s));return{value:Tt(p,[e]),gradFunc:(_,w)=>{const[T,I]=w,O=kr(_.shape,[e]);return[me(be(_,O),vt(pt(T,"float32"),ji(I))),me(be(_,O),vt(ji(I),pt(T,"float32")))]}}})(n,t)}(i,o);return ml(u,a,s)}}),Dce={fft:Uv,ifft:ng,rfft:jv,irfft:yE},Ace={hammingWindow:rue,hannWindow:jV,frame:GV,stft:aue},Oa={flipLeftRight:due,grayscaleToRGB:pue,resizeNearestNeighbor:qV,resizeBilinear:HV,rotateWithOffset:mue,cropAndResize:uue,nonMaxSuppression:yue,nonMaxSuppressionAsync:function Sue(n,t,e){return RE.apply(this,arguments)},nonMaxSuppressionWithScore:Eue,nonMaxSuppressionWithScoreAsync:function Due(n,t,e){return ME.apply(this,arguments)},nonMaxSuppressionPadded:Nue,nonMaxSuppressionPaddedAsync:function Oue(n,t,e){return PE.apply(this,arguments)},threshold:Lue,transform:Bue},XV={bandPart:Uue,gramSchmidt:Gue,qr:Hue},kce={absoluteDifference:Xue,computeWeightedLoss:ml,cosineDistance:Zue,hingeLoss:Jue,huberLoss:tce,logLoss:rce,meanSquaredError:ice,sigmoidCrossEntropy:lce,softmaxCrossEntropy:dce},Nce={sparseFillEmptyRows:he({sparseFillEmptyRows_:function hce(n,t,e,r){const s=ee(n,"indices","sparseFillEmptyRows","int32"),i=ee(t,"values","sparseFillEmptyRows"),o=ee(e,"denseShape","sparseFillEmptyRows","int32"),a=ee(r,"defaultValue","sparseFillEmptyRows",i.dtype);if(2!==s.rank)throw new Error(`Indices should be Tensor2D but received shape\n        ${s.shape}`);if(1!==i.rank)throw new Error(`Values should be Tensor1D but received shape ${i.shape}`);if(1!==o.rank)throw new Error(`Dense shape should be Tensor1D but received shape ${o.shape}`);if(0!==a.rank)throw new Error(`Default value should be a scalar but received shape ${a.shape}`);const c=fe.runKernel(WC,{indices:s,values:i,denseShape:o,defaultValue:a});return{outputIndices:c[0],outputValues:c[1],emptyRowIndicator:c[2],reverseIndexMap:c[3]}}}),sparseReshape:he({sparseReshape_:function fce(n,t,e){const r=ee(n,"inputIndices","sparseReshape","int32"),s=ee(t,"inputShape","sparseReshape","int32"),i=ee(e,"newShape","sparseReshape","int32");if(2!==r.rank)throw new Error(`Input indices should be Tensor2D but received shape\n        ${r.shape}`);if(1!==s.rank)throw new Error(`Input shape should be Tensor1D but received shape ${s.shape}`);if(1!==i.rank)throw new Error(`New shape should be Tensor1D but received shape ${i.shape}`);const a=fe.runKernel(HC,{inputIndices:r,inputShape:s,newShape:i});return{outputIndices:a[0],outputShape:a[1]}}}),sparseSegmentMean:he({sparseSegmentMean_:function gce(n,t,e){const r=ee(n,"data","sparseSegmentMean"),s=ee(t,"indices","sparseSegmentMean","int32"),i=ee(e,"segmentIds","sparseSegmentMean","int32");if(r.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==s.rank)throw new Error(`Indices should be Tensor1D but received shape\n          ${s.shape}`);if(1!==i.rank)throw new Error(`Segment ids should be Tensor1D but received shape\n          ${i.shape}`);return fe.runKernel(qC,{data:r,indices:s,segmentIds:i})}}),sparseSegmentSum:he({sparseSegmentSum_:function bce(n,t,e){const r=ee(n,"data","sparseSegmentSum"),s=ee(t,"indices","sparseSegmentSum","int32"),i=ee(e,"segmentIds","sparseSegmentSum","int32");if(r.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==s.rank)throw new Error(`Indices should be Tensor1D but received shape\n         ${s.shape}`);if(1!==i.rank)throw new Error(`Segment ids should be Tensor1D but received shape\n         ${i.shape}`);return fe.runKernel(KC,{data:r,indices:s,segmentIds:i})}})},Oce={stringNGrams:he({stringNGrams_:function vce(n,t,e,r,s,i,o,a){const u=ee(n,"data","stringNGrams","string");if("string"!==u.dtype)throw new Error("Data must be of datatype string");if(1!==u.shape.length)throw new Error(`Data must be a vector, saw: ${u.shape}`);const c=ee(t,"dataSplits","stringNGrams");if("int32"!==c.dtype)throw new Error("Data splits must be of datatype int32");const y=fe.runKernel(QC,{data:u,dataSplits:c},{separator:e,nGramWidths:r,leftPad:s,rightPad:i,padWidth:o,preserveShortSequences:a});return{nGrams:y[0],nGramsSplits:y[1]}}}),stringSplit:he({stringSplit_:function xce(n,t,e=!0){const r=ee(n,"input","stringSplit","string"),s=ee(t,"delimiter","stringSplit","string");if(1!==r.rank)throw new Error(`Input should be Tensor1D but received shape ${r.shape}`);if(0!==s.rank)throw new Error(`Delimiter should be a scalar but received shape ${s.shape}`);const a=fe.runKernel(JC,{input:r,delimiter:s},{skipEmpty:e});return{indices:a[0],values:a[1],shape:a[2]}}}),stringToHashBucketFast:he({stringToHashBucketFast_:function Sce(n,t){const e=ee(n,"input","stringToHashBucketFast","string"),r={numBuckets:t};if(t<=0)throw new Error("Number of buckets must be at least 1");return fe.runKernel(eI,{input:e},r)}}),staticRegexReplace:he({staticRegexReplace_:function Ice(n,t,e,r=!0){const s=ee(n,"input","staticRegexReplace","string");return fe.runKernel(ov,{x:s},{pattern:t,rewrite:e,replaceGlobal:r})}})},Oh=class Rce{static sgd(t){return new kI(t)}static momentum(t,e,r=!1){return new T3(t,e,r)}static rmsprop(t,e=.9,r=0,s=null,i=!1){return new S3(t,e,r,s,i)}static adam(t=.001,e=.9,r=.999,s=null){return new w3(t,e,r,s)}static adadelta(t=.001,e=.95,r=null){return new _3(t,e,r)}static adamax(t=.002,e=.9,r=.999,s=null,i=0){return new x3(t,e,r,s,i)}static adagrad(t,e=.1){return new v3(t,e)}},Mce=typeof requestAnimationFrame<"u"?requestAnimationFrame:typeof setImmediate<"u"?setImmediate:n=>n();function YV(){return new Promise(n=>Mce(()=>n()))}function FE(n,t){const e=n[0].length;n.forEach((s,i)=>{J(s.length===e,()=>`Error in concat${e}D: rank of tensors[${i}] must be the same as the rank of the rest (${e})`)}),J(t>=0&&t<e,()=>`Error in concat${e}D: axis must be between 0 and ${e-1}.`);const r=n[0];n.forEach((s,i)=>{for(let o=0;o<e;o++)J(o===t||s[o]===r[o],()=>`Error in concat${e}D: Shape of tensors[${i}] (${s}) does not match the shape of the rest (${r}) along the non-concatenated axis ${i}.`)})}function Ra(n,t){const e=n[0].slice();for(let r=1;r<n.length;r++)e[t]+=n[r][t];return e}var dr=(()=>((dr=dr||{})[dr.FIRST_DIM_SIZE=0]="FIRST_DIM_SIZE",dr[dr.VALUE_ROWIDS=1]="VALUE_ROWIDS",dr[dr.ROW_LENGTHS=2]="ROW_LENGTHS",dr[dr.ROW_SPLITS=3]="ROW_SPLITS",dr[dr.ROW_LIMITS=4]="ROW_LIMITS",dr[dr.ROW_STARTS=5]="ROW_STARTS",dr))();function ZV(n,t,e){let r=new Array;if(null==e&&null==t)return r;if(null==t)for(;r.length<n+e.length;)r.push(-1);else r=t.slice();if(null==e)return r;if(n+e.length!==r.length)throw new Error(`rt input.shape and shape=${t} are incompatible: rt input.rank = ${n+e.length}, but shape.rank = ${r.length}`);for(let s=1;s<e.length;++s){const i=e[s],o=r[r.length-e.length+s],a=r[o];if(i>=0)if(a>=0){if(a!==i)throw new Error(`rt input.shape and shape=${t} are incompatible: rt input.shape[${s+n}] = ${i} but shape[${s+n}] = ${a}`)}else r[o]=i}return r}function QV(n){const t={FIRST_DIM_SIZE:dr.FIRST_DIM_SIZE,VALUE_ROWIDS:dr.VALUE_ROWIDS,ROW_LENGTHS:dr.ROW_LENGTHS,ROW_SPLITS:dr.ROW_SPLITS,ROW_LIMITS:dr.ROW_LIMITS,ROW_STARTS:dr.ROW_STARTS},e=[];for(const r of n){if(!(r in t))break;e.push(t[r])}return e}function JV(n){return 0===n.length?0:n[0]===dr.FIRST_DIM_SIZE?n.length-1:n.length}function eB(n,t){if(null==n||null==t)return;const e=n.length,r=t.length;if(e>=r)throw new Error(`defaultValue.shape=${n} and ragged tensor flatValues.shape=${t}, are incompatible: defaultValue.rank = ${e} must be less than ragged tensor input flatValues.rank = ${r})`);for(let s=0;s<Math.min(e,r-1);++s){const i=n[s],o=t[s+1];if(i>=0&&o>=0&&1!==i&&i!==o)throw new Error(`defaultValue.shape=${n}, and ragged tensor input flatValues.shape=${t} are incompatible: defaultValue.shape[${s-n.length}] = ${i} but ragged tensor input.flatValues.shape[${s-n.length}] = ${o}`)}}const $E=30;function Kv(n){return n<=$E?n:K1(n,Math.floor(Math.sqrt(n)))}function LE(n,t,e){return[e*("number"==typeof n?n:n[0]),t*("number"==typeof n?n:n[1])]}function rg(n,t,e,r=!0){let s=[];if(r)s=s.concat(t.slice(0)),s.push(n[0]/e),s=s.concat(n.slice(1));else{s=s.concat(n[0]);const i=t.length;for(let o=0;o<i;++o)s=s.concat([n[o+1]/t[o],t[o]]);s=s.concat(n.slice(i+1))}return s}function sg(n,t,e=!0){const r=[];if(e){r.push(t);for(let s=t+1;s<n;++s)s<=2*t?(r.push(s),r.push(s-(t+1))):r.push(s)}else{const s=[],i=[];for(let o=1;o<n;++o)o>=2*t+1||o%2==1?i.push(o):s.push(o);r.push(...s),r.push(0),r.push(...i)}return r}function ig(n,t,e,r=!0){const s=[];s.push(r?n[0]/e:n[0]*e);for(let i=1;i<n.length;++i)s.push(i<=t.length?r?t[i-1]*n[i]:n[i]/t[i-1]:n[i]);return s}function VE(n,t){const e=[0];for(let r=0;r<t;++r)e.push(n[r][0]);return e}function BE(n,t,e){const r=n.slice(0,1);for(let s=0;s<e;++s)r.push(n[s+1]-t[s][0]-t[s][1]);return r}function zE(n,t){const e=n.shape.length,r=t.shape.length;if(e<1)throw new Error(`tf.gatherND() expects the input to be rank 1 or higher, but the rank was ${e}.`);if(r<1)throw new Error(`tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ${r}.`);if("int32"!==t.dtype)throw new Error(`tf.gatherND() expects the indices to be int32 type, but the dtype was ${t.dtype}.`);if(t.shape[r-1]>e)throw new Error(`index innermost dimension length must be <= tensor rank; saw: ${t.shape[r-1]} vs. ${e}`);if(0===Fe(n.shape))throw new Error(`Requested more than 0 entries, but input is empty. Input shape: ${n.shape}.`);const s=t.shape,i=s[s.length-1];let o=1;for(let m=0;m<s.length-1;++m)o*=s[m];const a=n.shape,u=s.slice();u.pop();let c=1;for(let m=i;m<e;++m)c*=a[m],u.push(a[m]);const p=[...Nt(n.shape).map(m=>m/c),1].slice(0,i);return[u,o,c,p]}const Xv=1.7580993408473768,Yv=1.0507009873554805,UE=.3275911,jE=.254829592,GE=-.284496736,WE=1.421413741,HE=-1.453152027,qE=1.061405429;function gl(n,t){if(n.length!==t.length)throw new Error(`Cannot merge real and imag arrays of different lengths. real:${n.length}, imag: ${t.length}.`);const e=new Float32Array(2*n.length);for(let r=0;r<e.length;r+=2)e[r]=n[r/2],e[r+1]=t[r/2];return e}function tB(n){const t=new Float32Array(n.length/2),e=new Float32Array(n.length/2);for(let r=0;r<n.length;r+=2)t[r/2]=n[r],e[r/2]=n[r+1];return{real:t,imag:e}}function nB(n){const t=Math.ceil(n.length/4),e=new Float32Array(t),r=new Float32Array(t);for(let s=0;s<n.length;s+=4)e[Math.floor(s/4)]=n[s],r[Math.floor(s/4)]=n[s+1];return{real:e,imag:r}}function rB(n){const t=Math.floor(n.length/4),e=new Float32Array(t),r=new Float32Array(t);for(let s=2;s<n.length;s+=4)e[Math.floor(s/4)]=n[s],r[Math.floor(s/4)]=n[s+1];return{real:e,imag:r}}function KE(n,t){return{real:n[2*t],imag:n[2*t+1]}}function sB(n,t,e,r){n[2*r]=t,n[2*r+1]=e}function iB(n,t){const e=new Float32Array(n/2),r=new Float32Array(n/2);for(let s=0;s<Math.ceil(n/2);s++){const i=(t?2:-2)*Math.PI*(s/n);e[s]=Math.cos(i),r[s]=Math.sin(i)}return{real:e,imag:r}}function oB(n,t,e){const r=(e?2:-2)*Math.PI*(n/t);return{real:Math.cos(r),imag:Math.sin(r)}}const XE="->",Pce=/->/g,aB=",",lB="...";function YE(n,t){const e=((n=n.replace(/\s/g,"")).length-n.replace(Pce,"").length)/XE.length;if(e<1)throw new Error("Equations without an arrow are not supported.");if(e>1)throw new Error(`Equation must contain exactly one arrow ("${XE}").`);const[r,s]=n.split(XE);J(-1===r.indexOf(lB),()=>`The ellipsis notation ("${lB}") is not supported yet.`);const i=r.split(aB),o=i.length;if(t!==o)throw new Error(`Expected ${o} input tensors, received ${t}`);if(o>2)throw new Error("Support for more than 2 input tensors is not implemented yet.");const a=[];for(let y=0;y<s.length;++y){const _=s[y];if(!i.some(w=>-1!==w.indexOf(_)))throw new Error(`Output subscripts contain the label ${_} not present in the input subscripts.`);-1===a.indexOf(_)&&a.push(_)}for(let y=0;y<r.length;++y){const _=r[y];-1===a.indexOf(_)&&_!==aB&&a.push(_)}const u=new Array(i.length);for(let y=0;y<o;++y){if(new Set(i[y].split("")).size!==i[y].length)throw new Error(`Found duplicate axes in input component ${i[y]}. Support for duplicate axes in input is not implemented yet.`);u[y]=[];for(let _=0;_<i[y].length;++_)u[y].push(a.indexOf(i[y][_]))}const c=a.length,m=[];for(let y=s.length;y<c;++y)m.push(y);return{allDims:a,summedDims:m,idDims:u}}function ZE(n,t){let e=new Array(n);e.fill(-1);for(let s=0;s<t.length;++s)e[t[s]]=s;const r=[];for(let s=0;s<n;++s)-1===e[s]&&r.push(s);return e=e.filter(s=>-1!==s),{permutationIndices:e,expandDims:r}}function QE(n,t,e){const r=new Array(n);for(let s=0;s<e.length;++s){const i=e[s].shape;for(let o=0;o<t[s].length;++o)void 0===r[t[s][o]]?r[t[s][o]]=i[o]:J(r[t[s][o]]===i[o],()=>`Expected dimension ${r[t[s][o]]} at axis ${o} of input shaped ${JSON.stringify(i)}, but got dimension ${i[o]}`)}}function JE(n,t){const e=n,r=[];let s=0;0===n.length&&e.push(-1),s=n.length+1;for(let o=0;o<s;++o)r.push([]);const i=[];for(let o=0;o<e.length;++o){const u=Fce(t,e[o]);for(const c of u)-1===i.indexOf(c)&&(r[o].push(c),i.push(c))}return{path:e,steps:r}}function eD(n){return n.every((t,e)=>t===e)}function Fce(n,t){const e=[];for(let r=0;r<n.length;++r)(0===n[r].length||-1!==n[r].indexOf(t)||-1===t)&&e.push(r);return e}function tD(n,t,e=0){let r=[];if("number"==typeof t)J(n.shape[e]%t==0,()=>"Number of splits must evenly divide the axis."),r=new Array(t).fill(n.shape[e]/t);else{J(t.reduce((o,a)=>(-1===a&&(o+=1),o),0)<=1,()=>"There should be only one negative value in split array.");const i=t.indexOf(-1);if(-1!==i){const o=t.reduce((a,u)=>u>0?a+u:a);t[i]=n.shape[e]-o}J(n.shape[e]===t.reduce((o,a)=>o+a),()=>"The sum of sizes must match the size of the axis dimension."),r=t}return r}function uB(n){return`Received SparseTensor with denseShape[0] = 0 but\n  indices.shape[0] = ${n}`}function cB(n,t){return`indices(${n}, 0) is invalid: ${t} < 0`}function dB(n,t,e){return`indices(${n}, 0) is invalid: ${t} >= ${e}`}function hB(n,t){return`only one output dimension may be -1, not both ${n} and ${t}`}function pB(n,t){return`size ${n} must be non-negative, not ${t}`}function fB(){return"reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero"}function mB(n,t){return`Input to reshape is a SparseTensor with ${Fe(n)}\n  dense values, but the requested shape requires a multiple of ${Fe(t)}. inputShape=${n} outputShape= ${t}`}function gB(n,t){return`Input to reshape is a tensor with ${Fe(n)} dense values, but the requested shape has ${Fe(t)}. inputShape=${n} outputShape=${t}`}function nD(){return"segment ids must be >= 0"}function yB(){return"segment ids are not increasing"}function bB(n,t){return`Segment id ${n} out of range [0, ${t}), possibly because segmentIds input is not sorted.`}function _B(n,t,e){return`Bad: indices[${n}] == ${t} out of range [0, ${e})`}function vB(n,t){let r,e=!1;for(n<=$E?(r=n,e=!0):r=K1(n,Math.floor(Math.sqrt(n)));!e;)r>t||r===n?e=!0:r=K1(n,r+1);return r}function wB(n,t,e){const r=[],s=n.length;for(let i=0;i<s;i++)r.push(i!==t?n[i]:e);return r}function rD(n,t,e,r){const s=t.shape.length,i=n.shape.length;if(0!==r&&(r<-s||r>s))throw new Error(`Expect batchDims in the range of [-${s}, ${s}], but got ${r}`);if(r<0&&(r+=s),r>i)throw new Error(`batchDims (${r}) must be less than rank(x) (\n    ${i}).`);if(e<r)throw new Error(`batchDims (${r}) must be less than or equal to axis (${e}).`);for(let m=0;m<r;++m)if(n.shape[m]!==t.shape[m])throw new Error(`x.shape[${m}]: ${n.shape[m]} should be equal to indices.shape[${m}]: ${t.shape[m]}.`);const o=n.shape[e],a=[];let u=1,c=1,p=1;for(let m=0;m<r;++m)a.push(n.shape[m]),u*=n.shape[m];for(let m=r;m<e;m++)a.push(n.shape[m]),c*=n.shape[m];for(let m=r;m<s;m++)a.push(t.shape[m]);for(let m=e+1;m<i;m++)a.push(n.shape[m]),p*=n.shape[m];return{batchSize:u,sliceSize:p,outerSize:c,dimSize:o,outputShape:a}}function yl(n){try{return n.map(t=>Jl(t))}catch(t){throw new Error(`Failed to decode encoded string bytes into utf-8, error: ${t}`)}}function xB(n){return n.map(t=>Ql(t))}!function dse(){for(const n of cse)Qe(n)}();const TB={kernelName:l_,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>me(n,Ah(pt(e,"float32"),-1))}}},$ce={kernelName:jf,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>{const r=zn(pt(e,"float32")),s=Ns(vt(Rt(1),r));return Zn(At(n,s))}}}},Lce={kernelName:Gf,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>{const r=Ns(vt(zn(pt(e,"float32")),1));return At(n,r)}}}},Vce={kernelName:dh,inputsToSave:["a","b"],gradFunc:(n,t)=>{const[e,r]=t,s=Ht(e.shape,r.shape);return{a:()=>{let a=n;const u=Xr(e.shape,s);return u.length>0&&(a=Tt(a,u)),be(a,e.shape)},b:()=>{let a=n;const u=Xr(r.shape,s);return u.length>0&&(a=Tt(a,u)),be(a,r.shape)}}}},Bce={kernelName:u_,saveAllInputs:!0,gradFunc:(n,t)=>{const e={};return t.forEach((r,s)=>{e[s]=()=>n.clone()}),e}},zce={kernelName:c_,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>mn(e)}}},Uce={kernelName:d_,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>mn(e)}}},jce={kernelName:Wf,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>At(n,Ns(vt(Rt(1),zn(pt(e,"float32")))))}}},Gce={kernelName:Hf,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>{const r=Ns(Ze(Rt(1),zn(pt(e,"float32"))));return At(n,r)}}}},Wce={kernelName:Xf,inputsToSave:["a","b"],gradFunc:(n,t)=>{const[e,r]=t,s=Ht(e.shape,r.shape);return{a:()=>{const a=Ze(zn(e),zn(r));let u=me(n,At(r,a));const c=Xr(e.shape,s);return c.length>0&&(u=Tt(u,c)),be(u,e.shape)},b:()=>{const a=Ze(zn(e),zn(r));let u=Zn(me(n,At(e,a)));const c=Xr(r.shape,s);return c.length>0&&(u=Tt(u,c)),be(u,r.shape)}}}},Hce={kernelName:qf,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>At(n,Ze(zn(pt(e,"float32")),1))}}},qce={kernelName:Kf,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>At(n,vt(Rt(1),zn(pt(e,"float32"))))}}},Xce=he({avgPool3dGrad_:function Kce(n,t,e,r,s,i){const o=ee(n,"dy","avgPool3dGrad"),a=ee(t,"input","avgPool3dGrad");let u=o,c=a,p=!1;4===a.rank&&(p=!0,u=be(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]]),c=be(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]])),J(5===u.rank,()=>`Error in avgPool3dGrad: dy must be rank 5 but got rank ${u.rank}.`),J(5===c.rank,()=>`Error in avgPool3dGrad: input must be rank 5 but got rank ${c.rank}.`),js("avgPool3dGrad",s,i);const _=fe.runKernel(tC,{dy:u,input:c},{filterSize:e,strides:r,pad:s,dimRoundingMode:i});return p?be(_,[_.shape[1],_.shape[2],_.shape[3],_.shape[4]]):_}}),Yce={kernelName:p_,inputsToSave:["x"],gradFunc:(n,t,e)=>{const[r]=t,{filterSize:s,strides:i,pad:o,dimRoundingMode:a}=e;return{x:()=>Xce(n,r,s,i,o,a)}}},Qce=he({avgPoolGrad_:function Zce(n,t,e,r,s){const i=ee(n,"dy","avgPoolGrad"),o=ee(t,"input","avgPoolGrad");J(o.rank===i.rank,()=>`Rank of input (${o.rank}) does not match rank of dy (${i.rank})`);let a=o,u=i,c=!1;3===o.rank&&(c=!0,a=be(o,[1,o.shape[0],o.shape[1],o.shape[2]]),u=be(i,[1,i.shape[0],i.shape[1],i.shape[2]])),J(4===u.rank,()=>`Error in avgPoolGrad: dy must be rank 4 but got rank ${u.rank}.`),J(4===a.rank,()=>`Error in avgPoolGrad: input must be rank 4 but got rank ${a.rank}.`);const y=fe.runKernel(eC,{dy:u,input:a},{filterSize:e,strides:r,pad:s});return c?be(y,[y.shape[1],y.shape[2],y.shape[3]]):y}}),Jce={kernelName:h_,inputsToSave:["x"],gradFunc:(n,t,e)=>{const[r]=t,{filterSize:s,strides:i,pad:o}=e;return{x:()=>Qce(n,r,s,i,o)}}},ede={kernelName:f_,inputsToSave:["a","b"],gradFunc:(n,t,e)=>{const[r,s]=t,{transposeA:i,transposeB:o}=e;return i||o?!i&&o?{a:()=>ln(n,s,!1,!1),b:()=>ln(n,r,!0,!1)}:i&&!o?{a:()=>ln(s,n,!1,!0),b:()=>ln(r,n,!1,!1)}:{a:()=>ln(s,n,!0,!0),b:()=>ln(n,r,!0,!0)}:{a:()=>ln(n,s,!1,!0),b:()=>ln(r,n,!0,!1)}}},tde={kernelName:m_,gradFunc:(n,t,e)=>{const{blockShape:r,crops:s}=e;return{x:()=>Fv(n,r,s)}}},nde={kernelName:"BroadcastTo",gradFunc:(n,t,e)=>{const s=e.inputShape,i=e.shape,o=Array.from(i);for(let u=s.length-1;u>=0;u--)if(s[u]===i[u])o[u]=1;else if(1!==s[u])throw new Error(`broadcastTo(): [${s}] cannot be broadcast to [${i}].`);const a=[];for(let u=0;u<o.length;u++)o[u]>1&&a.push(u);return{x:()=>Tt(n,a,!0)}}},rde={kernelName:Yf,gradFunc:n=>({x:()=>n.clone()})},sde={kernelName:Zf,gradFunc:n=>({x:()=>mn(n)})},ide={kernelName:Qf,inputsToSave:["x"],gradFunc:(n,t,e)=>{const[r]=t,{clipValueMin:s,clipValueMax:i}=e;return{x:()=>Os(ka(fu(r,s),Tc(r,i)),n,mn(n))}}},ode={kernelName:g_,inputsToSave:["x"],gradFunc:TB.gradFunc},ade={kernelName:y_,saveAllInputs:!0,gradFunc:(n,t,e)=>{const r=t.map(u=>u.shape),{axis:s}=e,i=sn(s,t[0].shape)[0],o=r.map(u=>u[i]);return Ii(n,o,i).map(u=>()=>u)}},lde={kernelName:b_,inputsToSave:["x","filter"],gradFunc:(n,t,e)=>{const[r,s]=t,{dilations:i,strides:o,pad:a,dataFormat:u}=e;return J(du(i),()=>`Error in gradient of conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${i}'`),{x:()=>qI(r.shape,n,s,o,a,u),filter:()=>EE(r,n,s.shape,o,a,u)}}},ude={kernelName:__,inputsToSave:["dy","filter"],gradFunc:(n,t,e)=>{const[r,s]=t,{strides:i,pad:o,dataFormat:a,dimRoundingMode:u}=e;return{dy:()=>hu(n,s,i,o,a,1,u),filter:()=>EE(n,r,s.shape,i,o,a,u)}}},dde=he({conv3DBackpropFilter_:function cde(n,t,e,r,s){let i=n;4===n.rank&&(i=be(n,[1,n.shape[0],n.shape[1],n.shape[2],n.shape[3]]));let o=t;return 4===o.rank&&(o=be(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]])),J(5===i.rank,()=>`Error in conv3dDerFilter: input must be rank 5, but got shape ${i.shape}.`),J(5===o.rank,()=>`Error in conv3dDerFilter: dy must be rank 5, but got shape ${o.shape}.`),J(5===e.length,()=>`Error in conv3dDerFilter: filterShape must be length 5, but got ${e}.`),J(i.shape[4]===e[3],()=>`Error in conv3dDerFilter: depth of input ${i.shape[4]}) must match input depth in filter (${e[3]}.`),J(o.shape[4]===e[4],()=>`Error in conv3dDerFilter: depth of dy (${o.shape[4]}) must match output depth for filter (${e[4]}).`),fe.runKernel(aC,{x:i,dy:o},{strides:r,pad:s,filterShape:e})}}),hde={kernelName:v_,inputsToSave:["x","filter"],gradFunc:(n,t,e)=>{const{dilations:r,strides:s,pad:i}=e;J(du(r),()=>`Error in gradient of conv3D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${r}'`);const[o,a]=t;return{x:()=>aV(o.shape,n,a,s,i),filter:()=>dde(o,n,a.shape,s,i)}}},pde={kernelName:Jf,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>me(Zn(fE(pt(e,"float32"))),n)}}},fde={kernelName:em,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>me(mE(pt(e,"float32")),n)}}},mde={kernelName:w_,inputsToSave:["x"],gradFunc:(n,t,e)=>{const[r]=t,{axis:s,exclusive:i,reverse:o}=e;return{x:()=>{const a=ur([s],r.rank);let u=YI(n,s,i,!o);return null!=a&&(u=yn(u,a)),u}}}},gde={kernelName:x_,inputsToSave:["x","filter"],gradFunc:(n,t,e)=>{const{dilations:r,strides:s,pad:i,dimRoundingMode:o}=e,a=r??[1,1];J(du(a),()=>`Error in gradient of depthwiseConv2dNative: dilation rates greater than 1 are not yet supported. Got dilations '${a}'`);const[u,c]=t;return J(4===u.rank,()=>`Error in gradient of depthwiseConv2dNative: input must be rank 4, but got rank ${u.rank}.`),J(4===c.rank,()=>`Error in gradient of depthwiseConv2dNative: filter must be rank 4, but got rank ${c.rank}.`),J(u.shape[3]===c.shape[2],()=>`Error in gradient of depthwiseConv2d: number of input channels (${u.shape[3]}) must match the inChannels dimension in filter ${c.shape[2]}.`),J(vs(s,a),()=>`Error in gradient of depthwiseConv2d: Either strides or dilations must be  1. Got strides ${s} and dilations '${a}'.`),js("depthwiseConv2d",i,o),{x:()=>UV(u.shape,n,c,s,i,a,o),filter:()=>zV(u,n,c.shape,s,i,a,o)}}},yde={kernelName:T_,inputsToSave:["x","filter"],gradFunc:(n,t,e)=>{const[r,s]=t,i={x:r,filter:s,dy:n},o={x:r,filter:s,dy:n};return{x:()=>fe.runKernel(gC,i,e),filter:()=>fe.runKernel(yC,o,e)}}},bde={kernelName:nm,outputsToSave:[!0],gradFunc:(n,t)=>{const[e]=t,r={dy:n,y:e};return{x:()=>fe.runKernel(_C,r)}}},_de={kernelName:rm,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t,r=me(ji(Zn(zn(e))),2/Math.sqrt(Math.PI));return{x:()=>me(n,r)}}},vde={kernelName:sm,outputsToSave:[!0],gradFunc:(n,t)=>{const[e]=t;return{x:()=>me(n,e)}}},wde={kernelName:C_,inputsToSave:["input"],gradFunc:(n,t)=>{const[e]=t;return{input:()=>be(n,e.shape)}}},xde={kernelName:im,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>me(n,ji(e))}}},Tde={kernelName:om,gradFunc:n=>({x:()=>mn(n)})},Sde={kernelName:am,inputsToSave:["a","b"],gradFunc:(n,t)=>{const[e,r]=t,s=Ht(e.shape,r.shape);return{a:()=>{const a=At(n,pt(r,"float32")),u=Xr(e.shape,s);return u.length>0?be(Tt(a,u),e.shape):a},b:()=>{let a=me(n,pt(e,"float32"));const u=Xr(r.shape,s);u.length>0&&(a=be(Tt(a,u),r.shape));const c=zn(r);return Zn(At(a,pt(c,"float32")))}}}},Cde={kernelName:I_,inputsToSave:["x","mean","variance","scale"],gradFunc:(n,t,e)=>{const{varianceEpsilon:r}=e,[s,i,o,a]=t,u=a??Rt(1),c=Xr(i.shape,s.shape),p=[];if(1===i.rank){for(let z=0;z<s.shape.length-1;++z)p.push(s.shape[z]);p.push(1)}const m=vt(s,i),y=me(n,u),_=cE(Ze(o,Rt(r))),w=me(me(me(_,_),_),Rt(-.5));return{x:()=>be(me(me(n,1===i.rank?xo(be(_,[1,1,1,i.shape[0]]),p):_),u),s.shape),mean:()=>{let z=me(me(_,Rt(-1)),y);return 1===i.rank&&(z=Tt(z,c)),be(z,i.shape)},variance:()=>{let z=me(me(w,m),y);return 1===i.rank&&(z=Tt(z,c)),be(z,i.shape)},scale:()=>{const z=me(m,_);let G=me(n,z);return 1===i.rank&&(G=Tt(G,c)),be(G,i.shape)},offset:()=>{let z=n;return 1===i.rank&&(z=Tt(z,c)),be(z,i.shape)}}}},Ide={kernelName:E_,inputsToSave:["x","indices"],gradFunc:(n,t,e)=>{const[r,s]=t,{axis:i}=e,o=sn(i,r.shape)[0];return{x:()=>{const u=r.shape,c=s.size,p=u.slice(0,o),m=p.length,y=u.slice(i,u.length).slice(1),_=y.length,w=SB(0,m),T=SB(m+1,m+1+_),I=CB([p,[c],y]),O=be(n,I),M=be(s,[c]),V=CB([[m],w,T]),z=yn(O,V);let G=wE(z,M,r.shape[o]);const Q=pu(V);return G=yn(G,Q),G},indices:()=>s}}};function SB(n,t){const e=[];for(let r=n;r<t;++r)e.push(r);return e}function CB(n){const t=[];for(let e=0;e<n.length;++e)for(let r=0;r<n[e].length;++r)t.push(n[e][r]);return t}const Ede={kernelName:lm,inputsToSave:["a","b"],gradFunc:(n,t)=>{const[e,r]=t;return{a:()=>mn(e),b:()=>mn(r)}}},Dde={kernelName:um,gradFunc:n=>({x:()=>pt(n,"float32")})},Ade={kernelName:cm,gradFunc:n=>({x:()=>mn(n)})},kde={kernelName:dm,gradFunc:n=>({x:()=>mn(n)})},Nde={kernelName:hm,gradFunc:n=>({x:()=>mn(n)})},Ode={kernelName:A_,inputsToSave:["x"],gradFunc:(n,t,e)=>{const[r]=t,{alpha:s}=e,i=Ci(r,0);return{x:()=>Os(i,n,me(n,s))}}},Rde={kernelName:fm,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>At(n,Ze(e,1))}}},Mde={kernelName:pm,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>At(n,pt(e,"float32"))}}},Pde={kernelName:"LogSoftmax",inputsToSave:[],outputsToSave:[!0],gradFunc:(n,t,e)=>{const[r]=t,{axis:s}=e;return{logits:()=>{const o=ji(r);return vt(n,me(Tt(n,s,!0),o))}}}},$de=he({localResponseNormalizationBackprop_:function Fde(n,t,e,r=5,s=1,i=1,o=.5){return fe.runKernel(EC,{x:n,y:t,dy:e},{depthRadius:r,bias:s,alpha:i,beta:o})}}),Lde={kernelName:P_,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,t,e)=>{const[r,s]=t,{depthRadius:i,bias:o,alpha:a,beta:u}=e;return{x:()=>$de(r,s,n,i,o,a,u)}}};function IB(n,t,e,r){return t.rank<e.rank&&(t=be(t,kr(t.shape,r))),n.rank<e.rank&&(n=be(n,kr(n.shape,r))),{x:()=>me(n,pt(Zo(e,t),n.dtype))}}const EB={kernelName:F_,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,t,e)=>{const r=e,{reductionIndices:s}=r,i=t[0],u=IB(n,t[1],i,sn(s,i.shape));return{x:()=>u.x()}}},Vde={kernelName:mm,inputsToSave:["a","b"],gradFunc:(n,t)=>{const[e,r]=t;return{a:()=>me(n,pt(fu(e,r),"float32")),b:()=>me(n,pt(Jm(e,r),"float32"))}}},zde=he({maxPool3dGrad_:function Bde(n,t,e,r,s,i,o){const a=ee(n,"dy","maxPool3dGrad"),u=ee(t,"input","maxPool3dGrad"),c=ee(e,"output","maxPool3dGrad");let p=a,m=u,y=c,_=!1;4===u.rank&&(_=!0,p=be(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]]),m=be(u,[1,u.shape[0],u.shape[1],u.shape[2],u.shape[3]]),y=be(c,[1,c.shape[0],c.shape[1],c.shape[2],c.shape[3]])),J(5===p.rank,()=>`Error in maxPool3dGrad: dy must be rank 5 but got rank ${p.rank}.`),J(5===m.rank,()=>`Error in maxPool3dGrad: input must be rank 5 but got rank ${m.rank}.`),J(5===y.rank,()=>`Error in maxPool3dGrad: output must be rank 5 but got rank ${y.rank}.`),js("maxPool3dGrad",i,o);const I=fe.runKernel(AC,{dy:p,input:m,output:y},{filterSize:r,strides:s,pad:i,dimRoundingMode:o});return _?be(I,[I.shape[1],I.shape[2],I.shape[3],I.shape[4]]):I}}),Ude={kernelName:L_,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,t,e)=>{const[r,s]=t,{filterSize:i,strides:o,pad:a,dimRoundingMode:u}=e;return{x:()=>zde(n,r,s,i,o,a,u)}}},Gde=he({maxPoolGrad_:function jde(n,t,e,r,s,i,o){const a=ee(n,"dy","maxPoolGrad"),u=ee(t,"input","maxPoolGrad"),c=ee(e,"output","maxPoolGrad");return J(u.rank===a.rank,()=>`Rank of input (${u.rank}) does not match rank of dy (${a.rank})`),J(4===a.rank,()=>`Error in maxPoolGrad: dy must be rank 4 but got rank ${a.rank}.`),J(4===u.rank,()=>`Error in maxPoolGrad: input must be rank 4 but got rank ${u.rank}.`),js("maxPoolGrad",i,o),fe.runKernel(DC,{dy:a,input:u,output:c},{filterSize:r,strides:s,pad:i,dimRoundingMode:o})}}),DB={kernelName:q_,inputsToSave:["x"],gradFunc:(n,t,e)=>{const r=t[0],{paddings:s}=e,i=s.map(o=>o[0]);return{x:()=>gn(n,i,r.shape)}}};const AB={kernelName:rv,gradFunc:(n,t,e)=>{const{blockShape:r,paddings:s}=e;return{x:()=>Iv(n,r,s)}}},kB={kernelName:sv,gradFunc:(n,t,e)=>{const{axis:r}=e;return{x:()=>Vr(n,r)}}},Bhe=[TB,$ce,Lce,Vce,Bce,zce,Uce,jce,Gce,Wce,Hce,qce,Yce,Jce,ede,tde,nde,rde,sde,ide,ode,ade,ude,lde,hde,pde,fde,mde,gde,yde,{kernelName:tm,inputsToSave:["a","b"],gradFunc:(n,t)=>{const[e,r]=t,s=Ht(e.shape,r.shape);return{a:()=>{const a=At(n,pt(r,"float32")),u=Xr(e.shape,s);return u.length>0?be(Tt(a,u),e.shape):a},b:()=>{let a=me(n,pt(e,"float32"));const u=Xr(r.shape,s);u.length>0&&(a=be(Tt(a,u),r.shape));const c=zn(r);return Zn(At(a,pt(c,"float32")))}}}},bde,_de,vde,wde,xde,Sde,Tde,Cde,Ide,Ede,Dde,Ade,kde,Nde,Ode,Rde,Mde,Pde,Lde,EB,EB,Vde,Ude,{kernelName:$_,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,t,e)=>{const[r,s]=t,{filterSize:i,strides:o,pad:a}=e;return{x:()=>Gde(n,r,s,i,o,a)}}},{kernelName:V_,inputsToSave:["x"],gradFunc:(n,t,e)=>{const[r]=t,{axis:s}=e,i=sn(s,r.shape),u=Fe(us(r.shape,i)[1]);return{x:()=>{const p=r.shape.slice();i.forEach(_=>{p[_]=1});const m=be(n,p);return At(me(m,Wi(r.shape,"float32")),u)}}}},{kernelName:B_,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,t,e)=>{const r=e,{axis:s}=r,[i,o]=t,u=IB(n,o,i,sn(s,i.shape));return{x:()=>u.x()}}},{kernelName:gm,inputsToSave:["a","b"],gradFunc:(n,t)=>{const[e,r]=t;return{a:()=>me(n,pt(Tc(e,r),"float32")),b:()=>me(n,pt(Ci(e,r),"float32"))}}},{kernelName:z_,inputsToSave:["x"],gradFunc:(n,t,e)=>{const r=t[0],{paddings:s}=e,i=s.map(o=>o[0]);return{x:()=>gn(n,i,r.shape)}}},{kernelName:ym,inputsToSave:["a","b"],gradFunc:(n,t)=>{const[e,r]=t,s=Ht(e.shape,r.shape);return{a:()=>{const a=Xr(e.shape,s);return a.length>0?be(Tt(n,a),e.shape):n},b:()=>{const a=me(n,Zn(Zm(At(e,r)))),u=Xr(r.shape,s);return u.length>0?be(Tt(a,u),r.shape):a}}}},{kernelName:bm,inputsToSave:["a","b"],gradFunc:(n,t)=>{const[e,r]=t,s=Ht(e.shape,r.shape);return{a:()=>{const a=me(n,pt(r,"float32")),u=Xr(e.shape,s);return u.length>0?be(Tt(a,u),e.shape):a},b:()=>{const a=me(n,pt(e,"float32")),u=Xr(r.shape,s);return u.length>0?be(Tt(a,u),r.shape):a}}}},{kernelName:U_,gradFunc:n=>({x:()=>Zn(n)})},{kernelName:W_,inputsToSave:["indices"],gradFunc:(n,t)=>{const e=t[0];return{indices:()=>Yr(e.shape,"float32")}}},{kernelName:G_,gradFunc:n=>({x:()=>mn(n)})},{kernelName:H_,saveAllInputs:!0,gradFunc:(n,t,e)=>{const{axis:r}=e;return So(n,r).map(i=>()=>i)}},DB,DB,{kernelName:_m,inputsToSave:["a","b"],outputsToSave:[!0],gradFunc:(n,t)=>{const[e,r,s]=t,i=e,o=r,a=Ht(i.shape,o.shape);return{a:()=>{const p=pt(o,"float32");let m=me(n,me(p,uu(i,vt(p,Rt(1)))));const y=Xr(i.shape,a);return y.length>0&&(m=Tt(m,y)),be(m,i.shape)},b:()=>{const p=Ci(i,0),m=Os(p,Gi(i),mn(i));let y=me(n,me(s,m));const _=Xr(o.shape,a);return _.length>0&&(y=Tt(y,_)),be(y,o.shape)}}}},{kernelName:K_,inputsToSave:["x","alpha"],gradFunc:(n,t)=>{const[e,r]=t,s=Ci(e,0);return{x:()=>Os(s,n,me(n,r)),alpha:()=>{let i=Os(s,mn(n),me(n,e));const o=Xr(r.shape,n.shape);return o.length>0&&(i=Tt(i,o)),be(i,r.shape)}}}},{kernelName:X_,inputsToSave:["x"],gradFunc:(n,t,e)=>{const[r]=t,{axis:s}=e;let i=[];return i=null==s?r.shape.map((o,a)=>a):"number"==typeof s?[s]:s,{x:()=>function ihe(n,t,e){const r=n.shape.length,s=r-e.length,i=ur(e,r);let o=n;null!=i&&(o=yn(n,i));const a=o.shape.slice(),c=a.splice(r-e.length,e.length).reduce((y,_)=>y*_,1);a.push(c);let m=function she(n,t,e){const r=n.shape.slice();r[e]=1;const s=be(t,r),i=Dv(n,e,!0,!1),o=Dv(n,e,!0,!0),a=me(i,o);return me(s,a)}(o.reshape(a),t,s);if(m=m.reshape(o.shape),null!=i){const y=pu(i);m=yn(m,y)}return m}(r,n,i)}}},{kernelName:vm,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>At(n,Zn(zn(e)))}}},{kernelName:xm,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t,r=me(Tc(e,6),Ah(e));return{x:()=>me(n,pt(r,"float32"))}}},{kernelName:wm,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>me(n,pt(Ah(e),"float32"))}}},{kernelName:Y_,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>be(n,e.shape)}}},{kernelName:Q_,inputsToSave:["images"],gradFunc:(n,t,e)=>{const[r]=t,s={dy:n,images:r};return{images:()=>fe.runKernel(zC,s,e)}}},{kernelName:Z_,inputsToSave:["images"],gradFunc:(n,t,e)=>{const[r]=t,s={dy:n,images:r};return{images:()=>fe.runKernel(BC,s,e)}}},{kernelName:J_,gradFunc:(n,t,e)=>{const{dims:r}=e,s=sn(r,n.shape);return{x:()=>To(n,s)}}},{kernelName:Tm,gradFunc:n=>({x:()=>mn(n)})},{kernelName:Sm,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>Zn(At(n,me(uu(e,1.5),2)))}}},{kernelName:ev,inputsToSave:["condition"],gradFunc:(n,t)=>{const[e]=t;return{condition:()=>pt(mn(e),"float32"),t:()=>me(n,pt(e,n.dtype)),e:()=>me(n,pt(Ov(e),n.dtype))}}},{kernelName:Cm,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>{const r=Ci(e,Rt(0)),s=Rt(Xv),i=Rt(Yv),o=me(n,i),a=me(me(n,s),ji(pt(e,"float32")));return Os(r,o,a)}}}},{kernelName:Am,outputsToSave:[!0],gradFunc:(n,t)=>{const[e]=t;return{x:()=>me(n,me(e,vt(Rt(1),e)))}}},{kernelName:Dm,gradFunc:n=>({x:()=>mn(n)})},{kernelName:Im,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>me(Ev(pt(e,"float32")),n)}}},{kernelName:Em,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>me(XI(pt(e,"float32")),n)}}},{kernelName:tv,inputsToSave:["x"],gradFunc:(n,t,e)=>{const[r]=t,{begin:s,size:i}=e,o=r.shape,[a,u]=Tv(r,s,i),c=[];for(let p=0;p<n.rank;p++)c.push([a[p],o[p]-a[p]-u[p]]);return{x:()=>mu(n,c)}}},{kernelName:iv,outputsToSave:[!0],gradFunc:(n,t,e)=>{const[r]=t,{dim:s}=e,o=me(n,r);return{logits:()=>vt(o,me(Tt(o,[s],!0),r))}}},{kernelName:km,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>me(n,Aa(e))}}},AB,AB,kB,kB,{kernelName:Nm,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>At(n,me(Ns(pt(e,"float32")),2))}}},{kernelName:Om,inputsToSave:["a","b"],gradFunc:(n,t)=>{const[e,r]=t,s=Rt(2);return{a:()=>me(n,me(s,vt(e,r))),b:()=>me(n,me(s,vt(r,e)))}}},{kernelName:YC,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>me(n,me(pt(e,"float32"),2))}}},{kernelName:$m,gradFunc:n=>({x:()=>mn(n)})},{kernelName:Rm,inputsToSave:["a","b"],gradFunc:(n,t)=>{const[e,r]=t,s=Ht(e.shape,r.shape);return{a:()=>{let a=n;const u=Xr(e.shape,s);return u.length>0&&(a=Tt(a,u)),be(a,e.shape)},b:()=>{let a=n;const u=Xr(r.shape,s);return u.length>0&&(a=Tt(a,u)),be(Zn(a),r.shape)}}}},{kernelName:nv,inputsToSave:["x"],gradFunc:(n,t,e)=>{const[r]=t,s=r.shape.slice(),{axis:i}=e;sn(i,r.shape).forEach(c=>{s[c]=1});const a=be(n,s),u=me(a,Wi(r.shape,"float32"));return{x:()=>u}}},{kernelName:Mm,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>At(n,zn(Ev(e)))}}},{kernelName:Pm,outputsToSave:[!0],gradFunc:(n,t)=>{const[e]=t;return{x:()=>me(vt(Rt(1),zn(e)),n)}}},{kernelName:Fm,inputsToSave:["x"],gradFunc:(n,t,e)=>{const[r]=t,{reps:s}=e;return{x:()=>{let o=mn(r);if(1===r.rank)for(let a=0;a<s[0];++a)o=Ze(o,gn(n,[a*r.shape[0]],[r.shape[0]]));else if(2===r.rank)for(let a=0;a<s[0];++a)for(let u=0;u<s[1];++u)o=Ze(o,gn(n,[a*r.shape[0],u*r.shape[1]],[r.shape[0],r.shape[1]]));else if(3===r.rank)for(let a=0;a<s[0];++a)for(let u=0;u<s[1];++u)for(let c=0;c<s[2];++c)o=Ze(o,gn(n,[a*r.shape[0],u*r.shape[1],c*r.shape[2]],[r.shape[0],r.shape[1],r.shape[2]]));else{if(4!==r.rank)throw new Error(`Gradient for tile operation is not implemented for rank-${r.rank} tensors yet.`);for(let a=0;a<s[0];++a)for(let u=0;u<s[1];++u)for(let c=0;c<s[2];++c)for(let p=0;p<s[3];++p)o=Ze(o,gn(n,[a*r.shape[0],u*r.shape[1],c*r.shape[2],p*r.shape[3]],[r.shape[0],r.shape[1],r.shape[2],r.shape[3]]))}return o}}}},{kernelName:hh,gradFunc:(n,t,e)=>{const r=e,{perm:s}=r,i=pu(s);return{x:()=>yn(n,i)}}},{kernelName:av,gradFunc:(n,t,e)=>{const r=e,{axis:s}=r;return{value:()=>qi(n,s)}}},{kernelName:lv,inputsToSave:["segmentIds"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>function Lhe(n,t){const e=hl(t,mn(t)),r=Qm(n,e);let s=fu(t,Rt(0,"int32"));const i=r.rank-s.rank;for(let a=0;a<i;++a)s=ii(s,a+1);s=ka(s,Wi(r.shape,"bool"));const o=mn(r);return Os(s,r,o)}(n,e)}}},{kernelName:uv,gradFunc:n=>({x:()=>mn(n)})}];for(const n of Bhe)Xne(n);$e().prototype.abs=function(){return this.throwIfDisposed(),Kr(this)},$e().prototype.acos=function(){return this.throwIfDisposed(),U3(this)},$e().prototype.acosh=function(){return this.throwIfDisposed(),j3(this)},$e().prototype.add=function(n){return this.throwIfDisposed(),Ze(this,n)},$e().prototype.all=function(n,t){return this.throwIfDisposed(),jI(this,n,t)},$e().prototype.any=function(n,t){return this.throwIfDisposed(),Sv(this,n,t)},$e().prototype.argMax=function(n){return this.throwIfDisposed(),xh(this,n)},$e().prototype.argMin=function(n){return this.throwIfDisposed(),G3(this,n)},$e().prototype.asScalar=function(){return this.throwIfDisposed(),J(1===this.size,()=>"The array must have only 1 element."),be(this,[])},$e().prototype.asType=function(n){return this.throwIfDisposed(),pt(this,n)},$e().prototype.as1D=function(){return this.throwIfDisposed(),be(this,[this.size])},$e().prototype.as2D=function(n,t){return this.throwIfDisposed(),be(this,[n,t])},$e().prototype.as3D=function(n,t,e){return this.throwIfDisposed(),be(this,[n,t,e])},$e().prototype.as4D=function(n,t,e,r){return this.throwIfDisposed(),be(this,[n,t,e,r])},$e().prototype.as5D=function(n,t,e,r,s){return this.throwIfDisposed(),be(this,[n,t,e,r,s])},$e().prototype.asin=function(){return this.throwIfDisposed(),W3(this)},$e().prototype.asinh=function(){return this.throwIfDisposed(),H3(this)},$e().prototype.atan=function(){return this.throwIfDisposed(),q3(this)},$e().prototype.atan2=function(n){return this.throwIfDisposed(),K3(this,n)},$e().prototype.atanh=function(){return this.throwIfDisposed(),X3(this)},$e().prototype.avgPool=function(n,t,e,r){return this.throwIfDisposed(),Cv(this,n,t,e,r)},$e().prototype.batchToSpaceND=function(n,t){return this.throwIfDisposed(),Iv(this,n,t)},$e().prototype.batchNorm=function(n,t,e,r,s){return this.throwIfDisposed(),Hm(this,n,t,e,r,s)},$e().prototype.broadcastTo=function(n){return this.throwIfDisposed(),Ch(this,n)},$e().prototype.cast=function(n){return this.throwIfDisposed(),pt(this,n)},$e().prototype.ceil=function(){return this.throwIfDisposed(),tV(this)},$e().prototype.clipByValue=function(n,t){return this.throwIfDisposed(),Si(this,n,t)},$e().prototype.concat=function(n,t){return this.throwIfDisposed(),n instanceof nr&&(n=[n]),Vr([this,...n],t)},$e().prototype.conv1d=function(n,t,e,r,s,i){return this.throwIfDisposed(),HI(this,n,t,e,r,s,i)},$e().prototype.conv2dTranspose=function(n,t,e,r,s){return this.throwIfDisposed(),KI(this,n,t,e,r,s)},$e().prototype.conv2d=function(n,t,e,r,s,i){return this.throwIfDisposed(),hu(this,n,t,e,r,s,i)},$e().prototype.cos=function(){return this.throwIfDisposed(),Ev(this)},$e().prototype.cosh=function(){return this.throwIfDisposed(),XI(this)},$e().prototype.cumprod=function(n,t,e){return this.throwIfDisposed(),Dv(this,n,t,e)},$e().prototype.cumsum=function(n,t,e){return this.throwIfDisposed(),YI(this,n,t,e)},$e().prototype.depthToSpace=function(n,t){return this.throwIfDisposed(),uV(this,n,t)},$e().prototype.depthwiseConv2d=function(n,t,e,r,s,i){return this.throwIfDisposed(),qm(this,n,t,e,r,s,i)},$e().prototype.dilation2d=function(n,t,e,r,s){return this.throwIfDisposed(),cV(this,n,t,e,r,s)},$e().prototype.divNoNan=function(n){return this.throwIfDisposed(),dV(this,n)},$e().prototype.div=function(n){return this.throwIfDisposed(),At(this,n)},$e().prototype.dot=function(n){return this.throwIfDisposed(),hV(this,n)},$e().prototype.elu=function(){return this.throwIfDisposed(),Km(this)},$e().prototype.equal=function(n){return this.throwIfDisposed(),Zo(this,n)},$e().prototype.erf=function(){return this.throwIfDisposed(),pV(this)},$e().prototype.euclideanNorm=function(n,t){return this.throwIfDisposed(),gV(this,n,t)},$e().prototype.exp=function(){return this.throwIfDisposed(),ji(this)},$e().prototype.expandDims=function(n){return this.throwIfDisposed(),ii(this,n)},$e().prototype.expm1=function(){return this.throwIfDisposed(),yV(this)},$e().prototype.fft=function(){return this.throwIfDisposed(),Uv(this)},$e().prototype.flatten=function(){return this.throwIfDisposed(),be(this,[this.size])},$e().prototype.floor=function(){return this.throwIfDisposed(),Zm(this)},$e().prototype.floorDiv=function(n){return this.throwIfDisposed(),AI(this,n)},$e().prototype.gather=function(n,t,e){return this.throwIfDisposed(),Qm(this,n,t,e)},$e().prototype.greaterEqual=function(n){return this.throwIfDisposed(),fu(this,n)},$e().prototype.greater=function(n){return this.throwIfDisposed(),Ci(this,n)},$e().prototype.ifft=function(){return this.throwIfDisposed(),ng(this)},$e().prototype.irfft=function(){return this.throwIfDisposed(),yE(this)},$e().prototype.isFinite=function(){return this.throwIfDisposed(),bV(this)},$e().prototype.isInf=function(){return this.throwIfDisposed(),_V(this)},$e().prototype.isNaN=function(){return this.throwIfDisposed(),vV(this)},$e().prototype.leakyRelu=function(n){return this.throwIfDisposed(),kv(this,n)},$e().prototype.lessEqual=function(n){return this.throwIfDisposed(),Tc(this,n)},$e().prototype.less=function(n){return this.throwIfDisposed(),Jm(this,n)},$e().prototype.localResponseNormalization=function(n,t,e,r){return this.throwIfDisposed(),wV(this,n,t,e,r)},$e().prototype.logSigmoid=function(){return this.throwIfDisposed(),xV(this)},$e().prototype.logSoftmax=function(n){return this.throwIfDisposed(),eE(this,n)},$e().prototype.logSumExp=function(n,t){return this.throwIfDisposed(),tE(this,n,t)},$e().prototype.log=function(){return this.throwIfDisposed(),Gi(this)},$e().prototype.log1p=function(){return this.throwIfDisposed(),Nv(this)},$e().prototype.logicalAnd=function(n){return this.throwIfDisposed(),ka(this,n)},$e().prototype.logicalNot=function(){return this.throwIfDisposed(),Ov(this)},$e().prototype.logicalOr=function(n){return this.throwIfDisposed(),nE(this,n)},$e().prototype.logicalXor=function(n){return this.throwIfDisposed(),TV(this,n)},$e().prototype.matMul=function(n,t,e){return this.throwIfDisposed(),ln(this,n,t,e)},$e().prototype.maxPool=function(n,t,e,r){return this.throwIfDisposed(),Mv(this,n,t,e,r)},$e().prototype.max=function(n,t){return this.throwIfDisposed(),wo(this,n,t)},$e().prototype.maximum=function(n){return this.throwIfDisposed(),hl(this,n)},$e().prototype.mean=function(n,t){return this.throwIfDisposed(),wr(this,n,t)},$e().prototype.min=function(n,t){return this.throwIfDisposed(),Xm(this,n,t)},$e().prototype.minimum=function(n){return this.throwIfDisposed(),Sc(this,n)},$e().prototype.mirrorPad=function(n,t){return this.throwIfDisposed(),CV(this,n,t)},$e().prototype.mod=function(n){return this.throwIfDisposed(),IV(this,n)},$e().prototype.mul=function(n){return this.throwIfDisposed(),me(this,n)},$e().prototype.neg=function(){return this.throwIfDisposed(),Zn(this)},$e().prototype.norm=function(n,t,e){return this.throwIfDisposed(),Ym(this,n,t,e)},$e().prototype.notEqual=function(n){return this.throwIfDisposed(),Eh(this,n)},$e().prototype.oneHot=function(n,t=1,e=0){return this.throwIfDisposed(),sE(this,n,t,e)},$e().prototype.onesLike=function(){return this.throwIfDisposed(),Hi(this)},$e().prototype.pad=function(n,t){return this.throwIfDisposed(),mu(this,n,t)},$e().prototype.pool=function(n,t,e,r,s,i){return this.throwIfDisposed(),EV(this,n,t,e,r,s,i)},$e().prototype.pow=function(n){return this.throwIfDisposed(),uu(this,n)},$e().prototype.prelu=function(n){return this.throwIfDisposed(),$v(this,n)},$e().prototype.prod=function(n,t){return this.throwIfDisposed(),DV(this,n,t)},$e().prototype.reciprocal=function(){return this.throwIfDisposed(),AV(this)},$e().prototype.relu=function(){return this.throwIfDisposed(),Na(this)},$e().prototype.relu6=function(){return this.throwIfDisposed(),lE(this)},$e().prototype.reshapeAs=function(n){return this.throwIfDisposed(),be(this,n.shape)},$e().prototype.reshape=function(n){return this.throwIfDisposed(),be(this,n)},$e().prototype.resizeBilinear=function(n,t,e){return this.throwIfDisposed(),HV(this,n,t,e)},$e().prototype.resizeNearestNeighbor=function(n,t,e){return this.throwIfDisposed(),qV(this,n,t,e)},$e().prototype.reverse=function(n){return this.throwIfDisposed(),To(this,n)},$e().prototype.rfft=function(){return this.throwIfDisposed(),jv(this)},$e().prototype.round=function(){return this.throwIfDisposed(),uE(this)},$e().prototype.rsqrt=function(){return this.throwIfDisposed(),cE(this)},$e().prototype.selu=function(){return this.throwIfDisposed(),dE(this)},$e().prototype.separableConv2d=function(n,t,e,r,s,i){return this.throwIfDisposed(),hE(this,n,t,e,r,s,i)},$e().prototype.sigmoid=function(){return this.throwIfDisposed(),Aa(this)},$e().prototype.sign=function(){return this.throwIfDisposed(),kV(this)},$e().prototype.sin=function(){return this.throwIfDisposed(),fE(this)},$e().prototype.sinh=function(){return this.throwIfDisposed(),mE(this)},$e().prototype.slice=function(n,t){return this.throwIfDisposed(),gn(this,n,t)},$e().prototype.softmax=function(n){return this.throwIfDisposed(),zv(this,n)},$e().prototype.softplus=function(){return this.throwIfDisposed(),Ih(this)},$e().prototype.spaceToBatchND=function(n,t){return this.throwIfDisposed(),Fv(this,n,t)},$e().prototype.split=function(n,t){return this.throwIfDisposed(),Ii(this,n,t)},$e().prototype.sqrt=function(){return this.throwIfDisposed(),Ns(this)},$e().prototype.square=function(){return this.throwIfDisposed(),zn(this)},$e().prototype.squaredDifference=function(n){return this.throwIfDisposed(),bE(this,n)},$e().prototype.squeeze=function(n){return this.throwIfDisposed(),Ic(this,n)},$e().prototype.stack=function(n,t){this.throwIfDisposed();const e=n instanceof nr?[this,n]:[this,...n];return qi(e,t)},$e().prototype.step=function(n){return this.throwIfDisposed(),Ah(this,n)},$e().prototype.stridedSlice=function(n,t,e,r,s,i,o,a){return this.throwIfDisposed(),NV(this,n,t,e,r,s,i,o,a)},$e().prototype.sub=function(n){return this.throwIfDisposed(),vt(this,n)},$e().prototype.sum=function(n,t){return this.throwIfDisposed(),Tt(this,n,t)},$e().prototype.tan=function(){return this.throwIfDisposed(),OV(this)},$e().prototype.tanh=function(){return this.throwIfDisposed(),Sh(this)},$e().prototype.tile=function(n){return this.throwIfDisposed(),xo(this,n)},$e().prototype.toBool=function(){return this.throwIfDisposed(),pt(this,"bool")},$e().prototype.toFloat=function(){return this.throwIfDisposed(),pt(this,"float32")},$e().prototype.toInt=function(){return this.throwIfDisposed(),pt(this,"int32")},$e().prototype.topk=function(n,t){return this.throwIfDisposed(),MV(this,n,t)},$e().prototype.transpose=function(n){return this.throwIfDisposed(),yn(this,n)},$e().prototype.unique=function(n){return this.throwIfDisposed(),PV(this,n)},$e().prototype.unsortedSegmentSum=function(n,t){return this.throwIfDisposed(),wE(this,n,t)},$e().prototype.unstack=function(n){return this.throwIfDisposed(),So(this,n)},$e().prototype.where=function(n,t){return this.throwIfDisposed(),Os(n,this,t)},$e().prototype.zerosLike=function(){return this.throwIfDisposed(),mn(this)};class Ma extends Error{constructor(t){super(t),Object.setPrototypeOf(this,Ma.prototype)}}class Co extends Error{constructor(t){super(t),Object.setPrototypeOf(this,Co.prototype)}}class _e extends Error{constructor(t){super(t),Object.setPrototypeOf(this,_e.prototype)}}class Qt extends Error{constructor(t){super(t),Object.setPrototypeOf(this,Qt.prototype)}}class sD extends Error{constructor(t){super(t),Object.setPrototypeOf(this,sD.prototype)}}class NB extends Error{constructor(t){super(t),Object.setPrototypeOf(this,NB.prototype)}}class OB{constructor(t){this.maxEntries=t||100,this.cache=new Map}get(t){let e;return this.cache.has(t)&&(e=this.cache.get(t),this.cache.delete(t),this.cache.set(t,e)),e}put(t,e){if(this.cache.has(t))this.cache.delete(t);else if(this.cache.size>=this.maxEntries){const r=this.cache.keys().next().value;this.cache.delete(r)}this.cache.set(t,e)}getMaxEntries(){return this.maxEntries}setMaxEntries(t){if(t<0)throw new Error(`The maxEntries of LRU caches must be at least 0, but got ${t}.`);if(this.maxEntries>t)for(let e=0;e<this.maxEntries-t;e++){const r=this.cache.keys().next().value;this.cache.delete(r)}this.maxEntries=t}}function Dc(n,t){if(Array.isArray(n)){let e=[];for(let r=0;r<t;r++)e=e.concat(n);return e}{const e=new Array(t);return e.fill(n),e}}function Ki(n,t){if(!n)throw new sD(t)}function RB(n,t){let e=0;for(const r of n)r===t&&e++;return e}function ai(n){return 1===n.length?n[0]:n}function Wn(n){return Array.isArray(n)?n:[n]}function bl(n){const e=n.replace(/(.)([A-Z][a-z0-9]+)/g,"$1_$2").replace(/([a-z])([A-Z])/g,"$1_$2").toLowerCase();return"_"!==e[0]?e:"private"+e}function Ac(n){return n.length<=1||-1===n.indexOf("_")?n:n.replace(/[_]+(\w|$)/g,(t,e)=>e.toUpperCase())}let Io={};function iD(n){if(null==n)return null;const t={};return t.className=n.getClassName(),t.config=n.getConfig(),t}function oD(n){if(null!=n&&"object"==typeof n)if(Array.isArray(n))n.forEach(t=>oD(t));else{const t=Object.keys(n);for(const e of t){const r=n[e];null!=r&&"object"==typeof r&&(Array.isArray(r)||"ndarray"!==r.type||"number"!=typeof r.value?oD(r):n[e]=r.value)}}}function og(n,t={},e={},r="object",s=!1){if("string"==typeof n){let o;if(n in e)o=e[n];else if(n in Io)o=Io[n];else if(o=t[n],null==o)throw new _e(`Unknown ${r}: ${n}. This may be due to one of the following reasons:\n1. The ${r} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.\n2. The custom ${r} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);return o}{const i=n;if(null==i.className||null==i.config)throw new _e(`${r}: Improper config format: ${JSON.stringify(i)}.\n'className' and 'config' must set.`);const o=i.className;let a,u;if(o in e?[a,u]=e[o]:o in Io?[a,u]=Io.className:o in t&&([a,u]=t[o]),null==a)throw new _e(`Unknown ${r}: ${o}. This may be due to one of the following reasons:\n1. The ${r} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.\n2. The custom ${r} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);if(null!=u){const c={};for(const _ of Object.keys(Io))c[_]=Io[_];for(const _ of Object.keys(e))c[_]=e[_];i.config.customObjects=c;const m=Object.assign({},Io);for(const _ of Object.keys(e))Io[_]=e[_];oD(i.config);const y=u(a,i.config,e,s);return Io=Object.assign({},m),y}{const c=Object.assign({},Io);for(const m of Object.keys(e))Io[m]=e[m];const p=new a(i.config);return Io=Object.assign({},c),p}}}function Zv(n,t){return-1*function zhe(n,t){return n<t?-1:n>t?1:0}(n,t)}function gu(n){if(null==n)return n;const t=[];for(const e of n)-1===t.indexOf(e)&&t.push(e);return t}function Uhe(n){if(null==n)throw new _e(`Invalid value in obj: ${JSON.stringify(n)}`);for(const t in n)if(n.hasOwnProperty(t))return!1;return!0}function kc(n,t,e){if(null!=e&&n.indexOf(e)<0)throw new _e(`${e} is not a valid ${t}.  Valid values are ${n} or null/undefined.`)}function aD(n,t,e=0,r=1/0){return Ki(e>=0),Ki(r>=e),Array.isArray(n)&&n.length>=e&&n.length<=r&&n.every(s=>typeof s===t)}function cs(n,t){Array.isArray(n)?(J(n.length>0,()=>`${t} is unexpectedly an empty array.`),n.forEach((e,r)=>cs(e,`element ${r+1} of ${t}`))):J(Number.isInteger(n)&&n>0,()=>`Expected ${t} to be a positive integer, but got ${MB(n)}.`)}function MB(n){return null===n?"null":Array.isArray(n)?"["+n.map(t=>MB(t)).join(",")+"]":"string"==typeof n?`"${n}"`:`${n}`}function PB(n){return"relu"===n?"relu":"linear"===n?"linear":"elu"===n?"elu":null}let Ghe=0;function FB(){return Ghe++}const Qv={};function Jv(n=""){return n in Qv||(Qv[n]=0),Qv[n]+=1,n+Qv[n].toString()}const Whe=["channelsFirst","channelsLast"],Hhe=["nearest","bilinear"],qhe=["valid","same","causal"],Khe=["max","avg"],Xhe=["sum","mul","concat","ave"],Rh=new Map;function Or(n){kc(Whe,"DataFormat",n)}function Xi(n){kc(qhe,"PaddingMode",n)}function $B(n){kc(Khe,"PoolMode",n)}const ag=[];function Nc(n,t){ag.push(n);try{const e=t();return ag.pop(),e}catch(e){throw ag.pop(),e}}function VB(n){if(!zB(n))throw new Error("Not a valid tensor name: '"+n+"'");return function Zhe(){return 0===ag.length?"":ag.join("/")+"/"}()+n}function BB(n){if(!zB(n))throw new Error("Not a valid tensor name: '"+n+"'");Rh.has(n)||Rh.set(n,0);const t=Rh.get(n);if(Rh.set(n,Rh.get(n)+1),t>0){const e=`${n}_${t}`;return Rh.set(e,1),e}return n}const Qhe=new RegExp(/^[A-Za-z0-9][-A-Za-z0-9\._\/]*$/);function zB(n){return!!n.match(Qhe)}function Jhe(n){return n===parseInt(n.toString(),10)}function yu(n,t,e){null==t&&(t=0),null==e&&(e=n.length);let r=1;for(let s=t;s<e;++s)r*=n[s];return r}function Mh(n){if(0===n.length)return Number.NaN;let t=Number.POSITIVE_INFINITY;for(let e=0;e<n.length;e++){const r=n[e];r<t&&(t=r)}return t}function bu(n){if(0===n.length)return Number.NaN;let t=Number.NEGATIVE_INFINITY;for(let e=0;e<n.length;e++){const r=n[e];r>t&&(t=r)}return t}function Qo(n,t){if(t<n)throw new _e(`end (${t}) < begin (${n}) is forbidden.`);const e=[];for(let r=n;r<t;++r)e.push(r);return e}let e0;function Zr(){return null==e0&&(e0=function Zre(){return fe.backend}().epsilon()),e0}function Pa(n,t){return pt(n,t)}function lg(n,t=-1){const e=n.shape.slice();return t<0&&(t=e.length+t+1),e.splice(t,0,1),be(n,e)}function Oc(n,t,e){return Ce(()=>{switch(n.rank){case 1:return Vv(n,t,e);case 2:return gE(n,[t,0],[e,n.shape[1]]);case 3:return Bv(n,[t,0,0],[e,n.shape[1],n.shape[2]]);case 4:return tg(n,[t,0,0,0],[e,n.shape[1],n.shape[2],n.shape[3]]);case 5:return gn(n,[t,0,0,0,0],[e,n.shape[1],n.shape[2],n.shape[3],n.shape[4]]);case 6:return gn(n,[t,0,0,0,0,0],[e,n.shape[1],n.shape[2],n.shape[3],n.shape[4],n.shape[5]]);default:throw new _e(`sliceAlongFirstAxis() received an unsupported tensor rank: ${n.rank}`)}})}function lD(n,t,e){return Ce(()=>{switch(n.rank){case 1:return Vv(n,t,e);case 2:return gE(n,[0,t],[n.shape[0],e]);case 3:return Bv(n,[0,0,t],[n.shape[0],n.shape[1],e]);case 4:return tg(n,[0,0,0,t],[n.shape[0],n.shape[1],n.shape[2],e]);default:throw new _e(`sliceAlongLastAxis() received an unsupported tensor rank: ${n.rank}`)}})}function t0(n,t,e,r){return Ce(()=>{switch(n.rank){case 1:return Vv(n,t,e);case 2:switch(r){case 1:return Oc(n,t,e);case 2:return lD(n,t,e);default:throw new _e(`The axis is not within the rank of the tensor ${r}`)}case 3:switch(r){case 1:return Oc(n,t,e);case 2:return Bv(n,[0,t,0],[n.shape[0],e,n.shape[2]]);case 3:return lD(n,t,e);default:throw new _e(`The axis is not within the rank of the tensor ${r}`)}case 4:switch(r){case 1:return Oc(n,t,e);case 2:return tg(n,[0,t,0,0],[n.shape[0],e,n.shape[2],n.shape[3]]);case 3:return tg(n,[0,0,t,0],[n.shape[0],n.shape[1],e,n.shape[3]]);case 4:return lD(n,t,e);default:throw new _e(`The axis is not within the rank of the tensor ${r}`)}default:throw new _e(`sliceAlongLastAxis() received an unsupported tensor rank: ${n.rank}`)}})}function uD(n,t=-1){let e;return t<0&&(e=n[0].rank,t=0!==e?e:0),t===n[0].rank&&(t=-1),Vr(n,t)}function jB(n,t){switch(n.rank){case 1:return nV([n,t]);case 2:return rV([n,t],0);case 3:return sV([n,t],0);case 4:return iV([n,t],0);default:throw new _e(`concatAlongFirstAxis() received an unsupported tensor rank: ${n.rank}`)}}function cD(n,t){if(Array.isArray(t)||(t=[t]),n.rank!==t.length)throw new _e(`The length of input n (${t.length}) does not match the number of dimensions in input x (${n.rank})`);return xo(n,t)}function n0(n,t=0,e=1,r,s){return aE(n,t,e,r,s)}function Fa(n,t,e,r){if(n.rank<2||t.rank<2)throw new Qt(`dot requires both inputs to be rank >= 2 but got x shape = ${n.shape} and y shape = ${t.shape}`);if(t.rank>=3&&n.shape.slice(-1)[0]!==t.shape.slice(-2)[0])throw new Qt(`If rank y >= 3, then the second last dim of y must equal the last dim of x but got x shape = ${n.shape} and  y shape = ${t.shape}`);if(2===n.rank&&2===t.rank)return DE({a:n,b:t,transposeA:!1,transposeB:!1,bias:r?dD(n.rank,r,"channelsLast"):null,activation:e});{const s=n.shape.slice(),i=s.pop();n=be(n,[-1,i]);const o=t.shape.slice(),a=o.pop(),u=o.pop(),c=[...o,a],p=Array.from({length:t.rank},(w,T)=>0===T?t.rank-2:T<=t.rank-2?T-1:T);t=be(yn(t,p),[u,-1]);const m=[...s,...c];return be(DE({a:n,b:t,transposeA:!1,transposeB:!1,bias:r?dD(n.rank,r,"channelsLast"):null,activation:e}),m)}}function GB(n,t,e){return Ce(()=>(t=Array.isArray(t)?oi(t,"int32"):pt(t,"int32"),Qm(n,t,e)))}function ug(n){return me(n,n)}function dD(n,t,e){const r=t.shape;if(1!==t.rank&&t.rank!==n)throw new _e(`Unexpected bias dimensions: ${t.rank}; expected it to be 1 or ${n}`);if(5===n){if("channelsFirst"===e)return be(t,1===r.length?[1,r[0],1,1,1]:[1,r[3],r[0],r[1],r[2]]);if("channelsLast"===e)return be(t,1===r.length?[1,1,1,1,r[0]]:[1].concat(r))}else if(4===n){if("channelsFirst"===e)return be(t,1===r.length?[1,r[0],1,1]:[1,r[2],r[0],r[1]]);if("channelsLast"===e)return be(t,1===r.length?[1,1,1,r[0]]:[1].concat(r))}else if(3===n){if("channelsFirst"===e)return be(t,1===r.length?[1,r[0],1]:[1,r[1],r[0]]);if("channelsLast"===e)return be(t,1===r.length?[1,1,r[0]]:[1].concat(r))}else if(n<3)return t;throw new _e(`Unsupported input rank by biasAdd: ${t.rank}`)}function ea(n,t,e){return Ce(()=>(null==e&&(e="channelsLast"),Or(e),Ze(n,dD(n.rank,t,e))))}function WB(n,t,e,r){return Ce(()=>LV(n,t,e,r))}function cg(n,t,e=!1){return e?n():t()}const lpe=["fanIn","fanOut","fanAvg"],upe=["normal","uniform","truncatedNormal"];class Eo extends _h{fromConfigUsesCustomObjects(){return!1}getConfig(){return{}}}Qe((()=>{class n extends Eo{apply(e,r){return Yr(e,r)}}return n.className="Zeros",n})());let HB=(()=>{class n extends Eo{apply(e,r){return Wi(e,r)}}return n.className="Ones",n})();Qe(HB),Qe((()=>{class n extends Eo{constructor(e){if(super(),"object"!=typeof e)throw new _e(`Expected argument of type ConstantConfig but got ${e}`);if(void 0===e.value)throw new _e(`config must have value set but got ${e}`);this.value=e.value}apply(e,r){return Ce(()=>me(Rt(this.value),Wi(e,r)))}getConfig(){return{value:this.value}}}return n.className="Constant",n})()),Qe((()=>{class n extends Eo{constructor(e){super(),this.DEFAULT_MINVAL=-.05,this.DEFAULT_MAXVAL=.05,this.minval=e.minval||this.DEFAULT_MINVAL,this.maxval=e.maxval||this.DEFAULT_MAXVAL,this.seed=e.seed}apply(e,r){return Cc(e,this.minval,this.maxval,r,this.seed)}getConfig(){return{minval:this.minval,maxval:this.maxval,seed:this.seed}}}return n.className="RandomUniform",n})()),Qe((()=>{class n extends Eo{constructor(e){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,r){if("float32"!==(r=r||"float32")&&"int32"!==r)throw new Qt(`randomNormal does not support dType ${r}.`);return n0(e,this.mean,this.stddev,r,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}return n.className="RandomNormal",n})()),Qe((()=>{class n extends Eo{constructor(e){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,r){if("float32"!==(r=r||"float32")&&"int32"!==r)throw new Qt(`truncatedNormal does not support dType ${r}.`);return vE(e,this.mean,this.stddev,r,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}return n.className="TruncatedNormal",n})()),Qe((()=>{class n extends Eo{constructor(e){super(),this.gain=null!=e.gain?e.gain:1}apply(e,r){return Ce(()=>{if(2!==e.length||e[0]!==e[1])throw new _e("Identity matrix initializer can only be used for 2D square matrices.");return me(this.gain,JI(e[0]))})}getConfig(){return{gain:this.gain}}}return n.className="Identity",n})());let Yi=(()=>{class n extends Eo{constructor(e){if(super(),e.scale<0)throw new _e(`scale must be a positive float. Got: ${e.scale}`);this.scale=null==e.scale?1:e.scale,this.mode=null==e.mode?"fanIn":e.mode,function cpe(n){kc(lpe,"FanMode",n)}(this.mode),this.distribution=null==e.distribution?"normal":e.distribution,function dpe(n){kc(upe,"Distribution",n)}(this.distribution),this.seed=e.seed}apply(e,r){const s=function hpe(n,t="channelsLast"){let e,r;if(Or(t),2===n.length)e=n[0],r=n[1];else if(-1!==[3,4,5].indexOf(n.length)){if("channelsFirst"===t){const s=yu(n,2);e=n[1]*s,r=n[0]*s}else if("channelsLast"===t){const s=yu(n,0,n.length-2);e=n[n.length-2]*s,r=n[n.length-1]*s}}else{const s=yu(n);e=Math.sqrt(s),r=Math.sqrt(s)}return[e,r]}(e),i=s[0],o=s[1];let a=this.scale;if(a/="fanIn"===this.mode?Math.max(1,i):"fanOut"===this.mode?Math.max(1,o):Math.max(1,(i+o)/2),"normal"===this.distribution){const u=Math.sqrt(a);if("float32"!==(r=r||"float32")&&"int32"!==r)throw new Qt(`${this.getClassName()} does not support dType ${r}.`);return vE(e,0,u,r,this.seed)}{const u=Math.sqrt(3*a);return Cc(e,-u,u,r,this.seed)}}getConfig(){return{scale:this.scale,mode:this.mode,distribution:this.distribution,seed:this.seed}}}return n.className="VarianceScaling",n})();Qe(Yi);let qB=(()=>{class n extends Yi{constructor(e){super({scale:1,mode:"fanAvg",distribution:"uniform",seed:null==e?null:e.seed})}getClassName(){return Yi.className}}return n.className="GlorotUniform",n})();Qe(qB);let KB=(()=>{class n extends Yi{constructor(e){super({scale:1,mode:"fanAvg",distribution:"normal",seed:null==e?null:e.seed})}getClassName(){return Yi.className}}return n.className="GlorotNormal",n})();Qe(KB);let XB=(()=>{class n extends Yi{constructor(e){super({scale:2,mode:"fanIn",distribution:"normal",seed:null==e?null:e.seed})}getClassName(){return Yi.className}}return n.className="HeNormal",n})();Qe(XB);let YB=(()=>{class n extends Yi{constructor(e){super({scale:2,mode:"fanIn",distribution:"uniform",seed:null==e?null:e.seed})}getClassName(){return Yi.className}}return n.className="HeUniform",n})();Qe(YB);let ZB=(()=>{class n extends Yi{constructor(e){super({scale:1,mode:"fanIn",distribution:"normal",seed:null==e?null:e.seed})}getClassName(){return Yi.className}}return n.className="LeCunNormal",n})();Qe(ZB);let QB=(()=>{class n extends Yi{constructor(e){super({scale:1,mode:"fanIn",distribution:"uniform",seed:null==e?null:e.seed})}getClassName(){return Yi.className}}return n.className="LeCunUniform",n})();Qe(QB),Qe((()=>{class n extends Eo{constructor(e){super(),this.DEFAULT_GAIN=1,this.ELEMENTS_WARN_SLOW=2e3,this.gain=null==e.gain?this.DEFAULT_GAIN:e.gain,this.seed=e.seed}apply(e,r){return Ce(()=>{if(e.length<2)throw new Qt("Shape must be at least 2D.");if("int32"!==r&&"float32"!==r&&void 0!==r)throw new TypeError(`Unsupported data type ${r}.`);const s=Fe(e.slice(0,-1)),i=e[e.length-1],o=s*i;o>this.ELEMENTS_WARN_SLOW&&console.warn(`Orthogonal initializer is being called on a matrix with more than ${this.ELEMENTS_WARN_SLOW} (${o}) elements: Slowness may result.`);const u=n0([Math.max(i,s),Math.min(i,s)],0,1,r,this.seed),c=XV.qr(u,!1);let p=c[0];const y=c[1].flatten().stridedSlice([0],[Math.min(i,s)*Math.min(i,s)],[Math.min(i,s)+1]);return p=me(p,y.sign()),s<i&&(p=p.transpose()),me(Rt(this.gain),p.reshape(e))})}getConfig(){return{gain:this.gain,seed:this.seed}}}return n.className="Orthogonal",n})());const JB={constant:"Constant",glorotNormal:"GlorotNormal",glorotUniform:"GlorotUniform",heNormal:"HeNormal",heUniform:"HeUniform",identity:"Identity",leCunNormal:"LeCunNormal",leCunUniform:"LeCunUniform",ones:"Ones",orthogonal:"Orthogonal",randomNormal:"RandomNormal",randomUniform:"RandomUniform",truncatedNormal:"TruncatedNormal",varianceScaling:"VarianceScaling",zeros:"Zeros"};function e4(n,t={}){return og(n,_o.getMap().classNameMap,t,"initializer")}function hr(n){return iD(n)}function rr(n){if("string"==typeof n){const t=n in JB?JB[n]:n;if("GlorotNormal"===t)return new KB;if("GlorotUniform"===t)return new qB;if("HeNormal"===t)return new XB;if("HeUniform"===t)return new YB;if("LeCunNormal"===t)return new ZB;if("LeCunUniform"===t)return new QB;{const e={};return e.className=t,e.config={},e4(e)}}return n instanceof Eo?n:e4(n)}function hD(n){return Array.isArray(n)&&Array.isArray(n[0])}function r0(n){return 0===n.length?[]:Array.isArray(n[0])?n:[n]}function Lt(n){let t;if(Array.isArray(n)){if(1!==n.length)throw new _e(`Expected Tensor length to be 1; got ${n.length}`);t=n[0]}else t=n;return t}function Tn(n){if(Array.isArray(n)&&Array.isArray(n[0])){if(1===n.length)return n[0];throw new _e(`Expected exactly 1 Shape; got ${n.length}`)}return n}function s0(n){let t=0;for(const e of n)t+=0===e.shape.length?1:e.shape.reduce((r,s)=>r*s);return t}const t4="Variable";class $a{constructor(t,e="float32",r=t4,s=!0,i=null){this.dtype=e??"float32",this.shape=t.shape,this.id=FB(),this.originalName=VB(r=r??t4),this.name=BB(this.originalName),this.trainable_=s,this.constraint=i,this.val=FV(t,this.trainable_,this.name,this.dtype)}read(){return this.assertNotDisposed(),this.val}write(t){return this.assertNotDisposed(),function ppe(n,t){if(n.shape.toString()!==t.shape.toString())throw new Error("Shape mismatch: "+JSON.stringify(n.shape)+" vs. "+JSON.stringify(t.shape))}(this.val,t),this.val.id!==t.id&&(this.val.assign(t),null!=this.constraint&&this.val.assign(this.constraint.apply(this.val))),this}dispose(){this.assertNotDisposed(),this.val.dispose()}assertNotDisposed(){if(this.val.isDisposed)throw new Error(`LayersVariable ${this.name} is already disposed.`)}get trainable(){return this.trainable_}set trainable(t){this.trainable_=t,this.val.trainable=t}}function pD(n){return n.map(t=>t.read())}function fD(n){n.forEach(t=>{t[0].write(t[1])})}class Qr{constructor(t){this.dtype=t.dtype,this.shape=t.shape,this.ndim=null!=t.shape?t.shape.length:t.ndim,this.maxNDim=t.maxNDim,this.minNDim=t.minNDim,this.axes=t.axes||{}}}class La{constructor(t,e,r,s,i,o,a){this.dtype=t,this.shape=e,this.sourceLayer=r,this.inputs=s,this.callArgs=i,this.outputTensorIndex=a,this.id=FB(),null!=o&&(this.originalName=VB(o),this.name=BB(this.originalName)),this.rank=e.length}}let fpe=0;class o0{constructor(t,e){this.callArgs=e,this.id=fpe++,this.outboundLayer=t.outboundLayer,this.inboundLayers=t.inboundLayers,this.nodeIndices=t.nodeIndices,this.tensorIndices=t.tensorIndices,this.inputTensors=t.inputTensors,this.outputTensors=t.outputTensors,this.inputMasks=t.inputMasks,this.outputMasks=t.outputMasks,this.inputShapes=t.inputShapes,this.outputShapes=t.outputShapes;for(const r of t.inboundLayers)r?.outboundNodes.push(this);t.outboundLayer.inboundNodes.push(this)}getConfig(){const t=[];for(const e of this.inboundLayers)t.push(null!=e?e.name:null);return{outboundLayer:this.outboundLayer?this.outboundLayer.name:null,inboundLayers:t,nodeIndices:this.nodeIndices,tensorIndices:this.tensorIndices}}}let mpe=0;class an extends _h{constructor(t={}){super(),this._callHook=null,this._addedWeightNames=[],this._stateful=!1,this.id=mpe++,this.activityRegularizer=null,this.inputSpec=null,this.supportsMasking=!1,this._trainableWeights=[],this._nonTrainableWeights=[],this._losses=[],this._updates=[],this._built=!1,this.inboundNodes=[],this.outboundNodes=[];let e=t.name;if(!e){const r=this.getClassName();e=bl(r)+"_"+Jv(r)}if(this.name=e,this.trainable_=null==t.trainable||t.trainable,null!=t.inputShape||null!=t.batchInputShape){let r;if(null!=t.batchInputShape)r=t.batchInputShape;else if(null!=t.inputShape){let i=null;null!=t.batchSize&&(i=t.batchSize),r=[i].concat(t.inputShape)}this.batchInputShape=r;let s=t.dtype;null==s&&(s=t.inputDType),null==s&&(s="float32"),this.dtype=s}this.initialWeights=null!=t.weights?t.weights:null,this._refCount=null,this.fastWeightInitDuringBuild=!1}static nodeKey(t,e){return t.name+"_ib-"+e.toString()}getNodeAtIndex(t,e){if(0===this.inboundNodes.length)throw new Co(`The layer has never been called and thus has no defined ${e}.`);if(this.inboundNodes.length<=t)throw new _e(`Asked to get ${e} at node ${t}, but the layer has only ${this.inboundNodes.length} inbound nodes.`);return this.inboundNodes[t]}getInputAt(t){return ai(this.getNodeAtIndex(t,"input").inputTensors)}getOutputAt(t){return ai(this.getNodeAtIndex(t,"output").outputTensors)}get input(){if(this.inboundNodes.length>1)throw new Ma(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer input" is ill-defined. Use \`getInputAt(nodeIndex)\` instead.`);if(0===this.inboundNodes.length)throw new Ma(`Layer ${this.name} is not connected, no input to return.`);return ai(this.getNodeAtIndex(0,"input").inputTensors)}get output(){if(0===this.inboundNodes.length)throw new Ma(`Layer ${this.name} has no inbound nodes.`);if(this.inboundNodes.length>1)throw new Ma(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer output" is ill-defined. Use \`getOutputAt(nodeIndex)\` instead.`);return ai(this.getNodeAtIndex(0,"output").outputTensors)}get losses(){return this._losses}calculateLosses(){return this.losses.map(t=>t())}get updates(){return this._updates}get built(){return this._built}set built(t){this._built=t}get trainable(){return this.trainable_}set trainable(t){this._trainableWeights.forEach(e=>e.trainable=t),this.trainable_=t}get trainableWeights(){return this.trainable_?this._trainableWeights.filter(t=>t.trainable):[]}set trainableWeights(t){this._trainableWeights=t}get nonTrainableWeights(){return this.trainable?this._trainableWeights.filter(t=>!t.trainable).concat(this._nonTrainableWeights):this._trainableWeights.concat(this._nonTrainableWeights)}set nonTrainableWeights(t){this._nonTrainableWeights=t}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}get stateful(){return this._stateful}resetStates(){if(!this.stateful)throw new Error("Cannot call the resetStates() method of a non-stateful Layer object.")}assertInputCompatibility(t){if(t=Wn(t),null==this.inputSpec||0===this.inputSpec.length)return;const e=Wn(this.inputSpec);if(t.length!==e.length)throw new _e(`Layer ${this.name} expects ${e.length} inputs, but it received ${t.length} input tensors. Input received: ${t}`);for(let r=0;r<t.length;r++){const s=t[r],i=e[r];if(null==i)continue;const o=s.rank;if(null!=i.ndim&&o!==i.ndim)throw new _e(`Input ${r} is incompatible with layer ${this.name}: expected ndim=${i.ndim}, found ndim=${o}`);if(null!=i.maxNDim&&o>i.maxNDim)throw new _e(`Input ${r} is incompatible with layer ${this.name}: expected max_ndim=${i.maxNDim}, found ndim=${o}`);if(null!=i.minNDim&&o<i.minNDim)throw new _e(`Input ${r} is incompatible with layer ${this.name}: expected min_ndim=${i.minNDim}, found ndim=${o}.`);if(null!=i.dtype&&s.dtype!==i.dtype)throw new _e(`Input ${r} is incompatible with layer ${this.name} : expected dtype=${i.dtype}, found dtype=${s.dtype}.`);if(i.axes){const a=s.shape;for(const u in i.axes){const c=Number(u),p=i.axes[u];if(null!=p&&-1===[p,null].indexOf(c>=0?a[c]:a[a.length+c]))throw new _e(`Input ${r} is incompatible with layer ${this.name}: expected axis ${c} of input shape to have value ${p} but got shape ${a}.`)}}if(null!=i.shape)for(let a=0;a<i.shape.length;++a){const u=i.shape[a],c=s.shape[a];if(null!=u&&null!=c&&u!==c)throw new _e(`Input ${r} is incompatible with layer ${this.name}: expected shape=${i.shape}, found shape=${s.shape}.`)}}}call(t,e){return t}invokeCallHook(t,e){null!=this._callHook&&this._callHook(t,e)}setCallHook(t){this._callHook=t}clearCallHook(){this._callHook=null}apply(t,e){e=e||{},this.assertNotDisposed();const r=Wn(t);let s=!0;for(const o of r)if(!(o instanceof La)){s=!1;break}let i=!0;for(const o of r)if(o instanceof La){i=!1;break}if(s===i)throw new _e("Arguments to apply() must be all SymbolicTensors or all Tensors");return Nc(this.name,()=>{if(!this.built){this.assertInputCompatibility(t);const o=[];for(const a of Wn(t))o.push(a.shape);this.build(ai(o)),this.built=!0,this.initialWeights&&this.setWeights(this.initialWeights),null===this._refCount&&i&&(this._refCount=1)}if(this.assertInputCompatibility(t),i){let o=this.call(t,e);const a=Wn(o),u=[];for(let c of a)-1!==r.indexOf(c)&&(c=c.clone()),u.push(c);if(o=ai(u),null!=this.activityRegularizer)throw new Qt("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return o}{const o=function gpe(n){n=Wn(n);const t=[];for(const e of n)t.push(e.shape);return ai(t)}(t),a=this.computeOutputShape(o);let u;const c="float32";if(this.warnOnIncompatibleInputShape(Array.isArray(t)?o[0]:o),u=null!=a&&a.length>0&&Array.isArray(a[0])?a.map((p,m)=>new La(c,p,this,Wn(t),e,this.name,m)):new La(c,a,this,Wn(t),e,this.name),this.addInboundNode(t,u,null,null,o,a,e),this._refCount++,null!=this.activityRegularizer)throw new Qt("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return u}})}warnOnIncompatibleInputShape(t){if(null!=this.batchInputShape)if(t.length!==this.batchInputShape.length)console.warn(`The rank of the input tensor provided (shape: ${JSON.stringify(t)}) does not match that of the batchInputShape (${JSON.stringify(this.batchInputShape)}) of the layer ${this.name}`);else{let e=!1;this.batchInputShape.forEach((r,s)=>{null!=r&&null!=t[s]&&t[s]!==r&&(e=!0)}),e&&console.warn(`The shape of the input tensor (${JSON.stringify(t)}) does not match the expectation of layer ${this.name}: ${JSON.stringify(this.batchInputShape)}`)}}get outputShape(){if(null==this.inboundNodes||0===this.inboundNodes.length)throw new Ma(`The layer ${this.name} has never been called and thus has no defined output shape.`);const t=[];for(const e of this.inboundNodes){const r=JSON.stringify(e.outputShapes);-1===t.indexOf(r)&&t.push(r)}if(1===t.length){const e=this.inboundNodes[0].outputShapes;return Array.isArray(e)&&Array.isArray(e[0])&&1===e.length?e[0]:e}throw new Ma(`The layer ${this.name} has multiple inbound nodes with different output shapes. Hence the notion of "output shape" is ill-defined for the layer.`)}countParams(){if(!this.built)throw new Co(`You tried to call countParams() on ${this.name}, but the layer is not built yet. Build it first by calling build(batchInputShape).`);return s0(this.weights)}build(t){this.built=!0}getWeights(t=!1){return pD(t?this.trainableWeights:this.weights)}setWeights(t){Ce(()=>{const e=this.weights;if(e.length!==t.length)throw new _e(`You called setWeights(weights) on layer "${this.name}" with a weight list of length ${t.length}, but the layer was expecting ${e.length} weights. Provided weights: ${t}...`);if(0===e.length)return;const r=[],s=pD(e);for(let i=0;i<s.length;++i){const o=s[i],a=e[i],u=t[i];if(!hn(o.shape,u.shape))throw new _e(`Layer weight shape ${o.shape} not compatible with provided weight shape ${u.shape}`);r.push([a,u])}fD(r)})}addWeight(t,e,r,s,i,o,a,u){if(-1!==this._addedWeightNames.indexOf(t))throw new _e(`Duplicate weight name ${t} for layer ${this.name}`);this._addedWeightNames.push(t),null==r&&(r="float32"),this.fastWeightInitDuringBuild&&(s=null!=u?u():rr("zeros"));const c=s.apply(e,r),p=new $a(c,r,t,o,a);return c.dispose(),null!=i&&this.addLoss(()=>i.apply(p.read())),null==o&&(o=!0),o?this._trainableWeights.push(p):this._nonTrainableWeights.push(p),p}setFastWeightInitDuringBuild(t){this.fastWeightInitDuringBuild=t}addLoss(t){null==t||Array.isArray(t)&&0===t.length||(t=Wn(t),null!=this._losses&&this.losses.push(...t))}computeOutputShape(t){return t}computeMask(t,e){if(!this.supportsMasking){if(null!=e){if(!Array.isArray(e))throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`);e.forEach(r=>{if(null!=r)throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`)})}return null}return e}addInboundNode(t,e,r,s,i,o,a=null){const u=Wn(t);e=Wn(e),r=Wn(r),s=Wn(s),i=r0(i),o=r0(o);const c=[],p=[],m=[];for(const y of u)c.push(y.sourceLayer),p.push(y.nodeIndex),m.push(y.tensorIndex);new o0({outboundLayer:this,inboundLayers:c,nodeIndices:p,tensorIndices:m,inputTensors:u,outputTensors:e,inputMasks:r,outputMasks:s,inputShapes:i,outputShapes:o},a);for(let y=0;y<e.length;y++)e[y].sourceLayer=this,e[y].nodeIndex=this.inboundNodes.length-1,e[y].tensorIndex=y}getConfig(){const t={name:this.name,trainable:this.trainable};return null!=this.batchInputShape&&(t.batchInputShape=this.batchInputShape),null!=this.dtype&&(t.dtype=this.dtype),t}disposeWeights(){return this.weights.forEach(t=>t.dispose()),this.weights.length}assertNotDisposed(){if(0===this._refCount)throw new Error(`Layer '${this.name}' is already disposed.`)}dispose(){if(!this.built)throw new Error(`Cannot dispose Layer ${this.name} because it has not been built yet.`);if(null===this._refCount)throw new Error(`Cannot dispose Layer ${this.name} because it has not been used yet.`);this.assertNotDisposed();let t=0;return 0==--this._refCount&&(t=this.disposeWeights()),{refCountAfterDispose:this._refCount,numDisposedVariables:t}}}function n4(n,t,e){if((null==t||null!=e&&e>0)&&(t=n.sourceLayer,e=n.nodeIndex),0===t.inboundNodes.length)return[n];{const r=t.inboundNodes[e];if(0===r.inboundLayers.length)return r.inputTensors;{const s=[];for(let i=0;i<r.inboundLayers.length;i++){const c=n4(r.inputTensors[i],r.inboundLayers[i],r.nodeIndices[i]);for(const p of c)-1===s.indexOf(p)&&s.push(p)}return s}}}let a0=(()=>{class n extends an{constructor(e){if(super({dtype:e.dtype,name:null!=e.name?e.name:Jv("input").toString()}),null==e.batchSize&&(e.batchSize=null),null==e.sparse&&(e.sparse=!1),this.trainable=!1,this.built=!0,this.sparse=e.sparse,null!=e.inputShape&&null!=e.batchInputShape)throw new _e("Only provide the inputShape OR batchInputShape argument to inputLayer, not both at the same time.");let r=e.batchInputShape;if(null==r){if(null==e.inputShape)throw new _e("An InputLayer should be passed either a `batchInputShape` or an `inputShape`.");r=[e.batchSize].concat(e.inputShape)}else if(null!=e.batchSize)throw new _e("Cannot specify batchSize if batchInputShape is specified when creating an InputLayer.");const s=e.dtype||"float32";this.batchInputShape=r,this.dtype=s,this.inputSpec=[{shape:r}];const i=new La(this.dtype,this.batchInputShape,this,[],{},this.name);i.nodeIndex=0,i.tensorIndex=0,new o0({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:[i],outputTensors:[i],inputMasks:[null],outputMasks:[null],inputShapes:[r],outputShapes:[r]})}apply(e,r){throw new _e(`Cannot pass any input to an InputLayer's apply() method. InputLayer name: ${this.name}`)}dispose(){return{refCountAfterDispose:this._refCount,numDisposedVariables:0}}getConfig(){return{batchInputShape:this.batchInputShape,dtype:this.dtype,sparse:this.sparse,name:this.name}}}return n.className="InputLayer",n})();Qe(a0);class _u{constructor(t){if(this.id2Value={},this.id2Mask={},this.name2Id={},t instanceof _u)for(const e in t.id2Value)this.id2Value[e]=t.id2Value[e],e in t.id2Mask&&(this.id2Mask[e]=t.id2Mask[e]);else{if(null==t)return;for(const e of t)this.add(e.key,e.value)}}add(t,e,r){if(null!=this.id2Value[t.id])throw new _e(`Duplicate key: name=${t.name}, id=${t.id}`);return this.id2Value[t.id]=function _pe(n,t){if(null==n.dtype||n.dtype===t.dtype)return t;try{return pt(t,n.dtype)}catch{throw new _e(`The dtype of the feed (${t.dtype}) can not be cast to the dtype of the key '${n.name}' (${n.dtype}).`)}}(t,e),this.name2Id[t.name]=t.id,null!=r&&(this.id2Mask[t.id]=r),this}addFeed(t){this.add(t.key,t.value)}hasKey(t){return null!=this.id2Value[t.id]}names(){return Object.keys(this.name2Id)}getValue(t){if(t instanceof La){if(null==this.id2Value[t.id])throw new _e(`Nonexistent key: ${t.name}`);return this.id2Value[t.id]}{const e=this.name2Id[t];if(null==e)throw new _e(`Feed dict has no SymbolicTensor name: ${t}`);return this.id2Value[e]}}getMask(t){if(t instanceof La){if(null==this.id2Value[t.id])throw new _e(`Nonexistent key: ${t.name}`);return this.id2Mask[t.id]}{const e=this.name2Id[t];if(null==e)throw new _e(`Feed dict has no SymbolicTensor name: ${t}`);return this.id2Mask[e]}}disposeMasks(){null!=this.id2Mask&&on(this.id2Mask)}}const l0=new OB,u0=new OB;function dg(n,t,e,r){const s=null!=e&&e.training,i=Array.isArray(n),o=i?n:[n],a=o.map(w=>w.name),u=[],c=t.names();for(const w of a)-1!==c.indexOf(w)?u.push(t.getValue(w)):u.push(null);null!=r&&(r.maxNumTensors=-1/0,r.minNumTensors=1/0);const p=a.join(",")+"|"+t.names().sort().join(",");let y,m=l0.get(p);if(null==m){const w=function wpe(n,t){J(null!=n&&n.length>0,()=>"Expected at least one fetch, got none");let e=[],r={};if(1===n.length){const s=r4(n[0],t);e=s.sorted,r=s.recipientMap}else{const s=new Set;for(const i of n){const{sorted:o,recipientMap:a}=r4(i,t);for(const u of o)s.has(u.name)||(e.push(u),s.add(u.name));for(const u in a)null==r[u]&&(r[u]=new Set),a[u].forEach(c=>r[u].add(c))}}return{sorted:e,recipientCounts:xpe(r)}}(o,t);m=w.sorted,y=w.recipientCounts,l0.put(p,m),u0.put(p,y)}y={},s||Object.assign(y,u0.get(p));const _=new _u(t);for(let w=0;w<m.length;++w){if(null!=r){const de=DI().numTensors;de>r.maxNumTensors&&(r.maxNumTensors=de),de<r.minNumTensors&&(r.minNumTensors=de)}const T=m[w],I=T.sourceLayer;if(I instanceof a0)continue;const O=[],M=[],V=[];let z=!1;for(const de of T.inputs){const pe=_.getValue(de),Te=_.getMask(de);O.push(pe),M.push(Te),null!=Te&&(z=!0),s||(y[de.name]--,0===y[de.name]&&!t.hasKey(de)&&-1===a.indexOf(de.name)&&!pe.isDisposed&&!0!==de.sourceLayer.stateful&&V.push(pe))}z&&((e=e||{}).mask=M[0]);const G=Wn(I.apply(O,e));let Q=null;I.supportsMasking&&(Q=I.computeMask(O,M));const ne=Tpe(T),oe=Array.isArray(ne)?ne:[ne];for(let de=0;de<oe.length;++de){_.hasKey(oe[de])||_.add(oe[de],G[de],Array.isArray(Q)?Q[0]:Q);const pe=a.indexOf(oe[de].name);-1!==pe&&(u[pe]=G[de])}s||on(V)}return _.disposeMasks(),i?u:u[0]}function xpe(n){const t={};for(const e in n)t[e]=n[e].size;return t}function r4(n,t){const e=new Set,r=[],s={};for(const a of t.names())e.add(a);const i=[],o=[];for(i.push(n);i.length>0;){const a=i[i.length-1];if(e.has(a.name)){i.pop();continue}const u=o[o.length-1]===i.length-1;if(0===a.inputs.length||u)i.pop(),r.push(a),e.add(a.name),u&&o.pop();else{o.push(i.length-1);for(const c of a.inputs)null==s[c.name]&&(s[c.name]=new Set),s[c.name].add(a.name),!e.has(c.name)&&i.push(c)}}return{sorted:r,recipientMap:s}}function Tpe(n){let t;if(1===n.sourceLayer.inboundNodes.length)t=n.sourceLayer.output;else{let e=null;for(let r=0;r<n.sourceLayer.inboundNodes.length;++r)for(const s of n.sourceLayer.inboundNodes[r].outputTensors)if(s.id===n.id){e=r;break}t=n.sourceLayer.getOutputAt(e)}return t}function mD(n,t){return Ce(()=>Ns(Tt(me(n,n),t,!0)))}De().registerFlag("TOPOLOGICAL_SORT_CACHE_MAX_ENTRIES",()=>100,function vpe(n){l0?.setMaxEntries(n),u0?.setMaxEntries(n)});class hg extends _h{getConfig(){return{}}}Qe((()=>{class n extends hg{constructor(e){super(),this.defaultMaxValue=2,this.defaultAxis=0,this.maxValue=null!=e.maxValue?e.maxValue:this.defaultMaxValue,this.axis=null!=e.axis?e.axis:this.defaultAxis}apply(e){return Ce(()=>{const r=mD(e,this.axis),s=Si(r,0,this.maxValue);return me(e,At(s,Ze(Zr(),r)))})}getConfig(){return{maxValue:this.maxValue,axis:this.axis}}}return n.className="MaxNorm",n})()),Qe((()=>{class n extends hg{constructor(e){super(),this.defaultAxis=0,this.axis=null!=e.axis?e.axis:this.defaultAxis}apply(e){return Ce(()=>At(e,Ze(Zr(),mD(e,this.axis))))}getConfig(){return{axis:this.axis}}}return n.className="UnitNorm",n})()),Qe((()=>{class n extends hg{apply(e){return Na(e)}}return n.className="NonNeg",n})()),Qe((()=>{class n extends hg{constructor(e){super(),this.defaultMinValue=0,this.defaultMaxValue=1,this.defaultRate=1,this.defaultAxis=0,this.minValue=null!=e.minValue?e.minValue:this.defaultMinValue,this.maxValue=null!=e.maxValue?e.maxValue:this.defaultMaxValue,this.rate=null!=e.rate?e.rate:this.defaultRate,this.axis=null!=e.axis?e.axis:this.defaultAxis}apply(e){return Ce(()=>{const r=mD(e,this.axis),s=Ze(me(this.rate,Si(r,this.minValue,this.maxValue)),me(1-this.rate,r));return me(e,At(s,Ze(Zr(),r)))})}getConfig(){return{minValue:this.minValue,maxValue:this.maxValue,rate:this.rate,axis:this.axis}}}return n.className="MinMaxNorm",n})());const s4={maxNorm:"MaxNorm",minMaxNorm:"MinMaxNorm",nonNeg:"NonNeg",unitNorm:"UnitNorm"};function Jr(n){return iD(n)}function i4(n,t={}){return og(n,_o.getMap().classNameMap,t,"constraint")}function es(n){return null==n?null:"string"==typeof n?i4({className:n in s4?s4[n]:n,config:{}}):n instanceof hg?n:i4(n)}function vu(n){return gD.apply(this,arguments)}function gD(){return(gD=Ve(function*(n){if(null==n)return;const t=[],e=[],r=[];for(const s in n){const i=n[s];if("number"!=typeof i){const o=i;t.push(o.data()),e.push(s),r.push(o)}}if(t.length>0){const s=yield Promise.all(t);for(let i=0;i<s.length;++i)n[e[i]]=s[i][0];on(r)}})).apply(this,arguments)}function o4(n){if(null!=n)for(const t in n){const e=n[t];"number"!=typeof e&&e.dispose()}}class Ph{constructor(){this.validationData=null}setParams(t){this.params=t}onEpochBegin(t,e){return Ve(function*(){})()}onEpochEnd(t,e){return Ve(function*(){})()}onBatchBegin(t,e){return Ve(function*(){})()}onBatchEnd(t,e){return Ve(function*(){})()}onTrainBegin(t){return Ve(function*(){})()}onTrainEnd(t){return Ve(function*(){})()}setModel(t){}}class Cpe{constructor(t,e=10){null==t&&(t=[]),this.callbacks=t,this.queueLength=e}append(t){this.callbacks.push(t)}setParams(t){for(const e of this.callbacks)e.setParams(t)}setModel(t){for(const e of this.callbacks)e.setModel(t)}onEpochBegin(t,e){var r=this;return Ve(function*(){null==e&&(e={});for(const s of r.callbacks)yield s.onEpochBegin(t,e)})()}onEpochEnd(t,e){var r=this;return Ve(function*(){null==e&&(e={});for(const s of r.callbacks)yield s.onEpochEnd(t,e)})()}onBatchBegin(t,e){var r=this;return Ve(function*(){null==e&&(e={});for(const s of r.callbacks)yield s.onBatchBegin(t,e)})()}onBatchEnd(t,e){var r=this;return Ve(function*(){null==e&&(e={});for(const s of r.callbacks)yield s.onBatchEnd(t,e)})()}onTrainBegin(t){var e=this;return Ve(function*(){null==t&&(t={});for(const r of e.callbacks)yield r.onTrainBegin(t)})()}onTrainEnd(t){var e=this;return Ve(function*(){null==t&&(t={});for(const r of e.callbacks)yield r.onTrainEnd(t)})()}}class Ipe extends Ph{constructor(){super()}onEpochBegin(t){var e=this;return Ve(function*(){e.seen=0,e.totals={}})()}onBatchEnd(t,e){var r=this;return Ve(function*(){null==e&&(e={});const s=null==e.size?0:e.size;r.seen+=s;for(const i in e){const o=e[i];if("number"==typeof o)r.totals.hasOwnProperty(i)||(r.totals[i]=0),r.totals[i]=r.totals[i]+o*s;else{let a;i in r.totals?a=r.totals[i]:r.totals[i]=0;const u=Ce(()=>Ze(r.totals[i],me(o,s)));r.totals[i]=u,a?.dispose()}}})()}onEpochEnd(t,e){var r=this;return Ve(function*(){if(null!=e)for(const s of r.params.metrics)null!=r.totals[s]&&("number"==typeof r.totals[s]?e[s]=r.totals[s]/r.seen:Ce(()=>{const i=me(At(1,r.seen),r.totals[s]);e[s]=i,r.totals[s].dispose(),as(e[s])}))})()}}class Epe extends Ph{onTrainBegin(t){var e=this;return Ve(function*(){e.epoch=[],e.history={}})()}onEpochEnd(t,e){var r=this;return Ve(function*(){null==e&&(e={}),r.epoch.push(t);for(const s in e)null==r.history[s]&&(r.history[s]=[]),r.history[s].push(e[s])})()}syncData(){var t=this;return Ve(function*(){const e=[],r=[],s=[];for(const o in t.history){const a=t.history[o];for(let u=0;u<a.length;++u)"number"!=typeof a[u]&&(e.push(a[u].data()),r.push(o),s.push(u))}const i=yield Promise.all(e);for(let o=0;o<i.length;++o)t.history[r[o]][s[o]].dispose(),t.history[r[o]][s[o]]=i[o][0]})()}}class Dpe extends Ph{constructor(t,e){if(super(),this.currentEpoch=0,this.nowFunc=t.nowFunc,this.nextFrameFunc=t.nextFrameFunc||YV,this.yieldEvery=e||"auto","auto"===this.yieldEvery&&(this.yieldEvery=125),"never"===this.yieldEvery&&null!=t.onYield)throw new Error("yieldEvery is `never` but you provided an `onYield` callback. Either change `yieldEvery` or remove the callback");H1(this.yieldEvery)&&(this.maybeWait=function jhe(n,t,e){let s,r=null!=e?e():ri();return(...o)=>{const a=null!=e?e():ri();return a-r<t||(r=a,s=n(...o)),s}}(this.maybeWait.bind(this),this.yieldEvery,this.nowFunc)),this.trainBegin=t.onTrainBegin,this.trainEnd=t.onTrainEnd,this.epochBegin=t.onEpochBegin,this.epochEnd=t.onEpochEnd,this.batchBegin=t.onBatchBegin,this.batchEnd=t.onBatchEnd,this.yield=t.onYield}maybeWait(t,e,r){var s=this;return Ve(function*(){const i=[];null!=s.yield&&(yield vu(r),i.push(s.yield(t,e,r))),i.push(s.nextFrameFunc()),yield Promise.all(i)})()}onEpochBegin(t,e){var r=this;return Ve(function*(){r.currentEpoch=t,null!=r.epochBegin&&(yield vu(e),yield r.epochBegin(t,e))})()}onEpochEnd(t,e){var r=this;return Ve(function*(){const s=[];null!=r.epochEnd&&(yield vu(e),s.push(r.epochEnd(t,e))),"epoch"===r.yieldEvery&&s.push(r.nextFrameFunc()),yield Promise.all(s)})()}onBatchBegin(t,e){var r=this;return Ve(function*(){null!=r.batchBegin&&(yield vu(e),yield r.batchBegin(t,e))})()}onBatchEnd(t,e){var r=this;return Ve(function*(){const s=[];null!=r.batchEnd&&(yield vu(e),s.push(r.batchEnd(t,e))),"batch"===r.yieldEvery?s.push(r.nextFrameFunc()):H1(r.yieldEvery)&&s.push(r.maybeWait(r.currentEpoch,t,e)),yield Promise.all(s)})()}onTrainBegin(t){var e=this;return Ve(function*(){null!=e.trainBegin&&(yield vu(t),yield e.trainBegin(t))})()}onTrainEnd(t){var e=this;return Ve(function*(){null!=e.trainEnd&&(yield vu(t),yield e.trainEnd(t))})()}}function a4(n,t){return null==n&&(n={}),n instanceof Ph?[n]:Array.isArray(n)&&n[0]instanceof Ph?n:Wn(n).map(r=>new Dpe(r,t))}let Ape=(()=>{class n{constructor(){}static registerCallbackConstructor(e,r){J(e>=0&&Number.isInteger(e),()=>`Verbosity level is expected to be an integer >= 0, but got ${e}`),n.checkForDuplicate(r),null==n.constructors[e]&&(n.constructors[e]=[]),n.constructors[e].push(r)}static checkForDuplicate(e){for(const r in n.constructors)n.constructors[+r].forEach(i=>{if(i===e)throw new _e("Duplicate callback constructor.")})}static clear(){n.constructors={}}static createCallbacks(e){const r=[];for(const s in n.constructors){const i=+s;e>=i&&r.push(...n.constructors[i])}return r.map(s=>new s)}}return n.constructors={},n})();function l4(n,t,e,r,s,i,o,a,u){const c=new Epe,p=[new Ipe,...Ape.createCallbacks(t)];null!=n&&p.push(...n),p.push(c);const m=new Cpe(p);return m.setParams({epochs:e,initialEpoch:r,samples:s,steps:i,batchSize:o,verbose:t,doValidation:a,metrics:u}),{callbackList:m,history:c}}function _l(n,t={},e=!1){return og(n,_o.getMap().classNameMap,t,"layer",e)}function c0(n,t){return Ce(()=>{"float32"!==n.dtype&&(n=pt(n,"float32"));const e=Tt(ug(n),t,!0),r=vh(e.shape,Zr()),s=Ns(hl(e,r));return At(n,s)})}function d0(n,t){return Ce(()=>wr(ug(vt(t,n)),-1))}function yD(n,t){return Ce(()=>wr(Kr(vt(t,n)),-1))}function bD(n,t){return Ce(()=>{const e=vt(n,t),r=Si(Kr(n),Zr(),Number.MAX_VALUE),s=Kr(At(e,r));return me(100,wr(s,-1))})}function pg(n,t,e=!1){return Ce(()=>{if(e)t=zv(t);else{const r=Tt(t,t.shape.length-1,!0);t=At(t,r)}return t=Si(t,Zr(),1-Zr()),Zn(Tt(me(pt(n,"float32"),Gi(t)),t.shape.length-1))})}function h0(n,t,e=!1){return Ce(()=>{const r=pt(Zm(function rpe(n){const t=[yu(n.shape)];return be(n,t)}(n)),"int32"),s=(t=Si(t,Zr(),1-Zr())).shape;return pg(be(sE(r,s[s.length-1]),s),t,e)})}function p0(n,t){return Ce(()=>{let e;return e=Si(t,Zr(),1-Zr()),e=Gi(At(e,vt(1,e))),wr(function Ppe(n,t){if(!hn(n.shape,t.shape))throw new _e(`logits and labels must have the same shape, but got shapes ${JSON.stringify(n.shape)} and ${JSON.stringify(t.shape)}`);return Ce(()=>{const e=Na(t),r=Zn(Kr(t));return Ze(vt(e,me(t,n)),Nv(ji(r)))})}(n,e),-1)})}function u4(n,t){return Ce(()=>{const e=c0(n,-1),r=c0(t,-1),s=me(e,r);return Zn(Tt(s,-1))})}const f0={meanSquaredError:d0,meanAbsoluteError:yD,meanAbsolutePercentageError:bD,meanSquaredLogarithmicError:function kpe(n,t){return Ce(()=>{const e=Si(t,Zr(),Number.MAX_VALUE),r=Gi(Ze(1,e)),s=Si(n,Zr(),Number.MAX_VALUE),i=Gi(Ze(1,s));return wr(ug(vt(r,i)),-1)})},squaredHinge:function Npe(n,t){return Ce(()=>{const e=hl(0,vt(1,me(n,t)));return wr(ug(e),-1)})},hinge:function Ope(n,t){return Ce(()=>{const e=hl(0,vt(1,me(n,t)));return wr(e,-1)})},categoricalHinge:function Rpe(n,t){return Ce(()=>{const e=Tt(me(n,t),-1),r=wo(me(vt(1,n),t),-1);return hl(0,Ze(1,vt(r,e)))})},logcosh:function Mpe(n,t){return Ce(()=>{const e=Math.log(2),r=vt(t,n),s=vt(Ze(r,Ih(me(-2,r))),e);return wr(s,-1)})},categoricalCrossentropy:pg,sparseCategoricalCrossentropy:h0,binaryCrossentropy:p0,kullbackLeiblerDivergence:function Fpe(n,t){return Ce(()=>{const e=Si(n,Zr(),1),r=Si(t,Zr(),1);return Tt(me(n,Gi(At(e,r))),-1)})},poisson:function $pe(n,t){return Ce(()=>{const e=Gi(Ze(Zr(),t));return wr(vt(t,me(n,e)),-1)})},cosineProximity:u4};function _D(n){if("string"==typeof n){if(n in f0)return f0[n];let t=`Unknown loss ${n}`;throw n.toLowerCase().includes("softmaxcrossentropy")&&(t=`Unknown loss ${n}. Use "categoricalCrossentropy" as the string name for tf.losses.softmaxCrossEntropy`),new _e(t)}return n}function c4(n,t){return Ce(()=>{const e=me(.5,Hi(t)),r=Pa(Ci(t,e),n.dtype);return wr(Zo(n,r),-1)})}function d4(n,t){return Ce(()=>Pa(Zo(xh(n,-1),xh(t,-1)),"float32"))}function zpe(n,t){return p0(n,t)}function Upe(n,t){return n.rank===t.rank&&(n=Ic(n,[n.rank-1])),(t=xh(t,-1)).dtype!==n.dtype&&(t=pt(t,n.dtype)),pt(Zo(n,t),"float32")}const p4=pg,f4=h0,m0={binaryAccuracy:c4,categoricalAccuracy:d4,precision:function Bpe(n,t){return Ce(()=>{const e=function h4(n,t){return Ce(()=>pt(Tt(ka(Zo(n,1),Zo(t,1))),"float32"))}(n,t),r=function Vpe(n,t){return Ce(()=>pt(Tt(ka(Zo(n,0),Zo(t,1))),"float32"))}(n,t),s=Ze(e,r);return pt(Os(Ci(s,0),At(e,s),0),"float32")})},categoricalCrossentropy:p4,sparseCategoricalCrossentropy:f4,mse:d0,MSE:d0,mae:yD,MAE:yD,mape:bD,MAPE:bD,cosine:u4};function Ype(n){if("string"==typeof n&&n in m0)return m0[n];if("string"!=typeof n&&null!=n)return n;throw new _e(`Unknown metric ${n}`)}function g0(n){if(Ki(null!==n,`Unknown LossOrMetricFn ${n}`),"string"==typeof n)return n;{let t;for(const e of Object.keys(f0))if(f0[e]===n){t=e;break}if(void 0!==t)return t;for(const e of Object.keys(m0))if(m0[e]===n){t=e;break}return void 0!==t?t:n.name}}function g4(n,t,e=!1){if(null==n||"object"!=typeof n||Object.getPrototypeOf(n)!==Object.prototype||!vD(n))throw new Error("User-defined metadata is expected to be a JSON object, but is not.");if(e){const r=JSON.stringify(n);r.length>1048576&&console.warn(`User-defined metadata of model "${t}" is too large in size (length=${r.length} when serialized). It is not recommended to store such large objects in user-defined metadata. Please make sure its serialized length is <= 1048576.`)}}function vD(n){if(null===n)return!0;if("object"==typeof n){if(Object.getPrototypeOf(n)===Object.prototype){const t=Object.keys(n);for(const e of t)if("string"!=typeof e||!vD(n[e]))return!1;return!0}if(Array.isArray(n)){for(const t of n)if(!vD(t))return!1;return!0}return!1}{const t=typeof n;return"string"===t||"number"===t||"boolean"===t}}function y0(n,t,e=console.log){let r="";for(let s=0;s<n.length;++s)s>0&&(r=r.slice(0,r.length-1)+" "),r+=n[s],r=r.slice(0,t[s]),r+=" ".repeat(t[s]-r.length);e(r)}function tfe(n,t,e){let r,s;try{s=n.inboundNodes.map(u=>JSON.stringify(u.inputShapes)).join(",")}catch{s="multiple"}try{r=JSON.stringify(n.outputShape)}catch{r="multiple"}y0([`${n.name} (${n.getClassName()})`,s,r,n.countParams().toString()],t,e)}function nfe(n,t,e,r){let s,i;try{i=n.inboundNodes.map(m=>JSON.stringify(m.inputShapes)).join(",")}catch{i="multiple"}try{s=JSON.stringify(n.outputShape)}catch{s="multiple"}const o=[];for(const m of n.inboundNodes)if(!(null!=e&&e.length>0&&-1===e.indexOf(m)))for(let y=0;y<m.inboundLayers.length;++y)o.push(`${m.inboundLayers[y].name}[${m.nodeIndices[y]}][${m.tensorIndices[y]}]`);const a=n.name,u=n.getClassName(),c=0===o.length?"":o[0];y0([`${a} (${u})`,i,s,n.countParams().toString(),c],t,r);for(let m=1;m<o.length;++m)y0(["","","","",o[m]],t,r)}function y4(n,t,e){return("inboundNodes"===n||"outputLayers"===n||"inputLayers"===n)&&0===t&&"string"==typeof e}function wD(n,t){if(null===n)return null;if("string"==typeof n)return Ac(n);if("number"==typeof n||"boolean"==typeof n)return n;if(n instanceof Array){const e=[],r=n.length;for(let s=0;s<r;++s){const i=n[s];y4(t,s,i)?e.push(i):e.push(wD(i,t))}return e}{const e={};for(const r of Object.keys(n)){const s=n[r];if("name"===r&&"string"==typeof s)e[r]=s;else{const i=Ac(r);e[i]=wD(s,i)}}return e}}function xD(n,t){if(null==n)return null;if("string"==typeof n)return bl(n);if("number"==typeof n||"boolean"==typeof n)return n;if(n instanceof Array){const e=[],r=n.length;for(let s=0;s<r;++s){const i=n[s];y4(t,s,i)?e.push(i):e.push(xD(i,t))}return e}{const e={};for(const r of Object.keys(n)){const s=n[r];e[bl(r)]="name"!==r&&"className"!==r||"string"!=typeof s?xD(s,r):s}return e}}class ta extends an{constructor(t){if(super({}),this.containerNodes=new Set,this.name=t.name,null==this.name){const M=this.getClassName().toLowerCase();this.name=Jv(M)}if(this.supportsMasking=!1,this.trainable_=!0,this.inputs=Array.isArray(t.inputs)?t.inputs.slice():[t.inputs],this.outputs=Array.isArray(t.outputs)?t.outputs.slice():[t.outputs],gu(this.inputs).length!==this.inputs.length)throw new _e(`The list of inputs passed to the model is redundant. All inputs should only appear once. Found: ${this.inputs.map(M=>M.name)}`);gu(this.outputs).length!==this.outputs.length&&console.warn(`The list of outputs passed to the model is redundant. All outputs should only appear once. Found: ${this.outputs.map(M=>M.name)}`),this.inputLayers=[],this.inputLayersNodeIndices=[],this.inputLayersTensorIndices=[],this.outputLayers=[],this.outputLayersNodeIndices=[],this.outputLayersTensorIndices=[],this.layers=[],this.internalContainerRefs=[];for(const M of this.outputs){const z=M.nodeIndex,G=M.tensorIndex;this.outputLayers.push(M.sourceLayer),this.outputLayersNodeIndices.push(z),this.outputLayersTensorIndices.push(G)}for(const M of this.inputs){const V=M.sourceLayer,z=M.nodeIndex,G=M.tensorIndex;Ki(0===z,"input layer has >1 nodes"),Ki(0===G,"input layer has >1 tensors"),this.inputLayers.push(V),this.inputLayersNodeIndices.push(z),this.inputLayersTensorIndices.push(G)}this.inputNames=[],this.outputNames=[],this.feedInputShapes=[],this.feedInputNames=[],this.feedOutputNames=[];for(let M=0;M<this.inputLayers.length;M++){const V=this.inputLayers[M];if(!(V instanceof a0))throw new TypeError(`Input layers to a LayersModel must be InputLayer objects. Received inputs: ${t.inputs}. Input ${M} (0-based) originates from layer type ${V.getClassName()}.`);this.inputNames.push(V.name),this.feedInputShapes.push(V.batchInputShape),this.feedInputNames.push(V.name)}for(const M of this.outputLayers)this.outputNames.push(M.name);this.internalInputShapes=this.inputs.map(M=>M.shape),this.internalOutputShapes=this.outputs.map(M=>M.shape);const e={},r={},s={},i={},o={},a=[],u=(M,V,z,G,Q,ne)=>{(null==G||null==Q||null==ne)&&(G=M.sourceLayer,Q=M.nodeIndex,ne=M.tensorIndex);const oe=G.inboundNodes[Q];if(-1!==z.indexOf(oe))throw new Co(`The tensor ${M.name} at layer "${G.name}" is part of a cycle.`);if(-1!==V.indexOf(oe))return;this.containerNodes.add(ta.nodeKey(G,Q)),G.id in o||(o[G.id]=Object.keys(o).length),-1===z.indexOf(oe)&&z.push(oe);const de=oe.inboundLayers.length;for(let pe=0;pe<de;pe++)u(oe.inputTensors[pe],V,z,oe.inboundLayers[pe],oe.nodeIndices[pe],oe.tensorIndices[pe]);for(V.push(oe);z.indexOf(oe)>=0;)z.splice(z.indexOf(oe),1);a.push(oe)},c=[],p=[];for(const M of this.outputs)u(M,c,p);const m=a.slice().reverse();for(const M of m){r[M.id]=M,M.id in e||(e[M.id]=0);let V=e[M.id];V=Math.max(V,null==s[M.outboundLayer.id]?0:s[M.outboundLayer.id]),s[M.outboundLayer.id]=V,i[M.outboundLayer.id]=M.outboundLayer,e[M.id]=V;for(let G=0;G<M.inboundLayers.length;G++){const oe=M.inboundLayers[G].inboundNodes[M.nodeIndices[G]];e[oe.id]=Math.max(V+1,null==e[oe.id]?0:e[oe.id]),r[oe.id]=oe}}const y={};for(const M in e){const V=e[M];V in y||(y[V]=[]),y[V].push(r[M])}const _={};for(const M in s){const V=s[M];V in _||(_[V]=[]),_[V].push(i[M])}let w=Object.keys(_).map(M=>parseInt(M,10)).sort(Zv);this.layers=[];for(const M of w){const V=_[M];V.sort((z,G)=>{const Q=o[z.id],ne=o[G.id];return Q<ne?-1:Q>ne?1:0});for(const z of V)z instanceof ta&&this.internalContainerRefs.push(z),this.layers.push(z)}this.layersByDepth=_,w=Object.keys(y).map(M=>parseInt(M,10)).sort(Zv);const T=this.inputs.slice(),I=[];for(const M of w)for(const V of y[M]){const z=V.outboundLayer;if(null!=z){for(const G of V.inputTensors)if(-1===T.indexOf(G))throw new Co(`Graph disconnected: cannot obtain value for tensor ${G} at layer "${z.name}". The following previous layers were accessed without issue: ${I}`);for(const G of V.outputTensors)T.push(G);I.push(z.name)}}this.nodesByDepth=y;const O=this.layers.map(M=>M.name);for(const M of O){const V=O.filter(z=>z===M).length;if(1!==V)throw new Co(`The name "${M}" is used ${V} times in the model. All layer names should be unique. Layer names: `+JSON.stringify(O))}this.outboundNodes=[],this.inboundNodes=[],new o0({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:this.inputs.map(M=>null),outputMasks:this.outputs.map(M=>null),inputShapes:this.inputs.map(M=>M.shape),outputShapes:this.outputs.map(M=>M.shape)}),this.built=!0,this._refCount=1}assertNotDisposed(){if(0===this._refCount)throw new Error(`Container '${this.name}' is already disposed.`)}dispose(){this.assertNotDisposed();const t={refCountAfterDispose:null,numDisposedVariables:0};if(0==--this._refCount){for(const e of this.layers)t.numDisposedVariables+=e.dispose().numDisposedVariables;for(const e of this.internalContainerRefs)t.numDisposedVariables+=e.dispose().numDisposedVariables}return t.refCountAfterDispose=this._refCount,t}get trainable(){return this.trainable_}set trainable(t){this.layers.forEach(e=>{e._trainableWeights.forEach(r=>r.trainable=t)}),this.trainable_=t}get trainableWeights(){if(this._trainableWeights.length>0)throw new _e("Container instance unexpectedly contains _trainableWeights.The trainable weights of a Container are a union of the trainable weights of its consituent Layers. Its own _trainableWeights must remain an empty Array.");if(!this.trainable)return[];let t=[];for(const e of this.layers)t=t.concat(e.trainableWeights);return t}get nonTrainableWeights(){const t=[];for(const e of this.layers)t.push(...e.nonTrainableWeights);if(!this.trainable){const e=[];for(const r of this.layers)e.push(...r.trainableWeights);return e.concat(t)}return t}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}loadWeights(t,e=!0){const r={};let s=0;for(const o of this.layers)for(const a of o.weights){if(null!=r[a.originalName])throw new _e(`Duplicate weight name: ${a.originalName}`);r[a.originalName]=a,s++}const i=[];for(const o in t){let a=o;if(null==r[o]){const u=o.split("/");a=u.slice(0,-2).concat([u[u.length-1]]).join("/")}if(null!=r[a])i.push([r[a],t[o]]);else if(e)throw new _e(`Provided weight data has no target variable: ${o}`);delete r[a]}if(e){const o=[];for(const a in r)o.push(a);if(o.length>0)throw new _e(`${o.length} of ${s} weights are not set: ${o}`)}fD(i)}updatedConfig(){const t=this.getConfig(),e={};return e.className=this.getClassName(),e.config=t,e.kerasVersion="tfjs-layers 4.5.0",e.backend="TensorFlow.js",e}toJSON(t,e=!0){const r=xD(this.updatedConfig());return e?JSON.stringify(r):r}call(t,e){return Ce(()=>{t=Wn(t);const r=new _u;for(let s=0;s<this.inputs.length;++s)r.add(this.inputs[s],t[s]);return dg(this.outputs,r,e)})}computeMask(t,e){return Ce(()=>{let r;return t=Wn(t),r=null==e?Dc(null,t.length):Wn(e),this.runInternalGraph(t,r)[1]})}computeOutputShape(t){const e=r0(t);if(e.length!==this.inputLayers.length)throw new _e(`Invalid inputShape argument ${t}: model has ${this.inputLayers.length} tensor inputs.`);const r={};for(let a=0;a<e.length;a++)r[this.inputLayers[a].name+"_0_0"]=e[a];const s=Object.keys(this.nodesByDepth).map(a=>parseInt(a,10)).sort(Zv);if(s.length>1)for(const a of s){const u=this.nodesByDepth[a];for(const c of u){const p=c.outboundLayer;if(-1!==this.inputLayers.map(T=>T.id).indexOf(p.id))continue;const m=[];for(let T=0;T<c.inboundLayers.length;T++)m.push(r[`${c.inboundLayers[T].name}_${c.nodeIndices[T]}_${c.tensorIndices[T]}`]);const _=r0(p.computeOutputShape(ai(m))),w=p.inboundNodes.indexOf(c);for(let T=0;T<_.length;T++)r[`${p.name}_${w}_${T}`]=_[T]}}const i=[],o=[];for(let a=0;a<this.outputLayers.length;a++)o.push(`${this.outputLayers[a].name}_${this.outputLayersNodeIndices[a]}_${this.outputLayersTensorIndices[a]}`);for(let a=0;a<o.length;a++){const u=o[a];Ki(u in r),i.push(r[u])}return ai(i)}runInternalGraph(t,e){null==e&&(e=Dc(null,t.length));const r={};for(let u=0;u<this.inputs.length;++u)r[this.inputs[u].id]=[t[u],e[u]];const s=Object.keys(this.nodesByDepth).map(u=>parseInt(u,10)).sort(Zv);for(const u of s){const c=this.nodesByDepth[u];for(const p of c){const m=p.outboundLayer,y=p.inputTensors,_=p.outputTensors,w=new Array;for(const T of y)T.id in r&&w.push(r[T.id]);if(w.length===y.length){let I,O,M,V,T={};if(null!=p.callArgs&&(T=p.callArgs),1===w.length){const[z,G]=w[0];null==T.mask&&(T.mask=G),M=Wn(m.call(z,T)),V=Wn(m.computeMask(z,G)),I=[z],O=[G]}else I=w.map(z=>z[0]),O=w.map(z=>z[1]),null==T.mask&&(T.mask=O),M=Wn(m.call(I,T)),V=Wn(m.computeMask(I,O));if(m.activityRegularizer)throw new Qt("LayersModel invocation with concrete Tensor value(s) in the presence of activity regularizer(s) is not supported yet.");for(let z=0;z<_.length;++z)r[_[z].id]=[M[z],V[z]]}}}const i=[],o=[],a=[];for(const u of this.outputs){Ki(u.id in r,`Could not compute output ${u.name} : ${u.id}`);const[c,p]=r[u.id];a.push(c.shape),i.push(c),o.push(p)}return[i,o,a]}buildNodeConversionMap(t){const e={};let r;for(const s of this.layers){r=s instanceof ta?1:0;for(let i=0;i<s.inboundNodes.length;i++){const o=ta.nodeKey(s,i);this.containerNodes.has(o)&&(e[o]=r,r+=1)}}return e}getLayer(t,e){if(null!=e){if(this.layers.length<=e)throw new _e(`Was asked to retrieve layer at index ${e}, but model only has ${this.layers.length} layer(s).`);return this.layers[e]}if(null==t)throw new _e("Provide either a layer name or layer index");for(const r of this.layers)if(r.name===t)return r;throw new _e(`No such layer: ${t}`)}calculateLosses(){return Ce(()=>{const t=[];for(const e of this.layers)for(let r=0;r<e.inboundNodes.length;++r){const s=ta.nodeKey(e,r);this.containerNodes.has(s)&&t.push(...e.calculateLosses())}return t})}getConfig(){const t={name:this.name},e=this.buildNodeConversionMap(this.layers),r=[];for(const o of this.layers){const a=o.getClassName(),u=o.getConfig(),c=[];for(let m=0;m<o.inboundNodes.length;m++){const y=o.inboundNodes[m],_=ta.nodeKey(o,m);let w={};if(this.containerNodes.has(_)){if(y.callArgs)try{JSON.stringify(y.callArgs),w=y.callArgs}catch{console.warn(`Layer ${o.name} was passed non-serializable keyword arguments: ${y.callArgs}. They will not be included in the serialized model (and thus will be missing at deserialization time).`),w={}}if(y.inboundLayers.length>0){const T=[];for(let I=0;I<y.inboundLayers.length;I++){const O=y.inboundLayers[I],V=y.tensorIndices[I];let G=e[ta.nodeKey(O,y.nodeIndices[I])];null==G&&(G=0),T.push([O.name,G,V,w])}c.push(T)}}}const p={};p.name=o.name,p.className=a,p.config=u,p.inboundNodes=c,r.push(p)}t.layers=r;const s=[];for(let o=0;o<this.inputLayers.length;o++){const a=this.inputLayers[o],c=ta.nodeKey(a,this.inputLayersNodeIndices[o]);if(!this.containerNodes.has(c))continue;let p=e[c];null==p&&(p=0),s.push([a.name,p,this.inputLayersTensorIndices[o]])}t.inputLayers=s;const i=[];for(let o=0;o<this.outputLayers.length;o++){const a=this.outputLayers[o],c=ta.nodeKey(a,this.outputLayersNodeIndices[o]);if(!this.containerNodes.has(c))continue;let p=e[c];null==p&&(p=0),i.push([a.name,p,this.outputLayersTensorIndices[o]])}return t.outputLayers=i,t}static fromConfig(t,e,r={},s=!1){const i={},o={};function a(I,O){I.name in o?o[I.name].push(O):o[I.name]=[O]}function u(I,O){const M=[];let V;for(const z of O){const G=z[0],Q=z[1],ne=z[2];if(V=null==z[3]?{}:z[3],!(G in i))return void a(I,O);const oe=i[G];if(oe.inboundNodes.length<=Q)return void a(I,O);M.push(oe.inboundNodes[Q].outputTensors[ne])}M.length>0&&I.apply(ai(M),V)}function c(I){const O=I.name,M=_l(I,null!=e.customObjects?e.customObjects:{});M.setFastWeightInitDuringBuild(s),i[O]=M,I.inboundNodes.forEach(z=>{if(!(z instanceof Array))throw new _e(`Corrupted configuration, expected array for nodeData: ${z}`);a(M,z)})}const p=e.name,m=e.layers;for(const I of m)c(I);for(;!Uhe(o);)for(const I of m){const O=i[I.name];if(O.name in o){const M=o[O.name];delete o[O.name];for(const V of M)u(O,V)}}const y=[],_=[],w=e.inputLayers;for(const I of w){const O=I[0],M=I[1],V=I[2];Ki(O in i),y.push(i[O].inboundNodes[M].outputTensors[V])}const T=e.outputLayers;for(const I of T){const O=I[0],M=I[1],V=I[2];Ki(O in i),_.push(i[O].inboundNodes[M].outputTensors[V])}return new t({inputs:y,outputs:_,name:p})}get stateful(){if(this._stateful)throw new _e("Container instance unexpectedly has _stateful = true. The statefulness of a Container is determined by the Layers it contains. Its _stateful property must remain the default false.");for(const t of this.layers)if(t.stateful)return!0;return!1}resetStates(){Ce(()=>{this.layers.forEach(t=>{t.stateful&&t.resetStates()})})}}function _4(n,t){return function b4(n,t,e){const r=t.length;if(null==n||Array.isArray(n)&&0===n.length)return t.map(s=>null);if(1===r)return Array.isArray(n)&&1===n.length?n:"object"==typeof n&&t[0]in n?[n[t[0]]]:[n];if(Array.isArray(n)){if(n.length!==r)throw new Error(`Provided ${e} is an array of ${n.length} element(s), but the model has ${r} outputs. Make sure a set of weights is provided for each model output.`);return n}if("object"==typeof n&&Object.keys(n).length>0&&"object"==typeof n[Object.keys(n)[0]]){const s=[];return t.forEach(i=>{s.push(i in n?n[i]:null)}),s}throw new Error(`The model has multiple (${r}) outputs, so ${e} must be either an array with ${r} elements or an object with ${t} keys. Provided ${e} not understood: ${JSON.stringify(n)}`)}(n,t,"classWeight")}function v4(n,t,e,r){return SD.apply(this,arguments)}function SD(){return(SD=Ve(function*(n,t,e,r){if(null!=t||null!=r)throw new Error("Support sampleWeight is not implemented yet");if(null!=e){const s=Ce(()=>{if(1===n.shape.length)return cl(n);if(2===n.shape.length){if(n.shape[1]>1)return xh(n,1);if(1===n.shape[1])return be(n,[n.shape[0]]);throw new Error(`Encountered unexpected last-dimension size (${n.shape[1]}) during handling of class weights. The size is expected to be >= 1.`)}throw new Error(`Unexpected rank of target (y) tensor (${n.rank}) during handling of class weights. The rank is expected to be 1 or 2.`)}),i=Array.from(yield s.data());on(s);const o=[];return i.forEach(a=>{if(null==e[a])throw new Error(`classWeight must contain all classes in the training data. The class ${a} exists in the data but not in classWeight`);o.push(e[a])}),oi(o,"float32")}return null})).apply(this,arguments)}function rfe(n,t){return me(n,t)}function w4(n,t){let e,r;e=t.xs,r=t.ys,J(null!=e&&null!=r,()=>`A Dataset iterator for fitDataset() is expected to generate objects of the form \`{xs: xVal, ys: yVal}\`, where the two values may be \`tf.Tensor\`, an array of Tensors, or a map of string to Tensor.  The provided Dataset instead generates ${t}`);const i=x4("input",n.inputNames,e),o=x4("output",n.outputNames,r),a=i[0].shape[0];J(i.length===n.inputs.length,()=>`LayersModel has ${n.inputs.length} inputs, but the dataset provides ${i.length} inputs.  (Expected input keys: ${JSON.stringify(n.inputNames)})`),J(o.length===n.outputs.length,()=>`LayersModel has ${n.outputs.length} outputs, but the dataset provides ${o.length} outputs.  (Expected output keys: ${JSON.stringify(n.outputNames)})`);for(let u=0;u<i.length;u++)J(i[u].shape[0]===a,()=>`Batch size mismatch: input ${n.inputNames[u]} has ${i[u].shape[0]}; expected  ${a} based on input ${n.inputNames[0]}.`);for(let u=0;u<o.length;u++)J(o[u].shape[0]===a,()=>`Batch size mismatch: output ${n.outputNames[u]} has ${o[u].shape[0]}; expected  ${a} based on input ${n.inputNames[0]}.`);return{xs:i,ys:o}}function x4(n,t,e){if(e instanceof nr)return[e];if(Array.isArray(e))return J(e.length===t.length,()=>`Received an array of ${e.length} Tensors, but expected ${t.length} to match the ${n} keys ${t}.`),e;{const r=[];for(const s of t){if(null==e[s])throw new _e(`The feature data generated by the dataset lacks the required ${n} key '${s}'.`);r.push(e[s])}return r}}function CD(){return(CD=Ve(function*(n,t,e){const r=null!=e.batchesPerEpoch;if(J(null!=n.optimizer,()=>"You must compile a model before training/testing. Use LayersModel.compile(modelCompileConfig)."),J(null!=e,()=>"For fitDataset(), the 2nd argument (config) is required, but it is not provided in this call."),J(null!=e.epochs&&e.epochs>0&&Number.isInteger(e.epochs),()=>`For fitDataset(), config.epochs is expected to be a positive integer, but got ${e.epochs}`),J(!r||e.batchesPerEpoch>0&&Number.isInteger(e.batchesPerEpoch),()=>`For fitDataset(), config.batchesPerEpoch is expected to be a positive integer if specified, but got ${e.batchesPerEpoch}`),J(null==e.validationSplit,()=>"`validationSplit` is not supported by `fitDataset()`. Use validationData instead."),n.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");n.isTraining=!0;try{const s=null!=e.validationData;let i,o;if(s)if(T4(e.validationData))J(null==e.validationBatches||e.validationBatches>0&&Number.isInteger(e.validationBatches),()=>`For fitDataset() with dataset-based validation, config.validationBatches is expected not to be provided, or to be a positive integer, but got ${e.validationBatches}`);else{const I=function ife(n){if(3===n.length)throw new Qt("Validation with sample weights is not implemented yet.");return{xs:n[0],ys:n[1]}}(e.validationData);i=I.xs,o=I.ys}const a=n.makeTrainFunction(),u=n.getDedupedMetricsNames();let c;c=s?u.slice().concat(u.map(I=>"val_"+I)):u.slice();const p=a4(e.callbacks,e.yieldEvery),m=null==e.verbose?1:e.verbose,{callbackList:y,history:_}=l4(p,m,e.epochs,null,null,function afe(n,t){let e=null;return null!=t.batchesPerEpoch?e=t.batchesPerEpoch:Number.isFinite(n.size)&&(e=n.size),e}(t,e),null,s,c);y.setModel(n),n.history=_,yield y.onTrainBegin(),n.stopTraining_=!1;let w=null==e.initialEpoch?0:e.initialEpoch,T=yield t.iterator();for(;w<e.epochs;){const I={};yield y.onEpochBegin(w);let O=0,M=0;for(r||(T=yield t.iterator());!r||O<e.batchesPerEpoch;){const V=yield T.next();if(r&&V.done){console.warn(`You provided \`batchesPerEpoch\` as ${e.batchesPerEpoch}, but your dataset iterator ran out of data after ${O} batches; interrupting training. Make sure that your dataset can generate at least \`batchesPerEpoch * epochs\` batches (in this case, ${e.batchesPerEpoch*e.epochs} batches). You may need to use the repeat() function when building your dataset.`);break}if(null!=V.value){const{xs:z,ys:G}=w4(n,V.value),Q={};Q.batch=M,Q.size=z[0].shape[0],yield y.onBatchBegin(M,Q);const ne=[];if(null!=e.classWeight){const pe=_4(e.classWeight,n.outputNames);for(let Te=0;Te<pe.length;++Te)ne.push(yield v4(G[Te],null,pe[Te]))}const oe=z.concat(G).concat(ne),de=a(oe);on(oe);for(let pe=0;pe<u.length;++pe){const Ae=de[pe];Q[u[pe]]=Ae,as(Ae)}yield y.onBatchEnd(M,Q),o4(Q),M++,O++}if(r?O>=e.batchesPerEpoch:V.done){if(s){let z;z=T4(e.validationData)?Wn(yield n.evaluateDataset(e.validationData,{batches:e.validationBatches})):Wn(n.evaluate(i,o,{batchSize:null==e.validationBatchSize?32:e.validationBatchSize,verbose:0}));for(let G=0;G<n.metricsNames.length;++G)I[`val_${n.metricsNames[G]}`]=z[G]}break}if(n.stopTraining_)break}if(yield y.onEpochEnd(w,I),w++,n.stopTraining_)break}return yield y.onTrainEnd(),yield n.history.syncData(),n.history}finally{n.isTraining=!1}})).apply(this,arguments)}function T4(n){return"function"==typeof n.iterator}function ID(){return(ID=Ve(function*(n,t,e){const r=null!=(e=e||{}).batches,s=n.testFunction;let i=[];if(e.verbose>0)throw new Qt("Verbose mode is not implemented yet.");J(!r||e.batches>0&&Number.isInteger(e.batches),()=>`Test loop expects \`batches\` to be a positive integer, but received ${JSON.stringify(e.batches)}`);const o=function lfe(n){return"function"==typeof n.next}(t)?t:yield t.iterator();let a=0,u=0;for(;!r||u<e.batches;){const c=yield o.next();if(i=Ce(()=>{if(c.value){const{xs:p,ys:m}=w4(n,c.value),y=p.concat(m),_=Ce(()=>s(y));if(on(y),0===u)for(let T=0;T<_.length;++T)i.push(Rt(0));const w=y[0].shape[0];for(let T=0;T<_.length;++T){const I=_[T],O=i[T];i[T]=Ce(()=>Ze(i[T],me(w,I))),u>0&&on(O)}on(_),a+=w,++u}return i}),c.done){r&&console.warn(`Your dataset iterator ran out of data during evaluateDataset(). Interrupting evalution. Make sure that your dataset can generate at least \`batches\` batches (in this case, ${e.batches} batches). You may need to use the repeat() function when building your dataset.`);break}}for(let c=0;c<i.length;++c){const p=i[c];i[c]=At(i[c],a),on(p)}return ai(i)})).apply(this,arguments)}function ED(n){J(n>0&&Number.isInteger(n),()=>`batchSize is required to be a positive integer, but got ${n}`)}function fg(n,t,e){return null==n?[null]:Array.isArray(n)?n.map(r=>Oc(r,t,e-t)):Oc(n,t,e-t)}function DD(n,t){return Ce(()=>null==n?null:Array.isArray(n)?n.map(e=>DD(e,t)):GB(n,"int32"===t.dtype?t:pt(t,"int32")))}function AD(n,t){const e=[];let r=0,s=null;for(;r<n;)s=r+t,s>=n&&(s=n),e.push([r,s]),r=s;return e}function S4(n){const t=[];n instanceof nr&&(n=[n]);for(let e=0;e<n.length;++e){const r=n[e];if(1===r.rank)t.push(lg(r,1));else{if(0===r.rank)throw new Error("Expected tensor to be at least 1D, but received a 0D tensor (scalar).");t.push(r)}}return t}function na(n,t){if(null==n)return;const e=[];if(t instanceof nr)e.push(t.id);else if(Array.isArray(t))t.forEach(s=>e.push(s.id));else if(null!=t)for(const s in t)e.push(t[s].id);const r=[];if(n instanceof nr)-1===e.indexOf(n.id)&&r.push(n);else if(Array.isArray(n))n.forEach(s=>{-1===e.indexOf(s.id)&&r.push(s)});else if(null!=n)for(const s in n){const i=n[s];-1===e.indexOf(i.id)&&r.push(i)}r.forEach(s=>{s.isDisposed||s.dispose()})}function kD(n){return Array.isArray(n)}function C4(n){return!function cfe(n){return n instanceof nr}(n)&&!kD(n)}function I4(n,t,e,r=!0,s=""){if(null==t||0===t.length){if(null!=n){let o=!1;if(kD(n)&&n.length>0)o=!0;else if(C4(n)){for(const a in n)if(n.hasOwnProperty(a)){o=!0;break}}else o=!0;if(o)throw new _e(`Error when checking model ${s} expected no data, but got ${n}`)}return[]}if(null==n)return t.map(o=>null);let i;if(C4(n)){i=[];for(const o of t){if(null==n[o])throw new _e(`No data provided for "${o}". Need data for each key in: ${t}`);i.push(n[o])}}else if(kD(n)){if(n.length!==t.length)throw new _e(`Error when checking model ${s}: the Array of Tensors that you are passing to your model is not the size the model expected. Expected to see ${t.length} Tensor(s), but instead got the following list of Tensor(s): ${n}`);i=n}else{if(t.length>1)throw new _e(`The model ${s} expects ${t.length} Tensor(s), but only received one Tensor. Found: Tensor with shape ${n.shape}`);i=[n]}if(i=S4(i),null!=e)for(let o=0;o<t.length;++o){if(null==e[o])continue;const a=i[o];if(a.shape.length!==e[o].length)throw new _e(`Error when checking ${s}: expected ${t[o]} to have ${e[o].length} dimension(s). but got array with shape ${a.shape}`);for(let u=0;u<e[o].length;++u){if(0===u&&!r)continue;const p=e[o][u];if(null!=p&&p>=0&&a.shape[u]!==p)throw new _e(`${s} expected a batch of elements where each example has shape [${e[o].slice(1,e[o].length)}] (i.e.,tensor shape [*,${e[o].slice(1,e[o].length)}]) but the ${s} received an input with ${a.shape[0]} examples, each with shape [${a.shape.slice(1,a.shape.length)}] (tensor shape [${a.shape}])`)}}return i}function E4(n,t,e,r=!0,s=""){let i;if(Array.isArray(n)){if(n.length!==t.length)throw new _e(`Error when checking model ${s}: the Array of Tensors that you are passing to your model is not the size the the model expected. Expected to see ${t.length} Tensor(s), but instead got ${n.length} Tensors(s).`);i=n}else{if(t.length>1)throw new _e(`The model expects ${t.length} ${s} Tensors, but only received one Tensor. Found: array with shape ${JSON.stringify(n.shape)}.`);i=[n]}if(null!=e)for(let o=0;o<t.length;++o){if(null==e[o])continue;const a=i[o];if(a.shape.length!==e[o].length)throw new _e(`Error when checking ${s}: expected ${t[o]} to have ${e[o].length} dimension(s), but got array with shape ${JSON.stringify(a.shape)}`);for(let u=0;u<e[o].length;++u){if(0===u&&!r)continue;const p=e[o][u];if(null!=p&&p!==a.shape[u])throw new _e(`Error when checking ${s}: expected ${t[o]} to have shape ${JSON.stringify(e[o])} but got array with shape ${JSON.stringify(a.shape)}.`)}}}let Fh=(()=>{class n extends ta{constructor(e){super(e),this.isTraining=!1}summary(e,r,s=console.log){if(!this.built)throw new _e("This model has never been called, thus its weights have not been created yet. So no summary can be displayed. Build the model first (e.g., by calling it on some test data).");!function Qpe(n,t,e,r=console.log){const s=function efe(n){let t=!0;const e=[],r=[];for(const s in n.nodesByDepth)e.push(n.nodesByDepth[s]);for(const s of e){if(s.length>1||1===s.length&&s[0].inboundLayers.length>1){t=!1;break}r.push(...s)}if(t)for(const s of n.layers){let i=!1;for(const o of s.inboundNodes)if(-1!==r.indexOf(o)){if(i){t=!1;break}i=!0}if(!t)break}return t}(n),i=["Layer (type)","Input Shape","Output shape","Param #"];let o;if(s?(t=t||90,e=e||[.32,.61,.89,1]):(t=t||115,e=e||[.24,.48,.7,.8,1]),e[e.length-1]<=1&&(e=e.map(p=>Math.floor(t*p))),!s){i.push("Receives inputs"),o=[];for(const p in n.nodesByDepth)o.push(...n.nodesByDepth[p])}r("_".repeat(t)),y0(i,e,r),r("=".repeat(t));const a=n.layers;for(let p=0;p<a.length;++p)s?tfe(a[p],e,r):nfe(a[p],e,o,r),r((p===a.length-1?"=":"_").repeat(t));n.checkTrainableWeightsConsistency();const u=function Jpe(n){let t;return t=s0(null!=n.collectedTrainableWeights?n.collectedTrainableWeights:n.trainableWeights),t}(n),c=s0(n.nonTrainableWeights);r(`Total params: ${u+c}`),r(`Trainable params: ${u}`),r(`Non-trainable params: ${c}`),r("_".repeat(t))}(this,e,r,s)}compile(e){if(null==e.loss&&(e.loss=[]),this.loss=e.loss,"string"==typeof e.optimizer)this.optimizer_=function Zpe(n){const t={Adagrad:()=>Oh.adagrad(.01),Adadelta:()=>Oh.adadelta(1,.95,Zr()),Adam:()=>Oh.adam(.001,.9,.999,Zr()),Adamax:()=>Oh.adamax(.002,.9,.999,Zr(),0),RMSProp:()=>Oh.rmsprop(.001,.9,0,Zr()),SGD:()=>Oh.sgd(.01)};if(t.adagrad=t.Adagrad,t.adadelta=t.Adadelta,t.adam=t.Adam,t.adamax=t.Adamax,t.rmsprop=t.RMSProp,t.sgd=t.SGD,n in t)return t[n]();throw new _e(`Unknown Optimizer ${n}`)}(e.optimizer),this.isOptimizerOwned=!0;else{if(!(e.optimizer instanceof lu))throw new _e("User-defined optimizer must be an instance of tf.Optimizer.");this.optimizer_=e.optimizer,this.isOptimizerOwned=!1}let r=[];if(Array.isArray(e.loss)||"string"==typeof e.loss||"function"==typeof e.loss)if(Array.isArray(e.loss)){if(e.loss.length!==this.outputs.length)throw new _e(`When passing an Array as loss, it should have one entry per model output. The model has ${this.outputs.length} output(s), but you passed loss=${e.loss}.`);r=e.loss.map(u=>_D(u))}else{const a=_D(e.loss);this.outputs.forEach(u=>{r.push(a)})}else{e.loss=e.loss;for(const a in e.loss)if(-1===this.outputNames.indexOf(a))throw new _e(`Unknown entry in loss dictionary: "${a}". Only expected the following keys: ${this.outputNames}`);for(const a of this.outputNames)null==e.loss[a]&&console.warn(`Output "${a}" is missing from loss dictionary. We assume this was done on purpose, and we will not be expecting data to be passed to ${a} during training`),r.push(_D(e.loss[a]))}this.lossFunctions=r,this.feedOutputNames=[],this.feedOutputShapes=[],this.feedLossFns=[];for(let a=0;a<this.outputs.length;++a){const u=this.internalOutputShapes[a];this.feedOutputNames.push(this.outputNames[a]),this.feedOutputShapes.push(u),this.feedLossFns.push(this.lossFunctions[a])}const s=[];this.metrics=e.metrics,this.metricsNames=["loss"],this.metricsTensors=[],Nc("loss",()=>{for(let a=0;a<this.outputs.length;++a)-1===s.indexOf(a)&&this.outputs.length>1&&(this.metricsTensors.push([this.lossFunctions[a],a]),this.metricsNames.push(this.outputNames[a]+"_loss"))});const i=function pfe(n,t){if(null==n||Array.isArray(n)&&0===n.length)return t.map(r=>[]);let e;if("string"==typeof n||"function"==typeof n)e=[n];else{if(!Array.isArray(n)&&"object"!=typeof n)throw new TypeError(`Type of metrics argument not understood. Expected an string,function, Array, or Object, found: ${n}`);e=n}if(Array.isArray(e))return t.map(r=>e);{const r=[];for(const s of t){let i=e.hasOwnProperty(s)?e[s]:[];Array.isArray(i)||(i=[i]),r.push(i)}return r}}(e.metrics,this.outputNames),o=(a,u,c)=>{this.outputNames.length>1&&(u=this.outputNames[a]+"_"+u),this.metricsNames.push(u),this.metricsTensors.push([c,a])};Nc("metric",()=>{for(let a=0;a<this.outputs.length;++a)-1===s.indexOf(a)&&(p=>{let y,_,w;for(const T of p){if("string"==typeof T&&-1!==["accuracy","acc","crossentropy","ce"].indexOf(T)){const O=this.internalOutputShapes[a];let M;1===O[O.length-1]||this.lossFunctions[a]===p0?-1!==["accuracy","acc"].indexOf(T)?_=c4:-1!==["crossentropy","ce"].indexOf(T)&&(_=zpe):this.lossFunctions[a]===h0?-1!==["accuracy","acc"].indexOf(T)?_=Upe:-1!==["crossentropy","ce"].indexOf(T)&&(_=f4):-1!==["accuracy","acc"].indexOf(T)?_=d4:-1!==["crossentropy","ce"].indexOf(T)&&(_=p4),-1!==["accuracy","acc"].indexOf(T)?M="acc":-1!==["crossentropy","ce"].indexOf(T)&&(M="ce"),w=_,y=""+M}else w=Ype(T),y=""+g0(T);let I;Nc(y,()=>{I=w}),o(a,y,I)}})(i[a])}),this.collectedTrainableWeights=this.trainableWeights}checkTrainableWeightsConsistency(){null!=this.collectedTrainableWeights&&this.trainableWeights.length!==this.collectedTrainableWeights.length&&console.warn("Discrepancy between trainableweights and collected trainable weights. Did you set `model.trainable` without calling `model.compile()` afterwards?")}evaluate(e,r,s={}){const i=null==s.batchSize?32:s.batchSize;ED(i);const a=this.standardizeUserDataXY(e,r,!0,i);try{const u=a[0].concat(a[1]);return this.makeTestFunction(),ai(this.testLoop(this.testFunction,u,i,s.verbose,s.steps))}finally{na(a[0],e),na(a[1],r)}}evaluateDataset(e,r){var s=this;return Ve(function*(){return s.makeTestFunction(),function ufe(n,t,e){return ID.apply(this,arguments)}(s,e,r)})()}checkNumSamples(e,r,s,i="steps"){let o;if(null!=s){if(o=null,null!=r)throw new _e(`If ${i} is set, batchSize must be null or undefined.Got batchSize = ${r}`)}else{if(null==e)throw new _e(`Either the input data should have a defined shape, or ${i} shoud be specified.`);o=Array.isArray(e)?e[0].shape[0]:e.shape[0]}return o}execute(e,r){if(Array.isArray(r)&&0===r.length)throw new _e("`outputs` is an empty Array, which is not allowed.");const s=Array.isArray(r),o=this.retrieveSymbolicTensors(s?r:[r]),a=new _u;if(e instanceof nr&&(e=[e]),Array.isArray(e)){if(e.length!==this.inputs.length)throw new _e(`The number of inputs provided (${e.length}) does not match the number of inputs of this model (${this.inputs.length}).`);for(let c=0;c<this.inputs.length;++c)a.add(this.inputs[c],e[c])}else for(const c of this.inputs){const p=e[c.name];if(null==p)throw new _e(`No value is provided for the model's input ${c.name}`);a.add(c,p)}const u=dg(o,a);return s?u:u[0]}retrieveSymbolicTensors(e){const r=Dc(null,e.length);let s=e.length;for(const i of this.layers){const o=Array.isArray(i.output)?i.output:[i.output],a=o.map(u=>u.name);for(let u=0;u<e.length;++u){const c=a.indexOf(e[u]);if(-1!==c&&(r[u]=o[c],s--),0===s)break}if(0===s)break}if(s>0){const i=[];throw r.forEach((o,a)=>{null==o&&i.push(e[a])}),new _e(`Cannot find SymbolicTensors for output name(s): ${JSON.stringify(i)}`)}return r}predictLoop(e,r=32,s=!1){return Ce(()=>{const i=this.checkNumSamples(e);if(s)throw new Qt("Verbose predictLoop() is not implemented yet.");const o=AD(i,r),a=this.outputs.map(u=>[]);for(let u=0;u<o.length;++u)Ce(()=>{const y=fg(e,o[u][0],o[u][1]),_=[];if(Array.isArray(y))for(let T=0;T<y.length;++T)_.push({key:this.inputs[T],value:y[T]});else _.push({key:this.inputs[0],value:y});const w=new _u(_);return dg(this.outputs,w)}).forEach((p,m)=>a[m].push(p));return ai(a.map(u=>Vr(u,0)))})}predict(e,r={}){const s=S4(e);E4(s,this.inputNames,this.feedInputShapes,!1);try{const i=null==r.batchSize?32:r.batchSize;return ED(i),this.predictLoop(s,i)}finally{na(s,e)}}predictOnBatch(e){E4(e,this.inputNames,this.feedInputShapes,!0);const r=(Array.isArray(e)?e[0]:e).shape[0];return this.predictLoop(e,r)}standardizeUserDataXY(e,r,s=!0,i){if(null==this.optimizer_)throw new Co("You must compile a model before training/testing. Use LayersModel.compile(modelCompileArgs).");const o=[];for(let a=0;a<this.feedOutputShapes.length;++a){const u=this.feedOutputShapes[a];o.push(this.feedLossFns[a]===h0?u.slice(0,u.length-1).concat([1]):u)}if(function dfe(n,t,e){const r=gu(n.map(i=>i.shape[0]));r.sort();const s=gu(t.map(i=>i.shape[0]));if(s.sort(),r.length>1)throw new _e(`All input Tensors (x) should have the same number of samples. Got array shapes: ${JSON.stringify(n.map(i=>i.shape))}`);if(s.length>1)throw new _e(`All target Tensors (y) should have the same number of samples. Got array shapes: ${JSON.stringify(t.map(i=>i.shape))}`);if(r.length>0&&s.length>0&&!hn(r,s))throw new _e(`Input Tensors should have the same number of samples as target Tensors. Found ${r[0]} input sample(s) and ${s[0]} target sample(s).`)}(e=I4(e,this.feedInputNames,this.feedInputShapes,!1,"input"),r=I4(r,this.feedOutputNames,o,!1,"target")),function hfe(n,t,e){const r=[d0,p0,pg];for(let s=0;s<n.length;++s){const i=n[s],o=t[s],a=e[s];if(null!=o){if(o===pg&&1===i.shape[i.shape.length-1])throw new _e(`You are passing a target array of shape ${i.shape} while using a loss 'categorical_crossentropy'. 'categorical_crossentropy'expects targets to be binary matrices (1s and 0s) of shape [samples, classes].`);if(-1!==r.indexOf(o)){const u=i.shape.slice(1),c=a.slice(1);for(let p=0;p<u.length;++p){const y=c[p];if(null!=y&&u[p]!==y)throw new _e(`A target Tensor with shape ${i.shape} was passed for an output of shape ${a}, while using a loss function that expects targets to have the same shape as the output.`)}}}}}(r,this.feedLossFns,this.feedOutputShapes),this.stateful&&null!=i&&i>0&&e[0].shape[0]%i!=0)throw new _e(`In a stateful network, you should only pass inputs with a number of samples that is divisible by the batch size ${i}. Found: ${e[0].shape[0]} sample(s).`);return[e,r]}standardizeUserData(e,r,s,i,o=!0,a){var u=this;return Ve(function*(){const[c,p]=u.standardizeUserDataXY(e,r,o,a);if(null!=s)throw new Error("sample weight is not supported yet.");let m=null;if(null!=i){const y=_4(i,u.outputNames);m=[];for(let _=0;_<y.length;++_)m.push(yield v4(p[_],null,y[_]))}return[c,p,m]})()}testLoop(e,r,s,i=0,o){return Ce(()=>{const a=this.checkNumSamples(r,s,o,"steps"),u=[];if(i>0)throw new Qt("Verbose mode is not implemented yet.");if(null!=o)throw new Qt("steps mode in testLoop() is not implemented yet");{const c=AD(a,s),p=oi(Qo(0,a));for(let m=0;m<c.length;++m){const y=c[m][0],_=c[m][1],w=Oc(p,y,_-y),T=DD(r,w),I=e(T);if(0===m)for(let O=0;O<I.length;++O)u.push(Rt(0));for(let O=0;O<I.length;++O)u[O]=Ze(u[O],me(_-y,I[O]))}for(let m=0;m<u.length;++m)u[m]=At(u[m],a)}return u})}getDedupedMetricsNames(){const e=this.metricsNames,r=[];for(let s=0;s<e.length;++s){const i=e[s];let o=i;RB(e,i)>1&&(o+=`_${RB(e.slice(0,s),i)}`),r.push(o)}return r}makeTrainFunction(){return e=>{const r=[],s=e.slice(0,this.inputs.length),i=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),o=e.slice(this.inputs.length+this.outputs.length,this.inputs.length+2*this.outputs.length),a=[],c=this.collectedTrainableWeights.map(y=>y.read());return[this.optimizer_.minimize(()=>{const y=[];for(let I=0;I<this.inputs.length;++I)y.push({key:this.inputs[I],value:s[I]});const _=new _u(y),w=dg(this.outputs,_,{training:!0});let T;for(let I=0;I<this.lossFunctions.length;++I){let M=(0,this.lossFunctions[I])(i[I],w[I]);null!=o[I]&&(M=rfe(M,o[I]));const V=wr(M);r.push(V),T=0===I?M:Ze(T,M)}for(let I=0;I<this.metricsTensors.length;++I){let O;if(this.outputs.length>1&&I<this.outputs.length)O=r[I];else{const V=this.metricsTensors[I][1];O=wr((0,this.metricsTensors[I][0])(i[V],w[V]))}as(O),a.push(O)}return T=wr(T),this.calculateLosses().forEach(I=>{T=Ze(T,I)}),T},!0,c)].concat(a)}}makeTestFunction(){this.testFunction=e=>Ce(()=>{const r=[];let s;const i=e.slice(0,this.inputs.length),o=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),a=[];for(let p=0;p<this.inputs.length;++p)a.push({key:this.inputs[p],value:i[p]});const u=new _u(a),c=dg(this.outputs,u);for(let p=0;p<this.lossFunctions.length;++p){const y=wr((0,this.lossFunctions[p])(o[p],c[p]));s=0===p?y:Ze(s,y),r.push(s)}for(let p=0;p<this.metricsTensors.length;++p){const y=this.metricsTensors[p][1],_=wr((0,this.metricsTensors[p][0])(o[y],c[y]));r.push(_)}return r})}fit(e,r,s={}){var i=this;return Ve(function*(){if(i.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");let o,a,u,c,p,m,y,_,w;i.isTraining=!0;try{const T=null==s.batchSize?32:s.batchSize;ED(T);const I=!1,O=yield i.standardizeUserData(e,r,s.sampleWeight,s.classWeight,I,T);o=O[0],a=O[1],w=O[2];let V,M=!1;if(null!=s.validationData&&s.validationData.length>0){if(M=!0,2!==s.validationData.length)throw 3===s.validationData.length?new Qt("validationData including sample weights is not supported yet."):new _e(`When passing validation data, it must contain 2 (valX, valY) or 3 (valX, valY, valSampleWeight) items; ${s.validationData} is invalid.`);p=s.validationData[0],m=s.validationData[1];const Te=!0,Ae=yield i.standardizeUserData(p,m,null,null,Te,T);y=Ae[0],_=Ae[1],V=y.concat(_)}else if(null!=s.validationSplit&&s.validationSplit>0&&s.validationSplit<1){M=!0;const Te=Math.floor(o[0].shape[0]*(1-s.validationSplit)),Ae=o[0].shape[0];y=fg(o,Te,Ae),u=o,o=fg(o,0,Te),_=fg(a,Te,Ae),c=a,a=fg(a,0,Te),V=y.concat(_)}else null!=s.validationSteps&&(M=!0);const z=o.concat(a).concat(w);i.checkTrainableWeightsConsistency();const G=i.makeTrainFunction(),Q=i.getDedupedMetricsNames();let ne,oe;M?(i.makeTestFunction(),ne=i.testFunction,oe=Q.slice().concat(Q.map(Te=>"val_"+Te))):(ne=null,V=[],oe=Q.slice());const de=a4(s.callbacks,s.yieldEvery);return yield i.fitLoop(G,z,Q,T,s.epochs,s.verbose,de,ne,V,s.shuffle,oe,s.initialEpoch,null,null)}finally{i.isTraining=!1,na(o,e),na(a,r),na(u,e),na(c,r),na(y,p),na(_,m),null!=w&&on(w)}})()}fitLoop(e,r,s,i,o,a,u,c,p,m,y,_,w,T){var I=this;return Ve(function*(){null==i&&(i=32),null==o&&(o=1),null==m&&(m=!0),null==_&&(_=0);let O=!1;if(null!=c&&null!=p&&(O=!0),null!=T&&(O=!0,null==w))throw new _e("Can only use `validationSteps` when doing step-wise training, i.e., `stepsPerEpoch` must be set.");const M=I.checkNumSamples(r,i,w,"steps_per_epoch");let V;null!=M&&(V=Qo(0,M)),null==a&&(a=1);const{callbackList:z,history:G}=l4(u,a,o,_,M,w,i,O,y);z.setModel(I),I.history=G,yield z.onTrainBegin(),I.stopTraining_=!1;for(let Q=_;Q<o;++Q){yield z.onEpochBegin(Q);const ne={};if(null!=w)throw new Qt("stepsPerEpoch mode is not implemented yet.");{if("batch"===m)throw new Qt("batch shuffling is not implemneted yet");m&&IL(V);const oe=oi(V),de=AD(M,i);for(let pe=0;pe<de.length;++pe){const Te={};if(yield z.onBatchBegin(pe,Te),Ce(()=>{const Ae=de[pe][0],Oe=de[pe][1],Me=Oc(oe,Ae,Oe-Ae);Te.batch=pe,Te.size=Oe-Ae;const Pe=DD(r,Me),ve=e(Pe);for(let Se=0;Se<s.length;++Se){const ke=ve[Se];Te[s[Se]]=ke,as(ke)}if(pe===de.length-1&&O){const Se=I.testLoop(c,p,i);for(let xe=0;xe<s.length;++xe){const ke=s[xe],We=Se[xe];as(We),ne["val_"+ke]=We}}}),yield z.onBatchEnd(pe,Te),o4(Te),I.stopTraining_)break}oe.dispose()}if(yield z.onEpochEnd(Q,ne),I.stopTraining_)break}return yield z.onTrainEnd(),yield I.history.syncData(),I.history})()}fitDataset(e,r){var s=this;return Ve(function*(){return function ofe(n,t,e){return CD.apply(this,arguments)}(s,e,r)})()}trainOnBatch(e,r){var s=this;return Ve(function*(){const i=yield s.standardizeUserData(e,r),o=i[0],a=i[1],c=s.makeTrainFunction()(o.concat(a)),p=[];for(const m of c){const y=yield m.data();p.push(y[0])}return on(c),na(i[0],e),na(i[1],r),ai(p)})()}getNamedWeights(e){const r=[],s=null!=e&&e.trainableOnly,i=s?this.trainableWeights:this.weights,o=this.getWeights(s);for(let a=0;a<i.length;++a)s&&!i[a].trainable||r.push({name:i[a].originalName,tensor:o[a]});return r}set stopTraining(e){this.stopTraining_=e}get stopTraining(){return this.stopTraining_}get optimizer(){return this.optimizer_}set optimizer(e){this.optimizer_!==e&&(this.optimizer_=e,this.isOptimizerOwned=!1)}dispose(){const e=super.dispose();if(0===e.refCountAfterDispose&&null!=this.optimizer&&this.isOptimizerOwned){const r=DI().numTensors;this.optimizer_.dispose(),e.numDisposedVariables+=r-DI().numTensors}return e}getLossIdentifiers(){let e;if("string"==typeof this.loss)e=bl(this.loss);else if(Array.isArray(this.loss)){for(const r of this.loss)if("string"!=typeof r)throw new Error("Serialization of non-string loss is not supported.");e=this.loss.map(r=>bl(r))}else{const r=Object.keys(this.loss);e={};const s=this.loss;for(const i of r){if("string"!=typeof s[i])throw new Error("Serialization of non-string loss is not supported.");e[i]=bl(s[i])}}return e}getMetricIdentifiers(){if("string"==typeof this.metrics||"function"==typeof this.metrics)return[bl(g0(this.metrics))];if(Array.isArray(this.metrics))return this.metrics.map(e=>bl(g0(e)));{const e={};for(const r in this.metrics)e[r]=bl(g0(this.metrics[r]));return e}}getTrainingConfig(){return{loss:this.getLossIdentifiers(),metrics:this.getMetricIdentifiers(),optimizer_config:{class_name:this.optimizer.getClassName(),config:this.optimizer.getConfig()}}}loadTrainingConfig(e){if(null!=e.weighted_metrics)throw new Error("Loading weight_metrics is not supported yet.");if(null!=e.loss_weights)throw new Error("Loading loss_weights is not supported yet.");if(null!=e.sample_weight_mode)throw new Error("Loading sample_weight_mode is not supported yet.");const s=_l(wD(e.optimizer_config));let i,o;if("string"==typeof e.loss)i=Ac(e.loss);else if(Array.isArray(e.loss))i=e.loss.map(a=>Ac(a));else if(null!=e.loss){i={};for(const a in e.loss)i[a]=Ac(e.loss[a])}if(Array.isArray(e.metrics))o=e.metrics.map(a=>Ac(a));else if(null!=e.metrics){o={};for(const a in e.metrics)o[a]=Ac(e.metrics[a])}this.compile({loss:i,metrics:o,optimizer:s})}save(e,r){var s=this;return Ve(function*(){if("string"==typeof e){const m=u3(e);if(0===m.length)throw new _e(`Cannot find any save handlers for URL '${e}'`);if(m.length>1)throw new _e(`Found more than one (${m.length}) save handlers for URL '${e}'`);e=m[0]}if(null==e.save)throw new _e("LayersModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");const i=yield fI(s.getNamedWeights(r)),c={modelTopology:s.toJSON(null,!1),format:"layers-model",generatedBy:"TensorFlow.js tfjs-layers v4.5.0",convertedBy:null};if(null!=r&&r.includeOptimizer&&null!=s.optimizer){c.trainingConfig=s.getTrainingConfig();const m="optimizer",{data:y,specs:_}=yield fI(yield s.optimizer.getWeights(),m);i.specs.push(..._),i.data=_v([i.data,y])}return null!=s.userDefinedMetadata&&(g4(s.userDefinedMetadata,s.name,!0),c.userDefinedMetadata=s.userDefinedMetadata),c.weightData=i.data,c.weightSpecs=i.specs,e.save(c)})()}setUserDefinedMetadata(e){g4(e,this.name),this.userDefinedMetadata=e}getUserDefinedMetadata(){return this.userDefinedMetadata}}return n.className="Model",n})();Qe(Fh),Qe((()=>{class n extends Fh{}return n.className="Functional",n})()),Qe((()=>{class n extends Fh{constructor(e){if(super({inputs:[],outputs:[]}),e=e||{},this.trainable=!0,this.built=!1,this.name=null!=e.name?e.name:Jv("sequential_"),null!=e.layers)for(const r of e.layers)this.add(r)}checkShape(e){if(e.inboundNodes[0].outputTensors[0].shape.some(s=>s<0))throw new _e(`Negative dimension size caused by adding layer ${e.name} with input shape [${e.inboundNodes[0].inputTensors[0].shape}]`)}add(e){const r=e instanceof n||e instanceof Fh;let s;if(r){if(s=e,1!==s.outputs.length)throw new _e("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");if(1!==s.inputs.length)throw new _e("All layers in a Sequential model should have a single input tensor. For multi-input layers, use the functional API.")}if(0===this.outputs.length){if(0===e.inboundNodes.length){if(null==e.batchInputShape)throw new _e("The first layer in a Sequential model must get an `inputShape` or `batchInputShape` argument.");const i=function bpe(n){if(null==n.batchShape&&null==n.shape)throw new Error("Please provide to Input either a `shape` or a `batchShape` argument. Note that `shape` does not include the batch dimension.");if(null!=n.batchShape&&null!=n.shape)throw new _e("Please provide either a `shape` or `batchShape` argument to Input, but not both.");let t=n.batchShape;null!=n.shape&&null==t&&(t=[null].concat(n.shape));let e=n.dtype;return null==e&&(e="float32"),new a0({batchInputShape:t,name:n.name,dtype:e,sparse:n.sparse}).inboundNodes[0].outputTensors[0]}({batchShape:e.batchInputShape,dtype:e.dtype,name:e.name+"_input"});e.apply(i)}if(r)this.outputs=s.outputs,this.inputs=s.inputs;else{if(1!==e.inboundNodes.length)throw new _e(`A layer added to a Sequential model must not already be connected somewhere else. LayersModel received layer ${e.name} which has ${e.inboundNodes.length} pre-existing inbound connections.`);if(1!==e.inboundNodes[0].outputTensors.length)throw new _e("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(e),this.outputs=[e.inboundNodes[0].outputTensors[0]],this.inputs=n4(this.outputs[0])}this.inboundNodes=[],new o0({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:Dc(null,this.inputs.length),outputMasks:[null],inputShapes:this.inputs.map(i=>i.shape),outputShapes:this.outputs[0].shape})}else{const i=e.apply(this.outputs[0]);if(Array.isArray(i))throw new TypeError("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(e),this.outputs=[i],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}this.layers.push(e),this.built=!1}pop(){if(0===this.layers.length)throw new TypeError("There are no layers in the model.");if(this.layers.pop(),0===this.layers.length)this.outputs=[],this.inboundNodes=[],this.outboundNodes=[];else{const e=this.layers.length-1;this.layers[e].outboundNodes=[],this.outputs=[this.layers[e].output],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}}call(e,r){return null==this.model&&this.build(),this.model.call(e,r)}build(e){if(Tn(e),0===this.inputs.length||0===this.outputs.length)throw new TypeError("Sequential model cannot be built: model is empty. Add some layers first.");this.model=new Fh({inputs:this.inputs,outputs:this.outputs[0],name:this.name+"_model"}),this.model.trainable=this.trainable,this.supportsMasking=this.model.supportsMasking,this.inputLayers=this.model.inputLayers,this.inputLayersNodeIndices=this.model.inputLayersNodeIndices,this.inputLayersTensorIndices=this.model.inputLayersTensorIndices,this.outputLayers=this.model.outputLayers,this.outputLayersNodeIndices=this.model.outputLayersNodeIndices,this.outputLayersTensorIndices=this.model.outputLayersTensorIndices,this.nodesByDepth=this.model.nodesByDepth,this.containerNodes=this.model.containerNodes,this.outputNames=this.model.outputNames,this.inputNames=this.model.inputNames,this.built=!0}countParams(){return this.built||this.build(),super.countParams()}summary(e,r,s=console.log){this.built||this.build(),super.summary(e,r,s)}setWeights(e){null==this.model&&this.build(),this.model.setWeights(e)}evaluate(e,r,s={}){if(!this.built)throw new Co("The model needs to be compiled before being used.");return this.model.evaluate(e,r,s)}evaluateDataset(e,r){var s=this;return Ve(function*(){if(!s.built)throw new Co("The model needs to be compiled before being used.");return s.model.evaluateDataset(e,r)})()}predict(e,r={}){return null==this.model&&this.build(),this.model.predict(e,r)}predictOnBatch(e){return null==this.model&&this.build(),this.model.predictOnBatch(e)}compile(e){this.build(),this.model.compile(e),this.optimizer_=this.model.optimizer,this.isOptimizerOwned=this.model.isOptimizerOwned,this.loss=this.model.loss,this.metrics=this.model.metrics,this.metricsTensors=this.model.metricsTensors,this.metricsNames=this.model.metricsNames}get optimizer(){return null==this.model?void 0:this.model.optimizer}set optimizer(e){this.model.optimizer=e}fit(e,r,s={}){var i=this;return Ve(function*(){if(!i.built)throw new Co("The model needs to be compiled before being used.");return i.model.fit(e,r,s)})()}fitDataset(e,r){var s=this;return Ve(function*(){if(!s.built)throw new Co("The model needs to be compiled before being used.");return s.model.fitDataset(e,r)})()}trainOnBatch(e,r){var s=this;return Ve(function*(){return s.model.trainOnBatch(e,r)})()}static fromConfig(e,r,s={},i=!1){let o,a={};if(r instanceof Array){if(null==r[0].className||"Merge"===r[0].className)throw new _e("Legacy serialization format not supported yet.");o=r}else J(null!=r.layers,()=>"When the config data for a Sequential model is not an Array, it must be an Object that contains the 'layers' field."),o=r.layers,delete r.layers,a=r;const u=new e(a);if(!(u instanceof n))throw new Qt(`Sequential.fromConfig called on non-Sequential input: ${u}`);for(const c of o){const m=_l(c,void 0,i);i&&m.setFastWeightInitDuringBuild(!0),u.add(m)}return u}set stopTraining(e){if(null==this.model)throw new _e("Cannot set the stopTraining property of a sequential model before it is compiled.");this.model.stopTraining=e}get stopTraining(){if(null==this.model)throw new _e("Cannot get the stopTraining property of a sequential model before it is compiled.");return this.model.stopTraining}getConfig(){const e=[];for(const r of this.layers){const s={};s.className=r.getClassName(),s.config=r.getConfig(),e.push(s)}return{name:this.name,layers:e}}}return n.className="Sequential",n})());class li extends _h{getConfig(){return{}}}Qe((()=>{class n extends li{apply(e,r=1){return function ipe(n,t=1){if(1!==t)throw new Qt(`Support for alpha values other than 1 (${t}) is not implemented yet.`);return Km(n)}(e,r)}}return n.className="elu",n})()),Qe((()=>{class n extends li{apply(e){return dE(e)}}return n.className="selu",n})()),Qe((()=>{class n extends li{apply(e){return Na(e)}}return n.className="relu",n})()),Qe((()=>{class n extends li{apply(e){return Ce(()=>Sc(6,Na(e)))}}return n.className="relu6",n})()),Qe((()=>{class n extends li{apply(e){return e}}return n.className="linear",n})()),Qe((()=>{class n extends li{apply(e){return Aa(e)}}return n.className="sigmoid",n})()),Qe((()=>{class n extends li{apply(e){return function ape(n){return Ce(()=>{const t=Ze(.5,me(.2,n));return Si(t,0,1)})}(e)}}return n.className="hardSigmoid",n})()),Qe((()=>{class n extends li{apply(e){return Ih(e)}}return n.className="softplus",n})()),Qe((()=>{class n extends li{apply(e){return function ope(n){return Ce(()=>At(n,Ze(Kr(n),1)))}(e)}}return n.className="softsign",n})()),Qe((()=>{class n extends li{apply(e){return Sh(e)}}return n.className="tanh",n})());let D4=(()=>{class n extends li{apply(e,r=-1){return zv(e,r)}}return n.className="softmax",n})();function wu(n){return n.getClassName()}function MD(n,t={}){return og(n,_o.getMap().classNameMap,t,"activation")}function xu(n){if(null==n){return MD({className:"linear",config:{}})}if("string"==typeof n){const t={};return t.className=n,t.config={},MD(t)}return n instanceof li?n:MD(n)}Qe(D4),Qe((()=>{class n extends li{apply(e,r=-1){return eE(e,r)}}return n.className="logSoftmax",n})()),Qe((()=>{class n extends li{apply(e,r=1){return Ce(()=>me(Aa(me(e,r)),e))}}return n.className="swish",n})()),Qe((()=>{class n extends li{apply(e){return Ce(()=>me(e,Sh(Ih(e))))}}return n.className="mish",n})());class A4 extends _h{}Qe((()=>{class n extends A4{constructor(e){super(),function PD(n){if(null!=n&&"object"!=typeof n)throw new Error(`Argument to L1L2 regularizer's constructor is expected to be an object, but received: ${n}`)}(e),this.l1=null==e||null==e.l1?.01:e.l1,this.l2=null==e||null==e.l2?.01:e.l2,this.hasL1=0!==this.l1,this.hasL2=0!==this.l2}apply(e){return Ce(()=>{let r=Yr([1]);return this.hasL1&&(r=Ze(r,Tt(me(this.l1,Kr(e))))),this.hasL2&&(r=Ze(r,Tt(me(this.l2,ug(e))))),be(r,[])})}getConfig(){return{l1:this.l1,l2:this.l2}}static fromConfig(e,r){return new e({l1:r.l1,l2:r.l2})}}return n.className="L1L2",n})());const k4={l1l2:"L1L2"};function Un(n){return iD(n)}function N4(n,t={}){return og(n,_o.getMap().classNameMap,t,"regularizer")}function sr(n){return null==n?null:"string"==typeof n?N4({className:n in k4?k4[n]:n,config:{}}):n instanceof A4?n:N4(n)}function $h(n,t,e){if("number"==typeof n)return Dc(n,t);if(n.length!==t)throw new _e(`The ${e} argument must be an integer or tuple of ${t} integers. Received: ${n.length} elements.`);for(let r=0;r<t;++r){const s=n[r];if(!Jhe(s))throw new _e(`The ${e} argument must be an integer or tuple of ${t} integers. Received: ${JSON.stringify(n)} including a non-integer number ${s}`)}return n}function ra(n,t,e,r,s=1){if(null==n)return n;let o;return o="same"===e?n:n-(t+(t-1)*(s-1))+1,Math.floor((o+r-1)/r)}function Va(n,t,e,r){if(null==n)return null;if("valid"===r)n=n*t+bu([e-t,0]);else{if("same"!==r)throw new _e(`Unsupport padding mode: ${r}.`);n*=t}return n}function $D(n,t){return Ce(()=>(Or(t),"channelsFirst"===t?yn(n,[0,2,3,1]):n))}function O4(n,t){return Ce(()=>(Or(t),"channelsFirst"===t?yn(n,[0,2,3,4,1]):n))}function LD(n,t,e,r=[1,1],s="valid",i,o,a=null){return Ce(()=>{if(null==i&&(i="channelsLast"),Or(i),3!==n.rank&&4!==n.rank)throw new _e(`conv2dWithBiasActivation expects input to be of rank 3 or 4, but received ${n.rank}.`);if(3!==t.rank&&4!==t.rank)throw new _e(`conv2dWithBiasActivation expects kernel to be of rank 3 or 4, but received ${n.rank}.`);let u=$D(n,i);if("causal"===s)throw new Qt("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");return u=BV({x:u,filter:t,strides:r,pad:"same"===s?"same":"valid",dilations:o,dataFormat:"NHWC",bias:e,activation:a}),"channelsFirst"===i&&(u=yn(u,[0,3,1,2])),u})}Qe((()=>{class n extends an{constructor(e){super(e??{}),this.supportsMasking=!0,null!=e&&(this.maxValue=e.maxValue)}call(e,r){e=Lt(e);let s=Na(e);return null!=this.maxValue&&(s=Si(s,0,this.maxValue)),s}computeOutputShape(e){return e}getConfig(){const e={maxValue:this.maxValue},r=super.getConfig();return Object.assign(e,r),e}}return n.className="ReLU",n})()),Qe((()=>{class n extends an{constructor(e){super(e??{}),this.DEFAULT_ALPHA=.3,null==e&&(e={}),this.alpha=null==e.alpha?this.DEFAULT_ALPHA:e.alpha}call(e,r){const s=Lt(e);return kv(s,this.alpha)}computeOutputShape(e){return e}getConfig(){const e={alpha:this.alpha},r=super.getConfig();return Object.assign(e,r),e}}return n.className="LeakyReLU",n})()),Qe((()=>{class n extends an{constructor(e){if(super(e??{}),this.DEFAULT_ALPHA_INITIALIZER="zeros",null==e&&(e={}),this.supportsMasking=!0,this.alphaInitializer=rr(e.alphaInitializer||this.DEFAULT_ALPHA_INITIALIZER),this.alphaRegularizer=sr(e.alphaRegularizer),this.alphaConstraint=es(e.alphaConstraint),null==e.sharedAxes)this.sharedAxes=null;else if(Array.isArray(e.sharedAxes))this.sharedAxes=e.sharedAxes;else{if("number"!=typeof e.sharedAxes)throw new _e(`Expected sharedAxes to be a number or an array of numbers, but got ${e.sharedAxes}`);this.sharedAxes=[e.sharedAxes]}}build(e){const r=(e=Tn(e)).slice(1);if(null!=this.sharedAxes)for(const i of this.sharedAxes)r[i-1]=1;this.alpha=this.addWeight("alpha",r,"float32",this.alphaInitializer,this.alphaRegularizer,!0,this.alphaConstraint);const s={};if(null!=this.sharedAxes)for(let i=1;i<e.length;++i)s[i]=e[i];this.inputSpec=[new Qr({ndim:e.length,axes:s})],this.built=!0}call(e,r){return e=Lt(e),$v(e,this.alpha.read())}getConfig(){const e={alphaInitializer:hr(this.alphaInitializer),alphaRegularizer:Un(this.alphaRegularizer),alphaConstraint:Jr(this.alphaConstraint),sharedAxes:this.sharedAxes},r=super.getConfig();return Object.assign(e,r),e}}return n.className="PReLU",n})()),Qe((()=>{class n extends an{constructor(e){if(super(e??{}),this.DEFAULT_ALPHA=1,null==e&&(e={}),null!=e.alpha&&e.alpha!==this.DEFAULT_ALPHA)throw new Qt(`Non-default alpha value (${e.alpha}) is not supported by the ELU layer yet.`);this.alpha=null==e.alpha?this.DEFAULT_ALPHA:e.alpha}call(e,r){const s=Lt(e);return Km(s)}computeOutputShape(e){return e}getConfig(){const e={alpha:this.alpha},r=super.getConfig();return Object.assign(e,r),e}}return n.className="ELU",n})()),Qe((()=>{class n extends an{constructor(e){super(e??{}),this.DEFAULT_THETA=1,null==e&&(e={}),this.theta=null==e.theta?this.DEFAULT_THETA:e.theta}call(e,r){const s=Lt(e);return me(s,pt(Ci(s,this.theta),"float32"))}computeOutputShape(e){return e}getConfig(){const e={theta:this.theta},r=super.getConfig();return Object.assign(e,r),e}}return n.className="ThresholdedReLU",n})()),Qe((()=>{class n extends an{constructor(e){super(e??{}),this.DEFAULT_AXIS=1,null==e&&(e={}),this.softmax=(new D4).apply,this.axis=null==e.axis?this.DEFAULT_AXIS:e.axis}call(e,r){const s=Lt(e);return this.softmax(s,this.axis)}computeOutputShape(e){return e}getConfig(){const e={axis:this.axis},r=super.getConfig();return Object.assign(e,r),e}}return n.className="Softmax",n})());class b0 extends an{constructor(t,e){if(super(e),this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",b0.verifyArgs(e),this.rank=t,cs(this.rank,"rank"),1!==this.rank&&2!==this.rank&&3!==this.rank)throw new Qt(`Convolution layer for rank other than 1, 2, or 3 (${this.rank}) is not implemented yet.`);if(this.kernelSize=$h(e.kernelSize,t,"kernelSize"),this.strides=$h(null==e.strides?1:e.strides,t,"strides"),this.padding=null==e.padding?"valid":e.padding,Xi(this.padding),this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,Or(this.dataFormat),this.activation=xu(e.activation),this.useBias=null==e.useBias||e.useBias,this.biasInitializer=rr(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.biasConstraint=es(e.biasConstraint),this.biasRegularizer=sr(e.biasRegularizer),this.activityRegularizer=sr(e.activityRegularizer),this.dilationRate=$h(null==e.dilationRate?1:e.dilationRate,t,"dilationRate"),1===this.rank&&Array.isArray(this.dilationRate)&&1!==this.dilationRate.length)throw new _e(`dilationRate must be a number or an array of a single number for 1D convolution, but received ${JSON.stringify(this.dilationRate)}`);if(2===this.rank){if("number"==typeof this.dilationRate)this.dilationRate=[this.dilationRate,this.dilationRate];else if(2!==this.dilationRate.length)throw new _e(`dilationRate must be a number or array of two numbers for 2D convolution, but received ${JSON.stringify(this.dilationRate)}`)}else if(3===this.rank)if("number"==typeof this.dilationRate)this.dilationRate=[this.dilationRate,this.dilationRate,this.dilationRate];else if(3!==this.dilationRate.length)throw new _e(`dilationRate must be a number or array of three numbers for 3D convolution, but received ${JSON.stringify(this.dilationRate)}`)}static verifyArgs(t){if(Ki("kernelSize"in t,"required key 'kernelSize' not in config"),"number"!=typeof t.kernelSize&&!aD(t.kernelSize,"number",1,3))throw new _e(`BaseConv expects config.kernelSize to be number or number[] with length 1, 2, or 3, but received ${JSON.stringify(t.kernelSize)}.`)}getConfig(){const t={kernelSize:this.kernelSize,strides:this.strides,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,activation:wu(this.activation),useBias:this.useBias,biasInitializer:hr(this.biasInitializer),biasRegularizer:Un(this.biasRegularizer),activityRegularizer:Un(this.activityRegularizer),biasConstraint:Jr(this.biasConstraint)},e=super.getConfig();return Object.assign(t,e),t}}class Lh extends b0{constructor(t,e){super(t,e),this.kernel=null,Lh.verifyArgs(e),this.filters=e.filters,cs(this.filters,"filters"),this.kernelInitializer=rr(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.kernelConstraint=es(e.kernelConstraint),this.kernelRegularizer=sr(e.kernelRegularizer)}build(t){t=Tn(t);const e="channelsFirst"===this.dataFormat?1:t.length-1;if(null==t[e])throw new _e(`The channel dimension of the input should be defined. Found ${t[e]}`);const r=t[e],s=this.kernelSize.concat([r,this.filters]);this.kernel=this.addWeight("kernel",s,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[{ndim:this.rank+2,axes:{[e]:r}}],this.built=!0}call(t,e){return Ce(()=>{let r;t=Lt(t);const s=null==this.bias?null:this.bias.read(),i=PB(this.activation.getClassName());if(null!=i&&2===this.rank)r=LD(t,this.kernel.read(),s,this.strides,this.padding,this.dataFormat,this.dilationRate,i);else{if(1===this.rank)r=function R4(n,t,e,r=1,s="valid",i,o=1){return Ce(()=>{if(null==i&&(i="channelsLast"),Or(i),3!==n.shape.length)throw new _e(`The input of a conv1dWithBias operation should be 3, but is ${n.shape.length} instead.`);if(3!==t.shape.length)throw new _e(`The kernel for a conv1dWithBias operation should be 3, but is ${t.shape.length} instead`);if(null!=e&&1!==e.shape.length)throw new _e(`The bias for a conv1dWithBias operation should be 1, but is ${t.shape.length} instead`);if("channelsFirst"===i&&(n=yn(n,[0,2,1])),"causal"===s)throw new Qt("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");let a=HI(n,t,r,"same"===s?"same":"valid","NWC",o);return null!=e&&(a=ea(a,e)),a})}(t,this.kernel.read(),s,this.strides[0],this.padding,this.dataFormat,this.dilationRate[0]);else if(2===this.rank)r=LD(t,this.kernel.read(),s,this.strides,this.padding,this.dataFormat,this.dilationRate);else{if(3!==this.rank)throw new Qt("convolutions greater than 3D are not implemented yet.");r=function M4(n,t,e,r=[1,1,1],s="valid",i,o){return Ce(()=>{if(null==i&&(i="channelsLast"),Or(i),4!==n.rank&&5!==n.rank)throw new _e(`conv3dWithBias expects input to be of rank 4 or 5, but received ${n.rank}.`);if(4!==t.rank&&5!==t.rank)throw new _e(`conv3dWithBias expects kernel to be of rank 4 or 5, but received ${n.rank}.`);let a=O4(n,i);if("causal"===s)throw new Qt("The support for CAUSAL padding mode in conv3dWithBias is not implemented yet.");return a=oV(a,t,r,"same"===s?"same":"valid","NDHWC",o),null!=e&&(a=ea(a,e)),"channelsFirst"===i&&(a=yn(a,[0,4,1,2,3])),a})}(t,this.kernel.read(),s,this.strides,this.padding,this.dataFormat,this.dilationRate)}null!=this.activation&&(r=this.activation.apply(r))}return r})}computeOutputShape(t){t=Tn(t);const e=[],r="channelsLast"===this.dataFormat?t.slice(1,t.length-1):t.slice(2);for(let i=0;i<r.length;++i){const o=ra(r[i],this.kernelSize[i],this.padding,this.strides[i],"number"==typeof this.dilationRate?this.dilationRate:this.dilationRate[i]);e.push(o)}let s=[t[0]];return"channelsLast"===this.dataFormat?(s=s.concat(e),s.push(this.filters)):(s.push(this.filters),s=s.concat(e)),s}getConfig(){const t={filters:this.filters,kernelInitializer:hr(this.kernelInitializer),kernelRegularizer:Un(this.kernelRegularizer),kernelConstraint:Jr(this.kernelConstraint)},e=super.getConfig();return Object.assign(t,e),t}static verifyArgs(t){if(!("filters"in t)||"number"!=typeof t.filters||t.filters<1)throw new _e(`Convolution layer expected config.filters to be a 'number' > 0 but got ${JSON.stringify(t.filters)}`)}}let P4=(()=>{class n extends Lh{constructor(e){super(2,e),n.verifyArgs(e)}getConfig(){const e=super.getConfig();return delete e.rank,e}static verifyArgs(e){if("number"!=typeof e.kernelSize&&!aD(e.kernelSize,"number",1,2))throw new _e(`Conv2D expects config.kernelSize to be number or number[] with length 1 or 2, but received ${JSON.stringify(e.kernelSize)}.`)}}return n.className="Conv2D",n})();Qe(P4);let F4=(()=>{class n extends Lh{constructor(e){super(3,e),n.verifyArgs(e)}getConfig(){const e=super.getConfig();return delete e.rank,e}static verifyArgs(e){if("number"!=typeof e.kernelSize&&(!Array.isArray(e.kernelSize)||1!==e.kernelSize.length&&3!==e.kernelSize.length))throw new _e(`Conv3D expects config.kernelSize to be number or [number, number, number], but received ${JSON.stringify(e.kernelSize)}.`)}}return n.className="Conv3D",n})();Qe(F4),Qe((()=>{class n extends P4{constructor(e){if(super(e),this.inputSpec=[new Qr({ndim:4})],"same"!==this.padding&&"valid"!==this.padding)throw new _e(`Conv2DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(e){if(4!==(e=Tn(e)).length)throw new _e("Input should have rank 4; Received input shape: "+JSON.stringify(e));const r="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[r])throw new _e("The channel dimension of the inputs should be defined. Found `None`.");const s=e[r],i=this.kernelSize.concat([this.filters,s]);this.kernel=this.addWeight("kernel",i,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new Qr({ndim:4,axes:{[r]:s}})],this.built=!0}call(e,r){return Ce(()=>{let s=Lt(e);if(4!==s.shape.length)throw new _e(`Conv2DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${s.shape.length}`);const i=s.shape;let a,u;"channelsFirst"===this.dataFormat?(a=2,u=3):(a=1,u=2);const p=i[u],y=this.kernelSize[1],w=this.strides[1],O=[i[0],Va(i[a],this.strides[0],this.kernelSize[0],this.padding),Va(p,w,y,this.padding),this.filters];"channelsLast"!==this.dataFormat&&(s=yn(s,[0,2,3,1]));let M=KI(s,this.kernel.read(),O,this.strides,this.padding);return"channelsLast"!==this.dataFormat&&(M=yn(M,[0,3,1,2])),null!=this.bias&&(M=ea(M,this.bias.read(),this.dataFormat)),null!=this.activation&&(M=this.activation.apply(M)),M})}computeOutputShape(e){const r=(e=Tn(e)).slice();let s,i,o;"channelsFirst"===this.dataFormat?(s=1,i=2,o=3):(s=3,i=1,o=2);const a=this.kernelSize[0],u=this.kernelSize[1],c=this.strides[0],p=this.strides[1];return r[s]=this.filters,r[i]=Va(r[i],c,a,this.padding),r[o]=Va(r[o],p,u,this.padding),r}getConfig(){const e=super.getConfig();return delete e.dilationRate,e}}return n.className="Conv2DTranspose",n})()),Qe((()=>{class n extends F4{constructor(e){if(super(e),this.inputSpec=[new Qr({ndim:5})],"same"!==this.padding&&"valid"!==this.padding)throw new _e(`Conv3DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(e){if(5!==(e=Tn(e)).length)throw new _e("Input should have rank 5; Received input shape: "+JSON.stringify(e));const r="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[r])throw new _e("The channel dimension of the inputs should be defined. Found `None`.");const s=e[r],i=this.kernelSize.concat([this.filters,s]);this.kernel=this.addWeight("kernel",i,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new Qr({ndim:5,axes:{[r]:s}})],this.built=!0}call(e,r){return Ce(()=>{let s=Lt(e);if(5!==s.shape.length)throw new _e(`Conv3DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${s.shape.length}`);const i=s.shape;let a,u,c;"channelsFirst"===this.dataFormat?(c=2,a=3,u=4):(c=1,a=2,u=3);const m=i[a],y=i[u],w=this.kernelSize[1],T=this.kernelSize[2],O=this.strides[1],M=this.strides[2],Q=[i[0],Va(i[c],this.strides[0],this.kernelSize[0],this.padding),Va(m,O,w,this.padding),Va(y,M,T,this.padding),this.filters];"channelsLast"!==this.dataFormat&&(s=yn(s,[0,2,3,4,1]));let ne=lV(s,this.kernel.read(),Q,this.strides,this.padding);return"channelsLast"!==this.dataFormat&&(ne=yn(ne,[0,4,1,2,3])),null!==this.bias&&(ne=ea(ne,this.bias.read(),this.dataFormat)),null!==this.activation&&(ne=this.activation.apply(ne)),ne})}computeOutputShape(e){const r=(e=Tn(e)).slice();let s,i,o,a;"channelsFirst"===this.dataFormat?(s=1,i=2,o=3,a=4):(s=4,i=1,o=2,a=3);const u=this.kernelSize[0],c=this.kernelSize[1],p=this.kernelSize[2],m=this.strides[0],y=this.strides[1],_=this.strides[2];return r[s]=this.filters,r[i]=Va(r[i],m,u,this.padding),r[o]=Va(r[o],y,c,this.padding),r[a]=Va(r[a],_,p,this.padding),r}getConfig(){const e=super.getConfig();return delete e.dilationRate,e}}return n.className="Conv3DTranspose",n})());let yfe=(()=>{class n extends Lh{constructor(e,r){if(super(e,r),this.DEFAULT_DEPTHWISE_INITIALIZER="glorotUniform",this.DEFAULT_POINTWISE_INITIALIZER="glorotUniform",this.depthwiseKernel=null,this.pointwiseKernel=null,null==r.filters)throw new _e("The `filters` configuration field is required by SeparableConv, but is unspecified.");if(null!=r.kernelInitializer||null!=r.kernelRegularizer||null!=r.kernelConstraint)throw new _e("Fields kernelInitializer, kernelRegularizer and kernelConstraint are invalid for SeparableConv2D. Use depthwiseInitializer, depthwiseRegularizer, depthwiseConstraint, pointwiseInitializer, pointwiseRegularizer and pointwiseConstraint instead.");if(null!=r.padding&&"same"!==r.padding&&"valid"!==r.padding)throw new _e(`SeparableConv${this.rank}D supports only padding modes: 'same' and 'valid', but received ${JSON.stringify(r.padding)}`);this.depthMultiplier=null==r.depthMultiplier?1:r.depthMultiplier,this.depthwiseInitializer=rr(r.depthwiseInitializer||this.DEFAULT_DEPTHWISE_INITIALIZER),this.depthwiseRegularizer=sr(r.depthwiseRegularizer),this.depthwiseConstraint=es(r.depthwiseConstraint),this.pointwiseInitializer=rr(r.depthwiseInitializer||this.DEFAULT_POINTWISE_INITIALIZER),this.pointwiseRegularizer=sr(r.pointwiseRegularizer),this.pointwiseConstraint=es(r.pointwiseConstraint)}build(e){if((e=Tn(e)).length<this.rank+2)throw new _e(`Inputs to SeparableConv${this.rank}D should have rank ${this.rank+2}, but received input shape: ${JSON.stringify(e)}`);const r="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[r]||e[r]<0)throw new _e(`The channel dimension of the inputs should be defined, but found ${JSON.stringify(e[r])}`);const s=e[r],i=this.kernelSize.concat([s,this.depthMultiplier]),o=[];for(let u=0;u<this.rank;++u)o.push(1);o.push(s*this.depthMultiplier,this.filters);const a=!0;this.depthwiseKernel=this.addWeight("depthwise_kernel",i,"float32",this.depthwiseInitializer,this.depthwiseRegularizer,a,this.depthwiseConstraint),this.pointwiseKernel=this.addWeight("pointwise_kernel",o,"float32",this.pointwiseInitializer,this.pointwiseRegularizer,a,this.pointwiseConstraint),this.bias=this.useBias?this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,a,this.biasConstraint):null,this.inputSpec=[new Qr({ndim:this.rank+2,axes:{[r]:s}})],this.built=!0}call(e,r){return Ce(()=>{let s;if(e=Lt(e),1===this.rank)throw new Qt("1D separable convolution is not implemented yet.");return 2===this.rank&&("channelsFirst"===this.dataFormat&&(e=yn(e,[0,2,3,1])),s=hE(e,this.depthwiseKernel.read(),this.pointwiseKernel.read(),this.strides,this.padding,this.dilationRate,"NHWC")),this.useBias&&(s=ea(s,this.bias.read(),this.dataFormat)),null!=this.activation&&(s=this.activation.apply(s)),"channelsFirst"===this.dataFormat&&(s=yn(s,[0,3,1,2])),s})}getConfig(){const e=super.getConfig();return delete e.rank,delete e.kernelInitializer,delete e.kernelRegularizer,delete e.kernelConstraint,e.depthwiseInitializer=hr(this.depthwiseInitializer),e.pointwiseInitializer=hr(this.pointwiseInitializer),e.depthwiseRegularizer=Un(this.depthwiseRegularizer),e.pointwiseRegularizer=Un(this.pointwiseRegularizer),e.depthwiseConstraint=Jr(this.depthwiseConstraint),e.pointwiseConstraint=Jr(this.pointwiseConstraint),e}}return n.className="SeparableConv",n})();function $4(n,t,e,r){if(Array.isArray(n)){if(null!=t||null!=e)throw new _e("When inputs is an array, neither initialState or constants should be provided");null!=r&&(e=n.slice(n.length-r,n.length),n=n.slice(0,n.length-r)),n.length>1&&(t=n.slice(1,n.length)),n=n[0]}function s(i){return null==i||Array.isArray(i)?i:[i]}return{inputs:n,initialState:t=s(t),constants:e=s(e)}}function L4(n,t,e,r=!1,s,i,o=!1,a=!1){return Ce(()=>{const u=t.shape.length;if(u<3)throw new _e(`Input should be at least 3D, but is ${u}D.`);const c=[1,0].concat(Qo(2,u));if(t=yn(t,c),null!=i)throw new Qt("The rnn() functoin of the deeplearn.js backend does not support constants yet.");o&&console.warn("Backend rnn(): the unroll = true option is not applicable to the imperative deeplearn.js backend."),null!=s&&((s=pt(pt(s,"bool"),"float32")).rank===u-1&&(s=ii(s,-1)),s=yn(s,c)),r&&(t=To(t,0),null!=s&&(s=To(s,0)));const p=[];let m,y=e;const _=t.shape[0],w=So(t);let T,I;null!=s&&(T=So(s));for(let O=0;O<_;++O){const M=w[O],V=Ce(()=>n(M,y));if(null==s)m=V[0],y=V[1];else{const z=Ce(()=>{const G=T[O],Q=vt(Hi(G),G);return{output:Ze(me(V[0],G),me(y[0],Q)),newStates:y.map((de,pe)=>Ze(me(V[1][pe],G),me(de,Q)))}});m=z.output,y=z.newStates}a&&p.push(m)}return a&&(I=qi(p,1)),[m,I,y]})}Qe((()=>{class n extends yfe{constructor(e){super(2,e)}}return n.className="SeparableConv2D",n})()),Qe((()=>{class n extends Lh{constructor(e){super(1,e),n.verifyArgs(e),this.inputSpec=[{ndim:3}]}getConfig(){const e=super.getConfig();return delete e.rank,delete e.dataFormat,e}static verifyArgs(e){if("number"!=typeof e.kernelSize&&!aD(e.kernelSize,"number",1,1))throw new _e(`Conv1D expects config.kernelSize to be number or number[] with length 1, but received ${JSON.stringify(e.kernelSize)}.`)}}return n.className="Conv1D",n})()),Qe((()=>{class n extends an{constructor(e){super(e),this.cropping="number"==typeof e.cropping?[[e.cropping,e.cropping],[e.cropping,e.cropping]]:"number"==typeof e.cropping[0]?[[e.cropping[0],e.cropping[0]],[e.cropping[1],e.cropping[1]]]:e.cropping,this.dataFormat=void 0===e.dataFormat?"channelsLast":e.dataFormat,this.inputSpec=[{ndim:4}]}computeOutputShape(e){return"channelsFirst"===this.dataFormat?[e[0],e[1],e[2]-this.cropping[0][0]-this.cropping[0][1],e[3]-this.cropping[1][0]-this.cropping[1][1]]:[e[0],e[1]-this.cropping[0][0]-this.cropping[0][1],e[2]-this.cropping[1][0]-this.cropping[1][1],e[3]]}call(e,r){return Ce(()=>{if(e=Lt(e),"channelsLast"===this.dataFormat){const s=t0(e,this.cropping[0][0],e.shape[1]-this.cropping[0][0]-this.cropping[0][1],2);return t0(s,this.cropping[1][0],e.shape[2]-this.cropping[1][1]-this.cropping[1][0],3)}{const s=t0(e,this.cropping[0][0],e.shape[2]-this.cropping[0][0]-this.cropping[0][1],3);return t0(s,this.cropping[1][0],e.shape[3]-this.cropping[1][1]-this.cropping[1][0],4)}})}getConfig(){const e={cropping:this.cropping,dataFormat:this.dataFormat},r=super.getConfig();return Object.assign(e,r),e}}return n.className="Cropping2D",n})()),Qe((()=>{class n extends an{constructor(e){super(e),this.DEFAULT_SIZE=[2,2],this.inputSpec=[{ndim:4}],this.size=null==e.size?this.DEFAULT_SIZE:e.size,this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,Or(this.dataFormat),this.interpolation=null==e.interpolation?"nearest":e.interpolation,function Yhe(n){kc(Hhe,"InterpolationFormat",n)}(this.interpolation)}computeOutputShape(e){return"channelsFirst"===this.dataFormat?[e[0],e[1],null==e[2]?null:this.size[0]*e[2],null==e[3]?null:this.size[1]*e[3]]:[e[0],null==e[1]?null:this.size[0]*e[1],null==e[2]?null:this.size[1]*e[2],e[3]]}call(e,r){return Ce(()=>{let s=Lt(e);const i=s.shape;if("channelsFirst"===this.dataFormat){s=yn(s,[0,2,3,1]);const o=this.size[0]*i[2],a=this.size[1]*i[3],u="nearest"===this.interpolation?Oa.resizeNearestNeighbor(s,[o,a]):Oa.resizeBilinear(s,[o,a]);return yn(u,[0,3,1,2])}{const o=this.size[0]*i[1],a=this.size[1]*i[2];return"nearest"===this.interpolation?Oa.resizeNearestNeighbor(s,[o,a]):Oa.resizeBilinear(s,[o,a])}})}getConfig(){const e={size:this.size,dataFormat:this.dataFormat,interpolation:this.interpolation},r=super.getConfig();return Object.assign(e,r),e}}return n.className="UpSampling2D",n})()),Qe((()=>{class n extends b0{constructor(e){super(2,e),this.depthwiseKernel=null,this.depthMultiplier=null==e.depthMultiplier?1:e.depthMultiplier,this.depthwiseInitializer=rr(e.depthwiseInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.depthwiseConstraint=es(e.depthwiseConstraint),this.depthwiseRegularizer=sr(e.depthwiseRegularizer)}build(e){if((e=Tn(e)).length<4)throw new _e(`Inputs to DepthwiseConv2D should have rank 4. Received input shape: ${JSON.stringify(e)}.`);const r="channelsFirst"===this.dataFormat?1:3;if(null==e[r]||e[r]<0)throw new _e(`The channel dimension of the inputs to DepthwiseConv2D should be defined, but is not (${e[r]}).`);const s=e[r];this.depthwiseKernel=this.addWeight("depthwise_kernel",[this.kernelSize[0],this.kernelSize[1],s,this.depthMultiplier],null,this.depthwiseInitializer,this.depthwiseRegularizer,!0,this.depthwiseConstraint),this.bias=this.useBias?this.addWeight("bias",[s*this.depthMultiplier],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):null,this.built=!0}call(e,r){return Ce(()=>{let s=function bfe(n,t,e=[1,1],r="valid",s,i){return Ce(()=>{null==s&&(s="channelsLast"),Or(s);let o=$D(n,s);if(4!==n.rank)throw new _e(`Input for depthwiseConv2d is required to be 4-D, but is instead ${n.rank}-D`);if(4!==t.rank)throw new _e(`depthwiseKernel is required to be 4-D, but is instead ${t.rank}-D`);return o=qm(o,t,e,"same"===r?"same":"valid","NHWC",i),"channelsFirst"===s&&(o=yn(o,[0,3,1,2])),o})}(e=Lt(e),this.depthwiseKernel.read(),this.strides,this.padding,this.dataFormat,null);return this.useBias&&(s=ea(s,this.bias.read(),this.dataFormat)),null!=this.activation&&(s=this.activation.apply(s)),s})}computeOutputShape(e){e=Tn(e);const s="channelsFirst"===this.dataFormat?e[3]:e[2],i="channelsFirst"===this.dataFormat?e[1]*this.depthMultiplier:e[3]*this.depthMultiplier,o=ra("channelsFirst"===this.dataFormat?e[2]:e[1],this.kernelSize[0],this.padding,this.strides[0]),a=ra(s,this.kernelSize[1],this.padding,this.strides[1]);return"channelsFirst"===this.dataFormat?[e[0],i,o,a]:[e[0],o,a,i]}getConfig(){const e=super.getConfig();return e.depthMultiplier=this.depthMultiplier,e.depthwiseInitializer=hr(this.depthwiseInitializer),e.depthwiseRegularizer=Un(this.depthwiseRegularizer),e.depthwiseConstraint=Jr(this.depthwiseRegularizer),e}}return n.className="DepthwiseConv2D",n})());let mg=(()=>{class n extends an{constructor(e){let r;if(super(e),null==e.cell)throw new _e("cell property is missing for the constructor of RNN.");if(r=Array.isArray(e.cell)?new z4({cells:e.cell}):e.cell,null==r.stateSize)throw new _e("The RNN cell should have an attribute `stateSize` (tuple of integers, one integer per RNN state).");this.cell=r,this.returnSequences=null!=e.returnSequences&&e.returnSequences,this.returnState=null!=e.returnState&&e.returnState,this.goBackwards=null!=e.goBackwards&&e.goBackwards,this._stateful=null!=e.stateful&&e.stateful,this.unroll=null!=e.unroll&&e.unroll,this.supportsMasking=!0,this.inputSpec=[new Qr({ndim:3})],this.stateSpec=null,this.states_=null,this.numConstants=null,this.keptStates=[]}getStates(){return null==this.states_?Qo(0,Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1).map(r=>null):this.states_}setStates(e){this.states_=e}computeOutputShape(e){hD(e)&&(e=e[0]);let r=this.cell.stateSize;Array.isArray(r)||(r=[r]);const s=r[0];let i;if(i=this.returnSequences?[e[0],e[1],s]:[e[0],s],this.returnState){const o=[];for(const a of r)o.push([e[0],a]);return[i].concat(o)}return i}computeMask(e,r){return Ce(()=>{Array.isArray(r)&&(r=r[0]);const s=this.returnSequences?r:null;if(this.returnState){const i=this.states.map(o=>null);return[s].concat(i)}return s})}get states(){if(null==this.states_){const e=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1,r=[];for(let s=0;s<e;++s)r.push(null);return r}return this.states_}set states(e){this.states_=e}build(e){if(null!=this.numConstants)throw new Qt("Constants support is not implemented in RNN yet.");hD(e)&&(e=e[0]);const s=this.stateful?e[0]:null,i=e.slice(2);this.inputSpec[0]=new Qr({shape:[s,null,...i]});const o=[e[0]].concat(e.slice(2));let a;if(this.cell.build(o),a=Array.isArray(this.cell.stateSize)?this.cell.stateSize:[this.cell.stateSize],null!=this.stateSpec){if(!hn(this.stateSpec.map(u=>u.shape[u.shape.length-1]),a))throw new _e(`An initialState was passed that is not compatible with cell.stateSize. Received stateSpec=${this.stateSpec}; However cell.stateSize is ${this.cell.stateSize}`)}else this.stateSpec=a.map(u=>new Qr({shape:[null,u]}));this.stateful&&this.resetStates()}resetStates(e,r=!1){Ce(()=>{if(!this.stateful)throw new Ma("Cannot call resetStates() on an RNN Layer that is not stateful.");const s=this.inputSpec[0].shape[0];if(null==s)throw new _e("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(null==this.states_)this.states_=Array.isArray(this.cell.stateSize)?this.cell.stateSize.map(i=>Yr([s,i])):[Yr([s,this.cell.stateSize])];else if(null==e)on(this.states_),null!=this.keptStates&&(on(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(i=>Yr([s,i])):this.states_[0]=Yr([s,this.cell.stateSize]);else{if(Array.isArray(e)||(e=[e]),e.length!==this.states_.length)throw new _e(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${e.length} state value(s). Input received: ${e}`);!0===r?this.keptStates.push(this.states_.slice()):on(this.states_);for(let i=0;i<this.states_.length;++i){const o=e[i],a=Array.isArray(this.cell.stateSize)?this.cell.stateSize[i]:this.cell.stateSize,u=[s,a];if(!hn(o.shape,u))throw new _e(`State ${i} is incompatible with layer ${this.name}: expected shape=${u}, received shape=${o.shape}`);this.states_[i]=o}}this.states_=this.states_.map(i=>as(i.clone()))})}apply(e,r){let s=null==r?null:r.initialState,i=null==r?null:r.constants;null==r&&(r={});const o=$4(e,s,i,this.numConstants);e=o.inputs,s=o.initialState,i=o.constants;let a=[],u=[];if(null!=s){r.initialState=s,a=a.concat(s),this.stateSpec=[];for(const p of s)this.stateSpec.push(new Qr({shape:p.shape}));u=u.concat(this.stateSpec)}if(null!=i&&(r.constants=i,a=a.concat(i),this.numConstants=i.length),a[0]instanceof La){const p=[e].concat(a),m=this.inputSpec.concat(u),y=this.inputSpec;this.inputSpec=m;const _=super.apply(p,r);return this.inputSpec=y,_}return super.apply(e,r)}call(e,r){return Ce(()=>{const s=null==r?null:r.mask,i=null==r?null:r.training;let o=null==r?null:r.initialState;e=Lt(e),null==o&&(o=this.stateful?this.states_:this.getInitialState(e));const a=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;if(o.length!==a)throw new _e(`RNN Layer has ${a} state(s) but was passed ${o.length} initial state(s).`);this.unroll&&console.warn("Ignoring unroll = true for RNN layer, due to imperative backend.");const u={training:i},p=L4((T,I)=>{const O=this.cell.call([T].concat(I),u);return[O[0],O.slice(1)]},e,o,this.goBackwards,s,null,this.unroll,this.returnSequences),m=p[0],y=p[1],_=p[2];this.stateful&&this.resetStates(_,i);const w=this.returnSequences?y:m;return this.returnState?[w].concat(_):w})}getInitialState(e){return Ce(()=>{let r=Yr(e.shape);return r=Tt(r,[1,2]),r=lg(r),Array.isArray(this.cell.stateSize)?this.cell.stateSize.map(s=>s>1?cD(r,[1,s]):r):this.cell.stateSize>1?[cD(r,[1,this.cell.stateSize])]:[r]})}get trainableWeights(){return this.trainable?this.cell.trainableWeights:[]}get nonTrainableWeights(){return this.trainable?this.cell.nonTrainableWeights:this.cell.weights}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),null!=this.cell&&this.cell.setFastWeightInitDuringBuild(e)}getConfig(){const e=super.getConfig(),r={returnSequences:this.returnSequences,returnState:this.returnState,goBackwards:this.goBackwards,stateful:this.stateful,unroll:this.unroll};null!=this.numConstants&&(r.numConstants=this.numConstants);const s=this.cell.getConfig();return this.getClassName()===n.className&&(r.cell={className:this.cell.getClassName(),config:s}),Object.assign(Object.assign(Object.assign({},s),e),r)}static fromConfig(e,r,s={}){const o=_l(r.cell,s);return new e(Object.assign(r,{cell:o}))}}return n.className="RNN",n})();Qe(mg);class _0 extends an{}let V4=(()=>{class n extends _0{constructor(e){super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=e.units,cs(this.units,"units"),this.activation=xu(null==e.activation?this.DEFAULT_ACTIVATION:e.activation),this.useBias=null==e.useBias||e.useBias,this.kernelInitializer=rr(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=rr(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=rr(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=sr(e.kernelRegularizer),this.recurrentRegularizer=sr(e.recurrentRegularizer),this.biasRegularizer=sr(e.biasRegularizer),this.kernelConstraint=es(e.kernelConstraint),this.recurrentConstraint=es(e.recurrentConstraint),this.biasConstraint=es(e.biasConstraint),this.dropout=Mh([1,bu([0,null==e.dropout?0:e.dropout])]),this.recurrentDropout=Mh([1,bu([0,null==e.recurrentDropout?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){e=Tn(e),this.kernel=this.addWeight("kernel",[e[e.length-1],this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.bias=this.useBias?this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):null,this.built=!0}call(e,r){return Ce(()=>{if(2!==e.length)throw new _e(`SimpleRNNCell expects 2 input Tensors, got ${e.length}.`);let s=e[1];e=e[0];const i=null!=r.training&&r.training;let o;0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=Tu({ones:()=>Hi(e),rate:this.dropout,training:i,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=Tu({ones:()=>Hi(s),rate:this.recurrentDropout,training:i,dropoutFunc:this.dropoutFunc}));const a=this.dropoutMask,u=this.recurrentDropoutMask;o=Fa(null!=a?me(e,a):e,this.kernel.read()),null!=this.bias&&(o=ea(o,this.bias.read())),null!=u&&(s=me(s,u));let c=Ze(o,Fa(s,this.recurrentKernel.read()));return null!=this.activation&&(c=this.activation.apply(c)),[c,c]})}getConfig(){const e=super.getConfig(),r={units:this.units,activation:wu(this.activation),useBias:this.useBias,kernelInitializer:hr(this.kernelInitializer),recurrentInitializer:hr(this.recurrentInitializer),biasInitializer:hr(this.biasInitializer),kernelRegularizer:Un(this.kernelRegularizer),recurrentRegularizer:Un(this.recurrentRegularizer),biasRegularizer:Un(this.biasRegularizer),activityRegularizer:Un(this.activityRegularizer),kernelConstraint:Jr(this.kernelConstraint),recurrentConstraint:Jr(this.recurrentConstraint),biasConstraint:Jr(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout};return Object.assign(Object.assign({},e),r)}}return n.className="SimpleRNNCell",n})();Qe(V4),Qe((()=>{class n extends mg{constructor(e){e.cell=new V4(e),super(e)}call(e,r){return Ce(()=>(null!=this.cell.dropoutMask&&(on(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(on(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),super.call(e,{mask:null==r?null:r.mask,training:null==r?null:r.training,initialState:null==r?null:r.initialState})))}static fromConfig(e,r){return new e(r)}}return n.className="SimpleRNN",n})());let B4=(()=>{class n extends _0{constructor(e){if(super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",e.resetAfter)throw new _e("GRUCell does not support reset_after parameter set to true.");this.units=e.units,cs(this.units,"units"),this.activation=xu(void 0===e.activation?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=xu(void 0===e.recurrentActivation?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=null==e.useBias||e.useBias,this.kernelInitializer=rr(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=rr(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=rr(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=sr(e.kernelRegularizer),this.recurrentRegularizer=sr(e.recurrentRegularizer),this.biasRegularizer=sr(e.biasRegularizer),this.kernelConstraint=es(e.kernelConstraint),this.recurrentConstraint=es(e.recurrentConstraint),this.biasConstraint=es(e.biasConstraint),this.dropout=Mh([1,bu([0,null==e.dropout?0:e.dropout])]),this.recurrentDropout=Mh([1,bu([0,null==e.recurrentDropout?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.implementation=e.implementation,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){e=Tn(e),this.kernel=this.addWeight("kernel",[e[e.length-1],3*this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,3*this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.bias=this.useBias?this.addWeight("bias",[3*this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):null,this.built=!0}call(e,r){return Ce(()=>{if(2!==e.length)throw new _e(`GRUCell expects 2 input Tensors (inputs, h, c), got ${e.length}.`);const s=null!=r.training&&r.training;let i=e[1];e=e[0],0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=Tu({ones:()=>Hi(e),rate:this.dropout,training:s,count:3,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=Tu({ones:()=>Hi(i),rate:this.recurrentDropout,training:s,count:3,dropoutFunc:this.dropoutFunc}));const a=this.recurrentDropoutMask;let u,c,p;0<this.dropout&&this.dropout<1&&(e=me(e,this.dropoutMask[0]));let m=Fa(e,this.kernel.read());this.useBias&&(m=ea(m,this.bias.read())),0<this.recurrentDropout&&this.recurrentDropout<1&&(i=me(i,a[0]));const y=this.recurrentKernel.read(),[_,w]=Ii(y,[2*this.units,this.units],y.rank-1),T=Fa(i,_),[I,O,M]=Ii(m,3,m.rank-1),[V,z]=Ii(T,2,T.rank-1);u=this.recurrentActivation.apply(Ze(I,V)),c=this.recurrentActivation.apply(Ze(O,z));const G=Fa(me(c,i),w);p=this.activation.apply(Ze(M,G));const Q=Ze(me(u,i),me(Ze(1,Zn(u)),p));return[Q,Q]})}getConfig(){const e=super.getConfig(),r={units:this.units,activation:wu(this.activation),recurrentActivation:wu(this.recurrentActivation),useBias:this.useBias,kernelInitializer:hr(this.kernelInitializer),recurrentInitializer:hr(this.recurrentInitializer),biasInitializer:hr(this.biasInitializer),kernelRegularizer:Un(this.kernelRegularizer),recurrentRegularizer:Un(this.recurrentRegularizer),biasRegularizer:Un(this.biasRegularizer),activityRegularizer:Un(this.activityRegularizer),kernelConstraint:Jr(this.kernelConstraint),recurrentConstraint:Jr(this.recurrentConstraint),biasConstraint:Jr(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation,resetAfter:!1};return Object.assign(Object.assign({},e),r)}}return n.className="GRUCell",n})();Qe(B4),Qe((()=>{class n extends mg{constructor(e){0===e.implementation&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new B4(e),super(e)}call(e,r){return Ce(()=>(null!=this.cell.dropoutMask&&(on(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(on(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),super.call(e,{mask:null==r?null:r.mask,training:null==r?null:r.training,initialState:null==r?null:r.initialState})))}static fromConfig(e,r){return 0===r.implmentation&&(r.implementation=1),new e(r)}}return n.className="GRU",n})());let VD=(()=>{class n extends _0{constructor(e){super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=e.units,cs(this.units,"units"),this.activation=xu(void 0===e.activation?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=xu(void 0===e.recurrentActivation?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=null==e.useBias||e.useBias,this.kernelInitializer=rr(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=rr(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=rr(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.unitForgetBias=e.unitForgetBias,this.kernelRegularizer=sr(e.kernelRegularizer),this.recurrentRegularizer=sr(e.recurrentRegularizer),this.biasRegularizer=sr(e.biasRegularizer),this.kernelConstraint=es(e.kernelConstraint),this.recurrentConstraint=es(e.recurrentConstraint),this.biasConstraint=es(e.biasConstraint),this.dropout=Mh([1,bu([0,null==e.dropout?0:e.dropout])]),this.recurrentDropout=Mh([1,bu([0,null==e.recurrentDropout?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.implementation=e.implementation,this.stateSize=[this.units,this.units],this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){var r;let i;if(e=Tn(e),this.kernel=this.addWeight("kernel",[e[e.length-1],4*this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,4*this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){if(this.unitForgetBias){const o=this.biasInitializer,a=this.units;i=new((r=class extends Eo{apply(c,p){const m=o.apply([a]),y=(new HB).apply([a]),_=o.apply([2*a]);return jB(jB(m,y),_)}}).className="CustomInit",r)}else i=this.biasInitializer;this.bias=this.addWeight("bias",[4*this.units],null,i,this.biasRegularizer,!0,this.biasConstraint)}else this.bias=null;this.built=!0}call(e,r){return Ce(()=>{const s=null!=r.training&&r.training;if(3!==e.length)throw new _e(`LSTMCell expects 3 input Tensors (inputs, h, c), got ${e.length}.`);let i=e[1];const o=e[2];e=e[0],0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=Tu({ones:()=>Hi(e),rate:this.dropout,training:s,count:4,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=Tu({ones:()=>Hi(i),rate:this.recurrentDropout,training:s,count:4,dropoutFunc:this.dropoutFunc}));const u=this.recurrentDropoutMask;let c,p,m,y;0<this.dropout&&this.dropout<1&&(e=me(e,this.dropoutMask[0]));let _=Fa(e,this.kernel.read());0<this.recurrentDropout&&this.recurrentDropout<1&&(i=me(i,u[0])),_=Ze(_,Fa(i,this.recurrentKernel.read())),this.useBias&&(_=ea(_,this.bias.read()));const[w,T,I,O]=Ii(_,4,_.rank-1);c=this.recurrentActivation.apply(w),p=this.recurrentActivation.apply(T),m=Ze(me(p,o),me(c,this.activation.apply(I))),y=this.recurrentActivation.apply(O);const M=me(y,this.activation.apply(m));return[M,M,m]})}getConfig(){const e=super.getConfig(),r={units:this.units,activation:wu(this.activation),recurrentActivation:wu(this.recurrentActivation),useBias:this.useBias,kernelInitializer:hr(this.kernelInitializer),recurrentInitializer:hr(this.recurrentInitializer),biasInitializer:hr(this.biasInitializer),unitForgetBias:this.unitForgetBias,kernelRegularizer:Un(this.kernelRegularizer),recurrentRegularizer:Un(this.recurrentRegularizer),biasRegularizer:Un(this.biasRegularizer),activityRegularizer:Un(this.activityRegularizer),kernelConstraint:Jr(this.kernelConstraint),recurrentConstraint:Jr(this.recurrentConstraint),biasConstraint:Jr(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation};return Object.assign(Object.assign({},e),r)}}return n.className="LSTMCell",n})();Qe(VD),Qe((()=>{class n extends mg{constructor(e){0===e.implementation&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new VD(e),super(e)}call(e,r){return Ce(()=>(null!=this.cell.dropoutMask&&(on(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(on(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),super.call(e,{mask:null==r?null:r.mask,training:null==r?null:r.training,initialState:null==r?null:r.initialState})))}static fromConfig(e,r){return 0===r.implmentation&&(r.implementation=1),new e(r)}}return n.className="LSTM",n})());let z4=(()=>{class n extends _0{constructor(e){super(e),this.cells=e.cells}get stateSize(){const e=[];for(const r of this.cells.slice().reverse())Array.isArray(r.stateSize)?e.push(...r.stateSize):e.push(r.stateSize);return e}call(e,r){return Ce(()=>{let s=e.slice(1);const i=[];for(const u of this.cells.slice().reverse())Array.isArray(u.stateSize)?i.push(s.splice(0,u.stateSize.length)):i.push(s.splice(0,1));i.reverse();const o=[];let a;for(let u=0;u<this.cells.length;++u){const c=this.cells[u];s=i[u],a=0===u?[e[0]].concat(s):[a[0]].concat(s),a=c.call(a,r),o.push(a.slice(1))}s=[];for(const u of o.slice().reverse())s.push(...u);return[a[0]].concat(s)})}build(e){let r;hD(e)&&(e=e[0]),this.cells.forEach((s,i)=>{Nc(`RNNCell_${i}`,()=>{s.build(e),r=Array.isArray(s.stateSize)?s.stateSize[0]:s.stateSize,e=[e[0],r]})}),this.built=!0}getConfig(){const e=super.getConfig(),i={cells:this.cells.map(o=>({className:o.getClassName(),config:o.getConfig()}))};return Object.assign(Object.assign({},e),i)}static fromConfig(e,r,s={}){const i=[];for(const o of r.cells)i.push(_l(o,s));return new e({cells:i})}get trainableWeights(){if(!this.trainable)return[];const e=[];for(const r of this.cells)e.push(...r.trainableWeights);return e}get nonTrainableWeights(){const e=[];for(const r of this.cells)e.push(...r.nonTrainableWeights);if(!this.trainable){const r=[];for(const s of this.cells)r.push(...s.trainableWeights);return r.concat(e)}return e}getWeights(){const e=[];for(const r of this.cells)e.push(...r.weights);return pD(e)}setWeights(e){const r=[];for(const s of this.cells){const o=e.splice(s.weights.length);for(let a=0;a<s.weights.length;++a)r.push([s.weights[a],o[a]])}fD(r)}}return n.className="StackedRNNCells",n})();function Tu(n){const{ones:t,rate:e,training:r=!1,count:s=1,dropoutFunc:i}=n,o=()=>null!=i?i(t(),e):WB(t(),e),a=()=>cg(o,t,r);return!s||s<=1?as(a().clone()):Array(s).fill(void 0).map(a).map(c=>as(c.clone()))}Qe(z4);let vfe=(()=>{class n extends mg{constructor(e){if(e.unroll)throw new Qt("Unrolling is not possible with convolutional RNNs.");if(Array.isArray(e.cell))throw new Qt("It is not possible at the moment to stack convolutional cells.");super(e),this.inputSpec=[new Qr({ndim:5})]}call(e,r){return Ce(()=>{if(null!=this.cell.dropoutMask&&(on(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(on(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),r&&r.constants)throw new _e("ConvRNN2D cell does not support constants");return super.call(e,{mask:null==r?null:r.mask,training:null==r?null:r.training,initialState:null==r?null:r.initialState})})}computeOutputShape(e){let r=this.computeSingleOutputShape(e);return this.returnSequences||(r=[r[0],...r.slice(2)]),this.returnState&&(r=[r,...Array(2).fill([e[0],...r.slice(-3)])]),r}getInitialState(e){return Ce(()=>{const{stateSize:r}=this.cell,i=this.computeSingleOutputShape(e.shape),a=Yr([i[0],...i.slice(2)]);return Array.isArray(r)?Array(r.length).fill(a):[a]})}resetStates(e,r=!1){Ce(()=>{if(!this.stateful)throw new Ma("Cannot call resetStates() on an RNN Layer that is not stateful.");const s=this.inputSpec[0].shape,i=this.computeSingleOutputShape(s),o=[i[0],...i.slice(2)];if(null==s[0])throw new _e("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(null==this.getStates())this.states_=Array.isArray(this.cell.stateSize)?this.cell.stateSize.map(()=>Yr(o)):[Yr(o)];else if(null==e)on(this.states_),null!=this.keptStates&&(on(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(()=>Yr(o)):this.states_[0]=Yr(o);else{if(Array.isArray(e)||(e=[e]),e.length!==this.states_.length)throw new _e(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${e.length} state value(s). Input received: ${e}`);r?this.keptStates.push(this.states_.slice()):on(this.states_);for(let u=0;u<this.states_.length;++u){const c=e[u],p=o;if(!hn(c.shape,p))throw new _e(`State ${u} is incompatible with layer ${this.name}: expected shape=${p}, received shape=${c.shape}`);this.states_[u]=c}}this.states_=this.states_.map(u=>as(u.clone()))})}computeSingleOutputShape(e){const{dataFormat:r,filters:s,kernelSize:i,padding:o,strides:a,dilationRate:u}=this.cell,c="channelsFirst"===r,m=e[c?4:3],y=ra(e[c?3:2],i[0],o,a[0],u[0]),_=ra(m,i[1],o,a[1],u[1]);return[...e.slice(0,2),...c?[s,y,_]:[y,_,s]]}}return n.className="ConvRNN2D",n})(),U4=(()=>{class n extends VD{constructor(e){const{filters:r,kernelSize:s,strides:i,padding:o,dataFormat:a,dilationRate:u}=e;super(Object.assign(Object.assign({},e),{units:r})),this.filters=r,cs(this.filters,"filters"),this.kernelSize=$h(s,2,"kernelSize"),this.kernelSize.forEach(c=>cs(c,"kernelSize")),this.strides=$h(i||1,2,"strides"),this.strides.forEach(c=>cs(c,"strides")),this.padding=o||"valid",Xi(this.padding),this.dataFormat=a||"channelsLast",Or(this.dataFormat),this.dilationRate=$h(u||1,2,"dilationRate"),this.dilationRate.forEach(c=>cs(c,"dilationRate"))}build(e){var r;e=Tn(e);const s="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[s])throw new _e(`The channel dimension of the input should be defined. Found ${e[s]}`);const a=this.kernelSize.concat([e[s],4*this.filters]);this.kernel=this.addWeight("kernel",a,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint);const u=this.kernelSize.concat([this.filters,4*this.filters]);if(this.recurrentKernel=this.addWeight("recurrent_kernel",u,null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){let c;if(this.unitForgetBias){const p=this.biasInitializer,m=this.filters;c=new((r=class extends Eo{apply(_,w){return uD([p.apply([m]),Wi([m]),p.apply([2*m])])}}).className="CustomInit",r)}else c=this.biasInitializer;this.bias=this.addWeight("bias",[4*this.filters],null,c,this.biasRegularizer,!0,this.biasConstraint)}this.built=!0}call(e,r){return Ce(()=>{if(3!==e.length)throw new _e(`ConvLSTM2DCell expects 3 input Tensors (inputs, h, c), got ${e.length}.`);const s=r.training||!1,i=e[0],o=e[1],a=e[2];0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=Tu({ones:()=>Hi(i),rate:this.dropout,training:s,count:4,dropoutFunc:this.dropoutFunc}));const c=this.dropoutMask,p=(Ke,et,Je)=>et&&et[Je]?me(et[Je],Ke):Ke;let m=p(i,c,0),y=p(i,c,1),_=p(i,c,2),w=p(i,c,3);0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=Tu({ones:()=>Hi(o),rate:this.recurrentDropout,training:s,count:4,dropoutFunc:this.dropoutFunc}));const T=this.recurrentDropoutMask;let I=p(o,T,0),O=p(o,T,1),M=p(o,T,2),V=p(o,T,3);const[G,Q,ne,oe]=Ii(this.kernel.read(),4,3),[de,pe,Te,Ae]=this.useBias?Ii(this.bias.read(),4):[null,null,null,null];m=this.inputConv(m,G,de,this.padding),y=this.inputConv(y,Q,pe,this.padding),_=this.inputConv(_,ne,Te,this.padding),w=this.inputConv(w,oe,Ae,this.padding);const[Oe,Me,Pe,ve]=Ii(this.recurrentKernel.read(),4,3);I=this.recurrentConv(I,Oe),O=this.recurrentConv(O,Me),M=this.recurrentConv(M,Pe),V=this.recurrentConv(V,ve);const Se=this.recurrentActivation.apply(Ze(m,I)),xe=this.recurrentActivation.apply(Ze(y,O)),ke=Ze(me(xe,a),me(Se,this.activation.apply(Ze(_,M)))),We=me(this.recurrentActivation.apply(Ze(w,V)),this.activation.apply(ke));return[We,We,ke]})}getConfig(){const s=function(n,t){var e={};for(var r in n)Object.prototype.hasOwnProperty.call(n,r)&&t.indexOf(r)<0&&(e[r]=n[r]);if(null!=n&&"function"==typeof Object.getOwnPropertySymbols){var s=0;for(r=Object.getOwnPropertySymbols(n);s<r.length;s++)t.indexOf(r[s])<0&&Object.prototype.propertyIsEnumerable.call(n,r[s])&&(e[r[s]]=n[r[s]])}return e}(super.getConfig(),["units"]),i={filters:this.filters,kernelSize:this.kernelSize,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,strides:this.strides};return Object.assign(Object.assign({},s),i)}inputConv(e,r,s,i){const o=hu(e,r,this.strides,i||"valid","channelsFirst"===this.dataFormat?"NCHW":"NHWC",this.dilationRate);return s?ea(o,s,this.dataFormat):o}recurrentConv(e,r){return hu(e,r,1,"same","channelsFirst"===this.dataFormat?"NCHW":"NHWC")}}return n.className="ConvLSTM2DCell",n})();Qe(U4),Qe((()=>{class n extends vfe{constructor(e){const r=new U4(e);super(Object.assign(Object.assign({},e),{cell:r}))}static fromConfig(e,r){return new e(r)}}return n.className="ConvLSTM2D",n})());let j4=(()=>{class n extends an{constructor(e){super(e),this.rate=Math.max(Math.min(e.rate,1),0),this.noiseShape=e.noiseShape,this.seed=e.seed,this.supportsMasking=!0}getNoiseShape(e){if(null==this.noiseShape)return this.noiseShape;const r=e.shape,s=[];for(let i=0;i<this.noiseShape.length;++i)s.push(null==this.noiseShape[i]?r[i]:this.noiseShape[i]);return s}call(e,r){return Ce(()=>{this.invokeCallHook(e,r);const s=Lt(e);if(0<this.rate&&this.rate<1){const i=null!=r.training&&r.training,o=this.getNoiseShape(s);return cg(()=>WB(s,this.rate,o,this.seed),()=>s,i)}return e})}getConfig(){const e={rate:this.rate,noiseShape:this.noiseShape,seed:this.seed},r=super.getConfig();return Object.assign(e,r),e}dispose(){return super.dispose()}}return n.className="Dropout",n})();Qe(j4),Qe((()=>{class n extends j4{constructor(e){super(e),this.inputSpec=[{ndim:3}]}getNoiseShape(e){const r=e.shape;return[r[0],1,r[2]]}}return n.className="SpatialDropout1D",n})()),Qe((()=>{class n extends an{constructor(e){if(super(e),this.activation=null,this.useBias=!0,this.kernel=null,this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",null==e.batchInputShape&&null==e.inputShape&&null!=e.inputDim){let r=null;null!=e.batchSize&&(r=e.batchSize),this.batchInputShape=[r,e.inputDim]}this.units=e.units,cs(this.units,"units"),this.activation=xu(e.activation),null!=e.useBias&&(this.useBias=e.useBias),this.kernelInitializer=rr(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.biasInitializer=rr(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelConstraint=es(e.kernelConstraint),this.biasConstraint=es(e.biasConstraint),this.kernelRegularizer=sr(e.kernelRegularizer),this.biasRegularizer=sr(e.biasRegularizer),this.activityRegularizer=sr(e.activityRegularizer),this.supportsMasking=!0,this.inputSpec=[{minNDim:2}]}build(e){const r=(e=Tn(e))[e.length-1];null==this.kernel&&(this.kernel=this.addWeight("kernel",[r,this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint))),this.inputSpec=[{minNDim:2,axes:{[-1]:r}}],this.built=!0}computeOutputShape(e){const r=(e=Tn(e)).slice();return r[r.length-1]=this.units,r}call(e,r){return Ce(()=>{this.invokeCallHook(e,r);const s=Lt(e),i=PB(this.activation.getClassName());let o;return null!=i?o=Fa(s,this.kernel.read(),i,this.bias?this.bias.read():null):(o=Fa(s,this.kernel.read()),null!=this.bias&&(o=ea(o,this.bias.read())),null!=this.activation&&(o=this.activation.apply(o))),o})}getConfig(){const e={units:this.units,activation:wu(this.activation),useBias:this.useBias,kernelInitializer:hr(this.kernelInitializer),biasInitializer:hr(this.biasInitializer),kernelRegularizer:Un(this.kernelRegularizer),biasRegularizer:Un(this.biasRegularizer),activityRegularizer:Un(this.activityRegularizer),kernelConstraint:Jr(this.kernelConstraint),biasConstraint:Jr(this.biasConstraint)},r=super.getConfig();return Object.assign(e,r),e}}return n.className="Dense",n})()),Qe((()=>{class n extends an{constructor(e){super(e=e||{}),this.inputSpec=[{minNDim:3}],this.dataFormat=e.dataFormat}computeOutputShape(e){e=Tn(e);for(const r of e.slice(1))if(null==r)throw new _e(`The shape of the input to "Flatten" is not fully defined (got ${e.slice(1)}). Make sure to pass a complete "input_shape" or "batch_input_shape" argument to the first layer in your model.`);return[e[0],yu(e,1)]}call(e,r){return Ce(()=>{this.invokeCallHook(e,r);let s=Lt(e);if("channelsFirst"===this.dataFormat&&s.rank>1){const i=[0];for(let o=2;o<s.rank;++o)i.push(o);i.push(1),s=yn(s,i)}return function spe(n){if(n.rank<=1)throw new _e(`batchFlatten requires a minimum rank of 2. Got rank: ${n.rank}.`);const t=[n.shape[0],yu(n.shape,1)];return be(n,t)}(s)})}getConfig(){const e={};null!=this.dataFormat&&(e.dataFormat=this.dataFormat);const r=super.getConfig();return Object.assign(e,r),e}}return n.className="Flatten",n})()),Qe((()=>{class n extends an{constructor(e){super(e),this.supportsMasking=!0,this.activation=xu(e.activation)}call(e,r){return Ce(()=>{this.invokeCallHook(e,r);const s=Lt(e);return this.activation.apply(s)})}getConfig(){const e={activation:wu(this.activation)},r=super.getConfig();return Object.assign(e,r),e}}return n.className="Activation",n})()),Qe((()=>{class n extends an{constructor(e){super(e),this.n=e.n,this.inputSpec=[{ndim:2}]}computeOutputShape(e){return[e[0],this.n,e[1]]}call(e,r){return Ce(()=>function npe(n,t){return Ce(()=>{if(2!==n.shape.length)throw new _e(`repeat() expects a rank-2 tensor, but received a rank-${n.shape.length} tensor.`);return cD(lg(n,1),[1,t,1])})}(e=Lt(e),this.n))}getConfig(){const e={n:this.n},r=super.getConfig();return Object.assign(e,r),e}}return n.className="RepeatVector",n})()),Qe((()=>{class n extends an{constructor(e){super(e),this.targetShape=e.targetShape;for(let r=0;r<this.targetShape.length;++r)this.isUnknown(this.targetShape[r])&&(this.targetShape[r]=null)}isUnknown(e){return e<0||null==e}fixUnknownDimension(e,r){const s="Total size of new array must be unchanged.",i=r.slice();let o=1,a=null;for(let c=0;c<i.length;++c){const p=i[c];if(this.isUnknown(p)){if(null!==a)throw new _e("Can only specifiy one unknown dimension.");a=c}else o*=p}const u=yu(e);if(null!==a){if(0===o||u%o!=0)throw new _e(s);i[a]=u/o}else if(u!==o)throw new _e(s);return i}computeOutputShape(e){let r=!1;for(let s=0;s<e.length;++s)if(this.isUnknown(e[s])){r=!0;break}return r?e.slice(0,1).concat(this.targetShape):e.slice(0,1).concat(this.fixUnknownDimension(e.slice(1),this.targetShape))}call(e,r){return Ce(()=>{this.invokeCallHook(e,r);const s=Lt(e),i=s.shape,o=i.slice(0,1).concat(this.fixUnknownDimension(i.slice(1),this.targetShape));return be(s,o)})}getConfig(){const e={targetShape:this.targetShape},r=super.getConfig();return Object.assign(e,r),e}}return n.className="Reshape",n})()),Qe((()=>{class n extends an{constructor(e){if(super(e),null==e.dims)throw new Error("Required configuration field `dims` is missing during Permute constructor call.");if(!Array.isArray(e.dims))throw new Error(`Permute constructor requires \`dims\` to be an Array, but received ${e.dims} instead.`);const r=Qo(1,e.dims.length+1);if(!hn(e.dims.slice().sort(),r))throw new Error("Invalid permutation `dims`: "+JSON.stringify(e.dims)+" `dims` must contain consecutive integers starting from 1.");this.dims=e.dims,this.dimsIncludingBatch=[0].concat(this.dims),this.inputSpec=[new Qr({ndim:this.dims.length+1})]}computeOutputShape(e){const r=(e=Tn(e)).slice();return this.dims.forEach((s,i)=>{r[i+1]=e[s]}),r}call(e,r){return yn(Lt(e),this.dimsIncludingBatch)}getConfig(){const e={dims:this.dims},r=super.getConfig();return Object.assign(e,r),e}}return n.className="Permute",n})()),Qe((()=>{class n extends an{constructor(e){super(e??{}),this.supportsMasking=!0,this.maskValue=null!=e?null==e.maskValue?0:e.maskValue:0}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),r={maskValue:this.maskValue};return Object.assign(r,e),r}computeMask(e,r){const s=Lt(e);return Sv(Eh(s,this.maskValue),-1)}call(e,r){return Ce(()=>{this.invokeCallHook(e,r);const s=Lt(e),a=Sv(Eh(s,this.maskValue),-1,!0);return me(s,pt(a,s.dtype))})}}return n.className="Masking",n})()),Qe((()=>{class n extends an{constructor(e){if(super(e),this.embeddings=null,this.DEFAULT_EMBEDDINGS_INITIALIZER="randomUniform",null==e.batchInputShape&&null==e.inputShape){let r=null;null!=e.batchSize&&(r=e.batchSize),this.batchInputShape=null==e.inputLength?[r,null]:[r].concat(Wn(e.inputLength))}this.inputDim=e.inputDim,cs(this.inputDim,"inputDim"),this.outputDim=e.outputDim,cs(this.outputDim,"outputDim"),this.embeddingsInitializer=rr(e.embeddingsInitializer||this.DEFAULT_EMBEDDINGS_INITIALIZER),this.embeddingsRegularizer=sr(e.embeddingsRegularizer),this.activityRegularizer=sr(e.activityRegularizer),this.embeddingsConstraint=es(e.embeddingsConstraint),this.maskZero=e.maskZero,this.supportsMasking=e.maskZero,this.inputLength=e.inputLength}build(e){this.embeddings=this.addWeight("embeddings",[this.inputDim,this.outputDim],this.dtype,this.embeddingsInitializer,this.embeddingsRegularizer,!0,this.embeddingsConstraint),this.built=!0}warnOnIncompatibleInputShape(e){}computeMask(e,r){return Ce(()=>this.maskZero?(e=Lt(e),Eh(e,mn(e))):null)}computeOutputShape(e){if(e=Tn(e),null==this.inputLength)return[...e,this.outputDim];const r=Wn(this.inputLength);if(r.length!==e.length-1)throw new _e(`"inputLength" is ${this.inputLength}, but received input shape has shape ${e}`);{let s=0;for(let i=0;i<r.length;++i){const o=r[i],a=e[i+1];if(null!=o&&null!=a&&o!==a)throw new _e(`"inputLength" is ${this.inputLength}, but received input shape has shape ${e}`);null==o&&(r[s]=a),s++}}return[e[0],...r,this.outputDim]}call(e,r){return Ce(()=>{this.invokeCallHook(e,r);let s=Lt(e);"int32"!==s.dtype&&(s=Pa(s,"int32"));const i=GB(this.embeddings.read(),be(s,[s.size]));return be(i,Tn(this.computeOutputShape(s.shape)))})}getConfig(){const e={inputDim:this.inputDim,outputDim:this.outputDim,embeddingsInitializer:hr(this.embeddingsInitializer),embeddingsRegularizer:Un(this.embeddingsRegularizer),activityRegularizer:Un(this.activityRegularizer),embeddingsConstraint:Jr(this.embeddingsConstraint),maskZero:this.maskZero,inputLength:this.inputLength},r=super.getConfig();return Object.assign(e,r),e}}return n.className="Embedding",n})());class Rc extends an{constructor(t){super(t||{}),this.supportsMasking=!0}mergeFunction(t){throw new Qt}computeElementwiseOpOutputShape(t,e){if(null==t||null==e)return null;if(t.length<e.length)return this.computeElementwiseOpOutputShape(e,t);if(0===e.length)return t;const r=t.slice(0,t.length-e.length);for(let s=0;s<e.length;++s){const i=t[t.length-e.length+s],o=e[s];if(null==i||null==o||i<0||o<0)r.push(null);else if(1===i)r.push(o);else if(1===o)r.push(i);else{if(i!==o)throw new _e("Operands could not be broadcast together with shapes "+JSON.stringify(t)+" "+JSON.stringify(e));r.push(i)}}return r}build(t){if(Array.isArray(t)&&!Array.isArray(t[0])&&(t=[Tn(t)]),t.length<2)throw new _e(`A merge layer should be called on an Array of at least 2 inputs. Got ${t.length} input(s).`);let e=[];for(const i of t)null!=i&&null!==i[0]&&e.push(i[0]);if(e=gu(e),e.length>1)throw new _e(`Can not merge tensors with different batch sizes. Got tensors with shapes: ${JSON.stringify(t)}.`);let r=null==t[0]?null:t[0].slice(1);for(let i=1;i<t.length;++i){const o=null==t[i]?null:t[i].slice(1);r=this.computeElementwiseOpOutputShape(r,o)}const s=t.map(i=>i.length);this.reshapeRequired=-1!==t.indexOf(null)||1!==gu(s).length}call(t,e){return Ce(()=>{if(this.reshapeRequired){const r=[],s=t.map(i=>i.rank);if(-1===s.indexOf(null)){const i=bu(s);for(let o of t){const a=o.rank;for(let u=0;u<i-a;++u)o=lg(o,1);r.push(o)}return this.mergeFunction(r)}{let i=!1;for(const u of t){const c=u.rank;if(null==c){const p=u.shape,m=p[0],y=p.slice(1).concat([m]);let _=be(u,[m].concat(yu(p.slice(1))));_=yn(_,[1,0]),_=be(_,y),r.push(_),i=!0}else if(c>1){const p=Qo(1,c).concat([0]);r.push(yn(u,p)),i=!0}else r.push(u)}let o=this.mergeFunction(r);const a=o.rank;if(i)if(null==a){const u=o.shape,p=u[u.length-1],m=[p].concat(u.slice(0,u.length-1));o=be(yn(be(o,[-1,p]),[1,0]),m)}else if(a>1){const u=[a-1].concat(Qo(0,a-1));o=yn(o,u)}return o}}return this.mergeFunction(t)})}computeOutputShape(t){let e;e=null==t[0]?null:t[0].slice(1);for(let s=1;s<t.length;++s){const i=null==t[s]?null:t[s].slice(1);e=this.computeElementwiseOpOutputShape(e,i)}let r=[];for(const s of t)null!=s&&null!==s[0]&&r.push(s[0]);return r=gu(r),e=1===r.length?r.concat(e):[null].concat(e),e}computeMask(t,e){return Ce(()=>{if(null==e)return null;if(!Array.isArray(e))throw new _e("`mask` should be an Array");if(!Array.isArray(t))throw new _e("`inputs` should be an Array");if(e.length!==t.length)throw new _e(`The Array 'inputs' and 'mask' are expected to have the same length, but have different lengths (${t.length} vs ${e.length})`);if(e.every(s=>null==s))return null;let r=(e=e.map(s=>null==s?s:ii(s,0)))[0];for(let s=1;s<e.length-1;++s)r=ka(r,e[s]);return r})}}function gg(n,t){for(;n<0;)n+=t;return n}function yg(n,t,e,r,s,i=.001){let o;if(2===n.rank)o=Z3(n,t,e,r,s,i);else if(3===n.rank)o=Q3(n,t,e,r,s,i);else{if(4!==n.rank)throw new Qt(`batchNormalization is not implemented for array of rank ${n.rank} yet`);o=J3(n,t,e,r,s,i)}return o}function v0(n,t,e,r,s,i){return Ce(()=>{let o;Or(s),$B(i),Xi(r),null==e&&(e=[1,1]),null==r&&(r="valid"),null==s&&(s="channelsLast"),null==i&&(i="max"),n=$D(n,s);const a="same"===r?"same":"valid";return o="max"===i?Mv(n,t,e,a):Cv(n,t,e,a),"channelsFirst"===s&&(o=yn(o,[0,3,1,2])),o})}function G4(n,t,e,r,s,i){return Ce(()=>{let o;Or(s),$B(i),Xi(r),null==e&&(e=[1,1,1]),null==r&&(r="valid"),null==s&&(s="channelsLast"),null==i&&(i="max"),n=O4(n,s);const a="same"===r?"same":"valid";return o="max"===i?SV(n,t,e,a):Y3(n,t,e,a),"channelsFirst"===s&&(o=yn(o,[0,4,1,2,3])),o})}Qe((()=>{class n extends Rc{constructor(e){super(e)}mergeFunction(e){return Ce(()=>{let r=e[0].clone();for(let s=1;s<e.length;++s)r=Ze(r,e[s]);return r})}}return n.className="Add",n})()),Qe((()=>{class n extends Rc{constructor(e){super(e)}mergeFunction(e){return Ce(()=>{let r=e[0].clone();for(let s=1;s<e.length;++s)r=me(r,e[s]);return r})}}return n.className="Multiply",n})()),Qe((()=>{class n extends Rc{constructor(e){super(e)}mergeFunction(e){return Ce(()=>{let r=e[0].clone();for(let s=1;s<e.length;++s)r=Ze(r,e[s]);return me(1/e.length,r)})}}return n.className="Average",n})()),Qe((()=>{class n extends Rc{constructor(e){super(e)}mergeFunction(e){return Ce(()=>{let r=e[0];for(let s=1;s<e.length;++s)r=hl(r,e[s]);return r})}}return n.className="Maximum",n})()),Qe((()=>{class n extends Rc{constructor(e){super(e)}mergeFunction(e){return Ce(()=>{let r=e[0];for(let s=1;s<e.length;++s)r=Sc(r,e[s]);return r})}}return n.className="Minimum",n})()),Qe((()=>{class n extends Rc{constructor(e){super(e),this.DEFAULT_AXIS=-1,null==e&&(e={}),this.axis=null==e.axis?this.DEFAULT_AXIS:e.axis,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){if(!Array.isArray(e)||!Array.isArray(e[0])||1===e.length)throw new _e("A `Concatenate` layer should be called on a list of at least 2 inputs");let r=!0;for(const i of e)if(null!=i){r=!1;break}if(r)return;const s=[];for(let i=0;i<e.length;++i){const o=e[i].slice();o.splice(this.axis,1);let a=!1;for(const u of s)if(hn(u,o)){a=!0;break}a||s.push(o)}if(s.length>1)throw new _e("A `Concatenate` layer requires inputs with matching shapes except for the concat axis. Got input shapes: "+JSON.stringify(e))}mergeFunction(e){return Ce(()=>uD(e,this.axis))}computeOutputShape(e){if(!Array.isArray(e)||!Array.isArray(e[0]))throw new _e("A `Concatenate` layer should be called on a list of inputs.");const r=e,s=r[0].slice(),i=this.axis<0?s.length+this.axis:this.axis;for(const o of r.slice(1)){if(null==s[i]||null==o[i]){s[i]=null;break}s[i]+=o[i]}return s}computeMask(e,r){if(null==r)return null;if(!Array.isArray(r))throw new _e("`mask` should be an array for Concatenate");if(!Array.isArray(e))throw new _e("`inputs` should be an array for Concatenate");if(r.length!==e.length)throw new _e(`Mismatch in the length of mask (${r.length}) and the legnth of inputs (${e.length})`);return Ce(()=>{let s=!0;if(r.forEach(a=>{null==a||(s=!1)}),s)return null;const i=[];for(let a=0;a<e.length;++a)i.push(null==r[a]?pt(Hi(e[a]),"bool"):r[a].rank<e[a].rank?ii(r[a],-1):r[a]);const o=Vr(i,this.axis);return jI(o,-1,!1)})}getConfig(){const e={axis:this.axis},r=super.getConfig();return Object.assign(e,r),e}}return n.className="Concatenate",n})()),Qe((()=>{class n extends Rc{constructor(e){super(e),this.axes=e.axes,this.normalize=null!=e.normalize&&e.normalize,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){J(Array.isArray(e)&&2===e.length&&Array.isArray(e[0])&&Array.isArray(e[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");const r=e[0],s=e[1];if(r.length>3||s.length>3)throw new Qt("Dot layer does not support tensors of 4D or higher rank yet.");const i=this.interpretAxes(r,s);if(r[i[0]]!==s[i[1]])throw new _e(`Dimension incompatibility: ${r[i[0]]} !== ${s[i[1]]}`)}mergeFunction(e){if(2!==e.length)throw new _e(`A \`Dot\` layer must be called on exactly 2 inputs, but received ${e.length} input(s).`);let i,r=e[0],s=e[1];return i=Array.isArray(this.axes)?this.axes.map((o,a)=>gg(o,e[a].shape.length)):[gg(this.axes,r.shape.length),gg(this.axes,s.shape.length)],this.normalize&&(r=c0(r,i[0]),s=c0(s,i[1])),function wfe(n,t,e){if(n.shape.length>3||t.shape.length>3)throw new Qt("batchDot is not implemented for tensors of 4D or higher rank yet");if(J(n.shape.length>=2,()=>`batchDot requires the rank of x to be >= 2, but got ${n.shape.length}`),J(n.shape.length>=2,()=>`batchDot requires the rank of y to be >= 2, but got ${t.shape.length}`),"number"==typeof e&&(e=[e,e]),"complex64"===n.dtype||"complex64"===t.dtype)throw new Qt("batchDot is not implemented for complex64-type Tensors yet.");const r=n.shape.length,s=t.shape.length;null==e&&(e=[r-1,s-2]);const i=e;return Ce(()=>{let o,a;if(r>s){o=r-s;const u=[];for(let c=0;c<o;++c)u.push(1);t=be(t,t.shape.concat(u))}else if(s>r){o=s-r;const u=[];for(let c=0;c<o;++c)u.push(1);n=be(n,n.shape.concat(u))}else o=0;if(a=2===n.shape.length&&2===t.shape.length?i[0]===i[1]?Tt(me(n,t),i[0]):Tt(me(yn(n,[1,0]),t),i[1]):ln(n,t,i[0]!==n.shape.length-1,i[1]===t.shape.length-1),o>0){let u;u=r>s?r+s-3:r-1;const c=[];for(let p=u;p<u+o;++p)c.push(p);a=Ic(a,c)}return 1===a.shape.length&&(a=ii(a,1)),a})}(r,s,i)}interpretAxes(e,r){let s;return s=Array.isArray(this.axes)?this.axes:[gg(this.axes,e.length),gg(this.axes,r.length)],s}computeOutputShape(e){J(Array.isArray(e)&&2===e.length&&Array.isArray(e[0])&&Array.isArray(e[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");const r=e[0].slice(),s=e[1].slice();if(r.length>3||s.length>3)throw new Qt("Dot layer does not support tensors of 4D or higher rank yet.");const i=this.interpretAxes(r,s);r.splice(i[0],1),s.splice(i[1],1),s.splice(0,1);const o=r.concat(s);return 1===o.length&&o.push(1),o}computeMask(e,r){return null}getConfig(){const e={axes:this.axes,normalize:this.normalize},r=super.getConfig();return Object.assign(e,r),e}}return n.className="Dot",n})()),Qe((()=>{class n extends an{constructor(e){super(e),this.supportsMasking=!0,this.stddev=e.stddev}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),r={stddev:this.stddev};return Object.assign(r,e),r}call(e,r){return Ce(()=>{this.invokeCallHook(e,r);const s=Lt(e);return cg(()=>Ze(n0(s.shape,0,this.stddev),s),()=>s,r.training||!1)})}}return n.className="GaussianNoise",n})()),Qe((()=>{class n extends an{constructor(e){super(e),this.supportsMasking=!0,this.rate=e.rate}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),r={rate:this.rate};return Object.assign(r,e),r}call(e,r){return Ce(()=>{this.invokeCallHook(e,r);const s=Lt(e);return this.rate>0&&this.rate<1?cg(()=>{const o=Math.sqrt(this.rate/(1-this.rate));return me(s,n0(s.shape,1,o))},()=>s,r.training||!1):s})}}return n.className="GaussianDropout",n})()),Qe((()=>{class n extends an{constructor(e){super(e),this.supportsMasking=!0,this.rate=e.rate,this.noiseShape=e.noiseShape}_getNoiseShape(e){return this.noiseShape||Lt(e).shape}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),r={rate:this.rate};return Object.assign(r,e),r}call(e,r){return Ce(()=>{if(this.rate<1&&this.rate>0){const s=this._getNoiseShape(e);return cg(()=>{const o=Lt(e),c=-1.7580993408473766;let p=fu(Cc(s),this.rate);p=Pa(p,"float32");const m=((1-this.rate)*(1+this.rate*c**2))**-.5,y=-m*c*this.rate,_=Ze(me(o,p),me(Ze(p,-1),c));return Ze(me(_,m),y)},()=>Lt(e),r.training||!1)}return e})}}return n.className="AlphaDropout",n})()),Qe((()=>{class n extends an{constructor(e){null==e&&(e={}),super(e),this.supportsMasking=!0,this.axis=null==e.axis?-1:e.axis,this.momentum=null==e.momentum?.99:e.momentum,this.epsilon=null==e.epsilon?.001:e.epsilon,this.center=null==e.center||e.center,this.scale=null==e.scale||e.scale,this.betaInitializer=rr(e.betaInitializer||"zeros"),this.gammaInitializer=rr(e.gammaInitializer||"ones"),this.movingMeanInitializer=rr(e.movingMeanInitializer||"zeros"),this.movingVarianceInitializer=rr(e.movingVarianceInitializer||"ones"),this.betaConstraint=es(e.betaConstraint),this.gammaConstraint=es(e.gammaConstraint),this.betaRegularizer=sr(e.betaRegularizer),this.gammaRegularizer=sr(e.gammaRegularizer)}build(e){e=Tn(e);const r=this.axis>=0?this.axis:this.axis+e.length,s=e[r];if(null==s)throw new _e(`Axis ${r} of input tensor should have a defined dimension but the layer received an input with shape ${JSON.stringify(e)}.`);this.inputSpec=[new Qr({ndim:e.length,axes:{[r]:s}})];const i=[s];this.scale&&(this.gamma=this.addWeight("gamma",i,null,this.gammaInitializer,this.gammaRegularizer,!0,this.gammaConstraint)),this.center&&(this.beta=this.addWeight("beta",i,null,this.betaInitializer,this.betaRegularizer,!0,this.betaConstraint)),this.movingMean=this.addWeight("moving_mean",i,null,this.movingMeanInitializer,null,!1),this.movingVariance=this.addWeight("moving_variance",i,null,this.movingVarianceInitializer,null,!1),this.built=!0}call(e,r){return Ce(()=>{const s=null!=r.training&&r.training,i=Lt(e),o=i.shape,a=o.length,u=Qo(0,a),c=this.axis>=0?this.axis:this.axis+a;u.splice(c,1);const p=Dc(1,a);p[c]=o[c];const m=u.slice();m.sort();const y=!hn(m,Qo(0,a).slice(0,a-1));if(!s)return(()=>{if(y){const V=be(this.movingMean.read(),p),z=be(this.movingVariance.read(),p),G=this.center?be(this.beta.read(),p):null,Q=this.scale?be(this.gamma.read(),p):null;return yg(i,V,z,G,Q,this.epsilon)}return yg(i,this.movingMean.read(),this.movingVariance.read(),null==this.beta?null:this.beta.read(),null==this.gamma?null:this.gamma.read(),this.epsilon)})();const[w,T,I]=function Sfe(n,t,e,r,s=.001){return hn(r.slice().sort(),Qo(0,n.rank-1))?function xfe(n,t,e,r,s=.001){return Ce(()=>{const i=Pv(n,r),o=i.mean,a=i.variance;return[yg(n,o,a,e,t,s),o,a]})}(n,t,e,r,s):function Tfe(n,t,e,r,s=.001){return Ce(()=>{const i=Pv(n,r),o=i.mean,a=i.variance,u=[];for(const w of Qo(0,n.rank))-1!==r.indexOf(w)?u.push(1):u.push(n.shape[w]);const c=be(o,u),p=be(a,u),m=null==t?null:be(t,u),y=null==e?null:be(e,u);return[yg(n,c,p,y,m,s),o,a]})}(n,t,e,r,s)}(i,this.gamma.read(),this.beta.read(),u,this.epsilon),O=(V,z,G)=>{Ce(()=>{const Q=1-G,ne=V.read(),oe=me(vt(ne,z),Q);V.write(vt(ne,oe))})};return(()=>{O(this.movingMean,T,this.momentum),O(this.movingVariance,I,this.momentum)})(),w})}getConfig(){const e={axis:this.axis,momentum:this.momentum,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:hr(this.betaInitializer),gammaInitializer:hr(this.gammaInitializer),movingMeanInitializer:hr(this.movingMeanInitializer),movingVarianceInitializer:hr(this.movingVarianceInitializer),betaRegularizer:Un(this.betaRegularizer),gammaRegularizer:Un(this.gammaRegularizer),betaConstraint:Jr(this.betaConstraint),gammaConstraint:Jr(this.gammaConstraint)},r=super.getConfig();return Object.assign(e,r),e}}return n.className="BatchNormalization",n})()),Qe((()=>{class n extends an{constructor(e){if(null==e&&(e={}),super(e),this.axis=null==e.axis?-1:e.axis,"number"==typeof this.axis){if(!Number.isInteger(this.axis))throw new Error(`Expected axis to be an integer, but received ${this.axis}`)}else{if(!Array.isArray(this.axis))throw new Error(`Expected axis to be an integer or an array of integers, but received ${JSON.stringify(this.axis)}`);for(const r of this.axis)if(!Number.isInteger(r))throw new Error(`Expected axis to be an array of integers, but received ${JSON.stringify(this.axis)}`)}this.epsilon=null==e.epsilon?.001:e.epsilon,this.center=null==e.center||e.center,this.scale=null==e.scale||e.scale,this.betaInitializer=rr(e.betaInitializer||"zeros"),this.gammaInitializer=rr(e.gammaInitializer||"ones"),this.betaRegularizer=sr(e.betaRegularizer),this.gammaRegularizer=sr(e.gammaRegularizer),this.supportsMasking=!0}build(e){const r=(e=Tn(e)).length;"number"==typeof this.axis&&(this.axis=[this.axis]);for(let o=0;o<this.axis.length;++o)this.axis[o]<0&&(this.axis[o]+=r);for(const o of this.axis)if(o<0||o>=r)throw new Error(`Invalid axis: ${o}`);if(this.axis.length!==gu(this.axis).length)throw new Error(`Found duplicate axes in: ${this.axis}`);const s=this.axis.map(o=>e[o]);this.gamma=this.scale?this.addWeight("gamma",s,"float32",this.gammaInitializer,this.gammaRegularizer,!0):null,this.beta=this.center?this.addWeight("beta",s,"float32",this.betaInitializer,this.betaRegularizer,!0):null,this.built=!0}call(e,r){const s=Lt(e),i=s.shape,o=i.length;return Ce(()=>{let{mean:u,variance:c}=Pv(s,this.axis,!0);const p=Dc(1,o);for(const I of this.axis)p[I]=i[I];const m=I=>null!=I&&I.shape.length!==o?be(I,p):I;let y=this.scale?m(this.gamma.read()):null,_=this.center?m(this.beta.read()):null;const w=[],T=[];for(let I=0;I<o;++I)-1!==this.axis.indexOf(I)?(w.push(i[I]),T.push(1)):(w.push(1),T.push(i[I]));return u=xo(u,w),c=xo(c,w),null!=y&&(y=xo(y,T)),null!=_&&(_=xo(_,T)),yg(s,u,c,_,y,this.epsilon)})}getConfig(){const e={axis:this.axis,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:hr(this.betaInitializer),gammaInitializer:hr(this.gammaInitializer),betaRegularizer:Un(this.betaRegularizer),gammaRegularizer:Un(this.gammaRegularizer)},r=super.getConfig();return Object.assign(e,r),e}}return n.className="LayerNormalization",n})()),Qe((()=>{class n extends an{constructor(e){if(null==e&&(e={}),super(e),this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,null==e.padding)this.padding=[[1,1],[1,1]];else if("number"==typeof e.padding)this.padding=[[e.padding,e.padding],[e.padding,e.padding]];else{if(e.padding=e.padding,2!==e.padding.length)throw new _e(`ZeroPadding2D expects padding to be a length-2 array, but received a length-${e.padding.length} array.`);let r,s;if("number"==typeof e.padding[0])r=[e.padding[0],e.padding[0]],s=[e.padding[1],e.padding[1]];else{if(e.padding=e.padding,2!==e.padding[0].length)throw new _e(`ZeroPadding2D expects height padding to be a length-2 array, but received a length-${e.padding[0].length} array.`);if(r=e.padding[0],2!==e.padding[1].length)throw new _e(`ZeroPadding2D expects width padding to be a length-2 array, but received a length-${e.padding[1].length} array.`);s=e.padding[1]}this.padding=[r,s]}this.inputSpec=[new Qr({ndim:4})]}computeOutputShape(e){let r,s;return e=Tn(e),"channelsFirst"===this.dataFormat?(r=null!=e[2]&&e[2]>=0?e[2]+this.padding[0][0]+this.padding[0][1]:null,s=null!=e[3]&&e[3]>=0?e[3]+this.padding[1][0]+this.padding[1][1]:null,[e[0],e[1],r,s]):(r=null!=e[1]&&e[1]>=0?e[1]+this.padding[0][0]+this.padding[0][1]:null,s=null!=e[2]&&e[2]>=0?e[2]+this.padding[1][0]+this.padding[1][1]:null,[e[0],r,s,e[3]])}call(e,r){return Ce(()=>function Cfe(n,t,e){return Ce(()=>{if(4!==n.rank)throw new _e(`temporalPadding expects input tensor to be 4-D, but received a ${n.rank}-D tensor.`);if(null==t&&(t=[[1,1],[1,1]]),2!==t.length||2!==t[0].length||2!==t[1].length)throw new _e("spatial2dPadding expects `padding` to be an Array of two Arrays, each of which is an Array of two integers.");if(null==e&&(e="channelsLast"),"channelsLast"!==e&&"channelsFirst"!==e)throw new _e(`Unknown data format: ${e}. Supported data formats are 'channelsLast' and 'channelsFirst.`);let r;return r="channelsFirst"===e?[[0,0],[0,0],t[0],t[1]]:[[0,0],t[0],t[1],[0,0]],mu(n,r)})}(Lt(e),this.padding,this.dataFormat))}getConfig(){const e={padding:this.padding,dataFormat:this.dataFormat},r=super.getConfig();return Object.assign(e,r),e}}return n.className="ZeroPadding2D",n})());class W4 extends an{constructor(t){if(null==t.poolSize&&(t.poolSize=2),super(t),"number"==typeof t.poolSize)this.poolSize=[t.poolSize];else{if(!Array.isArray(t.poolSize)||1!==t.poolSize.length||"number"!=typeof t.poolSize[0])throw new _e(`poolSize for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(t.poolSize)}`);this.poolSize=t.poolSize}if(cs(this.poolSize,"poolSize"),null==t.strides)this.strides=this.poolSize;else if("number"==typeof t.strides)this.strides=[t.strides];else{if(!Array.isArray(t.strides)||1!==t.strides.length||"number"!=typeof t.strides[0])throw new _e(`strides for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(t.strides)}`);this.strides=t.strides}cs(this.strides,"strides"),this.padding=null==t.padding?"valid":t.padding,Xi(this.padding),this.inputSpec=[new Qr({ndim:3})]}computeOutputShape(t){const e=ra((t=Tn(t))[1],this.poolSize[0],this.padding,this.strides[0]);return[t[0],e,t[2]]}call(t,e){return Ce(()=>{this.invokeCallHook(t,e),t=lg(Lt(t),2);const r=this.poolingFunction(Lt(t),[this.poolSize[0],1],[this.strides[0],1],this.padding,"channelsLast");return Ic(r,[2])})}getConfig(){const t={poolSize:this.poolSize,padding:this.padding,strides:this.strides},e=super.getConfig();return Object.assign(t,e),t}}Qe((()=>{class n extends W4{constructor(e){super(e)}poolingFunction(e,r,s,i,o){return Or(o),Xi(i),v0(e,r,s,i,o,"max")}}return n.className="MaxPooling1D",n})()),Qe((()=>{class n extends W4{constructor(e){super(e)}poolingFunction(e,r,s,i,o){return Or(o),Xi(i),v0(e,r,s,i,o,"avg")}}return n.className="AveragePooling1D",n})());class H4 extends an{constructor(t){if(null==t.poolSize&&(t.poolSize=[2,2]),super(t),this.poolSize=Array.isArray(t.poolSize)?t.poolSize:[t.poolSize,t.poolSize],null==t.strides)this.strides=this.poolSize;else if(Array.isArray(t.strides)){if(2!==t.strides.length)throw new _e(`If the strides property of a 2D pooling layer is an Array, it is expected to have a length of 2, but received length ${t.strides.length}.`);this.strides=t.strides}else this.strides=[t.strides,t.strides];cs(this.poolSize,"poolSize"),cs(this.strides,"strides"),this.padding=null==t.padding?"valid":t.padding,this.dataFormat=null==t.dataFormat?"channelsLast":t.dataFormat,Or(this.dataFormat),Xi(this.padding),this.inputSpec=[new Qr({ndim:4})]}computeOutputShape(t){t=Tn(t);let e="channelsFirst"===this.dataFormat?t[2]:t[1],r="channelsFirst"===this.dataFormat?t[3]:t[2];return e=ra(e,this.poolSize[0],this.padding,this.strides[0]),r=ra(r,this.poolSize[1],this.padding,this.strides[1]),"channelsFirst"===this.dataFormat?[t[0],t[1],e,r]:[t[0],e,r,t[3]]}call(t,e){return Ce(()=>(this.invokeCallHook(t,e),this.poolingFunction(Lt(t),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){const t={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(t,e),t}}Qe((()=>{class n extends H4{constructor(e){super(e)}poolingFunction(e,r,s,i,o){return Or(o),Xi(i),v0(e,r,s,i,o,"max")}}return n.className="MaxPooling2D",n})()),Qe((()=>{class n extends H4{constructor(e){super(e)}poolingFunction(e,r,s,i,o){return Or(o),Xi(i),v0(e,r,s,i,o,"avg")}}return n.className="AveragePooling2D",n})());class q4 extends an{constructor(t){if(null==t.poolSize&&(t.poolSize=[2,2,2]),super(t),this.poolSize=Array.isArray(t.poolSize)?t.poolSize:[t.poolSize,t.poolSize,t.poolSize],null==t.strides)this.strides=this.poolSize;else if(Array.isArray(t.strides)){if(3!==t.strides.length)throw new _e(`If the strides property of a 3D pooling layer is an Array, it is expected to have a length of 3, but received length ${t.strides.length}.`);this.strides=t.strides}else this.strides=[t.strides,t.strides,t.strides];cs(this.poolSize,"poolSize"),cs(this.strides,"strides"),this.padding=null==t.padding?"valid":t.padding,this.dataFormat=null==t.dataFormat?"channelsLast":t.dataFormat,Or(this.dataFormat),Xi(this.padding),this.inputSpec=[new Qr({ndim:5})]}computeOutputShape(t){t=Tn(t);let e="channelsFirst"===this.dataFormat?t[2]:t[1],r="channelsFirst"===this.dataFormat?t[3]:t[2],s="channelsFirst"===this.dataFormat?t[4]:t[3];return e=ra(e,this.poolSize[0],this.padding,this.strides[0]),r=ra(r,this.poolSize[1],this.padding,this.strides[1]),s=ra(s,this.poolSize[2],this.padding,this.strides[2]),"channelsFirst"===this.dataFormat?[t[0],t[1],e,r,s]:[t[0],e,r,s,t[4]]}call(t,e){return Ce(()=>(this.invokeCallHook(t,e),this.poolingFunction(Lt(t),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){const t={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(t,e),t}}Qe((()=>{class n extends q4{constructor(e){super(e)}poolingFunction(e,r,s,i,o){return Or(o),Xi(i),G4(e,r,s,i,o,"max")}}return n.className="MaxPooling3D",n})()),Qe((()=>{class n extends q4{constructor(e){super(e)}poolingFunction(e,r,s,i,o){return Or(o),Xi(i),G4(e,r,s,i,o,"avg")}}return n.className="AveragePooling3D",n})());class K4 extends an{constructor(t){super(t),this.inputSpec=[new Qr({ndim:3})]}computeOutputShape(t){return[t[0],t[2]]}call(t,e){throw new Qt}}Qe((()=>{class n extends K4{constructor(e){super(e||{})}call(e,r){return Ce(()=>{const s=Lt(e);return wr(s,1)})}}return n.className="GlobalAveragePooling1D",n})()),Qe((()=>{class n extends K4{constructor(e){super(e||{})}call(e,r){return Ce(()=>{const s=Lt(e);return wo(s,1)})}}return n.className="GlobalMaxPooling1D",n})());class X4 extends an{constructor(t){super(t),this.dataFormat=null==t.dataFormat?"channelsLast":t.dataFormat,Or(this.dataFormat),this.inputSpec=[new Qr({ndim:4})]}computeOutputShape(t){return"channelsLast"===this.dataFormat?[t[0],t[3]]:[t[0],t[1]]}call(t,e){throw new Qt}getConfig(){const t={dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(t,e),t}}Qe((()=>{class n extends X4{call(e,r){return Ce(()=>{const s=Lt(e);return wr(s,"channelsLast"===this.dataFormat?[1,2]:[2,3])})}}return n.className="GlobalAveragePooling2D",n})()),Qe((()=>{class n extends X4{call(e,r){return Ce(()=>{const s=Lt(e);return wo(s,"channelsLast"===this.dataFormat?[1,2]:[2,3])})}}return n.className="GlobalMaxPooling2D",n})());class Y4 extends an{constructor(t){super(t),this.layer=t.layer}build(t){this.built=!0}get trainable(){return null!=this.layer&&this.layer.trainable}set trainable(t){null!=this.layer&&(this.layer.trainable=t)}get trainableWeights(){return this.layer.trainableWeights}get nonTrainableWeights(){return this.layer.nonTrainableWeights}get updates(){return this.layer._updates}get losses(){return this.layer.losses}getWeights(){return this.layer.getWeights()}setWeights(t){this.layer.setWeights(t)}getConfig(){const t={layer:{className:this.layer.getClassName(),config:this.layer.getConfig()}},e=super.getConfig();return Object.assign(t,e),t}setFastWeightInitDuringBuild(t){super.setFastWeightInitDuringBuild(t),null!=this.layer&&this.layer.setFastWeightInitDuringBuild(t)}static fromConfig(t,e,r={}){const i=_l(e.layer,r);delete e.layer;const o={layer:i};return Object.assign(o,e),new t(o)}}Qe((()=>{class n extends Y4{constructor(e){super(e),this.supportsMasking=!0}build(e){if((e=Tn(e)).length<3)throw new _e(`TimeDistributed layer expects an input shape >= 3D, but received input shape ${JSON.stringify(e)}`);this.inputSpec=[{shape:e}];const r=[e[0]].concat(e.slice(2));this.layer.built||(this.layer.build(r),this.layer.built=!0),super.build(e)}computeOutputShape(e){const r=[(e=Tn(e))[0]].concat(e.slice(2)),s=this.layer.computeOutputShape(r);return[s[0],e[1]].concat(s.slice(1))}call(e,r){return Ce(()=>L4((a,u)=>[Lt(this.layer.call(a,r)),[]],e=Lt(e),[],!1,null,null,!1,!0)[1])}}return n.className="TimeDistributed",n})()),Qe((()=>{class n extends Y4{constructor(e){super(e);const r=e.layer.getConfig(),s={};s.className=e.layer.getClassName(),s.config=r,this.forwardLayer=_l(s),r.goBackwards=!0!==r.goBackwards;const i={};if(i.className=e.layer.getClassName(),i.config=r,this.backwardLayer=_l(i),this.forwardLayer.name="forward_"+this.forwardLayer.name,this.backwardLayer.name="backward_"+this.backwardLayer.name,this.mergeMode=void 0===e.mergeMode?"concat":e.mergeMode,function Ife(n){kc(Xhe,"BidirectionalMergeMode",n)}(this.mergeMode),e.weights)throw new Qt("weights support is not implemented for Bidirectional layer yet.");this._stateful=e.layer.stateful,this.returnSequences=e.layer.returnSequences,this.returnState=e.layer.returnState,this.supportsMasking=!0,this._trainable=!0,this.inputSpec=e.layer.inputSpec,this.numConstants=null}get trainable(){return this._trainable}set trainable(e){this._trainable=e,null!=this.forwardLayer&&(this.forwardLayer.trainable=e),null!=this.backwardLayer&&(this.backwardLayer.trainable=e)}getWeights(){return this.forwardLayer.getWeights().concat(this.backwardLayer.getWeights())}setWeights(e){const s=Math.floor(e.length/2);this.forwardLayer.setWeights(e.slice(0,s)),this.backwardLayer.setWeights(e.slice(s))}computeOutputShape(e){let s,i,o,r=this.forwardLayer.computeOutputShape(e);return Array.isArray(r)&&Array.isArray(r[0])||(r=[r]),this.returnState&&(o=r.slice(1)),s=r[0],"concat"===this.mergeMode?(s[s.length-1]*=2,i=[s]):i=null==this.mergeMode?[s,s.slice()]:[s],this.returnState?null==this.mergeMode?i.concat(o).concat(o.slice()):[s].concat(o).concat(o.slice()):ai(i)}apply(e,r){let s=null==r?null:r.initialState,i=null==r?null:r.constants;null==r&&(r={});const o=$4(e,s,i,this.numConstants);if(e=o.inputs,s=o.initialState,i=o.constants,Array.isArray(e)&&(s=e.slice(1),e=e[0]),(null==s||0===s.length)&&null==i)return super.apply(e,r);const a=[],u=[];if(null!=s){const p=s.length;if(p%2>0)throw new _e("When passing `initialState` to a Bidrectional RNN, the state should be an Array containing the states of the underlying RNNs.");r.initialState=s,a.push(...s);const m=s.map(y=>new Qr({shape:y.shape}));this.forwardLayer.stateSpec=m.slice(0,p/2),this.backwardLayer.stateSpec=m.slice(p/2),u.push(...m)}if(null!=i)throw new Qt("Support for constants in Bidirectional layers is not implemented yet.");const c=a[0]instanceof La;for(const p of a)if(p instanceof La!==c)throw new _e("The initial state of a Bidirectional layer cannot be specified as a mix of symbolic and non-symbolic tensors");if(c){const p=[e].concat(a),m=this.inputSpec.concat(u),y=this.inputSpec;this.inputSpec=m;const _=super.apply(p,r);return this.inputSpec=y,_}return super.apply(e,r)}call(e,r){return Ce(()=>{const s=r.initialState;let i,o,a,u;if(null==s)i=this.forwardLayer.call(e,r),o=this.backwardLayer.call(e,r);else{const c=s.slice(0,s.length/2),p=s.slice(s.length/2);i=this.forwardLayer.call(e,Object.assign(r,{initialState:c})),o=this.backwardLayer.call(e,Object.assign(r,{initialState:p}))}return this.returnState&&(Array.isArray(i)&&(a=i.slice(1).concat(o.slice(1))),i=i[0],o=o[0]),this.returnSequences&&(o=To(o,1)),"concat"===this.mergeMode?u=uD([i,o]):"sum"===this.mergeMode?u=Ze(i,o):"ave"===this.mergeMode?u=me(.5,Ze(i,o)):"mul"===this.mergeMode?u=me(i,o):null==this.mergeMode&&(u=[i,o]),this.returnState?null==this.mergeMode?u.concat(a):[u].concat(a):u})}resetStates(e){this.forwardLayer.resetStates(),this.backwardLayer.resetStates()}build(e){Nc(this.forwardLayer.name,()=>{this.forwardLayer.build(e)}),Nc(this.backwardLayer.name,()=>{this.backwardLayer.build(e)}),this.built=!0}computeMask(e,r){let s;if(Array.isArray(r)&&(r=r[0]),s=this.returnSequences?null==this.mergeMode?[r,r]:r:null==this.mergeMode?[null,null]:null,this.returnState){const o=this.forwardLayer.states.map(a=>null);return Array.isArray(s)?s.concat(o).concat(o):[s].concat(o).concat(o)}return s}get trainableWeights(){return this.forwardLayer.trainableWeights.concat(this.backwardLayer.trainableWeights)}get nonTrainableWeights(){return this.forwardLayer.nonTrainableWeights.concat(this.backwardLayer.nonTrainableWeights)}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),null!=this.forwardLayer&&this.forwardLayer.setFastWeightInitDuringBuild(e),null!=this.backwardLayer&&this.backwardLayer.setFastWeightInitDuringBuild(e)}getConfig(){const e={mergeMode:this.mergeMode},r=super.getConfig();return Object.assign(e,r),e}static fromConfig(e,r){const s=_l(r.layer);if(delete r.layer,null!=r.numConstants)throw new Qt("Deserialization of a Bidirectional layer with numConstants present is not supported yet.");const i=r;return i.layer=s,new e(i)}}return n.className="Bidirectional",n})()),Qe((()=>{class n extends an{constructor(e){super(e),this.scale=e.scale,this.offset=e.offset?e.offset:0}getConfig(){const e={scale:this.scale,offset:this.offset},r=super.getConfig();return Object.assign(e,r),e}call(e,r){return Ce(()=>("float32"!==(e=Lt(e)).dtype&&(e=Pa(e,"float32")),Ze(me(e,this.scale),this.offset)))}}return n.className="Rescaling",n})());const{resizeBilinear:Dfe,cropAndResize:Afe}=Oa;Qe((()=>{class n extends an{constructor(e){super(e),this.height=e.height,this.width=e.width}centerCrop(e,r,s,i,o,a,u,c){return Ce(()=>{let p,m=!1;const I=[r/a,s/u,(i+r)/a,(o+s)/u],O=[];3===e.rank?(m=!0,p=qi([e])):p=e;for(let Q=0;Q<p.shape[0];Q++)O.push(I);const M=Yo(O,[O.length,4]),V=Dh(0,O.length,1,"int32"),G=Afe(p,M,V,[i,o],"nearest");return Pa(m?Lt(So(G)):G,c)})}upsize(e,r,s,i){return Ce(()=>Pa(Dfe(e,[r,s]),i))}call(e,r){return Ce(()=>{const s=Lt(e),i=s.dtype,o=s.shape,a=o[o.length-3],u=o[o.length-2];let c=0;a!==this.height&&(c=Math.floor((a-this.height)/2));let p=0;return u!==this.width&&(p=Math.floor((u-this.width)/2),0===p&&(p=1)),c>=0&&p>=0?this.centerCrop(s,c,p,this.height,this.width,a,u,i):this.upsize(e,this.height,this.width,i)})}getConfig(){const e={height:this.height,width:this.width},r=super.getConfig();return Object.assign(e,r),e}computeOutputShape(e){const s=(e=Tn(e)).length-2;return e[e.length-3]=this.height,e[s]=this.width,e}}return n.className="CenterCrop",n})()),Qe((()=>{class n extends an{constructor(e){super(e),this.numTokens=e.numTokens,this.outputMode=e.outputMode?e.outputMode:"multiHot"}getConfig(){const e={numTokens:this.numTokens,outputMode:this.outputMode},r=super.getConfig();return Object.assign(e,r),e}computeOutputShape(e){return null==(e=Tn(e))?[this.numTokens]:"oneHot"===this.outputMode&&1!==e[e.length-1]?(e.push(this.numTokens),e):(e[e.length-1]=this.numTokens,e)}call(e,r){return Ce(()=>{let s;if("int32"!==(e=Lt(e)).dtype&&(e=Pa(e,"int32")),typeof r.countWeights<"u"){if("count"!==this.outputMode)throw new _e(`countWeights is not used when outputMode !== count.\n              Received countWeights=${r.countWeights}`);s=Lt(r.countWeights)}const i=wo(e),o=Xm(e),a=Ci(this.numTokens,i).bufferSync().get(0),u=fu(o,0).bufferSync().get(0);if(!a||!u)throw new _e(`Input values must be between 0 < values <= numTokens with numTokens=${this.numTokens}`);return function kfe(n,t,e,r){let s=Lt(n);if("int32"!==s.dtype&&(s=Pa(s,"int32")),"int"===t)return s;const i=s.shape;if(0===s.rank&&(s=ii(s,-1)),"oneHot"===t&&1!==s.shape[s.shape.length-1]&&(s=ii(s,-1)),s.rank>2)throw new _e(`When outputMode is not int, maximum output rank is 2 Received outputMode ${t} and input shape ${i} which would result in output rank ${s.rank}.`);const o=["multiHot","oneHot"].includes(t);let u;if(u=ZI(s,typeof r<"u"&&"count"===t?r:[],e,o),"tfIdf"!==t)return u;if(r)return me(u,r);throw new _e("When outputMode is 'tfIdf', weights must be provided.")}(e,this.outputMode,this.numTokens,s)})}}return n.className="CategoryEncoding",n})());const Z4=new Set(["bilinear","nearest"]);Qe((()=>{class n extends an{constructor(e){if(super(e),this.height=e.height,this.width=e.width,e.interpolation){if(!Z4.has(e.interpolation))throw new _e(`Invalid interpolation parameter: ${e.interpolation} is not implemented`);this.interpolation=e.interpolation}else this.interpolation="bilinear";this.cropToAspectRatio=!!e.cropToAspectRatio}computeOutputShape(e){return e=Tn(e),[this.height,this.width,e[2]]}getConfig(){const e={height:this.height,width:this.width,interpolation:this.interpolation,cropToAspectRatio:this.cropToAspectRatio},r=super.getConfig();return Object.assign(e,r),e}call(e,r){return Ce(()=>{const s=[this.height,this.width];if("bilinear"===this.interpolation)return Oa.resizeBilinear(e,s,!this.cropToAspectRatio);if("nearest"===this.interpolation)return Oa.resizeNearestNeighbor(e,s,!this.cropToAspectRatio);throw new Error(`Interpolation is ${this.interpolation} but only ${[...Z4]} are supported`)})}}return n.className="Resizing",n})());let Ofe=(()=>{class n{constructor(e){this.seed=e}next(){if(void 0!==this.seed)return this.seed++}}return n.className="RandomSeed",n})(),Rfe=(()=>{class n extends an{constructor(e){super(e),this.randomGenerator=new Ofe(e.seed)}getConfig(){const e={seed:this.randomGenerator.seed},r=super.getConfig();return Object.assign(e,r),e}}return n.className="BaseRandomLayer",n})();const Q4=new Set(["bilinear","nearest"]);Qe((()=>{class n extends Rfe{constructor(e){super(e);const{factor:r,interpolation:s="bilinear"}=e;if(this.factor=r,Array.isArray(this.factor)&&2===this.factor.length)this.widthLower=this.factor[0],this.widthUpper=this.factor[1];else{if(Array.isArray(this.factor)||!(this.factor>0))throw new _e(`Invalid factor: ${this.factor}. Must be positive number or tuple of 2 numbers`);this.widthLower=-this.factor,this.widthUpper=this.factor}if(this.widthLower<-1||this.widthUpper<-1)throw new _e(`factor must have values larger than -1. Got: ${this.factor}`);if(this.widthUpper<this.widthLower)throw new _e(`factor cannot have upper bound less than lower bound.\n        Got upper bound: ${this.widthUpper}.\n        Got lower bound: ${this.widthLower}\n      `);if(s){if(!Q4.has(s))throw new _e(`Invalid interpolation parameter: ${s} is not implemented`);this.interpolation=s}}getConfig(){const e={factor:this.factor,interpolation:this.interpolation},r=super.getConfig();return Object.assign(e,r),e}computeOutputShape(e){return e=Tn(e),[this.imgHeight,-1,e[2]]}call(e,r){return Ce(()=>{const s=Lt(e);this.imgHeight=s.shape[s.shape.length-3];const i=s.shape[s.shape.length-2];this.widthFactor=Cc([1],1+this.widthLower,1+this.widthUpper,"float32",this.randomGenerator.next());let o=this.widthFactor.dataSync()[0]*i;o=Math.round(o);const a=[this.imgHeight,o];switch(this.interpolation){case"bilinear":return Oa.resizeBilinear(e,a);case"nearest":return Oa.resizeNearestNeighbor(e,a);default:throw new Error(`Interpolation is ${this.interpolation}\n          but only ${[...Q4]} are supported`)}})}}return n.className="RandomWidth",n})()),De().registerFlag("KEEP_INTERMEDIATE_TENSORS",()=>!1,n=>{n&&console.warn("Keep intermediate tensors is ON. This will print the values of all intermediate tensors during model inference. Not all models support this mode. For details, check e2e/benchmarks/ model_config.js. This significantly impacts performance.")});var rz,Ye=(()=>((Ye=Ye||{})[Ye.DT_INVALID=0]="DT_INVALID",Ye[Ye.DT_FLOAT=1]="DT_FLOAT",Ye[Ye.DT_DOUBLE=2]="DT_DOUBLE",Ye[Ye.DT_INT32=3]="DT_INT32",Ye[Ye.DT_UINT8=4]="DT_UINT8",Ye[Ye.DT_INT16=5]="DT_INT16",Ye[Ye.DT_INT8=6]="DT_INT8",Ye[Ye.DT_STRING=7]="DT_STRING",Ye[Ye.DT_COMPLEX64=8]="DT_COMPLEX64",Ye[Ye.DT_INT64=9]="DT_INT64",Ye[Ye.DT_BOOL=10]="DT_BOOL",Ye[Ye.DT_QINT8=11]="DT_QINT8",Ye[Ye.DT_QUINT8=12]="DT_QUINT8",Ye[Ye.DT_QINT32=13]="DT_QINT32",Ye[Ye.DT_BFLOAT16=14]="DT_BFLOAT16",Ye[Ye.DT_QINT16=15]="DT_QINT16",Ye[Ye.DT_QUINT16=16]="DT_QUINT16",Ye[Ye.DT_UINT16=17]="DT_UINT16",Ye[Ye.DT_COMPLEX128=18]="DT_COMPLEX128",Ye[Ye.DT_HALF=19]="DT_HALF",Ye[Ye.DT_RESOURCE=20]="DT_RESOURCE",Ye[Ye.DT_VARIANT=21]="DT_VARIANT",Ye[Ye.DT_UINT32=22]="DT_UINT32",Ye[Ye.DT_UINT64=23]="DT_UINT64",Ye[Ye.DT_FLOAT_REF=101]="DT_FLOAT_REF",Ye[Ye.DT_DOUBLE_REF=102]="DT_DOUBLE_REF",Ye[Ye.DT_INT32_REF=103]="DT_INT32_REF",Ye[Ye.DT_UINT8_REF=104]="DT_UINT8_REF",Ye[Ye.DT_INT16_REF=105]="DT_INT16_REF",Ye[Ye.DT_INT8_REF=106]="DT_INT8_REF",Ye[Ye.DT_STRING_REF=107]="DT_STRING_REF",Ye[Ye.DT_COMPLEX64_REF=108]="DT_COMPLEX64_REF",Ye[Ye.DT_INT64_REF=109]="DT_INT64_REF",Ye[Ye.DT_BOOL_REF=110]="DT_BOOL_REF",Ye[Ye.DT_QINT8_REF=111]="DT_QINT8_REF",Ye[Ye.DT_QUINT8_REF=112]="DT_QUINT8_REF",Ye[Ye.DT_QINT32_REF=113]="DT_QINT32_REF",Ye[Ye.DT_BFLOAT16_REF=114]="DT_BFLOAT16_REF",Ye[Ye.DT_QINT16_REF=115]="DT_QINT16_REF",Ye[Ye.DT_QUINT16_REF=116]="DT_QUINT16_REF",Ye[Ye.DT_UINT16_REF=117]="DT_UINT16_REF",Ye[Ye.DT_COMPLEX128_REF=118]="DT_COMPLEX128_REF",Ye[Ye.DT_HALF_REF=119]="DT_HALF_REF",Ye[Ye.DT_RESOURCE_REF=120]="DT_RESOURCE_REF",Ye[Ye.DT_VARIANT_REF=121]="DT_VARIANT_REF",Ye[Ye.DT_UINT32_REF=122]="DT_UINT32_REF",Ye[Ye.DT_UINT64_REF=123]="DT_UINT64_REF",Ye))();!function(n){let t;var e;(e=t=n.CheckpointFormatVersion||(n.CheckpointFormatVersion={}))[e.LEGACY=0]="LEGACY",e[e.V1=1]="V1",e[e.V2=2]="V2"}(rz||(rz={}));const HD={};function sz(n){return HD[n]}function j(n,t,e,r,s){const i=t.inputParams[n];if(i&&void 0!==i.inputIndexStart){const a=i.inputIndexStart,u=0===i.inputIndexEnd?void 0:void 0===i.inputIndexEnd?a+1:i.inputIndexEnd,c=a<0?t.inputNames.length+a:a;if("tensor"===i.type)return xs(t.inputNames[c],e,r,s);if("tensors"===i.type){const y=t.inputs.slice(a,u);return t.inputNames.slice(a,u).filter((w,T)=>{var I;return"NoOp"!==(null===(I=y[T])||void 0===I?void 0:I.op)}).map(w=>xs(w,e,r,s))}const p=xs(t.inputNames[c],e,r,s),m=p.dataSync();return"number"===i.type?m[0]:yo(p.shape,m)}const o=t.attrParams[n];return o&&o.value}function xs(n,t,e,r){const[s,i]=Ei(n,e);if(null!=r){const a=r.getHashTableHandleByName(s);if(null!=a)return a}const o=e.currentContextIds.find(a=>!!t[x0(s,a)]);return void 0!==o?t[x0(s,o)][i]:void 0}function iz(n,t,e){return t[x0(n,e.currentContextId)]}function vl(n,t){const[e,r,s]=Ei(n,t);return[x0(e,t&&t.currentContextId),r,s]}function x0(n,t){return t?`${n}-${t}`:n}function Ei(n,t){if(""===n)return["",0,void 0];const e=null!=t&&null!=t.parseNodeNameCache;if(e){const i=t.parseNodeNameCache.get(n);if(null!=i)return i}const r=n.split(":");let s;if(1===r.length)s=[n,0,void 0];else{const o=3===r.length?r[1]:void 0;s=[r[0],Number(r[r.length-1]),o]}return e&&t.parseNodeNameCache.set(n,s),s}function T0(n,t,e){let r=j("pad",n,t,e);if("explicit"===r){r=j("explicitPaddings",n,t,e);const s=[[0,0],[0,0],[0,0],[0,0]];for(let i=0;i<4;i++)s[i][0]=r[2*i],s[i][1]=r[2*i+1];return s}return r}function wl(n){return n.kept?n:cl(n)}const Lfe=[{tfOpName:"Add",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddV2",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddN",category:"arithmetic",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"BiasAdd",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"Sub",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"RealDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Div",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"DivNoNan",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mul",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Maximum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Minimum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Pow",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SquaredDifference",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorMod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],Vfe=[{tfOpName:"Abs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan2",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ceil",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ClipByValue",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"clipValueMin",type:"number"},{start:2,name:"clipValueMax",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Complex",category:"basic_math",inputs:[{start:0,name:"real",type:"tensor"},{start:1,name:"imag",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ComplexAbs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Elu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Exp",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Floor",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Imag",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Neg",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Real",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Prelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"alpha",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu6",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Selu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sigmoid",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Rsqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Square",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sign",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Round",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Expm1",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log1p",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Reciprocal",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Softplus",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Erf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LeakyRelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"alpha",name:"alpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsNan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsFinite",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsInf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],Bfe=[{tfOpName:"EmptyTensorList",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"maxNumElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"LoopCond",category:"control",inputs:[{start:0,name:"pred",type:"tensor"}]},{tfOpName:"Switch",category:"control",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"pred",type:"tensor"}]},{tfOpName:"Merge",category:"control",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"Enter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"frame_name",name:"frameName",type:"string"},{tfName:"is_constant",name:"isConstant",type:"bool"}]},{tfOpName:"Exit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NextIteration",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayV3",category:"control",inputs:[{start:0,name:"size",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"dynamic_size",name:"dynamicSize",type:"bool"},{tfName:"clear_after_read",name:"clearAfterRead",type:"bool"},{tfName:"identical_element_shapes",name:"identicalElementShapes",type:"bool"},{tfName:"tensor_array_name",name:"name",type:"string"}]},{tfOpName:"TensorArrayWriteV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayReadV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayGatherV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"}]},{tfOpName:"TensorArrayScatterV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArrayConcatV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape_except0",name:"elementShapeExcept0",type:"shape",notSupported:!0}]},{tfOpName:"TensorArraySplitV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"tensor",type:"tensor"},{start:2,name:"lengths",type:"number[]"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArraySizeV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}]},{tfOpName:"TensorArrayCloseV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"}]},{tfOpName:"StatelessIf",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"If",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"StatelessWhile",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"While",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"TensorListScatter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListScatterV2",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"},{start:3,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGather",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListSetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListReserve",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListFromTensor",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListStack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"},{tfName:"num_elements",name:"numElements",type:"dtype"}]},{tfOpName:"TensorListSplit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"},{start:2,name:"lengths",type:"number[]"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcat",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcatV2",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPopBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPushBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListLength",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}]},{tfOpName:"TensorListResize",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"size",type:"number"}]}],zfe=[{tfOpName:"AvgPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[],notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPoolWithArgmax",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"include_batch_in_index",name:"includeBatchInIndex",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AvgPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Conv1D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"stride",name:"stride",type:"number"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NWC"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"dilation",name:"dilation",type:"number",defaultValue:1}]},{tfOpName:"Conv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"useCudnnOnGpu",name:"useCudnnOnGpu",type:"bool"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"_FusedConv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"use_cudnn_on_gpu",name:"useCudnnOnGpu",type:"bool",defaultValue:!0},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2}]},{tfOpName:"Conv2DBackpropInput",category:"convolution",inputs:[{start:2,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:0,name:"outputShape",type:"number[]"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]",notSupported:!0}]},{tfOpName:"DepthwiseConv2d",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"DepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"FusedDepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]}]},{tfOpName:"Conv3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"Dilation2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"rates",name:"dilations",type:"number[]"},{tfName:"padding",name:"pad",type:"string"}]}],Ufe=[{tfOpName:"Fill",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"},{start:1,name:"value",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"LinSpace",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"num",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"OneHot",category:"creation",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"depth",type:"number"},{start:2,name:"onValue",type:"number",defaultValue:1},{start:3,name:"offValue",type:"number",defaultValue:0}],attrs:[{tfName:"axis",name:"axis",type:"number",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Ones",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"OnesLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"RandomStandardNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniform",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number",defaultValue:0},{tfName:"maxval",name:"maxval",type:"number",defaultValue:1},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniformInt",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number"},{tfName:"maxval",name:"maxval",type:"number"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Range",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"step",type:"number",defaultValue:0}],attrs:[{tfName:"Tidx",name:"dtype",type:"dtype"}]},{tfOpName:"TruncatedNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"means",name:"mean",type:"number",defaultValue:0},{tfName:"stddev",name:"stdDev",type:"number",defaultValue:1},{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Zeros",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"ZerosLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Multinomial",category:"creation",inputs:[{start:0,name:"logits",type:"tensor"},{start:1,name:"numSamples",type:"number"}],attrs:[{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number"},{tfName:"T",name:"dtype",type:"dtype"},{tfName:"output_dtype",name:"output_dtype",type:"dtype"}]}],jfe=[{tfOpName:"NonMaxSuppressionV2",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV3",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV4",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"T_threshold",name:"threshold",type:"dtype",notSupported:!0},{tfName:"pad_to_max_output_size",name:"padToMaxOutputSize",type:"bool"}]},{tfOpName:"NonMaxSuppressionV5",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"},{start:5,name:"softNmsSigma",type:"number"}]},{tfOpName:"Where",category:"dynamic",inputs:[{start:0,name:"condition",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ListDiff",category:"dynamic",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],Gfe=[{tfOpName:"LowerBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"TopKV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"k",type:"number"}],attrs:[{tfName:"sorted",name:"sorted",type:"bool"}]},{tfOpName:"UpperBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"Unique",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"UniqueV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]}],Wfe=[{tfOpName:"PlaceholderWithDefault",category:"graph",inputs:[{start:0,name:"default",type:"tensor"}],attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Placeholder",category:"graph",attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Const",category:"graph"},{tfOpName:"Identity",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IdentityN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Snapshot",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Rank",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Size",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Shape",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"ShapeN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Print",category:"graph",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"data",type:"tensors"}],attrs:[{tfName:"message",name:"message",type:"string"},{tfName:"first_n",name:"firstN",type:"number",notSupported:!0},{tfName:"summarize",name:"summarize",type:"number",defaultValue:3}]},{tfOpName:"NoOp",category:"graph",inputs:[]},{tfOpName:"StopGradient",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"FakeQuantWithMinMaxVars",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"min",name:"min",type:"number"},{tfName:"max",name:"max",type:"number"}]}],Hfe=[{tfOpName:"HashTable",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"HashTableV2",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"LookupTableImport",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableImportV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFind",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFindV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableSize",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"LookupTableSizeV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"InitializeTable",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]},{tfOpName:"InitializeTableV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]}],qfe=[{tfOpName:"ResizeBilinear",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ResizeNearestNeighbor",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"CropAndResize",category:"image",inputs:[{start:0,name:"image",type:"tensor"},{start:1,name:"boxes",type:"tensor"},{start:2,name:"boxInd",type:"tensor"},{start:3,name:"cropSize",type:"number[]"}],attrs:[{tfName:"method",name:"method",type:"string"},{tfName:"extrapolation_value",name:"extrapolationValue",type:"number"}]},{tfOpName:"ImageProjectiveTransformV3",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"transforms",type:"tensor"},{start:2,name:"outputShape",type:"number[]"},{start:3,name:"fillValue",type:"number"}],attrs:[{tfName:"interpolation",name:"interpolation",type:"string"},{tfName:"fill_mode",name:"fillMode",type:"string"}]}],Kfe=[{tfOpName:"Equal",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NotEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Greater",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"GreaterEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Less",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LessEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalAnd",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalNot",category:"logical",inputs:[{start:0,name:"a",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalOr",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Select",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SelectV2",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BitwiseAnd",category:"logical",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}]}],Xfe=[{tfOpName:"_FusedMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMulV2",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Transpose",category:"matrices",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"perm",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Einsum",category:"matrices",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"equation",name:"equation",type:"string"},{tfName:"N",name:"n",type:"number",defaultValue:2},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"MatrixBandPart",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"numLower",type:"tensor"},{start:1,name:"numUpper",type:"tensor"}]}],Yfe=[{tfOpName:"EuclideanNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",defaultValue:!1}]},{tfOpName:"FusedBatchNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV2",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV3",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"LRN",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"depth_radius",name:"radius",type:"number",defaultValue:5},{tfName:"bias",name:"bias",type:"number",defaultValue:1},{tfName:"alpha",name:"alpha",type:"number",defaultValue:1},{tfName:"beta",name:"beta",type:"number",defaultValue:.5}]},{tfOpName:"Softmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"LogSoftmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]}],Zfe=[{tfOpName:"Bincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}]},{tfOpName:"DenseBincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}],attrs:[{tfName:"binary_output",name:"binaryOutput",type:"bool"}]},{tfOpName:"Max",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Mean",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Min",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Sum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"All",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Any",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"ArgMax",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"ArgMin",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"Prod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cumprod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]},{tfOpName:"Cumsum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]}],Qfe=[{tfOpName:"ConcatV2",category:"slice_join",inputs:[{start:0,end:-1,name:"tensors",type:"tensors"},{start:-1,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"Concat",category:"slice_join",inputs:[{start:1,end:0,name:"tensors",type:"tensors"},{start:0,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"GatherV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"axis",type:"number",defaultValue:0}],attrs:[{tfName:"batch_dims",name:"batchDims",type:"number",defaultValue:0}]},{tfOpName:"Gather",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",notSupported:!0}]},{tfOpName:"Reverse",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"dims",type:"bool[]"}]},{tfOpName:"ReverseV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}]},{tfOpName:"Slice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"size",type:"number[]"}]},{tfOpName:"StridedSlice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"end",type:"number[]"},{start:3,name:"strides",type:"number[]"}],attrs:[{tfName:"begin_mask",name:"beginMask",type:"number",defaultValue:0},{tfName:"end_mask",name:"endMask",type:"number",defaultValue:0},{tfName:"new_axis_mask",name:"newAxisMask",type:"number",defaultValue:0},{tfName:"ellipsis_mask",name:"ellipsisMask",type:"number",defaultValue:0},{tfName:"shrink_axis_mask",name:"shrinkAxisMask",type:"number",defaultValue:0}]},{tfOpName:"Pack",category:"slice_join",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0}]},{tfOpName:"Unpack",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0},{tfName:"num",name:"num",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Tile",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"reps",type:"number[]"}]},{tfOpName:"Split",category:"slice_join",inputs:[{start:0,name:"axis",type:"number",defaultValue:0},{start:1,name:"x",type:"tensor"}],attrs:[{tfName:"num_split",name:"numOrSizeSplits",type:"number",defaultValue:1}]},{tfOpName:"SplitV",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"numOrSizeSplits",type:"number[]"},{start:2,name:"axis",type:"number",defaultValue:0}]},{tfOpName:"ScatterNd",category:"slice_join",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"shape",type:"number[]"}]},{tfOpName:"GatherNd",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}]},{tfOpName:"SparseToDense",category:"slice_join",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!1,notSupported:!0}]},{tfOpName:"TensorScatterUpdate",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"values",type:"tensor"}]}],Jfe=[{tfOpName:"SparseFillEmptyRows",category:"sparse",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"denseShape",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}]},{tfOpName:"SparseReshape",category:"sparse",inputs:[{start:0,name:"inputIndices",type:"tensor"},{start:1,name:"inputShape",type:"tensor"},{start:2,name:"newShape",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SparseSegmentMean",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]},{tfOpName:"SparseSegmentSum",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]}],eme=[{tfOpName:"FFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"RFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]},{tfOpName:"IRFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]}],tme=[{tfOpName:"StaticRegexReplace",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"pattern",name:"pattern",type:"string"},{tfName:"rewrite",name:"rewrite",type:"string"},{tfName:"replace_global",name:"replaceGlobal",type:"bool"}]},{tfOpName:"StringNGrams",category:"string",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"dataSplits",type:"tensor"}],attrs:[{tfName:"separator",name:"separator",type:"string"},{tfName:"ngram_widths",name:"nGramWidths",type:"number[]"},{tfName:"left_pad",name:"leftPad",type:"string"},{tfName:"right_pad",name:"rightPad",type:"string"},{tfName:"pad_width",name:"padWidth",type:"number"},{tfName:"preserve_short_sequences",name:"preserveShortSequences",type:"bool"}],outputs:["ngrams","ngrams_splits"]},{tfOpName:"StringSplit",category:"string",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"delimiter",type:"tensor"}],attrs:[{tfName:"skip_empty",name:"skipEmpty",type:"bool"}],outputs:["indices","values","shape"]},{tfOpName:"StringToHashBucketFast",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"num_buckets",name:"numBuckets",type:"number"}]}],nme=[{tfOpName:"Cast",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"SrcT",name:"sdtype",type:"dtype",notSupported:!0},{tfName:"DstT",name:"dtype",type:"dtype"}]},{tfOpName:"ExpandDims",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"MirrorPad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"mode",name:"mode",type:"string"}]},{tfOpName:"Pad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"constant_value",name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"PadV2",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"},{start:2,name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"Reshape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"EnsureShape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"Squeeze",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"axis",tfDeprecatedName:"squeeze_dims",name:"axis",type:"number[]"}]},{tfOpName:"SpaceToBatchND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"paddings",type:"number[]"}]},{tfOpName:"BatchToSpaceND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"crops",type:"number[]"}]},{tfOpName:"DepthToSpace",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"block_size",name:"blockSize",type:"number"},{tfName:"data_format",name:"dataFormat",type:"string"}]},{tfOpName:"BroadcastTo",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}],attrs:[]},{tfOpName:"BroadcastArgs",category:"transformation",inputs:[{start:0,name:"s0",type:"tensor"},{start:1,name:"s1",type:"tensor"}],attrs:[]}];class oz{static get Instance(){return this._instance||(this._instance=new this)}constructor(){const e=[].concat(...[C,v,g,h,l,d,f,b,x,D,P,L,B,U,W,H,re,ue,te].map(r=>r.json));this.opMappers=e.reduce((r,s)=>(r[s.tfOpName]=s,r),{})}transformGraph(t,e={}){const s=[],i=[],o=[],a=t.node.reduce((T,I)=>(T[I.name]=this.mapNode(I),I.op.startsWith("Placeholder")?s.push(T[I.name]):"Const"===I.op?i.push(T[I.name]):(null==I.input||0===I.input.length)&&o.push(T[I.name]),T),{});let u=[];const c=[];let p={},m={};null!=e&&(p=this.mapSignatureEntries(e.inputs),m=this.mapSignatureEntries(e.outputs));const y=Object.keys(a);y.forEach(T=>{const I=a[T];I.inputNames.forEach((O,M)=>{const[V,,z]=vl(O),G=a[V];if(null!=G.outputs){const Q=G.outputs.indexOf(z);-1!==Q&&(I.inputNames[M]=`${V}:${Q}`)}I.inputs.push(G),G.children.push(I)})}),0===Object.keys(m).length?y.forEach(T=>{const I=a[T];0===I.children.length&&c.push(I)}):Object.keys(m).forEach(T=>{const[I]=vl(T),O=a[I];null!=O&&(O.signatureKey=m[T],c.push(O))}),Object.keys(p).length>0?Object.keys(p).forEach(T=>{const[I]=vl(T),O=a[I];O&&(O.signatureKey=p[T],u.push(O))}):u=s;let _={};null!=t.library&&null!=t.library.function&&(_=t.library.function.reduce((T,I)=>(T[I.signature.name]=this.mapFunction(I),T),{}));const w={nodes:a,inputs:u,outputs:c,weights:i,placeholders:s,signature:e,functions:_};return o.length>0&&(w.initNodes=o),w}mapSignatureEntries(t){return Object.keys(t||{}).reduce((e,r)=>(e[t[r].name]=r,e),{})}mapNode(t){const e=sz(t.op)||this.opMappers[t.op]||{};null==t.attr&&(t.attr={});const r={name:t.name,op:t.op,category:e.category,inputNames:(t.input||[]).map(s=>s.startsWith("^")?s.slice(1):s),inputs:[],children:[],inputParams:{},attrParams:{},rawAttrs:t.attr,outputs:e.outputs};return null!=e.inputs&&(r.inputParams=e.inputs.reduce((s,i)=>(s[i.name]={type:i.type,inputIndexStart:i.start,inputIndexEnd:i.end},s),{})),null!=e.attrs&&(r.attrParams=e.attrs.reduce((s,i)=>{const o=i.type;let a;switch(i.type){case"string":a=qD(t.attr,i.tfName,i.defaultValue),void 0===a&&i.tfDeprecatedName&&(a=qD(t.attr,i.tfDeprecatedName,i.defaultValue));break;case"string[]":a=tA(t.attr,i.tfName,i.defaultValue),void 0===a&&i.tfDeprecatedName&&(a=tA(t.attr,i.tfDeprecatedName,i.defaultValue));break;case"number":a=XD(t.attr,i.tfName,i.defaultValue||0),void 0===a&&i.tfDeprecatedName&&(a=XD(t.attr,i.tfDeprecatedName,i.defaultValue));break;case"number[]":a=eA(t.attr,i.tfName,i.defaultValue),void 0===a&&i.tfDeprecatedName&&(a=eA(t.attr,i.tfDeprecatedName,i.defaultValue));break;case"bool":a=KD(t.attr,i.tfName,i.defaultValue),void 0===a&&i.tfDeprecatedName&&(a=KD(t.attr,i.tfDeprecatedName,i.defaultValue));break;case"bool[]":a=rA(t.attr,i.tfName,i.defaultValue),void 0===a&&i.tfDeprecatedName&&(a=rA(t.attr,i.tfDeprecatedName,i.defaultValue));break;case"shape":a=JD(t.attr,i.tfName,i.defaultValue),void 0===a&&i.tfDeprecatedName&&(a=JD(t.attr,i.tfDeprecatedName,i.defaultValue));break;case"shape[]":a=nA(t.attr,i.tfName,i.defaultValue),void 0===a&&i.tfDeprecatedName&&(a=nA(t.attr,i.tfDeprecatedName,i.defaultValue));break;case"dtype":a=ZD(t.attr,i.tfName,i.defaultValue),void 0===a&&i.tfDeprecatedName&&(a=ZD(t.attr,i.tfDeprecatedName,i.defaultValue));break;case"dtype[]":a=QD(t.attr,i.tfName,i.defaultValue),void 0===a&&i.tfDeprecatedName&&(a=QD(t.attr,i.tfDeprecatedName,i.defaultValue));break;case"func":a=lz(t.attr,i.tfName,i.defaultValue),void 0===a&&i.tfDeprecatedName&&(a=lz(t.attr,i.tfDeprecatedName,i.defaultValue));break;case"tensor":case"tensors":break;default:throw new Error(`Unsupported param type: ${i.type} for op: ${t.op}`)}return s[i.name]={value:a,type:o},s},{})),r}mapFunction(t){const e=t.nodeDef,s=[];let i={};null!=e&&(i=e.reduce((m,y)=>(m[y.name]=this.mapNode(y),"Const"===y.op&&s.push(m[y.name]),m),{}));const o=[],a=[];t.signature.inputArg.forEach(m=>{const[y]=vl(m.name),_={name:y,op:"Placeholder",inputs:[],inputNames:[],category:"graph",inputParams:{},attrParams:{dtype:{value:YD(m.type),type:"dtype"}},children:[]};_.signatureKey=m.name,o.push(_),i[y]=_}),Object.keys(i).forEach(m=>{const y=i[m];y.inputNames.forEach((_,w)=>{const[T,,I]=vl(_),O=i[T];if(null!=O.outputs){const M=O.outputs.indexOf(I);-1!==M&&(y.inputNames[w]=`${T}:${M}`)}y.inputs.push(O),O.children.push(y)})});const c=t.ret;t.signature.outputArg.forEach(m=>{const[y,_]=vl(c[m.name]),w=i[y];null!=w&&(w.defaultOutput=_,a.push(w))});const p=this.mapArgsToSignature(t);return{nodes:i,inputs:o,outputs:a,weights:s,placeholders:[],signature:p}}mapArgsToSignature(t){return{methodName:t.signature.name,inputs:t.signature.inputArg.reduce((e,r)=>(e[r.name]=this.mapArgToTensorInfo(r),e),{}),outputs:t.signature.outputArg.reduce((e,r)=>(e[r.name]=this.mapArgToTensorInfo(r,t.ret),e),{})}}mapArgToTensorInfo(t,e){let r=t.name;return null!=e&&(r=e[r]),{name:r,dtype:t.type}}}function az(n,t){const e=Array.isArray(n)?String.fromCharCode.apply(null,n):function rme(n){const t=De().global;if(typeof t.atob<"u")return t.atob(n);if(typeof Buffer<"u")return new Buffer(n,"base64").toString();throw new Error("Unable to decode base64 in this environment. Missing built-in atob() or Buffer()")}(n);return t?e:e.toLowerCase()}function qD(n,t,e,r=!1){const s=n[t];return null!=s?az(s.s,r):e}function KD(n,t,e){const r=n[t];return r?r.b:e}function XD(n,t,e){const r=n[t]||{},s=null!=r.i?r.i:null!=r.f?r.f:e;return"number"==typeof s?s:parseInt(s,10)}function YD(n){switch("string"==typeof n&&(n=Ye[n]),n){case Ye.DT_FLOAT:case Ye.DT_HALF:return"float32";case Ye.DT_INT32:case Ye.DT_INT64:case Ye.DT_INT8:case Ye.DT_UINT8:return"int32";case Ye.DT_BOOL:return"bool";case Ye.DT_DOUBLE:return"float32";case Ye.DT_STRING:return"string";default:return null}}function lz(n,t,e){const r=n[t];return r&&r.func?r.func.name:e}function ZD(n,t,e){const r=n[t];return r&&r.type?YD(r.type):e}function QD(n,t,e){const r=n[t];return r&&r.list&&r.list.type?r.list.type.map(s=>YD(s)):e}function uz(n){if(!n.unknownRank)return null!=n.dim?n.dim.map(t=>"number"==typeof t.size?t.size:parseInt(t.size,10)):[]}function JD(n,t,e){const r=n[t];return r&&r.shape?uz(r.shape):e}function eA(n,t,e){const r=n[t];return r?((r.list.f&&r.list.f.length?r.list.f:r.list.i)||[]).map(s=>"number"==typeof s?s:parseInt(s,10)):e}function tA(n,t,e,r=!1){const s=n[t];return s&&s.list&&s.list.s?s.list.s.map(i=>az(i,r)):e}function nA(n,t,e){const r=n[t];return r&&r.list&&r.list.shape?r.list.shape.map(s=>uz(s)):e}function rA(n,t,e){const r=n[t];return r&&r.list&&r.list.b?r.list.b:e}class sme{constructor(t,e,r){this.node=t,this.tensorMap=e,this.context=r,this.inputs=[],this.attrs={},this.inputs=t.inputNames.map(s=>this.getInput(s)),null!=t.rawAttrs&&(this.attrs=Object.keys(t.rawAttrs).reduce((s,i)=>(s[i]=this.getAttr(i),s),{}))}getInput(t){return xs(t,this.tensorMap,this.context)}getAttr(t,e){const r=this.node.rawAttrs[t];if(null!=r.tensor)return xs(t,this.tensorMap,this.context);if(null!=r.i||null!=r.f)return XD(this.node.rawAttrs,t,e);if(null!=r.s)return qD(this.node.rawAttrs,t,e);if(null!=r.b)return KD(this.node.rawAttrs,t,e);if(null!=r.shape)return JD(this.node.rawAttrs,t,e);if(null!=r.type)return ZD(this.node.rawAttrs,t,e);if(null!=r.list){if(null!=r.list.i||null!=r.list.f)return eA(this.node.rawAttrs,t,e);if(null!=r.list.s)return tA(this.node.rawAttrs,t,e);if(null!=r.list.shape)return nA(this.node.rawAttrs,t,e);if(null!=r.list.b)return rA(this.node.rawAttrs,t,e);if(null!=r.list.type)return QD(this.node.rawAttrs,t,e)}return e}}function Do(n,t,e=""){if("number"!=typeof n&&"number"!=typeof t){J(n.length===t.length,()=>e+` Shapes ${n} and ${t} must match`);for(let r=0;r<n.length;r++){const s=n[r],i=t[r];J(s<0||i<0||s===i,()=>e+` Shapes ${n} and ${t} must match`)}}}function cz(n){return!("number"==typeof n||n.some(t=>t<0))}function bg(n,t,e){let r=sA(n,e);const s=!cz(r);if(s&&0===t.length)throw new Error(`Tried to calculate elements of an empty list with non-fully-defined elementShape: ${r}`);if(s&&t.forEach(i=>{r=sA(i.shape,r)}),!cz(r))throw new Error(`Non-fully-defined elementShape: ${r}`);return r}function sA(n,t){if("number"==typeof n)return t;if("number"==typeof t)return n;if(n.length!==t.length)throw new Error(`Incompatible ranks during merge: ${n} vs. ${t}`);const e=[];for(let r=0;r<n.length;++r){const s=n[r],i=t[r];if(s>=0&&i>=0&&s!==i)throw new Error(`Incompatible shape during merge: ${n} vs. ${t}`);e[r]=s>=0?s:i}return e}class ame{constructor(t,e,r,s,i,o,a){this.name=t,this.dtype=e,this.maxSize=r,this.elementShape=s,this.identicalElementShapes=i,this.dynamicSize=o,this.clearAfterRead=a,this.tensors=[],this.closed_=!1,this.idTensor=Rt(0),as(this.idTensor)}get id(){return this.idTensor.id}get closed(){return this.closed_}clearAndClose(t){this.tensors.forEach(e=>{(null==t||!t.has(e.tensor.id))&&e.tensor.dispose()}),this.tensors=[],this.closed_=!0,this.idTensor.dispose()}size(){return this.tensors.length}read(t){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(t<0||t>=this.size())throw new Error(`Tried to read from index ${t}, but array size is: ${this.size()}`);const e=this.tensors[t];if(e.cleared)throw new Error(`TensorArray ${this.name}: Could not read index ${t} twice because it was cleared after a previous read (perhaps try setting clear_after_read = false?).`);return this.clearAfterRead&&(e.cleared=!0),e.read=!0,e.tensor}readMany(t){return t.map(e=>this.read(e))}write(t,e){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(t<0||!this.dynamicSize&&t>=this.maxSize)throw new Error(`Tried to write to index ${t}, but array is not resizeable and size is: ${this.maxSize}`);const r=this.tensors[t]||{};if(e.dtype!==this.dtype)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${t},\n          because the value dtype is ${e.dtype}, but TensorArray dtype is ${this.dtype}.`);if(0===this.size()&&(null==this.elementShape||0===this.elementShape.length)&&(this.elementShape=e.shape),Do(this.elementShape,e.shape,`TensorArray ${this.name}: Could not write to TensorArray index ${t}.`),r.read)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${t}, because it has already been read.`);if(r.written)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${t}, because it has already been written.`);r.tensor=e,as(e),r.written=!0,this.tensors[t]=r}writeMany(t,e){if(t.length!==e.length)throw new Error(`TensorArray ${this.name}: could not write multiple tensors,because the index size: ${t.length} is not the same as tensors size: ${e.length}.`);t.forEach((r,s)=>this.write(r,e[s]))}gather(t,e){if(e&&e!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but gather requested dtype ${e}`);if(t)t=t.slice(0,this.size());else{t=[];for(let s=0;s<this.size();s++)t.push(s)}if(0===t.length)return Yo([],[0].concat(this.elementShape));const r=this.readMany(t);return Do(this.elementShape,r[0].shape,"TensorArray shape mismatch: "),qi(r,0)}concat(t){if(t&&t!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but concat requested dtype ${t}`);if(0===this.size())return Yo([],[0].concat(this.elementShape));const e=[];for(let s=0;s<this.size();s++)e.push(s);const r=this.readMany(e);return Do(this.elementShape,r[0].shape,`TensorArray shape mismatch: tensor array shape (${this.elementShape}) vs first tensor shape (${r[0].shape})`),Vr(r,0)}scatter(t,e){if(e.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${e.dtype}`);if(t.length!==e.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${t.length} vs. ${e.shape[0]}`);const r=Math.max(...t);if(!this.dynamicSize&&r>=this.maxSize)throw new Error(`Max index must be < array size (${r}  vs. ${this.maxSize})`);this.writeMany(t,So(e,0))}split(t,e){if(e.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${e.dtype}`);let r=0;const s=t.map(u=>(r+=u,r));if(r!==e.shape[0])throw new Error(`Expected sum of lengths to be equal to\n          tensor.shape[0], but sum of lengths is\n        ${r}, and tensor's shape is: ${e.shape}`);if(!this.dynamicSize&&t.length!==this.maxSize)throw new Error(`TensorArray's size is not equal to the size of lengths (${this.maxSize} vs. ${t.length}), and the TensorArray is not marked as dynamically resizeable`);const i=0===r?0:e.size/r,o=[];Ce(()=>{e=be(e,[1,r,i]);for(let u=0;u<t.length;++u)o[u]=be(gn(e,[0,0===u?0:s[u-1],0],[1,t[u],i]),this.elementShape);return o});const a=[];for(let u=0;u<t.length;u++)a[u]=u;this.writeMany(a,o)}}class Mc{get id(){return this.idTensor.id}constructor(t,e,r,s=-1){this.tensors=t,this.elementShape=e,this.elementDtype=r,t?.forEach(i=>{if(r!==i.dtype)throw new Error(`Invalid data types; op elements ${r}, but list elements ${i.dtype}`);Do(e,i.shape,"TensorList shape mismatch: "),as(i)}),this.idTensor=Rt(0),this.maxNumElements=s,as(this.idTensor)}copy(){return new Mc([...this.tensors],this.elementShape,this.elementDtype)}clearAndClose(t){this.tensors.forEach(e=>{(null==t||!t.has(e.id))&&e.dispose()}),this.tensors.length=0,this.idTensor.dispose()}size(){return this.tensors.length}stack(t,e,r=-1){if(e!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e}, but list elements ${this.elementDtype}`);if(-1!==r&&this.tensors.length!==r)throw new Error(`Operation expected a list with ${r} elements but got a list with ${this.tensors.length} elements.`);Do(t,this.elementShape,"TensorList shape mismatch: ");const s=bg(this.elementShape,this.tensors,t);return Ce(()=>{const i=this.tensors.map(o=>be(o,s));return qi(i,0)})}popBack(t,e){if(e!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e}, but list elements ${this.elementDtype}`);if(0===this.size())throw new Error("Trying to pop from an empty list.");const r=bg(this.elementShape,this.tensors,t),s=this.tensors.pop();return s.kept=!1,Do(s.shape,t,"TensorList shape mismatch: "),be(s,r)}pushBack(t){if(t.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t.dtype}, but list elements ${this.elementDtype}`);if(Do(t.shape,this.elementShape,"TensorList shape mismatch: "),this.maxNumElements===this.size())throw new Error("Trying to push element into a full list.");as(t),this.tensors.push(t)}resize(t){if(t<0)throw new Error(`TensorListResize expects size to be non-negative. Got: ${t}`);if(-1!==this.maxNumElements&&t>this.maxNumElements)throw new Error(`TensorListResize input size ${t} is greater maxNumElement ${this.maxNumElements}.`);const e=new Mc([],this.elementShape,this.elementDtype,this.maxNumElements);e.tensors.length=t;for(let r=0;r<Math.min(this.tensors.length,t);++r)e.tensors[r]=this.tensors[r];return e}getItem(t,e,r){if(r!==this.elementDtype)throw new Error(`Invalid data types; op elements ${r}, but list elements ${this.elementDtype}`);if(t<0||t>this.tensors.length)throw new Error(`Trying to access element ${t} in a list with ${this.tensors.length} elements.`);if(null==this.tensors[t])throw new Error(`element at index ${t} is null.`);Do(this.tensors[t].shape,e,"TensorList shape mismatch: ");const s=bg(this.elementShape,this.tensors,e);return be(this.tensors[t],s)}setItem(t,e){if(e.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e.dtype}, but list elements ${this.elementDtype}`);if(t<0||-1!==this.maxNumElements&&t>=this.maxNumElements)throw new Error(`Trying to set element ${t} in a list with max ${this.maxNumElements} elements.`);Do(this.elementShape,e.shape,"TensorList shape mismatch: "),as(e),null!=this.tensors[t]&&(this.tensors[t].kept=!1),this.tensors[t]=e}gather(t,e,r){if(e!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e}, but list elements ${this.elementDtype}`);Do(this.elementShape,r,"TensorList shape mismatch: "),t=t.slice(0,this.size());const s=bg(this.elementShape,this.tensors,r);return 0===t.length?Yo([],[0].concat(s)):Ce(()=>{const i=t.map(o=>be(this.tensors[o],s));return qi(i,0)})}concat(t,e){if(t&&t!==this.elementDtype)throw new Error(`TensorList dtype is ${this.elementDtype} but concat requested dtype ${t}`);Do(this.elementShape,e,"TensorList shape mismatch: ");const r=bg(this.elementShape,this.tensors,e);return 0===this.size()?Yo([],[0].concat(r)):Ce(()=>{const s=this.tensors.map(i=>be(i,r));return Vr(s,0)})}}const hme=function(){var n=Ve(function*(t,e,r){switch(t.op){case"If":case"StatelessIf":{const s=j("thenBranch",t,e,r),i=j("elseBranch",t,e,r),o=j("cond",t,e,r),a=j("args",t,e,r);return(yield o.data())[0]?r.functionMap[s].executeFunctionAsync(a,r.tensorArrayMap,r.tensorListMap):r.functionMap[i].executeFunctionAsync(a,r.tensorArrayMap,r.tensorListMap)}case"While":case"StatelessWhile":{const s=j("body",t,e,r),i=j("cond",t,e,r),o=j("args",t,e,r),a=yield r.functionMap[i].executeFunctionAsync(o,r.tensorArrayMap,r.tensorListMap),u=o.map(m=>m.id);let c=yield a[0].data();a.forEach(m=>{!m.kept&&-1===u.indexOf(m.id)&&m.dispose()});let p=o;for(;c[0];){const m=p;p=yield r.functionMap[s].executeFunctionAsync(p,r.tensorArrayMap,r.tensorListMap);const y=p.map(w=>w.id);m.forEach(w=>{!w.kept&&-1===u.indexOf(w.id)&&-1===y.indexOf(w.id)&&w.dispose()});const _=yield r.functionMap[i].executeFunctionAsync(p,r.tensorArrayMap,r.tensorListMap);c=yield _[0].data(),_.forEach(w=>{!w.kept&&-1===u.indexOf(w.id)&&-1===y.indexOf(w.id)&&w.dispose()})}return p}case"LoopCond":return[wl(j("pred",t,e,r))];case"Switch":{const s=j("pred",t,e,r);let i=j("data",t,e,r);return i.kept||(i=wl(i)),(yield s.data())[0]?[void 0,i]:[i,void 0]}case"Merge":{const s=t.inputNames.find(i=>void 0!==xs(i,e,r));return s?[wl(xs(s,e,r))]:void 0}case"Enter":{const s=j("frameName",t,e,r),i=j("tensor",t,e,r);return r.enterFrame(s),[wl(i)]}case"Exit":{const s=j("tensor",t,e,r);return r.exitFrame(),[wl(s)]}case"NextIteration":{const s=j("tensor",t,e,r);return r.nextIteration(),[wl(s)]}case"TensorArrayV3":{const s=j("size",t,e,r),i=j("dtype",t,e,r),o=j("elementShape",t,e,r),a=j("dynamicSize",t,e,r),u=j("clearAfterRead",t,e,r),c=j("identicalElementShapes",t,e,r),p=j("name",t,e,r),m=new ame(p,i,s,o,c,a,u);return r.addTensorArray(m),[m.idTensor,Rt(1)]}case"TensorArrayWriteV3":{const s=j("tensorArrayId",t,e,r),i=j("index",t,e,r),o=j("tensor",t,e,r),a=r.getTensorArray(s.id);return a.write(i,o),[a.idTensor]}case"TensorArrayReadV3":{const s=j("tensorArrayId",t,e,r),i=j("index",t,e,r);return[r.getTensorArray(s.id).read(i)]}case"TensorArrayGatherV3":{const s=j("tensorArrayId",t,e,r),i=j("indices",t,e,r),o=j("dtype",t,e,r);return[r.getTensorArray(s.id).gather(i,o)]}case"TensorArrayScatterV3":{const s=j("tensorArrayId",t,e,r),i=j("indices",t,e,r),o=j("tensor",t,e,r),a=r.getTensorArray(s.id);return a.scatter(i,o),[a.idTensor]}case"TensorArrayConcatV3":{const s=j("tensorArrayId",t,e,r),i=r.getTensorArray(s.id),o=j("dtype",t,e,r);return[i.concat(o)]}case"TensorArraySplitV3":{const s=j("tensorArrayId",t,e,r),i=j("tensor",t,e,r),o=j("lengths",t,e,r),a=r.getTensorArray(s.id);return a.split(o,i),[a.idTensor]}case"TensorArraySizeV3":{const s=j("tensorArrayId",t,e,r);return[Rt(r.getTensorArray(s.id).size(),"int32")]}case"TensorArrayCloseV3":{const s=j("tensorArrayId",t,e,r),i=r.getTensorArray(s.id);return i.clearAndClose(),[i.idTensor]}case"TensorListSetItem":{const s=j("tensorListId",t,e,r),i=j("index",t,e,r),o=j("tensor",t,e,r),a=r.getTensorList(s.id);return a.setItem(i,o),[a.idTensor]}case"TensorListGetItem":{const s=j("tensorListId",t,e,r),i=j("index",t,e,r),o=j("elementShape",t,e,r),a=j("elementDType",t,e,r);return[r.getTensorList(s.id).getItem(i,o,a)]}case"TensorListScatterV2":case"TensorListScatter":{const s=j("indices",t,e,r),u=function cme(n,t,e,r){if(t.length!==n.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${t.length} vs. ${n.shape[0]}`);const s=Math.max(...t);if(null!=r&&-1!==r&&s>=r)throw new Error(`Max index must be < array size (${s}  vs. ${r})`);const i=new Mc([],e,n.dtype,r),o=So(n,0);return t.forEach((a,u)=>{i.setItem(a,o[u])}),i}(j("tensor",t,e,r),s,j("elementShape",t,e,r),j("numElements",t,e,r));return r.addTensorList(u),[u.idTensor]}case"TensorListReserve":case"EmptyTensorList":{const s=j("elementShape",t,e,r),i=j("elementDType",t,e,r);let o;o="TensorListReserve"===t.op?"numElements":"maxNumElements";const a=j(o,t,e,r),c=function ume(n,t,e,r){return new Mc([],n,t,r)}(s,i,0,"TensorListReserve"===t.op?-1:a);return r.addTensorList(c),[c.idTensor]}case"TensorListGather":{const s=j("tensorListId",t,e,r),i=j("indices",t,e,r),o=j("elementShape",t,e,r),a=j("elementDType",t,e,r);return[r.getTensorList(s.id).gather(i,a,o)]}case"TensorListStack":{const s=j("tensorListId",t,e,r),i=j("elementShape",t,e,r),o=j("elementDType",t,e,r),a=j("numElements",t,e,r);return[r.getTensorList(s.id).stack(i,o,a)]}case"TensorListFromTensor":{const a=function lme(n,t,e){const r=n.dtype;if(n.shape.length<1)throw new Error(`Tensor must be at least a vector, but saw shape: ${n.shape}`);if(n.dtype!==e)throw new Error(`Invalid data types; op elements ${n.dtype}, but list elements ${e}`);Do(n.shape.slice(1),t,"TensorList shape mismatch: ");const i=So(n);return new Mc(i,t,r)}(j("tensor",t,e,r),j("elementShape",t,e,r),j("elementDType",t,e,r));return r.addTensorList(a),[a.idTensor]}case"TensorListConcat":case"TensorListConcatV2":{const s=j("tensorListId",t,e,r),i=r.getTensorList(s.id),o=j("dtype",t,e,r),a=j("elementShape",t,e,r);return[i.concat(o,a)]}case"TensorListPushBack":{const s=j("tensorListId",t,e,r),i=j("tensor",t,e,r),o=r.getTensorList(s.id);return o.pushBack(i),[o.idTensor]}case"TensorListPopBack":{const s=j("tensorListId",t,e,r),i=j("elementShape",t,e,r),o=j("elementDType",t,e,r);return[r.getTensorList(s.id).popBack(i,o)]}case"TensorListSplit":{const s=j("tensor",t,e,r),i=j("elementShape",t,e,r),a=function dme(n,t,e){let r=0;const s=t.map(p=>(r+=p,r));if(r!==n.shape[0])throw new Error(`Expected sum of lengths to be equal to\n          tensor.shape[0], but sum of lengths is\n        ${r}, and tensor's shape is: ${n.shape}`);const o=sA(n.shape.slice(1),e),a=0===r?0:n.size/r,u=Ce(()=>{const p=[];n=be(n,[1,r,a]);for(let m=0;m<t.length;++m)p[m]=be(gn(n,[0,0===m?0:s[m-1],0],[1,t[m],a]),o);return n.dispose(),p}),c=new Mc([],e,n.dtype,t.length);for(let p=0;p<u.length;p++)c.setItem(p,u[p]);return c}(s,j("lengths",t,e,r),i);return r.addTensorList(a),[a.idTensor]}case"TensorListLength":{const s=j("tensorListId",t,e,r);return[Rt(r.getTensorList(s.id).size(),"int32")]}case"TensorListResize":{const s=j("tensorListId",t,e,r),i=j("size",t,e,r),a=r.getTensorList(s.id).resize(i);return r.addTensorList(a),[a.idTensor]}default:throw TypeError(`Node type ${t.op} is not implemented`)}});return function(e,r,s){return n.apply(this,arguments)}}();function dz(n,t,e){const[r,s]=j("fusedOps",n,t,e),i="biasadd"===r,o=!i,a="prelu"===s,u="fusedbatchnorm"===r,c=j("numArgs",n,t,e);if(i){if(a&&2!==c)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!a&&i&&1!==c)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd must have one extra argument: bias.")}if(u)throw new Error("FusedConv2d and DepthwiseConv2d with FusedBatchNorm is not supported");const p=j("strides",n,t,e),m=T0(n,t,e),y=j("dataFormat",n,t,e).toUpperCase(),_=j("dilations",n,t,e);let[w,T]=j("args",n,t,e);return o&&(T=w,w=void 0),{stride:p,pad:m,dataFormat:y,dilations:_,biasArg:w,preluArg:T,activationFunc:s,leakyreluAlpha:j("leakyreluAlpha",n,t,e)}}function iA(n,t,e){return{boxes:j("boxes",n,t,e),scores:j("scores",n,t,e),maxOutputSize:j("maxOutputSize",n,t,e),iouThreshold:j("iouThreshold",n,t,e),scoreThreshold:j("scoreThreshold",n,t,e),softNmsSigma:j("softNmsSigma",n,t,e)}}const mme=function(){var n=Ve(function*(t,e,r,s,i=se){switch(t.op){case"NonMaxSuppressionV5":{const{boxes:o,scores:a,maxOutputSize:u,iouThreshold:c,scoreThreshold:p,softNmsSigma:m}=iA(t,e,r),y=yield i.image.nonMaxSuppressionWithScoreAsync(o,a,u,c,p,m);return[y.selectedIndices,y.selectedScores]}case"NonMaxSuppressionV4":{const{boxes:o,scores:a,maxOutputSize:u,iouThreshold:c,scoreThreshold:p}=iA(t,e,r),m=j("padToMaxOutputSize",t,e,r),y=yield i.image.nonMaxSuppressionPaddedAsync(o,a,u,c,p,m);return[y.selectedIndices,y.validOutputs]}case"NonMaxSuppressionV3":case"NonMaxSuppressionV2":{const{boxes:o,scores:a,maxOutputSize:u,iouThreshold:c,scoreThreshold:p}=iA(t,e,r);return[yield i.image.nonMaxSuppressionAsync(o,a,u,c,p)]}case"Where":{const o=i.cast(j("condition",t,e,r),"bool"),a=[yield i.whereAsync(o)];return o.dispose(),a}case"ListDiff":return i.setdiff1dAsync(j("x",t,e,r),j("y",t,e,r));default:throw TypeError(`Node type ${t.op} is not implemented`)}});return function(e,r,s,i){return n.apply(this,arguments)}}();class bme{get id(){return this.handle.id}constructor(t,e){this.keyDType=t,this.valueDType=e,this.handle=Rt(0),this.tensorMap=new Map,as(this.handle)}clearAndClose(){this.tensorMap.forEach(t=>t.dispose()),this.tensorMap.clear(),this.handle.dispose()}size(){return this.tensorMap.size}tensorSize(){return Rt(this.size(),"int32")}import(t,e){var r=this;return Ve(function*(){r.checkKeyAndValueTensor(t,e);const s=yield t.data();return r.tensorMap.forEach(i=>i.dispose()),r.tensorMap.clear(),Ce(()=>{const i=So(e),o=s.length,a=i.length;J(o===a,()=>`The number of elements doesn't match, keys has ${o} elements, the values has ${a} elements.`);for(let u=0;u<o;u++){const c=s[u],p=i[u];as(p),r.tensorMap.set(c,p)}return r.handle})})()}find(t,e){var r=this;return Ve(function*(){r.checkKeyAndValueTensor(t,e);const s=yield t.data();return Ce(()=>{const i=[];for(let o=0;o<s.length;o++){const u=r.findWithDefault(s[o],e);i.push(u)}return qi(i)})})()}findWithDefault(t,e){return this.tensorMap.get(t)??e}checkKeyAndValueTensor(t,e){if(t.dtype!==this.keyDType)throw new Error(`Expect key dtype ${this.keyDType}, but got ${t.dtype}`);if(e.dtype!==this.valueDType)throw new Error(`Expect value dtype ${this.valueDType}, but got ${e.dtype}`)}}const _me=function(){var n=Ve(function*(t,e,r,s){switch(t.op){case"HashTable":case"HashTableV2":{const i=s.getHashTableHandleByName(t.name);if(null!=i)return[i];{const o=j("keyDType",t,e,r),a=j("valueDType",t,e,r),u=new bme(o,a);return s.addHashTable(t.name,u),[u.handle]}}case"InitializeTable":case"InitializeTableV2":case"LookupTableImport":case"LookupTableImportV2":{const i=j("tableHandle",t,e,r,s),o=j("keys",t,e,r),a=j("values",t,e,r);return[yield s.getHashTableById(i.id).import(o,a)]}case"LookupTableFind":case"LookupTableFindV2":{const i=j("tableHandle",t,e,r,s),o=j("keys",t,e,r),a=j("defaultValue",t,e,r);return[yield s.getHashTableById(i.id).find(o,a)]}case"LookupTableSize":case"LookupTableSizeV2":{const i=j("tableHandle",t,e,r,s);return[s.getHashTableById(i.id).tensorSize()]}default:throw TypeError(`Node type ${t.op} is not implemented`)}});return function(e,r,s,i){return n.apply(this,arguments)}}();function hz(n,t,e,r,s=Ce){const i=((o,a,u)=>{switch(o.category){case"arithmetic":return s(()=>((n,t,e,r=se)=>{switch(n.op){case"BiasAdd":case"AddV2":case"Add":return[r.add(j("a",n,t,e),j("b",n,t,e))];case"AddN":return[r.addN(j("tensors",n,t,e))];case"FloorMod":case"Mod":return[r.mod(j("a",n,t,e),j("b",n,t,e))];case"Mul":return[r.mul(j("a",n,t,e),j("b",n,t,e))];case"RealDiv":case"Div":return[r.div(j("a",n,t,e),j("b",n,t,e))];case"DivNoNan":return[r.divNoNan(j("a",n,t,e),j("b",n,t,e))];case"FloorDiv":return[r.floorDiv(j("a",n,t,e),j("b",n,t,e))];case"Sub":return[r.sub(j("a",n,t,e),j("b",n,t,e))];case"Minimum":return[r.minimum(j("a",n,t,e),j("b",n,t,e))];case"Maximum":return[r.maximum(j("a",n,t,e),j("b",n,t,e))];case"Pow":return[r.pow(j("a",n,t,e),j("b",n,t,e))];case"SquaredDifference":return[r.squaredDifference(j("a",n,t,e),j("b",n,t,e))];default:throw TypeError(`Node type ${n.op} is not implemented`)}})(o,a,u));case"basic_math":return s(()=>((n,t,e,r=se)=>{switch(n.op){case"Abs":case"ComplexAbs":return[r.abs(j("x",n,t,e))];case"Acos":return[r.acos(j("x",n,t,e))];case"Acosh":return[r.acosh(j("x",n,t,e))];case"Asin":return[r.asin(j("x",n,t,e))];case"Asinh":return[r.asinh(j("x",n,t,e))];case"Atan":return[r.atan(j("x",n,t,e))];case"Atan2":return[r.atan2(j("x",n,t,e),j("y",n,t,e))];case"Atanh":return[r.atanh(j("x",n,t,e))];case"Ceil":return[r.ceil(j("x",n,t,e))];case"Complex":return[r.complex(j("real",n,t,e),j("imag",n,t,e))];case"Cos":return[r.cos(j("x",n,t,e))];case"Cosh":return[r.cosh(j("x",n,t,e))];case"Elu":return[r.elu(j("x",n,t,e))];case"Erf":return[r.erf(j("x",n,t,e))];case"Exp":return[r.exp(j("x",n,t,e))];case"Expm1":return[r.expm1(j("x",n,t,e))];case"Floor":return[r.floor(j("x",n,t,e))];case"Log":return[r.log(j("x",n,t,e))];case"Log1p":return[r.log1p(j("x",n,t,e))];case"Imag":return[r.imag(j("x",n,t,e))];case"Neg":return[r.neg(j("x",n,t,e))];case"Reciprocal":return[r.reciprocal(j("x",n,t,e))];case"Real":return[r.real(j("x",n,t,e))];case"Relu":return[r.relu(j("x",n,t,e))];case"Round":return[r.round(j("x",n,t,e))];case"Selu":return[r.selu(j("x",n,t,e))];case"Sigmoid":return[r.sigmoid(j("x",n,t,e))];case"Sin":return[r.sin(j("x",n,t,e))];case"Sign":return[r.sign(j("x",n,t,e))];case"Sinh":return[r.sinh(j("x",n,t,e))];case"Softplus":return[r.softplus(j("x",n,t,e))];case"Sqrt":return[r.sqrt(j("x",n,t,e))];case"Square":return[r.square(j("x",n,t,e))];case"Tanh":return[r.tanh(j("x",n,t,e))];case"Tan":return[r.tan(j("x",n,t,e))];case"ClipByValue":return[r.clipByValue(j("x",n,t,e),j("clipValueMin",n,t,e),j("clipValueMax",n,t,e))];case"Relu6":return[r.relu6(j("x",n,t,e))];case"Rsqrt":return[r.rsqrt(xs(n.inputNames[0],t,e))];case"LeakyRelu":return[r.leakyRelu(j("x",n,t,e),j("alpha",n,t,e))];case"Prelu":return[r.prelu(j("x",n,t,e),j("alpha",n,t,e))];case"IsNan":return[r.isNaN(xs(n.inputNames[0],t,e))];case"IsInf":return[r.isInf(xs(n.inputNames[0],t,e))];case"IsFinite":return[r.isFinite(xs(n.inputNames[0],t,e))];default:throw TypeError(`Node type ${n.op} is not implemented`)}})(o,a,u));case"control":return hme(o,a,u);case"convolution":return s(()=>((n,t,e,r=se)=>{switch(n.op){case"Conv1D":{const s=j("stride",n,t,e),i=j("pad",n,t,e),o=j("dataFormat",n,t,e).toUpperCase(),a=j("dilation",n,t,e);return[r.conv1d(j("x",n,t,e),j("filter",n,t,e),s,i,o,a)]}case"Conv2D":{const s=j("strides",n,t,e),i=T0(n,t,e),o=j("dataFormat",n,t,e).toUpperCase(),a=j("dilations",n,t,e);return[r.conv2d(j("x",n,t,e),j("filter",n,t,e),[s[1],s[2]],i,o,[a[1],a[2]])]}case"_FusedConv2D":{const{stride:s,pad:i,dataFormat:o,dilations:a,biasArg:u,preluArg:c,activationFunc:p,leakyreluAlpha:m}=dz(n,t,e);return[r.fused.conv2d({x:j("x",n,t,e),filter:j("filter",n,t,e),strides:[s[1],s[2]],pad:i,dataFormat:o,dilations:[a[1],a[2]],bias:u,activation:p,preluActivationWeights:c,leakyreluAlpha:m})]}case"FusedDepthwiseConv2dNative":{const{stride:s,pad:i,dataFormat:o,dilations:a,biasArg:u,preluArg:c,activationFunc:p,leakyreluAlpha:m}=dz(n,t,e);return[r.fused.depthwiseConv2d({x:j("x",n,t,e),filter:j("filter",n,t,e),strides:[s[1],s[2]],pad:i,dataFormat:o,dilations:[a[1],a[2]],bias:u,activation:p,preluActivationWeights:c,leakyreluAlpha:m})]}case"Conv2DBackpropInput":case"Conv2dTranspose":{const s=j("outputShape",n,t,e),i=j("strides",n,t,e),o=T0(n,t,e);return[r.conv2dTranspose(j("x",n,t,e),j("filter",n,t,e),s,[i[1],i[2]],o)]}case"DepthwiseConv2dNative":case"DepthwiseConv2d":{const s=j("strides",n,t,e),i=T0(n,t,e),o=j("dilations",n,t,e),a=j("dataFormat",n,t,e).toUpperCase();return[r.depthwiseConv2d(j("input",n,t,e),j("filter",n,t,e),[s[1],s[2]],i,a,[o[1],o[2]])]}case"Conv3D":{const s=j("strides",n,t,e),i=j("pad",n,t,e),o=j("dataFormat",n,t,e).toUpperCase(),a=j("dilations",n,t,e);return[r.conv3d(j("x",n,t,e),j("filter",n,t,e),[s[1],s[2],s[3]],i,o,[a[1],a[2],a[3]])]}case"AvgPool":{const s=j("strides",n,t,e),i=j("pad",n,t,e),o=j("kernelSize",n,t,e);return[r.avgPool(j("x",n,t,e),[o[1],o[2]],[s[1],s[2]],i)]}case"MaxPool":{const s=j("strides",n,t,e),i=j("pad",n,t,e),o=j("kernelSize",n,t,e);return[r.maxPool(j("x",n,t,e),[o[1],o[2]],[s[1],s[2]],i)]}case"MaxPoolWithArgmax":{const s=j("strides",n,t,e),i=j("pad",n,t,e),o=j("kernelSize",n,t,e),a=j("includeBatchInIndex",n,t,e),{result:u,indexes:c}=r.maxPoolWithArgmax(j("x",n,t,e),[o[1],o[2]],[s[1],s[2]],i,a);return[u,c]}case"AvgPool3D":{const s=j("strides",n,t,e),i=j("pad",n,t,e),o=j("kernelSize",n,t,e);return[r.avgPool3d(j("x",n,t,e),[o[1],o[2],o[3]],[s[1],s[2],s[3]],i)]}case"MaxPool3D":{const s=j("strides",n,t,e),i=j("pad",n,t,e),o=j("kernelSize",n,t,e);return[r.maxPool3d(j("x",n,t,e),[o[1],o[2],o[3]],[s[1],s[2],s[3]],i)]}case"Dilation2D":{const s=j("strides",n,t,e),i=j("pad",n,t,e),o=j("dilations",n,t,e),a=s[1],u=s[2],c=o[1],p=o[2];return[r.dilation2d(j("x",n,t,e),j("filter",n,t,e),[a,u],i,[c,p],"NHWC")]}default:throw TypeError(`Node type ${n.op} is not implemented`)}})(o,a,u));case"creation":return s(()=>((n,t,e,r=se)=>{switch(n.op){case"Fill":{const s=j("shape",n,t,e),i=j("dtype",n,t,e),o=j("value",n,t,e);return[r.fill(s,o,i)]}case"LinSpace":{const s=j("start",n,t,e),i=j("stop",n,t,e),o=j("num",n,t,e);return[r.linspace(s,i,o)]}case"Multinomial":{const s=j("logits",n,t,e),i=j("numSamples",n,t,e),o=j("seed",n,t,e);return[r.multinomial(s,i,o)]}case"OneHot":{const s=j("indices",n,t,e),i=j("depth",n,t,e),o=j("onValue",n,t,e),a=j("offValue",n,t,e),u=j("dtype",n,t,e);return[r.oneHot(s,i,o,a,u)]}case"Ones":return[r.ones(j("shape",n,t,e),j("dtype",n,t,e))];case"OnesLike":return[r.onesLike(j("x",n,t,e))];case"RandomStandardNormal":return[r.randomStandardNormal(j("shape",n,t,e),j("dtype",n,t,e),j("seed",n,t,e))];case"RandomUniform":return[r.randomUniform(j("shape",n,t,e),j("minval",n,t,e),j("maxval",n,t,e),j("dtype",n,t,e))];case"RandomUniformInt":return[r.randomUniformInt(j("shape",n,t,e),j("minval",n,t,e),j("maxval",n,t,e),j("seed",n,t,e))];case"Range":{const s=j("start",n,t,e),i=j("stop",n,t,e),o=j("step",n,t,e);return[r.range(s,i,o,j("dtype",n,t,e))]}case"TruncatedNormal":{const s=j("shape",n,t,e),i=j("mean",n,t,e),o=j("stdDev",n,t,e),a=j("seed",n,t,e);return[r.truncatedNormal(s,i,o,j("dtype",n,t,e),a)]}case"Zeros":return[r.zeros(j("shape",n,t,e),j("dtype",n,t,e))];case"ZerosLike":return[r.zerosLike(j("x",n,t,e))];default:throw TypeError(`Node type ${n.op} is not implemented`)}})(o,a,u));case"dynamic":return mme(o,a,u);case"evaluation":return s(()=>((n,t,e,r=se)=>{switch(n.op){case"LowerBound":{const s=j("sortedSequence",n,t,e),i=j("values",n,t,e);return[r.lowerBound(s,i)]}case"TopKV2":{const s=j("x",n,t,e),i=j("k",n,t,e),o=j("sorted",n,t,e),a=r.topk(s,i,o);return[a.values,a.indices]}case"UpperBound":{const s=j("sortedSequence",n,t,e),i=j("values",n,t,e);return[r.upperBound(s,i)]}case"Unique":{const s=j("x",n,t,e),i=r.unique(s);return[i.values,i.indices]}case"UniqueV2":{const s=j("x",n,t,e),i=j("axis",n,t,e),o=r.unique(s,i);return[o.values,o.indices]}default:throw TypeError(`Node type ${n.op} is not implemented`)}})(o,a,u));case"image":return s(()=>((n,t,e,r=se)=>{switch(n.op){case"ResizeBilinear":{const s=j("images",n,t,e),i=j("size",n,t,e),o=j("alignCorners",n,t,e),a=j("halfPixelCenters",n,t,e);return[r.image.resizeBilinear(s,[i[0],i[1]],o,a)]}case"ResizeNearestNeighbor":{const s=j("images",n,t,e),i=j("size",n,t,e),o=j("alignCorners",n,t,e),a=j("halfPixelCenters",n,t,e);return[r.image.resizeNearestNeighbor(s,[i[0],i[1]],o,a)]}case"CropAndResize":{const s=j("image",n,t,e),i=j("boxes",n,t,e),o=j("boxInd",n,t,e),a=j("cropSize",n,t,e),u=j("method",n,t,e),c=j("extrapolationValue",n,t,e);return[r.image.cropAndResize(s,i,o,a,u,c)]}case"ImageProjectiveTransformV3":{const s=j("images",n,t,e),i=j("transforms",n,t,e),o=j("outputShape",n,t,e),a=j("fillValue",n,t,e),u=j("interpolation",n,t,e),c=j("fillMode",n,t,e);return[r.image.transform(s,i,u.toLowerCase(),c.toLowerCase(),a,o)]}default:throw TypeError(`Node type ${n.op} is not implemented`)}})(o,a,u));case"graph":return s(()=>((n,t,e,r=se)=>{switch(n.op){case"Const":return t[n.name];case"PlaceholderWithDefault":const s=j("default",n,t,e);return[xs(n.name,t,e)||s];case"Placeholder":return[xs(n.name,t,e)];case"Identity":case"StopGradient":case"FakeQuantWithMinMaxVars":case"Snapshot":return[wl(j("x",n,t,e))];case"IdentityN":return j("x",n,t,e).map(p=>wl(p));case"Shape":return[r.tensor1d(j("x",n,t,e).shape,"int32")];case"ShapeN":return j("x",n,t,e).map(p=>r.tensor1d(p.shape));case"Size":return[r.scalar(j("x",n,t,e).size,"int32")];case"Rank":return[r.scalar(j("x",n,t,e).rank,"int32")];case"NoOp":return[r.scalar(1)];case"Print":const o=j("x",n,t,e),a=j("data",n,t,e),u=j("message",n,t,e),c=j("summarize",n,t,e);console.warn("The graph has a tf.print() operation,usually used for debugging, which slows down performance."),console.log(u);for(let p=0;p<a.length;p++)console.log(Array.prototype.slice.call(a[p].dataSync()).slice(0,c));return[o];default:throw TypeError(`Node type ${n.op} is not implemented`)}})(o,a,u));case"logical":return s(()=>((n,t,e,r=se)=>{switch(n.op){case"Equal":return[r.equal(j("a",n,t,e),j("b",n,t,e))];case"NotEqual":return[r.notEqual(j("a",n,t,e),j("b",n,t,e))];case"Greater":return[r.greater(j("a",n,t,e),j("b",n,t,e))];case"GreaterEqual":return[r.greaterEqual(j("a",n,t,e),j("b",n,t,e))];case"Less":return[r.less(j("a",n,t,e),j("b",n,t,e))];case"LessEqual":return[r.lessEqual(j("a",n,t,e),j("b",n,t,e))];case"LogicalAnd":return[r.logicalAnd(j("a",n,t,e),j("b",n,t,e))];case"LogicalNot":return[r.logicalNot(j("a",n,t,e))];case"LogicalOr":return[r.logicalOr(j("a",n,t,e),j("b",n,t,e))];case"Select":case"SelectV2":return[r.where(j("condition",n,t,e),j("a",n,t,e),j("b",n,t,e))];case"BitwiseAnd":return[r.bitwiseAnd(j("a",n,t,e),j("b",n,t,e))];default:throw TypeError(`Node type ${n.op} is not implemented`)}})(o,a,u));case"matrices":return s(()=>((n,t,e,r=se)=>{switch(n.op){case"BatchMatMul":case"BatchMatMulV2":case"MatMul":return[r.matMul(j("a",n,t,e),j("b",n,t,e),j("transposeA",n,t,e),j("transposeB",n,t,e))];case"Einsum":return[r.einsum(j("equation",n,t,e),...j("tensors",n,t,e))];case"Transpose":return[r.transpose(j("x",n,t,e),j("perm",n,t,e))];case"_FusedMatMul":const[s,i]=j("fusedOps",n,t,e),o="biasadd"===s,a="prelu"===i,u=j("numArgs",n,t,e),c=j("leakyreluAlpha",n,t,e);if(o){if(a&&2!==u)throw new Error("Fused MatMul with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!a&&1!==u)throw new Error("Fused MatMul with BiasAdd must have one extra argument: bias.")}const[p,m]=j("args",n,t,e);return[r.fused.matMul({a:j("a",n,t,e),b:j("b",n,t,e),transposeA:j("transposeA",n,t,e),transposeB:j("transposeB",n,t,e),bias:p,activation:i,preluActivationWeights:m,leakyreluAlpha:c})];case"MatrixBandPart":return[r.linalg.bandPart(j("a",n,t,e),j("numLower",n,t,e),j("numUpper",n,t,e))];default:throw TypeError(`Node type ${n.op} is not implemented`)}})(o,a,u));case"normalization":return s(()=>((n,t,e,r=se)=>{switch(n.op){case"EuclideanNorm":return[r.euclideanNorm(j("x",n,t,e),j("axis",n,t,e),j("keepDims",n,t,e))];case"FusedBatchNorm":case"FusedBatchNormV2":case"FusedBatchNormV3":return[r.batchNorm(j("x",n,t,e),j("mean",n,t,e),j("variance",n,t,e),j("offset",n,t,e),j("scale",n,t,e),j("epsilon",n,t,e))];case"LRN":return[r.localResponseNormalization(j("x",n,t,e),j("radius",n,t,e),j("bias",n,t,e),j("alpha",n,t,e),j("beta",n,t,e))];case"Softmax":return[r.softmax(j("x",n,t,e))];case"LogSoftmax":return[r.logSoftmax(j("x",n,t,e))];default:throw TypeError(`Node type ${n.op} is not implemented`)}})(o,a,u));case"ragged":return s(()=>((n,t,e,r=se)=>{switch(n.op){case"RaggedGather":{const{outputNestedSplits:s,outputDenseValues:i}=r.raggedGather(j("paramsNestedSplits",n,t,e),j("paramsDenseValues",n,t,e),j("indices",n,t,e),j("outputRaggedRank",n,t,e));return s.concat(i)}case"RaggedRange":{const{rtNestedSplits:s,rtDenseValues:i}=r.raggedRange(j("starts",n,t,e),j("limits",n,t,e),j("splits",n,t,e));return[s,i]}case"RaggedTensorToTensor":return[r.raggedTensorToTensor(j("shape",n,t,e),j("values",n,t,e),j("defaultValue",n,t,e),j("rowPartitionTensors",n,t,e),j("rowPartitionTypes",n,t,e))];default:throw TypeError(`Node type ${n.op} is not implemented`)}})(o,a,u));case"reduction":return s(()=>((n,t,e,r=se)=>{switch(n.op){case"Max":{const a=j("axis",n,t,e),u=j("keepDims",n,t,e);return[r.max(j("x",n,t,e),a,u)]}case"Mean":{const a=j("axis",n,t,e),u=j("keepDims",n,t,e);return[r.mean(j("x",n,t,e),a,u)]}case"Min":{const a=j("axis",n,t,e),u=j("keepDims",n,t,e);return[r.min(j("x",n,t,e),a,u)]}case"Sum":{const a=j("axis",n,t,e),u=j("keepDims",n,t,e);return[r.sum(j("x",n,t,e),a,u)]}case"All":{const a=j("axis",n,t,e),u=j("keepDims",n,t,e);return[r.all(j("x",n,t,e),a,u)]}case"Any":{const a=j("axis",n,t,e),u=j("keepDims",n,t,e);return[r.any(j("x",n,t,e),a,u)]}case"ArgMax":{const a=j("axis",n,t,e);return[r.argMax(j("x",n,t,e),a)]}case"ArgMin":{const a=j("axis",n,t,e);return[r.argMin(j("x",n,t,e),a)]}case"Prod":{const a=j("axis",n,t,e),u=j("keepDims",n,t,e);return[r.prod(j("x",n,t,e),a,u)]}case"Cumprod":{const a=j("axis",n,t,e),u=j("exclusive",n,t,e),c=j("reverse",n,t,e);return[r.cumprod(j("x",n,t,e),a,u,c)]}case"Cumsum":{const a=j("axis",n,t,e),u=j("exclusive",n,t,e),c=j("reverse",n,t,e);return[r.cumsum(j("x",n,t,e),a,u,c)]}case"Bincount":const s=j("x",n,t,e),i=j("weights",n,t,e),o=j("size",n,t,e);return[r.bincount(s,i,o)];case"DenseBincount":{const a=j("x",n,t,e),u=j("weights",n,t,e),c=j("size",n,t,e),p=j("binaryOutput",n,t,e);return[r.denseBincount(a,u,c,p)]}default:throw TypeError(`Node type ${n.op} is not implemented`)}})(o,a,u));case"slice_join":return s(()=>((n,t,e,r=se)=>{switch(n.op){case"ConcatV2":case"Concat":{const s=j("n",n,t,e),i=j("axis",n,t,e);let o=j("tensors",n,t,e);return o=o.slice(0,s),[r.concat(o,i)]}case"Gather":{const s=j("x",n,t,e),i=j("indices",n,t,e);return[r.gather(s,r.cast(i,"int32"),0)]}case"GatherV2":{const s=j("axis",n,t,e),i=j("batchDims",n,t,e),o=j("x",n,t,e),a=j("indices",n,t,e);return[r.gather(o,r.cast(a,"int32"),s,i)]}case"Reverse":{const s=j("dims",n,t,e),i=[];for(let a=0;a<s.length;a++)s[a]&&i.push(a);const o=j("x",n,t,e);return[r.reverse(o,i)]}case"ReverseV2":{const s=j("axis",n,t,e),i=j("x",n,t,e);return[r.reverse(i,s)]}case"Slice":{const s=j("begin",n,t,e),i=j("size",n,t,e);return[r.slice(j("x",n,t,e),s,i)]}case"StridedSlice":{const s=j("begin",n,t,e),i=j("end",n,t,e),o=j("strides",n,t,e),a=j("beginMask",n,t,e),u=j("endMask",n,t,e),c=j("ellipsisMask",n,t,e),p=j("newAxisMask",n,t,e),m=j("shrinkAxisMask",n,t,e),y=j("x",n,t,e);return[r.stridedSlice(y,s,i,o,a,u,c,p,m)]}case"Pack":return Ce(()=>{const s=j("axis",n,t,e),i=j("tensors",n,t,e),o=i[0].shape,a=r.squeeze(i[0]).shape,u=i.map(c=>{const p=hn(c.shape,o);if(!p&&!hn(r.squeeze(c).shape,a))throw new Error("the input tensors shape does not match");return p?c:r.reshape(c,o)});return[r.stack(u,s)]});case"Unpack":{const s=j("axis",n,t,e),i=j("tensor",n,t,e);return r.unstack(i,s)}case"Tile":{const s=j("reps",n,t,e);return[r.tile(j("x",n,t,e),s)]}case"Split":case"SplitV":{const s=j("axis",n,t,e),i=j("numOrSizeSplits",n,t,e),o=j("x",n,t,e);return r.split(o,i,s)}case"ScatterNd":{const s=j("indices",n,t,e),i=j("values",n,t,e),o=j("shape",n,t,e);return[r.scatterND(s,i,o)]}case"GatherNd":{const s=j("x",n,t,e),i=j("indices",n,t,e);return[r.gatherND(s,i)]}case"SparseToDense":{const s=j("sparseIndices",n,t,e),i=j("outputShape",n,t,e),o=j("sparseValues",n,t,e),a=j("defaultValue",n,t,e);return[r.sparseToDense(s,o,i,o.dtype===a.dtype?a:r.cast(a,o.dtype))]}case"TensorScatterUpdate":{const s=j("indices",n,t,e),i=j("values",n,t,e),o=j("tensor",n,t,e);return[r.tensorScatterUpdate(o,s,i)]}default:throw TypeError(`Node type ${n.op} is not implemented`)}})(o,a,u));case"sparse":return s(()=>((n,t,e,r=se)=>{switch(n.op){case"SparseFillEmptyRows":{const{outputIndices:s,outputValues:i,emptyRowIndicator:o,reverseIndexMap:a}=r.sparse.sparseFillEmptyRows(j("indices",n,t,e),j("values",n,t,e),j("denseShape",n,t,e),j("defaultValue",n,t,e));return[s,i,o,a]}case"SparseReshape":{const{outputIndices:s,outputShape:i}=r.sparse.sparseReshape(j("inputIndices",n,t,e),j("inputShape",n,t,e),j("newShape",n,t,e));return[s,i]}case"SparseSegmentMean":return[r.sparse.sparseSegmentMean(j("data",n,t,e),j("indices",n,t,e),j("segmentIds",n,t,e))];case"SparseSegmentSum":return[r.sparse.sparseSegmentSum(j("data",n,t,e),j("indices",n,t,e),j("segmentIds",n,t,e))];default:throw TypeError(`Node type ${n.op} is not implemented`)}})(o,a,u));case"spectral":return s(()=>((n,t,e,r=se)=>{switch(n.op){case"FFT":return[r.fft(j("x",n,t,e))];case"IFFT":return[r.ifft(j("x",n,t,e))];case"RFFT":return[r.rfft(j("x",n,t,e))];case"IRFFT":return[r.irfft(j("x",n,t,e))];default:throw TypeError(`Node type ${n.op} is not implemented`)}})(o,a,u));case"string":return s(()=>((n,t,e,r=se)=>{switch(n.op){case"StaticRegexReplace":return[r.string.staticRegexReplace(j("input",n,t,e),j("pattern",n,t,e),j("rewrite",n,t,e),j("replaceGlobal",n,t,e))];case"StringNGrams":{const{nGrams:s,nGramsSplits:i}=r.string.stringNGrams(j("data",n,t,e),j("dataSplits",n,t,e),j("separator",n,t,e),j("nGramWidths",n,t,e),j("leftPad",n,t,e),j("rightPad",n,t,e),j("padWidth",n,t,e),j("preserveShortSequences",n,t,e));return[s,i]}case"StringSplit":{const{indices:s,values:i,shape:o}=r.string.stringSplit(j("input",n,t,e),j("delimiter",n,t,e),j("skipEmpty",n,t,e));return[s,i,o]}case"StringToHashBucketFast":return[r.string.stringToHashBucketFast(j("input",n,t,e),j("numBuckets",n,t,e))];default:throw TypeError(`Node type ${n.op} is not implemented`)}})(o,a,u));case"transformation":return s(()=>((n,t,e,r=se)=>{switch(n.op){case"Cast":return[r.cast(j("x",n,t,e),j("dtype",n,t,e))];case"ExpandDims":{const s=j("axis",n,t,e);return[r.expandDims(j("x",n,t,e),s)]}case"Squeeze":{const s=j("axis",n,t,e);return[r.squeeze(j("x",n,t,e),s)]}case"Reshape":return[r.reshape(j("x",n,t,e),j("shape",n,t,e))];case"EnsureShape":return[r.ensureShape(j("x",n,t,e),j("shape",n,t,e))];case"MirrorPad":return[r.mirrorPad(j("x",n,t,e),j("padding",n,t,e),j("mode",n,t,e))];case"PadV2":case"Pad":return[r.pad(j("x",n,t,e),j("padding",n,t,e),j("constantValue",n,t,e))];case"SpaceToBatchND":{const s=j("blockShape",n,t,e),i=j("paddings",n,t,e);return[r.spaceToBatchND(j("x",n,t,e),s,i)]}case"BatchToSpaceND":{const s=j("blockShape",n,t,e),i=j("crops",n,t,e);return[r.batchToSpaceND(j("x",n,t,e),s,i)]}case"DepthToSpace":{const s=j("blockSize",n,t,e),i=j("dataFormat",n,t,e).toUpperCase();return[r.depthToSpace(j("x",n,t,e),s,i)]}case"BroadcastTo":return[r.broadcastTo(j("x",n,t,e),j("shape",n,t,e))];case"BroadcastArgs":return[r.broadcastArgs(j("s0",n,t,e),j("s1",n,t,e))];default:throw TypeError(`Node type ${n.op} is not implemented`)}})(o,a,u));case"hash_table":return _me(o,a,u,r);case"custom":const c=sz(o.op);if(c&&c.customExecutor)return c.customExecutor(new sme(o,a,u));throw TypeError(`Custom op ${o.op} is not registered.`);default:throw TypeError(`Unknown op '${o.op}'. File an issue at https://github.com/tensorflow/tfjs/issues so we can add it, or register a custom execution with tf.registerOp()`)}})(n,t,e);return mc(i)?i.then(o=>[].concat(o)):[].concat(i)}class pz{constructor(t={},e={},r={},s={},i){this.weightMap=t,this.tensorArrayMap=e,this.tensorListMap=r,this.functionMap=s,this.parseNodeNameCache=i,this.rootContext={id:0,frameName:"",iterationId:0},this.contexts=[this.rootContext],this.lastId=0,this.generateCurrentContextIds()}newFrame(t,e){return{id:t,frameName:e,iterationId:0}}set currentContext(t){this.contexts!==t&&(this.contexts=t,this.generateCurrentContextIds())}get currentContext(){return this.contexts}get currentContextId(){return this._currentContextIds[0]}get currentContextIds(){return this._currentContextIds}generateCurrentContextIds(){const t=[];for(let e=0;e<this.contexts.length-1;e++){const r=this.contexts.slice(0,this.contexts.length-e);t.push(this.contextIdforContexts(r))}t.push(""),this._currentContextIds=t}contextIdforContexts(t){return t?t.map(e=>0===e.id&&0===e.iterationId?"":`${e.frameName}-${e.iterationId}`).join("/"):""}enterFrame(t){this.contexts&&(this.lastId++,this.contexts=this.contexts.slice(),this.contexts.push(this.newFrame(this.lastId,t)),this._currentContextIds.unshift(this.contextIdforContexts(this.contexts)))}exitFrame(){if(!(this.contexts&&this.contexts.length>1))throw new Error("Cannot exit frame, the context is empty");this.contexts=this.contexts.slice(),this.contexts.splice(-1),this.currentContextIds.shift()}nextIteration(){if(!(this.contexts&&this.contexts.length>0))throw new Error("Cannot increase frame iteration, the context is empty");{this.contexts=this.contexts.slice(),this.lastId++;const t=Object.assign({},this.contexts[this.contexts.length-1]);t.iterationId+=1,t.id=this.lastId,this.contexts.splice(-1,1,t),this._currentContextIds.splice(0,1,this.contextIdforContexts(this.contexts))}}getWeight(t){return this.weightMap[t]}addTensorArray(t){this.tensorArrayMap[t.id]=t}getTensorArray(t){return this.tensorArrayMap[t]}addTensorList(t){this.tensorListMap[t.id]=t}getTensorList(t){return this.tensorListMap[t]}dispose(t){for(const e in this.tensorArrayMap)this.tensorArrayMap[e].clearAndClose(t);for(const e in this.tensorListMap)this.tensorListMap[e].clearAndClose(t)}}function fz(n,t,e,r){const s=new Set,i=[];let o=null,a=null;const u=new Set,c=new Set(Object.keys(n).map(y=>Ei(y)[0]));r=r||[];const p=new Set(r.map(y=>Ei(y.name)[0])),m=[...t];for(;m.length>0;){const y=m.pop();if((Pc(y)||Lme(y)||Vme(y))&&null==o&&(o=y,a=o.children.map(_=>_.name).filter(_=>s.has(_))),s.add(y.name),null==e[y.name]&&!c.has(y.name)&&!p.has(y.name)){if(0===y.inputs.length){i.push(y.name);continue}y.inputs.forEach(_=>{u.has(_.name)||(u.add(_.name),m.push(_))})}}return{inputs:n,outputs:t,usedNodes:s,missingInputs:i,dynamicNode:o,syncInputs:a}}class S0 extends Error{constructor(t){super(`NodesExecutionOrderError: ${t}`)}}const Pme=new Set(["Switch","Merge","Enter","Exit","NextIteration","StatelessIf","StatelessWhile","if","While"]),Fme=new Set(["NonMaxSuppressionV2","NonMaxSuppressionV3","NonMaxSuppressionV5","Where"]),$me=new Set(["HashTable","HashTableV2","LookupTableImport","LookupTableImportV2","LookupTableFind","LookupTableFindV2","LookupTableSize","LookupTableSizeV2"]);function Pc(n){return Pme.has(n.op)}function Lme(n){return Fme.has(n.op)}function Vme(n){return $me.has(n.op)}class C0{get weightIds(){return this.parent?this.parent.weightIds:this._weightIds}get functionExecutorMap(){return this.parent?this.parent.functionExecutorMap:this._functionExecutorMap}get weightMap(){return this.parent?this.parent.weightMap:this._weightMap}set weightMap(t){const e=Object.keys(t).map(r=>t[r].map(s=>s.id));this._weightIds=[].concat(...e),this._weightMap=t}set resourceManager(t){this._resourceManager=t}get inputs(){return this._inputs.map(t=>({name:t.name,shape:t.attrParams.shape?t.attrParams.shape.value:void 0,dtype:t.attrParams.dtype?t.attrParams.dtype.value:void 0}))}get outputs(){return this._outputs.map(t=>({name:t.name,shape:t.attrParams.shape?t.attrParams.shape.value:void 0,dtype:t.attrParams.dtype?t.attrParams.dtype.value:void 0}))}get inputNodes(){return this._inputs.map(t=>t.signatureKey||t.name)}get outputNodes(){return this._outputs.map(t=>{const e=t.signatureKey||t.name;return t.defaultOutput?`${e}:${t.defaultOutput}`:e})}get functions(){return Object.keys(this._functions).reduce((t,e)=>(t[e]=this._functions[e].signature,t),{})}constructor(t,e){this.graph=t,this.parent=e,this.compiledMap=new Map,this.parseNodeNameCache=new Map,this._weightMap={},this.SEPARATOR=",",this._functions={},this._functionExecutorMap={},this.keepIntermediateTensors=!1,this._outputs=t.outputs,this._inputs=t.inputs,this._initNodes=t.initNodes,this._signature=t.signature,this._functions=t.functions,null!=t.functions&&Object.keys(t.functions).forEach(r=>{this._functionExecutorMap[r]=new C0(t.functions[r],this)})}getCompilationKey(t,e){const r=t.map(i=>i.name).sort(),s=e.map(i=>i.name).sort();return r.join(this.SEPARATOR)+"--"+s.join(this.SEPARATOR)}compile(t,e){const r=fz(t,e,this.weightMap,this._initNodes),{missingInputs:s,dynamicNode:i,syncInputs:o}=r;if(null!=i)throw new Error(`This execution contains the node '${i.name}', which has the dynamic op '${i.op}'. Please use model.executeAsync() instead. Alternatively, to avoid the dynamic ops, specify the inputs [${o}]`);if(s.length>0){const c=e.map(m=>m.name),p=Object.keys(t);throw new Error(`Cannot compute the outputs [${c}] from the provided inputs [${p}]. Missing the following inputs: [${s}]`)}const a=function Nme(n,t){const{usedNodes:e,inputs:r}=t,o=I=>e.has("string"==typeof I?I:I.name);function a(I){return[...new Map(I.map(O=>[O.name,O])).values()]}const u=a([...Object.keys(r).map(I=>Ei(I)[0]).map(I=>n.nodes[I]),...n.weights,...n.initNodes||[]]).filter(o),c=a([...u,...Object.values(n.nodes)]).filter(o),p=new Map(c.map(I=>[I.name,I])),m={};for(const I of c){m[I.name]=m[I.name]||0;for(const O of I.children)o(O)||(m[O.name]=Number.POSITIVE_INFINITY),m[O.name]=(m[O.name]||0)+1}const y=Object.entries(m).filter(([,I])=>0===I).map(([I])=>I),_=[...y];for(;y.length>0;){const I=y.pop(),O=p.get(I);for(const M of O.children.filter(o))0==--m[M.name]&&(_.push(M.name),y.push(M.name))}const T=function Ome(n,t){const e=new Map(n.map(o=>[o.name,o])),r=t.map(o=>o.name),s=new Set(r);for(;r.length>0;){const o=r.pop(),a=e.get(o);for(const u of a.children)!e.has(u.name)||s.has(u.name)||(s.add(u.name),r.push(u.name))}return n.filter(o=>s.has(o.name))}(_.map(I=>p.get(I)),u);return function Rme(n,t){const e=new Map(n.map((a,u)=>[a.name,u])),r=new Set(t.map(a=>a.name)),s=a=>r.has("string"==typeof a?a:a.name),i=new Set(n.map(a=>a.name)),o=a=>i.has("string"==typeof a?a:a.name);for(const a of n){for(const u of a.children.filter(o)){if(!e.has(u.name))throw new S0(`Child ${u.name} of node ${a.name} is unreachable.`);if(e.get(a.name)>e.get(u.name))throw new S0(`Node ${a.name} is scheduled to run after its child ${u.name}.`)}if(!s(a))for(const u of a.inputs){if(!e.has(u.name))throw new S0(`Input ${u.name} of node ${a.name} is unreachable.`);if(e.get(u.name)>e.get(a.name))throw new S0(`Node ${a.name} is scheduled to run before its input ${u.name}.`)}}}(T,u),T}(this.graph,r),u=function Mme(n){const t=new Map(n.map((a,u)=>[a.name,u])),e=Number.MAX_SAFE_INTEGER,r=n.map((a,u)=>Pc(a)?e:u),s=a=>r[t.get(a.name)]??-1,i=n.map((a,u)=>a.children.map(s).reduce((c,p)=>Math.max(c,p),r[u])),o=new Map;for(let a=0;a<n.length;++a){const u=i[a];if(u===e)continue;const c=n[a],p=n[u];o.has(p.name)||o.set(p.name,[]),o.get(p.name).push(c)}return o}(a);return{orderedNodes:a,nodeLiveUntilMap:u}}cloneAndKeepTensor(t){if(null==t)return null;const e=t.clone();return as(e),e}cloneTensorList(t){return t?t.map(r=>this.cloneAndKeepTensor(r)):null}cloneTensorMap(t){return Object.fromEntries(Object.entries(t).map(([e,r])=>[e,this.cloneTensorList(r)]))}execute(t,e){this.disposeIntermediateTensors(),t=this.mapInputs(t);const r=Object.keys(t).sort();this.checkInputs(t),this.checkInputShapeAndType(t),e=this.mapOutputs(e),this.checkOutputs(e);const s=r.map(y=>this.graph.nodes[Ei(y)[0]]),i=e.map(y=>Ei(y)[0]),o=new Set(i);let a=i.map(y=>this.graph.nodes[y]);0===a.length&&(a=this._outputs);const u=this.getCompilationKey(s,a);let c=this.compiledMap.get(u);null==c&&(c=this.compile(t,a),this.compiledMap.set(u,c));try{this.keepIntermediateTensors=De().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(y){this.keepIntermediateTensors=!1,console.warn(y.message)}const p={},m={};return Ce(()=>{const y=new pz(this.weightMap,p,m,this.functionExecutorMap,this.parseNodeNameCache),_=Object.assign({},this.weightMap);this.keepIntermediateTensors&&(this.clonedTensorsMap=this.cloneTensorMap(this.weightMap)),Object.keys(t).forEach(O=>{const[M,V]=Ei(O,y),z=[];z[V]=t[O],_[M]=z,this.keepIntermediateTensors&&(this.clonedTensorsMap[M]=this.cloneTensorList(z))});const w=this.getFrozenTensorIds(_),{orderedNodes:T,nodeLiveUntilMap:I}=c;for(const O of T){if(_[O.name])continue;const M=hz(O,_,y,this._resourceManager);if(mc(M))throw new Error(`The execution of the op '${O.op}' returned a promise. Please use model.executeAsync() instead.`);_[O.name]=M,this.keepIntermediateTensors&&(this.clonedTensorsMap[O.name]=this.cloneTensorList(M)),this.checkTensorForDisposalWithNodeLiveUntilInfo(O,_,y,w,o,I.get(O.name))}return null==this.parent&&y.dispose(w),e.map(O=>xs(O,_,y))})}getFrozenTensorIds(t){const e=[].concat.apply([],Object.keys(t).map(r=>t[r]).map(r=>r.map(s=>s.id)));return new Set(e)}checkTensorForDisposal(t,e,r,s,i,o,a){if(!Pc(e)&&!o.has(t)){for(const u of r[t])null!=u&&(a[u.id]=(a[u.id]||0)+e.children.length);for(const u of e.inputs){if(Pc(u))continue;const c=iz(u.name,r,s);if(null!=c)for(const p of c){if(!p||p.kept||i.has(p.id))continue;const m=a[p.id];1===m?(p.dispose(),delete a[p.id]):null!=m&&a[p.id]--}}}}checkTensorForDisposalWithNodeLiveUntilInfo(t,e,r,s,i,o){function a(u){return Pc(u)||i.has(u.name)}if(!Pc(t)&&null!=o)for(const u of o){if(a(u))continue;const c=iz(u.name,e,r);for(const p of c)!p||p.kept||s.has(p.id)||p.dispose()}}executeAsync(t,e){var r=this;return Ve(function*(){return r._executeAsync(t,e)})()}disposeIntermediateTensors(){this.clonedTensorsMap&&(Object.values(this.clonedTensorsMap).forEach(t=>{for(const e of t)e&&!e.isDisposed&&e.dispose()}),this.clonedTensorsMap=null)}getIntermediateTensors(){return this.clonedTensorsMap}_executeAsync(t,e,r=!1,s={},i={}){var o=this;return Ve(function*(){o.disposeIntermediateTensors(),r||(t=o.mapInputs(t),o.checkInputs(t),o.checkInputShapeAndType(t),e=o.mapOutputs(e),o.checkOutputs(e));try{o.keepIntermediateTensors=De().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(_){o.keepIntermediateTensors=!1,console.warn(_.message)}const a=new pz(o.weightMap,s,i,o.functionExecutorMap,o.parseNodeNameCache);o.keepIntermediateTensors&&(o.clonedTensorsMap=o.cloneTensorMap(o.weightMap));const u=yield o.executeWithControlFlow(t,a,e,r),c=e.map(_=>xs(_,u,a)),p=c.map(_=>_.id),m=Object.keys(t).map(_=>t[_].id),y=new Set([...p,...m,...o.weightIds]);return Object.values(u).forEach(_=>{_.forEach(w=>{w&&!w.isDisposed&&!y.has(w.id)&&w.dispose()})}),null==o.parent&&a.dispose(y),c})()}executeFunctionAsync(t,e,r){var s=this;return Ve(function*(){const i=t.reduce((o,a,u)=>(o[s.inputs[u].name]=a,o),{});return s._executeAsync(i,s.outputNodes,!0,e,r)})()}executeWithControlFlow(t,e,r,s){var i=this;return Ve(function*(){const o=Object.keys(t),a=o.map(G=>i.graph.nodes[Ei(G)[0]]),u=r.map(G=>Ei(G)[0]),c=new Set(u);let p=u.map(G=>i.graph.nodes[G]);0===p.length&&(p=i._outputs);const{usedNodes:m,missingInputs:y,dynamicNode:_,syncInputs:w}=fz(t,p,i.weightMap,i._initNodes),T=[...a,...i.graph.weights,...i._initNodes||[]].map(G=>({node:G,contexts:e.currentContext})),I=Object.assign({},i.weightMap);Object.keys(t).forEach(G=>{const[Q,ne]=Ei(G),oe=[];oe[ne]=t[G],I[Q]=oe});const O={},M=i.getFrozenTensorIds(I),V={};for(;T.length>0;){const G=i.processStack(a,T,e,I,V,M,c,O,m);yield Promise.all(G)}null==_&&!s&&console.warn("This model execution did not contain any nodes with control flow or dynamic output shapes. You can use model.execute() instead.");const z=p.filter(G=>!Pc(G)&&!xs(G.name,I,e)).map(G=>G.name);if(z.length>0){let G="";throw null!=_&&(G=`Alternatively, to avoid the dynamic ops, use model.execute() and specify the inputs [${w}]`),new Error(`Cannot compute the outputs [${z}] from the provided inputs [${o}]. Consider providing the following inputs: [${y}]. ${G}`)}return I})()}processStack(t,e,r,s,i,o,a,u,c){const p=[];for(;e.length>0;){const m=e.pop();r.currentContext=m.contexts;let y="";if("Enter"===m.node.op&&j("isConstant",m.node,s,r)&&([y]=vl(m.node.name,r)),null==s[m.node.name]){const _=hz(m.node,s,r,this._resourceManager);y||([y]=vl(m.node.name,r));const w=r.currentContext;mc(_)?p.push(_.then(T=>(s[y]=T,this.keepIntermediateTensors&&(this.clonedTensorsMap[y]=this.cloneTensorList(T)),r.currentContext=w,this.checkTensorForDisposal(y,m.node,s,r,o,a,u),this.processChildNodes(m.node,e,r,s,i,c),T))):(s[y]=_,this.keepIntermediateTensors&&(this.clonedTensorsMap[y]=this.cloneTensorList(_)),this.checkTensorForDisposal(y,m.node,s,r,o,a,u),this.processChildNodes(m.node,e,r,s,i,c))}else this.processChildNodes(m.node,e,r,s,i,c)}return p}processChildNodes(t,e,r,s,i,o){t.children.forEach(a=>{const[u]=vl(a.name,r);i[u]||!o.has(a.name)||("Merge"===a.op?a.inputNames.some(c=>!!xs(c,s,r))&&(i[u]=!0,e.push({contexts:r.currentContext,node:a})):a.inputNames.every(c=>!!xs(c,s,r))&&(i[u]=!0,e.push({contexts:r.currentContext,node:a})))})}dispose(){Object.keys(this.weightMap).forEach(t=>this.weightMap[t].forEach(e=>e.dispose()))}checkInputShapeAndType(t){Object.keys(t).forEach(e=>{const r=t[e],[s]=Ei(e),i=this.graph.nodes[s];if(i.attrParams.shape&&i.attrParams.shape.value){const o=i.attrParams.shape.value;J(o.length===r.shape.length&&r.shape.every((u,c)=>-1===o[c]||o[c]===u),()=>`The shape of dict['${i.name}'] provided in model.execute(dict) must be [${o}], but was [${r.shape}]`)}i.attrParams.dtype&&i.attrParams.dtype.value&&J(r.dtype===i.attrParams.dtype.value,()=>`The dtype of dict['${i.name}'] provided in model.execute(dict) must be ${i.attrParams.dtype.value}, but was ${r.dtype}`)})}mapInputs(t){var e,r;const s={};for(const i in t){const o=null===(r=null===(e=this._signature)||void 0===e?void 0:e.inputs)||void 0===r?void 0:r[i];null!=o?s[o.name]=t[i]:s[i]=t[i]}return s}checkInputs(t){const e=Object.keys(t).filter(r=>{const[s]=Ei(r);return null==this.graph.nodes[s]});if(e.length>0)throw new Error(`The dict provided in model.execute(dict) has keys: [${e}] that are not part of graph`)}mapOutputs(t){return t.map(e=>{var r,s;const i=null===(s=null===(r=this._signature)||void 0===r?void 0:r.outputs)||void 0===s?void 0:s[e];return null!=i?i.name:e},{})}checkOutputs(t){t.forEach(e=>{const[r]=Ei(e);if(!this.graph.nodes[r])throw new Error(`The output '${e}' is not found in the graph`)})}}class Bme{constructor(t={},e={}){this.hashTableNameToHandle=t,this.hashTableMap=e}addHashTable(t,e){this.hashTableNameToHandle[t]=e.handle,this.hashTableMap[e.id]=e}getHashTableHandleByName(t){return this.hashTableNameToHandle[t]}getHashTableById(t){return this.hashTableMap[t]}dispose(){for(const t in this.hashTableMap)this.hashTableMap[t].clearAndClose(),delete this.hashTableMap[t];for(const t in this.hashTableNameToHandle)this.hashTableNameToHandle[t].dispose(),delete this.hashTableNameToHandle[t]}}const zme="?tfjs-format=file",Ume="model.json";class mz{get modelVersion(){return this.version}get inputNodes(){return this.executor.inputNodes}get outputNodes(){return this.executor.outputNodes}get inputs(){return this.executor.inputs}get outputs(){return this.executor.outputs}get weights(){return this.executor.weightMap}get metadata(){return this.artifacts.userDefinedMetadata}get modelSignature(){return this.signature}get modelStructuredOutputKeys(){return this.structuredOutputKeys}constructor(t,e={},r=F){this.modelUrl=t,this.loadOptions=e,this.version="n/a",this.io=r,null==e&&(this.loadOptions={}),this.resourceManager=new Bme}findIOHandler(){const t=this.modelUrl;if(null!=t.load)this.handler=t;else if(null!=this.loadOptions.requestInit)this.handler=this.io.browserHTTPRequest(t,this.loadOptions);else{const e=this.io.getLoadHandlers(t,this.loadOptions);if(0===e.length)e.push(this.io.browserHTTPRequest(t,this.loadOptions));else if(e.length>1)throw new Error(`Found more than one (${e.length}) load handlers for URL '${[t]}'`);this.handler=e[0]}}load(){if(this.findIOHandler(),null==this.handler.load)throw new Error("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");const t=this.handler.load();return mc(t)?t.then(e=>this.loadSync(e)):this.loadSync(t)}loadSync(t){this.artifacts=t;const e=this.artifacts.modelTopology;let r=this.artifacts.signature;if(null!=this.artifacts.userDefinedMetadata){const i=this.artifacts.userDefinedMetadata;null!=i.signature&&(r=i.signature),null!=i.structuredOutputKeys&&(this.structuredOutputKeys=i.structuredOutputKeys)}this.signature=r,this.version=`${e.versions.producer}.${e.versions.minConsumer}`;const s=this.io.decodeWeights(this.artifacts.weightData,this.artifacts.weightSpecs);if(this.executor=new C0(oz.Instance.transformGraph(e,this.signature)),this.executor.weightMap=this.convertTensorMapToTensorsMap(s),this.executor.resourceManager=this.resourceManager,null!=t.modelInitializer&&null!=t.modelInitializer.node){const i=oz.Instance.transformGraph(t.modelInitializer);this.initializer=new C0(i),this.initializer.weightMap=this.executor.weightMap,this.initializer.resourceManager=this.resourceManager,this.initializerSignature=t.initializerSignature}return!0}save(t,e){var r=this;return Ve(function*(){if("string"==typeof t){const s=r.io.getSaveHandlers(t);if(0===s.length)throw new Error(`Cannot find any save handlers for URL '${t}'`);if(s.length>1)throw new Error(`Found more than one (${s.length}) save handlers for URL '${t}'`);t=s[0]}if(null==t.save)throw new Error("GraphModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");return t.save(r.artifacts)})()}addStructuredOutputNames(t){if(this.structuredOutputKeys){const r={};return(t instanceof nr?[t]:t).forEach((s,i)=>r[this.structuredOutputKeys[i]]=s),r}return t}predict(t,e){const r=this.execute(t,this.outputNodes);return this.addStructuredOutputNames(r)}predictAsync(t,e){var r=this;return Ve(function*(){const s=yield r.executeAsync(t,r.outputNodes);return r.addStructuredOutputNames(s)})()}normalizeInputs(t){var e;if(!(t instanceof nr||Array.isArray(t))){const i=null===(e=this.signature)||void 0===e?void 0:e.inputs;if(null!=i)for(const o in i){const a=i[o];null!=a.resourceId&&(t[o]=this.resourceIdToCapturedInput[a.resourceId])}return t}t=Array.isArray(t)?t:[t];const r=Object.keys(this.resourceIdToCapturedInput).length;if(t.length+r!==this.inputNodes.length)throw new Error(`Input tensor count mismatch, the graph model has ${this.inputNodes.length-r} non-resource placeholders, while there are ${t.length} input tensors provided.`);let s=0;return this.inputNodes.reduce((i,o)=>{var a,u,c;const p=null===(c=null===(u=null===(a=this.signature)||void 0===a?void 0:a.inputs)||void 0===u?void 0:u[o])||void 0===c?void 0:c.resourceId;return i[o]=null!=p?this.resourceIdToCapturedInput[p]:t[s++],i},{})}normalizeOutputs(t){return t=t||this.outputNodes,Array.isArray(t)?t:[t]}executeInitializerGraph(){return null==this.initializer?[]:this.initializer.execute({},null==this.initializerSignature?[]:Object.keys(this.initializerSignature.outputs))}executeInitializerGraphAsync(){var t=this;return Ve(function*(){return null==t.initializer?[]:t.initializer.executeAsync({},null==t.initializerSignature?[]:Object.keys(t.initializerSignature.outputs))})()}setResourceIdToCapturedInput(t){if(this.resourceIdToCapturedInput={},this.initializerSignature){const e=this.initializerSignature.outputs,r=Object.keys(e);for(let s=0;s<r.length;s++)this.resourceIdToCapturedInput[e[r[s]].resourceId]=t[s]}}execute(t,e){null==this.resourceIdToCapturedInput&&this.setResourceIdToCapturedInput(this.executeInitializerGraph()),t=this.normalizeInputs(t),e=this.normalizeOutputs(e);const r=this.executor.execute(t,e);return r.length>1?r:r[0]}executeAsync(t,e){var r=this;return Ve(function*(){null==r.resourceIdToCapturedInput&&r.setResourceIdToCapturedInput(yield r.executeInitializerGraphAsync()),t=r.normalizeInputs(t),e=r.normalizeOutputs(e);const s=yield r.executor.executeAsync(t,e);return s.length>1?s:s[0]})()}getIntermediateTensors(){return this.executor.getIntermediateTensors()}disposeIntermediateTensors(){this.executor.disposeIntermediateTensors()}convertTensorMapToTensorsMap(t){return Object.keys(t).reduce((e,r)=>(e[r]=[t[r]],e),{})}dispose(){this.executor.dispose(),this.initializer&&(this.initializer.dispose(),this.resourceIdToCapturedInput&&on(this.resourceIdToCapturedInput)),this.resourceManager.dispose()}}function oA(n){return aA.apply(this,arguments)}function aA(){return(aA=Ve(function*(n,t={},e=F){if(null==n)throw new Error("modelUrl in loadGraphModel() cannot be null. Please provide a url or an IOHandler that loads the model");null==t&&(t={}),t.fromTFHub&&"string"==typeof n&&(n=function jme(n){return n.endsWith("/")||(n+="/"),`${n}${Ume}${zme}`}(n));const r=new mz(n,t,e);return yield r.load(),r})).apply(this,arguments)}function St(n,t){Array.isArray(n)||(n=[n]),n.forEach(e=>{null!=e&&J("complex64"!==e.dtype,()=>`${t} does not support complex64 tensors in the CPU backend.`)})}Symbol("out"),Symbol("field"),Symbol("quote"),Symbol("quoteafterquote"),Symbol("quoteinquote");const yge=xE;let bge=(()=>{class n extends j1{nextDataId(){return n.nextDataId++}constructor(){super(),this.blockSize=48,this.firstUse=!0,this.data=new CL(this,Da())}write(e,r,s){this.firstUse&&(this.firstUse=!1,De().get("IS_NODE")&&Ui("\n============================\nHi, looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, visit https://github.com/tensorflow/tfjs-node for more details. \n============================"));const i={id:this.nextDataId()};return this.data.set(i,{values:e,dtype:s,refCount:1}),i}makeTensorInfo(e,r,s){let i;if("string"===r&&null!=s&&s.length>0&&Uf(s[0])){const o=s.map(a=>Ql(a));i=this.write(o,e,r)}else i=this.write(s,e,r);return{dataId:i,shape:e,dtype:r}}refCount(e){return this.data.has(e)?this.data.get(e).refCount:0}incRef(e){this.data.get(e).refCount++}decRef(e){this.data.has(e)&&this.data.get(e).refCount--}move(e,r,s,i,o){this.data.set(e,{values:r,dtype:i,refCount:o})}numDataIds(){return this.data.numDataIds()}read(e){var r=this;return Ve(function*(){return r.readSync(e)})()}readSync(e){const{dtype:r,complexTensorInfos:s}=this.data.get(e);return"complex64"===r?gl(this.readSync(s.real.dataId),this.readSync(s.imag.dataId)):function Lne(n,t){if(Array.isArray(n))return n;if("float32"===t)return n instanceof Float32Array?n:new Float32Array(n);if("int32"===t)return n instanceof Int32Array?n:new Int32Array(n);if("bool"===t||"string"===t)return Uint8Array.from(new Int32Array(n));throw new Error(`Unknown dtype ${t}`)}(this.data.get(e).values,r)}bufferSync(e){const r=this.readSync(e.dataId);if("string"===e.dtype)try{const s=r.map(i=>Jl(i));return tn(e.shape,e.dtype,s)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return tn(e.shape,e.dtype,r)}makeOutput(e,r,s){return Da().makeTensorFromTensorInfo(this.makeTensorInfo(r,s,e),this)}disposeData(e,r=!1){if(this.data.has(e)){if(this.data.get(e).refCount--,!r&&this.data.get(e).refCount>0)return!1;const{complexTensorInfos:s}=this.data.get(e);null!=s&&(this.disposeData(s.real.dataId,!0),this.disposeData(s.imag.dataId,!0)),this.data.delete(e)}return!0}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}time(e){return Ve(function*(){const r=ri();return e(),{kernelMs:ri()-r}})()}memory(){return{unreliable:!0,reasons:["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."]}}where(e){St([e],"where");const r=this.readSync(e.dataId);return yge(e.shape,r)}dispose(){}floatPrecision(){return 32}epsilon(){return super.epsilon()}}return n.nextDataId=0,n})();function Ba(n){return(t,e,r)=>{const s=Ar(e,t.length);for(let i=0;i<t.length;++i)s[i]=n(t[i],r);return s}}function Rn(n,t,e){return Su(n,Ba(t),e)}function Su(n,t,e){return({inputs:r,attrs:s,backend:i})=>{const{x:o}=r;St(o,n);const a=i,u=a.data.get(o.dataId).values;let c;if("string"===o.dtype){if(!Array.isArray(u))throw new Error("String tensor's value was not an instance of Array");c=yl(u)}else c=u;const p=e||o.dtype,m=t(c,p,s);return a.makeTensorInfo(o.shape,p,m)}}b3("cpu",()=>new bge,1);const Iz=Rn(nm,n=>n>=0?n:Math.exp(n)-1),vge={kernelName:nm,backendName:"cpu",kernelFunc:Iz};function za(n){const{inputs:t,backend:e}=n,{x:r}=t;return e.incRef(r.dataId),{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}const wge={kernelName:um,backendName:"cpu",kernelFunc:za};function Ez(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{alpha:i}=r;St([s],"leakyRelu");const o=Fe(s.shape),a=e.data.get(s.dataId).values,u=_s("float32",o);for(let c=0;c<a.length;c++)u[c]=a[c]<0?i*a[c]:a[c];return e.makeTensorInfo(s.shape,"float32",u)}const xge={kernelName:A_,backendName:"cpu",kernelFunc:Ez};function Rr(n){return(t,e,r,s,i)=>{const o=Ht(t,e),a=o.length,u=Nt(o),p=_s(i,Fe(o)),m=t.length,y=e.length,_=Nt(t),w=Nt(e),T=wh(t,o),I=wh(e,o);if(T.length+I.length===0)for(let O=0;O<p.length;++O)p[O]=n(r[O%r.length],s[O%s.length]);else for(let O=0;O<p.length;++O){const M=ch(O,a,u),V=M.slice(-m);T.forEach(ne=>V[ne]=0);const z=Ia(V,m,_),G=M.slice(-y);I.forEach(ne=>G[ne]=0);const Q=Ia(G,y,w);p[O]=n(r[z],s[Q])}return[p,o]}}const Tge=Rr((n,t)=>n<0?t*n:n);function Dz(n){const{inputs:t,backend:e}=n,{x:r,alpha:s}=t;St([r,s],"prelu");const i=e.data.get(r.dataId).values,o=e.data.get(s.dataId).values,[a,u]=Tge(r.shape,s.shape,i,o,"float32");return e.makeTensorInfo(u,"float32",a)}const Sge={kernelName:K_,backendName:"cpu",kernelFunc:Dz},Az=Rn(wm,n=>Math.max(0,n)),Cge={kernelName:wm,backendName:"cpu",kernelFunc:Az},kz=Rn(xm,n=>Math.min(Math.max(0,n),6)),Ige={kernelName:xm,backendName:"cpu",kernelFunc:kz},Ege=Ba(n=>1/(1+Math.exp(-n))),Nz=Rn(Am,n=>1/(1+Math.exp(-n))),Dge={kernelName:Am,backendName:"cpu",kernelFunc:Nz};function A0(n,t,e,r,s){if("linear"===e)return za({inputs:{x:t},backend:n});if("relu"===e)return Az({inputs:{x:t},backend:n});if("elu"===e)return Iz({inputs:{x:t},backend:n});if("relu6"===e)return kz({inputs:{x:t},backend:n});if("prelu"===e)return Dz({inputs:{x:t,alpha:r},backend:n});if("leakyrelu"===e)return Ez({inputs:{x:t},backend:n,attrs:{alpha:s}});if("sigmoid"===e)return Nz({inputs:{x:t},backend:n});throw new Error(`Activation ${e} has not been implemented for the CPU backend.`)}function Di(n){const{inputs:t,backend:e}=n,{real:r,imag:s}=t,i=e.data.get(r.dataId).values,o=e.data.get(s.dataId).values,a=e.makeTensorInfo(r.shape,"complex64");return e.data.get(a.dataId).complexTensorInfos={real:e.makeTensorInfo(r.shape,"float32",i),imag:e.makeTensorInfo(s.shape,"float32",o)},a}const Age={kernelName:iC,backendName:"cpu",kernelFunc:Di};function k0(n,t,e="float32"){if("complex64"===e)return Di({inputs:{real:k0(n,t,"float32"),imag:k0(n,t,"float32")},backend:n});const r=ks(Fe(t),e);return n.makeTensorInfo(t,e,r)}function Fc(n){const{inputs:t,backend:e}=n,{input:r}=t,s=e.data.get(r.dataId).complexTensorInfos.real,i=e.data.get(s.dataId).values;return e.makeTensorInfo(s.shape,s.dtype,i)}const kge={kernelName:VC,backendName:"cpu",kernelFunc:Fc};function Oz(n,t,e,r){if("int32"===r)return[t,"int32",Int32Array.from(n)];if("bool"===r){const s=bc([0],e),[i,o]=Rr((a,u)=>a!==u?1:0)(t,[],n,s,"bool");return[o,"bool",i]}throw new Error(`Error in Cast: failed to cast ${e} to ${r}`)}function Cu(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{dtype:i}=r;if("complex64"===i){if("complex64"===s.dtype)return za({inputs:{x:s},backend:e});const p=k0(e,s.shape,s.dtype),m=Cu({inputs:{x:s},backend:e,attrs:{dtype:"float32"}}),y=Di({inputs:{real:m,imag:p},backend:e});return e.disposeIntermediateTensorInfo(p),e.disposeIntermediateTensorInfo(m),y}if("complex64"===s.dtype){const p=Fc({inputs:{input:s},backend:e}),m=Cu({inputs:{x:p},backend:e,attrs:{dtype:i}});return e.disposeIntermediateTensorInfo(p),m}if(!AL(s.dtype,i)){const p=za({inputs:{x:s},backend:e});return{dataId:p.dataId,shape:p.shape,dtype:i}}const o=e.data.get(s.dataId).values,[a,u,c]=Oz(o,s.shape,s.dtype,i);return e.makeTensorInfo(a,u,c)}const Nge={kernelName:Yf,backendName:"cpu",kernelFunc:Cu};function ts(n,t,e,r){return null==e?({inputs:s,backend:i})=>{const{a:o,b:a}=s,u=i;St([o,a],n);const c=u.data.get(o.dataId).values,p=u.data.get(a.dataId).values,m="string"===o.dtype?yl(c):c,y="string"===o.dtype?yl(p):p,_=r||o.dtype,[w,T]=t(o.shape,a.shape,m,y,_);return u.makeTensorInfo(T,_,w)}:({inputs:s,backend:i})=>{const{a:o,b:a}=s,u=i;if("complex64"===o.dtype||"complex64"===a.dtype){const c=Cu({inputs:{x:o},backend:u,attrs:{dtype:"complex64"}}),p=u.data.get(c.dataId),y=p.complexTensorInfos.imag,_=u.data.get(p.complexTensorInfos.real.dataId).values,w=u.data.get(y.dataId).values,T=Cu({inputs:{x:a},backend:u,attrs:{dtype:"complex64"}}),I=u.data.get(T.dataId),M=I.complexTensorInfos.imag,V=u.data.get(I.complexTensorInfos.real.dataId).values,z=u.data.get(M.dataId).values,[G,Q,ne]=e(o.shape,a.shape,_,w,V,z),oe=u.makeTensorInfo(ne,"float32",G),de=u.makeTensorInfo(ne,"float32",Q),pe=Di({inputs:{real:oe,imag:de},backend:u});return u.disposeIntermediateTensorInfo(c),u.disposeIntermediateTensorInfo(T),u.disposeIntermediateTensorInfo(oe),u.disposeIntermediateTensorInfo(de),pe}{const c=u.data.get(o.dataId).values,p=u.data.get(a.dataId).values,m=r||o.dtype,[y,_]=t(o.shape,a.shape,c,p,m);return u.makeTensorInfo(_,m,y)}}}function fA(n){return(t,e,r,s,i,o)=>{const a=Ht(t,e),u=Fe(a),c=a.length,p=Nt(a),m=_s("float32",u),y=_s("float32",u),_=wh(t,a),w=wh(e,a),T=gl(r,s),I=gl(i,o),O=t.length,M=Nt(t),V=e.length,z=Nt(e);if(_.length+w.length===0)for(let G=0;G<m.length;G++){const Q=G%T.length,ne=G%I.length,oe=n(T[2*Q],T[2*Q+1],I[2*ne],I[2*ne+1]);m[G]=oe.real,y[G]=oe.imag}else for(let G=0;G<m.length;G++){const Q=ch(G,c,p),ne=Q.slice(-O);_.forEach(Ae=>ne[Ae]=0);const oe=Ia(ne,O,M),de=Q.slice(-V);w.forEach(Ae=>de[Ae]=0);const pe=Ia(de,V,z),Te=n(T[2*oe],T[2*oe+1],I[2*pe],I[2*pe+1]);m[G]=Te.real,y[G]=Te.imag}return[m,y,a]}}const Rz=Rr((n,t)=>n+t),Oge=fA((n,t,e,r)=>({real:n+e,imag:t+r})),Vh=ts(dh,Rz,Oge),Rge={kernelName:dh,backendName:"cpu",kernelFunc:Vh};function Hn(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{shape:i}=r,o=Fe(s.shape),a=DL(i,o),u=Fe(a);J(o===u,()=>`The new shape (${a}) has ${u} elements and the old shape (${s.shape}) has ${o} elements. The new shape and old shape must have the same number of elements.`),e.incRef(s.dataId);const c=e.data.get(s.dataId);if(null!=c.complexTensorInfos){const m=c.complexTensorInfos.imag;c.complexTensorInfos.real.shape=a,m.shape=a}return{dataId:s.dataId,shape:a,dtype:s.dtype}}const Mge={kernelName:Y_,backendName:"cpu",kernelFunc:Hn};function Mz(n){const{inputs:t,backend:e,attrs:r}=n,{a:s,b:i}=t,{transposeA:o,transposeB:a}=r;St([s,i],"matMul");const u=s.shape.length,c=i.shape.length,p=o?s.shape[u-2]:s.shape[u-1],m=a?i.shape[c-1]:i.shape[c-2],y=o?s.shape[u-1]:s.shape[u-2],_=a?i.shape[c-2]:i.shape[c-1],w=s.shape.slice(0,-2),T=i.shape.slice(0,-2),I=Fe(w),O=Fe(T),V=Ht(s.shape.slice(0,-2),i.shape.slice(0,-2)).concat([y,_]);J(p===m,()=>`Error in matMul: inner shapes (${p}) and (${m}) of Tensors with shapes ${s.shape} and ${i.shape} and transposeA=${o} and transposeB=${a} must match.`);const G=a?[O,_,m]:[O,m,_],Q=Hn({inputs:{x:s},backend:e,attrs:{shape:o?[I,p,y]:[I,y,p]}}),ne=Hn({inputs:{x:i},backend:e,attrs:{shape:G}}),oe=o?Q.shape[1]:Q.shape[2],de=o?Q.shape[2]:Q.shape[1],pe=a?ne.shape[1]:ne.shape[2],Te=Math.max(I,O),Ae=e.data.get(Q.dataId).values,Oe=e.data.get(ne.dataId).values,Me=Nt(Q.shape),Pe=Nt(ne.shape),[ve,Se,xe]=o?[Me[0],1,Me[1]]:[Me[0],Me[1],1],[ke,We,Ke]=a?[1,Pe[1],Pe[0]]:[Pe[1],1,Pe[0]],et=de*pe,Je=tn([Te,de,pe],Q.dtype),tt=Je.values,it=e.blockSize;for(let yt=0;yt<Te;yt++){const ft=yt%I,kt=yt%O;for(let xt=0;xt<de;xt+=it){const jt=Math.min(xt+it,de);for(let qt=0;qt<pe;qt+=it){const Mn=Math.min(qt+it,pe);for(let qn=0;qn<oe;qn+=it){const xr=Math.min(qn+it,oe);for(let Kn=xt;Kn<jt;Kn++)for(let Bn=qt;Bn<Mn;Bn++){let pr=0;for(let ir=qn;ir<xr;ir++)pr+=Ae[ft*ve+Kn*Se+ir*xe]*Oe[ir*ke+Bn*We+kt*Ke];tt[yt*et+(Kn*pe+Bn)]+=pr}}}}}return e.disposeIntermediateTensorInfo(Q),e.disposeIntermediateTensorInfo(ne),e.makeTensorInfo(V,Je.dtype,Je.values)}const Pge={kernelName:f_,backendName:"cpu",kernelFunc:Mz},$ge={kernelName:cv,backendName:"cpu",kernelFunc:function Fge(n){const{inputs:t,backend:e,attrs:r}=n,{a:s,b:i,bias:o,preluActivationWeights:a}=t,{transposeA:u,transposeB:c,activation:p,leakyreluAlpha:m}=r;let y,_,w;const T=[];y=Mz({inputs:{a:s,b:i},attrs:{transposeA:u,transposeB:c},backend:e}),o&&(_=Vh({inputs:{a:y,b:o},backend:e}),T.push(y),y=_),p&&(w=A0(e,y,p,a,m),T.push(y),y=w);for(const O of T)e.disposeIntermediateTensorInfo(O);return y}};function Pz(n){const t=new Float32Array(n.length);for(let e=0;e<n.length;++e)t[e]=Math.abs(n[e]);return t}const Lge={kernelName:l_,backendName:"cpu",kernelFunc:n=>{const{x:t}=n.inputs,e=n.backend;St(t,"abs");let r=new Float32Array(Fe(t.shape));return r=Pz(e.data.get(t.dataId).values),e.makeOutput(r,t.shape,t.dtype)}},Vge=Rn(jf,n=>Math.acos(n)),Bge={kernelName:jf,backendName:"cpu",kernelFunc:Vge},zge=Rn(Gf,n=>Math.acosh(n)),Uge={kernelName:Gf,backendName:"cpu",kernelFunc:zge},Gge={kernelName:u_,backendName:"cpu",kernelFunc:function jge(n){const{inputs:t,backend:e}=n,r=t;St(t,"addN");const s=r.map(a=>e.data.get(a.dataId).values),i=tn(r[0].shape,r[0].dtype),o=i.values;for(let a=0;a<r.length;a++){const u=s[a];for(let c=0;c<o.length;c++)o[c]+=u[c]}return e.makeTensorInfo(i.shape,i.dtype,i.values)}};function mA(n,t,e,r,s){const i=t.length,o=Fe(t),a=Nt(t),u=Nt(s),c=_s(e,Fe(s));for(let p=0;p<o;++p){const m=ch(p,i,a),y=new Array(m.length);for(let w=0;w<y.length;w++)y[w]=m[r[w]];c[Ia(y,i,u)]=n[p]}return c}function ui(n){const{inputs:t,attrs:e,backend:r}=n,{x:s}=t,{perm:i}=e;St(s,"transpose");const a=new Array(s.shape.length);for(let m=0;m<a.length;m++)a[m]=s.shape[i[m]];const c=mA(r.data.get(s.dataId).values,s.shape,s.dtype,i,a);return{dataId:r.write(c,a,s.dtype),shape:a,dtype:s.dtype}}const Wge={kernelName:hh,backendName:"cpu",kernelFunc:ui},qge={kernelName:"All",backendName:"cpu",kernelFunc:function Hge(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{axis:i,keepDims:o}=r;St(s,"all");const a=sn(i,s.shape);let u=a;const c=ur(u,s.shape.length);let p=s;null!=c&&(p=ui({inputs:{x:s},backend:e,attrs:{perm:c}}),u=Nr(u.length,s.shape.length)),ws("all",u,p.shape.length);const[m,y]=us(p.shape,u),_=Fe(y),w=ks(Fe(m),p.dtype),T=e.data.get(p.dataId).values;for(let O=0;O<w.length;++O){const M=O*_;let V=T[M];for(let z=0;z<_;++z)V=V&&T[M+z];w[O]=V}null!=c&&e.disposeIntermediateTensorInfo(p);const I=e.makeTensorInfo(m,p.dtype,w);if(o){const M=Hn({inputs:{x:I},backend:e,attrs:{shape:kr(m,a)}});return e.disposeIntermediateTensorInfo(I),M}return I}},Xge={kernelName:"Any",backendName:"cpu",kernelFunc:function Kge(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{axis:i,keepDims:o}=r;St(s,"any");const a=sn(i,s.shape);let u=a;const c=ur(u,s.shape.length);let p=s;null!=c&&(p=ui({inputs:{x:s},backend:e,attrs:{perm:c}}),u=Nr(u.length,s.shape.length)),ws("any",u,p.shape.length);const[m,y]=us(p.shape,u),_=Fe(y),w=ks(Fe(m),p.dtype),T=e.data.get(p.dataId).values;for(let O=0;O<w.length;++O){const M=O*_;let V=T[M];for(let z=0;z<_;++z)V=V||T[M+z];w[O]=V}null!=c&&e.disposeIntermediateTensorInfo(p);const I=e.makeTensorInfo(m,p.dtype,w);if(o){const M=Hn({inputs:{x:I},backend:e,attrs:{shape:kr(m,a)}});return e.disposeIntermediateTensorInfo(I),M}return I}},Zge={kernelName:c_,backendName:"cpu",kernelFunc:function Yge(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{axis:i}=r;St(s,"argMax");let o=sn(i,s.shape);const a=ur(o,s.shape.length);let u=s;const c=[];null!=a&&(u=ui({inputs:{x:s},backend:e,attrs:{perm:a}}),c.push(u),o=Nr(o.length,u.shape.length)),o=[o[0]],ws("argMax",o,u.shape.length);const[p,m]=us(u.shape,o),_=ks(Fe(p),"int32"),w=Fe(m),T=e.data.get(u.dataId).values;for(let I=0;I<_.length;++I){const O=I*w;let M=T[O],V=0;for(let z=0;z<w;++z){const G=T[O+z];G>M&&(M=G,V=z)}_[I]=V}return c.forEach(I=>e.disposeIntermediateTensorInfo(I)),e.makeTensorInfo(p,"int32",_)}},Jge={kernelName:d_,backendName:"cpu",kernelFunc:function Qge(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{axis:i}=r;St(s,"argMin");let o=sn(i,s.shape);const a=ur(o,s.shape.length);let u=s;const c=[];null!=a&&(u=ui({inputs:{x:s},backend:e,attrs:{perm:a}}),c.push(u),o=Nr(o.length,u.shape.length)),o=[o[0]],ws("argMin",o,u.shape.length);const[p,m]=us(u.shape,o),_=ks(Fe(p),"int32"),w=Fe(m),T=e.data.get(u.dataId).values;for(let I=0;I<_.length;++I){const O=I*w;let M=T[O],V=0;for(let z=0;z<w;++z){const G=T[O+z];G<M&&(M=G,V=z)}_[I]=V}return c.forEach(I=>e.disposeIntermediateTensorInfo(I)),e.makeTensorInfo(p,"int32",_)}},eye=Rn(Wf,n=>Math.asin(n)),tye={kernelName:Wf,backendName:"cpu",kernelFunc:eye},nye=Rn(Hf,n=>Math.asinh(n)),rye={kernelName:Hf,backendName:"cpu",kernelFunc:nye},sye=Rn(qf,n=>Math.atan(n)),iye={kernelName:qf,backendName:"cpu",kernelFunc:sye},oye=Rr((n,t)=>Math.atan2(n,t)),aye=ts(Xf,oye),lye={kernelName:Xf,backendName:"cpu",kernelFunc:aye},uye=Rn(Kf,n=>Math.atanh(n)),cye={kernelName:Kf,backendName:"cpu",kernelFunc:uye};function gA(n,t,e,r,s,i){const o=s.strideHeight,a=s.strideWidth,u=s.dilationHeight,c=s.dilationWidth,p=s.effectiveFilterHeight,m=s.effectiveFilterWidth,y=s.padInfo.top,_=s.padInfo.left,w="max"===i?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,T=tn(s.outShape,e),I=T.values,O=s.outShape[1]*s.outShape[2]*s.outShape[3],M=s.outShape[2]*s.outShape[3],V=s.outShape[3];for(let z=0;z<s.batchSize;++z){const G=z*O,Q=z*r[0];for(let ne=0;ne<s.inChannels;++ne)for(let oe=0;oe<s.outHeight;++oe){const de=oe*o-y,pe=Math.max(0,de),Te=Math.min(s.inHeight,p+de),Ae=G+oe*M;for(let Oe=0;Oe<s.outWidth;++Oe){const Me=Oe*a-_,Pe=Math.max(0,Me),ve=Math.min(s.inWidth,m+Me);let Se=w,xe=0,ke=0;for(let Ke=pe;Ke<Te;Ke+=u){const et=Q+Ke*r[1];for(let Je=Pe;Je<ve;Je+=c){const it=n[et+Je*r[2]+ne];"max"===i&&it>Se?Se=it:"avg"===i&&(xe+=it,ke++)}if(isNaN(Se))break}I[Ae+Oe*V+ne]="avg"===i?xe/ke:Se}}}return T}function Fz(n,t,e,r,s=!1,i=!1){const o=tn(r.outShape,"int32"),a=r.strideHeight,u=r.strideWidth,c=r.dilationHeight,p=r.dilationWidth,m=r.effectiveFilterHeight,y=r.effectiveFilterWidth,_=r.padInfo.top,w=r.padInfo.left,T=tn(t,e,n);for(let I=0;I<r.batchSize;++I)for(let O=0;O<r.inChannels;++O)for(let M=0;M<r.outHeight;++M){const V=M*a-_;let z=V;for(;z<0;)z+=c;const G=Math.min(r.inHeight,m+V);for(let Q=0;Q<r.outWidth;++Q){const ne=Q*u-w;let oe=ne;for(;oe<0;)oe+=p;const de=Math.min(r.inWidth,y+ne);let pe=Number.NEGATIVE_INFINITY,Te=-1;for(let Ae=z;Ae<G;Ae+=c){const Oe=Ae-V;for(let Me=oe;Me<de;Me+=p){const Pe=Me-ne,ve=T.get(I,Ae,Me,O);ve>pe&&(pe=ve,Te=s?i?((I*r.inHeight+Ae)*r.inWidth+Me)*r.inChannels+O:(Ae*r.inWidth+Me)*r.inChannels+O:Oe*y+Pe)}}o.set(Te,I,M,Q,O)}}return o}function $z(n,t,e,r,s,i){const o=s.strideDepth,a=s.strideHeight,u=s.strideWidth,c=s.dilationDepth,p=s.dilationHeight,m=s.dilationWidth,y=s.effectiveFilterDepth,_=s.effectiveFilterHeight,w=s.effectiveFilterWidth,T=s.padInfo.front,I=s.padInfo.top,O=s.padInfo.left,M="max"===i?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,V=tn(s.outShape,e),z=V.values,G=s.outShape[1]*s.outShape[2]*s.outShape[3]*s.outShape[4],Q=s.outShape[2]*s.outShape[3]*s.outShape[4],ne=s.outShape[3]*s.outShape[4],oe=s.outShape[4];for(let de=0;de<s.batchSize;++de){const pe=de*G,Te=de*r[0];for(let Ae=0;Ae<s.inChannels;++Ae)for(let Oe=0;Oe<s.outDepth;++Oe){const Me=Oe*o-T;let Pe=Me;for(;Pe<0;)Pe+=c;const ve=Math.min(s.inDepth,y+Me),Se=pe+Oe*Q;for(let xe=0;xe<s.outHeight;++xe){const ke=xe*a-I;let We=ke;for(;We<0;)We+=p;const Ke=Math.min(s.inHeight,_+ke),et=Se+xe*ne;for(let Je=0;Je<s.outWidth;++Je){const tt=Je*u-O;let it=tt;for(;it<0;)it+=m;const yt=Math.min(s.inWidth,w+tt),ft=et+Je*oe;let kt=M,xt=0,jt=0;for(let Mn=Pe;Mn<ve;Mn+=c){const qn=Te+Mn*r[1];for(let xr=We;xr<Ke;xr+=p){const Kn=qn+xr*r[2];for(let Bn=it;Bn<yt;Bn+=m){const ir=n[Kn+Bn*r[3]+Ae];if("max"===i&&ir>kt?kt=ir:"avg"===i&&(xt+=ir,jt++),isNaN(kt))break}if(isNaN(kt))break}if(isNaN(kt))break}z[ft+Ae]="avg"===i?xt/Math.max(jt,1):kt}}}}return V}const pye={kernelName:h_,backendName:"cpu",kernelFunc:function hye(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t;St(s,"avgPool");const{filterSize:i,strides:o,pad:a,dimRoundingMode:u}=r;J(vs(o,1),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${o} and dilations '1'`);const p=vo(s.shape,i,o,1,a,u);let m;if(1===p.filterWidth&&1===p.filterHeight&&hn(p.inShape,p.outShape))m=za({inputs:{x:s},backend:e});else{const y=e.data.get(s.dataId).values,_=Nt(s.shape),w=gA(y,0,s.dtype,_,p,"avg");m=e.makeTensorInfo(p.outShape,s.dtype,w.values)}return m}},mye={kernelName:p_,backendName:"cpu",kernelFunc:function fye(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{filterSize:i,strides:o,pad:a,dimRoundingMode:u,dataFormat:c}=r;St(s,"avgPool3d");const p=pl(s.shape,i,o,1,a,u,c),y=$z(e.data.get(s.dataId).values,0,s.dtype,Nt(s.shape),p,"avg");return e.makeTensorInfo(y.shape,"float32",y.values)}},yye={kernelName:tC,backendName:"cpu",kernelFunc:function gye(n){const{inputs:t,backend:e,attrs:r}=n,{dy:s,input:i}=t,{filterSize:o,strides:a,pad:u,dimRoundingMode:c}=r;St([s,i],"avgPool3DGrad");const p=pl(i.shape,o,a,1,u,c),m=p.strideDepth,y=p.strideHeight,_=p.strideWidth,w=p.filterDepth,T=p.filterHeight,I=p.filterWidth,O=p.dilationDepth,M=p.dilationHeight,V=p.dilationWidth,z=p.effectiveFilterDepth,G=p.effectiveFilterHeight,Q=p.effectiveFilterWidth,ne=z-1-p.padInfo.front,oe=Q-1-p.padInfo.left,de=G-1-p.padInfo.top,pe=tn(i.shape,"float32"),Te=1/(w*T*I),Ae=e.bufferSync(s);for(let Oe=0;Oe<p.batchSize;++Oe)for(let Me=0;Me<p.inChannels;++Me)for(let Pe=0;Pe<p.inDepth;++Pe)for(let ve=0;ve<p.inHeight;++ve)for(let Se=0;Se<p.inWidth;++Se){const xe=Pe-ne,ke=ve-de,We=Se-oe;let Ke=0;for(let et=0;et<z;et+=O){const Je=(xe+et)/m;if(!(Je<0||Je>=p.outDepth||Math.floor(Je)!==Je))for(let tt=0;tt<G;tt+=M){const it=(ke+tt)/y;if(!(it<0||it>=p.outHeight||Math.floor(it)!==it))for(let yt=0;yt<Q;yt+=V){const ft=(We+yt)/_;ft<0||ft>=p.outWidth||Math.floor(ft)!==ft||(Ke+=Ae.get(Oe,Je,it,ft,Me))}}}pe.set(Ke*Te,Oe,Pe,ve,Se,Me)}return e.makeTensorInfo(pe.shape,pe.dtype,pe.values)}},_ye={kernelName:eC,backendName:"cpu",kernelFunc:function bye(n){const{inputs:t,backend:e,attrs:r}=n,{dy:s,input:i}=t,o=i;St([s,i],"avgPoolGrad");const{filterSize:a,strides:u,pad:c}=r,p=vo(o.shape,a,u,1,c),m=p.strideHeight,y=p.strideWidth,_=p.filterHeight,w=p.filterWidth,T=p.dilationHeight,I=p.dilationWidth,O=p.effectiveFilterHeight,M=p.effectiveFilterWidth,V=M-1-p.padInfo.left,z=O-1-p.padInfo.top,G=tn(o.shape,"float32"),Q=1/(_*w),ne=e.data.get(s.dataId).values,oe=tn(s.shape,"float32",ne);for(let de=0;de<p.batchSize;++de)for(let pe=0;pe<p.inChannels;++pe)for(let Te=0;Te<p.inHeight;++Te)for(let Ae=0;Ae<p.inWidth;++Ae){const Oe=Te-z,Me=Ae-V;let Pe=0;for(let ve=0;ve<O;ve+=T){const Se=(Oe+ve)/m;if(!(Se<0||Se>=p.outHeight||Math.floor(Se)!==Se))for(let xe=0;xe<M;xe+=I){const ke=(Me+xe)/y;ke<0||ke>=p.outWidth||Math.floor(ke)!==ke||(Pe+=oe.get(de,Se,ke,pe))}}G.set(Pe*Q,de,Te,Ae,pe)}return e.makeTensorInfo(G.shape,G.dtype,G.values)}},wye={kernelName:I_,backendName:"cpu",kernelFunc:function vye(n){const{inputs:t,backend:e,attrs:r}=n,{x:s,scale:i,offset:o,mean:a,variance:u}=t;J(a.shape.length===u.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),J(null==o||a.shape.length===o.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),J(null==i||a.shape.length===i.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks."),St([s,a,u,i,o],"batchNorm");let{varianceEpsilon:c}=r;null==c&&(c=.001);const p=e.data.get(s.dataId).values,m=e.data.get(a.dataId).values,y=e.data.get(u.dataId).values,_=i?e.data.get(i.dataId).values:new Float32Array([1]),w=o?e.data.get(o.dataId).values:new Float32Array([0]),T=new Float32Array(p.length),I=w.length,O=_.length,M=y.length,V=m.length;let z=0,G=0,Q=0,ne=0;for(let oe=0;oe<p.length;++oe)T[oe]=w[z++]+(p[oe]-m[G++])*_[Q++]/Math.sqrt(y[ne++]+c),z>=I&&(z=0),G>=V&&(G=0),Q>=O&&(Q=0),ne>=M&&(ne=0);return e.makeTensorInfo(s.shape,s.dtype,T)}};function Lz(n,t,e,r,s){const i=BI(r,t,e),o=Fe(e),a=Nt(r);if(i){const m=zI(t,a);return"string"===s?n.slice(m,m+o):n.subarray(m,m+o)}const c=tn(r,s,"string"===s?yl(n):n),p=tn(e,s);for(let m=0;m<p.size;++m){const y=p.indexToLoc(m),_=y.map((w,T)=>w+t[T]);p.set(c.get(..._),...y)}return"string"===s?xB(p.values):p.values}function $c(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{begin:i,size:o}=r;St(s,"slice");const[a,u]=Tv(s,i,o);LI(s,a,u);const p=Lz(e.data.get(s.dataId).values,a,u,s.shape,s.dtype);return e.makeTensorInfo(u,s.dtype,p)}const xye={kernelName:tv,backendName:"cpu",kernelFunc:$c},Sye={kernelName:m_,backendName:"cpu",kernelFunc:function Tye(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{blockShape:i,crops:o}=r;St([s],"batchToSpaceND");const a=i.reduce((O,M)=>O*M),u=rg(s.shape,i,a),c=sg(u.length,i.length),p=ig(s.shape,i,a),m=VE(o,i.length),y=BE(p,o,i.length),_=Hn({inputs:{x:s},backend:e,attrs:{shape:u}}),w=ui({inputs:{x:_},backend:e,attrs:{perm:c}}),T=Hn({inputs:{x:w},backend:e,attrs:{shape:p}}),I=$c({inputs:{x:T},backend:e,attrs:{begin:m,size:y}});return e.disposeIntermediateTensorInfo(_),e.disposeIntermediateTensorInfo(w),e.disposeIntermediateTensorInfo(T),I}};function yA(n,t,e,r,s){const i=Fe(r),o=ks(s,e);for(let a=0;a<n.length;a++){const u=n[a];if(u<0)throw new Error("Input x must be non-negative!");u>=s||(o[u]+=i>0?t[a]:1)}return o}function Vz(n,t,e,r=!1){const s=n.shape[0],i=n.shape[1],o=tn([s,e],t.dtype);for(let a=0;a<s;a++)for(let u=0;u<i;u++){const c=n.get(a,u);if(c<0)throw new Error("Input x must be non-negative!");c>=e||o.set(r?1:t.size>0?o.get(a,c)+t.get(a,u):o.get(a,c)+1,a,c)}return o}const Iye={kernelName:nC,backendName:"cpu",kernelFunc:function Cye(n){const{inputs:t,backend:e,attrs:r}=n,{x:s,weights:i}=t,{size:o}=r,c=yA(e.data.get(s.dataId).values,e.data.get(i.dataId).values,i.dtype,i.shape,o);return e.makeTensorInfo([o],i.dtype,c)}},Eye=Rr((n,t)=>n&t),Dye=ts(rC,Eye),Aye={kernelName:rC,backendName:"cpu",kernelFunc:Dye},Nye={kernelName:sC,backendName:"cpu",kernelFunc:function kye(n){const{inputs:t,backend:e}=n,{s0:r,s1:s}=t,i=e.data.get(r.dataId).values,o=e.data.get(s.dataId).values,a=Ht(Array.from(i),Array.from(o));return e.makeTensorInfo([a.length],"int32",Int32Array.from(a))}},Bz=Ba(n=>Math.ceil(n)),Oye=Su(Zf,Bz),Rye={kernelName:Zf,backendName:"cpu",kernelFunc:Oye},Mye=Rn(Qf,(n,t)=>n>t.clipValueMax?t.clipValueMax:n<t.clipValueMin?t.clipValueMin:n),Pye={kernelName:Qf,backendName:"cpu",kernelFunc:Mye},Fye={kernelName:g_,backendName:"cpu",kernelFunc:n=>{const{x:t}=n.inputs,e=n.backend,r=new Float32Array(Fe(t.shape)),s=e.data.get(t.dataId),o=s.complexTensorInfos.imag,a=e.data.get(s.complexTensorInfos.real.dataId).values,u=e.data.get(o.dataId).values;for(let c=0;c<a.length;c++)r[c]=Math.hypot(a[c],u[c]);return e.makeOutput(r,t.shape,"float32")}};function zz(n,t,e,r){const s=Ar(e,Fe(t));if(r&&"string"!==e){let i=0;n.forEach(o=>{const a=Fe(o.shape);s.set(o.vals,i),i+=a})}else{let i=0;n.forEach(o=>{const a="string"===e?yl(o.vals):o.vals;let u=0;for(let c=0;c<o.shape[0];++c){const p=c*t[1]+i;for(let m=0;m<o.shape[1];++m)s[p+m]=a[u++]}i+=o.shape[1]})}return s}function Bh(n){const{inputs:t,backend:e}=n,{input:r}=t,s=e.data.get(r.dataId).complexTensorInfos.imag,i=e.data.get(s.dataId).values;return e.makeTensorInfo(s.shape,s.dtype,i)}const $ye={kernelName:CC,backendName:"cpu",kernelFunc:Bh};function zh(n){const{inputs:t,backend:e,attrs:r}=n,{axis:s}=r,i=sn(s,t[0].shape)[0];FE(t.map(T=>T.shape),i);let a=Ra(t.map(T=>T.shape),i);if(0===Fe(a))return e.makeTensorInfo(a,t[0].dtype,[]);const u=t.filter(T=>Fe(T.shape)>0);if(1===u.length)return za({inputs:{x:u[0]},backend:e});if("complex64"===u[0].dtype){const T=u.map(z=>Fc({inputs:{input:z},backend:e})),I=u.map(z=>Bh({inputs:{input:z},backend:e})),O=zh({inputs:T,backend:e,attrs:{axis:i}}),M=zh({inputs:I,backend:e,attrs:{axis:i}}),V=Di({inputs:{real:O,imag:M},backend:e});return T.forEach(z=>e.disposeIntermediateTensorInfo(z)),I.forEach(z=>e.disposeIntermediateTensorInfo(z)),e.disposeIntermediateTensorInfo(O),e.disposeIntermediateTensorInfo(M),V}const c=u.map(T=>{const O=[-1,Fe(T.shape.slice(i))];return Hn({inputs:{x:T},backend:e,attrs:{shape:O}})}),p=c.map(T=>({vals:e.data.get(T.dataId).values,shape:T.shape}));a=Ra(c.map(T=>T.shape),1);const y=zz(p,a,t[0].dtype,1===c[0].shape[0]),_=Ra(u.map(T=>T.shape),i),w=e.makeTensorInfo(_,t[0].dtype,y);return c.forEach(T=>e.disposeIntermediateTensorInfo(T)),w}const Lye={kernelName:y_,backendName:"cpu",kernelFunc:zh};function Uz(n){const{inputs:t,backend:e,attrs:r}=n,{x:s,filter:i}=t,{strides:o,pad:a,dataFormat:u,dilations:c,dimRoundingMode:p}=r;St([s,i],"conv2d");const m=fl(u),y=ls(s.shape,i.shape,o,c,a,p,!1,m),_=y.filterHeight,w=y.filterWidth,T=y.dilationHeight,I=y.dilationWidth,O=y.padInfo.left,M=y.padInfo.top,V="channelsLast"===y.dataFormat,z=new qr(y.outShape,s.dtype),G=Nt(s.shape),Q=Nt(i.shape),ne=G[0],oe=V?G[1]:G[2],de=V?G[2]:1,pe=V?1:G[1],Te=z.strides[0],Ae=V?z.strides[1]:z.strides[2],Oe=V?z.strides[2]:1,Me=V?1:z.strides[1],Pe=e.data.get(s.dataId).values,ve=e.data.get(i.dataId).values,Se=z.values;for(let xe=0;xe<y.batchSize;++xe){const ke=xe*ne,We=xe*Te;for(let Ke=0;Ke<y.outHeight;++Ke){const et=We+Ke*Ae,Je=Ke*y.strideHeight-M;for(let tt=0;tt<_;++tt){const it=Je+tt*T;if(it<0||it>=y.inHeight)continue;const yt=tt*Q[0],ft=ke+it*oe;for(let kt=0;kt<y.outWidth;++kt){const xt=et+kt*Oe,jt=kt*y.strideWidth-O;for(let qt=0;qt<w;++qt){const Mn=jt+qt*I;if(Mn<0||Mn>=y.inWidth)continue;const xr=ft+Mn*de;let Kn=yt+qt*Q[1];for(let Bn=0;Bn<y.inChannels;++Bn){const pr=Pe[xr+Bn*pe];for(let ir=0;ir<y.outChannels;++ir)Se[xt+ir*Me]+=pr*ve[Kn+ir];Kn+=y.outChannels}}}}}}return e.makeTensorInfo(z.shape,z.dtype,Se)}const Vye={kernelName:b_,backendName:"cpu",kernelFunc:Uz},zye={kernelName:oC,backendName:"cpu",kernelFunc:function Bye(n){const{inputs:t,backend:e,attrs:r}=n,{x:s,dy:i}=t,{strides:o,pad:a,dataFormat:u,dimRoundingMode:c,filterShape:p}=r;St([s,i],"conv2dBackpropFilter");const m=fl(u),y=ls(s.shape,p,o,1,a,c,!1,m),{strideHeight:_,strideWidth:w,filterHeight:T,filterWidth:I}=y,O="channelsLast"===y.dataFormat,M=new qr(y.filterShape,"float32"),V=y.padInfo.left,z=y.padInfo.top,G=e.data.get(s.dataId).values,Q=e.data.get(i.dataId).values,ne=new qr(s.shape,s.dtype,G),oe=new qr(i.shape,i.dtype,Q);for(let de=0;de<T;++de){const pe=Math.max(0,Math.ceil((z-de)/_)),Te=Math.min(y.outHeight,(y.inHeight+z-de)/_);for(let Ae=0;Ae<I;++Ae){const Oe=Math.max(0,Math.ceil((V-Ae)/w)),Me=Math.min(y.outWidth,(y.inWidth+V-Ae)/w);for(let Pe=0;Pe<y.inChannels;++Pe)for(let ve=0;ve<y.outChannels;++ve){let Se=0;for(let xe=0;xe<y.batchSize;++xe)for(let ke=pe;ke<Te;++ke){const We=de+ke*_-z;for(let Ke=Oe;Ke<Me;++Ke){const et=Ae+Ke*w-V;Se+=O?ne.get(xe,We,et,Pe)*oe.get(xe,ke,Ke,ve):ne.get(xe,Pe,We,et)*oe.get(xe,ve,ke,Ke)}}M.set(Se,de,Ae,Pe,ve)}}}return e.makeTensorInfo(M.shape,M.dtype,M.values)}},jye={kernelName:__,backendName:"cpu",kernelFunc:function Uye(n){const{inputs:t,backend:e,attrs:r}=n,{dy:s,filter:i}=t,{inputShape:o,strides:a,pad:u,dataFormat:c,dimRoundingMode:p}=r;St([s,i],"conv2dBackpropInput");const m=Nt(i.shape),y=Nt(s.shape);let _=fl(c);const w=ls(o,i.shape,a,1,u,p,!1,_),T=new qr(w.inShape,"float32"),I=T.values,O=e.data.get(s.dataId).values,M=e.data.get(i.dataId).values,[V,z,G]=m,{batchSize:Q,filterHeight:ne,filterWidth:oe,inChannels:de,inHeight:pe,inWidth:Te,outChannels:Ae,outHeight:Oe,outWidth:Me,strideHeight:Pe,strideWidth:ve}=w;_=w.dataFormat;const Se=ne-1-w.padInfo.top,xe=oe-1-w.padInfo.left,ke="channelsLast"===_,We=T.strides[0],Ke=ke?T.strides[1]:T.strides[2],et=ke?T.strides[2]:1,Je=ke?1:T.strides[1],tt=y[0],it=ke?y[1]:y[2],yt=ke?y[2]:1,ft=ke?1:y[1];for(let kt=0;kt<Q;++kt)for(let xt=0;xt<de;++xt)for(let jt=0;jt<pe;++jt){const qt=jt-Se,Mn=Math.max(0,Math.ceil(qt/Pe)),qn=Math.min(Oe,(ne+qt)/Pe);for(let xr=0;xr<Te;++xr){const Kn=xr-xe,Bn=Math.max(0,Math.ceil(Kn/ve)),pr=Math.min(Me,(oe+Kn)/ve);let ir=0;for(let Ss=Mn;Ss<qn;++Ss){const $u=Ss*Pe-qt;for(let to=Bn;to<pr;++to){const oa=tt*kt+it*Ss+yt*to,Il=V*(ne-1-$u)+z*(oe-1-(to*ve-Kn))+G*xt;for(let Lu=0;Lu<Ae;++Lu)ir+=O[oa+ft*Lu]*M[Il+Lu]}}I[We*kt+Ke*jt+et*xr+Je*xt]=ir}}return e.makeTensorInfo(T.shape,T.dtype,T.values)}},Wye={kernelName:v_,backendName:"cpu",kernelFunc:function Gye(n){const{inputs:t,backend:e,attrs:r}=n,{x:s,filter:i}=t,{strides:o,pad:a,dilations:u}=r;St([s,i],"conv3d");const c=cu(s.shape,i.shape,o,u,a),{filterDepth:p,filterHeight:m,filterWidth:y,dilationDepth:_,dilationHeight:w,dilationWidth:T,padInfo:I}=c,O=I.front,M=I.left,V=I.top,z=new qr(c.outShape,s.dtype),G=e.data.get(s.dataId).values,Q=e.data.get(i.dataId).values,ne=z.values,oe=Nt(s.shape),de=Nt(i.shape);for(let pe=0;pe<c.batchSize;++pe){const Te=pe*oe[0],Ae=pe*z.strides[0];for(let Oe=0;Oe<c.outDepth;++Oe){const Me=Ae+Oe*z.strides[1],Pe=Oe*c.strideDepth-O;for(let ve=0;ve<p;++ve){const Se=Pe+ve*_;if(Se<0||Se>=c.inDepth)continue;const xe=ve*de[0],ke=Te+Se*oe[1];for(let We=0;We<c.outHeight;++We){const Ke=Me+We*z.strides[2],et=We*c.strideHeight-V;for(let Je=0;Je<m;++Je){const tt=et+Je*w;if(tt<0||tt>=c.inHeight)continue;const it=xe+Je*de[1],yt=ke+tt*oe[2];for(let ft=0;ft<c.outWidth;++ft){const kt=Ke+ft*c.outChannels,xt=ft*c.strideWidth-M;for(let jt=0;jt<y;++jt){const qt=xt+jt*T;if(qt<0||qt>=c.inWidth)continue;const qn=yt+qt*c.inChannels;let xr=it+jt*de[2];for(let Kn=0;Kn<c.inChannels;++Kn){const Bn=G[qn+Kn];for(let pr=0;pr<c.outChannels;++pr)ne[kt+pr]+=Bn*Q[xr+pr];xr+=c.outChannels}}}}}}}}return e.makeTensorInfo(z.shape,z.dtype,z.values)}},qye={kernelName:aC,backendName:"cpu",kernelFunc:function Hye(n){const{inputs:t,backend:e,attrs:r}=n,{x:s,dy:i}=t,{strides:o,pad:a,filterShape:u}=r;St([s,i],"conv3dBackpropFilterV2");const c=Nt(s.shape),p=Nt(i.shape),m=cu(s.shape,u,o,1,a),y=m.strideDepth,_=m.strideHeight,w=m.strideWidth,T=m.filterDepth,I=m.filterHeight,O=m.filterWidth,M=new qr(m.filterShape,"float32"),V=M.values,[z,G,Q,ne]=M.strides,oe=e.data.get(i.dataId).values,[de,pe,Te,Ae]=p,Oe=e.data.get(s.dataId).values,[Me,Pe,ve,Se]=c,xe=m.padInfo.front,ke=m.padInfo.left,We=m.padInfo.top;for(let Ke=0;Ke<T;++Ke){const et=Math.max(0,Math.ceil((xe-Ke)/y)),Je=Math.min(m.outDepth,(m.inDepth+xe-Ke)/y),tt=Ke*z;for(let it=0;it<I;++it){const yt=Math.max(0,Math.ceil((We-it)/_)),ft=Math.min(m.outHeight,(m.inHeight+We-it)/_),kt=it*G+tt;for(let xt=0;xt<O;++xt){const jt=Math.max(0,Math.ceil((ke-xt)/w)),qt=Math.min(m.outWidth,(m.inWidth+ke-xt)/w),Mn=xt*Q+kt;for(let qn=0;qn<m.inChannels;++qn){const xr=qn*ne+Mn;for(let Kn=0;Kn<m.outChannels;++Kn){let Bn=0;for(let pr=0;pr<m.batchSize;++pr){const ir=pr*Me,Cl=pr*de;for(let Ss=et;Ss<Je;++Ss){const to=(Ke+Ss*y-xe)*Pe+ir,Jc=Ss*pe+Cl;for(let oa=yt;oa<ft;++oa){const Lu=(it+oa*_-We)*ve+to,Vu=oa*Te+Jc;for(let Bu=jt;Bu<qt;++Bu)Bn+=Oe[(xt+Bu*w-ke)*Se+Lu+qn]*oe[Bu*Ae+Vu+Kn]}}}V[xr+Kn]=Bn}}}}}return e.makeTensorInfo(M.shape,M.dtype,M.values)}},Xye={kernelName:lC,backendName:"cpu",kernelFunc:function Kye(n){const{inputs:t,backend:e,attrs:r}=n,{dy:s,filter:i}=t,{pad:o,strides:a,inputShape:u}=r;St([s],"conv3dBackpropInputV2");const c=Nt(s.shape),p=Nt(i.shape),m=cu(u,i.shape,a,1,o),y=new qr(m.inShape,"float32"),_=y.values,[w,T,I,O]=y.strides,M=e.data.get(s.dataId).values,[V,z,G,Q]=c,ne=e.data.get(i.dataId).values,[oe,de,pe,Te]=p,{batchSize:Ae,filterDepth:Oe,filterHeight:Me,filterWidth:Pe,inChannels:ve,inDepth:Se,inHeight:xe,inWidth:ke,outChannels:We,outDepth:Ke,outHeight:et,outWidth:Je,strideDepth:tt,strideHeight:it,strideWidth:yt}=m,ft=Oe-1-m.padInfo.front,kt=Me-1-m.padInfo.top,xt=Pe-1-m.padInfo.left;for(let jt=0;jt<Ae;++jt)for(let qt=0;qt<ve;++qt)for(let Mn=0;Mn<Se;++Mn){const qn=Mn-ft,xr=Math.max(0,Math.ceil(qn/tt)),Kn=Math.min(Ke,(Oe+qn)/tt);for(let Bn=0;Bn<xe;++Bn){const pr=Bn-kt,ir=Math.max(0,Math.ceil(pr/it)),Cl=Math.min(et,(Me+pr)/it);for(let Ss=0;Ss<ke;++Ss){const $u=Ss-xt,to=Math.max(0,Math.ceil($u/yt)),Jc=Math.min(Je,(Pe+$u)/yt);let oa=0;for(let Il=xr;Il<Kn;++Il){const Lu=Il*tt-qn;for(let Vu=ir;Vu<Cl;++Vu){const Bu=Vu*it-pr;for(let Xg=to;Xg<Jc;++Xg){const eN=V*jt+z*Il+G*Vu+Q*Xg,wFe=oe*(Oe-1-Lu)+de*(Me-1-Bu)+pe*(Pe-1-(Xg*yt-$u))+Te*qt;for(let zw=0;zw<We;++zw)oa+=M[eN+zw]*ne[wFe+zw]}}}_[w*jt+T*Mn+I*Bn+O*Ss+qt]=oa}}}return e.makeTensorInfo(y.shape,y.dtype,y.values)}},Yye=Rn(Jf,n=>Math.cos(n)),Zye={kernelName:Jf,backendName:"cpu",kernelFunc:Yye},Qye=Rn(em,n=>Math.cosh(n)),Jye={kernelName:em,backendName:"cpu",kernelFunc:Qye},tbe={kernelName:cC,backendName:"cpu",kernelFunc:function ebe(n){const{inputs:t,backend:e,attrs:r}=n,{image:s,boxes:i,boxInd:o}=t,{cropSize:a,method:u,extrapolationValue:c}=r,[p,m,y,_]=s.shape,w=i.shape[0],[T,I]=a,O=tn([w,T,I,_],"float32"),M=e.data.get(i.dataId).values,V=e.data.get(o.dataId).values,z=e.data.get(s.dataId).values,G=Nt(s.shape),Q=Nt(O.shape);for(let ne=0;ne<w;ne++){const oe=4*ne,de=M[oe],pe=M[oe+1],Te=M[oe+2],Ae=M[oe+3],Oe=V[ne];if(Oe>=p)continue;const Me=T>1?(Te-de)*(m-1)/(T-1):0,Pe=I>1?(Ae-pe)*(y-1)/(I-1):0;for(let ve=0;ve<T;ve++){const Se=T>1?de*(m-1)+ve*Me:.5*(de+Te)*(m-1);if(Se<0||Se>m-1)for(let xe=0;xe<I;xe++)for(let ke=0;ke<_;ke++)O.values[ke+xe*Q[2]+ve*Q[1]+ne*Q[0]]=c;else if("bilinear"===u){const xe=Math.floor(Se),ke=Math.ceil(Se),We=Se-xe;for(let Ke=0;Ke<I;Ke++){const et=I>1?pe*(y-1)+Ke*Pe:.5*(pe+Ae)*(y-1);if(et<0||et>y-1){for(let yt=0;yt<_;yt++)O.values[yt+Ke*Q[2]+ve*Q[1]+ne*Q[0]]=c;continue}const Je=Math.floor(et),tt=Math.ceil(et),it=et-Je;for(let yt=0;yt<_;yt++){let ft=yt+Je*G[2]+xe*G[1]+Oe*G[0];const kt=z[ft];ft=yt+tt*G[2]+xe*G[1]+Oe*G[0];const xt=z[ft];ft=yt+Je*G[2]+ke*G[1]+Oe*G[0];const jt=z[ft];ft=yt+tt*G[2]+ke*G[1]+Oe*G[0];const qt=z[ft],Mn=kt+(xt-kt)*it;ft=yt+Ke*Q[2]+ve*Q[1]+ne*Q[0],O.values[ft]=Mn+(jt+(qt-jt)*it-Mn)*We}}}else for(let xe=0;xe<I;++xe){const ke=I>1?pe*(y-1)+xe*Pe:.5*(pe+Ae)*(y-1);if(ke<0||ke>y-1){for(let et=0;et<_;et++)O.values[et+xe*Q[2]+ve*Q[1]+ne*Q[0]]=c;continue}const We=Math.round(ke),Ke=Math.round(Se);for(let et=0;et<_;et++)O.values[et+xe*Q[2]+ve*Q[1]+ne*Q[0]]=z[et+We*G[2]+Ke*G[1]+Oe*G[0]]}}}return e.makeTensorInfo(O.shape,O.dtype,O.values)}},rbe={kernelName:uC,backendName:"cpu",kernelFunc:function nbe(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{axis:i,exclusive:o,reverse:a}=r;St(s,"cumprod");const u=ur([i],s.shape.length);let c=s;null!=u&&(c=ui({inputs:{x:s},backend:e,attrs:{perm:u}}));const p=Nr(1,s.shape.length)[0];if(p!==c.shape.length-1)throw new Error(`backend.cumprod in CPU expects an inner-most axis=${c.shape.length-1} but got axis=${p}`);const m=Ti(c.dtype,"int32"),y=X1(Fe(c.shape),m),_=e.data.get(c.dataId).values,w=c.shape[c.shape.length-1],T=a?(O,M)=>O+w-M-1:(O,M)=>O+M;for(let O=0;O<_.length;O+=w)for(let M=0;M<w;M++){const V=T(O,M);if(0===M)y[V]=o?1:_[V];else{const z=T(O,M-1);y[V]=o?_[z]*y[z]:_[V]*y[z]}}const I=e.makeTensorInfo(c.shape,m,y);if(null!=u){const M=ui({inputs:{x:I},backend:e,attrs:{perm:pu(u)}});return e.disposeIntermediateTensorInfo(I),e.disposeIntermediateTensorInfo(c),M}return I}},ibe={kernelName:w_,backendName:"cpu",kernelFunc:function sbe(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{axis:i,exclusive:o,reverse:a}=r;St(s,"cumsum");const u=ur([i],s.shape.length);let c=s;null!=u&&(c=ui({inputs:{x:s},backend:e,attrs:{perm:u}}));const p=Nr(1,s.shape.length)[0];if(p!==c.shape.length-1)throw new Error(`backend.cumsum in CPU expects an inner-most axis=${c.shape.length-1} but got axis=${p}`);const m=Ti(c.dtype,"int32"),y=ks(Fe(c.shape),m),_=e.data.get(c.dataId).values,w=c.shape[c.shape.length-1],T=a?(O,M)=>O+w-M-1:(O,M)=>O+M;for(let O=0;O<_.length;O+=w)for(let M=0;M<w;M++){const V=T(O,M);if(0===M)y[V]=o?0:_[V];else{const z=T(O,M-1);y[V]=o?_[z]+y[z]:_[V]+y[z]}}const I=e.makeTensorInfo(c.shape,m,y);if(null!=u){const M=ui({inputs:{x:I},backend:e,attrs:{perm:pu(u)}});return e.disposeIntermediateTensorInfo(I),e.disposeIntermediateTensorInfo(c),M}return I}},abe={kernelName:dC,backendName:"cpu",kernelFunc:function obe(n){const{inputs:t,backend:e,attrs:r}=n,{x:s,weights:i}=t,{size:o,binaryOutput:a}=r;if(1===s.shape.length){const p=yA(e.data.get(s.dataId).values,e.data.get(i.dataId).values,i.dtype,i.shape,o);return e.makeTensorInfo([o],i.dtype,p)}if(2===s.shape.length){const p=Vz(e.bufferSync(s),e.bufferSync(i),o,a);return e.makeTensorInfo(p.shape,i.dtype,p.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${s.shape.length}.`)}},ube={kernelName:hC,backendName:"cpu",kernelFunc:function lbe(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{blockSize:i,dataFormat:o}=r;J("NHWC"===o,()=>`Only NHWC dataFormat supported on CPU for depthToSpace. Got ${o}`);const a=s.shape[0],u=s.shape[1],c=s.shape[2],p=s.shape[3],m=u*i,y=c*i,_=p/(i*i),w=e.data.get(s.dataId).values,T=new Float32Array(a*m*y*_);let I=0;for(let O=0;O<a;++O)for(let M=0;M<m;++M){const V=Math.floor(M/i),z=M%i;for(let G=0;G<y;++G){const Q=Math.floor(G/i),oe=(z*i+G%i)*_;for(let de=0;de<_;++de)T[I++]=w[de+oe+p*(Q+c*(V+u*O))]}}return e.makeTensorInfo([a,m,y,_],s.dtype,T)}};function jz(n){const{inputs:t,backend:e,attrs:r}=n,{x:s,filter:i}=t,{strides:o,pad:a,dilations:u,dimRoundingMode:c}=r;St([s,i],"depthwiseConv2DNative");const p=Nt(s.shape),m=Nt(i.shape);let y=u;null==y&&(y=[1,1]),J(vs(o,y),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${o} and dilations '${y}'`);const _=ls(s.shape,i.shape,o,y,a,c,!0),{filterHeight:w,filterWidth:T,dilationHeight:I,dilationWidth:O,padInfo:M}=_,V=M.left,z=M.top,G=_.outChannels/_.inChannels,Q=new qr(_.outShape,s.dtype),ne=e.data.get(s.dataId).values,oe=e.data.get(i.dataId).values,de=Q.values;for(let pe=0;pe<_.batchSize;++pe){const Te=pe*p[0],Ae=pe*Q.strides[0];for(let Oe=0;Oe<_.outHeight;++Oe){const Me=Ae+Oe*Q.strides[1],Pe=Oe*_.strideHeight-z;for(let ve=0;ve<w;++ve){const Se=Pe+ve*I;if(Se<0||Se>=_.inHeight)continue;const xe=ve*m[0],ke=Te+Se*p[1];for(let We=0;We<_.outWidth;++We){const Ke=Me+We*Q.strides[2],et=We*_.strideWidth-V;for(let Je=0;Je<T;++Je){const tt=et+Je*O;if(tt<0||tt>=_.inWidth)continue;const yt=ke+tt*_.inChannels;let ft=Ke,kt=xe+Je*m[1];for(let xt=0;xt<_.inChannels;++xt){const jt=ne[yt+xt];for(let qt=0;qt<G;++qt)de[ft+qt]+=jt*oe[kt+qt];ft+=G,kt+=G}}}}}}return e.makeTensorInfo(Q.shape,Q.dtype,Q.values)}const cbe={kernelName:x_,backendName:"cpu",kernelFunc:jz},hbe={kernelName:pC,backendName:"cpu",kernelFunc:function dbe(n){const{inputs:t,backend:e,attrs:r}=n,{x:s,dy:i}=t,{strides:o,dilations:a,pad:u,dimRoundingMode:c,filterShape:p}=r;St([s,i],"depthwiseConv2dNativeBackpropFilter");const m=ls(s.shape,p,o,a,u,c,!0),{strideHeight:y,strideWidth:_,filterHeight:w,filterWidth:T}=m,I=new qr(m.filterShape,"float32"),O=m.padInfo.left,M=m.padInfo.top,V=m.outChannels/m.inChannels,z=e.data.get(s.dataId).values,G=new qr(s.shape,s.dtype,z),Q=e.data.get(i.dataId).values,ne=new qr(i.shape,i.dtype,Q);for(let oe=0;oe<w;++oe){const de=Math.max(0,Math.ceil((M-oe)/y)),pe=Math.min(m.outHeight,(m.inHeight+M-oe)/y);for(let Te=0;Te<T;++Te){const Ae=Math.max(0,Math.ceil((O-Te)/_)),Oe=Math.min(m.outWidth,(m.inWidth+O-Te)/_);for(let Me=0;Me<m.outChannels;++Me){const Pe=Math.trunc(Me/V),ve=Me%V;let Se=0;for(let xe=0;xe<m.batchSize;++xe)for(let ke=de;ke<pe;++ke){const We=oe+ke*y-M;for(let Ke=Ae;Ke<Oe;++Ke)Se+=G.get(xe,We,Te+Ke*_-O,Pe)*ne.get(xe,ke,Ke,Me)}I.set(Se,oe,Te,Pe,ve)}}}return e.makeTensorInfo(I.shape,I.dtype,I.values)}},fbe={kernelName:fC,backendName:"cpu",kernelFunc:function pbe(n){const{inputs:t,backend:e,attrs:r}=n,{dy:s,filter:i}=t,{strides:o,dilations:a,pad:u,dimRoundingMode:c,inputShape:p}=r;St([s,i],"depthwiseConv2DNativeBackpropInput");const m=Nt(s.shape),y=Nt(i.shape),_=ls(p,i.shape,o,a,u,c,!0),w=new qr(_.inShape,"float32"),T=w.values,[I,O,M]=w.strides,V=e.data.get(s.dataId).values,[z,G,Q]=m,ne=e.data.get(i.dataId).values,[oe,de,pe]=y,{batchSize:Te,filterHeight:Ae,filterWidth:Oe,inChannels:Me,inHeight:Pe,inWidth:ve,outChannels:Se,outHeight:xe,outWidth:ke,strideHeight:We,strideWidth:Ke}=_,et=Ae-1-_.padInfo.top,Je=Oe-1-_.padInfo.left,tt=Se/Me;for(let it=0;it<Te;++it)for(let yt=0;yt<Me;++yt)for(let ft=0;ft<Pe;++ft){const kt=ft-et,xt=Math.max(0,Math.ceil(kt/We)),jt=Math.min(xe,(Ae+kt)/We);for(let qt=0;qt<ve;++qt){const Mn=qt-Je,qn=Math.max(0,Math.ceil(Mn/Ke)),xr=Math.min(ke,(Oe+Mn)/Ke);let Kn=0;for(let Bn=xt;Bn<jt;++Bn){const pr=Bn*We-kt;for(let ir=qn;ir<xr;++ir){const Ss=z*it+G*Bn+Q*ir,$u=oe*(Ae-1-pr)+de*(Oe-1-(ir*Ke-Mn))+pe*yt;for(let to=0;to<tt;++to)Kn+=V[Ss+(yt*tt+to)]*ne[$u+to]}}T[I*it+O*ft+M*qt+yt]=Kn}}return e.makeTensorInfo(w.shape,w.dtype,w.values)}},gbe={kernelName:mC,backendName:"cpu",kernelFunc:function mbe(n){const{inputs:t,backend:e}=n,{x:r}=t,s=Fe(r.shape),i=e.data.get(r.dataId).values,o=tn([s,s],r.dtype),a=o.values;for(let c=0;c<i.length;c++)a[c*s+c]=i[c];const u=[...r.shape,...r.shape];return e.makeTensorInfo(u,o.dtype,o.values)}},ybe={kernelName:T_,backendName:"cpu",kernelFunc:({inputs:n,backend:t,attrs:e})=>{const{x:r,filter:s}=n,{strides:i,pad:o,dilations:a}=e,u=t,c=u.data.get(r.dataId).values,p=r.shape.length,m=u.data.get(s.dataId).values,y=s.shape.length,{batchSize:_,inHeight:w,inWidth:T,inChannels:I,outHeight:O,outWidth:M,padInfo:V,strideHeight:z,strideWidth:G,filterHeight:Q,filterWidth:ne,dilationHeight:oe,dilationWidth:de,outShape:pe}=jm(r.shape,s.shape,i,o,"NHWC",a),Te=Fe(pe),Ae=pe.length,Oe=Ar(r.dtype,Te);for(let Pe=0;Pe<_;++Pe)for(let ve=0;ve<O;++ve){const Se=ve*z-V.top;for(let xe=0;xe<M;++xe){const ke=xe*G-V.left;for(let We=0;We<I;++We){let Ke=Number.MIN_SAFE_INTEGER;for(let Je=0;Je<Q;++Je){const tt=Se+Je*oe;if(tt>=0&&tt<w)for(let it=0;it<ne;++it){const yt=ke+it*de;if(yt>=0&&yt<T){const ft=Ia([Pe,tt,yt,We],p,Nt(r.shape)),kt=Ia([Je,it,We],y,Nt(s.shape)),xt=c[ft]+m[kt];xt>Ke&&(Ke=xt)}}}Oe[Ia([Pe,ve,xe,We],Ae,Nt(pe))]=Ke}}}return{dataId:u.write(bc(Oe,r.dtype),pe,r.dtype),shape:pe,dtype:r.dtype}}},bbe={kernelName:yC,backendName:"cpu",kernelFunc:({inputs:n,backend:t,attrs:e})=>{const{x:r,filter:s,dy:i}=n,{strides:o,pad:a,dilations:u}=e,c=t,p=yo(r.shape,c.data.get(r.dataId).values),m=yo(s.shape,c.data.get(s.dataId).values),{batchSize:y,inHeight:_,inWidth:w,inChannels:T,outHeight:I,outWidth:O,padInfo:M,strideHeight:V,strideWidth:z,filterHeight:G,filterWidth:Q,dilationHeight:ne,dilationWidth:oe,outShape:de}=jm(r.shape,s.shape,o,a,"NHWC",u);J(i.rank===de.length,()=>`Error in ${yC}, dy must have the same rank as output ${de.length}, but got ${i.rank}`);const pe=yo(de,c.data.get(i.dataId).values),Te=NL(s.shape,s.dtype);for(let Oe=0;Oe<y;++Oe)for(let Me=0;Me<I;++Me){const Pe=Me*V-M.top;for(let ve=0;ve<O;++ve){const Se=ve*z-M.left;for(let xe=0;xe<T;++xe){let ke=Number.MIN_SAFE_INTEGER,We=0,Ke=0;for(let et=0;et<G;++et){const Je=Pe+et*ne;if(Je>=0&&Je<_)for(let tt=0;tt<Q;++tt){const it=Se+tt*oe;if(it>=0&&it<w){const yt=p[Oe][Je][it][xe]+m[et][tt][xe];yt>ke&&(ke=yt,We=et,Ke=tt)}}}Te[We][Ke][xe]+=pe[Oe][Me][ve][xe]}}}return{dataId:c.write(bc(Te,r.dtype),s.shape,s.dtype),shape:s.shape,dtype:s.dtype}}},_be={kernelName:gC,backendName:"cpu",kernelFunc:({inputs:n,backend:t,attrs:e})=>{const{x:r,filter:s,dy:i}=n,{strides:o,pad:a,dilations:u}=e,c=t,p=yo(r.shape,c.data.get(r.dataId).values),m=yo(s.shape,c.data.get(s.dataId).values),{batchSize:y,inHeight:_,inWidth:w,inChannels:T,outHeight:I,outWidth:O,padInfo:M,strideHeight:V,strideWidth:z,filterHeight:G,filterWidth:Q,dilationHeight:ne,dilationWidth:oe,outShape:de}=jm(r.shape,s.shape,o,a,"NHWC",u);J(i.rank===de.length,()=>`Error in ${gC}, dy must have the same rank as output ${de.length}, but got ${i.rank}`);const pe=yo(de,c.data.get(i.dataId).values),Te=NL(r.shape,r.dtype);for(let Oe=0;Oe<y;++Oe)for(let Me=0;Me<I;++Me){const Pe=Me*V-M.top;for(let ve=0;ve<O;++ve){const Se=ve*z-M.left;for(let xe=0;xe<T;++xe){let ke=Number.MIN_SAFE_INTEGER,We=Pe<0?0:Pe,Ke=Se<0?0:Se;for(let et=0;et<G;++et){const Je=Pe+et*ne;if(Je>=0&&Je<_)for(let tt=0;tt<Q;++tt){const it=Se+tt*oe;if(it>=0&&it<w){const yt=p[Oe][Je][it][xe]+m[et][tt][xe];yt>ke&&(ke=yt,We=Je,Ke=it)}}}Te[Oe][We][Ke][xe]+=pe[Oe][Me][ve][xe]}}}return{dataId:c.write(bc(Te,r.dtype),r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}},bA=Rr((n,t)=>n*t),vbe=fA((n,t,e,r)=>({real:n*e-t*r,imag:n*r+t*e})),N0=ts(bm,bA,vbe),wbe={kernelName:bm,backendName:"cpu",kernelFunc:N0};function wg(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{axis:i,keepDims:o}=r;let a;St(s,"sum"),a="bool"===s.dtype?Cu({inputs:{x:s},backend:e,attrs:{dtype:"int32"}}):za({inputs:{x:s},backend:e});const u=a.shape.length,c=sn(i,a.shape),p=ur(c,u);let m=c,y=a;null!=p&&(y=ui({inputs:{x:a},backend:e,attrs:{perm:p}}),m=Nr(m.length,u)),ws("sum",m,y.shape.length);const[_,w]=us(y.shape,m);let I=k0(e,_,Ti(y.dtype,"int32"));const O=Fe(w),M=e.data.get(I.dataId).values,V=e.data.get(y.dataId).values;for(let z=0;z<M.length;++z){const G=z*O;let Q=0;for(let ne=0;ne<O;++ne)Q+=V[G+ne];M[z]=Q}if(o){const G=I;I=Hn({inputs:{x:I},backend:e,attrs:{shape:kr(I.shape,c)}}),e.disposeIntermediateTensorInfo(G)}return e.disposeIntermediateTensorInfo(a),null!=p&&e.disposeIntermediateTensorInfo(y),I}const xbe={kernelName:nv,backendName:"cpu",kernelFunc:wg},Sbe={kernelName:bC,backendName:"cpu",kernelFunc:function Tbe(n){const{inputs:t,backend:e,attrs:r}=n,{equation:s}=r,i=t,{allDims:o,summedDims:a,idDims:u}=YE(s,i.length);QE(o.length,u,i);const{path:c,steps:p}=JE(a,u),m=p.length;let y=null,_=o.length;const w=[];for(let T=0;T<m;++T){for(const I of p[T]){const{permutationIndices:O,expandDims:M}=ZE(_,u[I]);let V;eD(O)?V=i[I]:(V=ui({inputs:{x:i[I]},backend:e,attrs:{perm:O}}),w.push(V));const z=V.shape.slice();for(let G=0;G<M.length;++G)z.splice(M[G],0,1);hn(V.shape,z)||(V=Hn({inputs:{x:V},backend:e,attrs:{shape:z}}),w.push(V)),null===y?y=V:(y=N0({inputs:{a:V,b:y},backend:e}),w.push(y))}T<m-1&&(c[T]>=0&&(y=wg({inputs:{x:y},backend:e,attrs:{axis:c[T]-(o.length-_),keepDims:!1}}),w.push(y)),_--)}for(const T of w)T!==y&&e.disposeIntermediateTensorInfo(T);return y}},Ibe={kernelName:_C,backendName:"cpu",kernelFunc:function Cbe(n){const{inputs:t,backend:e}=n,{dy:r,y:s}=t;St([r,s],"eluGrad");const i=new Float32Array(Fe(s.shape)),o=e.data.get(s.dataId).values,a=e.data.get(r.dataId).values;for(let u=0;u<o.length;++u){const c=o[u];i[u]=c>=0?a[u]:a[u]*(c+1)}return e.makeTensorInfo(s.shape,"float32",i)}},Gz=Rr((n,t)=>n===t?1:0),Wz=ts(S_,Gz,null,"bool"),Ebe={kernelName:S_,backendName:"cpu",kernelFunc:Wz},Dbe=UE,Abe=jE,kbe=GE,Nbe=WE,Obe=HE,Rbe=qE,Mbe=Rn(rm,n=>{const t=Math.sign(n),e=Math.abs(n),r=1/(1+Dbe*e);return t*(1-((((Rbe*r+Obe)*r+Nbe)*r+kbe)*r+Abe)*r*Math.exp(-e*e))}),Pbe={kernelName:rm,backendName:"cpu",kernelFunc:Mbe},Hz=Ba(n=>Math.exp(n)),qz=Su(sm,Hz,"float32"),Fbe={kernelName:sm,backendName:"cpu",kernelFunc:qz};function O0(n){const{inputs:t,backend:e,attrs:r}=n,{input:s}=t,{dim:i}=r,o=s.shape.length,a=s.shape.slice();let u=i;return i<0&&(J(-(o+1)<=i,()=>`Axis must be in the interval [${-(o+1)}, ${o}]`),u=o+i+1),a.splice(u,0,1),Hn({inputs:{x:s},backend:e,attrs:{shape:a}})}const $be={kernelName:C_,backendName:"cpu",kernelFunc:O0},Kz=Ba(n=>Math.expm1(n)),Lbe=Su(im,Kz),Vbe={kernelName:im,backendName:"cpu",kernelFunc:Lbe},Bbe=Rr((n,t)=>n/t),_A=ts(tm,Bbe),vA={kernelName:tm,backendName:"cpu",kernelFunc:_A},Xz=Rr((n,t)=>n-t),zbe=fA((n,t,e,r)=>({real:n-e,imag:t-r})),wA=ts(Rm,Xz,zbe),Ube={kernelName:Rm,backendName:"cpu",kernelFunc:wA};function Yz(n,t,e){const r=n.shape,s=r[0],i=r[1],o=e.data.get(n.dataId),a=o.complexTensorInfos.real,u=o.complexTensorInfos.imag,c=[s,i],p=Fe(c),m=_s("float32",p),y=_s("float32",p);for(let I=0;I<s;I++){const O=$c({inputs:{x:a},backend:e,attrs:{begin:[I,0],size:[1,i]}}),M=$c({inputs:{x:u},backend:e,attrs:{begin:[I,0],size:[1,i]}}),V=Di({inputs:{real:O,imag:M},backend:e}),{real:z,imag:G}=jbe(V,t,e),Q=gl(z,G);for(let ne=0;ne<i;ne++){const oe=KE(Q,ne);m[I*i+ne]=oe.real,y[I*i+ne]=oe.imag}e.disposeIntermediateTensorInfo(O),e.disposeIntermediateTensorInfo(M),e.disposeIntermediateTensorInfo(V)}const _=e.makeTensorInfo(c,"float32",m),w=e.makeTensorInfo(c,"float32",y),T=Di({inputs:{real:_,imag:w},backend:e});return e.disposeIntermediateTensorInfo(_),e.disposeIntermediateTensorInfo(w),T}function jbe(n,t,e){const r=Fe(n.shape),s=e.data.get(n.dataId),i=e.data.get(s.complexTensorInfos.real.dataId).values,o=e.data.get(s.complexTensorInfos.imag.dataId).values;if(function Gbe(n){return 0==(n&n-1)}(r)){const a=xA(i,o,r,t,e),u=[n.shape[0],n.shape[1]];if(t){const c=e.makeTensorInfo(u,"float32",a.real),p=e.makeTensorInfo(u,"float32",a.imag),m=e.makeTensorInfo([],"float32",Zl(r,"float32")),y=za({inputs:{x:m},backend:e}),_=vA.kernelFunc({inputs:{a:c,b:m},backend:e}),w=vA.kernelFunc({inputs:{a:p,b:y},backend:e}),T=e.data.get(_.dataId).values,I=e.data.get(w.dataId).values;return e.disposeIntermediateTensorInfo(c),e.disposeIntermediateTensorInfo(p),e.disposeIntermediateTensorInfo(m),e.disposeIntermediateTensorInfo(y),e.disposeIntermediateTensorInfo(_),e.disposeIntermediateTensorInfo(w),{real:T,imag:I}}return a}{const u=function Wbe(n,t,e){const r=new Float32Array(2*t);for(let s=0;s<t;s++){let i=0,o=0;for(let a=0;a<t;a++){const u=oB(s*a,t,e),c=KE(n,a);i+=c.real*u.real-c.imag*u.imag,o+=c.real*u.imag+c.imag*u.real}e&&(i/=t,o/=t),sB(r,i,o,s)}return r}(gl(i,o),r,t);return tB(u)}}function xA(n,t,e,r,s){if(1===e)return{real:n,imag:t};const i=gl(n,t),o=e/2,a=nB(i),u=a.real,c=a.imag,p=[u.length],m=s.makeTensorInfo(p,"float32",u),y=s.makeTensorInfo(p,"float32",c),_=Di({inputs:{real:m,imag:y},backend:s}),w=rB(i),T=w.real,I=w.imag,O=[T.length],M=s.makeTensorInfo(O,"float32",T),V=s.makeTensorInfo(O,"float32",I),z=Di({inputs:{real:M,imag:V},backend:s}),G=xA(u,c,o,r,s),Q=G.real,ne=G.imag,oe=[Q.length],de=s.makeTensorInfo(oe,"float32",Q),pe=s.makeTensorInfo(oe,"float32",ne),Te=Di({inputs:{real:de,imag:pe},backend:s}),Ae=xA(T,I,o,r,s),Oe=Ae.real,Me=Ae.imag,Pe=[Oe.length],ve=s.makeTensorInfo(Pe,"float32",Oe),Se=s.makeTensorInfo(Pe,"float32",Me),xe=Di({inputs:{real:ve,imag:Se},backend:s}),ke=iB(e,r),We=[ke.real.length],Ke=s.makeTensorInfo(We,"float32",ke.real),et=s.makeTensorInfo(We,"float32",ke.imag),Je=Di({inputs:{real:Ke,imag:et},backend:s}),tt=N0({inputs:{a:Je,b:xe},backend:s}),it=Vh({inputs:{a:Te,b:tt},backend:s}),yt=wA({inputs:{a:Te,b:tt},backend:s}),ft=Fc({inputs:{input:it},backend:s}),kt=Fc({inputs:{input:yt},backend:s}),xt=Bh({inputs:{input:it},backend:s}),jt=Bh({inputs:{input:yt},backend:s}),qt=zh({inputs:[ft,kt],backend:s,attrs:{axis:0}}),Mn=zh({inputs:[xt,jt],backend:s,attrs:{axis:0}}),qn=s.data.get(qt.dataId).values,xr=s.data.get(Mn.dataId).values;return s.disposeIntermediateTensorInfo(m),s.disposeIntermediateTensorInfo(y),s.disposeIntermediateTensorInfo(_),s.disposeIntermediateTensorInfo(M),s.disposeIntermediateTensorInfo(V),s.disposeIntermediateTensorInfo(z),s.disposeIntermediateTensorInfo(de),s.disposeIntermediateTensorInfo(pe),s.disposeIntermediateTensorInfo(Te),s.disposeIntermediateTensorInfo(ve),s.disposeIntermediateTensorInfo(Se),s.disposeIntermediateTensorInfo(xe),s.disposeIntermediateTensorInfo(Ke),s.disposeIntermediateTensorInfo(et),s.disposeIntermediateTensorInfo(Je),s.disposeIntermediateTensorInfo(tt),s.disposeIntermediateTensorInfo(it),s.disposeIntermediateTensorInfo(yt),s.disposeIntermediateTensorInfo(ft),s.disposeIntermediateTensorInfo(xt),s.disposeIntermediateTensorInfo(kt),s.disposeIntermediateTensorInfo(jt),s.disposeIntermediateTensorInfo(qt),s.disposeIntermediateTensorInfo(Mn),{real:qn,imag:xr}}const qbe={kernelName:"FFT",backendName:"cpu",kernelFunc:function Hbe(n){const{inputs:t,backend:e}=n,{input:r}=t,s=Fe(r.shape),i=r.shape[r.shape.length-1],a=Hn({inputs:{x:r},backend:e,attrs:{shape:[s/i,i]}}),u=Yz(a,!1,e),c=Hn({inputs:{x:u},backend:e,attrs:{shape:r.shape}});return e.disposeIntermediateTensorInfo(a),e.disposeIntermediateTensorInfo(u),c}};function TA(n){const{backend:t,attrs:e}=n,{shape:r,value:s,dtype:i}=e,o=i||uh(s),a=Ar(o,Fe(r));return function Xbe(n,t,e){n.fill(t)}(a,s),t.makeTensorInfo(r,o,a)}const Kbe={kernelName:wC,backendName:"cpu",kernelFunc:TA},Ybe={kernelName:xC,backendName:"cpu",kernelFunc:({inputs:n,backend:e})=>{const{image:r}=n,s=e,i=_s(r.dtype,Fe(r.shape)),[o,a,u,c]=r.shape,p=s.data.get(r.dataId).values;for(let y=0;y<o;y++){const _=y*u*a*c;for(let w=0;w<a;w++){const T=w*(u*c);for(let I=0;I<u;I++){const O=I*c;for(let M=0;M<c;M++){const V=Math.round(u-I-1),z=_+T+O+M;let G=p[z];V>=0&&V<u&&(G=p[_+T+V*c+M]),i[z]=G}}}}return{dataId:s.write(i,r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}},Zz=Ba(n=>Math.floor(n)),Zbe=Su(om,Zz),Qbe={kernelName:om,backendName:"cpu",kernelFunc:Zbe},Jbe=Rr((n,t)=>Math.floor(n/t)),e_e=ts(am,Jbe,null,"int32"),t_e={kernelName:am,backendName:"cpu",kernelFunc:e_e},r_e={kernelName:dv,backendName:"cpu",kernelFunc:function n_e(n){const{inputs:t,backend:e,attrs:r}=n,{x:s,filter:i,bias:o,preluActivationWeights:a}=t,{strides:u,pad:c,dataFormat:p,dilations:m,dimRoundingMode:y,activation:_,leakyreluAlpha:w}=r;let T=Uz({inputs:{x:s,filter:i},backend:e,attrs:{strides:u,pad:c,dataFormat:p,dilations:m,dimRoundingMode:y}});if(o){const I=T;if("NCHW"===p&&1===o.shape.length&&1!==o.shape[0]){const O=Hn({inputs:{x:o},backend:e,attrs:{shape:[o.shape[0],1,1]}});T=Vh({inputs:{a:T,b:O},backend:e}),e.disposeIntermediateTensorInfo(O)}else T=Vh({inputs:{a:T,b:o},backend:e});e.disposeIntermediateTensorInfo(I)}if(_){const I=T;if("NCHW"===p&&"prelu"===_&&1===a.shape.length&&1!==a.shape[0]){const O=Hn({inputs:{x:a},backend:e,attrs:{shape:[a.shape[0],1,1]}});T=A0(e,T,_,O,w),e.disposeIntermediateTensorInfo(O)}else T=A0(e,T,_,a,w);e.disposeIntermediateTensorInfo(I)}return T}},i_e={kernelName:hv,backendName:"cpu",kernelFunc:function s_e(n){const{inputs:t,backend:e,attrs:r}=n,{x:s,filter:i,bias:o,preluActivationWeights:a}=t,{strides:u,pad:c,dataFormat:p,dilations:m,dimRoundingMode:y,activation:_,leakyreluAlpha:w}=r;let T=jz({inputs:{x:s,filter:i},backend:e,attrs:{strides:u,pad:c,dataFormat:p,dilations:m,dimRoundingMode:y}});if(o){const I=T;T=Vh({inputs:{a:T,b:o},backend:e}),e.disposeIntermediateTensorInfo(I)}if(_){const I=T;T=A0(e,T,_,a,w),e.disposeIntermediateTensorInfo(I)}return T}};function Qz(n,t,e,r,s,i,o,a,u){const c=tn([r,i],e);for(let p=0;p<r;p++){const m=[];let y=0;for(let _=0;_<s;_++){const w=n[p*s+_];y+=w*o[_],m.push(w)}if(y<0||y>=u/i)throw new Error(`Invalid indices: ${m} does not index into ${a}`);for(let _=0;_<i;_++)c.values[p*i+_]=t.get(...t.indexToLoc(y*i+_))}return c}const a_e={kernelName:TC,backendName:"cpu",kernelFunc:function o_e(n){const{inputs:t,backend:e}=n,{params:r,indices:s}=t,i=Fe(r.shape),o=s.shape,a=o[o.length-1],[u,c,p,m]=zE(r,s);if(0===c)return e.makeTensorInfo(u,r.dtype,[]);const w=Qz(e.data.get(s.dataId).values,e.bufferSync(r),r.dtype,c,a,p,m,r.shape,i);return e.makeTensorInfo(u,r.dtype,w.values)}};function Jz(n,t,e){const r=tn(e,n.dtype);for(let s=0;s<r.size;++s){const o=r.indexToLoc(s).slice(),c=t.locToIndex([o[0],o[2]]);o[2]=t.values[c];const p=n.locToIndex(o);0<=p&&p<n.values.length&&(r.values[s]=n.values[p])}return r}const u_e={kernelName:E_,backendName:"cpu",kernelFunc:function l_e(n){const{inputs:t,backend:e,attrs:r}=n,{x:s,indices:i}=t,{axis:o,batchDims:a}=r;St([s,i],"gatherV2");const u=sn(o,s.shape)[0],c=e.data.get(i.dataId).values,p=s.shape[u];for(let z=0;z<c.length;++z){const G=c[z];J(G<=p-1&&G>=0,()=>`GatherV2: the index value ${G} is not in [0, ${p-1}]`)}let m=a;null==a&&(m=0);const y=Fe(i.shape),_=rD(s,i,u,m),w=Hn({inputs:{x:s},backend:e,attrs:{shape:[_.batchSize,_.outerSize,_.dimSize,_.sliceSize]}}),T=Hn({inputs:{x:i},backend:e,attrs:{shape:[_.batchSize,y/_.batchSize]}}),I=[_.batchSize,_.outerSize,y/_.batchSize,_.sliceSize],O=e.bufferSync(T),V=Jz(e.bufferSync(w),O,I);return e.disposeIntermediateTensorInfo(w),e.disposeIntermediateTensorInfo(T),e.makeTensorInfo(_.outputShape,V.dtype,V.values)}},eU=Rr((n,t)=>n>t?1:0),c_e=ts(D_,eU,null,"bool"),d_e={kernelName:D_,backendName:"cpu",kernelFunc:c_e},tU=Rr((n,t)=>n>=t?1:0),h_e=ts(lm,tU,null,"bool"),p_e={kernelName:lm,backendName:"cpu",kernelFunc:h_e},m_e={kernelName:SC,backendName:"cpu",kernelFunc:function f_e(n){const{inputs:t,backend:e}=n,{input:r}=t,s=Fe(r.shape),i=r.shape[r.shape.length-1],a=Hn({inputs:{x:r},backend:e,attrs:{shape:[s/i,i]}}),u=Yz(a,!0,e),c=Hn({inputs:{x:u},backend:e,attrs:{shape:r.shape}});return e.disposeIntermediateTensorInfo(a),e.disposeIntermediateTensorInfo(u),c}},g_e=Rn(cm,n=>Number.isFinite(n)?1:0,"bool"),y_e={kernelName:cm,backendName:"cpu",kernelFunc:g_e},b_e=Rn(dm,n=>Math.abs(n)===1/0?1:0,"bool"),__e={kernelName:dm,backendName:"cpu",kernelFunc:b_e},v_e=Rn(hm,n=>Number.isNaN(n)?1:0,"bool"),w_e={kernelName:hm,backendName:"cpu",kernelFunc:v_e},nU=Rr((n,t)=>n<t?1:0),x_e=ts(k_,nU,null,"bool"),T_e={kernelName:k_,backendName:"cpu",kernelFunc:x_e},rU=Rr((n,t)=>n<=t?1:0),S_e=ts(N_,rU,null,"bool"),C_e={kernelName:N_,backendName:"cpu",kernelFunc:S_e};function sU(n,t,e){const r=(t-n)/(e-1),s=ks(e,"float32");s[0]=n;for(let i=1;i<s.length;i++)s[i]=s[i-1]+r;return s}const E_e={kernelName:IC,backendName:"cpu",kernelFunc:function I_e(n){const{backend:t,attrs:e}=n,{start:r,stop:s,num:i}=e,o=sU(r,s,i);return t.makeTensorInfo([o.length],"float32",o)}},iU=Ba(n=>Math.log(n)),D_e=Su(pm,iU),A_e={kernelName:pm,backendName:"cpu",kernelFunc:D_e},k_e=Rn(fm,n=>Math.log1p(n)),N_e={kernelName:fm,backendName:"cpu",kernelFunc:k_e},O_e=Rr((n,t)=>n&&t),R_e=ts(O_,O_e,null,"bool"),M_e={kernelName:O_,backendName:"cpu",kernelFunc:R_e},P_e=Rn(R_,n=>n?0:1,"bool"),F_e={kernelName:R_,backendName:"cpu",kernelFunc:P_e},$_e=Rr((n,t)=>n||t),L_e=ts(M_,$_e,null,"bool"),V_e={kernelName:M_,backendName:"cpu",kernelFunc:L_e},z_e={kernelName:P_,backendName:"cpu",kernelFunc:function B_e(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{depthRadius:i,bias:o,alpha:a,beta:u}=r;St(s,"LRN");const c=s.shape[3],p=c-1,m=e.data.get(s.dataId).values,y=Fe(s.shape),_=new Float32Array(y);function w(T){const I=T%c;let O=T-I+Math.max(0,I-i);const M=T-I+Math.min(I+i,p);let V=0;for(;O<=M;O++){const z=m[O];V+=z*z}return V}for(let T=0;T<y;T++){const I=w(T),O=m[T]*Math.pow(o+a*I,-u);_[T]=O}return e.makeTensorInfo(s.shape,s.dtype,_)}},j_e={kernelName:EC,backendName:"cpu",kernelFunc:function U_e(n){const{inputs:t,backend:e,attrs:r}=n,{x:s,y:i,dy:o}=t,{depthRadius:a,bias:u,alpha:c,beta:p}=r;St(o,"LRNGrad");const m=Fe(o.shape),y=o.shape[3],_=e.data.get(o.dataId).values,w=e.data.get(s.dataId).values,T=e.data.get(i.dataId).values,I=new Float32Array(m),O=m;for(let M=0;M<O;M++){const V=M%y,z=M-V+Math.max(0,V-a),G=M-V+Math.min(y,V+a+1);let Q=0;for(let ne=z;ne<G;ne++)Q+=Math.pow(w[ne],2);Q=c*Q+u;for(let ne=z;ne<G;ne++){let oe=-2*c*p*w[ne]*T[M]/Q;M===ne&&(oe+=Math.pow(Q,-p)),oe*=_[M],I[ne]+=oe}}return e.makeTensorInfo(o.shape,s.dtype,I)}};function oU(n,t,e,r){const s=_s(r,Fe(e));for(let i=0;i<s.length;++i){const o=i*t;let a=n[o];for(let u=0;u<t;++u){const c=n[o+u];(Number.isNaN(c)||c>a)&&(a=c)}s[i]=a}return s}function aU(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{reductionIndices:i,keepDims:o}=r,a=e;let u=s.shape;const c=u.length,p=sn(i,u);let m=p;const y=ur(m,c);let _=a.data.get(s.dataId).values;if(null!=y){const z=new Array(c);for(let G=0;G<z.length;G++)z[G]=u[y[G]];_=mA(_,u,s.dtype,y,z),m=Nr(m.length,c),u=z}St(s,"max"),ws("max",m,c);const[w,T]=us(u,m),O=oU(_,Fe(T),w,s.dtype),M=a.write(O,w,s.dtype);let V=w;return o&&(V=kr(w,p)),{dataId:M,shape:V,dtype:s.dtype}}const G_e={kernelName:F_,backendName:"cpu",kernelFunc:aU},lU=Rr((n,t)=>Math.max(n,t)),W_e=ts(mm,lU),H_e={kernelName:mm,backendName:"cpu",kernelFunc:W_e},K_e={kernelName:$_,backendName:"cpu",kernelFunc:function q_e(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t;St(s,"maxPool");const{filterSize:i,strides:o,pad:a,dimRoundingMode:u}=r;J(vs(o,1),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${o} and dilations '1'`);const p=vo(s.shape,i,o,1,a,u);let m;if(1===p.filterWidth&&1===p.filterHeight&&hn(p.inShape,p.outShape))m=za({inputs:{x:s},backend:e});else{const y=e.data.get(s.dataId).values,_=Nt(s.shape),w=gA(y,0,s.dtype,_,p,"max");m=e.makeTensorInfo(p.outShape,s.dtype,w.values)}return m}},Y_e={kernelName:L_,backendName:"cpu",kernelFunc:function X_e(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{filterSize:i,strides:o,pad:a,dimRoundingMode:u,dataFormat:c}=r;St(s,"maxPool3d");const p=pl(s.shape,i,o,1,a,u,c),y=$z(e.data.get(s.dataId).values,0,s.dtype,Nt(s.shape),p,"max");return e.makeTensorInfo(y.shape,"float32",y.values)}},Q_e={kernelName:AC,backendName:"cpu",kernelFunc:function Z_e(n){const{inputs:t,backend:e,attrs:r}=n,{dy:s,input:i}=t,{filterSize:o,strides:a,pad:u,dimRoundingMode:c}=r;St([s,i],"maxPool3DGrad");const p=pl(i.shape,o,a,1,u,c),y=function dye(n,t){const e=tn(t.outShape,"int32"),r=t.strideDepth,s=t.strideHeight,i=t.strideWidth,o=t.dilationDepth,a=t.dilationHeight,u=t.dilationWidth,c=t.effectiveFilterDepth,p=t.effectiveFilterHeight,m=t.effectiveFilterWidth,y=t.padInfo.front,_=t.padInfo.top,w=t.padInfo.left;for(let T=0;T<t.batchSize;++T)for(let I=0;I<t.inChannels;++I)for(let O=0;O<t.outDepth;++O){const M=O*r-y;let V=M;for(;V<0;)V+=o;const z=Math.min(t.inDepth,c+M);for(let G=0;G<t.outHeight;++G){const Q=G*s-_;let ne=Q;for(;ne<0;)ne+=a;const oe=Math.min(t.inHeight,p+Q);for(let de=0;de<t.outWidth;++de){const pe=de*i-w;let Te=pe;for(;Te<0;)Te+=u;const Ae=Math.min(t.inWidth,m+pe);let Oe=Number.NEGATIVE_INFINITY,Me=-1;for(let Pe=V;Pe<z;Pe+=o){const ve=Pe-M;for(let Se=ne;Se<oe;Se+=a){const xe=Se-Q;for(let ke=Te;ke<Ae;ke+=u){const We=ke-pe,Ke=n.get(T,Pe,Se,ke,I);Ke>=Oe&&(Oe=Ke,Me=ve*p*m+xe*p+We)}}}e.set(Me,T,O,G,de,I)}}}return e}(e.bufferSync(i),p),_=p.strideDepth,w=p.strideHeight,T=p.strideWidth,I=p.dilationDepth,O=p.dilationHeight,M=p.dilationWidth,V=p.effectiveFilterDepth,z=p.effectiveFilterHeight,G=p.effectiveFilterWidth,Q=V-1-p.padInfo.front,ne=G-1-p.padInfo.left,oe=z-1-p.padInfo.top,de=tn(i.shape,"float32"),pe=e.bufferSync(s);for(let Te=0;Te<p.batchSize;++Te)for(let Ae=0;Ae<p.inChannels;++Ae)for(let Oe=0;Oe<p.inDepth;++Oe)for(let Me=0;Me<p.inHeight;++Me)for(let Pe=0;Pe<p.inWidth;++Pe){const ve=Oe-Q,Se=Me-oe,xe=Pe-ne;let ke=0;for(let We=0;We<V;We+=I){const Ke=(ve+We)/_;if(!(Ke<0||Ke>=p.outDepth||Math.floor(Ke)!==Ke))for(let et=0;et<z;et+=O){const Je=(Se+et)/w;if(!(Je<0||Je>=p.outHeight||Math.floor(Je)!==Je))for(let tt=0;tt<G;tt+=M){const it=(xe+tt)/T;if(it<0||it>=p.outWidth||Math.floor(it)!==it)continue;const kt=V*z*G-1-y.get(Te,Ke,Je,it,Ae)===We*z*G+et*G+tt?1:0;0!==kt&&(ke+=pe.get(Te,Ke,Je,it,Ae)*kt)}}}de.set(ke,Te,Oe,Me,Pe,Ae)}return e.makeTensorInfo(de.shape,de.dtype,de.values)}},eve={kernelName:DC,backendName:"cpu",kernelFunc:function J_e(n){const{inputs:t,backend:e,attrs:r}=n,{dy:s,input:i,output:o}=t,a=i;St([i,o],"maxPoolGrad");const{filterSize:u,strides:c,pad:p,dimRoundingMode:m}=r,y=vo(a.shape,u,c,1,p,m),_=e.data.get(a.dataId).values,w=tn(y.outShape,a.dtype,Fz(_,a.shape,a.dtype,y).values),T=y.strideHeight,I=y.strideWidth,O=y.dilationHeight,M=y.dilationWidth,V=y.effectiveFilterHeight,z=y.effectiveFilterWidth,G=z-1-y.padInfo.left,Q=V-1-y.padInfo.top,ne=tn(a.shape,"float32"),oe=e.data.get(s.dataId).values,de=tn(s.shape,"float32",oe);for(let pe=0;pe<y.batchSize;++pe)for(let Te=0;Te<y.inChannels;++Te)for(let Ae=0;Ae<y.inHeight;++Ae)for(let Oe=0;Oe<y.inWidth;++Oe){const Me=Ae-Q,Pe=Oe-G;let ve=0;for(let Se=0;Se<V;Se+=O){const xe=(Me+Se)/T;if(!(xe<0||xe>=y.outHeight||Math.floor(xe)!==xe))for(let ke=0;ke<z;ke+=M){const We=(Pe+ke)/I;if(We<0||We>=y.outWidth||Math.floor(We)!==We)continue;const Je=V*z-1-w.get(pe,xe,We,Te)===Se*z+ke?1:0;0!==Je&&(ve+=de.get(pe,xe,We,Te)*Je)}}ne.set(ve,pe,Ae,Oe,Te)}return e.makeTensorInfo(ne.shape,ne.dtype,ne.values)}},nve={kernelName:kC,backendName:"cpu",kernelFunc:({inputs:n,attrs:t,backend:e})=>{const{x:r}=n,{filterSize:s,strides:i,pad:o,includeBatchInIndex:a}=t,u=e;St(r,"MaxPoolWithArgmax");const c=u.data.get(r.dataId).values,p=vo(r.shape,s,i,[1,1],o),[m,y]=function tve(n,t,e,r,s){const o=gA(n,0,e,Nt(t),s,"max"),a=Fz(n,t,e,s,!0,r);return[o.values,a.values]}(c,r.shape,r.dtype,a,p),_=u.write(m,p.outShape,r.dtype),w=u.write(y,p.outShape,r.dtype);return[{dataId:_,shape:p.outShape,dtype:r.dtype},{dataId:w,shape:p.outShape,dtype:"int32"}]}},sve={kernelName:V_,backendName:"cpu",kernelFunc:function rve(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{axis:i,keepDims:o}=r,a=sn(i,s.shape),p=Fe(us(s.shape,a)[1]),m=[],y=e.makeTensorInfo([],"float32",new Float32Array([p]));m.push(y);const _=Cu({inputs:{x:s},backend:e,attrs:{dtype:"float32"}});m.push(_);const w=_A({inputs:{a:_,b:y},backend:e});m.push(w);const T=wg({inputs:{x:w},backend:e,attrs:{axis:i,keepDims:o}});return m.forEach(I=>e.disposeIntermediateTensorInfo(I)),T}},ove={kernelName:B_,backendName:"cpu",kernelFunc:function ive(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{axis:i,keepDims:o}=r;St(s,"min");const a=sn(i,s.shape);let u=a;const c=ur(u,s.shape.length);let p=s;null!=c&&(p=ui({inputs:{x:s},backend:e,attrs:{perm:c}}),u=Nr(u.length,s.shape.length)),ws("min",u,p.shape.length);const[m,y]=us(p.shape,u),_=Fe(y),w=ks(Fe(m),p.dtype),T=e.data.get(p.dataId).values;for(let O=0;O<w.length;++O){const M=O*_;let V=T[M];for(let z=0;z<_;++z){const G=T[M+z];(Number.isNaN(G)||G<V)&&(V=G)}w[O]=V}null!=c&&e.disposeIntermediateTensorInfo(p);const I=e.makeTensorInfo(m,p.dtype,w);if(o){const M=Hn({inputs:{x:I},backend:e,attrs:{shape:kr(m,a)}});return e.disposeIntermediateTensorInfo(I),M}return I}},uU=Rr((n,t)=>Math.min(n,t)),ave=ts(gm,uU),lve={kernelName:gm,backendName:"cpu",kernelFunc:ave},cve={kernelName:z_,backendName:"cpu",kernelFunc:function uve(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{paddings:i,mode:o}=r;St(s,"mirrorPad");const a=i.map((V,z)=>V[0]+s.shape[z]+V[1]),u=i.map(V=>V[0]),c=i.map((V,z)=>V[0]+s.shape[z]),p="reflect"===o?0:1,m=e.data.get(s.dataId).values,y=s.shape.length,_=Nt(s.shape),w=Fe(a),T=a.length,I=Nt(a),O=_s(s.dtype,w);for(let V=0;V<w;V++){let z=ch(V,T,I);for(let Q=0;Q<T;Q++)z[Q]<u[Q]?z[Q]=2*u[Q]-z[Q]-p:z[Q]>=c[Q]&&(z[Q]=2*(c[Q]-1)-z[Q]+p);z=z.map((Q,ne)=>Q-u[ne]);const G=Ia(z,y,_);O[V]=m[G]}return{dataId:e.write(O,a,s.dtype),shape:a,dtype:s.dtype}}},dve=Rr((n,t)=>{const e=n%t;return n<0&&t<0||n>=0&&t>=0?e:(e+t)%t}),hve=ts(ym,dve),pve={kernelName:ym,backendName:"cpu",kernelFunc:hve};function cU(n){const{inputs:t,backend:e,attrs:r}=n,{logits:s}=t,{dim:i}=r,o=s.shape.length;let a=i;if(-1===a&&(a=o-1),a!==o-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${o} and dim was ${a}`);const u=sn([a],s.shape),c=aU({inputs:{x:s},backend:e,attrs:{reductionIndices:u,keepDims:!1}}),p=kr(c.shape,u),m=Hn({inputs:{x:c},backend:e,attrs:{shape:p}}),y=wA({inputs:{a:s,b:m},backend:e}),_=qz({inputs:{x:y},backend:e}),w=wg({inputs:{x:_},backend:e,attrs:{axis:u,keepDims:!1}}),T=Hn({inputs:{x:w},backend:e,attrs:{shape:p}}),I=_A({inputs:{a:_,b:T},backend:e});return e.disposeIntermediateTensorInfo(c),e.disposeIntermediateTensorInfo(m),e.disposeIntermediateTensorInfo(y),e.disposeIntermediateTensorInfo(_),e.disposeIntermediateTensorInfo(w),e.disposeIntermediateTensorInfo(T),I}const fve={kernelName:iv,backendName:"cpu",kernelFunc:cU},gve={kernelName:NC,backendName:"cpu",kernelFunc:function mve(n){const{inputs:t,backend:e,attrs:r}=n,{logits:s}=t,{numSamples:i,seed:o,normalized:a}=r;St(s,"multinomial");const u=a?s:cU({inputs:{logits:s},backend:e,attrs:{dim:-1}}),c=u.shape[0],p=u.shape[1],m=e.data.get(u.dataId).values,y=[c,i],_=ks(Fe(y),"int32");for(let w=0;w<c;++w){const T=w*p,I=new Float32Array(p-1);I[0]=m[T];for(let V=1;V<I.length;++V)I[V]=I[V-1]+m[T+V];const O=Lv.alea(o.toString()),M=w*i;for(let V=0;V<i;++V){const z=O();_[M+V]=I.length;for(let G=0;G<I.length;G++)if(z<I[G]){_[M+V]=G;break}}}return a||e.disposeIntermediateTensorInfo(u),e.makeTensorInfo(y,"int32",_)}};function dU(n,t,e){const r=Zl(-1,e);return bA([],t,r,n,e)}const bve={kernelName:U_,backendName:"cpu",kernelFunc:function yve(n){const{inputs:t,backend:e}=n,{x:r}=t;St(r,"neg");const s=e.data.get(r.dataId).values,[i,o]=dU(s,r.shape,r.dtype);return e.makeTensorInfo(o,r.dtype,i)}},_ve=AE,wve={kernelName:OC,backendName:"cpu",kernelFunc:function vve(n){const{inputs:t,backend:e,attrs:r}=n,{boxes:s,scores:i}=t,{maxOutputSize:o,iouThreshold:a,scoreThreshold:u}=r;St(s,"NonMaxSuppression");const c=e.data.get(s.dataId).values,p=e.data.get(i.dataId).values,{selectedIndices:m}=_ve(c,p,o,a,u);return e.makeTensorInfo([m.length],"int32",new Int32Array(m))}},xve=kE,Sve={kernelName:RC,backendName:"cpu",kernelFunc:function Tve(n){const{inputs:t,backend:e,attrs:r}=n,{boxes:s,scores:i}=t,{maxOutputSize:o,iouThreshold:a,scoreThreshold:u,padToMaxOutputSize:c}=r;St(s,"NonMaxSuppressionPadded");const p=e.data.get(s.dataId).values,m=e.data.get(i.dataId).values,{selectedIndices:y,validOutputs:_}=xve(p,m,o,a,u,c);return[e.makeTensorInfo([y.length],"int32",new Int32Array(y)),e.makeTensorInfo([],"int32",new Int32Array([_]))]}},Cve=NE,Eve={kernelName:MC,backendName:"cpu",kernelFunc:function Ive(n){const{inputs:t,backend:e,attrs:r}=n,{boxes:s,scores:i}=t,{maxOutputSize:o,iouThreshold:a,scoreThreshold:u,softNmsSigma:c}=r;St(s,"NonMaxSuppressionWithScore");const p=e.data.get(s.dataId).values,m=e.data.get(i.dataId).values,y=o,_=a,w=u,T=c,{selectedIndices:I,selectedScores:O}=Cve(p,m,y,_,w,T);return[e.makeTensorInfo([I.length],"int32",new Int32Array(I)),e.makeTensorInfo([O.length],"float32",new Float32Array(O))]}},hU=Rr((n,t)=>n!==t?1:0),Dve=ts(j_,hU,null,"bool"),Ave={kernelName:j_,backendName:"cpu",kernelFunc:Dve},Nve={kernelName:W_,backendName:"cpu",kernelFunc:function kve(n){const{inputs:t,backend:e,attrs:r}=n,{indices:s}=t,{dtype:i,depth:o,onValue:a,offValue:u}=r;St(s,"oneHot");const c=Fe(s.shape),p=new Float32Array(c*o);p.fill(u);const m=e.data.get(s.dataId).values;for(let y=0;y<c;++y)m[y]>=0&&m[y]<o&&(p[y*o+m[y]]=a);return e.makeTensorInfo([...s.shape,o],i,p)}};function R0(n){const{inputs:t,backend:e}=n,{x:r}=t;if("string"===r.dtype)throw new Error("zerosLike is not supported for string tensors");if("complex64"===r.dtype){const s=Fc({inputs:{input:r},backend:e}),i=R0({inputs:{x:s},backend:e}),o=Bh({inputs:{input:r},backend:e}),a=R0({inputs:{x:o},backend:e}),u=Di({inputs:{real:i,imag:a},backend:e});return e.disposeIntermediateTensorInfo(s),e.disposeIntermediateTensorInfo(i),e.disposeIntermediateTensorInfo(o),e.disposeIntermediateTensorInfo(a),u}return TA({backend:e,attrs:{shape:r.shape,value:0,dtype:r.dtype}})}const Ove={kernelName:uv,backendName:"cpu",kernelFunc:R0},Rve={kernelName:G_,backendName:"cpu",kernelFunc:function pU(n){const{inputs:t,backend:e}=n,{x:r}=t;if("string"===r.dtype)throw new Error("onesLike is not supported for string tensors");if("complex64"===r.dtype){const s=Fc({inputs:{input:r},backend:e}),i=pU({inputs:{x:s},backend:e}),o=Bh({inputs:{input:r},backend:e}),a=R0({inputs:{x:o},backend:e}),u=Di({inputs:{real:i,imag:a},backend:e});return e.disposeIntermediateTensorInfo(s),e.disposeIntermediateTensorInfo(i),e.disposeIntermediateTensorInfo(o),e.disposeIntermediateTensorInfo(a),u}return TA({backend:e,attrs:{shape:r.shape,value:1,dtype:r.dtype}})}};function fU(n){const{inputs:t,backend:e,attrs:r}=n,{axis:s}=r;if(1===t.length)return O0({inputs:{input:t[0]},backend:e,attrs:{dim:s}});const i=t[0].shape,o=t[0].dtype;t.forEach(p=>{xi(i,p.shape,"All tensors passed to stack must have matching shapes"),J(o===p.dtype,()=>"All tensors passed to stack must have matching dtypes")});const a=[],c=zh({inputs:t.map(p=>{const m=O0({inputs:{input:p},backend:e,attrs:{dim:s}});return a.push(m),m}),backend:e,attrs:{axis:s}});return a.forEach(p=>e.disposeIntermediateTensorInfo(p)),c}const Mve={kernelName:H_,backendName:"cpu",kernelFunc:fU},mU={kernelName:q_,backendName:"cpu",kernelFunc:function Pve(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{paddings:i,constantValue:o}=r;St(s,"pad");const a=i.map((M,V)=>M[0]+s.shape[V]+M[1]),u=i.map(M=>M[0]),c=e.data.get(s.dataId).values,p=Fe(s.shape),m=s.shape.length,y=Nt(s.shape),_=Fe(a),w=a.length,T=Nt(a),I=_s(s.dtype,_);0!==o&&I.fill(o);for(let M=0;M<p;M++)I[Ia(ch(M,m,y).map((Q,ne)=>Q+u[ne]),w,T)]=c[M];return{dataId:e.write(I,a,s.dtype),shape:a,dtype:s.dtype}}},Fve=Rr((n,t)=>Math.pow(n,t)),$ve=ts(_m,Fve),Lve={kernelName:_m,backendName:"cpu",kernelFunc:$ve};function gU(n,t,e,r){const[s,i]=us(n,r),o=Ti(t,"int32"),a=ks(Fe(s),o),u=Fe(i);for(let c=0;c<a.length;++c){const p=c*u;let m=1;for(let y=0;y<u;++y)m*=e[p+y];a[c]=m}return{outVals:a,outShape:s,outDtype:o}}const Bve={kernelName:X_,backendName:"cpu",kernelFunc:function Vve(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{axis:i,keepDims:o}=r;St(s,"prod");const a=s.shape.length,u=sn(i,s.shape),c=ur(u,a);let p=u,m=s;const y=[];null!=c&&(m=ui({inputs:{x:s},backend:e,attrs:{perm:c}}),y.push(m),p=Nr(p.length,a));const _=e.data.get(m.dataId).values,{outVals:w,outShape:T,outDtype:I}=gU(m.shape,m.dtype,_,p);let O=T;return o&&(O=kr(T,u)),y.forEach(M=>e.disposeIntermediateTensorInfo(M)),e.makeTensorInfo(O,I,w)}};function yU(n,t){const e=n.slice(0,t);for(;e.length<t;)e.push(1);for(let r=t;r<n.length;r++)e[t-1]*=n[r];return e}function bU(n,t,e,r,s,i,o,a){if(0===n.length)throw new Error("paramsNestedSplits must be non empty");if(0===t[0].length)throw new Error("Split tensors must not be scalars");if(function zve(n,t,e){n.forEach((r,s)=>{if(r<0||r>=e){const i=ch(s,t.length,Nt(t)).join(",");throw new Error(`indices[${i}] = ${r} is not in [0, ${e})`)}})}(i,o,t[0][0]-1),0===r.length)throw new Error("params.rank must be nonzero");const c=r[0],{outSplits:p,valueSlices:m,numValues:y}=function jve(n,t,e,r){const s=[];let i=0;const a=new Array(t.length-1+e.length).fill(null).map(()=>[0]);!function Uve(n,t){for(let e=0;e<n.length;++e){const r=n[e],s=e===n.length-1?t:n[e+1].length;if(0===r.length)throw new Error("Ragged splits may not be empty");if(r[0]<0)throw new Error("Ragged splits must be non-negative");if(r[r.length-1]>s)throw new Error("Ragged splits must not point past values");for(let i=1;i<r.length;++i)if(r[i-1]>r[i])throw new Error("Ragged splits must be sorted in ascending order")}}(e,r);let u=1;for(let c=0;c<t.length-1;++c){u*=t[c];const p=t[c+1];for(let m=1;m<u+1;++m)a[c].push(m*p)}for(let c=0;c<n.length;++c){let p=n[c],m=n[c]+1;for(let y=0;y<e.length;++y){const _=e[y],w=y+t.length-1;if(w>=0){const T=a[w],I=T[T.length-1]-_[p];for(let O=p;O<m;++O)a[w].push(_[O+1]+I)}p=_[p],m=_[m]}m!==p&&(s.push([p,m]),i+=m-p)}return{outSplits:a,valueSlices:s,numValues:i}}(i,o,n,c),_=function Gve(n){const t=[];for(let e=0;e<n.length;++e){const s=Ar("int32",n[e].length);t.push(s),n[e].forEach((i,o)=>s[o]=i)}return t}(p),w=function Hve(n,t,e,r,s){const i=t.slice();i[0]=s;const o=Ar(e,Fe(i)),a=n.length;return function Wve(n,t,e,r,s,i){const o=yU(t,2)[1],a=yU(i,2)[1];let u=0;for(const c of e)for(let p=c[0];p<c[1];++p){for(let m=0;m<r;++m)s[u*a+m]=n[p*o+m];++u}}(n,t,r,0===a?0:a/t[0],o,i),[o,i]}(e,r,s,m,y);return[_,w[0],w[1]]}const Kve={kernelName:PC,backendName:"cpu",kernelFunc:function qve(n){const{inputs:t,backend:e,attrs:r}=n,{paramsNestedSplits:s,paramsDenseValues:i,indices:o}=t,u=s.map(O=>e.data.get(O.dataId).values),c=s.map(O=>O.shape),p=e.data.get(i.dataId).values,m=e.data.get(o.dataId).values,[y,_,w]=bU(u,c,p,i.shape,i.dtype,m,o.shape),T=y.map(O=>e.makeTensorInfo([O.length],"int32",O)),I=e.makeTensorInfo(w,i.dtype,_);return T.concat([I])}},_U=2147483647;function vU(n,t,e,r,s,i,o){if(t.length>1)throw new Error("starts must be a scalar or vector");if(s.length>1)throw new Error("limits must be a scalar or vector");if(o.length>1)throw new Error("deltas must be a scalar or vector");const a=0===t.length,u=0===s.length,c=0===o.length,p=[];a||p.push(t[0]),u||p.push(s[0]),c||p.push(o[0]);for(let I=1;I<p.length;++I)if(p[I]!==p[I-1])throw new Error("starts, limits, and deltas must have the same shape");const m=0===p.length?1:p[0],y=Ar("int32",m+1);y[0]=0;for(let I=0;I<m;++I){const O=a?n[0]:n[I],M=u?r[0]:r[I],V=c?i[0]:i[I];if(0===V)throw new Error("Requires delta != 0");let z;if(V>0&&M<O||V<0&&M>O)z=0;else if(z=Math.ceil(Math.abs((M-O)/V)),z>_U)throw new Error(`Requires ((limit - start) / delta) <= ${_U}`);y[I+1]=y[I]+z}const w=Ar(e,y[m]);let T=0;for(let I=0;I<m;++I){const O=y[I+1]-y[I];let M=a?n[0]:n[I];const V=c?i[0]:i[I];for(let z=0;z<O;++z)w[T++]=M,M+=V}return[y,w]}const Yve={kernelName:FC,backendName:"cpu",kernelFunc:function Xve(n){const{inputs:t,backend:e}=n,{starts:r,limits:s,deltas:i}=t,o=e.data.get(r.dataId).values,a=e.data.get(s.dataId).values,u=e.data.get(i.dataId).values,[c,p]=vU(o,r.shape,r.dtype,a,s.shape,u,i.shape);return[e.makeTensorInfo([c.length],"int32",c),e.makeTensorInfo([p.length],r.dtype,p)]}};var Ao=dr;class M0{constructor(t,e,r,s,i,o,a,u,c,p){this.shape=t,this.shapeShape=e,this.values=r,this.valuesShape=s,this.valuesDType=i,this.defaultValue=o,this.defaultValueShape=a,this.rowPartitionValues=u,this.rowPartitionValuesShapes=c,this.rowPartitionTypes=QV(p),this.raggedRank=JV(this.rowPartitionTypes)}getRowPartitionTypeByDimension(t){return this.rowPartitionTypes[0]===Ao.FIRST_DIM_SIZE?this.rowPartitionTypes[t+1]:this.rowPartitionTypes[t]}getRowPartitionTensor(t){return this.rowPartitionTypes[0]===Ao.FIRST_DIM_SIZE?this.rowPartitionValues[t+1]:this.rowPartitionValues[t]}getMaxWidth(t){const e=this.getRowPartitionTensor(t-1);switch(this.getRowPartitionTypeByDimension(t-1)){case Ao.VALUE_ROWIDS:return M0.getMaxWidthValueRowID(e);case Ao.ROW_SPLITS:return M0.getMaxWidthRowSplit(e);default:throw new Error(`Cannot handle partition type ${Ao[this.getRowPartitionTypeByDimension(t-1)]}`)}}static getMaxWidthRowSplit(t){const e=t.length;if(0===e||1===e)return 0;let r=0;for(let s=0;s<e-1;++s){const i=t[s+1]-t[s];i>r&&(r=i)}return r}static getMaxWidthValueRowID(t){const e=t.length;if(0===e)return 0;let r=0,s=t[0],i=0;for(let o=1;o<e;++o){const a=t[o];a!==s&&(s=a,i=Math.max(o-r,i),r=o)}return Math.max(e-r,i)}tensorShapeFromTensor(t,e,r=!0){if(0===e.length){if(-1===t[0])return[];throw new Error("The only valid scalar shape tensor is the fully unknown shape specified as -1.")}return xU(t,r)}calculateOutputSize(t){const e=this.valuesShape;eB(this.defaultValueShape,e);const s=this.tensorShapeFromTensor(this.shape,this.shapeShape),o=ZV(this.raggedRank,s,e);o[0]<0&&(o[0]=t);for(let a=1;a<=this.raggedRank;++a)o[a]<0&&(o[a]=this.getMaxWidth(a));return o}calculateFirstParentOutputIndex(t,e,r){const s=Math.min(t,r),i=[];let o=0;for(let a=0;a<s;++a,o+=e)i.push(o);for(let a=s;a<t;++a)i.push(-1);return J(i.length===t,()=>"Final length of result must be equal to firstDimension."),i}calculateOutputIndexRowSplit(t,e,r,s){const i=t.length,o=[];for(let a=0;a<i-1;++a){const u=t[a+1]-t[a];let c=Math.min(s,u),p=e[a];-1===p&&(c=0);for(let m=0;m<c;++m)o.push(p),p+=r;for(let m=0;m<u-c;++m)o.push(-1)}if(i>0&&o.length!==t[i-1])throw new Error("Invalid row split size.");return o}calculateOutputIndexValueRowID(t,e,r,s){const i=t.length,o=[];if(0===i)return[];let a=0,u=t[0];if(u>=e.length)throw new Error(`Got currentValueRowId=${u}, which is not less than ${e.length}`);let c=e[u];o.push(c);for(let p=1;p<i;++p){const m=t[p];if(m===u)c>=0&&(++a,a<s?c+=r:c=-1);else{if(a=0,u=m,m>=e.length)throw new Error(`Got nextValueRowId=${m} which is not less than ${e.length}`);c=e[m]}o.push(c)}if(o.length!==t.length)throw new Error("Invalid row ids.");return o}calculateOutputIndex(t,e,r,s){const i=this.getRowPartitionTensor(t),o=this.getRowPartitionTypeByDimension(t);switch(o){case Ao.VALUE_ROWIDS:return this.calculateOutputIndexValueRowID(i,e,r,s);case Ao.ROW_SPLITS:if(i.length-1>e.length)throw new Error(`Row partition size is greater than output size: ${i.length-1} > ${e.length}`);return this.calculateOutputIndexRowSplit(i,e,r,s);default:throw new Error(`Unsupported partition type: ${Ao[o]}`)}}getFirstDimensionSize(){const t=this.rowPartitionValues[0];if(0===this.rowPartitionTypes.length)throw new Error("No row_partition_types given.");const e=this.rowPartitionTypes[0];switch(e){case Ao.FIRST_DIM_SIZE:return t[0];case Ao.VALUE_ROWIDS:throw new Error("Cannot handle VALUE_ROWIDS in first dimension.");case Ao.ROW_SPLITS:return this.rowPartitionValuesShapes[0][0]-1;default:throw new Error(`Cannot handle type ${Ao[e]}`)}}compute(){if(this.rowPartitionValues[0].length<=0)throw new Error("Invalid first partition input. Tensor requires at least one element.");const e=this.getFirstDimensionSize(),r=this.calculateOutputSize(e),s=new Array(this.raggedRank+1);s[s.length-1]=1;for(let u=s.length-2;u>=0;--u)s[u]=s[u+1]*r[u+1];const i=xU(r,!1),o=Ar(this.valuesDType,Fe(i));if(s[0]*r[0]>0){let u=this.calculateFirstParentOutputIndex(e,s[0],r[0]);for(let c=1;c<=this.raggedRank;++c)u=this.calculateOutputIndex(c-1,u,s[c],r[c]);this.setOutput(this.raggedRank,u,o,i)}return[i,o]}setOutput(t,e,r,s){if(0===r.length)return;const i=this.values,o=r;let a=s.slice();a=a.slice(t+1);const u=Fe(a),c=e.length;let p=this.defaultValue;if(p.length!==u&&1!==p.length){const w=this.defaultValueShape;Ce(()=>{const T=be(p,w);p=Ch(T,a).dataSync()})}let m=0,y=0,_=0;for(let w=0;w<=c;++w){let T=w<c?e[w]:-1;if(T!==_){if(y<_){const I=i.subarray(m*u);wU(o.subarray(y*u),I,(_-y)*u)}if(w>=c&&(T=Math.floor(r.length/u)),T>_)if(1===this.defaultValue.length)o.subarray(_*u,T*u).fill(this.defaultValue[0]),_=T;else for(;T>_;)wU(o.slice(_*u),p,u),++_;T<0?(m=w+1,y=_):(m=w,y=_,_=y+1)}else++_}}}function wU(n,t,e){for(let r=0;r<e;r++)n[r]=t[r]}function xU(n,t){const e=[];for(let r of n){if(r<0){if(!t)throw new Error(`Dimension ${r} must be >= 0`);if(r<-1)throw new Error(`Dimension ${r} must be >= -1`);r=-1}e.push(r)}return e}function TU(n,t,e,r,s,i,o,a,u,c){return new M0(n,t,e,r,s,i,o,a,u,c).compute()}const Qve={kernelName:$C,backendName:"cpu",kernelFunc:function Zve(n){const{inputs:t,backend:e,attrs:r}=n,{shape:s,values:i,defaultValue:o,rowPartitionTensors:a}=t,{rowPartitionTypes:u}=r,c=e.data.get(s.dataId).values,p=e.data.get(i.dataId).values,m=e.data.get(o.dataId).values,y=a.map(I=>e.data.get(I.dataId).values),_=a.map(I=>I.shape),[w,T]=TU(c,s.shape,p,i.shape,i.dtype,m,o.shape,y,_,u);return e.makeTensorInfo(w,i.dtype,T)}};function SU(n,t,e,r){if(n===t||n<t&&e<0||t<n&&e>1)return ks(0,r);const u=ks(Math.abs(Math.ceil((t-n)/e)),r);t<n&&1===e&&(e=-1),u[0]=n;for(let c=1;c<u.length;c++)u[c]=u[c-1]+e;return u}const e0e={kernelName:LC,backendName:"cpu",kernelFunc:function Jve(n){const{backend:t,attrs:e}=n,{start:r,stop:s,dtype:i,step:o}=e,a=SU(r,s,o,i);return t.makeTensorInfo([a.length],i,a)}},t0e=Rn(vm,n=>1/n),n0e={kernelName:vm,backendName:"cpu",kernelFunc:t0e},s0e={kernelName:Q_,backendName:"cpu",kernelFunc:function r0e(n){const{inputs:t,backend:e,attrs:r}=n,{images:s}=t,{alignCorners:i,halfPixelCenters:o,size:a}=r;St(s,"resizeBilinear");const u=Nt(s.shape),[c,p]=a,[m,y,_,w]=s.shape,T=e.data.get(s.dataId).values,I=new Float32Array(Fe([m,c,p,w])),O=[i&&c>1?y-1:y,i&&p>1?_-1:_],M=[i&&c>1?c-1:c,i&&p>1?p-1:p];let V=0;const z=O[0]/M[0],G=O[1]/M[1];for(let Q=0;Q<m;Q++)for(let ne=0;ne<c;ne++){let oe;oe=o?z*(ne+.5)-.5:z*ne;const de=Math.max(0,Math.floor(oe)),pe=oe-de,Te=Math.min(y-1,Math.ceil(oe)),Ae=Q*u[0]+de*u[1],Oe=Q*u[0]+Te*u[1];for(let Me=0;Me<p;Me++){let Pe;Pe=o?G*(Me+.5)-.5:G*Me;const ve=Math.max(0,Math.floor(Pe)),Se=Pe-ve,xe=Math.min(_-1,Math.ceil(Pe)),ke=Ae+ve*u[2],We=Oe+ve*u[2],Ke=Ae+xe*u[2],et=Oe+xe*u[2];for(let Je=0;Je<w;Je++){const tt=T[ke+Je],it=T[We+Je],kt=tt+(T[Ke+Je]-tt)*Se;I[V++]=kt+(it+(T[et+Je]-it)*Se-kt)*pe}}}return e.makeTensorInfo([m,c,p,w],"float32",I)}},o0e={kernelName:zC,backendName:"cpu",kernelFunc:function i0e(n){const{inputs:t,backend:e,attrs:r}=n,{images:s,dy:i}=t,{alignCorners:o}=r;St([i,s],"resizeBilinearGrad");const a=Nt(s.shape),[u,c,p,m]=s.shape,[,y,_]=i.shape,w=new Float32Array(u*c*p*m),T=[o&&y>1?c-1:c,o&&_>1?p-1:p],I=[o&&y>1?y-1:y,o&&_>1?_-1:_],O=T[0]/I[0],M=T[1]/I[1],V=e.data.get(i.dataId).values;let z=0;for(let G=0;G<u;G++){const Q=G*a[0];for(let ne=0;ne<y;ne++){const oe=ne*O,de=Math.floor(oe),pe=Math.min(Math.ceil(oe),c-1),Te=Q+de*a[1],Ae=Q+pe*a[1],Oe=oe-de,Me=1-Oe;for(let Pe=0;Pe<_;Pe++){const ve=Pe*M,Se=Math.floor(ve),xe=Math.min(Math.ceil(ve),p-1),ke=ve-Se,We=1-ke,Ke=Te+Se*a[2],et=Te+xe*a[2],Je=Ae+Se*a[2],tt=Ae+xe*a[2],it=Me*We,yt=Me*ke,ft=Oe*We,kt=Oe*ke;for(let xt=0;xt<m;xt++){const jt=V[z++];w[Ke+xt]+=jt*it,w[et+xt]+=jt*yt,w[Je+xt]+=jt*ft,w[tt+xt]+=jt*kt}}}}return e.makeTensorInfo([u,p,c,m],"float32",w)}},l0e={kernelName:Z_,backendName:"cpu",kernelFunc:function a0e(n){const{inputs:t,backend:e,attrs:r}=n,{images:s}=t,{alignCorners:i,halfPixelCenters:o,size:a}=r;St(s,"resizeNearestNeighbor");const u=Nt(s.shape),[c,p]=a,[m,y,_,w]=s.shape,T=e.data.get(s.dataId).values,I=new Float32Array(m*c*p*w),O=[i&&c>1?y-1:y,i&&p>1?_-1:_],M=[i&&c>1?c-1:c,i&&p>1?p-1:p],V=O[0]/M[0],z=O[1]/M[1];let G=0;for(let Q=0;Q<m;Q++){const ne=Q*u[0];for(let oe=0;oe<c;oe++){const de=o?V*(oe+.5):V*oe;let pe=Math.min(y-1,i?Math.round(de):Math.floor(de));o&&(pe=Math.max(0,pe));const Te=ne+pe*u[1];for(let Ae=0;Ae<p;Ae++){const Oe=o?z*(Ae+.5):z*Ae;let Me=Math.min(_-1,i?Math.round(Oe):Math.floor(Oe));o&&(Me=Math.max(0,Me));const Pe=Te+Me*u[2];for(let ve=0;ve<w;ve++)I[G++]=T[Pe+ve]}}}return e.makeTensorInfo([m,c,p,w],s.dtype,I)}},c0e={kernelName:BC,backendName:"cpu",kernelFunc:function u0e(n){const{inputs:t,backend:e,attrs:r}=n,{images:s,dy:i}=t,{alignCorners:o}=r;St([i,s],"resizeNearestNeighborGrad");const a=Nt(s.shape),u=Nt(i.shape),[c,p,m,y]=s.shape,[,_,w]=i.shape,T=new Float32Array(c*p*m*y),I=e.data.get(i.dataId).values,O=[o&&_>1?p-1:p,o&&w>1?m-1:m],M=[o&&_>1?_-1:_,o&&w>1?w-1:w],V=O[0]/M[0],z=O[1]/M[1],G=1/V,Q=1/z,ne=2*Math.ceil(G)+2,oe=2*Math.ceil(Q)+2;for(let de=0;de<c;de++){const pe=de*a[0];for(let Te=0;Te<p;Te++){const Ae=pe+Te*a[1],Oe=Math.floor(Te*G),Me=Math.floor(Oe-ne/2);for(let Pe=0;Pe<m;Pe++){const ve=Ae+Pe*a[2],Se=Math.floor(Pe*Q),xe=Math.floor(Se-oe/2);for(let ke=0;ke<y;ke++){let We=0;for(let Ke=0;Ke<ne;Ke++){const et=Ke+Me;if(et<0||et>=_)continue;const Je=pe+et*u[1],tt=et*V;if(Te===Math.min(p-1,o?Math.round(tt):Math.floor(tt)))for(let yt=0;yt<oe;yt++){const ft=yt+xe;if(ft<0||ft>=w)continue;const kt=Je+ft*u[2],xt=ft*z;Pe===Math.min(m-1,o?Math.round(xt):Math.floor(xt))&&(We+=I[kt+ke])}}T[ve+ke]=We}}}}return e.makeTensorInfo(s.shape,s.dtype,T)}},h0e={kernelName:J_,backendName:"cpu",kernelFunc:function d0e(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{dims:i}=r;St(s,"reverse");const o=s.shape.length,a=sn(i,s.shape);if(0===o)return za({inputs:{x:s},backend:e});const u=new qr(s.shape,s.dtype),c=e.bufferSync(s);for(let p=0;p<u.size;p++){const m=u.indexToLoc(p),y=m.slice();a.forEach(_=>y[_]=s.shape[_]-1-y[_]),u.set(c.get(...y),...m)}return e.makeTensorInfo(u.shape,u.dtype,u.values)}},p0e={kernelName:sI,backendName:"cpu",kernelFunc:({inputs:n,attrs:t,backend:e})=>{const{image:r}=n,{radians:s,fillValue:i,center:o}=t,a=e,u=_s(r.dtype,Fe(r.shape)),[c,p,m,y]=r.shape,[_,w]=LE(o,p,m),I=Math.sin(s),O=Math.cos(s),M=a.data.get(r.dataId).values;for(let z=0;z<c;z++){const G=z*m*p*y;for(let Q=0;Q<p;Q++){const ne=Q*(m*y);for(let oe=0;oe<m;oe++){const de=oe*y;for(let pe=0;pe<y;pe++){const Te=[c,Q,oe,pe],Ae=Te[2],Oe=Te[1];let Me=(Ae-_)*O-(Oe-w)*I,Pe=(Ae-_)*I+(Oe-w)*O;Me=Math.round(Me+_),Pe=Math.round(Pe+w);let ve=i;"number"!=typeof i&&(ve=3===pe?255:i[pe]),Me>=0&&Me<m&&Pe>=0&&Pe<p&&(ve=M[G+Pe*(m*y)+Me*y+pe]),u[G+ne+de+pe]=ve}}}}return{dataId:a.write(u,r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}},f0e=Rn(Tm,n=>{const t=Math.floor(n);return n-t<.5?Math.floor(n):n-t>.5?Math.ceil(n):t%2==0?t:t+1}),m0e={kernelName:Tm,backendName:"cpu",kernelFunc:f0e},CU=Ba(n=>1/Math.sqrt(n)),g0e=Su(Sm,CU),y0e={kernelName:Sm,backendName:"cpu",kernelFunc:g0e};function Lc(n,t,e,r,s,i,o,a,u,c){const p=[r/s,s],m=n.values,y=t.values;if(0===r)return tn(e,t.dtype);const _=u instanceof qr?u:tn(p,t.dtype);"string"==typeof u||"number"==typeof u?_.values.fill(u):"boolean"==typeof u&&_.values.fill(+u);for(let w=0;w<i;w++){const T=[];let I=0;for(let O=0;O<o;O++){const M=m[w*o+O];T.push(M),I+=M*a[O]}if(I<0||I>=r/s)throw new Error(`Invalid indices: ${T} does not index into ${e}`);for(let O=0;O<s;O++)c?_.values[I*s+O]+=y[w*s+O]:_.values[I*s+O]=0===t.rank?y[0]:y[w*s+O]}return _}const _0e={kernelName:UC,backendName:"cpu",kernelFunc:function b0e(n){const{inputs:t,backend:e,attrs:r}=n,{indices:s,updates:i}=t,{shape:o}=r,{sliceRank:a,numUpdates:u,sliceSize:c,strides:p,outputSize:m}=Ec(0,s,o),T=Lc(e.bufferSync(s),e.bufferSync(i),o,m,c,u,a,p,0,!0);return e.makeTensorInfo(o,T.dtype,T.values)}};function v0e(n,t){let e=0,r=n.length,s=0;for(;e<r;)s=Math.floor((e+r)/2),n[s]<t?e=s+1:r=s;return r}function w0e(n,t){let e=0,r=n.length,s=0;for(;e<r;)s=Math.floor((e+r)/2),n[s]<=t?e=s+1:r=s;return r}const S0e={kernelName:GC,backendName:"cpu",kernelFunc:function T0e(n){const{inputs:t,backend:e,attrs:r}=n,{sortedSequence:s,values:i}=t,{side:o}=r,c=function x0e(n,t,e,r,s,i){const o=Ar("int32",e*s);for(let a=0;a<e;++a){const u=n.slice(a*r,(a+1)*r),c=a*s;for(let p=0;p<s;++p)o[c+p]="left"===i?v0e(u,t[p+c]):w0e(u,t[p+c])}return o}(e.data.get(s.dataId).values,e.data.get(i.dataId).values,s.shape[0],s.shape[1],i.shape[1],o);return e.makeTensorInfo(i.shape,"int32",c)}},I0e={kernelName:ev,backendName:"cpu",kernelFunc:function C0e(n){const{inputs:t,backend:e}=n,{condition:r,t:s,e:i}=t;St([r,s,i],"select");const o=r.shape.length,a=e.data.get(r.dataId).values,u=e.data.get(s.dataId).values,c=e.data.get(i.dataId).values,p=Ti(s.dtype,i.dtype),m=ks(Fe(s.shape),p);let y=0;const _=0===o||o>1||1===s.shape.length?1:Fe(s.shape.slice(1));for(let w=0;w<a.length;w++)for(let T=0;T<_;T++)m[y++]=1===a[w]?u[w]:c[w];return e.makeTensorInfo(s.shape,p,m)}},E0e=Xv,D0e=Yv,A0e=Rn(Cm,n=>n>=0?D0e*n:E0e*(Math.exp(n)-1)),k0e={kernelName:Cm,backendName:"cpu",kernelFunc:A0e},N0e=Rn(Dm,n=>n<0?-1:n>0?1:0),O0e={kernelName:Dm,backendName:"cpu",kernelFunc:N0e},R0e=Rn(Im,n=>Math.sin(n)),M0e={kernelName:Im,backendName:"cpu",kernelFunc:R0e},P0e=Rn(Em,n=>Math.sinh(n)),F0e={kernelName:Em,backendName:"cpu",kernelFunc:P0e},IU=Math.log(1.1920928955078125e-7)+2,$0e=Rn(km,n=>{const t=n>-IU,e=n<IU,r=Math.exp(n);let s;return s=e?r:t?n:Math.log(1+r),s}),L0e={kernelName:km,backendName:"cpu",kernelFunc:$0e},B0e={kernelName:rv,backendName:"cpu",kernelFunc:function V0e(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{blockShape:i,paddings:o}=r;St([s],"spaceToBatchND");const a=Fe(i),u=[[0,0]];u.push(...o);for(let Q=1+i.length;Q<s.shape.length;++Q)u.push([0,0]);const c=mU.kernelFunc({inputs:{x:s},backend:e,attrs:{paddings:u,constantValue:0}}),p=rg(c.shape,i,a,!1),m=sg(p.length,i.length,!1),y=ig(c.shape,i,a,!1),T=Hn({inputs:{x:c},backend:e,attrs:{shape:p}}),M=ui({inputs:{x:T},backend:e,attrs:{perm:m}}),G=Hn({inputs:{x:M},backend:e,attrs:{shape:y}});return e.disposeIntermediateTensorInfo(c),e.disposeIntermediateTensorInfo(T),e.disposeIntermediateTensorInfo(M),G}};function EU(n,t,e,r,s,i,o){const a=t[0],u=i[0],c=new Array(u),p=new Array(a),m=t[1];if(0===u){if(0!==a)throw new Error(uB(a));return[Ar(e,0),[0,m],Ar(s,0),c,p]}let y=!0,_=0;const w=new Array(u).fill(0);for(let I=0;I<a;++I){const O=n[I*m];if(O<0)throw new Error(cB(I,O));if(O>=u)throw new Error(dB(I,O,u));++w[O],y=y&&O>=_,_=O}let T=!0;for(let I=0;I<u;++I){const O=0===w[I];c[I]=O,T=T&&!O,w[I]=Math.max(w[I],1),I>0&&(w[I]+=w[I-1])}if(T&&y){const I=n,O=r;for(let M=0;M<a;++M)p[M]=M;return[I,[a,m],O,c,p]}{const I=w[u-1],O=Ar(e,I*m),M=Ar(s,I),V=new Array(u).fill(0);for(let z=0;z<a;++z){const G=n[z*m],ne=(0===G?0:w[G-1])+V[G];V[G]++;for(let oe=0;oe<m;++oe)O[ne*m+oe]=n[z*m+oe];M[ne]=r[z],p[z]=ne}for(let z=0;z<u;++z)if(0===V[z]){const Q=0===z?0:w[z-1];O[Q*m+0]=z;for(let ne=1;ne<m;++ne)O[Q*m+ne]=0;M[Q]=o}return[O,[I,m],M,c,p]}}const U0e={kernelName:WC,backendName:"cpu",kernelFunc:function z0e(n){const{inputs:t,backend:e}=n,{indices:r,values:s,denseShape:i,defaultValue:o}=t;if(1!==i.shape.length)throw new Error(`Dense shape must be a vector, saw:\n        ${i.shape}`);if(2!==r.shape.length)throw new Error(`Indices must be a matrix, saw:\n        ${r.shape}`);if(1!==s.shape.length)throw new Error(`Values must be a vector, saw:\n        ${s.shape}`);if(0!==o.shape.length)throw new Error(`Default value must be a scalar, saw:\n        ${o.shape}`);const a=e.data.get(r.dataId).values,u=e.data.get(s.dataId).values,c=e.data.get(i.dataId).values,p=e.data.get(o.dataId).values[0],[m,y,_,w,T]=EU(a,r.shape,r.dtype,u,s.dtype,c,p);return[e.makeTensorInfo(y,r.dtype,m),e.makeTensorInfo([y[0]],s.dtype,_),e.makeTensorInfo([w.length],"bool",new Uint8Array(w.map(I=>Number(I)))),e.makeTensorInfo([T.length],r.dtype,new Int32Array(T))]}};function DU(n,t,e,r,s){const i=Fe(r),o=t[0],a=s.length,u=[];let c=1,p=-1;for(let I=0;I<a;++I){const O=s[I];if(-1===O){if(-1!==p)throw new Error(hB(p,I));p=I,u.push(1)}else{if(O<0)throw new Error(pB(I,O));c*=O,u.push(O)}}if(-1!==p){if(c<=0)throw new Error("reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero");const I=Math.trunc(i/c);if(c*I!==i)throw new Error(mB(r,u));u[p]=I}if(Fe(u)!==i)throw new Error(gB(r,u));const y=r.length,_=[];if(y>0){_[y-1]=1;for(let I=y-2;I>=0;--I)_[I]=_[I+1]*r[I+1]}const w=[];if(a>0){w[a-1]=1;for(let I=a-2;I>=0;--I)w[I]=w[I+1]*u[I+1]}const T=Ar(e,o*a);for(let I=0;I<o;++I){let O=0;for(let M=0;M<y;++M)O+=n[I*y+M]*_[M];for(let M=0;M<a;++M)T[I*a+M]=Math.trunc(O/w[M]),O%=w[M]}return[T,[o,a],u]}const G0e={kernelName:HC,backendName:"cpu",kernelFunc:function j0e(n){const{inputs:t,backend:e}=n,{inputIndices:r,inputShape:s,newShape:i}=t;if(2!==r.shape.length)throw new Error(`Input indices should be a matrix but received shape\n        ${r.shape}`);if(1!==s.shape.length)throw new Error(`Input shape should be a vector but received shape\n        ${s.shape}`);if(1!==i.shape.length)throw new Error(`Target shape should be a vector but received shape ${i.shape}`);const o=Array.from(e.data.get(s.dataId).values),a=e.data.get(r.dataId).values,u=Array.from(e.data.get(i.dataId).values),[c,p,m]=DU(a,r.shape,r.dtype,o,u);return[e.makeTensorInfo(p,r.dtype,c),e.makeTensorInfo([m.length],i.dtype,new Int32Array(m))]}};function SA(n,t,e,r,s,i=!1,o=0){const a=r.length,u=[t[0],n.length/t[0]],c=u[1],m=a>0?s[a-1]+1:0;if(m<0)throw new Error("segment ids must be >= 0");const y=t.slice();y[0]=m;const w=Ar(e,y.reduce((V,z)=>V*z,1));if(0===a)return m>0&&w.fill(o),[w,y];if(m<=0)throw new Error("segment ids must be >= 0");let T=0,I=1,O=0,M=s[T];for(;;){let V=0;if(I<a){if(V=s[I],M===V){++I;continue}if(M>=V)throw new Error("segment ids are not increasing")}if(M<0||M>=m)throw new Error(bB(M,m));M>O&&w.fill(o,O*c,M*c);for(let z=T;z<I;++z){const G=r[z];if(G<0||G>=u[0])throw new Error(_B(z,r[z],u[0]));for(let Q=0;Q<c;Q++)w[M*c+Q]+=n[G*c+Q]}if(i)for(let z=0;z<c;z++)w[M*c+z]/=I-T;if(T=I,++I,O=M+1,M=V,I>a)break}return O<m&&w.fill(o,O*c,m*c),[w,y]}const H0e={kernelName:qC,backendName:"cpu",kernelFunc:function W0e(n){const{inputs:t,backend:e}=n,{data:r,indices:s,segmentIds:i}=t;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==s.shape.length)throw new Error(`Indices should be a vector but received shape\n          ${s.shape}`);if(1!==i.shape.length)throw new Error(`Segment ids should be a vector but received shape\n          ${i.shape}`);if(s.shape[0]!==i.shape[0])throw new Error("segmentIds and indices should have same size.");const o=e.data.get(r.dataId).values,a=e.data.get(s.dataId).values,u=e.data.get(i.dataId).values,[c,p]=SA(o,r.shape,r.dtype,a,u,!0);return e.makeTensorInfo(p,r.dtype,c)}},K0e={kernelName:KC,backendName:"cpu",kernelFunc:function q0e(n){const{inputs:t,backend:e}=n,{data:r,indices:s,segmentIds:i}=t;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==s.shape.length)throw new Error(`Indices should be a vector but received shape\n         ${s.shape}`);if(1!==i.shape.length)throw new Error(`Segment ids should be a vector but received shape\n         ${i.shape}`);if(s.shape[0]!==i.shape[0])throw new Error("segmentIds and indices should have same size.");const o=e.data.get(r.dataId).values,a=e.data.get(s.dataId).values,u=e.data.get(i.dataId).values,[c,p]=SA(o,r.shape,r.dtype,a,u);return e.makeTensorInfo(p,r.dtype,c)}},Y0e={kernelName:XC,backendName:"cpu",kernelFunc:function X0e(n){const{inputs:t,backend:e,attrs:r}=n,{sparseIndices:s,sparseValues:i,defaultValue:o}=t,{outputShape:a}=r,{sliceRank:u,numUpdates:c,sliceSize:p,strides:m,outputSize:y}=Ec(0,s,a),_=!1,w=e.bufferSync(s);let T;switch(i.dtype){case"bool":T=Lc(w,e.bufferSync(i),a,y,p,c,u,m,!!e.data.get(o.dataId).values[0],_);break;case"float32":case"int32":T=Lc(w,e.bufferSync(i),a,y,p,c,u,m,e.data.get(o.dataId).values[0],_);break;case"string":T=Lc(w,e.bufferSync(i),a,y,p,c,u,m,Jl(e.data.get(o.dataId).values[0]),_);break;default:throw new Error(`Unsupported type ${i.dtype}`)}return e.makeTensorInfo(a,T.dtype,T.values)}},Q0e={kernelName:sv,backendName:"cpu",kernelFunc:function Z0e(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{numOrSizeSplits:i,axis:o}=r,a=sn(o,s.shape)[0],u=tD(s,i,a),c=new Array(s.shape.length).fill(0),p=s.shape.slice();return u.map(m=>{const y=[...p];y[a]=m;const _=$c({inputs:{x:s},backend:e,attrs:{begin:c,size:y}});return c[a]+=m,_})}},J0e=Ba(n=>Math.sqrt(n)),ewe=Rn(Nm,n=>Math.sqrt(n)),twe={kernelName:Nm,backendName:"cpu",kernelFunc:ewe},nwe={kernelName:YC,backendName:"cpu",kernelFunc:({inputs:n,backend:t})=>{const{x:e}=n,r=t;St(e,"square");const s=r.data.get(e.dataId).values,i=new Float32Array(s.length);for(let a=0;a<s.length;++a){const u=s[a];i[a]=u*u}return{dataId:r.write(i,e.shape,e.dtype),shape:e.shape,dtype:e.dtype}}},rwe=Rr((n,t)=>{const e=n-t;return e*e}),swe=ts(Om,rwe),iwe={kernelName:Om,backendName:"cpu",kernelFunc:swe},AU=Ba((n,t)=>{const{pattern:e,replaceGlobal:r,rewrite:s}=t;return n.replace(new RegExp(e,r?"g":""),s)}),owe=Su(ov,AU),awe={kernelName:ov,backendName:"cpu",kernelFunc:owe},lwe=Rn($m,(n,t)=>{const e=t;return isNaN(n)?NaN:n>0?1:e.alpha}),uwe={kernelName:$m,backendName:"cpu",kernelFunc:lwe};function kU(n,t,e,r){const s=tn(n,t.dtype);for(let i=0;i<s.size;i++){const o=s.indexToLoc(i),a=new Array(o.length);for(let u=0;u<a.length;u++)a[u]=o[u]*e[u]+r[u];s.set(t.get(...a),...o)}return s}const dwe={kernelName:ZC,backendName:"cpu",kernelFunc:function cwe(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{begin:i,end:o,strides:a,beginMask:u,endMask:c,ellipsisMask:p,newAxisMask:m,shrinkAxisMask:y}=r;St(s,"stridedSlice");const{finalShapeSparse:_,finalShape:w,isIdentity:T,sliceDim0:I,isSimpleSlice:O,begin:M,end:V,strides:z}=UI(s.shape,i,o,a,u,c,p,m,y);let G;if(T)G=Hn({inputs:{x:s},backend:e,attrs:{shape:w}});else if(I||O){J(s.shape.length>=1,()=>`Input must have rank at least 1, got: ${s.shape.length}`);const Q=VI(M,V,z),ne=$c({inputs:{x:s},backend:e,attrs:{begin:M,size:Q}});G=Hn({inputs:{x:ne},backend:e,attrs:{shape:w}}),e.disposeIntermediateTensorInfo(ne)}else{const ne=kU(_,e.bufferSync(s),z,M);G=e.makeTensorInfo(w,ne.dtype,ne.values)}return G}};class hwe{constructor(t,e,r,s,i,o){this.separator=Ql(t),this.nGramWidths=e,this.leftPad=Ql(r),this.rightPad=Ql(s),this.padWidth=i,this.preserveShort=o}getPadWidth(t){return Math.min(this.padWidth<0?t-1:this.padWidth,t-1)}getNumNGrams(t,e){const r=this.getPadWidth(e);return Math.max(0,t+2*r-e+1)}createNGrams(t,e,r,s,i,o){for(let a=0;a<i;++a){const u=this.getPadWidth(o),c=Math.max(0,u-a),p=Math.max(0,u-(i-(a+1))),m=o-(c+p),y=e+(c>0?0:a-u);let _=0;_+=c*this.leftPad.length;for(let M=0;M<m;++M)_+=t[y+M].length;_+=p*this.rightPad.length,_+=(c+p+m-1)*this.separator.length,r[s+a]=new Uint8Array(_);const T=r[s+a];let I=0;const O=M=>M.forEach(V=>T[I++]=V);for(let M=0;M<c;++M)O(this.leftPad),O(this.separator);for(let M=0;M<m-1;++M)O(t[y+M]),O(this.separator);if(m>0){O(t[y+m-1]);for(let M=0;M<p;++M)O(this.separator),O(this.rightPad)}else{for(let M=0;M<p-1;++M)O(this.rightPad),O(this.separator);O(this.rightPad)}}}compute(t,e){const r=t.length,s=e.length;if(s>0){let u=e[0];if(0!==u)throw new Error(`First split value must be 0, got ${u}`);for(let c=1;c<s;++c){let p=e[c]>=u;if(p=p&&e[c]<=r,!p)throw new Error(`Invalid split value ${e[c]}, must be in [${u}, ${r}]`);u=e[c]}if(u!==r)throw new Error(`Last split value must be data size. Expected ${r}, got ${u}`)}const i=s-1,o=Ar("int32",s);if(0===r||0===s){const u=new Array(r);for(let c=0;c<=i;++c)o[c]=0;return[u,o]}o[0]=0;for(let u=1;u<=i;++u){const c=e[u]-e[u-1];let p=0;this.nGramWidths.forEach(m=>{p+=this.getNumNGrams(c,m)}),this.preserveShort&&c>0&&0===p&&(p=1),o[u]=o[u-1]+p}const a=new Array(o[i]);for(let u=0;u<i;++u){const c=e[u];let p=o[u];if(this.nGramWidths.forEach(m=>{const _=this.getNumNGrams(e[u+1]-e[u],m);this.createNGrams(t,c,a,p,_,m),p+=_}),this.preserveShort&&p===o[u]){const m=e[u+1]-e[u];if(0===m)continue;this.createNGrams(t,c,a,p,1,m+2*this.padWidth)}}return[a,o]}}function NU(n,t,e,r,s,i,o,a){return new hwe(e,r,s,i,o,a).compute(n,t)}const fwe={kernelName:QC,backendName:"cpu",kernelFunc:function pwe(n){const{inputs:t,backend:e,attrs:r}=n,{separator:s,nGramWidths:i,leftPad:o,rightPad:a,padWidth:u,preserveShortSequences:c}=r,{data:p,dataSplits:m}=t,y=e.data.get(p.dataId).values,_=e.data.get(m.dataId).values,[w,T]=NU(y,_,s,i,o,a,u,c);return[e.makeTensorInfo([w.length],"string",w),e.makeTensorInfo(m.shape,"int32",T)]}};function mwe(n,t,e,r){if(!n.length)return;if(0===t.length){for(let i=0;i<n.length;++i)r.push(n.subarray(i,i+1));return}if(1===t.length){const i=t[0];let o=n.indexOf(i);for(;-1!==o;){const a=n.subarray(0,o);(!e||0!==a.length)&&r.push(a),o=(n=n.subarray(o+1)).indexOf(i)}return void((!e||0!==n.length)&&r.push(n))}let s=0;for(let i=0;i<n.length+1;i++)if(i===n.length||-1!==t.indexOf(n[i])){const o=n.subarray(s,i);(!e||0!==o.length)&&r.push(o),s=i+1}}function OU(n,t,e){const r=n.length,s=[];let i=0,o=0;const a=new Array(r);for(let y=0;y<r;++y){const _=s.length;mwe(n[y],t,e,s);const w=s.length-_;a[y]=w,i+=w,o=Math.max(o,w)}const u=Ar("int32",2*i),c=new Array(i),p=[r,o];let m=0;for(let y=0;y<r;++y)for(let _=0;_<a[y];++_)u[2*m]=y,u[2*m+1]=_,c[m]=s[m],++m;return[u,c,p]}const ywe={kernelName:JC,backendName:"cpu",kernelFunc:function gwe(n){const{inputs:t,backend:e,attrs:r}=n,{skipEmpty:s}=r,{input:i,delimiter:o}=t;if("string"!==i.dtype)throw new Error("Input must be of datatype string");if(1!==i.shape.length)throw new Error(`Input must be a vector, got shape: ${i.shape}`);if(0!==o.shape.length)throw new Error(`Delimiter must be a scalar, got shape: ${o.shape}`);const a=e.data.get(i.dataId).values,u=e.data.get(o.dataId).values[0],[c,p,m]=OU(a,u,s),y=p.length;return[e.makeTensorInfo([y,2],"int32",c),e.makeTensorInfo([y],"string",p),e.makeTensorInfo([2],"int32",new Int32Array(m))]}};function RU(n,t){const e=Ar("int32",n.length);for(let r=0;r<n.length;++r)e[r]=tre(n[r]).modulo(t).getLowBitsUnsigned();return e}const _we={kernelName:eI,backendName:"cpu",kernelFunc:function bwe(n){const{inputs:t,backend:e,attrs:r}=n,{numBuckets:s}=r,{input:i}=t;if("string"!==i.dtype)throw new Error("Input must be of datatype string");if(s<=0)throw new Error("Number of buckets must be at least 1");const a=RU(e.data.get(i.dataId).values,s);return e.makeTensorInfo(i.shape,"int32",a)}},vwe=Rn(Mm,n=>Math.tan(n)),wwe={kernelName:Mm,backendName:"cpu",kernelFunc:vwe},xwe=Rn(Pm,n=>Math.tanh(n));function MU(n,t){const e=new Array(n.rank);for(let s=0;s<e.length;s++)e[s]=n.shape[s]*t[s];const r=tn(e,n.dtype);for(let s=0;s<r.values.length;++s){const i=r.indexToLoc(s),o=new Array(n.rank);for(let u=0;u<o.length;u++)o[u]=i[u]%n.shape[u];const a=n.locToIndex(o);r.values[s]=n.values[a]}return r}const xg=(n,t)=>{const e=t.value-n.value;return 0===e?n.index-t.index:e};function PU(n,t,e=0,r=n.length-1){for(;r>e;){if(r-e>600){const a=r-e+1,u=t-e+1,c=Math.log(a),p=.5*Math.exp(2*c/3),m=.5*Math.sqrt(c*p*(a-p)/a)*Math.sign(u-a/2);PU(n,t,Math.max(e,Math.floor(t-u*p/a+m)),Math.min(r,Math.floor(t+(a-u)*p/a+m)))}const s=n[t];let i=e,o=r;for(Kl(n,e,t),xg(n[r],s)>0&&Kl(n,e,r);i<o;){for(Kl(n,i,o),i++,o--;xg(n[i],s)<0;)i+=1;for(;xg(n[o],s)>0;)o-=1}0===xg(n[e],s)?Kl(n,e,o):(o+=1,Kl(n,o,r)),o<=t&&(e=o+1),t<=o&&(r=o-1)}}function FU(n,t,e,r,s){const i=t[t.length-1],[o,a]=[n.length/i,i],u=_s(e,o*r),c=_s("int32",o*r);for(let m=0;m<o;m++){const y=m*a,_=n.subarray(y,y+a);let w=new Array(_.length);_.forEach((M,V)=>w[V]={value:M,index:V}),r<w.length&&(PU(w,r),w=w.slice(0,r)),s&&w.sort(xg);const T=m*r,I=u.subarray(T,T+r),O=c.subarray(T,T+r);for(let M=0;M<r;M++)I[M]=w[M].value,O[M]=w[M].index}const p=t.slice();return p[p.length-1]=r,[tn(p,e,u),tn(p,"int32",c)]}function $U(n,t,e){switch(e){case"reflect":return function Owe(n,t){let e=n;if(e<0)if(t<=1)e=0;else{const r=2*t;e<r&&(e=r*Math.trunc(-e/r)+e),e=e<-t?e+r:-e-1}else if(e>t-1)if(t<=1)e=0;else{const r=2*t;e-=r*Math.trunc(e/r),e>=t&&(e=r-e-1)}return fc(0,e,t-1)}(n,t);case"wrap":return function Rwe(n,t){let e=n;return e<0?t<=1?e=0:e+=t*(Math.trunc(-e/(t-1))+1):e>t-1&&(t<=1?e=0:e-=t*Math.trunc(e/(t-1))),fc(0,e,t-1)}(n,t);case"nearest":return function Pwe(n,t){return fc(0,n,t-1)}(n,t);default:return function Mwe(n,t){return n}(n)}}function Tg(n,t,e,r,s,i,o,a,u,c,p){return 0<=a&&a<t&&0<=u&&u<e?n[o*r+a*s+u*i+c]:p}function Fwe(n,t,e,r,s,i,o,a,u,c,p){return Tg(n,t,e,r,s,i,o,Math.round(a),Math.round(u),c,p)}function $we(n,t,e,r,s,i,o,a,u,c,p){const m=Math.floor(a),y=Math.floor(u),_=m+1,w=y+1;return(_-a)*((w-u)*Tg(n,t,e,r,s,i,o,m,y,c,p)+(u-y)*Tg(n,t,e,r,s,i,o,m,w,c,p))+(a-m)*((w-u)*Tg(n,t,e,r,s,i,o,_,y,c,p)+(u-y)*Tg(n,t,e,r,s,i,o,_,w,c,p))}function LU(n,t,e,r){const s=sn(t,e)[0],i=[1,e[0],1];for(let w=0;w<s;w++)i[0]*=e[w];i[1]=e[s];for(let w=s+1;w<e.length;w++)i[2]*=e[w];const o=new Map,a=new Int32Array(e[s]),u=new qr(i,r,n),c=[],p=1===i[0]&&1===i[2];for(let w=0;w<e[s];w++){let T;if(p)T=n[w].toString();else{const O=[];for(let M=0;M<i[0];M++)for(let V=0;V<i[2];V++)O.push(u.get(M,w,V));T=O.join(",")}const I=o.get(T);if(null!=I)a[w]=I;else{const O=o.size;o.set(T,O),a[w]=O,c.push(w)}}const m=i.slice();m[1]=o.size;const y=new qr(m,r);c.forEach((w,T)=>{for(let I=0;I<i[0];I++)for(let O=0;O<i[2];O++)y.set(u.get(I,w,O),I,T,O)});const _=e.slice();return _[s]=m[1],{outputValues:y.values,outputShape:_,indices:a}}const Gwe=[$ge,Lge,Bge,Uge,Rge,Gge,qge,Xge,Zge,Jge,tye,rye,iye,lye,cye,pye,mye,yye,_ye,Pge,wye,Sye,Iye,Aye,Nye,Nge,Rye,Pye,Age,Fye,Lye,Vye,zye,jye,Wye,qye,Xye,Zye,Jye,tbe,rbe,ibe,abe,ube,cbe,hbe,fbe,gbe,ybe,bbe,_be,Sbe,vge,Ibe,Ebe,Pbe,Fbe,$be,Vbe,qbe,Kbe,Ybe,Qbe,t_e,r_e,i_e,a_e,u_e,d_e,p_e,wge,m_e,$ye,y_e,__e,w_e,xge,T_e,C_e,E_e,A_e,N_e,M_e,F_e,V_e,z_e,j_e,G_e,H_e,K_e,Y_e,Q_e,eve,nve,sve,ove,lve,cve,pve,gve,wbe,bve,wve,Sve,Eve,Ave,Nve,Rve,Mve,mU,Lve,Sge,Bve,Kve,Yve,Qve,e0e,kge,vA,n0e,Cge,Ige,Mge,s0e,o0e,l0e,c0e,h0e,p0e,m0e,y0e,_0e,S0e,I0e,k0e,Dge,O0e,M0e,F0e,xye,fve,L0e,B0e,U0e,G0e,H0e,K0e,Y0e,Q0e,twe,nwe,iwe,awe,uwe,dwe,fwe,ywe,_we,Ube,xbe,wwe,{kernelName:Pm,backendName:"cpu",kernelFunc:xwe},{kernelName:jC,backendName:"cpu",kernelFunc:function Swe(n){const{inputs:t,backend:e}=n,{tensor:r,indices:s,updates:i}=t,{sliceRank:o,numUpdates:a,sliceSize:u,strides:c,outputSize:p}=Ec(0,s,r.shape),y=e.bufferSync(s),_=e.bufferSync(i),w=e.bufferSync(r),T=Lc(y,_,r.shape,p,u,a,o,c,w,!1);return e.makeTensorInfo(r.shape,T.dtype,T.values)}},{kernelName:Fm,backendName:"cpu",kernelFunc:function Iwe(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{reps:i}=r;St(s,"tile");const o=MU(e.bufferSync(s),i);return e.makeTensorInfo(o.shape,o.dtype,o.values)}},{kernelName:tI,backendName:"cpu",kernelFunc:function Dwe(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{k:i,sorted:o}=r;St(s,"topk");const a=e.data.get(s.dataId).values,[u,c]=FU(a,s.shape,s.dtype,i,o);return[e.makeTensorInfo(u.shape,u.dtype,u.values),e.makeTensorInfo(c.shape,c.dtype,c.values)]}},{kernelName:nI,backendName:"cpu",kernelFunc:function kwe(n){const{inputs:t,attrs:e,backend:r}=n,{image:s,transforms:i}=t,{interpolation:o,fillMode:a,fillValue:u,outputShape:c}=e,[p,m,y,_]=s.shape,[w,T]=c??[m,y],I=[p,w,T,_],O=Nt(s.shape),M=O[0],V=O[1],z=O[2],G=Nt(I),Q=G[0],ne=G[1],oe=G[2],de=_s(s.dtype,Fe(I));de.fill(u);const pe=r.data.get(s.dataId).values,Te=r.data.get(i.dataId).values;for(let Oe=0;Oe<p;++Oe){const Me=1===i.shape[0]?Te:Te.subarray(8*Oe,8*Oe+8);for(let Pe=0;Pe<w;++Pe)for(let ve=0;ve<T;++ve)for(let Se=0;Se<_;++Se){let xe;const ke=Me[6]*ve+Me[7]*Pe+1;if(0===ke)continue;const Ke=(Me[3]*ve+Me[4]*Pe+Me[5])/ke,et=$U((Me[0]*ve+Me[1]*Pe+Me[2])/ke,y,a),Je=$U(Ke,m,a);switch(o){case"nearest":xe=Fwe(pe,m,y,M,V,z,Oe,Je,et,Se,u);break;case"bilinear":xe=$we(pe,m,y,M,V,z,Oe,Je,et,Se,u);break;default:throw new Error(`Error in Transform: Expect 'nearest' or 'bilinear', but got ${o}`)}de[Oe*Q+Pe*ne+ve*oe+Se]=xe}return r.makeTensorInfo(I,s.dtype,de)}return{dataId:r.write(de,I,s.dtype),shape:s.shape,dtype:s.dtype}}},Wge,{kernelName:rI,backendName:"cpu",kernelFunc:function Lwe(n){const{inputs:t,attrs:e,backend:r}=n,{axis:s}=e,{x:i}=t;St(i,"unique");const o=r.data.get(i.dataId).values,{outputValues:a,outputShape:u,indices:c}=LU(o,s,i.shape,i.dtype);return[r.makeTensorInfo(u,i.dtype,a),r.makeTensorInfo([c.length],"int32",c)]}},{kernelName:av,backendName:"cpu",kernelFunc:function Bwe(n){const{inputs:t,backend:e,attrs:r}=n,{value:s}=t;let{axis:i}=r;i<0&&(i+=s.shape.length);const o=s.shape.length,a=s.shape[i],u=new Array(o-1);let c=0;for(let _=0;_<o;_++)_!==i&&(u[c++]=s.shape[_]);const p=new Array(o).fill(0),m=s.shape.slice();m[i]=1;const y=new Array(a);for(let _=0;_<y.length;_++){p[i]=_;const w=$c({inputs:{x:s},backend:e,attrs:{begin:p,size:m}});y[_]=Hn({inputs:{x:w},backend:e,attrs:{shape:u}}),e.disposeIntermediateTensorInfo(w)}return y}},{kernelName:lv,backendName:"cpu",kernelFunc:function Uwe(n){const{inputs:t,backend:e,attrs:r}=n,{x:s,segmentIds:i}=t,{numSegments:o}=r;St(s,"unsortedSegmentSum");const c=[],p=[],m=s.shape.length-i.shape.length;let y=i;for(let w=0;w<m;++w){const T=O0({inputs:{input:y},backend:e,attrs:{dim:w+1}});y=T,p.push(T)}for(let w=0;w<o;++w){const T=Zl(w,"int32"),I=e.makeTensorInfo([],"int32",T),O=Wz({inputs:{a:I,b:y},backend:e}),M=Cu({inputs:{x:O},backend:e,attrs:{dtype:"float32"}}),V=N0({inputs:{a:M,b:s},backend:e}),z=wg({inputs:{x:V},backend:e,attrs:{axis:0,keepDims:!1}});c.push(z),p.push(I),p.push(O),p.push(M),p.push(V),p.push(z)}const _=fU({inputs:c,backend:e,attrs:{axis:0}});return p.forEach(w=>e.disposeIntermediateTensorInfo(w)),_}},Ove];for(const n of Gwe)oI(n);const Iu={},P0={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0};function sa(n,t){if(!(n in Iu)||null!=t){const r=function qwe(n,t){if(1!==n&&2!==n)throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");const e=t??function Hwe(n){if(!De().getBool("IS_SAFARI")&&typeof OffscreenCanvas<"u"&&2===n)return new OffscreenCanvas(300,150);if(typeof document<"u")return document.createElement("canvas");throw new Error("Cannot create a canvas in this context")}(n);return e.addEventListener("webglcontextlost",r=>{r.preventDefault(),delete Iu[n]},!1),De().getBool("SOFTWARE_WEBGL_ENABLED")&&(P0.failIfMajorPerformanceCaveat=!1),1===n?e.getContext("webgl",P0)||e.getContext("experimental-webgl",P0):e.getContext("webgl2",P0)}(n,t);if(null===r)return console.log("Could not get context for WebGL version",n),null;Iu[n]=r}const e=Iu[n];return null==e||e.isContextLost()?(delete Iu[n],sa(n)):(e.disable(e.DEPTH_TEST),e.disable(e.STENCIL_TEST),e.disable(e.BLEND),e.disable(e.DITHER),e.disable(e.POLYGON_OFFSET_FILL),e.disable(e.SAMPLE_COVERAGE),e.enable(e.SCISSOR_TEST),e.enable(e.CULL_FACE),e.cullFace(e.BACK),Iu[n])}var Ua=(()=>((Ua=Ua||{})[Ua.DENSE=0]="DENSE",Ua[Ua.SHARED_BATCH=1]="SHARED_BATCH",Ua))(),Mr=(()=>((Mr=Mr||{})[Mr.RENDER=0]="RENDER",Mr[Mr.UPLOAD=1]="UPLOAD",Mr[Mr.PIXELS=2]="PIXELS",Mr[Mr.DOWNLOAD=3]="DOWNLOAD",Mr))(),Ln=(()=>((Ln=Ln||{})[Ln.UNPACKED_FLOAT16=0]="UNPACKED_FLOAT16",Ln[Ln.UNPACKED_FLOAT32=1]="UNPACKED_FLOAT32",Ln[Ln.PACKED_4X1_UNSIGNED_BYTE=2]="PACKED_4X1_UNSIGNED_BYTE",Ln[Ln.PACKED_2X2_FLOAT32=3]="PACKED_2X2_FLOAT32",Ln[Ln.PACKED_2X2_FLOAT16=4]="PACKED_2X2_FLOAT16",Ln))();function Sg(n,t){return[t,n]}function F0(n){const t=Fe(n);return W1(Math.ceil(t/4))}function Uh(n,t){return[Math.max(1,Math.ceil(t/2)),Math.max(1,Math.ceil(n/2))]}function CA(n,t){const e=n;let r,s,i,o,a,u,c,p,m,y;return 2===De().getNumber("WEBGL_VERSION")?(r=e.R32F,s=e.R16F,i=e.RGBA16F,o=e.RGBA32F,a=e.RED,c=4,p=1,m=e.HALF_FLOAT,y=e.FLOAT,u=e.RGBA8):(r=n.RGBA,s=n.RGBA,i=n.RGBA,o=e.RGBA,a=n.RGBA,c=4,p=4,m=null!=t?t.HALF_FLOAT_OES:null,y=n.FLOAT,u=n.RGBA),{internalFormatFloat:r,internalFormatHalfFloat:s,internalFormatPackedHalfFloat:i,internalFormatPackedFloat:o,textureFormatFloat:a,downloadTextureFormat:u,downloadUnpackNumChannels:c,defaultNumChannels:p,textureTypeHalfFloat:m,textureTypeFloat:y}}function dt(n,t){const e=t();return De().getBool("DEBUG")&&function Ywe(n){const t=n.getError();if(t!==n.NO_ERROR)throw new Error("WebGL Error: "+function exe(n,t){switch(t){case n.NO_ERROR:return"NO_ERROR";case n.INVALID_ENUM:return"INVALID_ENUM";case n.INVALID_VALUE:return"INVALID_VALUE";case n.INVALID_OPERATION:return"INVALID_OPERATION";case n.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case n.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case n.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return`Unknown error code ${t}`}}(n,t))}(n),e}function Jwe(n){return!!(De().getBool("WEBGL_RENDER_FLOAT32_ENABLED")||0===n||5.96e-8<Math.abs(n)&&Math.abs(n)<65504)}function $0(n,t){return xl(n,()=>n.getExtension(t),'Extension "'+t+'" not supported on this browser.')}const rxe=/ERROR: [0-9]+:([0-9]+):/g;function VU(n,t){const e=rxe.exec(t);if(null==e)return console.log(`Couldn't parse line number in error: ${t}`),void console.log(n);const r=+e[1],s=n.split("\n"),i=s.length.toString().length+2,o=s.map((m,y)=>lh((y+1).toString(),i)+m);let a=0;for(let m=0;m<o.length;m++)a=Math.max(o[m].length,a);const u=o.slice(0,r-1),c=o.slice(r-1,r),p=o.slice(r);console.log(u.join("\n")),console.log(t.split("\n")[0]),console.log(`%c ${lh(c[0],a)}`,"border:1px solid red; background-color:#e3d2d2; color:#a61717"),console.log(p.join("\n"))}function IA(n,t){if(dt(n,()=>n.validateProgram(t)),!1===n.getProgramParameter(t,n.VALIDATE_STATUS))throw console.log(n.getProgramInfoLog(t)),new Error("Shader program validation failed.")}function BU(n,t,e,r,s,i,o){const a=n.getAttribLocation(t,e);return-1!==a&&(dt(n,()=>n.bindBuffer(n.ARRAY_BUFFER,r)),dt(n,()=>n.vertexAttribPointer(a,s,n.FLOAT,!1,i,o)),dt(n,()=>n.enableVertexAttribArray(a)),!0)}function fxe(n,t,e,r){dt(n,()=>function dxe(n,t,e){(function UU(n,t){const e=n.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,r=t+n.TEXTURE0;if(r<n.TEXTURE0||r>e)throw new Error(`textureUnit must be in [gl.TEXTURE0, gl.TEXTURE${e}].`)})(n,e),dt(n,()=>n.activeTexture(n.TEXTURE0+e)),dt(n,()=>n.bindTexture(n.TEXTURE_2D,t))}(n,t,r)),dt(n,()=>n.uniform1i(e,r))}function EA(n,t,e){dt(n,()=>n.bindFramebuffer(n.FRAMEBUFFER,e)),dt(n,()=>n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,t,0))}function zU(n,t){dt(n,()=>n.bindFramebuffer(n.FRAMEBUFFER,t)),dt(n,()=>n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,null,0))}function L0(n){const t=n.checkFramebufferStatus(n.FRAMEBUFFER);if(t!==n.FRAMEBUFFER_COMPLETE)throw new Error("Error binding framebuffer: "+function mxe(n,t){switch(t){case n.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case n.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case n.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case n.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return`unknown error ${t}`}}(n,t))}function xl(n,t,e){const r=dt(n,()=>t());if(null==r)throw new Error(e);return r}function jh(n,t=2){return Fe(n.slice(0,n.length-t))}function Gh(n){if(0===n.length)throw Error("Cannot get rows and columns of an empty shape array.");return[n.length>1?n[n.length-2]:1,n[n.length-1]]}function V0(n){let t=[1,1,1];return 0===n.length||1===n.length&&1===n[0]||(t=[jh(n),...Gh(n)]),t}function B0(n){return n%2==0}function z0(n,t){if(hn(n=n.slice(-2),t=t.slice(-2))||!n.length||!t.length||0===n[0]||0===n[1]||0===t[0]||0===t[1])return!0;if(n.length!==t.length){const e=n[n.length-1],r=t[t.length-1];if(e===r||B0(e)&&B0(r)&&(1===n[0]||1===t[0]))return!0}return n[1]===t[1]&&B0(n[0])&&B0(t[0])}let U0,j0;function ko(n,t){return null!=n.getExtension(t)}function jU(n){try{if(null!=sa(n))return!0}catch(t){return console.log("Error when getting WebGL context: ",t),!1}return!1}function DA(n){const t=CA(n),e=n.createTexture();n.bindTexture(n.TEXTURE_2D,e),n.texImage2D(n.TEXTURE_2D,0,t.internalFormatFloat,1,1,0,t.textureFormatFloat,t.textureTypeFloat,null);const i=n.createFramebuffer();n.bindFramebuffer(n.FRAMEBUFFER,i),n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,e,0);const o=n.checkFramebufferStatus(n.FRAMEBUFFER)===n.FRAMEBUFFER_COMPLETE;return n.bindTexture(n.TEXTURE_2D,null),n.bindFramebuffer(n.FRAMEBUFFER,null),n.deleteTexture(e),n.deleteFramebuffer(i),o}function Cg(n,t){Array.isArray(n)||(n=[n]),n.forEach(e=>{null!=e&&J("complex64"!==e.dtype,()=>`${t} does not support complex64 tensors in the WebGL backend.`)})}const It=De();function Gs(){let n,t,e,r,s,i,o,a,u,c;return 2===De().getNumber("WEBGL_VERSION")?(n="#version 300 es",t="in",e="out",r="in",s="texture",i="outputColor",o="out vec4 outputColor;",a=De().getBool("WEBGL2_ISNAN_CUSTOM")?"\n      bool isnan_custom(float val) {\n        uint floatToUint = floatBitsToUint(val);\n        return (floatToUint & 0x7fffffffu) > 0x7f800000u;\n      }\n\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan_custom(val.x),\n          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));\n      }\n\n      #define isnan(value) isnan_custom(value)\n    ":"",u="",c="\n      #define round(value) newRound(value)\n      int newRound(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 newRound(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "):(n="",t="attribute",e="varying",r="varying",s="texture2D",i="gl_FragColor",o="",a="\n      #define isnan(value) isnan_custom(value)\n      bool isnan_custom(float val) {\n        return (val > 0. || val < 1. || val == 0.) ? false : true;\n      }\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));\n      }\n    ",u="\n      uniform float INFINITY;\n\n      bool isinf(float val) {\n        return abs(val) == INFINITY;\n      }\n      bvec4 isinf(vec4 val) {\n        return equal(abs(val), vec4(INFINITY));\n      }\n    ",c="\n      int round(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 round(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "),{version:n,attribute:t,varyingVs:e,varyingFs:r,texture2D:s,output:i,defineOutput:o,defineSpecialNaN:a,defineSpecialInf:u,defineRound:c}}function Vc(n,t,e="index"){const r=Nt(t);return r.map((s,i)=>`int ${n[i]} = ${e} / ${s}; ${i===r.length-1?`int ${n[i+1]} = ${e} - ${n[i]} * ${s}`:`index -= ${n[i]} * ${s}`};`).join("")}function G0(n,t,e="index"){const r=Nt(t);return r.map((s,i)=>`int ${n[i]} = ${e} / outShapeStrides[${i}]; ${i===r.length-1?`int ${n[i+1]} = ${e} - ${n[i]} * outShapeStrides[${i}]`:`index -= ${n[i]} * outShapeStrides[${i}]`};`).join("")}function AA(n){const t=Nt(n).map(e=>e.toString());return`\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * ${t[0]} + coords.y * ${t[1]} + coords.z;\n  }\n`}It.registerFlag("HAS_WEBGL",()=>It.getNumber("WEBGL_VERSION")>0),It.registerFlag("WEBGL_VERSION",()=>jU(2)?2:jU(1)?1:0),It.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS",()=>!1),It.registerFlag("WEBGL_BUFFER_SUPPORTED",()=>2===It.get("WEBGL_VERSION")),It.registerFlag("WEBGL_CPU_FORWARD",()=>!0),It.registerFlag("WEBGL_FORCE_F16_TEXTURES",()=>!1),It.registerFlag("WEBGL_PACK",()=>It.getBool("HAS_WEBGL")),It.registerFlag("WEBGL_PACK_NORMALIZATION",()=>It.getBool("WEBGL_PACK")),It.registerFlag("WEBGL_PACK_CLIP",()=>It.getBool("WEBGL_PACK")),It.registerFlag("WEBGL_PACK_DEPTHWISECONV",()=>It.getBool("WEBGL_PACK")),It.registerFlag("WEBGL_PACK_BINARY_OPERATIONS",()=>It.getBool("WEBGL_PACK")),It.registerFlag("WEBGL_PACK_UNARY_OPERATIONS",()=>It.getBool("WEBGL_PACK")),It.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS",()=>It.getBool("WEBGL_PACK")),It.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS",()=>It.getBool("WEBGL_PACK")),It.registerFlag("WEBGL_PACK_REDUCE",()=>It.getBool("WEBGL_PACK")),It.registerFlag("WEBGL_LAZILY_UNPACK",()=>It.getBool("WEBGL_PACK")),It.registerFlag("WEBGL_CONV_IM2COL",()=>It.getBool("WEBGL_PACK")),It.registerFlag("WEBGL_MAX_TEXTURE_SIZE",()=>function yxe(n){if(null==U0){const t=sa(n);U0=t.getParameter(t.MAX_TEXTURE_SIZE)}return U0}(It.getNumber("WEBGL_VERSION"))),It.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER",()=>function bxe(n){if(null==j0){const t=sa(n);j0=t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,j0)}(It.getNumber("WEBGL_VERSION"))),It.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",()=>{const n=It.getNumber("WEBGL_VERSION");return 0===n?0:function _xe(n){if(0===n)return 0;let t;const e=sa(n);return t=ko(e,"EXT_disjoint_timer_query_webgl2")&&2===n?2:ko(e,"EXT_disjoint_timer_query")?1:0,t}(n)}),It.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",()=>It.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0&&!ZL()),It.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE",()=>function vxe(n){if(0===n)return!1;const t=sa(n);if(1===n){if(!ko(t,"OES_texture_float"))return!1}else if(!ko(t,"EXT_color_buffer_float"))return!1;return DA(t)}(It.getNumber("WEBGL_VERSION"))),It.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED",()=>!It.getBool("WEBGL_FORCE_F16_TEXTURES")&&It.getBool("WEBGL_RENDER_FLOAT32_CAPABLE")),It.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED",()=>function wxe(n){if(0===n)return!1;const t=sa(n);if(1!==n){if(ko(t,"EXT_color_buffer_float"))return DA(t);const r="EXT_color_buffer_half_float";if(ko(t,r)){const s=t.getExtension(r);return function xxe(n,t){const e=CA(n,t),r=n.createTexture();n.bindTexture(n.TEXTURE_2D,r),n.texImage2D(n.TEXTURE_2D,0,e.internalFormatHalfFloat,1,1,0,e.textureFormatFloat,e.textureTypeHalfFloat,null);const o=n.createFramebuffer();n.bindFramebuffer(n.FRAMEBUFFER,o),n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,r,0);const a=n.checkFramebufferStatus(n.FRAMEBUFFER)===n.FRAMEBUFFER_COMPLETE;return n.bindTexture(n.TEXTURE_2D,null),n.bindFramebuffer(n.FRAMEBUFFER,null),n.deleteTexture(r),n.deleteFramebuffer(o),a}(t,s)}return!1}return!(!ko(t,"OES_texture_float")||!ko(t,"WEBGL_color_buffer_float"))&&DA(t)}(It.getNumber("WEBGL_VERSION"))),It.registerFlag("WEBGL_FENCE_API_ENABLED",()=>function Txe(n){return 2===n&&null!=sa(n).fenceSync}(It.getNumber("WEBGL_VERSION"))),It.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM",()=>It.getBool("WEBGL_RENDER_FLOAT32_ENABLED")?4:0),It.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD",()=>-1,n=>{if(n<0&&-1!==n)throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never delete) or at least 0, but got ${n}.`)}),It.registerFlag("WEBGL_FLUSH_THRESHOLD",()=>ZL()?1:-1,n=>{if(n<0&&-1!==n)throw new Error(`WEBGL_FLUSH_THRESHOLD must be -1 (indicating never manual flush) or at least 0, but got ${n}.`)}),It.registerFlag("CPU_HANDOFF_SIZE_THRESHOLD",()=>128),It.registerFlag("WEBGL_USE_SHAPES_UNIFORMS",()=>!1),It.registerFlag("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD",()=>1e5),It.registerFlag("TOPK_K_CPU_HANDOFF_THRESHOLD",()=>128),It.registerFlag("WEBGL_EXP_CONV",()=>!1),It.registerFlag("SOFTWARE_WEBGL_ENABLED",()=>It.getBool("IS_TEST")),It.registerFlag("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE",()=>1/0),It.registerFlag("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE",()=>!1),It.registerFlag("WEBGL2_ISNAN_CUSTOM",()=>!1),It.registerFlag("ENGINE_COMPILE_ONLY",()=>!1);const GU="\n  const float FLOAT_MAX = 1.70141184e38;\n  const float FLOAT_MIN = 1.17549435e-38;\n\n  lowp vec4 encode_float(highp float v) {\n    if (isnan(v)) {\n      return vec4(255, 255, 255, 255);\n    }\n\n    highp float av = abs(v);\n\n    if(av < FLOAT_MIN) {\n      return vec4(0.0, 0.0, 0.0, 0.0);\n    } else if(v > FLOAT_MAX) {\n      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;\n    } else if(v < -FLOAT_MAX) {\n      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;\n    }\n\n    highp vec4 c = vec4(0,0,0,0);\n\n    highp float e = floor(log2(av));\n    highp float m = exp2(fract(log2(av))) - 1.0;\n\n    c[2] = floor(128.0 * m);\n    m -= c[2] / 128.0;\n    c[1] = floor(32768.0 * m);\n    m -= c[1] / 32768.0;\n    c[0] = floor(8388608.0 * m);\n\n    highp float ebias = e + 127.0;\n    c[3] = floor(ebias / 2.0);\n    ebias -= c[3] * 2.0;\n    c[2] += floor(ebias) * 128.0;\n\n    c[3] += 128.0 * step(0.0, -v);\n\n    return c / 255.0;\n  }\n",{getBroadcastDims:WU}=S;function Ixe(n,t,e){const r=[];if(n.forEach(_=>{const w=Fe(_.shapeInfo.logicalShape);if(_.shapeInfo.isUniform?r.push(`uniform float ${_.name}${w>1?`[${w}]`:""};`):(r.push(`uniform sampler2D ${_.name};`),r.push(`uniform int offset${_.name};`)),e.enableShapeUniforms){const{uniformShape:T}=NA(e.packedInputs,_.shapeInfo.logicalShape,_.shapeInfo.texShape);switch(T.length){case 1:r.push(`uniform int ${_.name}Shape;`);break;case 2:r.push(`uniform ivec2 ${_.name}Shape;`);break;case 3:r.push(`uniform ivec3 ${_.name}Shape;`);break;case 4:r.push(`uniform ivec4 ${_.name}Shape;`)}r.push(`uniform ivec2 ${_.name}TexShape;`)}}),e.enableShapeUniforms){switch(t.logicalShape.length){case 1:r.push("uniform int outShape;");break;case 2:r.push("uniform ivec2 outShape;"),r.push("uniform int outShapeStrides;");break;case 3:r.push("uniform ivec3 outShape;"),r.push("uniform ivec2 outShapeStrides;");break;case 4:r.push("uniform ivec4 outShape;"),r.push("uniform ivec3 outShapeStrides;")}r.push("uniform ivec2 outTexShape;")}e.customUniforms&&e.customUniforms.forEach(_=>{r.push(`uniform ${_.type} ${_.name}${_.arrayIndex?`[${_.arrayIndex}]`:""};`)});const s=r.join("\n"),i=n.map(_=>function Exe(n,t,e=!1,r){let s="";s+=e?HU(n,r):Wh(n,r);return n.shapeInfo.logicalShape.length<=t.logicalShape.length&&(s+=e?function oTe(n,t){const e=n.name,r=e.charAt(0).toUpperCase()+e.slice(1),s="get"+r+"AtOutCoords",i=n.shapeInfo.logicalShape.length,o=t.logicalShape.length,a=WU(n.shapeInfo.logicalShape,t.logicalShape),u=Vn(o),c=o-i;let p;const m=["x","y","z","w","u","v"];p=0===i?"":o<2&&a.length>=1?"coords = 0;":a.map(M=>`coords.${m[M+c]} = 0;`).join("\n");let y="";y=o<2&&i>0?"coords":n.shapeInfo.logicalShape.map((M,V)=>`coords.${m[V+c]}`).join(", ");let _="return outputValue;";const T=1===Fe(n.shapeInfo.logicalShape),O=1===Fe(t.logicalShape);if(1!==i||T||O){if(T&&!O)_=1===o?"\n        return vec4(outputValue.x, outputValue.x, 0., 0.);\n      ":"\n        return vec4(outputValue.x);\n      ";else if(a.length){const M=i-2,V=i-1;a.indexOf(M)>-1&&a.indexOf(V)>-1?_="return vec4(outputValue.x);":a.indexOf(M)>-1?_="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":a.indexOf(V)>-1&&(_="return vec4(outputValue.xx, outputValue.zz);")}}else _="\n      return vec4(outputValue.xy, outputValue.xy);\n    ";return`\n    vec4 ${s}() {\n      ${u} coords = getOutputCoords();\n      ${p}\n      vec4 outputValue = get${r}(${y});\n      ${_}\n    }\n  `}(n,t):function aTe(n,t){const e=n.name,r=e.charAt(0).toUpperCase()+e.slice(1),s="get"+r+"AtOutCoords",a=n.shapeInfo.logicalShape.length,u=t.logicalShape.length;if(!n.shapeInfo.isUniform&&a===u&&null==n.shapeInfo.flatOffset&&hn(n.shapeInfo.texShape,t.texShape))return`\n      float ${s}() {\n        return sampleTexture(${e}, resultUV);\n      }\n    `;const c=Vn(u),p=WU(n.shapeInfo.logicalShape,t.logicalShape),m=u-a;let y;const _=["x","y","z","w","u","v"];y=0===a?"":u<2&&p.length>=1?"coords = 0;":p.map(T=>`coords.${_[T+m]} = 0;`).join("\n");let w="";return w=u<2&&a>0?"coords":n.shapeInfo.logicalShape.map((T,I)=>`coords.${_[I+m]}`).join(", "),`\n    float ${s}() {\n      ${c} coords = getOutputCoords();\n      ${y}\n      return get${r}(${w});\n    }\n  `}(n,t)),s}(_,t,e.packedInputs,e.enableShapeUniforms)).join("\n"),o=t.texShape,a=Gs(),u=function kxe(n){return`\n    float sampleTexture(sampler2D textureSampler, vec2 uv) {\n      return ${n.texture2D}(textureSampler, uv).r;\n    }\n  `}(a);let c,p,m=function Rxe(n){return`${n.version}\n    precision highp float;\n    precision highp int;\n    precision highp sampler2D;\n    ${n.varyingFs} vec2 resultUV;\n    ${n.defineOutput}\n    const vec2 halfCR = vec2(0.5, 0.5);\n\n    struct ivec5\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n    };\n\n    struct ivec6\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n      int v;\n    };\n\n    uniform float NAN;\n    ${n.defineSpecialNaN}\n    ${n.defineSpecialInf}\n    ${n.defineRound}\n\n    int imod(int x, int y) {\n      return x - y * (x / y);\n    }\n\n    int idiv(int a, int b, float sign) {\n      int res = a / b;\n      int mod = imod(a, b);\n      if (sign < 0. && mod != 0) {\n        res -= 1;\n      }\n      return res;\n    }\n\n    //Based on the work of Dave Hoskins\n    //https://www.shadertoy.com/view/4djSRW\n    #define HASHSCALE1 443.8975\n    float random(float seed){\n      vec2 p = resultUV * seed;\n      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n      p3 += dot(p3, p3.yzx + 19.19);\n      return fract((p3.x + p3.y) * p3.z);\n    }\n\n    ${Mxe}\n    ${Pxe}\n    ${Fxe}\n  `}(a);return t.isPacked?(c=function Dxe(n,t,e){switch(n.length){case 0:return"\n    int getOutputCoords() {\n      return 0;\n    }\n  ";case 1:return function Lxe(n,t,e){const r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];return 1===r[0]?e?"\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * ceil(float(outTexShape[1]) / 2.0));\n      }\n    ":`\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * ${r[1]}.0);\n      }\n    `:1===r[1]?e?"\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * ceil(float(outTexShape[0]) / 2.0));\n      }\n    ":`\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * ${r[0]}.0);\n      }\n    `:e?"\n    int getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      return 2 * (resTexRC.x * packedTexShape[1] + resTexRC.y);\n    }\n  ":`\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${r[0]}, ${r[1]}));\n      return 2 * (resTexRC.x * ${r[1]} + resTexRC.y);\n    }\n  `}(0,t,e);case 2:return function Hxe(n,t,e){const r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];if(hn(n,t))return e?"\n      ivec2 getOutputCoords() {\n        ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n        return 2 * ivec2(resultUV.yx * vec2(packedTexShape[0], packedTexShape[1]));\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        return 2 * ivec2(resultUV.yx * vec2(${r[0]}, ${r[1]}));\n      }\n    `;const s=Math.ceil(n[1]/2);return e?"\n    ivec2 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      int texelsInLogicalRow = int(ceil(float(outShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec2(r, c);\n    }\n  ":`\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${r[0]}, ${r[1]}));\n\n      int index = resTexRC.x * ${r[1]} + resTexRC.y;\n      int r = 2 * (index / ${s});\n      int c = imod(index, ${s}) * 2;\n\n      return ivec2(r, c);\n    }\n  `}(n,t,e);case 3:return function Bxe(n,t,e){if(e)return"\n    ivec3 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      int texelsInLogicalRow = int(ceil(float(outShape[2]) / 2.0));\n      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n\n      int b = index / texelsInBatch;\n      index -= b * texelsInBatch;\n\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec3(b, r, c);\n    }\n  ";const r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],s=Math.ceil(n[2]/2),i=s*Math.ceil(n[1]/2);return`\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${r[0]}, ${r[1]}));\n      int index = resTexRC.x * ${r[1]} + resTexRC.y;\n\n      int b = index / ${i};\n      index -= b * ${i};\n\n      int r = 2 * (index / ${s});\n      int c = imod(index, ${s}) * 2;\n\n      return ivec3(b, r, c);\n    }\n  `}(n,t,e);default:return function Uxe(n,t,e){if(e)return"\n    ivec4 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n\n      int texelsInLogicalRow = int(ceil(float(outShape[3]) / 2.0));\n      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[2]) / 2.0));\n      int texelsInBatchN = texelsInBatch * outShape[1];\n\n      int b2 = index / texelsInBatchN;\n      index -= b2 * texelsInBatchN;\n\n      int b = index / texelsInBatch;\n      index -= b * texelsInBatch;\n\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec4(b2, b, r, c);\n    }\n  ";const r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],s=Math.ceil(n[n.length-1]/2),i=s*Math.ceil(n[n.length-2]/2);let o=i,a="",u="b, r, c";for(let c=2;c<n.length-1;c++)o*=n[n.length-c-1],a=`\n      int b${c} = index / ${o};\n      index -= b${c} * ${o};\n    `+a,u=`b${c}, `+u;return`\n    ivec${n.length} getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${r[0]}, ${r[1]}));\n      int index = resTexRC.x * ${r[1]} + resTexRC.y;\n\n      ${a}\n\n      int b = index / ${i};\n      index -= b * ${i};\n\n      int r = 2 * (index / ${s});\n      int c = imod(index, ${s}) * 2;\n\n      return ivec${n.length}(${u});\n    }\n  `}(n,t,e)}}(t.logicalShape,o,e.enableShapeUniforms),p=function Oxe(n){return`\n    void setOutput(vec4 val) {\n      ${n.output} = val;\n    }\n  `}(a)):(c=function Axe(n,t,e){switch(n.length){case 0:return"\n    int getOutputCoords() {\n      return 0;\n    }\n  ";case 1:return function Vxe(n,t,e){return 1===t[0]?e?"\n      int getOutputCoords() {\n        return int(resultUV.x * float(outTexShape[1]));\n      }\n    ":`\n      int getOutputCoords() {\n        return int(resultUV.x * ${t[1]}.0);\n      }\n    `:1===t[1]?e?"\n      int getOutputCoords() {\n        return int(resultUV.y * float(outTexShape[0]));\n      }\n    ":`\n      int getOutputCoords() {\n        return int(resultUV.y * ${t[0]}.0);\n      }\n    `:e?"\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(outTexShape[0], outTexShape[1]));\n      return resTexRC.x * outTexShape[1] + resTexRC.y;\n    }\n  ":`\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${t[0]}, ${t[1]}));\n      return resTexRC.x * ${t[1]} + resTexRC.y;\n    }\n  `}(0,t,e);case 2:return function qxe(n,t,e){return hn(n,t)?e?"\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(outTexShape[0], outTexShape[1]));\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(${t[0]}, ${t[1]}));\n      }\n    `:1===n[1]?e?"\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(outTexShape[0], outTexShape[1]));\n        int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(${t[0]}, ${t[1]}));\n        int index = resTexRC.x * ${t[1]} + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    `:1===n[0]?e?"\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(outTexShape[0], outTexShape[1]));\n        int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n        return ivec2(0, index);\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(${t[0]}, ${t[1]}));\n        int index = resTexRC.x * ${t[1]} + resTexRC.y;\n        return ivec2(0, index);\n      }\n    `:e?"\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(outTexShape[0], outTexShape[1]));\n      int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n      int r = index / outShape[1];\n      int c = index - r * outShape[1];\n      return ivec2(r, c);\n    }\n  ":`\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n      int r = index / ${n[1]};\n      int c = index - r * ${n[1]};\n      return ivec2(r, c);\n    }\n  `}(n,t,e);case 3:return function zxe(n,t,e){if(e)return`\n  ivec3 getOutputCoords() {\n    ivec2 resTexRC = ivec2(resultUV.yx *\n                           vec2(outTexShape[0], outTexShape[1]));\n    int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n    ${G0(["r","c","d"],n)}\n    return ivec3(r, c, d);\n  }\n`;const r=Vc(["r","c","d"],n);return`\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n      ${r}\n      return ivec3(r, c, d);\n    }\n  `}(n,t,e);case 4:return function jxe(n,t,e){if(e)return`\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(outTexShape[0], outTexShape[1]));\n      int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n      ${G0(["r","c","d","d2"],n)}\n      return ivec4(r, c, d, d2);\n    }\n  `;const r=Vc(["r","c","d","d2"],n);return`\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n      ${r}\n      return ivec4(r, c, d, d2);\n    }\n  `}(n,t,e);case 5:return function Gxe(n,t){const e=Vc(["r","c","d","d2","d3"],n);return`\n    ivec5 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx * vec2(${t[0]},\n                             ${t[1]}));\n\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n\n      ${e}\n\n      ivec5 outShape = ivec5(r, c, d, d2, d3);\n      return outShape;\n    }\n  `}(n,t);case 6:return function Wxe(n,t){const e=Vc(["r","c","d","d2","d3","d4"],n);return`\n    ivec6 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n\n      ${e}\n\n      ivec6 result = ivec6(r, c, d, d2, d3, d4);\n      return result;\n    }\n  `}(n,t);default:throw new Error(`${n.length}-D output sampling is not yet supported`)}}(t.logicalShape,o,e.enableShapeUniforms),p=function Nxe(n){return`\n    void setOutput(float val) {\n      ${n.output} = vec4(val, 0, 0, 0);\n    }\n  `}(a)),e.packedInputs&&(m+=$xe),[m,u,p,s,c,i,e.userCode].join("\n")}function Wh(n,t=!1){const e=n.shapeInfo.logicalShape;switch(e.length){case 0:return function Xxe(n,t){const e=n.name,r="get"+e.charAt(0).toUpperCase()+e.slice(1);if(n.shapeInfo.isUniform)return`float ${r}() {return ${e};}`;const[s,i]=n.shapeInfo.texShape;if(1===s&&1===i)return`\n      float ${r}() {\n        return sampleTexture(${e}, halfCR);\n      }\n    `;const o=Bc(e);if(t)return`\n    float ${r}() {\n      vec2 uv = uvFromFlat(${e}TexShape[0], ${e}TexShape[1], ${o});\n      return sampleTexture(${e}, uv);\n    }\n  `;const[a,u]=n.shapeInfo.texShape;return`\n    float ${r}() {\n      vec2 uv = uvFromFlat(${a}, ${u}, ${o});\n      return sampleTexture(${e}, uv);\n    }\n  `}(n,t);case 1:return function Zxe(n,t){const e=n.name,r="get"+e.charAt(0).toUpperCase()+e.slice(1);if(n.shapeInfo.isUniform)return`\n      float ${r}(int index) {\n        ${Hh(n)}\n      }\n    `;const s=n.shapeInfo.texShape,i=s[0],o=s[1];if(1===o&&1===i)return`\n      float ${r}(int index) {\n        return sampleTexture(${e}, halfCR);\n      }\n    `;const a=Bc(e);return 1===o?t?`\n      float ${r}(int index) {\n        vec2 uv = vec2(0.5, (float(index + ${a}) + 0.5) / float(${e}TexShape[0]));\n        return sampleTexture(${e}, uv);\n      }\n    `:`\n      float ${r}(int index) {\n        vec2 uv = vec2(0.5, (float(index + ${a}) + 0.5) / ${i}.0);\n        return sampleTexture(${e}, uv);\n      }\n    `:1===i?t?`\n      float ${r}(int index) {\n        vec2 uv = vec2((float(index + ${a}) + 0.5) / float(${e}TexShape[1]), 0.5);\n        return sampleTexture(${e}, uv);\n      }\n    `:`\n      float ${r}(int index) {\n        vec2 uv = vec2((float(index + ${a}) + 0.5) / ${o}.0, 0.5);\n        return sampleTexture(${e}, uv);\n      }\n    `:t?`\n    float ${r}(int index) {\n      vec2 uv = uvFromFlat(${e}TexShape[0], ${e}TexShape[1], index + ${a});\n      return sampleTexture(${e}, uv);\n    }\n  `:`\n    float ${r}(int index) {\n      vec2 uv = uvFromFlat(${i}, ${o}, index + ${a});\n      return sampleTexture(${e}, uv);\n    }\n  `}(n,t);case 2:return function Jxe(n,t){const e=n.shapeInfo.logicalShape,r=n.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),i=n.shapeInfo.texShape;if(null!=i&&hn(e,i))return t?`\n      float ${s}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n    float ${s}(int row, int col) {\n      vec2 uv = (vec2(col, row) + halfCR) / vec2(${i[1]}.0, ${i[0]}.0);\n      return sampleTexture(${r}, uv);\n    }\n  `;const{newShape:o,keptDims:a}=Xl(e);if(o.length<e.length){const _=["row","col"];return`\n      ${Wh(qh(n,o),t)}\n      float ${s}(int row, int col) {\n        return ${s}(${Kh(_,a)});\n      }\n    `}if(n.shapeInfo.isUniform)return`\n      float ${s}(int row, int col) {\n        int index = round(dot(vec2(row, col), vec2(${e[1]}, 1)));\n        ${Hh(n)}\n      }\n    `;const c=i[0],p=i[1],m=Bc(r);return 1===p?t?`\n      float ${s}(int row, int col) {\n        float index = dot(vec3(row, col, ${m}), vec3(${r}Shape[1], 1, 1));\n        vec2 uv = vec2(0.5, (index + 0.5) / float(${r}TexShape[0]));\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n    float ${s}(int row, int col) {\n      float index = dot(vec3(row, col, ${m}), vec3(${e[1]}, 1, 1));\n      vec2 uv = vec2(0.5, (index + 0.5) / ${c}.0);\n      return sampleTexture(${r}, uv);\n    }\n  `:1===c?t?`\n      float ${s}(int row, int col) {\n        float index = dot(vec3(row, col, ${m}), vec3(${r}Shape[1], 1, 1));\n        vec2 uv = vec2((index + 0.5) / float(${r}TexShape[1]), 0.5);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n    float ${s}(int row, int col) {\n      float index = dot(vec3(row, col, ${m}), vec3(${e[1]}, 1, 1));\n      vec2 uv = vec2((index + 0.5) / ${p}.0, 0.5);\n      return sampleTexture(${r}, uv);\n    }\n  `:t?`\n      float ${s}(int row, int col) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * ${r}Shape[1] + col + ${m};\n        vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n  float ${s}(int row, int col) {\n    // Explicitly use integer operations as dot() only works on floats.\n    int index = row * ${e[1]} + col + ${m};\n    vec2 uv = uvFromFlat(${c}, ${p}, index);\n    return sampleTexture(${r}, uv);\n  }\n`}(n,t);case 3:return function tTe(n,t){const e=n.shapeInfo.logicalShape,r=n.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),i=e[1]*e[2],o=e[2],{newShape:a,keptDims:u}=Xl(e);if(a.length<e.length){const I=["row","col","depth"];return`\n        ${Wh(qh(n,a),t)}\n        float ${s}(int row, int col, int depth) {\n          return ${s}(${Kh(I,u)});\n        }\n      `}if(n.shapeInfo.isUniform)return`\n      float ${s}(int row, int col, int depth) {\n        int index = round(dot(vec3(row, col, depth),\n                          vec3(${i}, ${o}, 1)));\n        ${Hh(n)}\n      }\n    `;const p=n.shapeInfo.texShape,m=p[0],y=p[1],_=n.shapeInfo.flatOffset;if(y===i&&null==_)return t?`\n      float ${s}(int row, int col, int depth) {\n        int stride1 = ${r}Shape[2];\n        float texR = float(row);\n        float texC = dot(vec2(col, depth), vec2(stride1, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n        float ${s}(int row, int col, int depth) {\n          float texR = float(row);\n          float texC = dot(vec2(col, depth), vec2(${o}, 1));\n          vec2 uv = (vec2(texC, texR) + halfCR) /\n                     vec2(${y}.0, ${m}.0);\n          return sampleTexture(${r}, uv);\n        }\n      `;if(y===o&&null==_)return t?`\n      float ${s}(int row, int col, int depth) {\n        float texR = dot(vec2(row, col), vec2(${r}Shape[1], 1));\n        float texC = float(depth);\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n    float ${s}(int row, int col, int depth) {\n      float texR = dot(vec2(row, col), vec2(${e[1]}, 1));\n      float texC = float(depth);\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${y}.0, ${m}.0);\n      return sampleTexture(${r}, uv);\n    }\n  `;const w=Bc(r);return t?`\n    float ${s}(int row, int col, int depth) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int stride0 = ${r}Shape[1] * ${r}Shape[2];\n      int stride1 = ${r}Shape[2];\n      int index = row * stride0 + col * stride1 + depth + ${w};\n      vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index);\n      return sampleTexture(${r}, uv);\n    }\n    `:`\n      float ${s}(int row, int col, int depth) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * ${i} + col * ${o} + depth + ${w};\n        vec2 uv = uvFromFlat(${m}, ${y}, index);\n        return sampleTexture(${r}, uv);\n      }\n  `}(n,t);case 4:return function rTe(n,t){const e=n.shapeInfo.logicalShape,r=n.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),i=e[3],o=e[2]*i,a=e[1]*o,{newShape:u,keptDims:c}=Xl(e);if(u.length<e.length){const V=["row","col","depth","depth2"];return`\n      ${Wh(qh(n,u),t)}\n      float ${s}(int row, int col, int depth, int depth2) {\n        return ${s}(${Kh(V,c)});\n      }\n    `}if(n.shapeInfo.isUniform)return`\n      float ${s}(int row, int col, int depth, int depth2) {\n        int index = round(dot(vec4(row, col, depth, depth2),\n                          vec4(${a}, ${o}, ${i}, 1)));\n        ${Hh(n)}\n      }\n    `;const p=n.shapeInfo.flatOffset,m=n.shapeInfo.texShape,y=m[0],_=m[1],w=`int stride2 = ${r}Shape[3];`,T=`int stride1 = ${r}Shape[2] * stride2;`,I=`int stride0 = ${r}Shape[1] * stride1;`;if(_===a&&null==p)return t?`\n      float ${s}(int row, int col, int depth, int depth2) {\n        ${w}\n        ${T}\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3(stride1, stride2, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n      float ${s}(int row, int col, int depth, int depth2) {\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3(${o}, ${i}, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${_}.0, ${y}.0);\n        return sampleTexture(${r}, uv);\n      }\n    `;if(_===i&&null==p)return t?`\n      float ${s}(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3(${r}Shape[1] * ${r}Shape[2], ${r}Shape[2], 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n      float ${s}(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3(${e[1]*e[2]}, ${e[2]}, 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${_}.0, ${y}.0);\n        return sampleTexture(${r}, uv);\n      }\n    `;const O=Bc(r);return t?`\n    float ${s}(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      ${w}\n      ${T}\n      ${I}\n      int index = row * stride0 + col * stride1 +\n          depth * stride2 + depth2;\n      vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index + ${O});\n      return sampleTexture(${r}, uv);\n    }\n  `:`\n    float ${s}(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${a} + col * ${o} +\n          depth * ${i} + depth2;\n      vec2 uv = uvFromFlat(${y}, ${_}, index + ${O});\n      return sampleTexture(${r}, uv);\n    }\n  `}(n,t);case 5:return function sTe(n){const t=n.shapeInfo.logicalShape,e=n.name,r="get"+e.charAt(0).toUpperCase()+e.slice(1),s=t[4],i=t[3]*s,o=t[2]*i,a=t[1]*o,{newShape:u,keptDims:c}=Xl(t);if(u.length<t.length){const I=["row","col","depth","depth2","depth3"];return`\n      ${Wh(qh(n,u))}\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        return ${r}(${Kh(I,c)});\n      }\n    `}if(n.shapeInfo.isUniform)return`\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        float index = dot(\n          vec4(row, col, depth, depth2),\n          vec4(${a}, ${o}, ${i}, ${s})) +\n          depth3;\n        ${Hh(n)}\n      }\n    `;const p=n.shapeInfo.flatOffset,m=n.shapeInfo.texShape,y=m[0],_=m[1];if(_===a&&null==p)return`\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n                         vec4(${o}, ${i}, ${s}, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${_}.0, ${y}.0);\n        return sampleTexture(${e}, uv);\n      }\n    `;if(_===s&&null==p)return`\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        float texR = dot(\n          vec4(row, col, depth, depth2),\n          vec4(${t[1]*t[2]*t[3]},\n               ${t[2]*t[3]}, ${t[3]}, 1));\n        int texC = depth3;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${_}.0, ${y}.0);\n        return sampleTexture(${e}, uv);\n      }\n    `;return`\n    float ${r}(int row, int col, int depth, int depth2, int depth3) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${a} + col * ${o} + depth * ${i} +\n          depth2 * ${s} + depth3 + ${Bc(e)};\n      vec2 uv = uvFromFlat(${y}, ${_}, index);\n      return sampleTexture(${e}, uv);\n    }\n  `}(n);case 6:return function iTe(n){const t=n.shapeInfo.logicalShape,e=n.name,r="get"+e.charAt(0).toUpperCase()+e.slice(1),{newShape:s,keptDims:i}=Xl(t);if(s.length<t.length){const O=["row","col","depth","depth2","depth3","depth4"];return`\n      ${Wh(qh(n,s))}\n      float ${r}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        return ${r}(${Kh(O,i)});\n      }\n    `}const o=t[5],a=t[4]*o,u=t[3]*a,c=t[2]*u,p=t[1]*c;if(n.shapeInfo.isUniform)return`\n      float ${r}(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n        int index = round(dot(\n          vec4(row, col, depth, depth2),\n          vec4(${p}, ${c}, ${u}, ${a})) +\n          dot(\n            vec2(depth3, depth4),\n            vec2(${o}, 1)));\n        ${Hh(n)}\n      }\n    `;const m=n.shapeInfo.flatOffset,y=n.shapeInfo.texShape,_=y[0],w=y[1];if(w===p&&null==m)return`\n      float ${r}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n          vec4(${c}, ${u}, ${a}, ${o})) +\n               float(depth4);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${w}.0, ${_}.0);\n        return sampleTexture(${e}, uv);\n      }\n    `;if(w===o&&null==m)return`\n      float ${r}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        float texR = dot(vec4(row, col, depth, depth2),\n          vec4(${t[1]*t[2]*t[3]*t[4]},\n               ${t[2]*t[3]*t[4]},\n               ${t[3]*t[4]},\n               ${t[4]})) + float(depth3);\n        int texC = depth4;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${w}.0, ${_}.0);\n        return sampleTexture(${e}, uv);\n      }\n    `;return`\n    float ${r}(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${p} + col * ${c} + depth * ${u} +\n          depth2 * ${a} + depth3 * ${o} + depth4 + ${Bc(e)};\n      vec2 uv = uvFromFlat(${_}, ${w}, index);\n      return sampleTexture(${e}, uv);\n    }\n  `}(n);default:throw new Error(`${e.length}-D input sampling is not yet supported`)}}function HU(n,t){switch(n.shapeInfo.logicalShape.length){case 0:return function Kxe(n){const t=n.name;return`\n    vec4 ${"get"+t.charAt(0).toUpperCase()+t.slice(1)}() {\n      return ${Gs().texture2D}(${t}, halfCR);\n    }\n  `}(n);case 1:return function Yxe(n,t){const e=n.name,r="get"+e.charAt(0).toUpperCase()+e.slice(1),s=n.shapeInfo.texShape,i=Gs();if(t)return`\n    vec4 ${r}(int index) {\n      ivec2 packedTexShape = ivec2(ceil(float(${e}TexShape[0]) / 2.0), ceil(float(${e}TexShape[1]) / 2.0));\n      vec2 uv = packedUVfrom1D(\n        packedTexShape[0], packedTexShape[1], index);\n      return ${i.texture2D}(${e}, uv);\n    }\n  `;const o=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)];return`\n    vec4 ${r}(int index) {\n      vec2 uv = packedUVfrom1D(\n        ${o[0]}, ${o[1]}, index);\n      return ${i.texture2D}(${e}, uv);\n    }\n  `}(n,t);case 2:return function Qxe(n,t){const e=n.shapeInfo.logicalShape,r=n.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),i=n.shapeInfo.texShape,o=i[0],a=i[1],u=Gs();if(null!=i&&hn(e,i))return t?`\n      vec4 ${s}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);\n\n        return ${u.texture2D}(${r}, uv);\n      }\n    `:`\n      vec4 ${s}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${a}.0, ${o}.0);\n\n        return ${u.texture2D}(${r}, uv);\n      }\n    `;if(t)return`\n    vec4 ${s}(int row, int col) {\n      ivec2 packedTexShape = ivec2(ceil(float(${r}TexShape[0]) / 2.0), ceil(float(${r}TexShape[1]) / 2.0));\n      int valuesPerRow = int(ceil(float(${r}Shape[1]) / 2.0));\n      vec2 uv = packedUVfrom2D(valuesPerRow, packedTexShape[0], packedTexShape[1], row, col);\n      return ${u.texture2D}(${r}, uv);\n    }\n  `;const c=[Math.ceil(i[0]/2),Math.ceil(i[1]/2)];return`\n    vec4 ${s}(int row, int col) {\n      vec2 uv = packedUVfrom2D(${Math.ceil(e[1]/2)}, ${c[0]}, ${c[1]}, row, col);\n      return ${u.texture2D}(${r}, uv);\n    }\n  `}(n,t);case 3:return function eTe(n,t){const e=n.shapeInfo.logicalShape,r=n.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),i=n.shapeInfo.texShape,o=[Math.ceil(i[0]/2),Math.ceil(i[1]/2)];if(1===e[0]){const _=[1,2],T=["b","row","col"];return`\n        ${HU(qh(n,e.slice(1)),t)}\n        vec4 ${s}(int b, int row, int col) {\n          return ${s}(${Kh(T,_)});\n        }\n      `}const a=Gs();if(t)return`\n    vec4 ${s}(int b, int row, int col) {\n      ivec2 packedTexShape = ivec2(ceil(float(${r}TexShape[0]) / 2.0), ceil(float(${r}TexShape[1]) / 2.0));\n      int valuesPerRow = int(ceil(float(${r}Shape[2]) / 2.0));\n      int texelsInBatch = valuesPerRow * int(ceil(float(${r}Shape[1]) / 2.0));\n      vec2 uv = packedUVfrom3D(\n        packedTexShape[0], packedTexShape[1], texelsInBatch, valuesPerRow, b, row, col);\n      return ${a.texture2D}(${r}, uv);\n    }\n  `;const u=o[0],c=o[1],p=Math.ceil(e[2]/2);return`\n    vec4 ${s}(int b, int row, int col) {\n      vec2 uv = packedUVfrom3D(\n        ${u}, ${c}, ${p*Math.ceil(e[1]/2)}, ${p}, b, row, col);\n      return ${a.texture2D}(${r}, uv);\n    }\n  `}(n,t);default:return function nTe(n,t){const e=n.name,r="get"+e.charAt(0).toUpperCase()+e.slice(1),s=Gs();if(t)return`\n    vec4 ${r}(int b2, int b, int row, int col) {\n      int valuesPerRow = int(ceil(float(${e}Shape[3]) / 2.0));\n      int texelsInBatch = valuesPerRow * int(ceil(float(${e}Shape[2]) / 2.0));\n      int index = b * texelsInBatch + (row / 2) * valuesPerRow + (col / 2);\n      texelsInBatch *= ${e}Shape[1];\n      index = b2 * texelsInBatch + index;\n      ivec2 packedTexShape = ivec2(ceil(float(${e}TexShape[0]) / 2.0), ceil(float(${e}TexShape[1]) / 2.0));\n      int texR = index / packedTexShape[1];\n      int texC = index - texR * packedTexShape[1];\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(packedTexShape[1], packedTexShape[0]); return ${s.texture2D}(${e}, uv);\n    }\n  `;const i=n.shapeInfo.logicalShape,o=i.length,a=n.shapeInfo.texShape,u=[Math.ceil(a[0]/2),Math.ceil(a[1]/2)],c=u[0],p=u[1],m=Math.ceil(i[o-1]/2);let y=m*Math.ceil(i[o-2]/2),_="int b, int row, int col",w=`b * ${y} + (row / 2) * ${m} + (col / 2)`;for(let T=2;T<o-1;T++)_=`int b${T}, `+_,y*=i[o-T-1],w=`b${T} * ${y} + `+w;return`\n    vec4 ${r}(${_}) {\n      int index = ${w};\n      int texR = index / ${p};\n      int texC = index - texR * ${p};\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${p}, ${c});\n      return ${s.texture2D}(${e}, uv);\n    }\n  `}(n,t)}}const Mxe="\nvec2 uvFromFlat(int texNumR, int texNumC, int index) {\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\nvec2 packedUVfrom1D(int texNumR, int texNumC, int index) {\n  int texelIndex = index / 2;\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",Pxe="\nvec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,\n  int texNumC, int row, int col) {\n  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",Fxe="\nvec2 packedUVfrom3D(int texNumR, int texNumC,\n    int texelsInBatch, int texelsInLogicalRow, int b,\n    int row, int col) {\n  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",$xe="\n  float getChannel(vec4 frag, vec2 innerDims) {\n    vec2 modCoord = mod(innerDims, 2.);\n    return modCoord.x == 0. ?\n      (modCoord.y == 0. ? frag.r : frag.g) :\n      (modCoord.y == 0. ? frag.b : frag.a);\n  }\n  float getChannel(vec4 frag, int dim) {\n    float modCoord = mod(float(dim), 2.);\n    return modCoord == 0. ? frag.r : frag.g;\n  }\n";function Bc(n){return`offset${n}`}function Hh(n){const t=n.name,e=Fe(n.shapeInfo.logicalShape);return e<2?`return ${t};`:`\n    for (int i = 0; i < ${e}; i++) {\n      if (i == index) {\n        return ${t}[i];\n      }\n    }\n  `}function Vn(n){if(n<=1)return"int";if(2===n)return"ivec2";if(3===n)return"ivec3";if(4===n)return"ivec4";if(5===n)return"ivec5";if(6===n)return"ivec6";throw Error(`GPU for rank ${n} is not yet supported`)}function NA(n,t,e){const{newShape:r,keptDims:s}=Xl(t),i=t.length,o=n&&3===i&&1===t[0],a=o?t.slice(1):r,u=!n&&i>1&&!hn(t,e)&&r.length<i||o;return{useSqueezeShape:u,uniformShape:u?a:t,keptDims:s}}function qh(n,t){const e=JSON.parse(JSON.stringify(n));return e.shapeInfo.logicalShape=t,e}function Kh(n,t){return t.map(e=>n[e]).join(", ")}function KU(n,t,e){const r=[],s=[];let i,o,a,u=null,c=null;c=n.getUniformLocation(e,"NAN",!1),1===De().getNumber("WEBGL_VERSION")&&(u=n.getUniformLocation(e,"INFINITY",!1));const p=!1;for(const m of t.variableNames){const y={name:m,uniform:n.getUniformLocation(e,m,p),offset:n.getUniformLocation(e,`offset${m}`,p)};t.enableShapeUniforms&&(y.shape=n.getUniformLocation(e,`${m}Shape`,p),y.texShape=n.getUniformLocation(e,`${m}TexShape`,p)),r.push(y)}if(t.enableShapeUniforms&&(i=n.getUniformLocation(e,"outShape",p),a=n.getUniformLocation(e,"outShapeStrides",p),o=n.getUniformLocation(e,"outTexShape",p)),t.customUniforms)for(const m of t.customUniforms)s.push(n.getUniformLocation(e,m.name,p));return{variablesLocations:r,customUniformLocations:s,infLoc:u,nanLoc:c,outShapeLocation:i,outShapeStridesLocation:a,outTexShapeLocation:o}}function XU(n,t){if(n.length!==t.length)throw Error(`Binary was compiled with ${n.length} inputs, but was executed with ${t.length} inputs`);n.forEach((e,r)=>{const s=e.logicalShape,i=t[r],o=i.shape;if(!hn(s,o))throw Error(`Binary was compiled with different shapes than the current args. Shapes ${s} and ${o} must match`);if(e.isUniform&&i.isUniform)return;const a=e.texShape,u=i.isUniform?null:i.texData.texShape;if(!hn(a,u))throw Error(`Binary was compiled with different texture shapes than the current args. Shape ${a} and ${u} must match`)})}function Rs(n){return De().getBool("WEBGL_USE_SHAPES_UNIFORMS")&&n<=4}class dTe{constructor(t){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outPackingScheme=Ua.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const e=Gs();this.outputShape=t,this.enableShapeUniforms=Rs(this.outputShape.length),this.userCode=`\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ${this.enableShapeUniforms?G0(["r","c","d"],t):Vc(["r","c","d"],t)}\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));\n        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getA(rc.x, rc.y, rc.z);\n        }\n\n        ${e.output} = result;\n      }\n    `}}class hTe{constructor(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outPackingScheme=Ua.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const e=Gs();this.outputShape=t,this.enableShapeUniforms=Rs(this.outputShape.length),this.userCode=`\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ${this.enableShapeUniforms?G0(["r","c","d"],t):Vc(["r","c","d"],t)}\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));\n        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));\n        }\n\n        ${e.output} = result;\n      }\n    `}}class pTe{constructor(t){this.variableNames=["A"],this.outTexUsage=Mr.DOWNLOAD;const e=Gs();this.outputShape=t,this.userCode=`\n      ${GU}\n\n      void main() {\n        float x = getAAtOutCoords();\n        ${e.output} = encode_float(x);\n      }\n    `}}class fTe{constructor(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outTexUsage=Mr.DOWNLOAD;const e=Gs();this.outputShape=t,this.userCode=`\n      ${GU}\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));\n        ${e.output} = encode_float(x);\n      }\n    `}}const mTe={R:0,G:1,B:2,A:3};class YU{constructor(t,e=!1,r="RGBA"){this.variableNames=["A"],this.customUniforms=[{name:"texShape",type:"ivec2"}];const s=Gs();this.outputShape=t,this.enableShapeUniforms=Rs(this.outputShape.length);let i="result";e&&(i="floor(result * 255. + 0.5)");let o="";for(let a=0;a<r.length;a++)o+=`\n          if(offset == ${a}) {\n            result = values[${mTe[r[a]]}];\n          }`;this.userCode=`\n      ${this.enableShapeUniforms?"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n":AA(t)}\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int flatIndex = getFlatIndex(coords);\n        float result = 0.;\n        int offset = imod(flatIndex, ${r.length});\n\n        flatIndex = idiv(flatIndex, ${r.length}, 1.);\n\n        int r = flatIndex / texShape[1];\n        if (r < texShape[0]) {\n          int c = imod(flatIndex, texShape[1]);\n          vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);\n          vec4 values = ${s.texture2D}(A, uv);\n          ${o}\n        }\n        ${s.output} = vec4(${i}, 0., 0., 0.);\n      }\n    `}}class gTe{constructor(t,e=!1){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.customUniforms=[{name:"texShape",type:"ivec2"}];const r=Gs();this.outputShape=t,this.enableShapeUniforms=Rs(this.outputShape.length);let s="",i="result";e&&(i="floor(result * 255. + 0.5)");for(let o=0;o<=1;o++)for(let a=0;a<=1;a++){const u=2*o+a;s+=`\n          localCoords = coords;\n          if(localCoords[2] + ${a} < ${this.enableShapeUniforms?"outShape[2]":`${t[2]}`}) {\n          localCoords[2] += ${a};\n          if (localCoords[1] + ${o} < ${this.enableShapeUniforms?"outShape[1]":`${t[1]}`}) {\n            localCoords[1] += ${o};\n\n            flatIndex = getFlatIndex(localCoords);\n            offset = imod(flatIndex, 4);\n\n            flatIndex = idiv(flatIndex, 4, 1.);\n\n            int r = flatIndex / texShape[1];\n            int c = imod(flatIndex, texShape[1]);\n            vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);\n            values = ${r.texture2D}(A, uv);\n\n            if (offset == 0) {\n              result[${u}] = values[0];\n            } else if (offset == 1) {\n              result[${u}] = values[1];\n            } else if (offset == 2) {\n              result[${u}] = values[2];\n            } else {\n              result[${u}] = values[3];\n            }\n          }\n        }\n        `}this.userCode=`\n        ${this.enableShapeUniforms?"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n":AA(t)}\n\n        void main() {\n          ivec3 coords = getOutputCoords();\n\n          vec4 result = vec4(0.);\n          int flatIndex, r, c, offset;\n          ivec3 localCoords;\n          vec2 uv;\n          vec4 values;\n\n          ${s}\n\n          ${r.output} = ${i};\n        }\n    `}}function Ig(n,t,e,r,s,i){!function uxe(n,t){const e=De().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(n<=0||t<=0)throw new Error(`Requested texture size [${n}x${t}] is invalid.`);if(n>e||t>e)throw new Error(`Requested texture size [${n}x${t}] greater than WebGL maximum on this browser / GPU [${e}x${e}].`)}(t,e);const o=function lxe(n){return xl(n,()=>n.createTexture(),"Unable to create WebGLTexture.")}(n),a=n.TEXTURE_2D;return dt(n,()=>n.bindTexture(a,o)),dt(n,()=>n.texParameteri(a,n.TEXTURE_WRAP_S,n.CLAMP_TO_EDGE)),dt(n,()=>n.texParameteri(a,n.TEXTURE_WRAP_T,n.CLAMP_TO_EDGE)),dt(n,()=>n.texParameteri(a,n.TEXTURE_MIN_FILTER,n.NEAREST)),dt(n,()=>n.texParameteri(a,n.TEXTURE_MAG_FILTER,n.NEAREST)),1===De().getNumber("WEBGL_VERSION")?dt(n,()=>n.texImage2D(a,0,r,t,e,0,s,i,null)):dt(n,()=>n.texStorage2D(a,1,r,t,e)),dt(n,()=>n.bindTexture(n.TEXTURE_2D,null)),{texture:o,texShape:[e,t]}}function ZU(n){return n.internalFormatFloat}function QU(n){return n.internalFormatHalfFloat}function JU(n){return n.downloadTextureFormat}function ej(n){return n.internalFormatPackedFloat}function tj(n){return n.internalFormatPackedHalfFloat}class OA{constructor(t){this.outputTexture=null,this.program=null,this.disposed=!1,this.itemsToPoll=[];const e=De().getNumber("WEBGL_VERSION");if(null!=t?(this.gl=t,function Wwe(n,t){Iu[n]=t}(e,t)):this.gl=sa(e),t=this.gl,2===De().getNumber("WEBGL_VERSION")){const i=t;this.createVertexArray=()=>dt(i,()=>i.createVertexArray()),this.bindVertexArray=o=>dt(i,()=>i.bindVertexArray(o)),this.deleteVertexArray=o=>dt(i,()=>i.deleteVertexArray(o)),this.getVertexArray=()=>dt(i,()=>i.getParameter(i.VERTEX_ARRAY_BINDING))}else if(null!=t){const i=t.getExtension("OES_vertex_array_object");if(null==i)throw new Error("All WebGL1 implementations are expected to offer OES_vertex_array_object.");this.createVertexArray=()=>dt(t,()=>i.createVertexArrayOES()),this.bindVertexArray=o=>dt(t,()=>i.bindVertexArrayOES(o)),this.deleteVertexArray=o=>dt(t,()=>i.deleteVertexArrayOES(o)),this.getVertexArray=()=>dt(t,()=>t.getParameter(i.VERTEX_ARRAY_BINDING_OES))}let r="WEBGL_color_buffer_float";const s="EXT_color_buffer_half_float";if(this.parallelCompilationExtension=this.gl.getExtension("KHR_parallel_shader_compile"),1===De().getNumber("WEBGL_VERSION")){const o="OES_texture_half_float";if(this.textureFloatExtension=$0(this.gl,"OES_texture_float"),ko(this.gl,o))this.textureHalfFloatExtension=$0(this.gl,o);else if(De().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");if(this.colorBufferFloatExtension=this.gl.getExtension(r),ko(this.gl,s))this.colorBufferHalfFloatExtension=$0(this.gl,s);else if(De().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}else if(r="EXT_color_buffer_float",ko(this.gl,r))this.colorBufferFloatExtension=this.gl.getExtension(r);else{if(!ko(this.gl,s))throw new Error("GL context does not support color renderable floats");this.colorBufferHalfFloatExtension=this.gl.getExtension(s)}this.vertexBuffer=function bTe(n){return function oxe(n,t){const e=xl(n,()=>n.createBuffer(),"Unable to create WebGLBuffer");return dt(n,()=>n.bindBuffer(n.ARRAY_BUFFER,e)),dt(n,()=>n.bufferData(n.ARRAY_BUFFER,t,n.STATIC_DRAW)),e}(n,new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]))}(this.gl),this.indexBuffer=function _Te(n){return function axe(n,t){const e=xl(n,()=>n.createBuffer(),"Unable to create WebGLBuffer");return dt(n,()=>n.bindBuffer(n.ELEMENT_ARRAY_BUFFER,e)),dt(n,()=>n.bufferData(n.ELEMENT_ARRAY_BUFFER,t,n.STATIC_DRAW)),e}(n,new Uint16Array([0,1,2,2,1,3]))}(this.gl),this.framebuffer=function cxe(n){return xl(n,()=>n.createFramebuffer(),"Unable to create WebGLFramebuffer.")}(this.gl),this.textureConfig=CA(this.gl,this.textureHalfFloatExtension)}get debug(){return De().getBool("DEBUG")}dispose(){if(this.disposed)return;null!=this.program&&console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."),null!=this.outputTexture&&console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");const t=this.gl;dt(t,()=>t.finish()),dt(t,()=>t.bindFramebuffer(t.FRAMEBUFFER,null)),dt(t,()=>t.deleteFramebuffer(this.framebuffer)),dt(t,()=>t.bindBuffer(t.ARRAY_BUFFER,null)),dt(t,()=>t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,null)),dt(t,()=>t.deleteBuffer(this.indexBuffer)),this.disposed=!0}createFloat32MatrixTexture(t,e){return this.throwIfDisposed(),function vTe(n,t,e,r){const[s,i]=Sg(t,e);return Ig(n,s,i,ZU(r),r.textureFormatFloat,n.FLOAT)}(this.gl,t,e,this.textureConfig)}createFloat16MatrixTexture(t,e){return this.throwIfDisposed(),function wTe(n,t,e,r){const[s,i]=Sg(t,e);return Ig(n,s,i,QU(r),r.textureFormatFloat,r.textureTypeHalfFloat)}(this.gl,t,e,this.textureConfig)}createUnsignedBytesMatrixTexture(t,e){return this.throwIfDisposed(),function xTe(n,t,e,r){const[s,i]=Sg(t,e);return Ig(n,s,i,JU(r),n.RGBA,n.UNSIGNED_BYTE)}(this.gl,t,e,this.textureConfig)}uploadPixelDataToTexture(t,e){this.throwIfDisposed(),function ETe(n,t,e){dt(n,()=>n.bindTexture(n.TEXTURE_2D,t)),e.data instanceof Uint8Array?2===De().getNumber("WEBGL_VERSION")?dt(n,()=>n.texSubImage2D(n.TEXTURE_2D,0,0,0,e.width,e.height,n.RGBA,n.UNSIGNED_BYTE,e.data)):dt(n,()=>n.texImage2D(n.TEXTURE_2D,0,n.RGBA,e.width,e.height,0,n.RGBA,n.UNSIGNED_BYTE,e.data)):2===De().getNumber("WEBGL_VERSION")?dt(n,()=>n.texSubImage2D(n.TEXTURE_2D,0,0,0,n.RGBA,n.UNSIGNED_BYTE,e)):dt(n,()=>n.texImage2D(n.TEXTURE_2D,0,n.RGBA,n.RGBA,n.UNSIGNED_BYTE,e)),dt(n,()=>n.bindTexture(n.TEXTURE_2D,null))}(this.gl,t,e)}uploadDenseMatrixToTexture(t,e,r,s){this.throwIfDisposed(),function ITe(n,t,e,r,s,i){let o,a,u;dt(n,()=>n.bindTexture(n.TEXTURE_2D,t)),s instanceof Uint8Array?(o=new Uint8Array(e*r*4),a=n.UNSIGNED_BYTE,u=n.RGBA):(o=new Float32Array(e*r*4),a=n.FLOAT,u=i.internalFormatPackedFloat),o.set(s),2===De().getNumber("WEBGL_VERSION")?dt(n,()=>n.texSubImage2D(n.TEXTURE_2D,0,0,0,e,r,n.RGBA,a,o)):dt(n,()=>n.texImage2D(n.TEXTURE_2D,0,u,e,r,0,n.RGBA,a,o)),dt(n,()=>n.bindTexture(n.TEXTURE_2D,null))}(this.gl,t,e,r,s,this.textureConfig)}createFloat16PackedMatrixTexture(t,e){return this.throwIfDisposed(),function STe(n,t,e,r){const[s,i]=Uh(t,e);return Ig(n,s,i,tj(r),n.RGBA,r.textureTypeHalfFloat)}(this.gl,t,e,this.textureConfig)}createPackedMatrixTexture(t,e){return this.throwIfDisposed(),function TTe(n,t,e,r){const[s,i]=Uh(t,e);return Ig(n,s,i,ej(r),n.RGBA,n.FLOAT)}(this.gl,t,e,this.textureConfig)}deleteMatrixTexture(t){this.throwIfDisposed(),this.outputTexture===t&&(zU(this.gl,this.framebuffer),this.outputTexture=null),dt(this.gl,()=>this.gl.deleteTexture(t))}downloadByteEncodedFloatMatrixFromOutputTexture(t,e,r){return this.downloadMatrixDriver(t,()=>function kTe(n,t,e,r){const[s,i]=Sg(t,e),a=new Uint8Array(function Kwe(n,t){return n*t}(t*e,4));return dt(n,()=>n.readPixels(0,0,s,i,r.downloadTextureFormat,n.UNSIGNED_BYTE,a)),new Float32Array(a.buffer)}(this.gl,e,r,this.textureConfig))}downloadPackedMatrixFromBuffer(t,e,r,s,i,o){return function NTe(n,t,e,r,s,i,o,a){const u=n,c=new Float32Array(function Xwe(n,t){const[e,r]=Uh(n,t);return e*r*4}(i,o));return u.bindBuffer(u.PIXEL_PACK_BUFFER,t),u.getBufferSubData(u.PIXEL_PACK_BUFFER,0,c),u.bindBuffer(u.PIXEL_PACK_BUFFER,null),c}(this.gl,t,0,0,0,i,o)}downloadFloat32MatrixFromBuffer(t,e){return function ATe(n,t,e){const r=n,s=new Float32Array(e);return r.bindBuffer(r.PIXEL_PACK_BUFFER,t),r.getBufferSubData(r.PIXEL_PACK_BUFFER,0,s),r.bindBuffer(r.PIXEL_PACK_BUFFER,null),s}(this.gl,t,e)}createBufferFromTexture(t,e,r){this.bindTextureToFrameBuffer(t);const s=function DTe(n,t,e,r){const s=n.createBuffer();dt(n,()=>n.bindBuffer(n.PIXEL_PACK_BUFFER,s));const a=16*t*e;return dt(n,()=>n.bufferData(n.PIXEL_PACK_BUFFER,a,n.STREAM_READ)),dt(n,()=>n.readPixels(0,0,e,t,n.RGBA,n.FLOAT,0)),dt(n,()=>n.bindBuffer(n.PIXEL_PACK_BUFFER,null)),s}(this.gl,e,r);return this.unbindTextureToFrameBuffer(),s}createAndWaitForFence(){const t=this.createFence(this.gl);return this.pollFence(t)}createFence(t){let e,r;if(De().getBool("WEBGL_FENCE_API_ENABLED")){const s=t,i=s.fenceSync(s.SYNC_GPU_COMMANDS_COMPLETE,0);t.flush(),r=()=>{const o=s.clientWaitSync(i,0,0);return o===s.ALREADY_SIGNALED||o===s.CONDITION_SATISFIED},e=i}else De().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(e=this.beginQuery(),this.endQuery(),r=()=>this.isQueryAvailable(e,De().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))):r=()=>!0;return{query:e,isFencePassed:r}}downloadMatrixFromPackedTexture(t,e,r){return this.downloadMatrixDriver(t,()=>function OTe(n,t,e){const r=new Float32Array(t*e*4);return dt(n,()=>n.readPixels(0,0,e,t,n.RGBA,n.FLOAT,r)),r}(this.gl,e,r))}createProgram(t){this.throwIfDisposed();const e=this.gl;null==this.vertexShader&&(this.vertexShader=function yTe(n){const t=Gs();return function txe(n,t){const e=xl(n,()=>n.createShader(n.VERTEX_SHADER),"Unable to create vertex WebGLShader.");if(dt(n,()=>n.shaderSource(e,t)),dt(n,()=>n.compileShader(e)),!1===n.getShaderParameter(e,n.COMPILE_STATUS))throw console.log(n.getShaderInfoLog(e)),new Error("Failed to compile vertex shader.");return e}(n,`${t.version}\n    precision highp float;\n    ${t.attribute} vec3 clipSpacePos;\n    ${t.attribute} vec2 uv;\n    ${t.varyingVs} vec2 resultUV;\n\n    void main() {\n      gl_Position = vec4(clipSpacePos, 1);\n      resultUV = uv;\n    }`)}(e));const r=function sxe(n){return xl(n,()=>n.createProgram(),"Unable to create WebGLProgram.")}(e);dt(e,()=>e.attachShader(r,this.vertexShader)),dt(e,()=>e.attachShader(r,t)),function ixe(n,t){if(dt(n,()=>n.linkProgram(t)),!De().get("ENGINE_COMPILE_ONLY")&&!1===n.getProgramParameter(t,n.LINK_STATUS))throw console.log(n.getProgramInfoLog(t)),new Error("Failed to link vertex and fragment shaders.")}(e,r);const s=Object.assign(r,{vao:this.createVertexArray()});return this.debug&&IA(e,s),s}buildVao(t){this.setProgram(t),this.bindVertexArray(t.vao);const e=this.gl;dt(e,()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,this.indexBuffer)),function CTe(n,t,e){dt(n,()=>n.bindBuffer(n.ARRAY_BUFFER,e)),BU(n,t,"clipSpacePos",e,3,20,0)&&BU(n,t,"uv",e,2,20,12)}(e,t,this.vertexBuffer)}deleteProgram(t){this.throwIfDisposed(),t===this.program&&(this.program=null),null!=t&&(dt(this.gl,()=>this.gl.deleteProgram(t)),this.deleteVertexArray(t.vao))}setProgram(t){this.throwIfDisposed(),this.program=t,null!=this.program&&this.debug&&IA(this.gl,this.program),dt(this.gl,()=>this.gl.useProgram(t))}getUniformLocation(t,e,r=!0){return this.throwIfDisposed(),r?function hxe(n,t,e){return xl(n,()=>n.getUniformLocation(t,e),'uniform "'+e+'" not present in program.')}(this.gl,t,e):function pxe(n,t,e){return n.getUniformLocation(t,e)}(this.gl,t,e)}getAttributeLocation(t,e){return this.throwIfDisposed(),dt(this.gl,()=>this.gl.getAttribLocation(t,e))}getUniformLocationNoThrow(t,e){return this.throwIfDisposed(),this.gl.getUniformLocation(t,e)}setInputMatrixTexture(t,e,r){this.throwIfDisposed(),this.throwIfNoProgram(),fxe(this.gl,t,e,r)}setOutputMatrixTexture(t,e,r){this.setOutputMatrixTextureDriver(t,r,e)}setOutputPackedMatrixTexture(t,e,r){this.throwIfDisposed();const[s,i]=Uh(e,r);this.setOutputMatrixTextureDriver(t,s,i)}setOutputMatrixWriteRegion(t,e,r,s){this.setOutputMatrixWriteRegionDriver(r,t,s,e)}setOutputPackedMatrixWriteRegion(t,e,r,s){throw new Error("setOutputPackedMatrixWriteRegion not implemented.")}debugValidate(){null!=this.program&&IA(this.gl,this.program),L0(this.gl)}executeProgram(){this.throwIfDisposed(),this.throwIfNoProgram();const t=this.gl;if(this.debug){const e=this.getVertexArray();console.assert(e===this.program.vao,"VAO changed between setProgram and executeProgram!"),this.debugValidate()}dt(t,()=>t.drawElements(t.TRIANGLES,6,t.UNSIGNED_SHORT,0))}blockUntilAllProgramsCompleted(){this.throwIfDisposed(),dt(this.gl,()=>this.gl.finish())}getQueryTimerExtension(){return null==this.disjointQueryTimerExtension&&(this.disjointQueryTimerExtension=$0(this.gl,2===De().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")),this.disjointQueryTimerExtension}getQueryTimerExtensionWebGL2(){return this.getQueryTimerExtension()}getQueryTimerExtensionWebGL1(){return this.getQueryTimerExtension()}beginQuery(){if(2===De().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){const r=this.gl,s=this.getQueryTimerExtensionWebGL2(),i=r.createQuery();return r.beginQuery(s.TIME_ELAPSED_EXT,i),i}const t=this.getQueryTimerExtensionWebGL1(),e=t.createQueryEXT();return t.beginQueryEXT(t.TIME_ELAPSED_EXT,e),e}endQuery(){if(2===De().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){const e=this.gl,r=this.getQueryTimerExtensionWebGL2();return void e.endQuery(r.TIME_ELAPSED_EXT)}const t=this.getQueryTimerExtensionWebGL1();t.endQueryEXT(t.TIME_ELAPSED_EXT)}waitForQueryAndGetTime(t){var e=this;return Ve(function*(){return yield EL(()=>e.disposed||e.isQueryAvailable(t,De().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))),e.getQueryTime(t,De().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))})()}getQueryTime(t,e){if(0===e)return null;if(2===e){const r=this.gl;return r.getQueryParameter(t,r.QUERY_RESULT)/1e6}{const r=this.getQueryTimerExtensionWebGL1();return r.getQueryObjectEXT(t,r.QUERY_RESULT_EXT)/1e6}}isQueryAvailable(t,e){if(0===e)return!0;if(2===e){const r=this.gl,s=this.getQueryTimerExtensionWebGL2(),i=r.getQueryParameter(t,r.QUERY_RESULT_AVAILABLE);return null==this.disjoint&&(this.disjoint=this.gl.getParameter(s.GPU_DISJOINT_EXT)),i&&!this.disjoint}{const r=this.getQueryTimerExtensionWebGL1(),s=r.getQueryObjectEXT(t,r.QUERY_RESULT_AVAILABLE_EXT);return null==this.disjoint&&(this.disjoint=this.gl.getParameter(r.GPU_DISJOINT_EXT)),s&&!this.disjoint}}pollFence(t){return new Promise(e=>{this.addItemToPoll(()=>t.isFencePassed(),()=>e())})}pollItems(){const t=function RTe(n){let t=0;for(;t<n.length&&n[t]();++t);return t-1}(this.itemsToPoll.map(e=>e.isDoneFn));for(let e=0;e<=t;++e){const{resolveFn:r}=this.itemsToPoll[e];r()}this.itemsToPoll=this.itemsToPoll.slice(t+1)}addItemToPoll(t,e){if(this.itemsToPoll.push({isDoneFn:t,resolveFn:e}),this.itemsToPoll.length>1)return;let r;"setTimeoutCustom"in De().platform&&(r=De().platform.setTimeoutCustom.bind(De().platform)),EL(()=>(this.pollItems(),0===this.itemsToPoll.length),()=>0,null,r)}bindTextureToFrameBuffer(t){this.throwIfDisposed(),EA(this.gl,t,this.framebuffer),this.debug&&L0(this.gl)}unbindTextureToFrameBuffer(){null!=this.outputTexture?(EA(this.gl,this.outputTexture,this.framebuffer),this.debug&&L0(this.gl)):zU(this.gl,this.framebuffer)}downloadMatrixDriver(t,e){this.bindTextureToFrameBuffer(t);const r=e();return this.unbindTextureToFrameBuffer(),r}setOutputMatrixTextureDriver(t,e,r){this.throwIfDisposed();const s=this.gl;EA(s,t,this.framebuffer),this.debug&&L0(s),this.outputTexture=t,dt(s,()=>s.viewport(0,0,e,r)),dt(s,()=>s.scissor(0,0,e,r))}setOutputMatrixWriteRegionDriver(t,e,r,s){this.throwIfDisposed(),dt(this.gl,()=>this.gl.scissor(t,e,r,s))}throwIfDisposed(){if(this.disposed)throw new Error("Attempted to use disposed GPGPUContext.")}throwIfNoProgram(){if(null==this.program)throw new Error("No GPU program is currently set.")}}const{addImpl:MTe,bincountImpl:nj,bincountReduceImpl:PTe,castImpl:FTe,ceilImpl:$Te,concatImpl:LTe,equalImpl:VTe,expImpl:BTe,expm1Impl:zTe,floorImpl:UTe,gatherNdImpl:jTe,gatherV2Impl:GTe,greaterImpl:WTe,greaterEqualImpl:HTe,lessImpl:qTe,lessEqualImpl:KTe,linSpaceImpl:XTe,logImpl:YTe,maxImpl:ZTe,maximumImpl:QTe,minimumImpl:JTe,multiplyImpl:eSe,negImpl:tSe,notEqualImpl:nSe,prodImpl:rSe,raggedGatherImpl:sSe,raggedRangeImpl:iSe,raggedTensorToTensorImpl:oSe,rangeImpl:aSe,rsqrtImpl:lSe,scatterImpl:uSe,sigmoidImpl:cSe,simpleAbsImpl:rj,sliceImpl:dSe,sparseFillEmptyRowsImpl:hSe,sparseReshapeImpl:pSe,sparseSegmentReductionImpl:sj,sqrtImpl:fSe,staticRegexReplaceImpl:mSe,stridedSliceImpl:gSe,stringNGramsImpl:ySe,stringSplitImpl:bSe,stringToHashBucketFastImpl:_Se,subImpl:vSe,tileImpl:wSe,topKImpl:xSe,transposeImpl:RA,uniqueImpl:TSe}=Y;function ij(n,t){return["x","y","z","w","u","v"].slice(0,t).map(e=>`${n}.${e}`)}function Ws(n,t){return 1===t?[n]:ij(n,t)}class CSe{constructor(t){if(this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outputShape=t,this.rank=t.length,this.enableShapeUniforms=Rs(this.outputShape.length),0===this.rank)this.userCode="\n        void main() {\n          setOutput(vec4(getA(), 0., 0., 0.));\n        }\n      ";else{const e=Ws("rc",this.rank),r=Vn(this.rank),s=this.getOutOfBoundsCondition(e),i=this.getSetup(e),o=this.getOutput(e);this.userCode=`\n        void main() {\n          ${r} rc = getOutputCoords();\n\n          if(${s}) {\n            setOutput(vec4(0));\n          } else {\n            ${i}\n\n            setOutput(vec4(${o}));\n          }\n        }\n      `}}getSourceCoordsArr(t){const e=[];for(let r=0;r<=1;r++)for(let s=0;s<=1;s++){let i=`${0===r?"r":"rp1"}, ${0===s?"c":"cp1"}`;for(let o=2;o<this.rank;o++)i=`${t[t.length-1-o]},`+i;e.push(i)}return e}getOutOfBoundsCondition(t){if(1===this.rank)return`rc > ${this.enableShapeUniforms?"outShape":this.outputShape[0]}`;let e="";for(let r=this.rank-2;r<this.rank;r++)e+=`${t[r]} >= ${this.enableShapeUniforms?`outShape[${r}]`:this.outputShape[r]}`,r<this.rank-1&&(e+="||");return e}getSetup(t){if(1===this.rank)return"";const e=t.slice(-2);return`\n      int r = ${e[0]};\n      int c = ${e[1]};\n      int rp1 = r + 1;\n      int cp1 = c + 1;\n\n      bool cEdge = cp1 >= ${this.enableShapeUniforms?`outShape[${this.rank} - 1]`:this.outputShape[this.rank-1]};\n      bool rEdge = rp1 >= ${this.enableShapeUniforms?`outShape[${this.rank} - 2]`:this.outputShape[this.rank-2]};\n    `}getOutput(t){const e=this.getSourceCoordsArr(t);return 1===this.rank?`getA(rc), (rc + 1 >= ${this.enableShapeUniforms?"outShape":this.outputShape[0]} ? 0. : getA(rc + 1)), 0, 0`:`getA(${e[0]}),\n            cEdge ? 0. : getA(${e[1]}),\n            rEdge ? 0. : getA(${e[2]}),\n            rEdge || cEdge ? 0. : getA(${e[3]})`}}class oj{constructor(t,e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec3"}],this.outputShape=t,this.enableShapeUniforms=Rs(this.outputShape.length);let r="";for(let s=0;s<4;s++){let i="thisRC = rc;";s%2==1&&(i+="thisRC.z += 1;"),s>1&&(i+="thisRC.y += 1;"),r+=`\n        ${i}\n        ${s>0?"if(thisRC.y < rows && thisRC.z < cols){":""}\n          int flatIndex = getFlatIndex(thisRC);\n\n          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);\n          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));\n\n          result[${s}] =\n            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);\n        ${s>0?"}":""}\n      `}this.userCode=`\n      ${function ISe(n,t){return`\n    ivec3 inputCoordsFromReshapedOutCoords(int index) {\n      ${t?function Cxe(n,t,e="index"){const s=function Sxe(n,t){const e=n.length,r=n.map(i=>`${t}[${i}]`),s=new Array(e-1);s[e-2]=r[e-1];for(let i=e-3;i>=0;--i)s[i]=`(${s[i+1]} * ${r[i+1]})`;return s}(n.map((i,o)=>o),t);return s.map((i,o)=>`int ${n[o]} = ${e} / ${s[o]}; ${o===s.length-1?`int ${n[o+1]} = ${e} - ${n[o]} * ${s[o]}`:`index -= ${n[o]} * ${s[o]}`};`).join("")}(["r","c","d"],"inputShape"):Vc(["r","c","d"],n)}\n      return ivec3(r, c, d);\n    }\n  `}(e,this.enableShapeUniforms)}\n      ${this.enableShapeUniforms?"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n":AA(t)}\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0.);\n\n        ivec3 thisRC;\n        int rows = ${this.enableShapeUniforms?"outShape[1]":t[1]};\n        int cols = ${this.enableShapeUniforms?"outShape[2]":t[2]};\n\n        ${r}\n\n        setOutput(result);\n      }\n    `}}class ESe{constructor(t){this.gpgpu=t,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0,this.freeTextures={},this.usedTextures={},this.logEnabled=!1}acquireTexture(t,e,r){const s=lj(e,r),i=uj(t,s,r);i in this.freeTextures||(this.freeTextures[i]=[]),i in this.usedTextures||(this.usedTextures[i]=[]);const o=aj(t,s,this.gpgpu.gl,this.gpgpu.textureConfig,r);if(this.freeTextures[i].length>0){this.numFreeTextures--,this.numUsedTextures++,this._numBytesFree-=o,this.log();const u=this.freeTextures[i].pop();return this.usedTextures[i].push(u),u}let a;return s===Ln.PACKED_2X2_FLOAT32?a=this.gpgpu.createPackedMatrixTexture(t[0],t[1]):s===Ln.PACKED_2X2_FLOAT16?a=this.gpgpu.createFloat16PackedMatrixTexture(t[0],t[1]):s===Ln.UNPACKED_FLOAT32?a=this.gpgpu.createFloat32MatrixTexture(t[0],t[1]):s===Ln.UNPACKED_FLOAT16?a=this.gpgpu.createFloat16MatrixTexture(t[0],t[1]):s===Ln.PACKED_4X1_UNSIGNED_BYTE&&(a=this.gpgpu.createUnsignedBytesMatrixTexture(t[0],t[1])),this.usedTextures[i].push(a),this.numUsedTextures++,this._numBytesAllocated+=o,this.log(),a}releaseTexture(t,e,r,s){if(null==this.freeTextures)return;const i=lj(r,s),o=uj(e,i,s);o in this.freeTextures||(this.freeTextures[o]=[]);const a=aj(e,i,this.gpgpu.gl,this.gpgpu.textureConfig,s),u=De().get("WEBGL_DELETE_TEXTURE_THRESHOLD");-1!==u&&this._numBytesAllocated>u?(this.gpgpu.deleteMatrixTexture(t.texture),this._numBytesAllocated-=a):(this.freeTextures[o].push(t),this.numFreeTextures++,this._numBytesFree+=a),this.numUsedTextures--;const c=this.usedTextures[o],p=c&&c.indexOf(t);if(null==p||p<0)throw new Error("Cannot release a texture that was never provided by this texture manager");c[p]=c[c.length-1],c.pop(),this.log()}log(){if(!this.logEnabled)return;console.log("Free/Used",`${this.numFreeTextures} / ${this.numUsedTextures}`,`(${this.numFreeTextures+this.numUsedTextures})`);const e=this._numBytesFree/this._numBytesAllocated;console.log(`Bytes allocated: ${this._numBytesAllocated}`),console.log(`Bytes unused: ${this._numBytesFree} (${Math.round(100*e)}%)`)}get numBytesAllocated(){return this._numBytesAllocated}get numBytesFree(){return this._numBytesFree}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){if(null!=this.freeTextures){for(const t in this.freeTextures)this.freeTextures[t].forEach(e=>{this.gpgpu.deleteMatrixTexture(e.texture)});for(const t in this.usedTextures)this.usedTextures[t].forEach(e=>{this.gpgpu.deleteMatrixTexture(e.texture)});this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0}}}function aj(n,t,e,r,s){const i=function ASe(n,t){switch(n){case Ln.PACKED_2X2_FLOAT32:return ej(t);case Ln.PACKED_2X2_FLOAT16:return tj(t);case Ln.UNPACKED_FLOAT32:return ZU(t);case Ln.UNPACKED_FLOAT16:return QU(t);case Ln.PACKED_4X1_UNSIGNED_BYTE:return JU(t);default:throw new Error(`Unknown physical texture type ${n}`)}}(t,r);let o;if(s){const[u,c]=Uh(n[0],n[1]);o=u*c}else{const[u,c]=Sg(n[0],n[1]);o=u*c}const a=function DSe(n,t){if(t===n.R32F)return 4;if(t===n.R16F)return 2;if(t===n.RGBA32F)return 16;if(t===n.RGBA)return 16;if(t===n.RGBA16F)return 8;if(t===n.RGBA8)return 4;throw new Error(`Unknown internal format ${t}`)}(e,i);return o*a}function lj(n,t){if(n===Mr.UPLOAD)return Ln.PACKED_2X2_FLOAT32;if(n===Mr.RENDER||null==n)return function kSe(n){return De().getBool("WEBGL_RENDER_FLOAT32_ENABLED")?n?Ln.PACKED_2X2_FLOAT32:Ln.UNPACKED_FLOAT32:n?Ln.PACKED_2X2_FLOAT16:Ln.UNPACKED_FLOAT16}(t);if(n===Mr.DOWNLOAD||n===Mr.PIXELS)return Ln.PACKED_4X1_UNSIGNED_BYTE;throw new Error(`Unknown logical texture type ${n}`)}function uj(n,t,e){return`${n[0]}_${n[1]}_${t}_${e}`}class ja{constructor(t,e){this.variableNames=["A"],this.outputShape=t,this.enableShapeUniforms=Rs(this.outputShape.length),this.userCode=`\n      float unaryOperation(float x) {\n        ${e}\n      }\n\n      void main() {\n        float x = getAAtOutCoords();\n        float y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    `}}const Zi="if (isnan(x)) return x;",NSe="return x;",cj="return abs(x);",OSe="return (x >= 0.0) ? x : (exp(x) - 1.0);",RSe=Zi+"\n  return (x < 0.0) ? 0.0 : x;\n",MSe=Zi+"\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n",Eu="return x;",PSe="return 1.0 / (1.0 + exp(-1.0 * x));",FSe="return x;",$Se="\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n",LSe="\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",VSe="\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",BSe="return 1.0 / (1.0 + exp(-1.0 * x));";class Du{constructor(t,e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t,this.enableShapeUniforms=Rs(this.outputShape.length),this.userCode=`\n      vec4 unaryOperation(vec4 x) {\n        ${e}\n      }\n\n      void main() {\n        vec4 x = getAAtOutCoords();\n        vec4 y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    `}}class zSe{constructor(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outputShape=t,this.enableShapeUniforms=Rs(this.outputShape.length);const e=t.length,r=Ws("rc",e),s=Vn(e),i=function SSe(n,t){if(1===n)return"rc";let e="";for(let r=0;r<n;r++)e+=t[r],r<n-1&&(e+=",");return e}(e,r),o=r.slice(-2),a=e<=1?"rc":`vec2(${o.join(",")})`;this.userCode=`\n      void main() {\n        ${s} rc = getOutputCoords();\n        vec4 packedInput = getA(${i});\n\n        setOutput(getChannel(packedInput, ${a}));\n      }\n    `}}const USe=xE,H0={},HSe=De().getNumber("CPU_HANDOFF_SIZE_THRESHOLD");let XSe=(()=>{class n extends j1{nextDataId(){return n.nextDataId++}constructor(e){if(super(),this.pendingRead=new WeakMap,this.pendingDisposal=new WeakSet,this.dataRefCount=new WeakMap,this.numBytesInGPU=0,this.uploadWaitMs=0,this.downloadWaitMs=0,this.lastGlFlushTime=0,this.warnedAboutMemory=!1,this.pendingDeletes=0,this.disposed=!1,!De().getBool("HAS_WEBGL"))throw new Error("WebGL is not supported on this device");let r;if(null!=e){if(e instanceof OA)r=e;else{const s=sa(De().getNumber("WEBGL_VERSION"),e);r=new OA(s)}this.binaryCache={},this.gpgpuCreatedLocally=!1}else{const s=sa(De().getNumber("WEBGL_VERSION"));r=new OA(s),this.binaryCache=function WSe(n){return n in H0||(H0[n]={}),H0[n]}(De().getNumber("WEBGL_VERSION")),this.gpgpuCreatedLocally=!0}this.gpgpu=r,this.canvas=this.gpgpu.gl.canvas,this.textureManager=new ESe(this.gpgpu),this.numMBBeforeWarning=function KSe(){return null==De().global.screen?1024:De().global.screen.height*De().global.screen.width*window.devicePixelRatio*600/1024/1024}(),this.texData=new CL(this,Da())}numDataIds(){return this.texData.numDataIds()-this.pendingDeletes}writeTexture(e,r,s,i,o,a){const u=this.makeTensorInfo(r,s),c=this.texData.get(u.dataId);c.isPacked=!1,c.texture={texture:e,texShape:[i,o]},c.texShape=[i,o];const p=V0(r),m=new YU(p,!1,a),y=this.runWebGLProgram(m,[u],s,[[i,o]]);return y.shape=r,c.texture=null,this.disposeIntermediateTensorInfo(u),y.dataId}write(e,r,s){if((De().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS")||De().getBool("DEBUG"))&&this.checkNumericalProblems(e),"complex64"===s&&null!=e)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");const i={id:this.nextDataId()};return this.texData.set(i,{shape:r,dtype:s,values:e,usage:Mr.UPLOAD,refCount:1}),i}refCount(e){return this.texData.has(e)?this.texData.get(e).refCount:0}incRef(e){this.texData.get(e).refCount++}decRef(e){this.texData.has(e)&&this.texData.get(e).refCount--}move(e,r,s,i,o){if(De().getBool("DEBUG")&&this.checkNumericalProblems(r),"complex64"===i)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.texData.set(e,{shape:s,dtype:i,values:r,usage:Mr.UPLOAD,refCount:o})}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}readSync(e){const r=this.texData.get(e),{values:s,dtype:i,complexTensorInfos:o,slice:a,shape:u,isPacked:c}=r;if(null!=a){let _;_=c?new Du(u,Eu):new ja(u,Eu);const w=this.runWebGLProgram(_,[{dataId:e,shape:u,dtype:i}],i),T=this.readSync(w.dataId);return this.disposeIntermediateTensorInfo(w),T}if(null!=s)return this.convertAndCacheOnCPU(e);if("string"===i)return s;const p=null!=this.activeTimers;let m,y;return p&&(m=ri()),y="complex64"===i?gl(this.readSync(o.real.dataId),this.readSync(o.imag.dataId)):this.getValuesFromTexture(e),p&&(this.downloadWaitMs+=ri()-m),this.convertAndCacheOnCPU(e,y)}read(e){var r=this;return Ve(function*(){if(r.pendingRead.has(e)){const I=r.pendingRead.get(e);return new Promise(O=>I.push(O))}const s=r.texData.get(e),{values:i,shape:o,slice:a,dtype:u,complexTensorInfos:c,isPacked:p}=s;if(null!=a){let I;I=p?new Du(o,Eu):new ja(o,Eu);const O=r.runWebGLProgram(I,[{dataId:e,shape:o,dtype:u}],u),M=r.read(O.dataId);return r.disposeIntermediateTensorInfo(O),M}if(null!=i)return r.convertAndCacheOnCPU(e);if(De().getBool("DEBUG")&&!De().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&2===De().getNumber("WEBGL_VERSION"))throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");let y,_,m=null;if("complex64"!==u&&De().get("WEBGL_BUFFER_SUPPORTED")){y=r.decode(e);const I=r.texData.get(y.dataId);m=r.gpgpu.createBufferFromTexture(I.texture.texture,...F0(o))}if(r.pendingRead.set(e,[]),"complex64"!==u&&(yield r.gpgpu.createAndWaitForFence()),"complex64"===u){const I=yield Promise.all([r.read(c.real.dataId),r.read(c.imag.dataId)]);_=gl(I[0],I[1])}else if(null==m)_=r.getValuesFromTexture(e);else{const I=Fe(o);_=r.gpgpu.downloadFloat32MatrixFromBuffer(m,I)}if(null!=y&&r.disposeIntermediateTensorInfo(y),null!=m){const I=r.gpgpu.gl;dt(I,()=>I.deleteBuffer(m))}const w=r.convertAndCacheOnCPU(e,_),T=r.pendingRead.get(e);return r.pendingRead.delete(e),T.forEach(I=>I(w)),r.pendingDisposal.has(e)&&(r.pendingDisposal.delete(e),r.disposeData(e)&&Da().removeDataId(e,r),r.pendingDeletes--),w})()}readToGPU(e,r={}){const s=this.texData.get(e),{values:i,shape:o,slice:a,dtype:u,isPacked:c,texture:p}=s;if("complex64"===u)throw new Error("Does not support reading texture for complex64 dtype.");if(null!=a){let w;w=c?new Du(o,Eu):new ja(o,Eu);const T=this.runWebGLProgram(w,[{dataId:e,shape:o,dtype:u}],u),I=this.readToGPU(T,r);return this.disposeIntermediateTensorInfo(T),I}if(null==p)throw null!=i?new Error("Data is not on GPU but on CPU."):new Error("There is no data on GPU or CPU.");const m=this.decode(e,r.customTexShape),y=Da().makeTensorFromTensorInfo(m),_=this.texData.get(m.dataId);return Object.assign({tensorRef:y},_.texture)}bufferSync(e){const r=this.readSync(e.dataId);if("string"===e.dtype)try{const s=r.map(i=>Jl(i));return tn(e.shape,e.dtype,s)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return tn(e.shape,e.dtype,r)}checkNumericalProblems(e){if(null!=e)for(let r=0;r<e.length;r++){const s=e[r];if(!Jwe(s))throw De().getBool("WEBGL_RENDER_FLOAT32_CAPABLE")?Error(`The value ${s} cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'`):Error(`The value ${s} cannot be represented on this device.`)}}getValuesFromTexture(e){const{shape:r,dtype:s,isPacked:i}=this.texData.get(e),o=Fe(r);if(De().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")){const _=this.decode(e),w=this.texData.get(_.dataId),T=this.gpgpu.downloadMatrixFromPackedTexture(w.texture.texture,...F0(r)).subarray(0,o);return this.disposeIntermediateTensorInfo(_),T}const a=De().getBool("WEBGL_PACK")&&!0===i,u=a?V0(r):r,c=a?new fTe(u):new pTe(u),p=this.runWebGLProgram(c,[{shape:u,dtype:s,dataId:e}],"float32"),m=this.texData.get(p.dataId),y=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(m.texture.texture,m.texShape[0],m.texShape[1]).subarray(0,o);return this.disposeIntermediateTensorInfo(p),y}timerAvailable(){return De().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0}time(e){var r=this;const s=this.activeTimers,i=[];let o=!1;null==this.programTimersStack?(this.programTimersStack=i,o=!0):this.activeTimers.push(i),this.activeTimers=i,e();const a=_c(this.activeTimers.map(p=>p.query)).filter(p=>null!=p),u=_c(this.activeTimers.map(p=>p.name)).filter(p=>null!=p);this.activeTimers=s,o&&(this.programTimersStack=null);const c={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null};return Ve(function*(){if(De().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0){const p=yield Promise.all(a);c.kernelMs=function One(n){let t=0;for(let e=0;e<n.length;e++)t+=n[e];return t}(p),c.getExtraProfileInfo=()=>p.map((m,y)=>({name:u[y],ms:m})).map(m=>`${m.name}: ${m.ms}`).join(", ")}else c.kernelMs={error:"WebGL query timers are not supported in this environment."};return r.uploadWaitMs=0,r.downloadWaitMs=0,c})()}memory(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU,numBytesInGPUAllocated:this.textureManager.numBytesAllocated,numBytesInGPUFree:this.textureManager.numBytesFree}}startTimer(){return De().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.beginQuery():{startMs:ri(),endMs:null}}endTimer(e){return De().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?(this.gpgpu.endQuery(),e):(e.endMs=ri(),e)}getQueryTime(e){var r=this;return Ve(function*(){return De().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?r.gpgpu.waitForQueryAndGetTime(e):e.endMs-e.startMs})()}disposeData(e,r=!1){if(this.pendingDisposal.has(e))return!1;if(!this.texData.has(e))return!0;if(r?this.texData.get(e).refCount=0:this.texData.get(e).refCount--,!r&&this.texData.get(e).refCount>0)return!1;if(this.pendingRead.has(e))return this.pendingDisposal.add(e),this.pendingDeletes++,!1;this.releaseGPUData(e);const{complexTensorInfos:s}=this.texData.get(e);return null!=s&&(this.disposeData(s.real.dataId,r),this.disposeData(s.imag.dataId,r)),this.texData.delete(e),!0}releaseGPUData(e){const{texture:r,dtype:s,texShape:i,usage:o,isPacked:a,slice:u}=this.texData.get(e),c=u&&u.origDataId||e,p=this.dataRefCount.get(c);p>1?this.dataRefCount.set(c,p-1):(this.dataRefCount.delete(c),null!=r&&(this.numBytesInGPU-=this.computeBytes(i,s),this.textureManager.releaseTexture(r,i,o,a)));const m=this.texData.get(e);m.texture=null,m.texShape=null,m.isPacked=!1,m.slice=null}getTexture(e){return this.uploadToGPU(e),this.texData.get(e).texture.texture}getDataInfo(e){return this.texData.get(e)}shouldExecuteOnCPU(e,r=HSe){return De().getBool("WEBGL_CPU_FORWARD")&&e.every(s=>null==this.texData.get(s.dataId).texture&&Fe(s.shape)<r)}getGPGPUContext(){return this.gpgpu}where(e){Ui("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");const r=e.dataSync();return USe(e.shape,r)}packedUnaryOp(e,r,s){const i=new Du(e.shape,r),o=this.compileAndRun(i,[e],s);return Da().makeTensorFromTensorInfo(o)}abs(e){if(this.shouldExecuteOnCPU([e])&&"complex64"!==e.dtype){const i=rj(this.texData.get(e.dataId).values);return this.makeOutput(e.shape,e.dtype,i)}if(De().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(e,cj,e.dtype);const r=new ja(e.shape,cj),s=this.compileAndRun(r,[e]);return Da().makeTensorFromTensorInfo(s)}makeTensorInfo(e,r,s){let i;if("string"===r&&null!=s&&s.length>0&&Uf(s[0])){const o=s.map(a=>Ql(a));i=this.write(o,e,r)}else i=this.write(s,e,r);return this.texData.get(i).usage=null,{dataId:i,shape:e,dtype:r}}makeOutput(e,r,s){return Da().makeTensorFromTensorInfo(this.makeTensorInfo(e,r,s),this)}unpackTensor(e){const r=new zSe(e.shape);return this.runWebGLProgram(r,[e],e.dtype)}packTensor(e){const r=new CSe(e.shape);return this.runWebGLProgram(r,[e],e.dtype,null,!0)}packedReshape(e,r){const s=[jh(e.shape),...Gh(e.shape)],i={dtype:e.dtype,shape:s,dataId:e.dataId},o=[jh(r),...Gh(r)],a=new oj(o,s),p=this.runWebGLProgram(a,[i],e.dtype,[s],!0);return{dataId:p.dataId,shape:r,dtype:p.dtype}}decode(e,r){const s=this.texData.get(e),{isPacked:i,shape:o,dtype:a}=s;null!=r&&J(Fe(o)<=r[0]*r[1]*4,()=>"customTexShape is too small. Row * Column * 4 should be equal or larger than the size of the tensor data.");const u=V0(o);let c;c=i?new hTe(u):new dTe(u);const m=[r??F0(u)];return{dtype:a,shape:o,dataId:this.runWebGLProgram(c,[{shape:u,dtype:a,dataId:e}],a,m,!0,r).dataId}}runWebGLProgram(e,r,s,i,o=!1,a){const u=this.makeTensorInfo(e.outputShape,s),c=this.texData.get(u.dataId);if(e.packedOutput&&(c.isPacked=!0),e.outPackingScheme===Ua.DENSE){const M=a??F0(e.outputShape);c.texShape=M.map(V=>2*V)}if(null!=e.outTexUsage&&(c.usage=e.outTexUsage),0===Fe(u.shape))return c.values=_s(u.dtype,0),u;const p=[],m=r.map(M=>{if("complex64"===M.dtype)throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");let V=this.texData.get(M.dataId);if(null==V.texture){if(!e.packedInputs&&Fe(M.shape)<=De().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))return{shape:M.shape,texData:null,isUniform:!0,uniformValues:V.values};e.packedInputs&&(V.isPacked=!0,V.shape=M.shape)}if(this.uploadToGPU(M.dataId),!!V.isPacked!=!!e.packedInputs)M=V.isPacked?this.unpackTensor(M):this.packTensor(M),p.push(M),V=this.texData.get(M.dataId);else if(V.isPacked&&!z0(V.shape,M.shape)){const z=M,G=M.shape;M.shape=V.shape,M=this.packedReshape(M,G),p.push(M),V=this.texData.get(M.dataId),z.shape=G}return{shape:M.shape,texData:V,isUniform:!1}});this.uploadToGPU(u.dataId);const y={shape:u.shape,texData:c,isUniform:!1},_=function cTe(n,t,e){let r="";t.concat(e).forEach(o=>{const a=null!=o.texData&&null!=o.texData.slice&&o.texData.slice.flatOffset>0;if(n.enableShapeUniforms&&!o.isUniform){const u=o.texData.texShape,{useSqueezeShape:c,uniformShape:p,keptDims:m}=NA(n.packedInputs,o.shape,u);let y="",_="",w="";if(1===p.length&&n.packedInputs){const G=[Math.ceil(u[0]/2),Math.ceil(u[1]/2)];y=`${G[0]>1}_${G[1]>1}`}else if(2!==p.length||n.packedInputs){if(p.length>2&&!n.packedInputs){const G=Nt(p);w=`${G[0]===u[1]}_${G[G.length-1]===u[1]}`}}else _=`${p[0]>1}_${p[1]>1}`;const T=o.shape.length,I=2===p.length&&hn(o.shape,u),O=1===Fe(o.shape),M=wh(o.shape,e.shape),V=!n.packedInputs&&T===e.shape.length&&hn(u,e.texData.texShape);r+=`${T}_${V}_${c?m:""}_${p.length}_${O}_${M}_${I}_${y}_${_}_${w}_${n.packedInputs||p.length>2?"":`${u[0]>1}_${u[1]>1}`}_${a}`}else r+=`${o.shape}_${o.isUniform?"uniform":o.texData.texShape}_${a}`});let i=n.constructor.name;return i+="_"+r+"_"+n.userCode+`${De().getNumber("WEBGL_VERSION")}`,i}(e,m,y),w=this.getAndSaveBinary(_,()=>function lTe(n,t,e,r){const s=e.map((p,m)=>{const y={logicalShape:p.shape,texShape:p.isUniform?null:p.texData.texShape,isUniform:p.isUniform,isPacked:!p.isUniform&&p.texData.isPacked,flatOffset:null};return null!=p.texData&&null!=p.texData.slice&&p.texData.slice.flatOffset>0&&(y.flatOffset=p.texData.slice.flatOffset),{name:t.variableNames[m],shapeInfo:y}}),i=s.map(p=>p.shapeInfo),o={logicalShape:r.shape,texShape:r.texData.texShape,isUniform:!1,isPacked:r.texData.isPacked,flatOffset:null},a=Ixe(s,o,t),u=function nxe(n,t){const e=xl(n,()=>n.createShader(n.FRAGMENT_SHADER),"Unable to create fragment WebGLShader.");if(dt(n,()=>n.shaderSource(e,t)),dt(n,()=>n.compileShader(e)),De().get("ENGINE_COMPILE_ONLY"))return e;if(!1===n.getShaderParameter(e,n.COMPILE_STATUS))throw VU(t,n.getShaderInfoLog(e)),new Error("Failed to compile fragment shader.");return e}(n.gl,a),c=n.createProgram(u);return De().get("ENGINE_COMPILE_ONLY")?{program:t,fragmentShader:u,source:a,webGLProgram:c,inShapeInfos:i,outShapeInfo:o,variablesLocations:null,customUniformLocations:null,infLoc:null,nanLoc:null,outShapeLocation:null,outShapeStridesLocation:null,outTexShapeLocation:null}:(n.buildVao(c),Object.assign({program:t,fragmentShader:u,source:a,webGLProgram:c,inShapeInfos:i,outShapeInfo:o},KU(n,t,c)))}(this.gpgpu,e,m,y)),T=null!=this.activeTimers;let I;T&&(I=this.startTimer()),De().get("ENGINE_COMPILE_ONLY")||function uTe(n,t,e,r,s){t.program.enableShapeUniforms||(XU(t.inShapeInfos,e),XU([t.outShapeInfo],[r]));const i=r.texData.texture,o=r.texData.texShape;r.texData.isPacked?n.setOutputPackedMatrixTexture(i.texture,o[0],o[1]):n.setOutputMatrixTexture(i.texture,o[0],o[1]),n.setProgram(t.webGLProgram),n.bindVertexArray(t.webGLProgram.vao),1===De().getNumber("WEBGL_VERSION")&&null!==t.infLoc&&n.gl.uniform1f(t.infLoc,1/0),null!==t.nanLoc&&n.gl.uniform1f(t.nanLoc,NaN);for(let u=0;u<e.length;++u){const c=e[u],{uniform:p,offset:m,shape:y,texShape:_}=t.variablesLocations[u];if(y){const{uniformShape:w}=NA(t.program.packedInputs,c.shape,c.texData.texShape);switch(w.length){case 1:n.gl.uniform1iv(y,new Int32Array(w));break;case 2:n.gl.uniform2iv(y,new Int32Array(w));break;case 3:n.gl.uniform3iv(y,new Int32Array(w));break;case 4:n.gl.uniform4iv(y,new Int32Array(w))}}if(_&&n.gl.uniform2i(_,c.texData.texShape[0],c.texData.texShape[1]),null!=p){if(c.isUniform){if(Fe(c.shape)<2)n.gl.uniform1f(p,c.uniformValues[0]);else{let w=c.uniformValues;w instanceof Float32Array||(w=new Float32Array(w)),n.gl.uniform1fv(p,w)}continue}null!=c.texData.slice&&null!=m&&n.gl.uniform1i(m,c.texData.slice.flatOffset),n.setInputMatrixTexture(c.texData.texture.texture,p,u)}}const a=t.outShapeLocation;if(a)switch(r.shape.length){case 1:n.gl.uniform1iv(a,new Int32Array(r.shape));break;case 2:n.gl.uniform2iv(a,new Int32Array(r.shape));break;case 3:n.gl.uniform3iv(a,new Int32Array(r.shape));break;case 4:n.gl.uniform4iv(a,new Int32Array(r.shape))}if(t.outShapeStridesLocation){const u=Nt(r.shape);switch(r.shape.length){case 2:n.gl.uniform1iv(t.outShapeStridesLocation,new Int32Array(u));break;case 3:n.gl.uniform2iv(t.outShapeStridesLocation,new Int32Array(u));break;case 4:n.gl.uniform3iv(t.outShapeStridesLocation,new Int32Array(u))}}if(t.outTexShapeLocation&&n.gl.uniform2i(t.outTexShapeLocation,r.texData.texShape[0],r.texData.texShape[1]),t.program.customUniforms&&s)for(let u=0;u<t.program.customUniforms.length;++u){const c=t.program.customUniforms[u],p=t.customUniformLocations[u],m=s[u];if("float"===c.type)n.gl.uniform1fv(p,m);else if("vec2"===c.type)n.gl.uniform2fv(p,m);else if("vec3"===c.type)n.gl.uniform3fv(p,m);else if("vec4"===c.type)n.gl.uniform4fv(p,m);else if("int"===c.type)n.gl.uniform1iv(p,m);else if("ivec2"===c.type)n.gl.uniform2iv(p,m);else if("ivec3"===c.type)n.gl.uniform3iv(p,m);else{if("ivec4"!==c.type)throw Error(`uniform type ${c.type} is not supported yet.`);n.gl.uniform4iv(p,m)}}n.executeProgram()}(this.gpgpu,w,m,y,i),p.forEach(M=>this.disposeIntermediateTensorInfo(M)),T&&(I=this.endTimer(I),this.activeTimers.push({name:e.constructor.name,query:this.getQueryTime(I)}));const O=De().get("WEBGL_FLUSH_THRESHOLD");if(O>0){const M=ri();M-this.lastGlFlushTime>O&&(this.gpgpu.gl.flush(),this.lastGlFlushTime=M)}if(!De().getBool("WEBGL_LAZILY_UNPACK")&&c.isPacked&&!1===o){const M=this.unpackTensor(u);return this.disposeIntermediateTensorInfo(u),M}return u}compileAndRun(e,r,s,i,o=!1){return this.runWebGLProgram(e,r,s=s||r[0].dtype,i,o)}getAndSaveBinary(e,r){return e in this.binaryCache||(this.binaryCache[e]=r()),this.binaryCache[e]}getTextureManager(){return this.textureManager}dispose(){this.disposed||(De().getBool("IS_TEST")||Object.keys(this.binaryCache).forEach(r=>{this.gpgpu.deleteProgram(this.binaryCache[r].webGLProgram),delete this.binaryCache[r]}),this.textureManager.dispose(),null!=this.canvas&&typeof HTMLCanvasElement<"u"&&this.canvas instanceof HTMLCanvasElement?this.canvas.remove():this.canvas=null,this.gpgpuCreatedLocally&&(this.gpgpu.program=null,this.gpgpu.dispose()),this.disposed=!0)}floatPrecision(){return null==this.floatPrecisionValue&&(this.floatPrecisionValue=Ce(()=>{if(!De().get("WEBGL_RENDER_FLOAT32_ENABLED")){const e=De().getBool("DEBUG");De().set("DEBUG",!1);const r=this.abs(Rt(1e-8)).dataSync()[0];if(De().set("DEBUG",e),r>0)return 32}return 16})),this.floatPrecisionValue}epsilon(){return 32===this.floatPrecision()?1e-7:1e-4}uploadToGPU(e){const r=this.texData.get(e),{shape:s,dtype:i,values:o,texture:a,usage:u,isPacked:c}=r;if(null!=a)return;const p=null!=this.activeTimers;let m;p&&(m=ri());let y=r.texShape;if(null==y&&(y=function gxe(n,t=!1){let e=De().getNumber("WEBGL_MAX_TEXTURE_SIZE"),r=De().getNumber("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE");r===1/0&&De().getBool("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE")&&(r=e/2),t&&(e*=2,r*=2,1===(n=n.map((a,u)=>u>=n.length-2?G1(n[u]):n[u])).length&&(n=[2,n[0]])),2!==n.length&&(n=Xl(n).newShape);let s=Fe(n),i=null;n.length<=1&&s<=e?i=[1,s]:2===n.length&&n[0]<=e&&n[1]<=e?i=n:3===n.length&&n[0]*n[1]<=e&&n[2]<=e?i=[n[0]*n[1],n[2]]:3===n.length&&n[0]<=e&&n[1]*n[2]<=e?i=[n[0],n[1]*n[2]]:4===n.length&&n[0]*n[1]*n[2]<=e&&n[3]<=e?i=[n[0]*n[1]*n[2],n[3]]:4===n.length&&n[0]<=e&&n[1]*n[2]*n[3]<=e&&(i=[n[0],n[1]*n[2]*n[3]]);const o=null!=i&&Math.max(...i)>r&&Math.min(...i)<=(t?2:1)&&Math.min(...i)>0;if(null==i||o)if(t){const a=jh(n);let u=2,c=2;n.length&&([u,c]=Gh(n)),s=a*(u/2)*(c/2),i=W1(s).map(p=>2*p)}else i=W1(s);return i}(s,c),r.texShape=y),null!=o){const _=V0(s);let w,T=y[1],I=y[0];const O=o instanceof Uint8Array||o instanceof Uint8ClampedArray;(c||!O)&&([T,I]=Uh(y[0],y[1])),w=c?new gTe(_,O):new YU(_,O);const M=O?[I,T]:y,V=this.makeTensorInfo(M,i),z=this.texData.get(V.dataId);z.usage=O?Mr.PIXELS:Mr.UPLOAD,z.texShape=M,this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(V.dataId),T,I,o);const ne=this.runWebGLProgram(w,[V],i,[[I,T]],!0),oe=this.texData.get(ne.dataId);r.texShape=oe.texShape,r.isPacked=oe.isPacked,r.usage=oe.usage,De().get("ENGINE_COMPILE_ONLY")?this.disposeData(ne.dataId):(r.texture=oe.texture,r.values=null,this.texData.delete(ne.dataId)),this.disposeIntermediateTensorInfo(V),p&&(this.uploadWaitMs+=ri()-m)}else{const _=this.acquireTexture(y,u,i,c);r.texture=_}}convertAndCacheOnCPU(e,r){const s=this.texData.get(e),{dtype:i}=s;return null!=r&&(s.values=function YSe(n,t){if("float32"===t||"complex64"===t)return n;if("int32"===t||"bool"===t){const e="int32"===t?new Int32Array(n.length):new Uint8Array(n.length);for(let r=0;r<e.length;++r)e[r]=Math.round(n[r]);return e}throw new Error(`Unknown dtype ${t}`)}(r,i)),s.values}acquireTexture(e,r,s,i){if(this.numBytesInGPU+=this.computeBytes(e,s),!this.warnedAboutMemory&&this.numBytesInGPU>1024*this.numMBBeforeWarning*1024){const o=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=!0,console.warn(`High memory usage in GPU: ${o} MB, most likely due to a memory leak`)}return this.textureManager.acquireTexture(e,r,i)}computeBytes(e,r){return e[0]*e[1]*a_(r)}checkCompileCompletion(){for(const[,e]of Object.entries(this.binaryCache))this.checkCompletion_(e)}checkCompileCompletionAsync(){var e=this;return Ve(function*(){const r=[];if(e.gpgpu.parallelCompilationExtension){for(const[,s]of Object.entries(e.binaryCache))r.push(e.checkCompletionAsync_(s));return Promise.all(r)}for(const[,s]of Object.entries(e.binaryCache)){const i=new Promise(o=>{try{e.checkCompletion_(s),o(!0)}catch(a){throw a}});r.push(i)}return Promise.all(r)})()}checkCompletionAsync_(e){var r=this;return Ve(function*(){return r.gpgpu.gl.getProgramParameter(e.webGLProgram,r.gpgpu.parallelCompilationExtension.COMPLETION_STATUS_KHR)?r.checkCompletion_(e):(yield YV(),r.checkCompletionAsync_(e))})()}checkCompletion_(e){if(!1===this.gpgpu.gl.getProgramParameter(e.webGLProgram,this.gpgpu.gl.LINK_STATUS))throw console.log(this.gpgpu.gl.getProgramInfoLog(e.webGLProgram)),!1===this.gpgpu.gl.getShaderParameter(e.fragmentShader,this.gpgpu.gl.COMPILE_STATUS)?(VU(e.source,this.gpgpu.gl.getShaderInfoLog(e.fragmentShader)),new Error("Failed to compile fragment shader.")):new Error("Failed to link vertex and fragment shaders.");return!0}getUniformLocations(){for(const e of Object.values(this.binaryCache)){this.gpgpu.buildVao(e.webGLProgram);const{variablesLocations:r,customUniformLocations:s,infLoc:i,nanLoc:o,outShapeLocation:a,outShapeStridesLocation:u,outTexShapeLocation:c}=KU(this.gpgpu,e.program,e.webGLProgram);e.variablesLocations=r,e.customUniformLocations=s,e.infLoc=i,e.nanLoc=o,e.outShapeLocation=a,e.outShapeStridesLocation=u,e.outTexShapeLocation=c}}createTensorFromGPUData(e,r,s){e.channels=e.channels||"RGBA";const{texture:i,height:o,width:a,channels:u}=e,c=Da().backend;if(!c.gpgpu.gl.isTexture(i))throw new Error("The texture is invalid. Also, please make sure the texture and the TFJS WebGL backend are using the same canvas. If you want to use your own custom canvas, you have to create and use the custom TFJS WebGL backend created from the canvas through 'new tf.MathBackendWebGL(customCanvas)'.");const p=c.writeTexture(i,r,s,o,a,u);return Da().makeTensorFromDataId(p,r,s,c)}}return n.nextDataId=0,n})();QL()&&b3("webgl",()=>new XSe,2);const MA="\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n";class Xh{constructor(t,e,r){this.variableNames=["A","B"],this.outputShape=Ht(e,r),this.enableShapeUniforms=Rs(this.outputShape.length),this.userCode=`\n      float binaryOperation(float a, float b) {\n        ${t}\n      }\n\n      void main() {\n        float a = getAAtOutCoords();\n        float b = getBAtOutCoords();\n        setOutput(binaryOperation(a, b));\n      }\n    `}}const zc="\n  result.r = isNaN.r ? NAN : result.r;\n  result.g = isNaN.g ? NAN : result.g;\n  result.b = isNaN.b ? NAN : result.b;\n  result.a = isNaN.a ? NAN : result.a;\n";class Eg{constructor(t,e,r,s=!1){this.variableNames=["A","B"],this.supportsBroadcasting=!0,this.packedInputs=!0,this.packedOutput=!0,this.outputShape=Ht(e,r);const i=this.outputShape.length;this.enableShapeUniforms=Rs(i);let o="";if(s)if(0===i||1===Fe(this.outputShape))o="\n          result.y = 0.;\n          result.z = 0.;\n          result.w = 0.;\n        ";else if(o=`\n          ${Vn(i)} coords = getOutputCoords();\n        `,1===i)o+=this.enableShapeUniforms?"\n            result.y = (coords + 1) >= outShape ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          ":`\n            result.y = (coords + 1) >= ${this.outputShape[0]} ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          `;else{const u=Ws("coords",i);o+=this.enableShapeUniforms?`\n            bool nextRowOutOfBounds =\n              (${u[i-2]} + 1) >= outShape[${i} - 2];\n            bool nextColOutOfBounds =\n              (${u[i-1]} + 1) >= outShape[${i} - 1];\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          `:`\n            bool nextRowOutOfBounds =\n              (${u[i-2]} + 1) >= ${this.outputShape[i-2]};\n            bool nextColOutOfBounds =\n              (${u[i-1]} + 1) >= ${this.outputShape[i-1]};\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          `}this.userCode=`\n      vec4 binaryOperation(vec4 a, vec4 b) {\n        ${t}\n      }\n\n      void main() {\n        vec4 a = getAAtOutCoords();\n        vec4 b = getBAtOutCoords();\n\n        vec4 result = binaryOperation(a, b);\n        ${o}\n\n        setOutput(result);\n      }\n    `}}function Ai(n){const{inputs:t,backend:e}=n,{x:r}=t;return e.incRef(r.dataId),{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}const JSe={kernelName:um,backendName:"webgl",kernelFunc:Ai};function Au(n){const{inputs:t,backend:e}=n,{real:r,imag:s}=t,i=e.makeTensorInfo(r.shape,"complex64"),o=e.texData.get(i.dataId),a=Ai({inputs:{x:r},backend:e}),u=Ai({inputs:{x:s},backend:e});return o.complexTensorInfos={real:a,imag:u},i}const e1e={kernelName:iC,backendName:"webgl",kernelFunc:Au},dj="return (a < 0.) ? b * a : a;",hj="\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n",n1e={kernelName:A_,backendName:"webgl",kernelFunc:function t1e(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{alpha:i}=r,o=e.makeTensorInfo([],"float32",Zl(i,"float32")),a=De().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Eg(hj,s.shape,o.shape):new Xh(dj,s.shape,o.shape),u=e.runWebGLProgram(a,[s,o],"float32");return e.disposeIntermediateTensorInfo(o),u}},pj="return (a < 0.) ? b * a : a;",fj="\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n",s1e={kernelName:K_,backendName:"webgl",kernelFunc:function r1e(n){const{inputs:t,backend:e}=n,{x:r,alpha:s}=t,i=De().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Eg(fj,r.shape,s.shape):new Xh(pj,r.shape,s.shape);return e.runWebGLProgram(i,[r,s],"float32")}},Yh="if (isnan(x)) return x;";function bn({opSnippet:n,packedOpSnippet:t,cpuKernelImpl:e,dtype:r}){return({inputs:s,backend:i})=>{const{x:o}=s,a=i,u=r||o.dtype;if(a.shouldExecuteOnCPU([o])&&null!=e){const m=a.texData.get(o.dataId),y=e(m.values,u);return a.makeTensorInfo(o.shape,u,y)}let p;return p=De().getBool("WEBGL_PACK_UNARY_OPERATIONS")&&null!=t?new Du(o.shape,t):new ja(o.shape,n),a.runWebGLProgram(p,[o],u)}}function Ts({opSnippet:n,packedOpSnippet:t,checkOutOfBounds:e=!1,supportsComplex:r=!1,cpuKernelImpl:s,dtype:i}){return({inputs:o,backend:a})=>{const{a:u,b:c}=o,p=a;if(r&&"complex64"===u.dtype){const w=p.texData.get(u.dataId),T=p.texData.get(c.dataId),[I,O]=[[w.complexTensorInfos.real,T.complexTensorInfos.real],[w.complexTensorInfos.imag,T.complexTensorInfos.imag]].map(V=>{const[z,G]=V,Q={dataId:z.dataId,dtype:z.dtype,shape:u.shape},ne={dataId:G.dataId,dtype:G.dtype,shape:c.shape},oe=new Xh(n,u.shape,c.shape);return p.runWebGLProgram(oe,[Q,ne],Ti(z.dtype,G.dtype))}),M=Au({inputs:{real:I,imag:O},backend:p});return p.disposeIntermediateTensorInfo(I),p.disposeIntermediateTensorInfo(O),M}const m=i||Ti(u.dtype,c.dtype);if(("string"===u.dtype||"string"===c.dtype||p.shouldExecuteOnCPU([u,c]))&&null!=s){const w=p.texData.get(u.dataId).values,T=p.texData.get(c.dataId).values,I="string"===u.dtype?yl(w):w,O="string"===u.dtype?yl(T):T,[M,V]=s(u.shape,c.shape,I,O,m),z=p.makeTensorInfo(V,m);return p.texData.get(z.dataId).values=M,z}let _;return _=De().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&null!=t?new Eg(t,u.shape,c.shape,e):new Xh(n,u.shape,c.shape),p.runWebGLProgram(_,[u,c],m)}}function Dg(n,t=!1){if("linear"===n)return t?FSe:NSe;if("relu"===n)return t?LSe:RSe;if("elu"===n)return t?$Se:OSe;if("relu6"===n)return t?VSe:MSe;if("prelu"===n)return t?fj:pj;if("leakyrelu"===n)return t?hj:dj;if("sigmoid"===n)return t?BSe:PSe;throw new Error(`Activation ${n} has not been implemented for the WebGL backend.`)}class mj{constructor(t,e,r,s=!1,i=!1,o=!1,a=null,u=!1,c=!1){this.variableNames=["matrixA","matrixB"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=r,this.enableShapeUniforms=Rs(this.outputShape.length);const m=Math.ceil((s?t[1]:t[2])/2),y=s?"i * 2, rc.y":"rc.y, i * 2",_=i?"rc.z, i * 2":"i * 2, rc.z",w=s?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"],T=i?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"];let I="",O="";a&&(I=u?`vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ${a}\n        }`:c?`vec4 activation(vec4 a) {\n          vec4 b = getLeakyreluAlphaAtOutCoords();\n          ${a}\n        }`:`vec4 activation(vec4 x) {\n          ${a}\n        }`,O="result = activation(result);");const M=o?"result += getBiasAtOutCoords();":"";o&&this.variableNames.push("bias"),u&&this.variableNames.push("preluActivationWeights"),c&&this.variableNames.push("leakyreluAlpha");let V="rc.x",z="rc.x";t[0]<e[0]?V=`imod(rc.x, ${t[0]})`:e[0]<t[0]&&(z=`imod(rc.x, ${e[0]})`),this.userCode=`\n      ${I}\n      // Don't use uniform for sharedDimensionPacked for performance.\n      const float sharedDimension = ${m}.0;\n\n      vec4 dot2x2ARowBCol(ivec3 rc) {\n        vec4 result = vec4(0);\n        int batchA = ${V};\n        int batchB = ${z};\n        for (int i = 0; i < ${m}; i++) {\n          vec4 a = getMatrixA(batchA, ${y});\n          vec4 b = getMatrixB(batchB, ${_});\n\n          // These swizzled products need to be separately added.\n          // See: https://github.com/tensorflow/tfjs/issues/1735\n          result += (${w[0]} * ${T[0]});\n          result += (${w[1]} * ${T[1]});\n        }\n        return result;\n      }\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n        vec4 result = dot2x2ARowBCol(rc);\n\n        ${M}\n\n        ${O}\n\n        setOutput(result);\n      }\n    `}}const gj={REAL:"return areal * breal - aimag * bimag;",IMAG:"return areal * bimag + aimag * breal;"};class yj{constructor(t,e,r){this.variableNames=["AReal","AImag","BReal","BImag"],this.outputShape=Ht(e,r),this.userCode=`\n      float binaryOpComplex(\n          float areal, float aimag, float breal, float bimag) {\n        ${t}\n      }\n\n      void main() {\n        float areal = getARealAtOutCoords();\n        float aimag = getAImagAtOutCoords();\n        float breal = getBRealAtOutCoords();\n        float bimag = getBImagAtOutCoords();\n        setOutput(binaryOpComplex(areal, aimag, breal, bimag));\n      }\n    `}}const bj="return a * b;";function PA(n){const{inputs:t,backend:e}=n,{a:r,b:s}=t,i=Ti(r.dtype,s.dtype);if("complex64"===r.dtype){const a=e.texData.get(r.dataId),u=e.texData.get(s.dataId),c=new yj(gj.REAL,r.shape,s.shape),p=new yj(gj.IMAG,r.shape,s.shape),m=[{dataId:a.complexTensorInfos.real.dataId,dtype:a.complexTensorInfos.real.dtype,shape:r.shape},{dataId:a.complexTensorInfos.imag.dataId,dtype:a.complexTensorInfos.imag.dtype,shape:r.shape},{dataId:u.complexTensorInfos.real.dataId,dtype:u.complexTensorInfos.real.dtype,shape:s.shape},{dataId:u.complexTensorInfos.imag.dataId,dtype:u.complexTensorInfos.imag.dtype,shape:s.shape}],y=e.runWebGLProgram(c,m,"float32"),_=e.runWebGLProgram(p,m,"float32"),w=Au({inputs:{real:y,imag:_},backend:e});return e.disposeIntermediateTensorInfo(y),e.disposeIntermediateTensorInfo(_),w}if(e.shouldExecuteOnCPU([r,s])){const a=e.texData.get(r.dataId),u=e.texData.get(s.dataId),[c,p]=eSe(r.shape,s.shape,a.values,u.values,i),m=e.makeTensorInfo(p,i);return e.texData.get(m.dataId).values=c,m}let o;return o=De().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Eg(bj,r.shape,s.shape):new Xh(bj,r.shape,s.shape),e.runWebGLProgram(o,[r,s],i)}const i1e={kernelName:bm,backendName:"webgl",kernelFunc:PA};function ut(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{shape:i}=r,o=e,a=Fe(s.shape),u=DL(i,a),c=Fe(u);J(a===c,()=>`The new shape (${u}) has ${c} elements and the old shape (${s.shape}) has ${a} elements. The new shape and old shape must have the same number of elements.`);const p=o.texData.get(s.dataId);return!p.isPacked||z0(s.shape,u)||null!==p.texture&&z0(p.shape,u)?(o.incRef(s.dataId),{dataId:s.dataId,shape:u,dtype:s.dtype}):function o1e(n,t,e){const r=[jh(n.shape),...Gh(n.shape)],s={dtype:n.dtype,shape:r,dataId:n.dataId},i=[jh(t),...Gh(t)],o=new oj(i,r),c=e.runWebGLProgram(o,[s],n.dtype,[r],!0);return{dataId:c.dataId,shape:t,dtype:c.dtype}}(s,u,o)}const a1e={kernelName:Y_,backendName:"webgl",kernelFunc:ut};class _j{constructor(t,e){this.variableNames=["x"];const{windowSize:r,batchSize:s,inSize:i,outSize:o}=t;this.outputShape=[s,o];const a=4*Math.floor(r/4),u=r%4;let c="sumValue += dot(values, ones);";if(null!=e){const m=1/e;c=`sumValue += dot(values * ${ah(m)?m.toPrecision(2):m}, ones);`}let p="";i%r>0&&(p=`\n        if (inIdx < 0 || inIdx >= ${i}) {\n          return 0.0;\n        }\n      `),this.userCode=`\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ${p}\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${r};\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ${a}; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ${c}\n        }\n\n        int inIdx = inOffset + ${a};\n        if (${1===u}) {\n          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);\n\n          ${c}\n        } else if (${2===u}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1), 0.0, 0.0);\n\n          ${c}\n        } else if (${3===u}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2), 0.0);\n\n          ${c}\n        }\n        setOutput(sumValue);\n      }\n    `}}class l1e{constructor(t,e){this.variableNames=["x"];const{windowSize:r,batchSize:s,inSize:i,outSize:o}=t;this.outputShape=[s,o];let a="0.0",u="";"prod"===e?a="1.0":"min"===e?(a="1.0 / 1e-20",u="min"):"max"===e&&(a="-1.0 / 1e-20",u="max");let c=`${e}(${e}(${e}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"sum"===e?c="sumValue":"prod"===e?c="prodValue":"all"===e?c="allValue":"any"===e&&(c="anyValue");const p=4*Math.floor(r/4),m=r%4;let y=`\n      if (${"sum"===e}) {\n        sumValue += dot(values, ones);\n      } else if (${"prod"===e}) {\n        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);\n        prodValue *= tmp[0] * tmp[1];\n      } else {\n        minMaxValue = ${u}(values, minMaxValue);\n        if (${"min"===e} || ${"max"===e}) {\n          minMaxValue = ${u}(values, minMaxValue);\n          bvec4 isNaN = isnan(values);\n          if (isNaN.r || isNaN.g || isNaN.b || isNaN.a) {\n            minMaxValue = vec4(NAN);\n          }\n        }\n      }\n    `,_="vec4";"all"===e?(a="1.0",y="\n        bool reducedAllValue = all(values);\n        float floatedReducedAllValue = float(reducedAllValue);\n        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);\n      ",_="bvec4"):"any"===e&&(a="0.0",y="\n        bool reducedAnyValue = any(values);\n        float floatedReducedAnyValue = float(reducedAnyValue);\n        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);\n      ",_="bvec4");let w="";i%r>0&&(w=`\n        if (inIdx < 0 || inIdx >= ${i}) {\n          return initializationValue;\n        }\n      `),this.userCode=`\n      const float initializationValue = ${a};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ${w}\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${r};\n\n        vec4 minMaxValue = vec4(${a});\n        float prodValue = 1.0;\n        float sumValue = 0.0;\n        float allValue = 1.0;\n        float anyValue = 0.0;\n\n        for (int i = 0; i < ${p}; i += 4) {\n          int inIdx = inOffset + i;\n          ${_} values = ${_}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ${y}\n        }\n\n        int inIdx = inOffset + ${p};\n        if (${1===m}) {\n          ${_} values = ${_}(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          ${y}\n        } else if (${2===m}) {\n          ${_} values = ${_}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          ${y}\n        } else if (${3===m}) {\n          ${_} values = ${_}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          ${y}\n        }\n        setOutput(${c});\n      }\n    `}}function Uc(n,t,e,r){const s=function u1e(n){const t=[];for(;0===t.length||1!==t[t.length-1].outSize;){const e=t.length?t[t.length-1].outSize:n[1],r=Kv(e);t.push({inSize:e,windowSize:r,outSize:Math.ceil(e/r)})}return t}(n.shape);let i=n;for(let o=0;o<s.length;o++){const{inSize:a,windowSize:u,outSize:c}=s[o];let p,m;p="mean"===e?0===o?new _j({windowSize:u,inSize:a,batchSize:n.shape[0],outSize:c},a):new _j({windowSize:u,inSize:a,batchSize:n.shape[0],outSize:c}):new l1e({windowSize:u,inSize:a,batchSize:n.shape[0],outSize:c},e),m=i,i=r.runWebGLProgram(p,[i],t),m.dataId!==n.dataId&&r.disposeIntermediateTensorInfo(m)}return i}class c1e{constructor(t,e){this.variableNames=["A"];const r=new Array(t.length);for(let o=0;o<r.length;o++)r[o]=t[e[o]];this.outputShape=r,this.rank=r.length;const s=Vn(this.rank),i=function d1e(n){const t=n.length;if(t>6)throw Error(`Transpose for rank ${t} is not yet supported`);const e=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"],r=new Array(t);for(let s=0;s<n.length;s++)r[n[s]]=e[s];return r.join()}(e);this.userCode=`\n    void main() {\n      ${s} resRC = getOutputCoords();\n      setOutput(getA(${i}));\n    }\n    `}}class h1e{constructor(t,e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0;const r=new Array(t.length);for(let p=0;p<r.length;p++)r[p]=t[e[p]];if(this.outputShape=r,this.rank=r.length,this.rank>6)throw Error(`Packed transpose for rank ${this.rank} is not yet supported.`);const s=Vn(this.rank),i=ij("rc",this.rank),o=new Array(this.rank);for(let p=0;p<e.length;p++)o[e[p]]=i[p];const a=`vec2(${o.slice(-2).join()})`,u=`++${i[this.rank-1]} < ${r[this.rank-1]}`,c=`getChannel(getA(${o.join()}), ${a})`;this.userCode=`\n    void main() {\n      ${s} rc = getOutputCoords();\n      vec4 result = vec4(0.);\n      result[0] = ${c};\n      if(${u}) {\n        result[1] = ${c};\n      }\n      --${i[this.rank-1]};\n      if(++${i[this.rank-2]} < ${r[this.rank-2]}) {\n        result[2] = ${c};\n        if(${u}) {\n          result[3] = ${c};\n        }\n      }\n      setOutput(result);\n    }\n    `}}function q0(n,t,e){const r=De().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new h1e(n.shape,t):new c1e(n.shape,t);return e.runWebGLProgram(r,[n],n.dtype)}function K0(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{axis:i,keepDims:o}=r;return function p1e(n,t,e,r){const i=n.shape.length,o=sn(t,n.shape);let a=o;const u=ur(a,i),c=null!=u;let p=n;c&&(p=q0(n,u,r),a=Nr(a.length,i)),ws("sum",a,i);const[m,y]=us(p.shape,a);let _=m;e&&(_=kr(m,o));const w=Fe(y),O=ut({inputs:{x:p},attrs:{shape:[Fe(n.shape)/w,w]},backend:r}),V=Uc(O,cI(n.dtype),"sum",r),z=ut({inputs:{x:V},attrs:{shape:_},backend:r});return r.disposeIntermediateTensorInfo(O),r.disposeIntermediateTensorInfo(V),c&&r.disposeIntermediateTensorInfo(p),z}(s,i,o,e)}const f1e={kernelName:nv,backendName:"webgl",kernelFunc:K0};function Hs(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{perm:i}=r,o=e,u=new Array(s.shape.length);for(let p=0;p<u.length;p++)u[p]=s.shape[i[p]];let c;if(o.shouldExecuteOnCPU([s])){const m=o.texData.get(s.dataId).values,y=RA(m,s.shape,s.dtype,i,u);c=o.makeTensorInfo(u,s.dtype),o.texData.get(c.dataId).values=y}else c=q0(s,i,o);return c}const m1e={kernelName:hh,backendName:"webgl",kernelFunc:Hs},vj=1e3;function X0({a:n,b:t,transposeA:e,transposeB:r,backend:s,bias:i=null,preluActivationWeights:o=null,leakyreluAlpha:a=0,activation:u=null}){const c=n.shape.length,p=t.shape.length,m=e?n.shape[c-2]:n.shape[c-1],y=r?t.shape[p-1]:t.shape[p-2],_=e?n.shape[c-1]:n.shape[c-2],w=r?t.shape[p-2]:t.shape[p-1],T=n.shape.slice(0,-2),I=t.shape.slice(0,-2),O=Fe(T),M=Fe(I),z=Ht(n.shape.slice(0,-2),t.shape.slice(0,-2)).concat([_,w]);J(m===y,()=>`Error in matMul: inner shapes (${m}) and (${y}) of Tensors with shapes ${n.shape} and ${t.shape} and transposeA=${e} and transposeB=${r} must match.`);const G=e?[O,m,_]:[O,_,m],Q=r?[M,w,y]:[M,y,w],ne=ut({inputs:{x:n},backend:s,attrs:{shape:G}}),oe=ut({inputs:{x:t},backend:s,attrs:{shape:Q}}),de=[ne,oe],pe=Math.max(O,M),Te=e?ne.shape[1]:ne.shape[2],Ae=null!=i,Oe=null!=o,Me="leakyrelu"===u,Pe=null!=u?Dg(u,!0):null;let Se;if((1===_||1===w)&&Te>vj&&!1===(Ae||Oe||Me||null!=Pe)){let ke=ne,We=oe;e&&(ke=Hs({inputs:{x:ne},backend:s,attrs:{perm:[0,2,1]}}),de.push(ke)),r&&(We=Hs({inputs:{x:oe},backend:s,attrs:{perm:[0,2,1]}}),de.push(We));const et=1===w;let Je=ke;1!==w&&(Je=ut({inputs:{x:ke},backend:s,attrs:{shape:[pe,Te,1]}}),de.push(Je));const tt=1===w?2:1;let it=We;et&&(it=ut({inputs:{x:We},backend:s,attrs:{shape:[pe,1,Te]}}),de.push(it));const yt=PA({inputs:{a:Je,b:it},backend:s});Se=K0({inputs:{x:yt},backend:s,attrs:{axis:tt,keepDims:!0}}),de.push(yt)}else{const ke=Ti(n.dtype,t.dtype),We=new mj(G,Q,[pe,_,w],e,r,Ae,Pe,Oe,Me),Ke=[ne,oe];if(null!=i&&Ke.push(i),Oe&&Ke.push(o),Me){const et=s.makeTensorInfo([],"float32",Zl(a,"float32"));Ke.push(et),de.push(et)}Se=s.runWebGLProgram(We,Ke,ke)}const xe=ut({inputs:{x:Se},backend:s,attrs:{shape:z}});de.push(Se);for(const ke of de)s.disposeIntermediateTensorInfo(ke);return xe}const y1e={kernelName:cv,backendName:"webgl",kernelFunc:function g1e(n){const{inputs:t,backend:e,attrs:r}=n,{a:s,b:i,bias:o,preluActivationWeights:a}=t,{transposeA:u,transposeB:c,activation:p,leakyreluAlpha:m}=r;return X0({a:s,b:i,transposeA:u,transposeB:c,backend:e,bias:o,preluActivationWeights:a,leakyreluAlpha:m,activation:p})}},wj="return abs(x);",_1e={kernelName:l_,backendName:"webgl",kernelFunc:function b1e(n){const{inputs:t,backend:e}=n,{x:r}=t;if(e.shouldExecuteOnCPU([r])&&"complex64"!==r.dtype){const i=e.texData.get(r.dataId),o=rj(i.values);return e.makeTensorInfo(r.shape,r.dtype,o)}let s;return s=De().getBool("WEBGL_PACK_UNARY_OPERATIONS")?new Du(r.shape,wj):new ja(r.shape,wj),e.runWebGLProgram(s,[r],r.dtype)}},w1e=bn({opSnippet:Zi+"\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return acos(x);\n"}),x1e={kernelName:jf,backendName:"webgl",kernelFunc:w1e},S1e=bn({opSnippet:Zi+"\n  if (x < 1.0) return NAN;\nreturn log(x + sqrt(x * x - 1.0));"}),C1e={kernelName:Gf,backendName:"webgl",kernelFunc:S1e},xj="return a + b;",I1e=Ts({opSnippet:xj,packedOpSnippet:xj,supportsComplex:!0,cpuKernelImpl:MTe}),E1e={kernelName:dh,backendName:"webgl",kernelFunc:I1e};class D1e{constructor(t,e){this.outputShape=[],this.outputShape=t,this.variableNames=e.map((i,o)=>`T${o}`);const r=[];this.variableNames.forEach(i=>{r.push(`float v${i} = get${i}AtOutCoords();`)});const s=this.variableNames.map(i=>`v${i}`).join(" + ");this.userCode=`\n      void main() {\n        ${r.join("\n        ")}\n\n        float result = ${s};\n        setOutput(result);\n      }\n    `}}class A1e{constructor(t,e){this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t,this.variableNames=e.map((i,o)=>`T${o}`);const r=[];this.variableNames.forEach(i=>{r.push(`vec4 v${i} = get${i}AtOutCoords();`)});const s=this.variableNames.map(i=>`v${i}`).join(" + ");this.userCode=`\n      void main() {\n        ${r.join("\n        ")}\n\n        vec4 result = ${s};\n        setOutput(result);\n      }\n    `}}const k1e={kernelName:u_,backendName:"webgl",kernelFunc:function Y0(n){const{inputs:t,backend:e}=n,r=t;if(1===r.length)return Ai({inputs:{x:r[0]},backend:e});if(r.length>De().get("WEBGL_MAX_TEXTURES_IN_SHADER")){const u=Math.floor(r.length/2),c=Y0({inputs:r.slice(0,u),backend:e}),p=Y0({inputs:r.slice(u),backend:e});return Y0({inputs:[c,p],backend:e})}const s=r.map(u=>u.dtype).reduce((u,c)=>Ti(u,c)),i=r.map(u=>u.shape),a=De().getBool("WEBGL_PACK")?new A1e(r[0].shape,i):new D1e(r[0].shape,i);return e.runWebGLProgram(a,r,s)}},O1e={kernelName:"All",backendName:"webgl",kernelFunc:function N1e(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{axis:i,keepDims:o}=r,a=s.shape.length,u=sn(i,s.shape);let c=u;const p=ur(c,a);let m=s;null!=p&&(m=Hs({inputs:{x:s},backend:e,attrs:{perm:p}}),c=Nr(c.length,a)),ws("all",c,a);const[y,_]=us(m.shape,c),T=ut({inputs:{x:m},backend:e,attrs:{shape:[-1,Fe(_)]}}),I=Uc(T,T.dtype,"all",e);let O;return O=ut(o?{inputs:{x:I},backend:e,attrs:{shape:kr(y,u)}}:{inputs:{x:I},backend:e,attrs:{shape:y}}),e.disposeIntermediateTensorInfo(T),e.disposeIntermediateTensorInfo(I),null!=p&&e.disposeIntermediateTensorInfo(m),O}},M1e={kernelName:"Any",backendName:"webgl",kernelFunc:function R1e(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{axis:i,keepDims:o}=r,a=s.shape.length,u=sn(i,s.shape);let c=u;const p=ur(c,a);let m=s;null!=p&&(m=Hs({inputs:{x:s},backend:e,attrs:{perm:p}}),c=Nr(c.length,a)),ws("any",c,a);const[y,_]=us(m.shape,c),T=ut({inputs:{x:m},backend:e,attrs:{shape:[-1,Fe(_)]}}),I=Uc(T,T.dtype,"any",e);let O;return O=ut(o?{inputs:{x:I},backend:e,attrs:{shape:kr(y,u)}}:{inputs:{x:I},backend:e,attrs:{shape:y}}),e.disposeIntermediateTensorInfo(T),e.disposeIntermediateTensorInfo(I),null!=p&&e.disposeIntermediateTensorInfo(m),O}};class P1e{constructor(t,e,r){this.variableNames=["A"];const{windowSize:s,batchSize:i,outSize:o}=t;r||this.variableNames.push("bestIndicesA"),this.outputShape=[i,o],this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${s};\n\n        int bestIndex = inOffset;\n        float bestValue = getA(batch, bestIndex);\n\n        for (int i = 0; i < ${s}; i++) {\n          int inIdx = ${r?"inOffset + i;":"round(getBestIndicesA(batch, inOffset + i));"};\n          float candidate = getA(batch, inIdx);\n          if (candidate ${"max"===e?">":"<"} bestValue) {\n            bestValue = candidate;\n            bestIndex = inIdx;\n          }\n        }\n        setOutput(float(bestIndex));\n      }\n    `}}class F1e{constructor(t,e,r,s){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,J(t.length>2,()=>`Packed arg${r.charAt(0).toUpperCase()+r.slice(1)} supports only inputs with rank above 2.`);const o=Math.ceil(t[t.length-1]/e);this.outputShape=t.slice(0,-1),o>1&&this.outputShape.push(o),s||this.variableNames.push("bestIndicesA");const a=this.outputShape,u=a.length,c=Vn(u),p=Ws("coords",u);let m,y;if(1===o){y=u+1;const oe=Vn(y);m=`\n        ${oe} sourceLocR = ${oe}(${p.join()}, 0);\n        ++${p[u-1]};\n        ${oe} sourceLocG = ${oe}(${p.join()}, 0);\n        ++${p[u-2]};\n        ${oe} sourceLocA = ${oe}(${p.join()}, 0);\n        --${p[u-1]};\n        ${oe} sourceLocB = ${oe}(${p.join()}, 0);\n        --${p[u-2]};`}else y=u,m=`\n        ${c} sourceLocR = coords;\n        ++${p[u-1]};\n        ${c} sourceLocG = coords;\n        ++${p[u-2]};\n        ${c} sourceLocA = coords;\n        --${p[u-1]};\n        ${c} sourceLocB = coords;\n        --${p[u-2]};`;const _=["x","y","z","w","u","v"].slice(0,y),w="."+_[y-1],T=_.map(oe=>"int "+oe),I=Ws("sourceLocR",y-1).concat("inIdx.r"),O=Ws("sourceLocG",y-1).concat("inIdx.g"),M=Ws("sourceLocB",y-1).concat("inIdx.b"),V=Ws("sourceLocA",y-1).concat("inIdx.a"),z="max"===r?"greaterThan":"lessThan",G=s?"":`\n          inIdx = round(vec4(getBestIndicesAChannel(${I.join()}),\n                             getBestIndicesAChannel(${O.join()}),\n                             getBestIndicesAChannel(${M.join()}),\n                             getBestIndicesAChannel(${V.join()})));`,Q=`vec4(\n            getAChannel(${I.join()}),\n            hasNextCol ? getAChannel(${O.join()}) : 0.,\n            hasNextRow ? getAChannel(${M.join()}) : 0.,\n            hasNextRow && hasNextCol ? getAChannel(${V.join()}) : 0.)`,ne=s?"":`\n      float getBestIndicesAChannel(${T.join()}) {\n        return getChannel(getBestIndicesA(${_.join()}),\n                                          vec2(${_.slice(-2).join()}));\n      }`;this.userCode=`\n      float getAChannel(${T.join()}) {\n        return getChannel(getA(${_.join()}),\n                               vec2(${_.slice(-2).join()}));\n      }\n      ${ne}\n      void main() {\n        ${c} coords = getOutputCoords();\n        bool hasNextCol = ${p[u-1]} < ${a[u-1]-1};\n        bool hasNextRow = ${p[u-2]} < ${a[u-2]-1};\n        ${m}\n        ivec4 srcIdx = ivec4(sourceLocR${w}, sourceLocG${w},\n          sourceLocB${w}, sourceLocA${w}) * ${e};\n        ivec4 inIdx = srcIdx;\n        vec4 bestIndex = vec4(inIdx);\n        vec4 bestValue = ${Q};\n\n        for (int i = 0; i < ${e}; i++) {\n          inIdx = srcIdx;\n          ${G}\n          vec4 candidate = ${Q};\n          bvec4 nan = isnan(candidate);\n          bvec4 replace = bvec4(\n            vec4(${z}(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));\n\n          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,\n                           replace.y  ? candidate.y : bestValue.y,\n                           replace.z  ? candidate.z : bestValue.z,\n                           replace.w  ? candidate.w : bestValue.w);\n          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));\n          srcIdx++;\n        }\n        setOutput(bestIndex);\n      }\n    `}}function Tj(n,t,e,r=null){let s=t.shape[0],i=t.shape[1];null!=r&&(s=r.shape[0],i=r.shape[1]);const o=Kv(i),a={windowSize:o,inSize:i,batchSize:s,outSize:Math.ceil(i/o)},u=new P1e(a,e,null==r),c=[t];null!=r&&c.push(r);const p=n.runWebGLProgram(u,c,"int32");if(1===p.shape[1])return p;const m=Tj(n,t,e,p);return n.disposeIntermediateTensorInfo(p),m}function Sj(n,t,e,r=null){const s=null!=r?r.shape:t.shape,o=Kv(s[s.length-1]),a=new F1e(s,o,e,null==r),c=n.runWebGLProgram(a,null==r?[t]:[t,r],"int32");if(c.shape.length===t.shape.length){const p=Sj(n,t,e,c);return n.disposeIntermediateTensorInfo(c),p}return c}function Cj(n,t,e,r){const s=[e];if(ws("arg"+r.charAt(0).toUpperCase()+r.slice(1),s,t.shape.length),!De().getBool("WEBGL_PACK_REDUCE")||t.shape.length<=2){const i=[],o=n.texData.get(t.dataId);let u=t;null!==o&&o.isPacked&&(u=n.unpackTensor(t),i.push(u));const[c,p]=us(u.shape,s),m=Fe(p),y=ut({inputs:{x:u},backend:n,attrs:{shape:[-1,m]}});i.push(y);const _=Tj(n,y,r);i.push(_);const w=ut({inputs:{x:_},backend:n,attrs:{shape:c}});return i.forEach(T=>n.disposeIntermediateTensorInfo(T)),w}return Sj(n,t,r)}const L1e={kernelName:c_,backendName:"webgl",kernelFunc:function $1e(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{axis:i}=r;let o=sn(i,s.shape);const a=ur(o,s.shape.length);let u=s;const c=[];null!=a&&(u=Hs({inputs:{x:s},backend:e,attrs:{perm:a}}),c.push(u),o=Nr(o.length,u.shape.length)),ws("argMax",[o[0]],u.shape.length);const p=Cj(e,u,o[0],"max");return c.forEach(m=>e.disposeIntermediateTensorInfo(m)),p}},B1e={kernelName:d_,backendName:"webgl",kernelFunc:function V1e(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{axis:i}=r;let o=sn(i,s.shape);const a=ur(o,s.shape.length);let u=s;const c=[];null!=a&&(u=Hs({inputs:{x:s},backend:e,attrs:{perm:a}}),c.push(u),o=Nr(o.length,u.shape.length)),ws("argMin",[o[0]],u.shape.length);const p=Cj(e,u,o[0],"min");return c.forEach(m=>e.disposeIntermediateTensorInfo(m)),p}},U1e=bn({opSnippet:Zi+"\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return asin(x);\n"}),j1e={kernelName:Wf,backendName:"webgl",kernelFunc:U1e},W1e=bn({opSnippet:Zi+"return log(x + sqrt(x * x + 1.0));"}),H1e={kernelName:Hf,backendName:"webgl",kernelFunc:W1e},K1e=bn({opSnippet:Zi+"\n  return atan(x);\n"}),X1e={kernelName:qf,backendName:"webgl",kernelFunc:K1e},Q1e=Ts({opSnippet:MA+"\n  return atan(a, b);\n",packedOpSnippet:"\n  vec4 result = atan(a, b);\n  bvec4 isNaNA = isnan(a);\n  bvec4 isNaNB = isnan(b);\n  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);\n  "+zc+"\n  return result;\n"}),J1e={kernelName:Xf,backendName:"webgl",kernelFunc:Q1e},tCe=bn({opSnippet:Zi+"\n  if ((x < -1.0) || (x > 1.0)) return NAN;\nreturn (log(1.0 + x) - log(1.0 - x)) / 2.0;"}),nCe={kernelName:Kf,backendName:"webgl",kernelFunc:tCe};class Ag{constructor(t,e,r,s=!1,i=!1){if(this.variableNames=["x"],"avg"===e&&r)throw new Error("Cannot compute positions for average pool.");const o=t.filterWidth,a=t.strideHeight,u=t.strideWidth,c=t.dilationHeight,p=t.dilationWidth,m=t.effectiveFilterHeight,y=t.effectiveFilterWidth,_=t.padInfo.top,w=t.padInfo.left;this.outputShape=t.outShape;const T="avg"===e;let M="0.0";if(T||(M="-1.0 / 1e-20"),r)return void(this.userCode=`\n        const ivec2 strides = ivec2(${a}, ${u});\n        const ivec2 pads = ivec2(${_}, ${w});\n\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int batch = coords[0];\n          int d = coords[3];\n\n          ivec2 xRCCorner = coords.yz * strides - pads;\n          int xRCorner = xRCCorner.x;\n          int xCCorner = xRCCorner.y;\n\n          // max/min x(?, ?, d) to get y(yR, yC, d).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n          float avgValue = 0.0;\n\n          for (int wR = 0; wR < ${m};\n              wR += ${c}) {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ${t.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${y};\n                wC += ${p}) {\n              int xC = xCCorner + wC;\n\n              if (xC < 0 || xC >= ${t.inWidth}) {\n                continue;\n              }\n\n              float value = getX(batch, xR, xC, d);\n\n              // If a min / max value has already been found, use it. If not,\n              // use the current value.\n              float currMinMaxValue = mix(\n                  value, minMaxValue, minMaxValueFound);\n              if (value >= currMinMaxValue) {\n                minMaxValue = value;\n                minMaxValueFound = 1.0;\n                minMaxPosition = ${s?i?`((batch  * ${t.inHeight} + xR) * ${t.inWidth} + xC) * ${t.inChannels} + d`:`(xR * ${t.inWidth} + xC) * ${t.inChannels} + d`:`wR * ${y} + wC`};\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      `);let z=`${e}(${e}(${e}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"avg"===e&&(z="avgValue / max(count, 1.0)");const G=4*Math.floor(o/4),Q=o%4,ne=`\n      if (${T}) {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = max(values, minMaxValue);\n      }\n    `;this.userCode=`\n      const ivec2 strides = ivec2(${a}, ${u});\n      const ivec2 pads = ivec2(${_}, ${w});\n      const float initializationValue = ${M};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xR, int xC, int d) {\n        if (xC < 0 || xC >= ${t.inWidth}) {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xR, xC, d);\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d = coords[3];\n\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // max/min x(?, ?, d) to get y(yR, yC, d).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(${M});\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wR = 0; wR < ${m};\n            wR += ${c}) {\n          int xR = xRCorner + wR;\n\n          if (xR < 0 || xR >= ${t.inHeight}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${G}; wC += 4) {\n            int xC = xCCorner + wC * ${p};\n\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${p}, d),\n              getValue(batch, xR, xC + 2 * ${p}, d),\n              getValue(batch, xR, xC + 3 * ${p}, d)\n            );\n\n            ${ne}\n          }\n\n          int xC = xCCorner + ${G};\n          if (${1===Q}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              initializationValue,\n              initializationValue,\n              initializationValue\n            );\n\n            ${ne}\n          } else if (${2===Q}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${p}, d),\n              initializationValue,\n              initializationValue\n            );\n\n            ${ne}\n          } else if (${3===Q}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${p}, d),\n              getValue(batch, xR, xC + 2 * ${p}, d),\n              initializationValue\n            );\n\n            ${ne}\n          }\n        }\n        setOutput(${z});\n      }\n    `}}class FA{constructor(t,e,r,s=!1,i=!1){if(this.variableNames=["x"],"avg"===e&&r)throw new Error("Cannot compute positions for average pool.");const o=t.filterWidth,a=t.strideDepth,u=t.strideHeight,c=t.strideWidth,p=t.dilationDepth,m=t.dilationHeight,y=t.dilationWidth,_=t.effectiveFilterDepth,w=t.effectiveFilterHeight,T=t.effectiveFilterWidth,I=t.padInfo.front,O=t.padInfo.top,M=t.padInfo.left;this.outputShape=t.outShape;const V="avg"===e;let z="0.0";if(V||(z="-1.0 / 1e-20"),r)return void(this.userCode=`\n        const ivec3 strides =\n            ivec3(${a}, ${u}, ${c});\n        const ivec3 pads = ivec3(${I}, ${O}, ${M});\n\n        void main() {\n          ivec5 coords = getOutputCoords();\n          int batch = coords.x;\n          int ch = coords.u;\n\n          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n          int xDCorner = xCorner.x;\n          int xRCorner = xCorner.y;\n          int xCCorner = xCorner.z;\n\n          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n\n          for (int wD = 0; wD < ${_};\n              wD += ${p}) {\n            int xD = xDCorner + wD;\n\n            if (xD < 0 || xD >= ${t.inDepth}) {\n              continue;\n            }\n\n            for (int wR = 0; wR < ${w};\n                wR += ${m}) {\n              int xR = xRCorner + wR;\n\n              if (xR < 0 || xR >= ${t.inHeight}) {\n                continue;\n              }\n\n              for (int wC = 0; wC < ${T};\n                  wC += ${y}) {\n                int xC = xCCorner + wC;\n\n                if (xC < 0 || xC >= ${t.inWidth}) {\n                  continue;\n                }\n\n                float value = getX(batch, xD, xR, xC, ch);\n\n                // If a min / max value has already been found, use it. If not,\n                // use the current value.\n                float currMinMaxValue = mix(\n                    value, minMaxValue, minMaxValueFound);\n                if (value >= currMinMaxValue) {\n                  minMaxValue = value;\n                  minMaxValueFound = 1.0;\n                  minMaxPosition = ${s?i?`(((batch * ${t.inDepth} + xD) * ${t.inHeight} + xR) * ${t.inWidth} + xC) * ${t.inChannels} + ch`:`((xD * ${t.inHeight} + xR) * ${t.inWidth} + xC) * ${t.inChannels} + ch`:`wD * ${w} * ${T} +\n                      wR * ${T} + wC`};\n                }\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      `);let Q=`${e}(${e}(${e}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"avg"===e&&(Q="avgValue / max(count, 1.0)");const ne=4*Math.floor(o/4),oe=o%4,de=`\n      if (${V}) {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = max(values, minMaxValue);\n      }\n    `;this.userCode=`\n      const ivec3 strides =\n        ivec3(${a}, ${u}, ${c});\n      const ivec3 pads = ivec3(${I}, ${O}, ${M});\n      const float initializationValue = ${z};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xD, int xR, int xC, int ch) {\n        if (xC < 0 || xC >= ${t.inWidth}) {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xD, xR, xC, ch);\n      }\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xDCorner = xCorner.x;\n        int xRCorner = xCorner.y;\n        int xCCorner = xCorner.z;\n\n        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(${z});\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wD = 0; wD < ${_};\n            wD += ${p}) {\n          int xD = xDCorner + wD;\n\n          if (xD < 0 || xD >= ${t.inDepth}) {\n            continue;\n          }\n\n          for (int wR = 0; wR < ${w};\n            wR += ${m}) {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ${t.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${ne}; wC += 4) {\n              int xC = xCCorner + wC * ${y};\n\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${y}, ch),\n                getValue(batch, xD, xR, xC + 2 * ${y}, ch),\n                getValue(batch, xD, xR, xC + 3 * ${y}, ch)\n              );\n\n              ${de}\n            }\n\n            int xC = xCCorner + ${ne};\n            if (${1===oe}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                initializationValue,\n                initializationValue,\n                initializationValue\n              );\n\n              ${de}\n            } else if (${2===oe}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${y}, ch),\n                initializationValue,\n                initializationValue\n              );\n\n              ${de}\n            } else if (${3===oe}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${y}, ch),\n                getValue(batch, xD, xR, xC + 2 * ${y}, ch),\n                initializationValue\n              );\n\n              ${de}\n            }\n          }\n        }\n        setOutput(${Q});\n      }\n    `}}const sCe={kernelName:h_,backendName:"webgl",kernelFunc:function rCe(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t;Cg(s,"avgPool");const{filterSize:i,strides:o,pad:a,dimRoundingMode:u}=r;J(vs(o,1),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${o} and dilations '1'`);const p=vo(s.shape,i,o,1,a,u);if(1===p.filterWidth&&1===p.filterHeight&&hn(p.inShape,p.outShape))return Ai({inputs:{x:s},backend:e});const m=new Ag(p,"avg",!1);return e.runWebGLProgram(m,[s],"float32")}},oCe={kernelName:p_,backendName:"webgl",kernelFunc:function iCe(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{filterSize:i,strides:o,pad:a,dimRoundingMode:u,dataFormat:c}=r,m=pl(s.shape,i,o,[1,1,1],a,u,c),y=new FA(m,"avg",!1);return e.runWebGLProgram(y,[s],"float32")}};class aCe{constructor(t){this.variableNames=["dy"],this.outputShape=t.inShape;const u=t.effectiveFilterHeight,c=t.effectiveFilterWidth;this.userCode=`\n      const ivec2 pads = ivec2(${u-1-t.padInfo.top}, ${c-1-t.padInfo.left});\n      const float avgMultiplier = float(${1/(t.filterHeight*t.filterWidth)});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${u};\n            wR += ${t.dilationHeight}) {\n          float dyR = float(dyRCorner + wR) / ${t.strideHeight}.0;\n\n          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ${c};\n            wC+= ${t.dilationWidth}) {\n            float dyC = float(dyCCorner + wC) / ${t.strideWidth}.0;\n\n            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n\n            dotProd += dyValue * avgMultiplier;\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class lCe{constructor(t){this.variableNames=["dy"],this.outputShape=t.inShape;const m=t.effectiveFilterDepth,y=t.effectiveFilterHeight,_=t.effectiveFilterWidth;this.userCode=`\n      const ivec3 pads = ivec3(${m-1-t.padInfo.front}, ${y-1-t.padInfo.top}, ${_-1-t.padInfo.left});\n      const float avgMultiplier = float(${1/(t.filterDepth*t.filterHeight*t.filterWidth)});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ${m};\n            wD += ${t.dilationDepth}) {\n          float dyD = float(dyDCorner + wD) / ${t.strideDepth}.0;\n\n          if (dyD < 0.0 || dyD >= ${t.outDepth}.0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ${y};\n              wR += ${t.dilationHeight}) {\n            float dyR = float(dyRCorner + wR) / ${t.strideHeight}.0;\n\n            if (dyR < 0.0 || dyR >= ${t.outHeight}.0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ${_};\n                wC += ${t.dilationWidth}) {\n              float dyC = float(dyCCorner + wC) / ${t.strideWidth}.0;\n\n              if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n\n              dotProd += dyValue * avgMultiplier;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const cCe={kernelName:tC,backendName:"webgl",kernelFunc:function uCe(n){const{inputs:t,backend:e,attrs:r}=n,{dy:s,input:i}=t,o=i,{filterSize:a,strides:u,pad:c,dimRoundingMode:p}=r,y=pl(o.shape,a,u,[1,1,1],c,p),_=new lCe(y);return e.runWebGLProgram(_,[s],o.dtype)}},hCe={kernelName:eC,backendName:"webgl",kernelFunc:function dCe(n){const{inputs:t,backend:e,attrs:r}=n,{dy:s,input:i}=t,o=i;Cg([s,i],"avgPoolGrad");const{filterSize:a,strides:u,pad:c}=r,p=vo(o.shape,a,u,1,c),m=new aCe(p);return e.runWebGLProgram(m,[s],o.dtype)}},fCe={kernelName:f_,backendName:"webgl",kernelFunc:function pCe(n){const{inputs:t,backend:e,attrs:r}=n,{a:s,b:i}=t,{transposeA:o,transposeB:a}=r;return X0({a:s,b:i,transposeA:o,transposeB:a,backend:e})}};class mCe{constructor(t,e,r,s,i,o){this.outputShape=[],this.variableNames=["x","mean","variance"],Ht(t,e),Ht(t,r);let a="0.0";null!=s&&(Ht(t,s),this.variableNames.push("offset"),a="getOffsetAtOutCoords()");let u="1.0";null!=i&&(Ht(t,i),this.variableNames.push("scale"),u="getScaleAtOutCoords()"),this.outputShape=t,this.userCode=`\n      void main() {\n        float x = getXAtOutCoords();\n        float mean = getMeanAtOutCoords();\n        float variance = getVarianceAtOutCoords();\n        float offset = ${a};\n        float scale = ${u};\n        float inv = scale * inversesqrt(variance + float(${o}));\n        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));\n      }\n    `}}class gCe{constructor(t,e,r,s,i,o){this.packedInputs=!0,this.packedOutput=!0,this.variableNames=["x","mean","variance"],Ht(t,e),Ht(t,r);let a="vec4(0.0)";null!=s&&(Ht(t,s),this.variableNames.push("offset"),a="getOffsetAtOutCoords()");let u="vec4(1.0)";null!=i&&(Ht(t,i),this.variableNames.push("scale"),u="getScaleAtOutCoords()"),this.outputShape=t,this.userCode=`\n      void main() {\n        vec4 offset = ${a};\n        vec4 scale = ${u};\n\n        vec4 x = getXAtOutCoords();\n        vec4 mean = getMeanAtOutCoords();\n        vec4 variance = getVarianceAtOutCoords();\n\n        vec4 inv = scale * inversesqrt(variance + vec4(${o}));\n\n        setOutput((x - mean) * inv + offset);\n      }\n    `}}const yCe={kernelName:I_,backendName:"webgl",kernelFunc:({inputs:n,backend:t,attrs:e})=>{const{x:r,mean:s,variance:i,offset:o,scale:a}=n;J(s.shape.length===i.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),J(null==o||s.shape.length===o.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),J(null==a||s.shape.length===a.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");let{varianceEpsilon:u}=e;null==u&&(u=.001);const c=[r,s,i];let p=null;null!=o&&(p=o.shape,c.push(o));let m=null;null!=a&&(m=a.shape,c.push(a));const y=De().getBool("WEBGL_PACK_NORMALIZATION")?new gCe(r.shape,s.shape,i.shape,p,m,u):new mCe(r.shape,s.shape,i.shape,p,m,u);return t.runWebGLProgram(y,c,c[0].dtype)}};class bCe{constructor(t){this.variableNames=["source"],this.outputShape=t,this.rank=t.length;const e=Vn(this.rank);this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const r=function _Ce(n){if(1===n)return"sourceLoc";if(n<=6)return $A.slice(0,n).map(t=>"sourceLoc."+t).join(",");throw Error(`Slicing for rank ${n} is not yet supported`)}(this.rank);let s;s=`\n        ${e} sourceLoc;\n        ${e} coords = getOutputCoords();\n        ${t.map((o,a)=>`sourceLoc.${$A[a]} = start[${a}] + coords.${$A[a]};`).join("\n")}\n      `,this.userCode=`\n      void main() {\n        ${s}\n        setOutput(getSource(${r}));\n      }\n    `}}const $A=["x","y","z","w","u","v"];class vCe{constructor(t){this.variableNames=["source"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t,this.rank=t.length,this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const e=Vn(this.rank),r=Ws("coords",this.rank),s=Ws("sourceLoc",this.rank),i=1===this.rank?"sourceLoc":`vec2(${s.slice(-2).join()})`,o=`getChannel(getSource(${s.join()}), ${i})`,a=`\n      result.x = ${o};\n      if (++${r[this.rank-1]} < ${t[this.rank-1]}) {\n        ++${s[this.rank-1]};\n        result.y = ${o};\n        --${s[this.rank-1]};\n      }\n    `,u=1===this.rank?"":`\n      --${r[this.rank-1]};\n      if (++${r[this.rank-2]} < ${t[this.rank-2]}) {\n        ++${s[this.rank-2]};\n        result.z = ${o};\n        if (++${r[this.rank-1]} < ${t[this.rank-1]}) {\n          ++${s[this.rank-1]};\n          result.w = ${o};\n        }\n      }\n    `,c=this.rank<=4?`sourceLoc = coords +\n            ${e}(${t.map((p,m)=>`start[${m}]`).join()});`:t.map((p,m)=>`${s[m]} = ${r[m]} + start[${m}];`).join("\n");this.userCode=`\n      void main() {\n        ${e} coords = getOutputCoords();\n        ${e} sourceLoc;\n        ${c}\n        vec4 result = vec4(0.);\n        ${a}\n        ${u}\n        setOutput(result);\n      }\n    `}}function Zh(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{begin:i,size:o}=r,[a,u]=Tv(s,i,o);if(LI(s,a,u),0===Fe(u))return e.makeTensorInfo(u,s.dtype,[]);if(e.shouldExecuteOnCPU([s])||"string"===s.dtype){const m=e.texData.get(s.dataId),y=dSe(m.values,a,u,s.shape,s.dtype);return e.makeTensorInfo(u,s.dtype,y)}const{isPacked:c}=e.texData.get(s.dataId),p=BI(s.shape,a,u);if(c||!p){const m=De().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new vCe(u):new bCe(u);return e.runWebGLProgram(m,[s],s.dtype,[a])}return e.uploadToGPU(s.dataId),function wCe(n,t,e,r){const s=r.texData.get(n.dataId),i=r.makeTensorInfo(e,n.dtype),o=r.texData.get(i.dataId);Object.assign(o,s),o.refCount=1,o.shape=e,o.dtype=n.dtype;let a=zI(t,Nt(n.shape));s.slice&&(a+=s.slice.flatOffset),o.slice={flatOffset:a,origDataId:s.slice&&s.slice.origDataId||n.dataId};const u=r.dataRefCount.get(o.slice.origDataId)||1;return r.dataRefCount.set(o.slice.origDataId,u+1),i}(s,a,u,e)}const xCe={kernelName:tv,backendName:"webgl",kernelFunc:Zh},TCe={kernelName:m_,backendName:"webgl",kernelFunc:n=>{const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{blockShape:i,crops:o}=r;J(s.shape.length<=4,()=>"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet");const a=i.reduce((M,V)=>M*V),u=rg(s.shape,i,a),c=sg(u.length,i.length),p=ig(s.shape,i,a),m=VE(o,i.length),y=BE(p,o,i.length),_=[],w=ut({inputs:{x:s},backend:e,attrs:{shape:u}}),T=Hs({inputs:{x:w},backend:e,attrs:{perm:c}}),I=ut({inputs:{x:T},backend:e,attrs:{shape:p}}),O=Zh({inputs:{x:I},backend:e,attrs:{begin:m,size:y}});return _.push(w),_.push(T),_.push(I),_.forEach(M=>e.disposeIntermediateTensorInfo(M)),O}},CCe={kernelName:nC,backendName:"webgl",kernelFunc:function SCe(n){const{inputs:t,backend:e,attrs:r}=n,{x:s,weights:i}=t,{size:o}=r,a=e.readSync(s.dataId),u=e.readSync(i.dataId),c=nj(a,u,i.dtype,i.shape,o);return e.makeTensorInfo([o],i.dtype,c)}},ECe={kernelName:sC,backendName:"webgl",kernelFunc:function ICe(n){const{inputs:t,backend:e}=n,{s0:r,s1:s}=t,i=e.readSync(r.dataId),o=e.readSync(s.dataId),a=Ht(Array.from(i),Array.from(o));return e.makeTensorInfo([a.length],"int32",Int32Array.from(a))}},Ij=Ts({opSnippet:"return float(a != b);",cpuKernelImpl:nSe,dtype:"bool"}),DCe={kernelName:j_,backendName:"webgl",kernelFunc:Ij};function kg(n){const{inputs:t,backend:e}=n,{input:r}=t;return Ai({inputs:{x:e.texData.get(r.dataId).complexTensorInfos.real},backend:e})}const ACe={kernelName:VC,backendName:"webgl",kernelFunc:kg},OCe={kernelName:Yf,backendName:"webgl",kernelFunc:function LA(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{dtype:i}=r;if("complex64"===i){if("complex64"===s.dtype)return Ai({inputs:{x:s},backend:e});const o=Yr(s.shape),a=LA({inputs:{x:s},backend:e,attrs:{dtype:"float32"}}),u=Au({inputs:{real:a,imag:o},backend:e});return o.dispose(),e.disposeIntermediateTensorInfo(a),u}if("complex64"===s.dtype){const o=kg({inputs:{input:s},backend:e}),a=LA({inputs:{x:o},backend:e,attrs:{dtype:i}});return e.disposeIntermediateTensorInfo(o),a}if(!AL(s.dtype,i)){const o=Ai({inputs:{x:s},backend:e});return{dataId:o.dataId,shape:o.shape,dtype:i}}if(e.shouldExecuteOnCPU([s])){const o=e.texData.get(s.dataId).values,[a,u,c]=FTe(o,s.shape,s.dtype,i);return e.makeTensorInfo(a,u,c)}if("int32"===i)return function NCe(n,t){const e=new ja(n.shape,"return float(int(x));"),r=t.runWebGLProgram(e,[n],"int32");return{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}(s,e);if("bool"===i){const o=e.makeTensorInfo([],"bool",_s("bool",1)),u=Ij({inputs:{a:s,b:o},backend:e});return e.disposeIntermediateTensorInfo(o),u}throw new Error(`Error in Cast: failed to cast ${s.dtype} to ${i}`)}},Ej="return ceil(x);",RCe=bn({opSnippet:Ej,packedOpSnippet:Ej,cpuKernelImpl:$Te}),MCe={kernelName:Zf,backendName:"webgl",kernelFunc:RCe};class PCe{constructor(t){this.variableNames=["A"],this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=t,this.userCode="\n\n      void main() {\n        float value = getAAtOutCoords();\n        if (isnan(value)) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, minVal, maxVal));\n      }\n    "}}class FCe{constructor(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=t,this.userCode="\n      void main() {\n        vec4 value = getAAtOutCoords();\n\n        if (any(isnan(value))) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));\n      }\n    "}}const LCe={kernelName:Qf,backendName:"webgl",kernelFunc:function $Ce(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{clipValueMin:i,clipValueMax:o}=r;let a;return a=De().getBool("WEBGL_PACK_CLIP")?new FCe(s.shape):new PCe(s.shape),e.runWebGLProgram(a,[s],s.dtype,[[i],[o]])}};class VCe{constructor(t){this.variableNames=["real","imag"],this.outputShape=t,this.userCode="\n      void main() {\n        float re = abs(getRealAtOutCoords());\n        float im = abs(getImagAtOutCoords());\n        float mx = max(re, im);\n\n        // sadly the length function in glsl is not underflow-safe\n        // (at least not on Intel GPUs). So the safe solution is\n        // to ensure underflow-safety in all cases.\n        setOutput(\n          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))\n        );\n      }\n    "}}function Dj(n,t){return{dataId:t.dataId,dtype:t.dtype,shape:n.shape}}const zCe={kernelName:g_,backendName:"webgl",kernelFunc:function BCe(n){const{inputs:t,backend:e}=n,{x:r}=t,s=e.texData.get(r.dataId),i=new VCe(r.shape),o=[Dj(r,s.complexTensorInfos.real),Dj(r,s.complexTensorInfos.imag)];return e.runWebGLProgram(i,o,o[0].dtype)}};class UCe{constructor(t){this.outputShape=[],this.outputShape=Ra(t,1),this.variableNames=t.map((o,a)=>`T${a}`);const e=new Array(t.length-1);e[0]=t[0][1];for(let o=1;o<e.length;o++)e[o]=e[o-1]+t[o][1];const r=[`if (yC < ${e[0]}) setOutput(getT0(yR, yC));`];for(let o=1;o<e.length;o++)r.push(`else if (yC < ${e[o]}) setOutput(getT${o}(yR, yC-${e[o-1]}));`);r.push(`else setOutput(getT${e.length}(yR, yC-${e[e.length-1]}));`),this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int yR = coords.x;\n        int yC = coords.y;\n\n        ${r.join("\n        ")}\n      }\n    `}}class jCe{constructor(t,e){this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[],this.outputShape=Ra(t,e);const r=this.outputShape,s=r.length,i=Vn(s),o=Ws("coords",s),a=["x","y","z","w","u","v"].slice(0,s);this.variableNames=t.map((T,I)=>`T${I}`);const u=new Array(t.length-1);u[0]=t[0][e];for(let T=1;T<u.length;T++)u[T]=u[T-1]+t[T][e];const c=a[e],p=a.slice(-2),m=a.join();let y=`if (${c} < ${u[0]}) {\n        return getChannel(\n            getT0(${m}), vec2(${p.join()}));\n        }`;for(let T=1;T<u.length;T++){const I=u[T-1];y+=`\n        if (${c} < ${u[T]}  && ${c} >= ${u[T-1]}) {\n          return getChannel(\n            getT${T}(${Z0(a,c,I)}),\n            vec2(${Z0(p,c,I)}));\n        }`}const w=u[u.length-1];y+=`\n        return getChannel(\n          getT${u.length}(${Z0(a,c,w)}),\n          vec2(${Z0(p,c,w)}));`,this.userCode=`\n      float getValue(${a.map(T=>"int "+T)}) {\n        ${y}\n      }\n\n      void main() {\n        ${i} coords = getOutputCoords();\n        vec4 result = vec4(getValue(${o}), 0., 0., 0.);\n\n        ${o[s-1]} = ${o[s-1]} + 1;\n        if (${o[s-1]} < ${r[s-1]}) {\n          result.g = getValue(${o});\n        }\n\n        ${o[s-2]} = ${o[s-2]} + 1;\n        if (${o[s-2]} < ${r[s-2]}) {\n          result.a = getValue(${o});\n        }\n\n        ${o[s-1]} = ${o[s-1]} - 1;\n        if (${o[s-2]} < ${r[s-2]} &&\n            ${o[s-1]} < ${r[s-1]}) {\n          result.b = getValue(${o});\n        }\n        setOutput(result);\n      }\n    `}}function Z0(n,t,e){const r=n.indexOf(t);return n.map((i,o)=>o===r?`${i} - ${e}`:i).join()}function Q0(n){const{inputs:t,backend:e}=n,{input:r}=t;return Ai({inputs:{x:e.texData.get(r.dataId).complexTensorInfos.imag},backend:e})}const GCe={kernelName:CC,backendName:"webgl",kernelFunc:Q0};function Ng(n,t,e){const r=n[0].dtype;if("complex64"===r){const _=n.map(M=>kg({inputs:{input:M},backend:e})),w=n.map(M=>Q0({inputs:{input:M},backend:e})),T=Ng(_,t,e),I=Ng(w,t,e),O=Au({inputs:{real:T,imag:I},backend:e});return _.forEach(M=>e.disposeIntermediateTensorInfo(M)),w.forEach(M=>e.disposeIntermediateTensorInfo(M)),e.disposeIntermediateTensorInfo(T),e.disposeIntermediateTensorInfo(I),O}let s=e.shouldExecuteOnCPU(n);if("string"===r&&(s=!0),s){const _=n.map(z=>{const Q=[-1,Fe(z.shape.slice(t))];return ut({inputs:{x:z},backend:e,attrs:{shape:Q}})}),w=_.map(z=>({vals:e.readSync(z.dataId),shape:z.shape})),T=Ra(_.map(z=>z.shape),1),O=LTe(w,T,r,1===_[0].shape[0]),M=Ra(n.map(z=>z.shape),t),V=e.makeTensorInfo(M,r,O);return _.forEach(z=>e.disposeIntermediateTensorInfo(z)),V}const i=n.filter(_=>Fe(_.shape)>0),o=De().getBool("WEBGL_PACK_ARRAY_OPERATIONS")&&i[0].shape.length>1;if(1===i.length){const _=o?new ja(n[0].shape,Eu):new Du(n[0].shape,Eu);return e.runWebGLProgram(_,n,r)}const a=De().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER");if(i.length>a){const _=[];for(let T=0;T<i.length;T+=a){const I=i.slice(T,T+a);_.push(Ng(I,t,e))}const w=Ng(_,t,e);for(const T of _)e.disposeIntermediateTensorInfo(T);return w}if(o){const _=new jCe(i.map(w=>w.shape),t);return e.runWebGLProgram(_,i,r)}const{tensors2D:u,outShape:c}=function WCe(n,t,e){const r=Ra(n.map(i=>i.shape),t);return{tensors2D:n.map(i=>ut({inputs:{x:i},attrs:{shape:[-1,Fe(i.shape.slice(t))]},backend:e})),outShape:r}}(i,t,e),p=new UCe(u.map(_=>_.shape)),m=e.runWebGLProgram(p,u,r);u.forEach(_=>e.disposeIntermediateTensorInfo(_));const y=ut({inputs:{x:m},attrs:{shape:c},backend:e});return e.disposeIntermediateTensorInfo(m),y}function Aj(n){const{inputs:t,backend:e,attrs:r}=n,{axis:s}=r,i=sn(s,t[0].shape)[0];FE(t.map(c=>c.shape),i);const a=Ra(t.map(c=>c.shape),i);if(0===Fe(a))return e.makeTensorInfo(a,t[0].dtype,[]);const u=t.filter(c=>Fe(c.shape)>0);return 1===u.length?Ai({inputs:{x:u[0]},backend:e}):Ng(u,i,e)}const HCe={kernelName:y_,backendName:"webgl",kernelFunc:Aj};class kj{constructor(t,e=!1,r=null,s=!1,i=!1){this.variableNames=["x","W"],this.outputShape=t.outShape;const o=t.padInfo.top,a=t.padInfo.left,u=t.strideHeight,c=t.strideWidth,p=t.dilationHeight,m=t.dilationWidth,y=t.filterHeight,_=t.filterWidth,w=4*Math.floor(t.inChannels/4),T=t.inChannels%4,I="channelsLast"===t.dataFormat,O=I?1:2,M=I?2:3,V=I?3:1;let z="",G="";r&&(z=s?`float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ${r}\n        }`:i?`float activation(float a) {\n          float b = getLeakyreluAlphaAtOutCoords();\n          ${r}\n        }`:`\n          float activation(float x) {\n            ${r}\n          }\n        `,G="result = activation(result);");const Q=e?"result += getBiasAtOutCoords();":"";e&&this.variableNames.push("bias"),s&&this.variableNames.push("preluActivationWeights"),i&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n      ${z}\n\n      const ivec2 strides = ivec2(${u}, ${c});\n      const ivec2 pads = ivec2(${o}, ${a});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d2 = coords[${V}];\n\n        ivec2 xRCCorner =\n            ivec2(coords[${O}], coords[${M}]) * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${y}; wR++) {\n          int xR = xRCorner + wR * ${p};\n\n          if (xR < 0 || xR >= ${t.inHeight}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${_}; wC++) {\n            int xC = xCCorner + wC * ${m};\n\n            if (xC < 0 || xC >= ${t.inWidth}) {\n              continue;\n            }\n\n            for (int d1 = 0; d1 < ${w}; d1 += 4) {\n              vec4 wValues = vec4(\n                getW(wR, wC, d1, d2),\n                getW(wR, wC, d1 + 1, d2),\n                getW(wR, wC, d1 + 2, d2),\n                getW(wR, wC, d1 + 3, d2)\n              );\n\n              if (${I}) {\n                vec4 xValues = vec4(\n                  getX(batch, xR, xC, d1),\n                  getX(batch, xR, xC, d1 + 1),\n                  getX(batch, xR, xC, d1 + 2),\n                  getX(batch, xR, xC, d1 + 3)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec4 xValues = vec4(\n                  getX(batch, d1, xR, xC),\n                  getX(batch, d1 + 1, xR, xC),\n                  getX(batch, d1 + 2, xR, xC),\n                  getX(batch, d1 + 3, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n\n            if (${1===T}) {\n\n              if (${I}) {\n                dotProd +=\n                    getX(batch, xR, xC, ${w}) *\n                    getW(wR, wC, ${w}, d2);\n              } else {\n                dotProd +=\n                    getX(batch, ${w}, xR, xC) *\n                    getW(wR, wC, ${w}, d2);\n              }\n\n            } else if (${2===T}) {\n              vec2 wValues = vec2(\n                getW(wR, wC, ${w}, d2),\n                getW(wR, wC, ${w} + 1, d2)\n              );\n\n              if (${I}) {\n                vec2 xValues = vec2(\n                  getX(batch, xR, xC, ${w}),\n                  getX(batch, xR, xC, ${w} + 1)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec2 xValues = vec2(\n                  getX(batch, ${w}, xR, xC),\n                  getX(batch, ${w} + 1, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            } else if (${3===T}) {\n              vec3 wValues = vec3(\n                getW(wR, wC, ${w}, d2),\n                getW(wR, wC, ${w} + 1, d2),\n                getW(wR, wC, ${w} + 2, d2)\n              );\n\n              if (${I}) {\n                vec3 xValues = vec3(\n                  getX(batch, xR, xC, ${w}),\n                  getX(batch, xR, xC, ${w} + 1),\n                  getX(batch, xR, xC, ${w} + 2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec3 xValues = vec3(\n                  getX(batch, ${w}, xR, xC),\n                  getX(batch, ${w} + 1, xR, xC),\n                  getX(batch, ${w} + 2, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            }\n          }\n        }\n\n        float result = dotProd;\n        ${Q}\n        ${G}\n        setOutput(result);\n      }\n    `}}class qCe{constructor(t){this.variableNames=["x","W"],this.outputShape=t.outShape;const e=t.padInfo.front,r=t.padInfo.top,s=t.padInfo.left,i=t.strideDepth,o=t.strideHeight,a=t.strideWidth,u=t.dilationDepth,c=t.dilationHeight,p=t.dilationWidth,m=t.filterDepth,y=t.filterHeight,_=t.filterWidth,w=4*Math.floor(t.inChannels/4),T=t.inChannels%4;this.userCode=`\n      const ivec3 strides = ivec3(${i}, ${o}, ${a});\n      const ivec3 pads = ivec3(${e}, ${r}, ${s});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d2 = coords.u;\n\n        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xFCorner = xFRCCorner.x;\n        int xRCorner = xFRCCorner.y;\n        int xCCorner = xFRCCorner.z;\n\n        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get\n        // y(yF, yR, yC, d2). ? = to be determined. : = across all\n        // values in that axis.\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ${m}; wF++) {\n          int xF = xFCorner + wF * ${u};\n\n          if (xF < 0 || xF >= ${t.inDepth}) {\n            continue;\n          }\n\n          for (int wR = 0; wR < ${y}; wR++) {\n            int xR = xRCorner + wR * ${c};\n\n            if (xR < 0 || xR >= ${t.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${_}; wC++) {\n              int xC = xCCorner + wC * ${p};\n\n              if (xC < 0 || xC >= ${t.inWidth}) {\n                continue;\n              }\n\n              for (int d1 = 0; d1 < ${w}; d1 += 4) {\n                vec4 xValues = vec4(\n                  getX(batch, xF, xR, xC, d1),\n                  getX(batch, xF, xR, xC, d1 + 1),\n                  getX(batch, xF, xR, xC, d1 + 2),\n                  getX(batch, xF, xR, xC, d1 + 3)\n                );\n                vec4 wValues = vec4(\n                  getW(wF, wR, wC, d1, d2),\n                  getW(wF, wR, wC, d1 + 1, d2),\n                  getW(wF, wR, wC, d1 + 2, d2),\n                  getW(wF, wR, wC, d1 + 3, d2)\n                );\n\n                dotProd += dot(xValues, wValues);\n              }\n\n              if (${1===T}) {\n                dotProd +=\n                  getX(batch, xF, xR, xC, ${w}) *\n                  getW(wF, wR, wC, ${w}, d2);\n              } else if (${2===T}) {\n                vec2 xValues = vec2(\n                  getX(batch, xF, xR, xC, ${w}),\n                  getX(batch, xF, xR, xC, ${w} + 1)\n                );\n                vec2 wValues = vec2(\n                  getW(wF, wR, wC, ${w}, d2),\n                  getW(wF, wR, wC, ${w} + 1, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else if (${3===T}) {\n                vec3 xValues = vec3(\n                  getX(batch, xF, xR, xC, ${w}),\n                  getX(batch, xF, xR, xC, ${w} + 1),\n                  getX(batch, xF, xR, xC, ${w} + 2)\n                );\n                vec3 wValues = vec3(\n                  getW(wF, wR, wC, ${w}, d2),\n                  getW(wF, wR, wC, ${w} + 1, d2),\n                  getW(wF, wR, wC, ${w} + 2, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class Nj{constructor(t,e=!1,r=null,s=!1,i=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=t.outShape,this.enableShapeUniforms=Rs(this.outputShape.length);const o=t.padInfo.left,a=t.strideWidth,u=t.dilationWidth,c=t.filterHeight,p=t.filterWidth,m=p;let y="\n       int xR; int xC; int xCOffset;\n       vec4 wTexel; vec4 previous; vec4 final;";for(let I=0;I<p;I++)y+=`\n           vec4 xTexelC${2*I};\n           int xTexelC${2*I}Ready;\n           vec4 xTexelC${2*I+1};\n           int xTexelC${2*I+1}Ready;\n           vec4 xC${I};`;y+=`\n     for (int r = 0; r < ${c}; r++) {\n      for (int d1 = 0; d1 < ${t.inChannels}; d1 += 2) {\n       `;for(let I=0;I<p;I++)y+=`\n           xTexelC${2*I} = vec4(0.0);\n           xTexelC${2*I}Ready = 0;\n           xTexelC${2*I+1} = vec4(0.0);\n           xTexelC${2*I+1}Ready = 0;\n           xC${I} = vec4(0.0);`;y+="\n         xR = xRCorner + r * dilations[0];\n         if (xR >=0 && xR < inDims[0]) {\n       ";for(let I=0;I<(m+1)/2;I++){const O=2*I;if(y+=`\n           xC = xCCorner + ${O*u};\n           `,1===a){if(O<p&&(o%2==1?(y+=`\n                 xCOffset = xC + 1;\n                 if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${O}Ready == 0) {\n                   xTexelC${O} = getX(batch, xR, xCOffset, d1);\n\n                   // Need to manually clear unused channels in case\n                   // we're reading from recycled texture.\n                   if (xCOffset + 1 >= inDims[1]) {\n                     xTexelC${O}.zw = vec2(0.0);\n                   }\n                   xTexelC${O}Ready = 1;\n                 }\n               `,y+=1===u&&O>0?`\n                 xC${O} = vec4(xTexelC${O-2}.zw, xTexelC${O}.xy);\n                 `:`\n                   xCOffset = xC + 1 - 2;\n\n                   if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                     previous = getX(batch, xR, xCOffset, d1);\n\n                     // Need to manually clear unused channels in case\n                     // we're reading from recycled texture.\n                     if (xCOffset + 1 >= inDims[1]) {\n                       previous.zw = vec2(0.0);\n                     }\n\n                     xC${O} = vec4(previous.zw, xTexelC${O}.xy);\n                   } else {\n                     xC${O} = vec4(0.0, 0.0, xTexelC${O}.xy);\n                   }\n                   `):y+=`\n                 if (xC >= 0 && xC < inDims[1] && xTexelC${O}Ready == 0) {\n                   xTexelC${O} = getX(batch, xR, xC, d1);\n                   if (xC + 1 >= inDims[1]) {\n                     xTexelC${O}.zw = vec2(0.0);\n                   }\n                   xTexelC${O}Ready = 1;\n                 }\n\n                 xC${O} = xTexelC${O};\n                 `,O+1<p)){const M=o%2==0?G1(u):u;u%2==0&&o%2==1||u%2!=0&&o%2!=1?(y+=`\n                   xCOffset = xC + imod(pads[1], 2) + ${M};\n\n                   if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${O+1}Ready == 0) {\n                     xTexelC${O+1} = getX(batch, xR, xCOffset, d1);\n\n                     // Need to manually clear unused channels in case\n                     // we're reading from recycled texture.\n                     if (xCOffset + 1 >= inDims[1]) {\n                       xTexelC${O+1}.zw = vec2(0.0);\n                     }\n                     xTexelC${O+1}Ready = 1;\n                   }\n                   `,y+=u>1?`\n                     xCOffset -= 2;\n                     if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                      previous = getX(batch, xR, xCOffset, d1);\n                      xC${O+1} = vec4(previous.zw, xTexelC${O+1}.xy);\n                     } else {\n                      xC${O+1} = vec4(0.0, 0.0, xTexelC${O+1}.xy);\n                     }\n                     `:`\n                     xC${O+1} = vec4(xTexelC${O}.zw, xTexelC${O+1}.xy);\n                     `):y+=1===M?`\n                     xC${O+1} = xTexelC${O};\n                     `:`\n                     xCOffset = xC + ${M};\n\n                     if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${O+1}Ready == 0) {\n                       xTexelC${O+1} = getX(batch, xR, xCOffset, d1);\n                       if (xCOffset + 1 >= inDims[1]) {\n                         xTexelC${O+1}.zw = vec2(0.0);\n                       }\n                       xTexelC${O+1}Ready = 1;\n                     }\n\n                     xC${O+1} = xTexelC${O+1};\n                     `}}else O<p&&(o%2==1?(y+=`\n                 xCOffset = xC + 1 - strides[1];\n                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${O}Ready == 0) {\n                   xTexelC${O} = getX(batch, xR, xCOffset, d1);\n                   // Need to manually clear unused channels in case\n                   // we're reading from recycled texture.\n                   if (xCOffset + 1 >= inDims[1]) {\n                     xTexelC${O}.zw = vec2(0.0);\n                   }\n                   xTexelC${O}Ready = 1;\n                 }\n\n                 if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${O+1}Ready == 0) {\n                   xTexelC${O+1} = getX(batch, xR, xC + 1, d1);\n                   // Need to manually clear unused channels in case\n                   // we're reading from recycled texture.\n                   if (xC + 2 >= inDims[1]) {\n                     xTexelC${O+1}.zw = vec2(0.0);\n                   }\n                   xTexelC${O+1}Ready = 1;\n                 }\n\n                 xC${O} = vec4(xTexelC${O}.zw, xTexelC${O+1}.zw);\n               `,O+1<p&&(y+=`\n                   final = vec4(0.0);\n                   xCOffset = xC + 1 + strides[1];\n                   if(xCOffset >= 0 && xCOffset < inDims[1]) {\n                     final = getX(batch, xR, xCOffset, d1);\n                   }\n                   xC${O+1} = vec4(xTexelC${O+1}.xy, final.xy);\n                 `)):(y+=`\n                 if(xC >= 0 && xC < inDims[1] && xTexelC${O}Ready == 0) {\n                   xTexelC${O} = getX(batch, xR, xC, d1);\n                   if (xC + 1 >= inDims[1]) {\n                     xTexelC${O}.zw = vec2(0.0);\n                   }\n                   xTexelC${O}Ready = 1;\n                 }\n\n                 xCOffset = xC + strides[1];\n                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${O+1}Ready == 0) {\n                   xTexelC${O+1} = getX(batch, xR, xCOffset, d1);\n                   if (xCOffset + 1 >= inDims[1]) {\n                     xTexelC${O+1}.zw = vec2(0.);\n                   }\n                   xTexelC${O+1}Ready = 1;\n                 }\n\n                 xC${O} = vec4(\n                   xTexelC${O}.xy, xTexelC${O+1}.xy);\n               `,O+1<p&&(y+=`\n                   xC${O+1} = vec4(xTexelC${O}.zw, xTexelC${O+1}.zw);\n                 `)));O<p&&(y+=`\n             wTexel = getW(r, ${O}, d1, d2);\n             dotProd += xC${O}.xxzz * vec4(wTexel.xy, wTexel.xy);\n             if(d1 + 1 < ${t.inChannels}) {\n               dotProd += xC${O}.yyww * vec4(wTexel.zw, wTexel.zw);\n             }\n           `,O+1<p&&(y+=`\n               wTexel = getW(r, ${O+1}, d1, d2);\n               dotProd += xC${O+1}.xxzz * vec4(wTexel.xy, wTexel.xy);\n               if(d1 + 1 < ${t.inChannels}) {\n                 dotProd += xC${O+1}.yyww * vec4(wTexel.zw, wTexel.zw);\n               }\n             `))}y+="\n     }\n   ",y+="\n     }\n   ",y+="\n     }\n   ";let _="",w="";r&&(_=s?`vec4 activation(vec4 a) {\n           vec4 b = getPreluActivationWeightsAtOutCoords();\n           ${r}\n         }`:i?`vec4 activation(vec4 a) {\n           vec4 b = getLeakyreluAlphaAtOutCoords();\n           ${r}\n         }`:`vec4 activation(vec4 x) {\n           ${r}\n         }`,w="result = activation(result);");const T=e?"result += getBiasAtOutCoords();":"";e&&this.variableNames.push("bias"),s&&this.variableNames.push("preluActivationWeights"),i&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n       ${_}\n\n       void main() {\n         ivec4 coords = getOutputCoords();\n         int batch = coords.x;\n         ivec2 xRCCorner = coords.yz * strides - pads;\n         int d2 = coords.w;\n         int xRCorner = xRCCorner.x;\n         int xCCorner = xRCCorner.y;\n\n         //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.\n         vec4 dotProd = vec4(0.000000000000001);\n\n         ${y}\n\n         vec4 result = dotProd - vec4(0.000000000000001);\n         ${T}\n         ${w}\n         setOutput(result);\n       }\n     `}}class KCe{constructor(t,e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec4"},{name:"pad",type:"ivec2"},{name:"stride",type:"ivec2"},{name:"dilation",type:"ivec2"},{name:"inChannels",type:"int"},{name:"itemsPerBlockRow",type:"int"},{name:"outWidth",type:"int"}],this.outputShape=t,this.enableShapeUniforms=Rs(this.outputShape.length);const{dataFormat:r}=e,s=Gs(),i="channelsLast"===r,o=i?1:2,a=i?2:3,u=this.enableShapeUniforms?"if(blockIndex < outShape[2] && pos < outShape[1]) {":`if(blockIndex < ${t[2]} && pos < ${t[1]}) {`;let c="";for(let p=0;p<=1;p++)for(let m=0;m<=1;m++)c+=`\n          blockIndex = rc.z + ${m};\n          pos = rc.y + ${p};\n\n          ${u}\n            offsetY = int(blockIndex / outWidth) * stride[0] - pad[0];\n            d0 = offsetY + dilation[0] * (pos / itemsPerBlockRow);\n\n            if(d0 < inputShape[${o}] && d0 >= 0) {\n              // Use custom imod instead mod. On Intel GPU, mod may generate\n              // unexpected value.\n              // https://github.com/tensorflow/tfjs/issues/5447\n              offsetX = imod(blockIndex, outWidth) * stride[1] - pad[1];\n              d1 = offsetX + dilation[1] * (imod(pos, itemsPerBlockRow) /\n                  inChannels);\n\n              if(d1 < inputShape[${a}] && d1 >= 0) {\n\n                ch = imod(pos, inChannels);\n\n                if (${i}) {\n                  innerDims = vec2(d1, ch);\n                  result[${2*p+m}] = getChannel(\n                    getA(rc.x, d0, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                } else {\n                  innerDims = vec2(d0, d1);\n                  result[${2*p+m}] = getChannel(\n                    getA(rc.x, ch, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                }\n              }\n            }\n          }\n        `;this.userCode=`\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0);\n\n        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;\n        vec2 innerDims;\n\n        ${c}\n\n        ${s.output} = result;\n      }\n    `}}function J0(n,t){const e=n.length;return e>=3?t?[...n.slice(0,-3),n[e-3]*n[e-2],n[e-1]]:[...n.slice(0,-3),n[e-3],n[e-2]*n[e-1]]:!t&&1===e&&n[0]>1?[n[0],1]:null}function Oj({x:n,filter:t,convInfo:e,backend:r,bias:s=null,preluActivationWeights:i=null,leakyreluAlpha:o=0,activation:a=null}){const u=n.shape,c=r.texData.get(n.dataId),p=e.inChannels,m=u[0]*u[1]*u[2],y=e.outChannels,_="channelsLast"===e.dataFormat;let I;const O=[];if(null!=i){const z=J0(i.shape,_);null!=z&&(i=ut({inputs:{x:i},backend:r,attrs:{shape:z}}),O.push(i))}if(null!=s){const z=J0(s.shape,_);null!=z&&(s=ut({inputs:{x:s},backend:r,attrs:{shape:z}}),O.push(s))}if((1!==m&&1!==y||!(p>vj))&&c.isPacked&&_&&null!=c.texture&&u[2]%2!=0&&hn(c.shape.slice(-3),u.slice(-3))){const G={dataId:n.dataId,shape:[1,u[0]*u[1]*(u[2]+1),e.inChannels],dtype:n.dtype},Q=c.shape;c.shape=c.shape.slice(),c.shape[c.shape.length-2]++,J(z0(c.shape,G.shape),()=>`packed reshape ${c.shape} to ${G.shape} isn't free`);const ne=ut({inputs:{x:t},backend:r,attrs:{shape:[1,e.inChannels,e.outChannels]}});O.push(ne);const oe=X0({a:G,b:ne,backend:r,transposeA:!1,transposeB:!1,bias:s,activation:a,preluActivationWeights:i,leakyreluAlpha:o}),de=r.texData.get(oe.dataId);J(de.isPacked,()=>"batchMatMul result is expected to be packed"),c.shape=Q,de.shape=e.outShape,I=Ai({inputs:{x:oe},backend:r}),I.shape=e.outShape,O.push(oe)}else{const z=e.outHeight*e.outWidth,G=ut({inputs:{x:n},backend:r,attrs:{shape:_?[e.batchSize,z,e.inChannels]:[e.batchSize,e.inChannels,z]}}),Q=ut({inputs:{x:t},backend:r,attrs:{shape:[1,e.inChannels,e.outChannels]}}),ne=X0({a:_?G:Q,b:_?Q:G,transposeA:!_,transposeB:!1,backend:r,bias:s,activation:a,preluActivationWeights:i,leakyreluAlpha:o});I=ut({inputs:{x:ne},backend:r,attrs:{shape:e.outShape}}),O.push(G),O.push(Q),O.push(ne)}for(const z of O)r.disposeIntermediateTensorInfo(z);return I}function Rj({x:n,filter:t,convInfo:e,backend:r,bias:s=null,preluActivationWeights:i=null,leakyreluAlpha:o=0,activation:a=null}){const{filterWidth:u,filterHeight:c,inChannels:p,outWidth:m,outHeight:y,dataFormat:_}=e,w="channelsLast"===_,T=u*c*p,I=y*m,O=[e.batchSize,T,I],z=[];if(null!=i){const xe=J0(i.shape,w);null!=xe&&(i=ut({inputs:{x:i},backend:r,attrs:{shape:xe}}),z.push(i))}if(null!=s){const xe=J0(s.shape,w);null!=xe&&(s=ut({inputs:{x:s},backend:r,attrs:{shape:xe}}),z.push(s))}const G=ut({inputs:{x:t},backend:r,attrs:{shape:[1,T,Fe(t.shape)/T]}});z.push(G);const Q=new KCe(O,e),oe=r.runWebGLProgram(Q,[n],"float32",[n.shape,[e.padInfo.top,e.padInfo.left],[e.strideHeight,e.strideWidth],[e.dilationHeight,e.dilationWidth],[e.inChannels],[e.filterWidth*e.inChannels],[e.outWidth]]),de=ut({inputs:{x:oe},backend:r,attrs:{shape:O}});z.push(oe),z.push(de);const pe=null!=s,Te=null!=i,Ae="leakyrelu"===a,Oe=a?Dg(a,!0):null,Me=new mj(w?de.shape:G.shape,w?G.shape:de.shape,w?[e.batchSize,I,e.outChannels]:[e.batchSize,e.outChannels,I],!0,!1,pe,Oe,Te,Ae),Pe=w?[de,G]:[G,de];if(s&&Pe.push(s),Te&&Pe.push(i),Ae){const xe=r.makeTensorInfo([],"float32",Zl(o,"float32"));Pe.push(xe),z.push(xe)}const ve=r.runWebGLProgram(Me,Pe,"float32"),Se=ut({inputs:{x:ve},backend:r,attrs:{shape:e.outShape}});z.push(ve);for(const xe of z)r.disposeIntermediateTensorInfo(xe);return Se}const YCe={kernelName:b_,backendName:"webgl",kernelFunc:function XCe(n){const{inputs:t,backend:e,attrs:r}=n,{x:s,filter:i}=t,{strides:o,pad:a,dataFormat:u,dilations:c,dimRoundingMode:p}=r,m=fl(u),y=ls(s.shape,i.shape,o,c,a,p,!1,m);let _;if(1!==y.filterHeight||1!==y.filterWidth||1!==y.dilationHeight||1!==y.dilationWidth||1!==y.strideHeight||1!==y.strideWidth||"SAME"!==y.padInfo.type&&"VALID"!==y.padInfo.type)if(y.strideWidth<=2&&"channelsLast"===m&&De().getBool("WEBGL_EXP_CONV")){const T=new Nj(y);_=e.runWebGLProgram(T,[s,i],"float32",[[y.padInfo.top,y.padInfo.left],[y.strideHeight,y.strideWidth],[y.dilationHeight,y.dilationWidth],[y.inHeight,y.inWidth]])}else if(De().getBool("WEBGL_CONV_IM2COL"))_=Rj({x:s,filter:i,convInfo:y,backend:e});else{const T=new kj(y);_=e.runWebGLProgram(T,[s,i],"float32")}else _=Oj({x:s,filter:i,convInfo:y,backend:e});const w=ut({inputs:{x:_},backend:e,attrs:{shape:y.outShape}});return e.disposeIntermediateTensorInfo(_),w}};class ZCe{constructor(t){this.variableNames=["x","dy"],this.outputShape=t.filterShape,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int d2 = coords.w;\n\n        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ${t.batchSize}; b++) {\n          for (int yR = 0; yR < ${t.outHeight}; yR++) {\n            int xR = wR + yR * ${t.strideHeight} - ${t.padInfo.top};\n\n            if (xR < 0 || xR >= ${t.inHeight}) {\n              continue;\n            }\n\n            for (int yC = 0; yC < ${t.outWidth}; yC++) {\n              int xC = wC + yC * ${t.strideWidth} - ${t.padInfo.left};\n\n              if (xC < 0 || xC >= ${t.inWidth}) {\n                continue;\n              }\n\n              ${"channelsLast"===t.dataFormat?"float dyValue = getDy(b, yR, yC, d2);\n              float xValue = getX(b, xR, xC, d1);\n              dotProd += (xValue * dyValue);":"float dyValue = getDy(b, d2, yR, yC);\n              float xValue = getX(b, d1, xR, xC);\n              dotProd += (xValue * dyValue);"}\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class QCe{constructor(t){this.variableNames=["dy","W"],this.outputShape=t.inShape;const e=t.filterHeight,r=t.filterWidth,o="channelsLast"===t.dataFormat;this.userCode=`\n      const ivec2 pads = ivec2(${e-1-t.padInfo.top}, ${r-1-t.padInfo.left});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[${o?3:1}];\n\n        ivec2 dyCorner = ivec2(coords[${o?1:2}], coords[${o?2:3}]) - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${e}; wR++) {\n          float dyR = float(dyRCorner + wR) / ${t.strideHeight}.0;\n\n          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ${e} - 1 - wR;\n\n          for (int wC = 0; wC < ${r}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${t.strideWidth}.0;\n\n            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ${r} - 1 - wC;\n\n            for (int d2 = 0; d2 < ${t.outChannels}; d2++) {\n\n              if (${o}) {\n                float xValue = getDy(batch, idyR, idyC, d2);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              } else {\n                float xValue = getDy(batch, d2, idyR, idyC);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class JCe{constructor(t){this.variableNames=["x","dy"],this.outputShape=t.filterShape,this.userCode=`\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int wF = coords.x;\n        int wR = coords.y;\n        int wC = coords.z;\n        int d1 = coords.w;\n        int d2 = coords.u;\n\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ${t.batchSize}; b++) {\n          for (int yF = 0; yF < ${t.outDepth}; yF++) {\n            int xF = wF + yF * ${t.strideDepth} - ${t.padInfo.front};\n\n            if (xF < 0 || xF >= ${t.inDepth}) {\n              continue;\n            }\n\n            for (int yR = 0; yR < ${t.outHeight}; yR++) {\n              int xR = wR + yR * ${t.strideHeight} - ${t.padInfo.top};\n\n              if (xR < 0 || xR >= ${t.inHeight}) {\n                continue;\n              }\n\n              for (int yC = 0; yC < ${t.outWidth}; yC++) {\n                int xC = wC + yC * ${t.strideWidth} - ${t.padInfo.left};\n\n                if (xC < 0 || xC >= ${t.inWidth}) {\n                  continue;\n                }\n\n                float dyValue = getDy(b, yF, yR, yC, d2);\n                float xValue = getX(b, xF, xR, xC, d1);\n                dotProd += (xValue * dyValue);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class eIe{constructor(t){this.variableNames=["dy","W"],this.outputShape=t.inShape;const e=t.filterDepth,r=t.filterHeight,s=t.filterWidth;this.userCode=`\n      const ivec3 pads = ivec3(${e-1-t.padInfo.front}, ${r-1-t.padInfo.top}, ${s-1-t.padInfo.left});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.u;\n\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyFCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ${e}; wF++) {\n          float dyF = float(dyFCorner + wF) / ${t.strideDepth}.0;\n\n          if (dyF < 0.0 || dyF >= ${t.outDepth}.0 || fract(dyF) > 0.0) {\n            continue;\n          }\n          int idyF = int(dyF);\n\n          int wFPerm = ${e} - 1 - wF;\n\n          for (int wR = 0; wR < ${r}; wR++) {\n            float dyR = float(dyRCorner + wR) / ${t.strideHeight}.0;\n\n            if (dyR < 0.0 || dyR >= ${t.outHeight}.0 ||\n              fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            int wRPerm = ${r} - 1 - wR;\n\n            for (int wC = 0; wC < ${s}; wC++) {\n              float dyC = float(dyCCorner + wC) / ${t.strideWidth}.0;\n\n              if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              int wCPerm = ${s} - 1 - wC;\n\n              for (int d2 = 0; d2 < ${t.outChannels}; d2++) {\n                float xValue = getDy(batch, idyF, idyR, idyC, d2);\n                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const nIe={kernelName:oC,backendName:"webgl",kernelFunc:function tIe(n){const{inputs:t,backend:e,attrs:r}=n,{x:s,dy:i}=t,{strides:o,pad:a,dataFormat:u,dimRoundingMode:c,filterShape:p}=r,m=fl(u),y=ls(s.shape,p,o,1,a,c,!1,m),_=new ZCe(y);return e.runWebGLProgram(_,[s,i],"float32")}};class rIe{constructor(t){this.variableNames=["dy","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"strides",type:"vec2"}],this.outputShape=t.inShape,this.enableShapeUniforms=Rs(this.outputShape.length);const e=t.filterHeight,r=t.filterWidth;this.userCode=`\n      const ivec2 pads = ivec2(${e-1-t.padInfo.top}, ${r-1-t.padInfo.left});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[3];\n\n        ivec2 dyCorner = ivec2(coords[1], coords[2]) - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        vec4 result = vec4(0.);\n        for (int wR = 0; wR < ${e}; wR++) {\n          float dyR = float(dyRCorner + wR) / strides[0];\n          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n          int wRPerm = ${e} - 1 - wR;\n\n          for (int wC = 0; wC < ${r}; wC++) {\n            int wCPerm = ${r} - 1 - wC;\n\n            float dyC = float(dyCCorner + wC) / strides[1];\n            bool idyCVal = (dyC >= 0.0) && (dyC < ${t.outWidth}.0)\n              && (fract(dyC) == 0.0);\n            int idyC = int(dyC);\n\n            float dyC2 = float(dyCCorner + wC + 1) / strides[1];\n            bool idyCVal2 = (dyC2 >= 0.0) && (dyC2 < ${t.outWidth}.0)\n              && (fract(dyC2) == 0.0);\n            int idyC2 = int(dyC2);\n\n            if (idyCVal && idyCVal2) {\n              for (int d2 = 0; d2 < ${t.outChannels}; d2 += 2) {\n                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);\n                vec4 dySample = getDy(batch, idyR, idyC, d2);\n                vec4 dySample2 = (idyC / 2 == idyC2 / 2) ?\n                  dySample : getDy(batch, idyR, idyC2, d2);\n\n                vec2 dyValue = mod(float(idyC), 2.) == 0. ?\n                  dySample.xy : dySample.zw;\n                result.xy += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n\n                dyValue = mod(float(idyC2), 2.) == 0. ?\n                  dySample2.xy : dySample2.zw;\n                result.zw += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n              }\n            } else if (idyCVal) {\n              for (int d2 = 0; d2 < ${t.outChannels}; d2 += 2) {\n                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);\n                vec4 dySample = getDy(batch, idyR, idyC, d2);\n                vec2 dyValue = mod(float(idyC), 2.) == 0. ?\n                  dySample.xy : dySample.zw;\n                result.xy += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n              }\n            } else if (idyCVal2) {\n              for (int d2 = 0; d2 < ${t.outChannels}; d2 += 2) {\n                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);\n                vec4 dySample = getDy(batch, idyR, idyC2, d2);\n                vec2 dyValue = mod(float(idyC2), 2.) == 0. ?\n                  dySample.xy : dySample.zw;\n                result.zw += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n              }\n            }\n          }\n        }\n        setOutput(result);\n      }\n    `}}const iIe={kernelName:__,backendName:"webgl",kernelFunc:function sIe(n){const{inputs:t,backend:e,attrs:r}=n,{dy:s,filter:i}=t,{inputShape:o,strides:a,pad:u,dataFormat:c,dimRoundingMode:p}=r,m=fl(c),y=ls(o,i.shape,a,1,u,p,!1,m);if(De().getBool("WEBGL_PACK")&&"channelsLast"===m){const _=[[y.strideHeight,y.strideWidth]],w=new rIe(y);return e.runWebGLProgram(w,[s,i],"float32",_)}{const _=new QCe(y);return e.runWebGLProgram(_,[s,i],"float32")}}},aIe={kernelName:v_,backendName:"webgl",kernelFunc:function oIe(n){const{inputs:t,backend:e,attrs:r}=n,{x:s,filter:i}=t,{strides:o,pad:a,dilations:u}=r,c=cu(s.shape,i.shape,o,u,a),p=new qCe(c);return e.runWebGLProgram(p,[s,i],"float32")}},uIe={kernelName:aC,backendName:"webgl",kernelFunc:function lIe(n){const{inputs:t,backend:e,attrs:r}=n,{x:s,dy:i}=t,{strides:o,pad:a,filterShape:u}=r,c=cu(s.shape,u,o,1,a),p=new JCe(c);return e.runWebGLProgram(p,[s,i],"float32")}},dIe={kernelName:lC,backendName:"webgl",kernelFunc:function cIe(n){const{inputs:t,backend:e,attrs:r}=n,{dy:s,filter:i}=t,{pad:o,strides:a,inputShape:u}=r,c=cu(u,i.shape,a,1,o),p=new eIe(c);return e.runWebGLProgram(p,[s,i],"float32")}},fIe=bn({opSnippet:Yh+"\n  return cos(x);\n",packedOpSnippet:`\n  vec4 result = cos(x);\n  bvec4 isNaN = isnan(x);\n  ${zc}\n  return result;\n`}),mIe={kernelName:Jf,backendName:"webgl",kernelFunc:fIe},gIe=bn({opSnippet:"\n  float e2x = exp(-x);\n  return (e2x + 1.0 / e2x) / 2.0;\n"}),yIe={kernelName:em,backendName:"webgl",kernelFunc:gIe};class bIe{constructor(t,e,r,s,i){this.variableNames=["Image","Boxes","BoxInd"],this.outputShape=[];const[o,a,u,c]=t,[p]=e,[m,y]=r;this.outputShape=[p,m,y,c];const _="bilinear"===s?1:0,[w,T]=[a-1+".0",u-1+".0"],[I,O,M]=m>1?[""+(a-1)/(m-1),"(y2-y1) * height_ratio",`y1*${w} + float(y)*(height_scale)`]:["0.0","0.0",`0.5 * (y1+y2) * ${w}`],[V,z,G]=y>1?[""+(u-1)/(y-1),"(x2-x1) * width_ratio",`x1*${T} + float(x)*(width_scale)`]:["0.0","0.0",`0.5 * (x1+x2) * ${T}`];this.userCode=`\n      const float height_ratio = float(${I});\n      const float width_ratio = float(${V});\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int y = coords[1];\n        int x = coords[2];\n        int d = coords[3];\n\n        // get box vals\n        float y1 = getBoxes(b,0);\n        float x1 = getBoxes(b,1);\n        float y2 = getBoxes(b,2);\n        float x2 = getBoxes(b,3);\n\n        // get image in batch index\n        int bInd = round(getBoxInd(b));\n        if(bInd < 0 || bInd >= ${o}) {\n          return;\n        }\n\n        float height_scale = ${O};\n        float width_scale = ${z};\n\n        float in_y = ${M};\n        if( in_y < 0.0 || in_y > ${w} ) {\n          setOutput(float(${i}));\n          return;\n        }\n        float in_x = ${G};\n        if( in_x < 0.0 || in_x > ${T} ) {\n          setOutput(float(${i}));\n          return;\n        }\n\n        vec2 sourceFracIndexCR = vec2(in_x,in_y);\n        if(${_} == 1) {\n          // Compute the four integer indices.\n          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);\n          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));\n\n          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);\n          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);\n          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);\n          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);\n\n          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);\n\n          float top = topLeft + (topRight - topLeft) * fracCR.x;\n          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;\n          float newValue = top + (bottom - top) * fracCR.y;\n          setOutput(newValue);\n        } else {\n          // Compute the coordinators of nearest neighbor point.\n          ivec2 sourceNearestCR = ivec2(floor(\n            sourceFracIndexCR + vec2(0.5,0.5)));\n          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);\n          setOutput(newValue);\n        }\n      }\n    `}}const _Ie={kernelName:cC,backendName:"webgl",kernelFunc:n=>{const{inputs:t,backend:e,attrs:r}=n,{image:s,boxes:i,boxInd:o}=t,{cropSize:a,method:u,extrapolationValue:c}=r,p=new bIe(s.shape,i.shape,a,u,c);return e.runWebGLProgram(p,[s,i,o],"float32")}};var ku=(()=>((ku=ku||{}).Prod="*",ku.Sum="+",ku))();class Mj{constructor(t,e,r,s){this.op=t,this.outputShape=e,this.variableNames=["x"],this.customUniforms=[{name:"index",type:"float"}];const i=this.outputShape.length,a=r?this.op===ku.Prod?"1.0":"0.0":`getX(${Pj(i,"coords",this.op)})`,u=this.outputShape[this.outputShape.length-1];let c="",p="";r?(c=s?"end != "+(u-1):"end != 0",p=s?"end + 1":"end - 1"):(c=s?`end + pow2 < ${u}`:"end >= pow2",p=s?"end + pow2":"end - pow2"),this.userCode=`\n      void main() {\n        ${Vn(i)} coords = getOutputCoords();\n        int end = ${Fj(i,"coords",this.op)};\n        float val = ${a};\n        int pow2 = int(pow(2.0, index));\n        if (${c}) {\n          int idx = ${p};\n          ${Fj(i,"coords",this.op)} = idx;\n          val ${this.op}= getX(${Pj(i,"coords",this.op)});\n        }\n        setOutput(val);\n      }\n    `}}function Pj(n,t,e){if(1===n)return`${t}`;if(2===n)return`${t}.x, ${t}.y`;if(3===n)return`${t}.x, ${t}.y, ${t}.z`;if(4===n)return`${t}.x, ${t}.y, ${t}.z, ${t}.w`;throw new Error(`Cumulative ${e} for rank ${n} is not yet supported`)}function Fj(n,t,e){if(1===n)return`${t}`;if(2===n)return`${t}.y`;if(3===n)return`${t}.z`;if(4===n)return`${t}.w`;throw new Error(`Cumulative ${e} for rank ${n} is not yet supported`)}function $j(n,t,e,r,s,i){const o=t.shape.length,a=ur([r],o);let u=t;null!=a&&(u=Hs({inputs:{x:t},backend:e,attrs:{perm:a}}));const c=Nr(1,o)[0];if(c!==o-1)throw new Error(`WebGL cumprod shader expects an inner-most axis=${t.shape.length-1} but got axis=${r}`);const p=u.shape[c];let m=Ai({inputs:{x:u},backend:e});for(let y=0;y<=Math.ceil(Math.log2(p))-1;y++){const _=new Mj(n,u.shape,!1,i),T=m;m=e.runWebGLProgram(_,[m],m.dtype,[[y]]),e.disposeIntermediateTensorInfo(T)}if(s){const y=new Mj(n,u.shape,s,i),_=m;m=e.runWebGLProgram(y,[m],m.dtype),e.disposeIntermediateTensorInfo(_)}if(null!=a){const _=Hs({inputs:{x:m},backend:e,attrs:{perm:pu(a)}});return e.disposeIntermediateTensorInfo(m),e.disposeIntermediateTensorInfo(u),_}return m}const wIe={kernelName:uC,backendName:"webgl",kernelFunc:function vIe(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{axis:i,exclusive:o,reverse:a}=r;return $j(ku.Prod,s,e,i,o,a)}},TIe={kernelName:w_,backendName:"webgl",kernelFunc:function xIe(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{axis:i,exclusive:o,reverse:a}=r;return $j(ku.Sum,s,e,i,o,a)}},CIe={kernelName:dC,backendName:"webgl",kernelFunc:function SIe(n){const{inputs:t,backend:e,attrs:r}=n,{x:s,weights:i}=t,{size:o,binaryOutput:a}=r;if(1===s.shape.length){const u=e.readSync(s.dataId),c=e.readSync(i.dataId),p=nj(u,c,i.dtype,i.shape,o);return e.makeTensorInfo([o],i.dtype,p)}if(2===s.shape.length){const u=e.bufferSync(s),c=e.bufferSync(i),p=PTe(u,c,o,a);return e.makeTensorInfo(p.shape,i.dtype,p.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${s.shape.length}.`)}};class IIe{constructor(t,e,r){this.variableNames=["x"],this.outputShape=[],this.outputShape=t,this.blockSize=e,this.dataFormat=r,this.userCode=`\n    void main() {\n      ivec4 coords = getOutputCoords();\n      int b = coords[0];\n      int h = ${this.getHeightCoordString()};\n      int w = ${this.getWidthCoordString()};\n      int d = ${this.getDepthCoordString()};\n\n      int in_h = h / ${e};\n      int offset_h = imod(h, ${e});\n      int in_w = w / ${e};\n      int offset_w = imod(w, ${e});\n      int offset_d = (offset_h * ${e} + offset_w) *\n        ${this.getOutputDepthSize()};\n      int in_d = d + offset_d;\n\n      float result = ${this.getInputSamplingString()};\n      setOutput(result);\n    }\n  `}getHeightCoordString(){return"NHWC"===this.dataFormat?"coords[1]":"coords[2]"}getWidthCoordString(){return"NHWC"===this.dataFormat?"coords[2]":"coords[3]"}getDepthCoordString(){return"NHWC"===this.dataFormat?"coords[3]":"coords[1]"}getOutputDepthSize(){return"NHWC"===this.dataFormat?this.outputShape[3]:this.outputShape[1]}getInputSamplingString(){return"NHWC"===this.dataFormat?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}}const DIe={kernelName:hC,backendName:"webgl",kernelFunc:function EIe(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{blockSize:i,dataFormat:o}=r,a=s.shape[0],m=("NHWC"===o?s.shape[1]:s.shape[2])*i,y=("NHWC"===o?s.shape[2]:s.shape[3])*i,_=("NHWC"===o?s.shape[3]:s.shape[1])/(i*i),T=new IIe("NHWC"===o?[a,m,y,_]:[a,_,m,y],i,o);return e.runWebGLProgram(T,[s],s.dtype)}};class Lj{constructor(t,e=!1,r=null,s=!1,i=!1){this.variableNames=["x","W"],this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=t.outShape,this.enableShapeUniforms=Rs(this.outputShape.length);const o=t.filterHeight,a=t.filterWidth,u=t.outChannels/t.inChannels;let c="",p="";r&&(c=s?`float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ${r}\n        }`:i?`float activation(float a) {\n          float b = getLeakyreluAlphaAtOutCoords();\n          ${r}\n        }`:`\n          float activation(float x) {\n            ${r}\n          }\n        `,p="result = activation(result);");const m=e?"result += getBiasAtOutCoords();":"";e&&this.variableNames.push("bias"),s&&this.variableNames.push("preluActivationWeights"),i&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n      ${c}\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / ${u};\n        int q = d2 - d1 * ${u};\n\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.\n        for (int wR = 0; wR < ${o}; wR++) {\n          int xR = xRCorner + wR * dilations[0];\n\n          if (xR < 0 || xR >= inDims[0]) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${a}; wC++) {\n            int xC = xCCorner + wC * dilations[1];\n\n            if (xC < 0 || xC >= inDims[1]) {\n              continue;\n            }\n\n            float xVal = getX(batch, xR, xC, d1);\n            float wVal = getW(wR, wC, d1, q);\n            dotProd += xVal * wVal;\n          }\n        }\n\n        float result = dotProd;\n        ${m}\n        ${p}\n        setOutput(result);\n      }\n    `}}class Vj{constructor(t,e=!1,r=null,s=!1,i=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=t.outShape,this.enableShapeUniforms=Rs(this.outputShape.length);const o=t.outChannels/t.inChannels,a=t.padInfo.left,u=t.strideWidth,c=t.dilationWidth,p=t.filterHeight,m=t.filterWidth,y=m;let _="\n      int xR; int xC; int xCOffset;\n      vec4 wTexel; vec4 previous; vec4 final;";for(let O=0;O<m;O++)_+=`\n          vec4 xTexelC${2*O};\n          int xTexelC${2*O}Ready;\n          vec4 xTexelC${2*O+1};\n          int xTexelC${2*O+1}Ready;\n          vec4 xC${O};`;_+=`\n    for (int r = 0; r < ${p}; r++) {\n      `;for(let O=0;O<m;O++)_+=`\n          xTexelC${2*O} = vec4(0.0);\n          xTexelC${2*O}Ready = 0;\n          xTexelC${2*O+1} = vec4(0.0);\n          xTexelC${2*O+1}Ready = 0;\n          xC${O} = vec4(0.0);`;_+="\n        xR = xRCorner + r * dilations[0];\n        if (xR >=0 && xR < inDims[0]) {\n      ";for(let O=0;O<(y+1)/2;O++){const M=2*O;if(_+=`\n          xC = xCCorner + ${M*c};\n          `,1===u){if(M<m&&(a%2==1?(_+=`\n                xCOffset = xC + 1;\n                if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${M}Ready == 0) {\n                  xTexelC${M} = getX(batch, xR, xCOffset, d1);\n\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC${M}.zw = vec2(0.0);\n                  }\n                  xTexelC${M}Ready = 1;\n                }\n              `,_+=1===c&&M>0?`\n                xC${M} = vec4(xTexelC${M-2}.zw, xTexelC${M}.xy);\n                `:`\n                  xCOffset = xC + 1 - 2;\n\n                  if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                    previous = getX(batch, xR, xCOffset, d1);\n\n                    // Need to manually clear unused channels in case\n                    // we're reading from recycled texture.\n                    if (xCOffset + 1 >= inDims[1]) {\n                      previous.zw = vec2(0.0);\n                    }\n\n                    xC${M} = vec4(previous.zw, xTexelC${M}.xy);\n                  } else {\n                    xC${M} = vec4(0.0, 0.0, xTexelC${M}.xy);\n                  }\n                  `):_+=`\n                if (xC >= 0 && xC < inDims[1] && xTexelC${M}Ready == 0) {\n                  xTexelC${M} = getX(batch, xR, xC, d1);\n                  if (xC + 1 >= inDims[1]) {\n                    xTexelC${M}.zw = vec2(0.0);\n                  }\n                  xTexelC${M}Ready = 1;\n                }\n\n                xC${M} = xTexelC${M};\n                `,M+1<m)){const V=a%2==0?G1(c):c;c%2==0&&a%2==1||c%2!=0&&a%2!=1?(_+=`\n                  xCOffset = xC + imod(pads[1], 2) + ${V};\n\n                  if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${M+1}Ready == 0) {\n                    xTexelC${M+1} = getX(batch, xR, xCOffset, d1);\n\n                    // Need to manually clear unused channels in case\n                    // we're reading from recycled texture.\n                    if (xCOffset + 1 >= inDims[1]) {\n                      xTexelC${M+1}.zw = vec2(0.0);\n                    }\n                    xTexelC${M+1}Ready = 1;\n                  }\n                  `,_+=c>1?`\n                    xCOffset -= 2;\n                    if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                     previous = getX(batch, xR, xCOffset, d1);\n                     xC${M+1} = vec4(previous.zw, xTexelC${M+1}.xy);\n                    } else {\n                     xC${M+1} = vec4(0.0, 0.0, xTexelC${M+1}.xy);\n                    }\n                    `:`\n                    xC${M+1} = vec4(xTexelC${M}.zw, xTexelC${M+1}.xy);\n                    `):_+=1===V?`\n                    xC${M+1} = xTexelC${M};\n                    `:`\n                    xCOffset = xC + ${V};\n\n                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${M+1}Ready == 0) {\n                      xTexelC${M+1} = getX(batch, xR, xCOffset, d1);\n                      if (xCOffset + 1 >= inDims[1]) {\n                        xTexelC${M+1}.zw = vec2(0.0);\n                      }\n                      xTexelC${M+1}Ready = 1;\n                    }\n\n                    xC${M+1} = xTexelC${M+1};\n                    `}}else M<m&&(a%2==1?(_+=`\n                xCOffset = xC + 1 - strides[1];\n                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${M}Ready == 0) {\n                  xTexelC${M} = getX(batch, xR, xCOffset, d1);\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC${M}.zw = vec2(0.0);\n                  }\n                  xTexelC${M}Ready = 1;\n                }\n\n                if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${M+1}Ready == 0) {\n                  xTexelC${M+1} = getX(batch, xR, xC + 1, d1);\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xC + 2 >= inDims[1]) {\n                    xTexelC${M+1}.zw = vec2(0.0);\n                  }\n                  xTexelC${M+1}Ready = 1;\n                }\n\n                xC${M} = vec4(xTexelC${M}.zw, xTexelC${M+1}.zw);\n              `,M+1<m&&(_+=`\n                  final = vec4(0.0);\n                  xCOffset = xC + 1 + strides[1];\n                  if(xCOffset >= 0 && xCOffset < inDims[1]) {\n                    final = getX(batch, xR, xCOffset, d1);\n                  }\n                  xC${M+1} = vec4(xTexelC${M+1}.xy, final.xy);\n                `)):(_+=`\n                if(xC >= 0 && xC < inDims[1] && xTexelC${M}Ready == 0) {\n                  xTexelC${M} = getX(batch, xR, xC, d1);\n                  if (xC + 1 >= inDims[1]) {\n                    xTexelC${M}.zw = vec2(0.0);\n                  }\n                  xTexelC${M}Ready = 1;\n                }\n\n                xCOffset = xC + strides[1];\n                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${M+1}Ready == 0) {\n                  xTexelC${M+1} = getX(batch, xR, xCOffset, d1);\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC${M+1}.zw = vec2(0.);\n                  }\n                  xTexelC${M+1}Ready = 1;\n                }\n\n                xC${M} = vec4(\n                  xTexelC${M}.xy, xTexelC${M+1}.xy);\n              `,M+1<m&&(_+=`\n                  xC${M+1} = vec4(xTexelC${M}.zw, xTexelC${M+1}.zw);\n                `)));M<m&&(_+=`\n            wTexel = getW(r, ${M}, d1, q);\n            dotProd += xC${M} * vec4(wTexel.xz, wTexel.xz);\n          `,M+1<m&&(_+=`\n              wTexel = getW(r, ${M+1}, d1, q);\n              dotProd += xC${M+1} * vec4(wTexel.xz, wTexel.xz);\n            `))}_+="\n    }\n  ",_+="\n      }\n    ";let w="",T="";r&&(w=s?`vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ${r}\n        }`:i?`vec4 activation(vec4 a) {\n          vec4 b = getLeakyreluAlphaAtOutCoords();\n          ${r}\n        }`:`vec4 activation(vec4 x) {\n          ${r}\n        }`,T="result = activation(result);");const I=e?"result += getBiasAtOutCoords();":"";e&&this.variableNames.push("bias"),s&&this.variableNames.push("preluActivationWeights"),i&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n      ${w}\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / ${o};\n        int q = d2 - d1 * ${o};\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.\n        vec4 dotProd = vec4(0.000000000000001);\n\n        ${_}\n\n        vec4 result = dotProd - vec4(0.000000000000001);\n        ${I}\n        ${T}\n        setOutput(result);\n      }\n    `}}const kIe={kernelName:x_,backendName:"webgl",kernelFunc:function AIe(n){const{inputs:t,backend:e,attrs:r}=n,{x:s,filter:i}=t,{strides:o,pad:a,dilations:u,dimRoundingMode:c}=r;let p=u;null==p&&(p=[1,1]),J(vs(o,p),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${o} and dilations '${p}'`);const m=ls(s.shape,i.shape,o,p,a,c,!0);let y;return y=De().getBool("WEBGL_PACK_DEPTHWISECONV")&&m.strideWidth<=2&&m.outChannels/m.inChannels==1?new Vj(m):new Lj(m),e.runWebGLProgram(y,[s,i],"float32",[[m.padInfo.top,m.padInfo.left],[m.strideHeight,m.strideWidth],[m.dilationHeight,m.dilationWidth],[m.inHeight,m.inWidth]])}};class NIe{constructor(t){this.variableNames=["x","dy"],this.outputShape=t.filterShape,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int dm = coords.w;\n        int d2 = d1 * ${t.outChannels/t.inChannels} + dm;\n\n        float dotProd = 0.0;\n\n        // TO DO: Vec4 over the batch size\n        for (int b = 0; b < ${t.batchSize}; b++) {\n          for (int yR = 0; yR < ${t.outHeight}; yR++) {\n            int xR = wR + yR * ${t.strideHeight} - ${t.padInfo.top};\n\n            if (xR < 0 || xR >= ${t.inHeight}) {\n              continue;\n            }\n\n            for (int yC = 0; yC < ${t.outWidth}; yC++) {\n              int xC = wC + yC * ${t.strideWidth} - ${t.padInfo.left};\n\n              if (xC < 0 || xC >= ${t.inWidth}) {\n                continue;\n              }\n\n              float dyValue = getDy(b, yR, yC, d2);\n              float xValue = getX(b, xR, xC, d1);\n              dotProd += (xValue * dyValue);\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class OIe{constructor(t){this.variableNames=["dy","W"],this.outputShape=t.inShape;const e=t.filterHeight,r=t.filterWidth,u=t.outChannels/t.inChannels;this.userCode=`\n      const ivec2 pads = ivec2(${e-1-t.padInfo.top}, ${r-1-t.padInfo.left});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[3];\n        ivec2 dyCorner = coords.yz - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        float dotProd = 0.0;\n\n        for (int wR = 0; wR < ${e}; wR++) {\n          float dyR = float(dyRCorner + wR) / ${t.strideHeight}.0;\n\n          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ${e} - 1 - wR;\n\n          for (int wC = 0; wC < ${r}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${t.strideWidth}.0;\n\n            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ${r} - 1 - wC;\n\n            // TO DO: Vec4 over the channelMul\n            for (int dm = 0; dm < ${u}; dm++) {\n              int d2 = d1 * ${u} + dm;\n              float xValue = getDy(batch, idyR, idyC, d2);\n              float wValue = getW(wRPerm, wCPerm, d1, dm);\n              dotProd += xValue * wValue;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const MIe={kernelName:pC,backendName:"webgl",kernelFunc:function RIe(n){const{inputs:t,backend:e,attrs:r}=n,{x:s,dy:i}=t,{strides:o,dilations:a,pad:u,dimRoundingMode:c,filterShape:p}=r,m=ls(s.shape,p,o,a,u,c,!0),y=new NIe(m);return e.runWebGLProgram(y,[s,i],"float32")}},FIe={kernelName:fC,backendName:"webgl",kernelFunc:function PIe(n){const{inputs:t,backend:e,attrs:r}=n,{dy:s,filter:i}=t,{strides:o,dilations:a,pad:u,dimRoundingMode:c,inputShape:p}=r,m=ls(p,i.shape,o,a,u,c,!0),y=new OIe(m);return e.runWebGLProgram(y,[s,i],"float32")}};class $Ie{constructor(t){this.variableNames=["X"],this.outputShape=[t,t],this.userCode="\n      void main() {\n          ivec2 coords = getOutputCoords();\n          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;\n          setOutput(val);\n      }\n    "}}const VIe={kernelName:mC,backendName:"webgl",kernelFunc:function LIe(n){const{inputs:t,backend:e}=n,{x:r}=t,s=[...r.shape,...r.shape],i=Fe(r.shape),o=ut({inputs:{x:r},backend:e,attrs:{shape:[i]}}),a=new $Ie(i),u=e.runWebGLProgram(a,[o],o.dtype),c=ut({inputs:{x:u},backend:e,attrs:{shape:s}});return e.disposeIntermediateTensorInfo(o),e.disposeIntermediateTensorInfo(u),c}};class BIe{constructor(t){this.variableNames=["x","W"],this.outputShape=t.outShape;const{inHeight:e,inWidth:r,padInfo:s,strideHeight:i,strideWidth:o,filterHeight:a,filterWidth:u,dilationHeight:c,dilationWidth:p}=t,{top:m,left:y}=s;this.userCode=`\n      const ivec2 strides = ivec2(${i}, ${o});\n      const ivec2 pads = ivec2(${m}, ${y});\n      const float neg_infinity = -3.4e38;\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.w;\n        ivec2 outTopLeftCorner =\n            coords.yz * strides - pads;\n        int hBeg = outTopLeftCorner.x;\n        int wBeg = outTopLeftCorner.y;\n\n        float curVal = neg_infinity;\n        for (int h = 0; h < ${a}; h++) {\n          int hIn = hBeg + h * ${c};\n\n          if (hIn >= 0 && hIn < ${e}) {\n            for (int w = 0; w < ${u}; w++) {\n              int wIn = wBeg + w * ${p};\n\n              if (wIn >= 0 && wIn < ${r}) {\n                float xVal = getX(batch, hIn, wIn, d1);\n                float wVal = getW(h, w, d1);\n\n                float val = xVal + wVal;\n                if (val > curVal) {\n                  curVal = val;\n                }\n              }\n            }\n          }\n        }\n\n        float result = curVal;\n        setOutput(result);\n      }\n    `}}const UIe={kernelName:T_,backendName:"webgl",kernelFunc:function zIe(n){const{inputs:t,backend:e,attrs:r}=n,{x:s,filter:i}=t,{strides:o,pad:a,dilations:u}=r,c=jm(s.shape,i.shape,o,a,"NHWC",u);let p;const m=new BIe(c);p=e.runWebGLProgram(m,[s,i],"float32");const y=ut({inputs:{x:p},backend:e,attrs:{shape:c.outShape}});return e.disposeIntermediateTensorInfo(p),y}},GIe={kernelName:bC,backendName:"webgl",kernelFunc:function jIe(n){const{inputs:t,backend:e,attrs:r}=n,{equation:s}=r,i=t,{allDims:o,summedDims:a,idDims:u}=YE(s,i.length);QE(o.length,u,i);const{path:c,steps:p}=JE(a,u),m=p.length;let y=null,_=o.length;const w=[];for(let T=0;T<m;++T){for(const I of p[T]){const{permutationIndices:O,expandDims:M}=ZE(_,u[I]);let V;eD(O)?V=i[I]:(V=Hs({inputs:{x:i[I]},backend:e,attrs:{perm:O}}),w.push(V));const z=V.shape.slice();for(let G=0;G<M.length;++G)z.splice(M[G],0,1);hn(V.shape,z)||(V=ut({inputs:{x:V},backend:e,attrs:{shape:z}}),w.push(V)),null===y?y=V:(y=PA({inputs:{a:V,b:y},backend:e}),w.push(y))}T<m-1&&(c[T]>=0&&(y=K0({inputs:{x:y},backend:e,attrs:{axis:c[T]-(o.length-_),keepDims:!1}}),w.push(y)),_--)}for(const T of w)T!==y&&e.disposeIntermediateTensorInfo(T);return y}},WIe=bn({opSnippet:"return (x >= 0.0) ? x : (exp(x) - 1.0);",packedOpSnippet:"\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n"}),HIe={kernelName:nm,backendName:"webgl",kernelFunc:WIe},XIe={kernelName:_C,backendName:"webgl",kernelFunc:n=>{const{inputs:t,backend:e}=n,{dy:r,y:s}=t,i=De().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Eg("\n  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));\n  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));\n",r.shape,s.shape):new Xh("return (b >= 0.0) ? a : a * (b + 1.0);",r.shape,s.shape);return e.runWebGLProgram(i,[r,s],r.dtype)}},YIe=Ts({opSnippet:"return float(a == b);",packedOpSnippet:"\n  return vec4(equal(a, b));\n",dtype:"bool",cpuKernelImpl:VTe}),ZIe={kernelName:S_,backendName:"webgl",kernelFunc:YIe},JIe=bn({opSnippet:`\n  // Error function is calculated approximately with elementary function.\n  // See "Handbook of Mathematical Functions with Formulas,\n  // Graphs, and Mathematical Tables", Abramowitz and Stegun.\n  float p = ${UE};\n  float a1 = ${jE};\n  float a2 = ${GE};\n  float a3 = ${WE};\n  float a4 = ${HE};\n  float a5 = ${qE};\n\n  float sign = sign(x);\n  x = abs(x);\n  float t = 1.0 / (1.0 + p * x);\n  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));\n`}),eEe={kernelName:rm,backendName:"webgl",kernelFunc:JIe},Bj=bn({opSnippet:Yh+"\n  return exp(x);\n",packedOpSnippet:"\n  vec4 result = exp(x);\n  bvec4 isNaN = isnan(x);\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",cpuKernelImpl:BTe,dtype:"float32"}),nEe={kernelName:sm,backendName:"webgl",kernelFunc:Bj};function VA(n){const{inputs:t,attrs:e,backend:r}=n,{dim:s}=e,{input:i}=t,o=i.shape.length,a=i.shape.slice();let u=s;return s<0&&(J(-(o+1)<=s,()=>`Axis must be in the interval [${-(o+1)}, ${o}]`),u=o+s+1),a.splice(u,0,1),ut({inputs:{x:i},backend:r,attrs:{shape:a}})}const rEe={kernelName:C_,backendName:"webgl",kernelFunc:VA},zj="return exp(x) - 1.0;",sEe=bn({opSnippet:zj,packedOpSnippet:zj,cpuKernelImpl:zTe}),iEe={kernelName:im,backendName:"webgl",kernelFunc:sEe};class Uj{constructor(t,e,r){this.variableNames=["real","imag"];const s=e[1];this.outputShape=e;const i=r?`2.0 * ${Math.PI}`:`-2.0 * ${Math.PI}`,o=r?`${s}.0`:"1.0";let a;if("real"===t)a="return real * expR - imag * expI;";else{if("imag"!==t)throw new Error(`FFT component must be either "real" or "imag", got ${t}.`);a="return real * expI + imag * expR;"}this.userCode=`\n      const float exponentMultiplier = ${i};\n\n      float unaryOpComplex(float real, float expR, float imag, float expI) {\n        ${a}\n      }\n\n      float mulMatDFT(int batch, int index) {\n        float indexRatio = float(index) / float(${s});\n        float exponentMultiplierTimesIndexRatio =\n            exponentMultiplier * indexRatio;\n\n        float result = 0.0;\n\n        for (int i = 0; i < ${s}; i++) {\n          // x = (-2|2 * PI / N) * index * i;\n          float x = exponentMultiplierTimesIndexRatio * float(i);\n          float expR = cos(x);\n          float expI = sin(x);\n          float real = getReal(batch, i);\n          float imag = getImag(batch, i);\n\n          result +=\n              unaryOpComplex(real, expR, imag, expI) / ${o};\n        }\n\n        return result;\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        setOutput(mulMatDFT(coords[0], coords[1]));\n      }\n    `}}function jj(n,t,e){const r=e.texData.get(n.dataId),s=Fe(n.shape),i=n.shape[n.shape.length-1],a=ut({inputs:{x:n},backend:e,attrs:{shape:[s/i,i]}}),u=a.shape,c=new Uj("real",u,t),p=new Uj("imag",u,t),m=[{dataId:r.complexTensorInfos.real.dataId,dtype:r.complexTensorInfos.real.dtype,shape:u},{dataId:r.complexTensorInfos.imag.dataId,dtype:r.complexTensorInfos.imag.dtype,shape:u}],y=e.runWebGLProgram(c,m,"float32"),_=e.runWebGLProgram(p,m,"float32"),w=Au({inputs:{real:y,imag:_},backend:e});e.disposeIntermediateTensorInfo(y),e.disposeIntermediateTensorInfo(_);const T=ut({inputs:{x:w},backend:e,attrs:{shape:n.shape}});return e.disposeIntermediateTensorInfo(a),e.disposeIntermediateTensorInfo(w),T}const aEe={kernelName:"FFT",backendName:"webgl",kernelFunc:function oEe(n){const{inputs:t,backend:e}=n,{input:r}=t;return jj(r,!1,e)}};class lEe{constructor(t,e){this.outputShape=[],this.customUniforms=[{name:"value",type:"float"}],this.variableNames=["x"],this.outputShape=t,this.userCode="\n      void main() {\n        // Input can be obtained from uniform value.\n        setOutput(value);\n      }\n    "}}function Og(n){const{backend:t,attrs:e}=n,{shape:r,value:s}=e;let{dtype:i}=e;if(i=i||uh(s),"string"===i){const o=Ar(i,Fe(r));return o.fill(s),t.makeTensorInfo(r,i,o)}{const o=new lEe(r,s);return t.runWebGLProgram(o,[],i,[[s]])}}const uEe={kernelName:wC,backendName:"webgl",kernelFunc:Og};class cEe{constructor(t){this.variableNames=["Image"],this.outputShape=[];const e=t[2];this.outputShape=t,this.userCode=`\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int x = coords[2];\n\n          int coordX = ${e} - x - 1;\n          float outputValue;\n          if(coordX >= 0 && coordX < ${e}) {\n            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);\n          } else {\n            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);\n          }\n          setOutput(outputValue);\n        }\n    `}}const dEe={kernelName:xC,backendName:"webgl",kernelFunc:({inputs:n,backend:t})=>{const{image:e}=n,r=t,s=new cEe(e.shape);return r.runWebGLProgram(s,[e],e.dtype)}},Gj="return floor(x);",hEe=bn({opSnippet:Gj,packedOpSnippet:Gj,cpuKernelImpl:UTe}),pEe={kernelName:om,backendName:"webgl",kernelFunc:hEe},fEe=Ts({opSnippet:"\n  float s = sign(a) * sign(b);\n  int ia = round(a);\n  int ib = round(b);\n  if (ib != 0) {\n    // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n    return float(idiv(ia, ib, s));\n  } else {\n    return NAN;\n  }\n",packedOpSnippet:"\n  ivec4 ia = round(a);\n  ivec4 ib = round(b);\n  bvec4 cond = notEqual(ib, ivec4(0));\n  ivec4 result = ivec4(0);\n  vec4 s = sign(a) * sign(b);\n\n  // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n  if (cond[0]) {\n    result[0] = idiv(ia[0], ib[0], s[0]);\n  }\n  if (cond[1]) {\n    result[1] = idiv(ia[1], ib[1], s[1]);\n  }\n  if (cond[2]) {\n    result[2] = idiv(ia[2], ib[2], s[2]);\n  }\n  if (cond[3]) {\n    result[3] = idiv(ia[3], ib[3], s[3]);\n  }\n  return vec4(result);\n",dtype:"int32"}),mEe={kernelName:am,backendName:"webgl",kernelFunc:fEe};class gEe{constructor(t){this.variableNames=["A"];const e=Gs(),[r,s]=t;this.outputShape=t,this.userCode=`\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${s}.0, ${r}.0);\n\n        vec4 values = ${e.texture2D}(A, uv);\n        float value;\n        if (depth == 0) {\n          value = values.r;\n        } else if (depth == 1) {\n          value = values.g;\n        } else if (depth == 2) {\n          value = values.b;\n        } else if (depth == 3) {\n          value = values.a;\n        }\n\n        setOutput(floor(value * 255.0 + 0.5));\n      }\n    `}}class yEe{constructor(t){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;const e=Gs(),[r,s]=t;this.outputShape=t,this.userCode=`\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n\n        vec4 result = vec4(0.);\n\n        for(int row=0; row<=1; row++) {\n          for(int col=0; col<=1; col++) {\n            texC = coords[1] + row;\n            depth = coords[2] + col;\n\n            vec2 uv = (vec2(texC, texR) + halfCR) /\n                       vec2(${s}.0, ${r}.0);\n            vec4 values = ${e.texture2D}(A, uv);\n            float value;\n            if (depth == 0) {\n              value = values.r;\n            } else if (depth == 1) {\n              value = values.g;\n            } else if (depth == 2) {\n              value = values.b;\n            } else if (depth == 3) {\n              value = values.a;\n            }\n\n            result[row * 2 + col] = floor(value * 255.0 + 0.5);\n          }\n        }\n\n        ${e.output} = result;\n      }\n    `}}const bEe={kernelName:"FromPixels",backendName:"webgl",kernelFunc:function _Ee(n){const{inputs:t,backend:e,attrs:r}=n;let{pixels:s}=t;const{numChannels:i}=r,o=typeof HTMLVideoElement<"u"&&s instanceof HTMLVideoElement,a=typeof HTMLImageElement<"u"&&s instanceof HTMLImageElement,[u,c]=o?[s.videoWidth,s.videoHeight]:[s.width,s.height],p=[c,u],m=[c,u,i];if(a||o){const T=De().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");(null==Qh||T!==BA)&&(BA=T,Qh=document.createElement("canvas").getContext("2d",{willReadFrequently:BA})),Qh.canvas.width=u,Qh.canvas.height=c,Qh.drawImage(s,0,0,u,c),s=Qh.canvas}const y=e.makeTensorInfo(p,"int32");e.texData.get(y.dataId).usage=Mr.PIXELS,e.gpgpu.uploadPixelDataToTexture(e.getTexture(y.dataId),s);const _=De().getBool("WEBGL_PACK")?new yEe(m):new gEe(m),w=e.runWebGLProgram(_,[y],"int32");return e.disposeData(y.dataId),w}};let Qh,BA=De().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");const wEe={kernelName:dv,backendName:"webgl",kernelFunc:function vEe(n){const{inputs:t,backend:e,attrs:r}=n,{x:s,filter:i,bias:o,preluActivationWeights:a}=t,{strides:u,pad:c,dataFormat:p,dilations:m,dimRoundingMode:y,activation:_,leakyreluAlpha:w}=r,T=fl(p),I=ls(s.shape,i.shape,u,m,c,y,!1,T);let O;const M=[],V=null!=o,z=null!=a,G="leakyrelu"===_,Q=()=>{const oe=[s,i],de=(pe,Te)=>{if("NCHW"===Te&&1===pe.shape.length&&1!==pe.shape[0]){const Ae=ut({inputs:{x:pe},backend:e,attrs:{shape:[pe.shape[0],1,1]}});return M.push(Ae),Ae}return pe};if(V&&oe.push(de(o,p)),z&&oe.push(de(a,p)),G){const pe=e.makeTensorInfo([],"float32",Zl(w,"float32"));oe.push(pe),M.push(pe)}return oe};if(1!==I.filterHeight||1!==I.filterWidth||1!==I.dilationHeight||1!==I.dilationWidth||1!==I.strideHeight||1!==I.strideWidth||"SAME"!==I.padInfo.type&&"VALID"!==I.padInfo.type)if(I.strideWidth<=2&&"channelsLast"===T&&De().getBool("WEBGL_EXP_CONV")){const oe=_?Dg(_,!0):null,de=new Nj(I,V,oe,z,G),pe=[[I.padInfo.top,I.padInfo.left],[I.strideHeight,I.strideWidth],[I.dilationHeight,I.dilationWidth],[I.inHeight,I.inWidth]],Te=Q();O=e.runWebGLProgram(de,Te,"float32",pe)}else if(De().getBool("WEBGL_CONV_IM2COL"))O=Rj({x:s,filter:i,convInfo:I,backend:e,bias:o,activation:_,preluActivationWeights:a,leakyreluAlpha:w});else{const oe=_?Dg(_,!1):null,de=new kj(I,V,oe,z,G),pe=Q();O=e.runWebGLProgram(de,pe,"float32")}else O=Oj({x:s,filter:i,convInfo:I,backend:e,bias:o,activation:_,preluActivationWeights:a,leakyreluAlpha:w});const ne=ut({inputs:{x:O},backend:e,attrs:{shape:I.outShape}});return M.push(O),M.forEach(oe=>e.disposeIntermediateTensorInfo(oe)),ne}},TEe={kernelName:hv,backendName:"webgl",kernelFunc:function xEe(n){const{inputs:t,backend:e,attrs:r}=n,{x:s,filter:i,bias:o,preluActivationWeights:a}=t,{strides:u,pad:c,dilations:p,dimRoundingMode:m,activation:y,leakyreluAlpha:_}=r,w=[];let T=p;null==T&&(T=[1,1]),J(vs(u,T),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${u} and dilations '${T}'`);const I=ls(s.shape,i.shape,u,T,c,m,!0),O=De().getBool("WEBGL_PACK_DEPTHWISECONV")&&I.strideWidth<=2&&I.outChannels/I.inChannels==1,M=y?Dg(y,O):null,V=[s,i],z=null!=o,G=null!=a,Q="leakyrelu"===y;if(z&&V.push(o),G&&V.push(a),Q){const pe=e.makeTensorInfo([],"float32",Zl(_,"float32"));V.push(pe),w.push(pe)}let ne;ne=O?new Vj(I,z,M,G,Q):new Lj(I,z,M,G,Q);const de=e.runWebGLProgram(ne,V,"float32",[[I.padInfo.top,I.padInfo.left],[I.strideHeight,I.strideWidth],[I.dilationHeight,I.dilationWidth],[I.inHeight,I.inWidth]]);return w.forEach(pe=>e.disposeIntermediateTensorInfo(pe)),de}};class SEe{constructor(t,e,r,s){this.sliceDim=t,this.strides=e,this.paramsShape=s,this.variableNames=["x","indices"],this.outputShape=r;const i=Vn(r.length);let o="\n    int index;";for(let a=0;a<this.sliceDim;a++)o+=`\n          index = round(getIndices(coords[0], ${a}));\n          out_of_bounds = out_of_bounds || index < 0;\n          out_of_bounds = out_of_bounds || index >= ${this.paramsShape[a]};\n          flattenIndex += index * ${this.strides[a]};`;this.userCode=`\n         void main() {\n          ${i} coords = getOutputCoords();\n          int flattenIndex = 0;\n          bool out_of_bounds = false;\n\n          ${o}\n\n          setOutput(out_of_bounds ? 0.0 : getX(flattenIndex, coords[1]));\n        }\n      `}}const IEe={kernelName:TC,backendName:"webgl",kernelFunc:function CEe(n){const{inputs:t,backend:e}=n,{params:r,indices:s}=t,i=s.shape,o=i[i.length-1],a=Fe(r.shape),[u,c,p,m]=zE(r,s),y=ut({inputs:{x:s},backend:e,attrs:{shape:[c,o]}}),_=ut({inputs:{x:r},backend:e,attrs:{shape:[Fe(r.shape)/p,p]}});if(e.shouldExecuteOnCPU([r,s])||"string"===r.dtype){const O=e.readSync(s.dataId),M=e.bufferSync(r),V=jTe(O,M,r.dtype,c,o,p,m,r.shape,a);return e.makeTensorInfo(u,r.dtype,V.values)}const w=new SEe(o,m,[c,p],r.shape),T=e.runWebGLProgram(w,[_,y],_.dtype),I=ut({inputs:{x:T},backend:e,attrs:{shape:u}});return e.disposeIntermediateTensorInfo(y),e.disposeIntermediateTensorInfo(_),e.disposeIntermediateTensorInfo(T),I}};class EEe{constructor(t,e){this.variableNames=["A","indices"],this.outputShape=e,this.rank=e.length;const r=Vn(this.rank),s=function DEe(n,t){const e=["resRC.x","resRC.y","resRC.z","resRC.w"],r=[];for(let s=0;s<n.length;s++)r.push(2===s?"index":`${e[s]}`);return r.join()}(t);this.userCode=`\n      void main() {\n        ${r} resRC = getOutputCoords();\n        int index = int(getIndices(resRC.x, resRC.z));\n        float inBounds = (index >= 0) && (index < ${t[2]}) ? 1.0 : 0.0;\n        setOutput(inBounds * getA(${s}));\n      }\n    `}}function Wj(n){const{inputs:t,backend:e,attrs:r}=n,{x:s,indices:i}=t,{axis:o,batchDims:a}=r,u=sn(o,s.shape)[0];if(De().get("DEBUG")){const M=e.readSync(i.dataId),V=s.shape[u];for(let z=0;z<M.length;++z){const G=M[z];J(G<=V-1&&G>=0,()=>`GatherV2: the index value ${G} is not in [0, ${V-1}]`)}}const c=rD(s,i,u,a),p=Fe(i.shape),m=[],y=ut({inputs:{x:s},backend:e,attrs:{shape:[c.batchSize,c.outerSize,c.dimSize,c.sliceSize]}}),_=ut({inputs:{x:i},backend:e,attrs:{shape:[c.batchSize,p/c.batchSize]}});m.push(y),m.push(_);const w=[c.batchSize,c.outerSize,p/c.batchSize,c.sliceSize];if(e.shouldExecuteOnCPU([s,i])||"string"===s.dtype){const M=e.bufferSync(_),V=e.bufferSync(y),z=GTe(V,M,w);return m.forEach(G=>e.disposeIntermediateTensorInfo(G)),e.makeTensorInfo(c.outputShape,z.dtype,z.values)}const T=new EEe(y.shape,w),I=e.runWebGLProgram(T,[y,_],y.dtype);m.push(I);const O=ut({inputs:{x:I},backend:e,attrs:{shape:c.outputShape}});return m.forEach(M=>e.disposeIntermediateTensorInfo(M)),O}const AEe={kernelName:E_,backendName:"webgl",kernelFunc:Wj},kEe=Ts({opSnippet:"return float(a > b);",packedOpSnippet:"\n  return vec4(greaterThan(a, b));\n",cpuKernelImpl:WTe,dtype:"bool"}),NEe={kernelName:D_,backendName:"webgl",kernelFunc:kEe},OEe=Ts({opSnippet:"return float(a >= b);",packedOpSnippet:"\n  return vec4(greaterThanEqual(a, b));\n",dtype:"bool",cpuKernelImpl:HTe}),REe={kernelName:lm,backendName:"webgl",kernelFunc:OEe},PEe={kernelName:SC,backendName:"webgl",kernelFunc:function MEe(n){const{inputs:t,backend:e}=n,{input:r}=t;return jj(r,!0,e)}},FEe=bn({opSnippet:"return float(!isnan(x) && !isinf(x));",dtype:"bool"}),$Ee={kernelName:cm,backendName:"webgl",kernelFunc:FEe},LEe=bn({opSnippet:"return float(isinf(x));",dtype:"bool"}),VEe={kernelName:dm,backendName:"webgl",kernelFunc:LEe},BEe=bn({opSnippet:"return float(isnan(x));",dtype:"bool"}),zEe={kernelName:hm,backendName:"webgl",kernelFunc:BEe},UEe=Ts({opSnippet:"return float(a < b);",packedOpSnippet:"\n  return vec4(lessThan(a, b));\n",cpuKernelImpl:qTe,dtype:"bool"}),jEe={kernelName:k_,backendName:"webgl",kernelFunc:UEe},GEe=Ts({opSnippet:"return float(a <= b);",packedOpSnippet:"\n  return vec4(lessThanEqual(a, b));\n",cpuKernelImpl:KTe,dtype:"bool"}),WEe={kernelName:N_,backendName:"webgl",kernelFunc:GEe},qEe={kernelName:IC,backendName:"webgl",kernelFunc:function HEe(n){const{backend:t,attrs:e}=n,{start:r,stop:s,num:i}=e,o=XTe(r,s,i);return t.makeTensorInfo([o.length],"float32",o)}},XEe=bn({opSnippet:Yh+"\n  return x < 0.0 ? 0./0. : log(x);\n",packedOpSnippet:"\n  vec4 result = log(x);\n  bvec4 isNaN = isnan(x);\n  result.r = isNaN.r ? x.r : (x.r < 0.0 ? 0./0. : result.r);\n  result.g = isNaN.g ? x.g : (x.g < 0.0 ? 0./0. : result.g);\n  result.b = isNaN.b ? x.b : (x.b < 0.0 ? 0./0. : result.b);\n  result.a = isNaN.a ? x.a : (x.a < 0.0 ? 0./0. : result.a);\n  return result;\n",cpuKernelImpl:YTe}),YEe={kernelName:pm,backendName:"webgl",kernelFunc:XEe},QEe=bn({opSnippet:Yh+"\n  return log(1.0 + x);\n"}),JEe={kernelName:fm,backendName:"webgl",kernelFunc:QEe},eDe=Ts({opSnippet:"return float(a >= 1.0 && b >= 1.0);",packedOpSnippet:"\n  return vec4(\n    vec4(greaterThanEqual(a, vec4(1.0))) *\n    vec4(greaterThanEqual(b, vec4(1.0))));\n",dtype:"bool"}),tDe={kernelName:O_,backendName:"webgl",kernelFunc:eDe},nDe=bn({opSnippet:"return float(!(x >= 1.0));"}),rDe={kernelName:R_,backendName:"webgl",kernelFunc:nDe},sDe=Ts({opSnippet:"return float(a >= 1.0 || b >= 1.0);",packedOpSnippet:"\n  return min(\n    vec4(greaterThanEqual(a, vec4(1.0))) +\n    vec4(greaterThanEqual(b, vec4(1.0))),\n    vec4(1.0));\n",dtype:"bool"}),iDe={kernelName:M_,backendName:"webgl",kernelFunc:sDe};class oDe{constructor(t,e,r,s,i){this.variableNames=["x"],this.outputShape=[];const o=e,a=t[3]-1;let u;this.outputShape=t;const c=`float(${r}) + float(${s}) * sum`;u=.5===i?`inversesqrt(${c})`:1===i?`1.0/(${c})`:`exp(log(${c}) * float(-${i}));`,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n        int d = coords[3];\n        float x = getX(b, r, c, d);\n        float sum = 0.0;\n        for (int j = -${o}; j <= ${o}; j++) {\n          int idx = d + j;\n          if (idx >= 0 && idx <=  ${a}) {\n            float z = getX(b, r, c, idx);\n            sum += z * z;\n          }\n        }\n        float val = x * ${u};\n        setOutput(val);\n      }\n    `}}class aDe{constructor(t,e,r,s,i){this.variableNames=["x"],this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0;const o=e,a=t[3]-1;let u;this.outputShape=t;const c=`float(${r}) + float(${s}) * sum`;u=.5===i?`inversesqrt(${c})`:1===i?`1.0/(${c})`:`exp(log(${c}) * float(-${i}));`,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords.x;\n        int r = coords.y;\n        int c = coords.z;\n        int d = coords.w;\n\n        bool hasNextCol = d < ${this.outputShape[3]};\n        bool hasNextRow = c < ${this.outputShape[2]};\n\n        vec4 sum = vec4(0.);\n        vec4 xFragAtOutputCoords = getX(b, r, c, d);\n\n        vec4 xAtOutputCoords = vec4(\n          getChannel(xFragAtOutputCoords, vec2(c, d)),\n          hasNextCol ?\n            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,\n          hasNextRow ?\n            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0\n        );\n\n        int firstChannel = d - ${o};\n        vec2 cache = vec2(0.);\n        if(firstChannel >= 0){\n          vec4 firstChannelFrag = getX(b, r, c, firstChannel);\n          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));\n            if(hasNextRow){\n              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));\n            }\n        }\n\n        ivec2 depth = ivec2(d, d + 1);\n        for (int j = - ${o}; j <= ${o}; j++) {\n          ivec2 idx = depth + j;\n          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));\n          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(${a}));\n\n          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;\n          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;\n\n          if(depthInRange || depthPlusOneInRange){\n            vec4 z = vec4(0.);\n            vec4 xFragAtCurrentDepth;\n            z.xz = cache.xy;\n            if(depthPlusOneInRange && hasNextCol){\n              xFragAtCurrentDepth = idx.y != d ?\n                getX(b, r, c, idx.y) : xFragAtOutputCoords;\n              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));\n              if(hasNextRow){\n                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));\n              }\n            }\n            cache.xy = z.yw;\n            sum += z * z;\n          }\n        }\n        vec4 result = xAtOutputCoords * ${u};\n        setOutput(result);\n      }\n    `}}const lDe={kernelName:P_,backendName:"webgl",kernelFunc:n=>{const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{depthRadius:i,bias:o,alpha:a,beta:u}=r,c=De().getBool("WEBGL_PACK_NORMALIZATION")?new aDe(s.shape,i,o,a,u):new oDe(s.shape,i,o,a,u);return e.runWebGLProgram(c,[s],s.dtype)}};class uDe{constructor(t,e,r,s,i){this.variableNames=["inputImage","outputImage","dy"],this.outputShape=[],this.outputShape=t,this.depth=t[3],this.depthRadius=e,this.bias=r,this.alpha=s,this.beta=i,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n\n        float result = 0.0;\n        for (int d = 0; d < ${this.depth}; ++d) {\n          int depthBegin = int(max(0.0, float(d - ${e})));\n          int depthEnd = int(min(float(${this.depth}),\n              float(d + ${e} + 1)));\n\n          const int MIN_DEPTH_BEGIN = 0;\n          const int MAX_DEPTH_END = ${this.depth};\n\n          float norm = 0.0;\n          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd) {\n              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);\n            }\n            else {\n              break;\n            }\n          }\n\n          norm = float(${s}) * norm + float(${r});\n\n          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd){\n              float dyi = -2.0 * float(${s})\n                * float(${i})\n                * getInputImage(b, r, c, k) * getOutputImage(b, r, c, d)\n                / norm;\n              if (k == d) {\n                dyi += pow(norm, -1.0 * ${i});\n              }\n              if (k == coords[3]) {\n                dyi *= getDy(b, r, c, d);\n                result += dyi;\n              }\n            }\n            else {\n              break;\n            }\n          }\n      }\n      setOutput(result);\n      }\n    `}}const cDe={kernelName:EC,backendName:"webgl",kernelFunc:n=>{const{inputs:t,backend:e,attrs:r}=n,{x:s,y:i,dy:o}=t,{depthRadius:a,bias:u,alpha:c,beta:p}=r,m=new uDe(s.shape,a,u,c,p);return e.runWebGLProgram(m,[s,i,o],s.dtype)}};function Hj(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{reductionIndices:i,keepDims:o}=r,a=s.shape.length,u=sn(i,s.shape);let c=u;const p=ur(c,a),m=null!=p,y=e.shouldExecuteOnCPU([s]);let _=s;if(m){if(y){const V=e.texData.get(_.dataId).values,z=new Array(a);for(let ne=0;ne<z.length;ne++)z[ne]=s.shape[p[ne]];const G=RA(V,s.shape,s.dtype,p,z);_=e.makeTensorInfo(z,s.dtype),e.texData.get(_.dataId).values=G}else _=q0(s,p,e);c=Nr(c.length,a)}ws("max",c,a);const[w,T]=us(_.shape,c);let O,I=w;if(o&&(I=kr(w,u)),y){const V=e.texData.get(_.dataId).values,z=ZTe(V,Fe(T),I,s.dtype);O=e.makeTensorInfo(I,s.dtype),e.texData.get(O.dataId).values=z}else O=function dDe(n,t,e,r){const s=Fe(t),a=ut({inputs:{x:n},attrs:{shape:[Fe(n.shape)/s,s]},backend:r}),u=Uc(a,n.dtype,"max",r),c=ut({inputs:{x:u},attrs:{shape:e},backend:r});return r.disposeIntermediateTensorInfo(a),r.disposeIntermediateTensorInfo(u),c}(_,T,I,e);return m&&e.disposeIntermediateTensorInfo(_),O}const hDe={kernelName:F_,backendName:"webgl",kernelFunc:Hj},mDe=Ts({opSnippet:MA+"\n  return max(a, b);\n",packedOpSnippet:"\n  vec4 result = vec4(max(a, b));\n  bvec4 isNaNA = isnan(a);\n  bvec4 isNaNB = isnan(b);\n  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);\n  "+zc+"\n  return result;\n",cpuKernelImpl:QTe}),gDe={kernelName:mm,backendName:"webgl",kernelFunc:mDe},bDe={kernelName:$_,backendName:"webgl",kernelFunc:function yDe(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t;Cg(s,"maxPool");const{filterSize:i,strides:o,pad:a,dimRoundingMode:u}=r;J(vs(o,1),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${o} and dilations '1'`);const p=vo(s.shape,i,o,1,a,u);if(1===p.filterWidth&&1===p.filterHeight&&hn(p.inShape,p.outShape))return Ai({inputs:{x:s},backend:e});const m=new Ag(p,"max",!1);return e.runWebGLProgram(m,[s],s.dtype)}},vDe={kernelName:L_,backendName:"webgl",kernelFunc:function _De(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{filterSize:i,strides:o,pad:a,dataFormat:u,dimRoundingMode:c}=r,m=pl(s.shape,i,o,[1,1,1],a,c,u),y=new FA(m,"max",!1);return e.runWebGLProgram(y,[s],s.dtype)}};class wDe{constructor(t){this.variableNames=["dy","maxPos"],this.outputShape=t.inShape;const i=t.effectiveFilterHeight,o=t.effectiveFilterWidth;this.userCode=`\n      const ivec2 pads = ivec2(${i-1-t.padInfo.top}, ${o-1-t.padInfo.left});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${i};\n          wR += ${t.dilationHeight}) {\n          float dyR = float(dyRCorner + wR) / ${t.strideHeight}.0;\n\n          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ${o}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${t.strideWidth}.0;\n\n            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n            int maxPosValue = ${i*o-1} - int(getMaxPos(b, idyR, idyC, d));\n\n            // Get the current value, check it against the value from the\n            // position matrix.\n            int curPosValue = wR * ${o} + wC;\n            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n            dotProd += dyValue * mask;\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class xDe{constructor(t){this.variableNames=["dy","maxPos"],this.outputShape=t.inShape;const u=t.effectiveFilterDepth,c=t.effectiveFilterHeight,p=t.effectiveFilterWidth;this.userCode=`\n      const ivec3 pads = ivec3(${u-1-t.padInfo.front}, ${c-1-t.padInfo.top}, ${p-1-t.padInfo.left});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ${u};\n           wD += ${t.dilationDepth}) {\n          float dyD = float(dyDCorner + wD) / ${t.strideDepth}.0;\n\n          if (dyD < 0.0 || dyD >= ${t.outDepth}.0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ${c};\n              wR += ${t.dilationHeight}) {\n            float dyR = float(dyRCorner + wR) / ${t.strideHeight}.0;\n\n            if (dyR < 0.0 || dyR >= ${t.outHeight}.0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ${p};\n                wC += ${t.dilationWidth}) {\n              float dyC = float(dyCCorner + wC) / ${t.strideWidth}.0;\n\n              if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n              int maxPosValue = ${u*c*p-1} -\n                  int(getMaxPos(batch, idyD, idyR, idyC, ch));\n\n              // Get the current value, check it against the value from the\n              // position matrix.\n              int curPosValue =\n                  wD * ${c} * ${p} +\n                  wR * ${p} + wC;\n              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n              dotProd += dyValue * mask;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const SDe={kernelName:AC,backendName:"webgl",kernelFunc:function TDe(n){const{inputs:t,backend:e,attrs:r}=n,{dy:s,input:i}=t,o=i,{filterSize:a,strides:u,pad:c,dimRoundingMode:p}=r,y=pl(o.shape,a,u,[1,1,1],c,p),_=new FA(y,"max",!0),w=e.runWebGLProgram(_,[o],o.dtype),T=new xDe(y),I=e.runWebGLProgram(T,[s,w],o.dtype);return e.disposeIntermediateTensorInfo(w),I}},IDe={kernelName:DC,backendName:"webgl",kernelFunc:function CDe(n){const{inputs:t,backend:e,attrs:r}=n,{dy:s,input:i,output:o}=t,a=i;Cg([i,o],"maxPoolGrad");const{filterSize:u,strides:c,pad:p,dimRoundingMode:m}=r,y=vo(a.shape,u,c,1,p,m),w=new Ag(y,"max",!0),T=e.runWebGLProgram(w,[a],a.dtype),I=new wDe(y),O=e.runWebGLProgram(I,[s,T],a.dtype);return e.disposeIntermediateTensorInfo(T),O}},DDe={kernelName:kC,backendName:"webgl",kernelFunc:({inputs:n,attrs:t,backend:e})=>{const{x:r}=n,{filterSize:s,strides:i,pad:o,includeBatchInIndex:a}=t,u=e;J(4===r.shape.length,()=>`Error in maxPool: input must be rank 4 but got rank ${r.shape.length}.`);const c=[1,1];J(vs(i,c),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${c}'`);const p=vo(r.shape,s,i,c,o),[m,y]=function EDe(n,t,e,r){let s=new Ag(e,"max",!1);const i=r.runWebGLProgram(s,[n],"float32");return s=new Ag(e,"max",!0,!0,t),[i,r.runWebGLProgram(s,[n],"float32")]}(r,a,p,u);return[m,y]}},kDe={kernelName:V_,backendName:"webgl",kernelFunc:({inputs:n,attrs:t,backend:e})=>{const{x:r}=n,{keepDims:s,axis:i}=t,o=e,a=r.shape.length,u=sn(i,r.shape);let c=u;const p=ur(c,a),m=null!=p,y=o.shouldExecuteOnCPU([r]),_=[];let w=r;if(m){if(y){const z=o.texData.get(w.dataId).values,G=new Array(a);for(let oe=0;oe<G.length;oe++)G[oe]=r.shape[p[oe]];const Q=RA(z,r.shape,r.dtype,p,G);w=o.makeTensorInfo(G,r.dtype),o.texData.get(w.dataId).values=Q}else w=q0(r,p,o);_.push(w),c=Nr(c.length,a)}ws("sum",c,a);const[T,I]=us(w.shape,c);let O=T;s&&(O=kr(T,u));const M=function ADe(n,t,e,r){const s=Fe(t),a=ut({inputs:{x:n},attrs:{shape:[Fe(n.shape)/s,s]},backend:r}),u=Uc(a,"float32","mean",r),c=ut({inputs:{x:u},attrs:{shape:e},backend:r});return r.disposeIntermediateTensorInfo(a),r.disposeIntermediateTensorInfo(u),c}(w,I,O,o);for(const V of _)o.disposeIntermediateTensorInfo(V);return M}},ODe={kernelName:B_,backendName:"webgl",kernelFunc:function NDe(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{axis:i,keepDims:o}=r,a=s.shape.length,u=sn(i,s.shape);let c=u;const p=ur(c,a);let m=s;null!=p&&(m=Hs({inputs:{x:s},backend:e,attrs:{perm:p}}),c=Nr(c.length,s.shape.length)),ws("min",c,a);const[y,_]=us(m.shape,c),T=ut({inputs:{x:m},backend:e,attrs:{shape:[-1,Fe(_)]}}),I=Uc(T,T.dtype,"min",e);let O;return O=ut(o?{inputs:{x:I},backend:e,attrs:{shape:kr(y,u)}}:{inputs:{x:I},backend:e,attrs:{shape:y}}),e.disposeIntermediateTensorInfo(T),e.disposeIntermediateTensorInfo(I),null!=p&&e.disposeIntermediateTensorInfo(m),O}},PDe=Ts({opSnippet:MA+"\n  return min(a, b);\n",packedOpSnippet:"\n  vec4 result = vec4(min(a, b));\n  bvec4 isNaNA = isnan(a);\n  bvec4 isNaNB = isnan(b);\n  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);\n  "+zc+"\n  return result;\n",cpuKernelImpl:JTe}),FDe={kernelName:gm,backendName:"webgl",kernelFunc:PDe};class $De{constructor(t,e,r){this.variableNames=["x"],this.outputShape=e.map((p,m)=>p[0]+t[m]+p[1]);const s=t.length,i=Vn(s),o=e.map(p=>p[0]).join(","),a=e.map((p,m)=>p[0]+t[m]).join(","),u=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,s),c="reflect"===r?0:1;this.userCode=1!==s?`\n      ${i} start = ${i}(${o});\n      ${i} end = ${i}(${a});\n\n      void main() {\n        ${i} outC = getOutputCoords();\n        for (int i = 0; i < ${s}; i++) {\n          if (outC[i] < start[i]) {\n            outC[i] = start[i] * 2 - outC[i] - ${c};\n          } else if(outC[i] >= end[i]) {\n            outC[i] = (end[i] - 1) * 2 - outC[i] + ${c};\n          }\n        }\n        ${i} coords = outC - start;\n        setOutput(getX(${u}));\n      }\n    `:`\n        int start = ${o};\n        int end = ${a};\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start) {\n            outC = start * 2 - outC - ${c};\n          } else if(outC >= end) {\n            outC = (end - 1) * 2 - outC + ${c};\n          }\n          setOutput(getX(outC - start));\n        }\n      `}}class LDe{constructor(t,e,r){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e.map((w,T)=>w[0]+t[T]+w[1]);const s=t.length,i=Vn(s),o=e.map(w=>w[0]).join(","),a=e.map((w,T)=>w[0]+t[T]).join(","),u=Ws("rc",s),c=Ws("source",s),p=`${u[s-1]} < ${this.outputShape[s-1]}`,m=1===s?"source":`vec2(${c.slice(-2).join()})`,y="reflect"===r?0:1;let _="";if(1===s){const w=`\n        ${i} source = rc;\n        if (source < start) {\n          source = start * 2 - source - ${y};\n        } else if (source >= end) {\n          source = (end - 1) * 2 - source + ${y};\n        }\n        source -= start;\n      `;_=`\n        ${i} rc = outputLoc;\n        ${w}\n        result[0] = getChannel(getX(${c.join()}), ${m});\n        ${u[s-1]} += 1;\n        if(${p}) {\n          ${w}\n          result[1] = getChannel(getX(${c.join()}), ${m});\n        }\n      `}else{const w=`\n        ${i} source = rc;\n        ${i} lt = ${i}(lessThan(source, start));\n        ${i} gte = ${i}(greaterThanEqual(source, end));\n        ${i} orig = 1 - (lt + gte);\n        source = orig * source +\n                lt * (start * 2 - source - ${y}) +\n                gte * ((end - 1) * 2 - source + ${y});\n        source -= start;\n      `;_=`\n        ${i} rc = outputLoc;\n        ${w}\n        result[0] = getChannel(getX(${c.join()}), ${m});\n        ${u[s-1]} += 1;\n        if(${p}) {\n          ${w}\n          result[1] = getChannel(getX(${c.join()}), ${m});\n        }\n        rc = outputLoc;\n        ${u[s-2]} += 1;\n        if(${u[s-2]} < ${this.outputShape[s-2]}) {\n          ${w}\n          result[2] = getChannel(getX(${c.join()}), ${m});\n          ${u[s-1]} += 1;\n          if(${p}) {\n            ${w}\n            result[3] = getChannel(getX(${c.join()}), ${m});\n          }\n        }\n      `}this.userCode=`\n      const ${i} start = ${i}(${o});\n      const ${i} end = ${i}(${a});\n\n      void main() {\n        ${i} outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        ${_}\n        setOutput(result);\n      }\n    `}}const VDe={kernelName:z_,backendName:"webgl",kernelFunc:({inputs:n,backend:t,attrs:e})=>{const{x:r}=n,{paddings:s,mode:i}=e,o=De().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new LDe(r.shape,s,i):new $De(r.shape,s,i);return t.runWebGLProgram(o,[r],r.dtype)}},UDe=Ts({opSnippet:"if (b == 0.0) return NAN;\n  return mod(a, b);",packedOpSnippet:"\n  vec4 result = mod(a, b);\n  bvec4 isNaN = equal(b, vec4(0.0));\n  "+zc+"\n  return result;\n"}),jDe={kernelName:ym,backendName:"webgl",kernelFunc:UDe};class GDe{constructor(t,e,r){this.variableNames=["probs"],this.customUniforms=[{name:"seed",type:"float"}],this.outputShape=[t,r],this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n\n        float r = random(seed);\n        float cdf = 0.0;\n\n        for (int i = 0; i < ${e-1}; i++) {\n          cdf += getProbs(batch, i);\n\n          if (r < cdf) {\n            setOutput(float(i));\n            return;\n          }\n        }\n\n        // If no other event happened, last event happened.\n        setOutput(float(${e-1}));\n      }\n    `}}const qj=Ts({opSnippet:"\nif (a == b) {\n  return 1.0;\n};\nreturn a / b;",packedOpSnippet:"\n  // vec4 one = vec4(equal(a, b));\n  // return one + (vec4(1.0) - one) * a / b;\n  vec4 result = a / b;\n  if(a.x == b.x) {\n    result.x = 1.;\n  }\n  if(a.y == b.y) {\n    result.y = 1.;\n  }\n  if(a.z == b.z) {\n    result.z = 1.;\n  }\n  if(a.w == b.w) {\n    result.w = 1.;\n  }\n\n  return result;\n",checkOutOfBounds:!0}),WDe={kernelName:tm,backendName:"webgl",kernelFunc:qj},Kj="return a - b;",Xj=Ts({opSnippet:Kj,packedOpSnippet:Kj,supportsComplex:!0,cpuKernelImpl:vSe}),HDe={kernelName:Rm,backendName:"webgl",kernelFunc:Xj};function Yj(n){const{inputs:t,backend:e,attrs:r}=n,{logits:s}=t,{dim:i}=r,o=sn([i],s.shape),a=Hj({inputs:{x:s},backend:e,attrs:{reductionIndices:o,keepDims:!1}}),u=kr(a.shape,o),c=ut({inputs:{x:a},backend:e,attrs:{shape:u}}),p=Xj({inputs:{a:s,b:c},backend:e}),m=Bj({inputs:{x:p},backend:e}),y=K0({inputs:{x:m},backend:e,attrs:{axis:o,keepDims:!1}}),_=ut({inputs:{x:y},backend:e,attrs:{shape:u}}),w=qj({inputs:{a:m,b:_},backend:e});return e.disposeIntermediateTensorInfo(a),e.disposeIntermediateTensorInfo(c),e.disposeIntermediateTensorInfo(p),e.disposeIntermediateTensorInfo(m),e.disposeIntermediateTensorInfo(y),e.disposeIntermediateTensorInfo(_),w}const qDe={kernelName:iv,backendName:"webgl",kernelFunc:Yj},XDe={kernelName:NC,backendName:"webgl",kernelFunc:function KDe(n){const{inputs:t,backend:e,attrs:r}=n,{logits:s}=t,{numSamples:i,seed:o,normalized:a}=r,u=a?s:Yj({inputs:{logits:s},backend:e,attrs:{dim:s.shape.length-1}}),m=new GDe(u.shape[0],u.shape[1],i),_=e.runWebGLProgram(m,[u],"int32",[[o]]);return a||e.disposeIntermediateTensorInfo(u),_}},YDe=Zi+"\n  return -x;\n",JDe={kernelName:U_,backendName:"webgl",kernelFunc:function QDe(n){const{inputs:t,backend:e}=n,{x:r}=t;if(e.shouldExecuteOnCPU([r])){const i=e.texData.get(r.dataId),[o,a]=tSe(i.values,r.shape,r.dtype);return e.makeTensorInfo(a,r.dtype,o)}let s;return s=De().getBool("WEBGL_PACK_UNARY_OPERATIONS")?new Du(r.shape,"\n  vec4 result = -x;\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"):new ja(r.shape,YDe),e.runWebGLProgram(s,[r],r.dtype)}},eAe=AE,nAe={kernelName:OC,backendName:"webgl",kernelFunc:function tAe(n){Ui("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:e,attrs:r}=n,{boxes:s,scores:i}=t,{maxOutputSize:o,iouThreshold:a,scoreThreshold:u}=r,c=e.readSync(s.dataId),p=e.readSync(i.dataId),{selectedIndices:m}=eAe(c,p,o,a,u);return e.makeTensorInfo([m.length],"int32",new Int32Array(m))}},rAe=kE,iAe={kernelName:RC,backendName:"webgl",kernelFunc:function sAe(n){Ui("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:e,attrs:r}=n,{boxes:s,scores:i}=t,{maxOutputSize:o,iouThreshold:a,scoreThreshold:u,padToMaxOutputSize:c}=r,p=e.readSync(s.dataId),m=e.readSync(i.dataId),{selectedIndices:y,validOutputs:_}=rAe(p,m,o,a,u,c);return[e.makeTensorInfo([y.length],"int32",new Int32Array(y)),e.makeTensorInfo([],"int32",new Int32Array([_]))]}},oAe=NE,lAe={kernelName:MC,backendName:"webgl",kernelFunc:function aAe(n){Ui("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:e,attrs:r}=n,{boxes:s,scores:i}=t,{maxOutputSize:o,iouThreshold:a,scoreThreshold:u,softNmsSigma:c}=r,p=e.readSync(s.dataId),m=e.readSync(i.dataId),y=o,_=a,w=u,T=c,{selectedIndices:I,selectedScores:O}=oAe(p,m,y,_,w,T);return[e.makeTensorInfo([I.length],"int32",new Int32Array(I)),e.makeTensorInfo([O.length],"float32",new Float32Array(O))]}};class uAe{constructor(t,e,r,s){this.variableNames=["indices"],this.outputShape=[t,e],this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int index = round(getIndices(coords.x));\n        setOutput(mix(float(${s}), float(${r}),\n                      float(index == coords.y)));\n      }\n    `}}const cAe={kernelName:W_,backendName:"webgl",kernelFunc:n=>{const{inputs:t,backend:e,attrs:r}=n,{indices:s}=t,{dtype:i,depth:o,onValue:a,offValue:u}=r,c=Fe(s.shape),p=new uAe(c,o,a,u),m=ut({inputs:{x:s},backend:e,attrs:{shape:[c]}}),y=e.runWebGLProgram(p,[m],i);e.disposeIntermediateTensorInfo(m);const w=ut({inputs:{x:y},backend:e,attrs:{shape:[...s.shape,o]}});return e.disposeIntermediateTensorInfo(y),w}};function ew(n){const{inputs:t,backend:e}=n,{x:r}=t;if("complex64"===r.dtype){const s=kg({inputs:{input:r},backend:e}),i=ew({inputs:{x:s},backend:e}),o=Q0({inputs:{input:r},backend:e}),a=ew({inputs:{x:o},backend:e}),u=Au({inputs:{real:i,imag:a},backend:e});return e.disposeIntermediateTensorInfo(s),e.disposeIntermediateTensorInfo(i),e.disposeIntermediateTensorInfo(o),e.disposeIntermediateTensorInfo(a),u}return Og({attrs:{shape:r.shape,dtype:r.dtype,value:"string"===r.dtype?"":0},backend:e})}const dAe={kernelName:uv,backendName:"webgl",kernelFunc:ew},hAe={kernelName:G_,backendName:"webgl",kernelFunc:function Zj(n){const{inputs:t,backend:e}=n,{x:r}=t;if("string"===r.dtype)throw new Error("onesLike is not supported under string dtype");if("complex64"===r.dtype){const s=kg({inputs:{input:r},backend:e}),i=Zj({inputs:{x:s},backend:e}),o=Q0({inputs:{input:r},backend:e}),a=ew({inputs:{x:o},backend:e}),u=Au({inputs:{real:i,imag:a},backend:e});return e.disposeIntermediateTensorInfo(s),e.disposeIntermediateTensorInfo(i),e.disposeIntermediateTensorInfo(o),e.disposeIntermediateTensorInfo(a),u}return Og({attrs:{shape:r.shape,dtype:r.dtype,value:1},backend:e})}},fAe={kernelName:H_,backendName:"webgl",kernelFunc:function pAe(n){const{inputs:t,backend:e,attrs:r}=n,{axis:s}=r;if(1===t.length)return VA({inputs:{input:t[0]},backend:e,attrs:{dim:s}});const i=t[0].shape,o=t[0].dtype;t.forEach(p=>{xi(i,p.shape,"All tensors passed to stack must have matching shapes"),J(o===p.dtype,()=>"All tensors passed to stack must have matching dtypes")});const a=[],c=Aj({inputs:t.map(p=>{const m=VA({inputs:{input:p},backend:e,attrs:{dim:s}});return a.push(m),m}),backend:e,attrs:{axis:s}});return a.forEach(p=>e.disposeIntermediateTensorInfo(p)),c}};class mAe{constructor(t,e,r){this.variableNames=["x"],this.customUniforms=[{name:"value",type:"float"}],this.outputShape=e.map((c,p)=>c[0]+t[p]+c[1]);const s=t.length,i=Vn(s),o=e.map(c=>c[0]).join(","),a=e.map((c,p)=>c[0]+t[p]).join(","),u=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,s);this.userCode=1!==s?`\n      ${i} start = ${i}(${o});\n      ${i} end = ${i}(${a});\n\n      void main() {\n        ${i} outC = getOutputCoords();\n        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {\n          setOutput(value);\n        } else {\n          ${i} coords = outC - start;\n          setOutput(getX(${u}));\n        }\n      }\n    `:`\n        int start = ${o};\n        int end = ${a};\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start || outC >= end) {\n            setOutput(value);\n          } else {\n            setOutput(getX(outC - start));\n          }\n        }\n      `}}class gAe{constructor(t,e,r){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"value",type:"float"}],this.outputShape=e.map((T,I)=>T[0]+t[I]+T[1]);const s=t.length,i=Vn(s),o=e.map(T=>T[0]).join(","),a=e.map((T,I)=>T[0]+t[I]).join(","),u=Ws("rc",s),c=Ws("source",s),p=`${u[s-1]} < ${this.outputShape[s-1]}`,m=1===s?"source":`vec2(${c.slice(-2).join()})`,y=[`${i} rc = outputLoc;`,`${u[s-1]} += 1;\n       if(${p}) {\n      `,1===s?"":`}\n       rc = outputLoc;\n       ${u[s-2]} += 1;\n       if(${u[s-2]} < ${this.outputShape[s-2]}) {`,1===s?"":`  ${u[s-1]} += 1;\n         if(${p}) {`],_=1===s?"rc < start || rc >= end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))";let w="";for(let T=0,I=1===s?2:4;T<I;T++)w+=`\n        ${y[T]}\n        if (${_}) {\n          result[${T}] = float(value);\n        } else {\n          ${i} source = rc - start;\n          result[${T}] = getChannel(getX(${c.join()}), ${m});\n        }\n      `;w+=1===s?"} ":"}}",this.userCode=`\n      const ${i} start = ${i}(${o});\n      const ${i} end = ${i}(${a});\n\n      void main() {\n        ${i} outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        ${w}\n        setOutput(result);\n      }\n    `}}const Qj=n=>{const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{paddings:i,constantValue:o}=r;if(0===Fe(s.shape))return Og({backend:e,attrs:{shape:i.map((p,m)=>p[0]+s.shape[m]+p[1]),value:o,dtype:s.dtype}});const a=De().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new gAe(s.shape,i,o):new mAe(s.shape,i,o);return e.runWebGLProgram(a,[s],s.dtype,[[o]])},yAe={kernelName:q_,backendName:"webgl",kernelFunc:Qj},vAe=Ts({opSnippet:"\n  if(a < 0.0 && floor(b) < b){\n    return NAN;\n  }\n  if (b == 0.0) {\n    return 1.0;\n  }\n  return (round(mod(b, 2.0)) != 1) ?\n      pow(abs(a), b) : sign(a) * pow(abs(a), b);\n",packedOpSnippet:"\n  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.\n  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));\n  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);\n  vec4 result = multiplier * pow(abs(a), b);\n\n  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS\n  bvec4 isExpZero = equal(b, vec4(0.0));\n  result.r = isExpZero.r ? 1.0 : result.r;\n  result.g = isExpZero.g ? 1.0 : result.g;\n  result.b = isExpZero.b ? 1.0 : result.b;\n  result.a = isExpZero.a ? 1.0 : result.a;\n\n  bvec4 isNaN1 = lessThan(a, vec4(0.0));\n  bvec4 isNaN2 = lessThan(floor(b), b);\n  bvec4 isNaN = bvec4(isNaN1.x && isNaN2.x, isNaN1.y && isNaN2.y, isNaN1.z && isNaN2.z, isNaN1.w && isNaN2.w);\n  "+zc+"\n  return result;\n"}),wAe={kernelName:_m,backendName:"webgl",kernelFunc:vAe},TAe={kernelName:X_,backendName:"webgl",kernelFunc:function xAe(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{axis:i,keepDims:o}=r,a=s.shape.length,u=[],c=sn(i,s.shape);let p=c;const m=ur(p,a);let _,y=s;if(null!=m&&(y=Hs({inputs:{x:s},backend:e,attrs:{perm:m}}),p=Nr(p.length,a),u.push(y)),ws("prod",p,a),e.shouldExecuteOnCPU([y])){const w=e.texData.get(y.dataId).values,{outVals:T,outShape:I,outDtype:O}=rSe(y.shape,y.dtype,w,p);_=e.makeTensorInfo(I,O,T)}else{const[w,T]=us(y.shape,p),I=Fe(T),O=ut({inputs:{x:y},backend:e,attrs:{shape:[-1,I]}}),V=Uc(O,cI(s.dtype),"prod",e);_=ut({inputs:{x:V},backend:e,attrs:{shape:w}}),u.push(O),u.push(V)}if(o){u.push(_);const w=kr(_.shape,c);_=ut({inputs:{x:_},backend:e,attrs:{shape:w}})}return u.forEach(w=>e.disposeIntermediateTensorInfo(w)),_}},CAe={kernelName:PC,backendName:"webgl",kernelFunc:function SAe(n){const{inputs:t,backend:e,attrs:r}=n,{paramsNestedSplits:s,paramsDenseValues:i,indices:o}=t,{outputRaggedRank:a}=r,u=s.map(O=>e.readSync(O.dataId)),c=s.map(O=>O.shape),p=e.readSync(i.dataId),m=e.readSync(o.dataId),[y,_,w]=sSe(u,c,p,i.shape,i.dtype,m,o.shape,a),T=y.map(O=>e.makeTensorInfo([O.length],"int32",O)),I=e.makeTensorInfo(w,i.dtype,_);return T.concat([I])}},EAe={kernelName:FC,backendName:"webgl",kernelFunc:function IAe(n){const{inputs:t,backend:e}=n,{starts:r,limits:s,deltas:i}=t,o=e.readSync(r.dataId),a=e.readSync(s.dataId),u=e.readSync(i.dataId),[c,p]=iSe(o,r.shape,r.dtype,a,s.shape,u,i.shape);return[e.makeTensorInfo([c.length],"int32",c),e.makeTensorInfo([p.length],r.dtype,p)]}},AAe={kernelName:$C,backendName:"webgl",kernelFunc:function DAe(n){const{inputs:t,backend:e,attrs:r}=n,{shape:s,values:i,defaultValue:o,rowPartitionTensors:a}=t,{rowPartitionTypes:u}=r,c=e.readSync(s.dataId),p=e.readSync(i.dataId),m=e.readSync(o.dataId),y=a.map(I=>e.readSync(I.dataId)),_=a.map(I=>I.shape),[w,T]=oSe(c,s.shape,p,i.shape,i.dtype,m,o.shape,y,_,u);return e.makeTensorInfo(w,i.dtype,T)}},Jj=n=>{const{backend:t,attrs:e}=n,{start:r,stop:s,step:i,dtype:o}=e,a=aSe(r,s,i,o);return t.makeTensorInfo([a.length],o,a)},kAe={kernelName:LC,backendName:"webgl",kernelFunc:Jj},NAe=bn({opSnippet:"return 1.0 / x;"}),OAe={kernelName:vm,backendName:"webgl",kernelFunc:NAe},MAe=bn({opSnippet:Zi+"\n  return (x < 0.0) ? 0.0 : x;\n",packedOpSnippet:"\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"}),PAe={kernelName:wm,backendName:"webgl",kernelFunc:MAe},$Ae=bn({opSnippet:Zi+"\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n",packedOpSnippet:"\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"}),LAe={kernelName:xm,backendName:"webgl",kernelFunc:$Ae};class VAe{constructor(t,e,r,s,i){this.variableNames=["A"],this.outputShape=[];const[o,a,u,c]=t;this.outputShape=[o,e,r,c];const p=[s&&e>1?a-1:a,s&&r>1?u-1:u],m=[s&&e>1?e-1:e,s&&r>1?r-1:r];let y;y=i?"(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)":"vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ${p[0]/m[0]},\n          ${p[1]/m[1]});\n      const vec2 inputShapeRC = vec2(${a}.0, ${u}.0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = ${y};\n\n        // Compute the four integer indices.\n        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));\n        ivec2 sourceCeilRC = ivec2(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);\n        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);\n        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);\n        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);\n\n        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);\n\n        float top = topLeft + (topRight - topLeft) * fracRC.y;\n        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;\n        float newValue = top + (bottom - top) * fracRC.x;\n\n        setOutput(newValue);\n      }\n    `}}class BAe{constructor(t,e,r,s,i){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[o,a,u,c]=t;this.outputShape=[o,e,r,c];const p=[s&&e>1?a-1:a,s&&r>1?u-1:u],m=[s&&e>1?e-1:e,s&&r>1?r-1:r];let y;y=i?"(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)":"vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          ${p[0]/m[0]},\n          ${p[1]/m[1]},\n          ${p[1]/m[1]});\n      const vec3 inputShapeRC = vec3(${a}.0, ${u}.0,\n                                     ${u}.0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = ${y};\n\n        // Compute the four integer indices.\n        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));\n        ivec3 sourceCeilRC = ivec3(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < ${c-1};\n        bool hasNextRow = coords.z < ${r-1};\n\n        // In parallel, construct four corners for all four components in\n        // packed 2x2 cell.\n        vec4 topLeft = vec4(\n          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 bottomLeft = vec4(\n          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 topRight = vec4(\n          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec4 bottomRight = vec4(\n          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);\n\n        vec4 top = mix(topLeft, topRight, fracRC.yyzz);\n        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);\n        vec4 newValue = mix(top, bottom, fracRC.x);\n\n        setOutput(newValue);\n      }\n    `}}const UAe={kernelName:Q_,backendName:"webgl",kernelFunc:function zAe(n){const{inputs:t,backend:e,attrs:r}=n,{images:s}=t,{alignCorners:i,halfPixelCenters:o,size:a}=r,[u,c]=a,p=De().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new BAe(s.shape,u,c,i,o):new VAe(s.shape,u,c,i,o);return e.runWebGLProgram(p,[s],"float32")}};class jAe{constructor(t,e,r){this.variableNames=["dy"],this.outputShape=[],this.outputShape=e;const[,s,i]=e,[,o,a]=t,u=[r&&o>1?s-1:s,r&&a>1?i-1:i],c=[r&&o>1?o-1:o,r&&a>1?a-1:a],p=u[0]/c[0],m=u[1]/c[1],y=1/p,_=1/m,w=2*Math.ceil(y)+2,T=2*Math.ceil(_)+2;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(${p});\n        const float widthScale = float(${m});\n\n        const float invHeightScale = float(${y});\n        const float invWidthScale = float(${_});\n\n        const int winHeight = int(${w});\n        const int winWidth = int(${T});\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(startRLerp - float(winHeight / 2));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(startCLerp - float(winWidth / 2));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ${o}) {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ${a}) {\n              continue;\n            }\n\n            float dxR = float(dyR) * heightScale;\n            int topDxRIndex = int(floor(dxR));\n            int bottomDxRIndex = int(min(ceil(dxR), ${s-1}.0));\n            float dxRLerp = dxR - float(topDxRIndex);\n            float inverseDxRLerp = 1.0 - dxRLerp;\n\n            float dxC = float(dyC) * widthScale;\n            int leftDxCIndex = int(floor(dxC));\n            int rightDxCIndex = int(min(ceil(dxC), ${i-1}.0));\n            float dxCLerp = dxC - float(leftDxCIndex);\n            float inverseDxCLerp = 1.0 - dxCLerp;\n\n            if (r == topDxRIndex && c == leftDxCIndex) {\n              // topLeft\n              accumulator +=\n                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;\n            }\n\n            if (r == topDxRIndex && c == rightDxCIndex) {\n              // topRight\n              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == leftDxCIndex) {\n              // bottomLeft\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == rightDxCIndex) {\n              // bottomRight\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    `}}const WAe={kernelName:zC,backendName:"webgl",kernelFunc:function GAe(n){const{inputs:t,backend:e,attrs:r}=n,{images:s,dy:i}=t,{alignCorners:o}=r,a=new jAe(i.shape,s.shape,o);return e.runWebGLProgram(a,[i],i.dtype)}};class HAe{constructor(t,e,r,s,i){this.variableNames=["A"],this.outputShape=[];const[o,a,u,c]=t;this.outputShape=[o,e,r,c];const p=[s&&e>1?a-1:a,s&&r>1?u-1:u],m=[s&&e>1?e-1:e,s&&r>1?r-1:r];let _;_=i?"max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC, vec2(0.0))":"vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ${p[0]/m[0]},\n          ${p[1]/m[1]});\n      const vec2 inputShapeRC = vec2(${a}.0, ${u}.0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = ${_};\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec2 sourceNearestRC = ivec2(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${s?"0.5":"0.0"})));\n        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);\n\n        setOutput(newValue);\n      }\n    `}}class qAe{constructor(t,e,r,s,i){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[o,a,u,c]=t;this.outputShape=[o,e,r,c];const p=[s&&e>1?a-1:a,s&&r>1?u-1:u],m=[s&&e>1?e-1:e,s&&r>1?r-1:r];let _;_=i?"max((vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC, vec3(0.0))":"vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          ${p[0]/m[0]},\n          ${p[1]/m[1]},\n          ${p[1]/m[1]});\n      const vec3 inputShapeRC = vec3(${a}.0, ${u}.0,\n                                     ${u}.0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = ${_};\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec3 sourceNearestRC = ivec3(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${s?"0.5":"0.0"})));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < ${c-1};\n        bool hasNextRow = coords.z < ${r-1};\n\n        vec4 newValue = vec4(\n          getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d),\n          hasNextCol ? getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d + 1) : 0.0);\n\n        setOutput(newValue);\n      }\n    `}}const XAe={kernelName:Z_,backendName:"webgl",kernelFunc:function KAe(n){const{inputs:t,backend:e,attrs:r}=n,{images:s}=t,{alignCorners:i,halfPixelCenters:o,size:a}=r,[u,c]=a,p=De().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new qAe(s.shape,u,c,i,o):new HAe(s.shape,u,c,i,o);return e.runWebGLProgram(p,[s],s.dtype)}};class YAe{constructor(t,e,r){this.variableNames=["dy"],this.outputShape=[],this.outputShape=e;const[,s,i]=e,[,o,a]=t,u=[r&&o>1?s-1:s,r&&a>1?i-1:i],c=[r&&o>1?o-1:o,r&&a>1?a-1:a],p=u[0]/c[0],m=u[1]/c[1],y=1/p,_=1/m,w=2*Math.ceil(y)+2,T=2*Math.ceil(_)+2;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(${p});\n        const float widthScale = float(${m});\n\n        const float invHeightScale = float(${y});\n        const float invWidthScale = float(${_});\n\n        const int winHeight = int(${w});\n        const int winWidth = int(${T});\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(floor(startRLerp - float(winHeight / 2)));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(floor(startCLerp - float(winWidth / 2)));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ${o}) {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ${a}) {\n              continue;\n            }\n\n            float sourceFracRow =\n              float(${u[0]}) *\n                (float(dyR) / float(${c[0]}));\n\n            float sourceFracCol =\n                float(${u[1]}) *\n                  (float(dyC) / float(${c[1]}));\n\n            int sourceNearestRow = int(min(\n                float(int(${s}) - 1),\n                ${r} ? float(round(sourceFracRow)) :\n                                  float(floor(sourceFracRow))));\n\n            int sourceNearestCol = int(min(\n                float(int(${i}) - 1),\n                ${r} ? float(round(sourceFracCol)) :\n                                  float(floor(sourceFracCol))));\n\n            if (r == sourceNearestRow && c == sourceNearestCol) {\n              accumulator += getDy(b, dyR, dyC, d);\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    `}}const QAe={kernelName:BC,backendName:"webgl",kernelFunc:function ZAe(n){const{inputs:t,backend:e,attrs:r}=n,{images:s,dy:i}=t,{alignCorners:o}=r,a=new YAe(i.shape,s.shape,o);return e.runWebGLProgram(a,[i],i.dtype)}};class JAe{constructor(t,e){this.variableNames=["x"];const r=t.length;if(r>4)throw new Error(`WebGL backend: Reverse of rank-${r} tensor is not yet supported`);if(this.outputShape=t,1===r)return void(this.userCode=`\n        void main() {\n          int coord = getOutputCoords();\n          setOutput(getX(${t[0]} - coord - 1));\n        }\n      `);const i=t.map((a,u)=>(a=>-1!==e.indexOf(a)&&1!==t[a]?`${t[a]} - coords[${a}] - 1`:`coords[${a}]`)(u)).join(","),o=Vn(r);this.userCode=`\n      void main() {\n        ${o} coords = getOutputCoords();\n        setOutput(getX(${i}));\n      }\n    `}}class eke{constructor(t,e){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0;const r=t.length;if(r>4)throw new Error(`WebGL backend: Reverse of rank-${r} tensor is not yet supported`);this.outputShape=t;const s=Ws("rc",r),i=`${s[r-1]} + 1 < ${this.outputShape[r-1]}`,o=`${s[r-2]} + 1 < ${this.outputShape[r-2]}`,a=Vn(r);function y(w){const T=t.map((M,V)=>function _(w,T){return-1!==e.indexOf(w)&&1!==t[w]?`${t[w]} - ${T[w]} - 1`:`${T[w]}`}(V,w));return`getChannel(getX(${T.join(",")}), vec2(${T.slice(-2).join(",")}))`}this.userCode=1===r?`\n        void main(){\n          int rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = getChannel(getX(${t[0]} - rc - 1),\n            ${t[0]} - rc - 1);\n          if(${i}){\n              result.g = getChannel(getX(${t[0]} - (rc  + 1) - 1),\n                ${t[0]} - (rc  + 1) - 1);\n          }\n          setOutput(result);\n        }\n      `:`\n        void main() {\n          ${a} rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = ${function u(w){return y(w)}(s.slice())};\n          if(${i}){\n            result.g = ${function c(w){return w[r-1]="("+w[r-1]+" + 1)",y(w)}(s.slice())};\n          }\n          if(${o}) {\n            result.b = ${function p(w){return w[r-2]="("+w[r-2]+" + 1)",y(w)}(s.slice())};\n            if(${i}) {\n              result.a = ${function m(w){return w[r-1]="("+w[r-1]+" + 1)",w[r-2]="("+w[r-2]+" + 1)",y(w)}(s.slice())};\n            }\n          }\n          setOutput(result);\n        }\n    `}}const nke={kernelName:J_,backendName:"webgl",kernelFunc:function tke(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{dims:i}=r,o=s.shape.length,a=sn(i,s.shape);if(0===o)return Ai({inputs:{x:s},backend:e});const u=De().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new eke(s.shape,a):new JAe(s.shape,a);return e.runWebGLProgram(u,[s],s.dtype)}};class rke{constructor(t,e){this.variableNames=["Image"],this.outputShape=[],this.customUniforms=[{name:"params",type:"vec4"}];const r=t[1],s=t[2];this.outputShape=t;let i="";i="number"==typeof e?`float outputValue = ${e.toFixed(2)};`:`\n        vec3 fill = vec3(${e.join(",")});\n        float outputValue = fill[coords[3]];`,this.userCode=`\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int x = coords[2];\n          int y = coords[1];\n          float coordXFloat = (float(x) - params[0]) * params[3] -\n            (float(y) - params[1]) * params[2];\n          float coordYFloat = (float(x) - params[0]) * params[2] +\n            (float(y) - params[1]) * params[3];\n          int coordX = int(round(coordXFloat + params[0]));\n          int coordY = int(round(coordYFloat + params[1]));\n          ${i}\n          if(coordX >= 0 && coordX < ${s} && coordY >= 0 && coordY < ${r}) {\n            outputValue = getImage(coords[0], coordY, coordX, coords[3]);\n          }\n          setOutput(outputValue);\n        }\n    `}}const ske={kernelName:sI,backendName:"webgl",kernelFunc:({inputs:n,attrs:t,backend:e})=>{const{image:r}=n,{radians:s,fillValue:i,center:o}=t,a=e,u=new rke(r.shape,i),[c,p]=LE(o,r.shape[1],r.shape[2]),m=[[c,p,Math.sin(s),Math.cos(s)]];return a.runWebGLProgram(u,[r],r.dtype,m)}},ike=bn({opSnippet:"\n  // OpenGL ES does not support round function.\n  // The algorithm is based on banker's rounding.\n  float base = floor(x);\n  if ((x - base) < 0.5) {\n    return floor(x);\n  } else if ((x - base) > 0.5) {\n    return ceil(x);\n  } else {\n    if (mod(base, 2.0) == 0.0) {\n      return base;\n    } else {\n      return base + 1.0;\n    }\n  }\n"}),oke={kernelName:Tm,backendName:"webgl",kernelFunc:ike},ake=bn({opSnippet:"return inversesqrt(x);",cpuKernelImpl:lSe}),lke={kernelName:Sm,backendName:"webgl",kernelFunc:ake};class zA{constructor(t,e,r,s,i,o,a=!0,u=!1){this.variableNames=["updates","indices","defaultValue"],this.outputShape=o;const c=Vn(i.length),p=Vn(o.length);let m="";1===r?m="i":2===r&&(m="i, j");let _="";1===s?_="i":2===s&&(_="i, coords[1]");let T="";u&&(T="coords[0], coords[1]"),this.userCode=`\n        ${c} strides = ${c}(${i});\n\n        void main() {\n          ${p} coords = getOutputCoords();\n          float sum = 0.0;\n          bool found = false;\n          for (int i = 0; i < ${t}; i++) {\n            int flattenedIndex = 0;\n            for (int j = 0; j < ${e}; j++) {\n              int index = round(getIndices(${m}));\n              flattenedIndex += index * ${e>1?"strides[j]":"strides"};\n            }\n            if (flattenedIndex == coords[0]) {\n              sum += getUpdates(${_});\n              found = true;\n            }\n          }\n          setOutput(mix(getDefaultValue(${T}), sum, float(found)));\n        }\n      `}}class uke{constructor(t,e,r,s,i,o,a=!0,u=!1){this.variableNames=["updates","indices","defaultValue"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=o;const c=Vn(i.length),p=Vn(o.length);let m="";1===r?m="i":2===r&&(m="i, j");let _="";1===s?_="i":2===s&&(_="i, coords[1]");let T="";u&&(T="coords[0], coords[1]"),this.userCode=`\n        ${c} strides = ${c}(${i});\n\n        void main() {\n          ${p} coords = getOutputCoords();\n          vec4 sum = vec4(0.);\n          vec4 found = vec4(0.);\n          for (int i = 0; i < ${t}; i+=2) {\n            ivec2 flattenedIndex = ivec2(0);\n            for (int j = 0; j < ${e}; j+=2) {\n              ivec4 index = round(getIndices(${m}));\n              flattenedIndex += index.xz * ${e>1?"strides[j]":"strides"};\n              if (j + 1 < ${e}) {\n                flattenedIndex += index.yw * ${e>1?"strides[j + 1]":"strides"};\n              }\n            }\n            if (flattenedIndex[0] == coords[0] || flattenedIndex[1] == coords[0] ||\n                flattenedIndex[0] == coords[0] + 1 || flattenedIndex[1] == coords[0] + 1) {\n              vec4 updVals = getUpdates(${_});\n              if (flattenedIndex[0] == coords[0]) {\n                sum.xy += updVals.xy;\n                found.xy = vec2(1.);\n              } else if (flattenedIndex[0] == coords[0] + 1) {\n                sum.zw += updVals.xy;\n                found.zw = vec2(1.);\n              }\n              if (flattenedIndex[1] == coords[0]) {\n                sum.xy += updVals.zw;\n                found.xy = vec2(1.);\n              } else if (flattenedIndex[1] == coords[0] + 1) {\n                sum.zw += updVals.zw;\n                found.zw = vec2(1.);\n              }\n            }\n          }\n          setOutput(mix(getDefaultValue(${T}), sum, found));\n        }\n      `}}const dke={kernelName:UC,backendName:"webgl",kernelFunc:function cke(n){const{inputs:t,backend:e,attrs:r}=n,{indices:s,updates:i}=t,{shape:o}=r,{sliceRank:a,numUpdates:u,sliceSize:c,strides:p,outputSize:m}=Ec(0,s,o),y=[m/c,c];if(0===m)return e.makeTensorInfo(o,s.dtype);const _=ut({inputs:{x:s},backend:e,attrs:{shape:[u,a]}}),w=ut({inputs:{x:i},backend:e,attrs:{shape:[u,c]}}),T=e.makeTensorInfo([],"float32",new Float32Array([0]));let I;I=De().getBool("WEBGL_PACK")?new uke(u,a,_.shape.length,w.shape.length,p,y):new zA(u,a,_.shape.length,w.shape.length,p,y);const O=e.runWebGLProgram(I,[w,_,T],w.dtype),M=ut({inputs:{x:O},backend:e,attrs:{shape:o}});return e.disposeIntermediateTensorInfo(_),e.disposeIntermediateTensorInfo(w),e.disposeIntermediateTensorInfo(O),e.disposeIntermediateTensorInfo(T),M}};class hke{constructor(t,e,r,s){this.variableNames=["sortedSequence","values"],this.customUniforms=[{name:"numInputs",type:"int"}],this.outputShape=[t,r];const o=`for (int i = 0; i < ${Math.ceil(Math.log2(e+1))}; ++i) { if (left >= right) break;`,a=2===De().getNumber("WEBGL_VERSION")?"while (left < right) {":o;this.userCode=`\n       int findBound(int batch, float value) {\n         int left = 0;\n         int right = numInputs;\n         int mid;\n         ${a}\n           mid = (left + right) / 2;\n           if (getSortedSequence(batch, mid) ${"left"===s?"<":"<="} value) {\n             left = mid + 1;\n           } else {\n             right = mid;\n           }\n         }\n         return right;\n       }\n\n       void main() {\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int valueIndex = coords[1];\n\n         float value = getValues(batch, valueIndex);\n\n         setOutput(float(findBound(batch, value)));\n       }\n     `}}const fke={kernelName:GC,backendName:"webgl",kernelFunc:function pke(n){const{inputs:t,backend:e,attrs:r}=n,{sortedSequence:s,values:i}=t,{side:o}=r,a=new hke(s.shape[0],s.shape[1],i.shape[1],o);return e.runWebGLProgram(a,[s,i],"int32",[[s.shape[1]]])}};class mke{constructor(t,e,r){let s,i;if(this.variableNames=["c","a","b"],this.outputShape=e,r>4)throw Error(`Where for rank ${r} is not yet supported`);if(1===r)i="resRC",s="resRC";else{const a=["resRC.x","resRC.y","resRC.z","resRC.w"],u=[],c=[];for(let p=0;p<e.length;p++)c.push(`${a[p]}`),p<t&&u.push(`${a[p]}`);s=u.join(),i=c.join()}const o=Vn(r);this.userCode=`\n      void main() {\n        ${o} resRC = getOutputCoords();\n        float cVal = getC(${s});\n        if (cVal >= 1.0) {\n          setOutput(getA(${i}));\n        } else {\n          setOutput(getB(${i}));\n        }\n      }\n    `}}const yke={kernelName:ev,backendName:"webgl",kernelFunc:function gke(n){const{inputs:t,backend:e}=n,{condition:r,t:s,e:i}=t,o=new mke(r.shape.length,s.shape,s.shape.length);return e.runWebGLProgram(o,[r,s,i],Ti(s.dtype,i.dtype))}},_ke=bn({opSnippet:`\n  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.\n  // see: https://arxiv.org/abs/1706.02515\n  float scaleAlpha = ${Xv};\n  float scale = ${Yv};\n  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);\n`}),vke={kernelName:Cm,backendName:"webgl",kernelFunc:_ke},xke=bn({opSnippet:Yh+"\n  return 1.0 / (1.0 + exp(-1.0 * x));\n",packedOpSnippet:"\n  vec4 result = 1.0 / (1.0 + exp(-1.0 * x));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",cpuKernelImpl:cSe}),Tke={kernelName:Am,backendName:"webgl",kernelFunc:xke},Ske=bn({opSnippet:"\n  if (isnan(x)) { return 0.0; }\n  return sign(x);\n"}),Cke={kernelName:Dm,backendName:"webgl",kernelFunc:Ske},Dke=bn({opSnippet:Yh+"\n  return sin(x);\n",packedOpSnippet:`\n  vec4 result = sin(x);\n  bvec4 isNaN = isnan(x);\n  ${zc}\n  return result;\n`}),Ake={kernelName:Im,backendName:"webgl",kernelFunc:Dke},kke=bn({opSnippet:"\n  float e2x = exp(x);\n  return (e2x - 1.0 / e2x) / 2.0;\n"}),Nke={kernelName:Em,backendName:"webgl",kernelFunc:kke},Oke=bn({opSnippet:"\n  float epsilon = 1.1920928955078125e-7;\n  float threshold = log(epsilon) + 2.0;\n\n  bool too_large = x > -threshold;\n  bool too_small = x < threshold;\n\n  float result;\n  float exp_x = exp(x);\n\n  if (too_large){\n    result = x;\n  }\n  else if (too_small){\n    result = exp_x;\n  }\n  else{\n    result = log(exp_x + 1.0);\n  }\n  return result;\n"}),Rke={kernelName:km,backendName:"webgl",kernelFunc:Oke},Mke={kernelName:rv,backendName:"webgl",kernelFunc:n=>{const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{blockShape:i,paddings:o}=r;J(s.shape.length<=4,()=>"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet");const a=i.reduce((O,M)=>O*M),u=[[0,0]];u.push(...o);for(let O=1+i.length;O<s.shape.length;++O)u.push([0,0]);const c=[],p=Qj({inputs:{x:s},backend:e,attrs:{paddings:u,constantValue:0}}),m=rg(p.shape,i,a,!1),y=sg(m.length,i.length,!1),_=ig(p.shape,i,a,!1),w=ut({inputs:{x:p},backend:e,attrs:{shape:m}}),T=Hs({inputs:{x:w},backend:e,attrs:{perm:y}}),I=ut({inputs:{x:T},backend:e,attrs:{shape:_}});return c.push(p),c.push(w),c.push(T),c.forEach(O=>e.disposeIntermediateTensorInfo(O)),I}},Fke={kernelName:WC,backendName:"webgl",kernelFunc:function Pke(n){const{inputs:t,backend:e}=n,{indices:r,values:s,denseShape:i,defaultValue:o}=t;if(1!==i.shape.length)throw new Error(`Dense shape must be a vector, saw:\n         ${i.shape}`);if(2!==r.shape.length)throw new Error(`Indices must be a matrix, saw:\n         ${r.shape}`);if(1!==s.shape.length)throw new Error(`Values must be a vector, saw:\n         ${s.shape}`);if(0!==o.shape.length)throw new Error(`Default value must be a scalar, saw:\n        ${o.shape}`);const a=e.readSync(r.dataId),u=e.readSync(s.dataId),c=e.readSync(i.dataId),p=e.readSync(o.dataId)[0],[m,y,_,w,T]=hSe(a,r.shape,r.dtype,u,s.dtype,c,p);return[e.makeTensorInfo(y,r.dtype,m),e.makeTensorInfo([y[0]],s.dtype,_),e.makeTensorInfo([w.length],"bool",new Uint8Array(w.map(I=>Number(I)))),e.makeTensorInfo([T.length],r.dtype,new Int32Array(T))]}},Lke={kernelName:HC,backendName:"webgl",kernelFunc:function $ke(n){const{inputs:t,backend:e}=n,{inputIndices:r,inputShape:s,newShape:i}=t;if(2!==r.shape.length)throw new Error(`Input indices should be a matrix but received shape ${r.shape}`);if(1!==s.shape.length)throw new Error(`Input shape should be a vector but received shape ${s.shape}`);if(1!==i.shape.length)throw new Error(`Target shape should be a vector but received shape ${i.shape}`);const o=Array.from(e.readSync(s.dataId)),a=e.readSync(r.dataId),u=Array.from(e.readSync(i.dataId)),[c,p,m]=pSe(a,r.shape,r.dtype,o,u);return[e.makeTensorInfo(p,r.dtype,c),e.makeTensorInfo([m.length],i.dtype,new Int32Array(m))]}},Bke={kernelName:qC,backendName:"webgl",kernelFunc:function Vke(n){const{inputs:t,backend:e}=n,{data:r,indices:s,segmentIds:i}=t;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==s.shape.length)throw new Error(`Indices should be a vector but received shape\n              ${s.shape}`);if(1!==i.shape.length)throw new Error(`Segment ids should be a vector but received shape\n              ${i.shape}`);const o=e.readSync(r.dataId),a=e.readSync(s.dataId),u=e.readSync(i.dataId),[c,p]=sj(o,r.shape,r.dtype,a,u,!0);return e.makeTensorInfo(p,r.dtype,c)}},Uke={kernelName:KC,backendName:"webgl",kernelFunc:function zke(n){const{inputs:t,backend:e}=n,{data:r,indices:s,segmentIds:i}=t;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==s.shape.length)throw new Error(`Indices should be a vector but received shape\n             ${s.shape}`);if(1!==i.shape.length)throw new Error(`Segment ids should be a vector but received shape\n             ${i.shape}`);const o=e.readSync(r.dataId),a=e.readSync(s.dataId),u=e.readSync(i.dataId),[c,p]=sj(o,r.shape,r.dtype,a,u);return e.makeTensorInfo(p,r.dtype,c)}},Gke={kernelName:XC,backendName:"webgl",kernelFunc:function jke(n){const{inputs:t,backend:e,attrs:r}=n,{sparseIndices:s,sparseValues:i,defaultValue:o}=t,{outputShape:a}=r,{sliceRank:u,numUpdates:c,sliceSize:p,strides:m,outputSize:y}=Ec(0,s,a);if("string"===i.dtype){const O=e.bufferSync(s),M=e.bufferSync(i),V=Jl(e.readSync(o.dataId)[0]),z=uSe(O,M,a,y,p,c,u,m,V,!1);return e.makeTensorInfo(a,z.dtype,z.values)}const w=new zA(c,u,s.shape.length,i.shape.length,m,[y,1],!1),T=e.runWebGLProgram(w,[i,s,o],i.dtype),I=ut({inputs:{x:T},backend:e,attrs:{shape:a}});return e.disposeIntermediateTensorInfo(T),I}},Hke={kernelName:sv,backendName:"webgl",kernelFunc:function Wke(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{numOrSizeSplits:i,axis:o}=r,a=sn(o,s.shape)[0],u=tD(s,i,a),p=new Array(s.shape.length).fill(0),m=s.shape.slice();return u.map(y=>{const _=[...m];_[a]=y;const w=Zh({inputs:{x:s},backend:e,attrs:{begin:p,size:_}});return p[a]+=y,w})}},eG="return sqrt(x);",qke=bn({opSnippet:eG,packedOpSnippet:eG,cpuKernelImpl:fSe}),Kke={kernelName:Nm,backendName:"webgl",kernelFunc:qke},Yke={kernelName:YC,backendName:"webgl",kernelFunc:bn({opSnippet:"return x * x;"})},tG="return (a - b) * (a - b);",Zke=Ts({opSnippet:tG,packedOpSnippet:tG}),Qke={kernelName:Om,backendName:"webgl",kernelFunc:Zke},eNe={kernelName:ov,backendName:"webgl",kernelFunc:function Jke(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t;if("string"!==s.dtype)throw new Error("Input must be of datatype string");const o=yl(e.readSync(s.dataId)),a=mSe(o,"string",r);return e.makeTensorInfo(s.shape,"string",a)}},nNe={kernelName:$m,backendName:"webgl",kernelFunc:function tNe({inputs:n,attrs:t,backend:e}){const{x:r}=n,i=new ja(r.shape,Zi+`\n    return x > 0.0 ? 1.0 : float(${t.alpha});\n  `);return e.runWebGLProgram(i,[r],r.dtype)}};class rNe{constructor(t,e,r){this.variableNames=["x"],this.outputShape=r;const s=r.length,i=Vn(r.length),o=Vn(r.length);let a="";if(1===s)a="coords * strides + begin";else{let u=0;a=r.map((c,p)=>(u++,1===r.length?`coords * strides[${p}] + begin[${p}]`:`coords[${u-1}] * strides[${p}] + begin[${p}]`)).join(",")}this.userCode=`\n      ${i} begin = ${i}(${t});\n      ${i} strides = ${i}(${e});\n\n      void main() {\n        ${o} coords = getOutputCoords();\n        setOutput(getX(${a}));\n      }\n    `}}const iNe={kernelName:ZC,backendName:"webgl",kernelFunc:function sNe(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{begin:i,end:o,strides:a,beginMask:u,endMask:c,ellipsisMask:p,newAxisMask:m,shrinkAxisMask:y}=r,{finalShapeSparse:_,finalShape:w,isIdentity:T,sliceDim0:I,isSimpleSlice:O,begin:M,end:V,strides:z}=UI(s.shape,i,o,a,u,c,p,m,y);let G;if(T)G=ut({inputs:{x:s},backend:e,attrs:{shape:w}});else if(I||O){J(s.shape.length>=1,()=>`Input must have rank at least 1, got: ${s.shape.length}`);const ne=VI(M,V,z),oe=Zh({inputs:{x:s},backend:e,attrs:{begin:M,size:ne}});G=ut({inputs:{x:oe},backend:e,attrs:{shape:w}}),e.disposeIntermediateTensorInfo(oe)}else if(e.shouldExecuteOnCPU([s])){const oe=e.readSync(s.dataId),de=tn(s.shape,s.dtype,oe),pe=gSe(_,de,z,M);G=e.makeTensorInfo(w,s.dtype,pe.values)}else{const oe=new rNe(M,z,_);G=e.runWebGLProgram(oe,[s],s.dtype)}const Q=ut({inputs:{x:G},backend:e,attrs:{shape:w}});return e.disposeIntermediateTensorInfo(G),Q}},aNe={kernelName:QC,backendName:"webgl",kernelFunc:function oNe(n){const{inputs:t,backend:e,attrs:r}=n,{separator:s,nGramWidths:i,leftPad:o,rightPad:a,padWidth:u,preserveShortSequences:c}=r,{data:p,dataSplits:m}=t,y=e.readSync(p.dataId),_=e.readSync(m.dataId),[w,T]=ySe(y,_,s,i,o,a,u,c);return[e.makeTensorInfo([w.length],"string",w),e.makeTensorInfo(m.shape,"int32",T)]}},uNe={kernelName:JC,backendName:"webgl",kernelFunc:function lNe(n){const{inputs:t,backend:e,attrs:r}=n,{skipEmpty:s}=r,{input:i,delimiter:o}=t;if("string"!==i.dtype)throw new Error("Input must be of datatype string");if(1!==i.shape.length)throw new Error(`Input must be a vector, got shape: ${i.shape}`);if(0!==o.shape.length)throw new Error(`Delimiter must be a scalar, got shape: ${o.shape}`);const a=e.readSync(i.dataId),u=e.readSync(o.dataId)[0],[c,p,m]=bSe(a,u,s),y=p.length;return[e.makeTensorInfo([y,2],"int32",c),e.makeTensorInfo([y],"string",p),e.makeTensorInfo([2],"int32",new Int32Array(m))]}},dNe={kernelName:eI,backendName:"webgl",kernelFunc:function cNe(n){const{inputs:t,backend:e,attrs:r}=n,{numBuckets:s}=r,{input:i}=t;if("string"!==i.dtype)throw new Error("Input must be of datatype string");if(s<=0)throw new Error("Number of buckets must be at least 1");const o=e.readSync(i.dataId),a=_Se(o,s);return e.makeTensorInfo(i.shape,"int32",a)}},hNe=bn({opSnippet:"return tan(x);"}),pNe={kernelName:Mm,backendName:"webgl",kernelFunc:hNe},fNe=bn({opSnippet:"\n  float e2x = exp(-2.0 * abs(x));\n  return sign(x) * (1.0 - e2x) / (1.0 + e2x);\n"}),mNe={kernelName:Pm,backendName:"webgl",kernelFunc:fNe},yNe={kernelName:jC,backendName:"webgl",kernelFunc:function gNe(n){const{inputs:t,backend:e}=n,{tensor:s,indices:i,updates:o}=t,{sliceRank:a,numUpdates:u,sliceSize:c,strides:p,outputSize:m}=Ec(0,i,s.shape),y=[m/c,c];if(0===m)return e.makeTensorInfo(s.shape,i.dtype);const _=ut({inputs:{x:i},backend:e,attrs:{shape:[u,a]}}),w=ut({inputs:{x:o},backend:e,attrs:{shape:[u,c]}}),T=ut({inputs:{x:s},backend:e,attrs:{shape:y}}),I=new zA(u,a,_.shape.length,w.shape.length,p,y,!1,!0),O=e.runWebGLProgram(I,[w,_,T],T.dtype),M=ut({inputs:{x:O},backend:e,attrs:{shape:s.shape}});return e.disposeIntermediateTensorInfo(_),e.disposeIntermediateTensorInfo(w),e.disposeIntermediateTensorInfo(T),e.disposeIntermediateTensorInfo(O),M}};class bNe{constructor(t,e){this.variableNames=["A"];const r=new Array(t.length);for(let o=0;o<r.length;o++)r[o]=t[o]*e[o];this.outputShape=r,this.rank=r.length;const s=Vn(this.rank),i=function _Ne(n){const t=n.length;if(t>5)throw Error(`Tile for rank ${t} is not yet supported`);if(1===t)return`imod(resRC, ${n[0]})`;const e=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"],r=[];for(let s=0;s<n.length;s++)r.push(`imod(${e[s]}, ${n[s]})`);return r.join()}(t);this.userCode=`\n      void main() {\n        ${s} resRC = getOutputCoords();\n        setOutput(getA(${i}));\n      }\n    `}}function nG(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{reps:i}=r;if("string"===s.dtype||s.shape.length>5){const u=e.readSync(s.dataId),c="string"===s.dtype?u.map(y=>Jl(y)):u,p=tn(s.shape,s.dtype,c),m=wSe(p,i);return e.makeTensorInfo(m.shape,m.dtype,m.values)}const o=new bNe(s.shape,i);return e.runWebGLProgram(o,[s],s.dtype)}const vNe={kernelName:Fm,backendName:"webgl",kernelFunc:nG};class wNe{constructor(t){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"negativeInf",type:"float"},{name:"dir",type:"int"},{name:"inc",type:"int"}],this.outputShape=t,this.userCode="\n       void main() {\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int elemIdx = coords[1];\n\n         // We compare elements pair-wise within a group of size 2 * inc.\n         // The comparing rule for each group alternates between ascending\n         // and descending. Within each group, we compare each pair at\n         // positions i and i+inc. To decide whether an element at position i\n         // is x0 or x1, we mod it by 2 * inc, if the result is smaller than\n         // inc, it is in the first half of the group, we denote it as x0,\n         // otherwise we denote it as x1.\n         // For example, as shown in the Bitonic top K paper referenced above,\n         // Figure5(a) shows that element[1] is in the\n         // second half of the group when group size is 2, but it is in the\n         // first half of the group when group size is 4.\n\n         bool isFirstInPair = imod(elemIdx, 2 * inc) < inc;\n         int i = isFirstInPair ? elemIdx : elemIdx - inc;\n\n         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));\n         int i1 = firstPass == 1 ? i + inc : int(getIndices(batch, i + inc));\n         float x0 = i0 < n ? getX(batch, i0) : negativeInf;\n         float x1 = i1 < n ? getX(batch, i1) : negativeInf;\n\n         // Denotes which direction indices are in (ascending or descending).\n         bool reverse = imod(elemIdx, 2 * dir) >= dir;\n         bool isGreater = x0 > x1 || (x0 == x1 && i1 > i0);\n         if (reverse == isGreater) { // Elements in opposite order of direction\n           int iTemp = i0;\n           i0 = i1;\n           i1 = iTemp;\n         }\n         if (isFirstInPair) {\n            setOutput(float(i0));\n         } else {\n            setOutput(float(i1));\n         }\n       }\n     "}}class xNe{constructor(t){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"k",type:"int"}],this.outputShape=t,this.userCode="\n    void main() {\n         // Takes max of indices (0, k), (1, k + 1), (2, k + 2) ...\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int elemIdx = coords[1];\n\n         // The output size is half of the previous size.\n         // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _ (k=4),\n         // we only need to output the indices at positions |, the indices at\n         // positions _ can be thrown away, see Figure5(b) After Phase 2\n         // (Merge phase) in the Bitonic Top K paper referenced above.\n         // For example, the paper shows we only need to output the orange bars.\n         // The output sequence should look like this | | | | | | | |.\n         // Because the sequence is halved, to map the output index back\n         // to the previous sequence to find the corresponding value,\n         // we need to double the index. When we double the index,\n         // we basically interpolate a position, so 2i looks like\n         // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k position\n         // of each 2k positions by - elemIdx % k. E.g. for output at\n         // index 4,5,6,7, we want to get the corresponding element at\n         // original index 8,9,10,11, for output at index 8,9,10,11,\n         // we want to get the corresponding element at original index\n         // 16,17,18,19, so on and so forth.\n\n         int i = elemIdx < k ? elemIdx : (elemIdx * 2 - imod(elemIdx, k));\n         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));\n         int i1 = firstPass == 1 ? i + k : int(getIndices(batch, i + k));\n\n         float x0 = getX(batch, i0);\n         float x1 = i1 < n ? getX(batch, i1) : x0;\n\n         setOutput(x0 >= x1 ? float(i0) : float(i1));\n       }\n     "}}function jc(n,t){null!==t&&n.disposeIntermediateTensorInfo(t)}function rG(n){let t=1;for(;t<n;)t*=2;return t}const SNe={kernelName:tI,backendName:"webgl",kernelFunc:function TNe(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{k:i,sorted:o}=r,a=De().getNumber("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD"),u=De().getNumber("TOPK_K_CPU_HANDOFF_THRESHOLD"),c=s.shape,p=c[c.length-1];if(e.shouldExecuteOnCPU([s])||p<a||i>u){const pe=e.readSync(s.dataId),[Te,Ae]=xSe(pe,c,s.dtype,i,o);return[e.makeTensorInfo(Te.shape,Te.dtype,Te.values),e.makeTensorInfo(Ae.shape,Ae.dtype,Ae.values)]}if(0===i)return c[c.length-1]=0,[e.makeTensorInfo(c,s.dtype,[]),e.makeTensorInfo(c,"int32",[])];if(1===p)return[s,Og({attrs:{shape:c,dtype:"int32",value:0},backend:e})];const m=e.texData.get(s.dataId),y=null!==m&&m.isPacked,_=y?e.unpackTensor(s):s,T=Fe(c)/p,I=ut({inputs:{x:_},attrs:{shape:[T,p]},backend:e});y&&jc(e,_);const O=rG(i),M=rG(p);let V=null;const z=()=>null===V?[I,I]:[I,V],G=(pe,Te,Ae)=>{const Oe=z(),Me=new wNe(Ae),Se=V;V=e.runWebGLProgram(Me,Oe,"int32",[[p],[null===V?1:0],[Number.NEGATIVE_INFINITY],[pe],[Te]]),jc(e,Se)};for(let pe=1;pe<O;pe*=2){const Te=2*pe;for(let Ae=pe;Ae>=1;Ae/=2)G(Te,Ae,[T,M])}for(let pe=M;pe>O;pe/=2){const Te=z(),Ae=new xNe([T,pe/2]),Pe=V;V=e.runWebGLProgram(Ae,Te,"int32",[[p],[null===V?1:0],[O]]),jc(e,Pe);const ve=O/2,Se=2*ve;for(let xe=ve;xe>=1;xe/=2)G(Se,xe,V.shape)}let Q=V;V=Zh({inputs:{x:V},backend:e,attrs:{begin:0,size:[T,i]}}),jc(e,Q);let ne=Wj({inputs:{x:I,indices:V},backend:e,attrs:{axis:1,batchDims:1}});jc(e,I);const oe=c.slice(0,-1);oe.push(i),Q=V,V=ut({inputs:{x:V},attrs:{shape:oe},backend:e}),jc(e,Q);const de=ne;return ne=ut({inputs:{x:ne},attrs:{shape:oe},backend:e}),jc(e,de),[ne,V]}};class CNe{constructor(t,e,r,s,i,o){this.variableNames=["Image","Transforms"],this.outputShape=o;const a="nearest"===r?1:2;let u;switch(s){case"constant":default:u=1;break;case"reflect":u=2;break;case"wrap":u=3;break;case"nearest":u=4}this.userCode=`\n            float mapCoord(float outCoord, float len) {\n              float inCoord = outCoord;\n              if(${u} == 2) {\n                if (inCoord < 0.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz2 = 2.0 * len;\n                    if (inCoord < sz2) {\n                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +\n                      inCoord;\n                    }\n                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;\n                  }\n                } else if (inCoord > len - 1.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz2 = 2.0 * len;\n                    inCoord -= sz2 * float(int(float(inCoord / sz2)));\n                    if (inCoord >= len) {\n                      inCoord = sz2 - inCoord - 1.0;\n                    }\n                  }\n                }\n                return clamp(inCoord, 0.0, len - 1.0);\n              } else if (${u} == 3) {\n                if (inCoord < 0.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz = len - 1.0;\n                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);\n                  }\n                } else if (inCoord > len - 1.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz = len - 1.0;\n                    inCoord -= len * float(int(float(inCoord / sz)));\n                  }\n                }\n                return clamp(inCoord, 0.0, len - 1.0);\n              } else if (${u} == 4) {\n                return clamp(outCoord, 0.0, len - 1.0);\n              } else {\n                return outCoord;\n              }\n            }\n\n            float readWithFillValue(int batch, int coordY, int coordX,\n              int channel) {\n              float outputValue;\n              if (0 <= coordY && coordY < ${t} && 0 <= coordX && coordX < ${e}) {\n                  outputValue = getImage(batch, coordY, coordX, channel);\n              } else {\n                outputValue = float(${i});\n              }\n              return outputValue;\n            }\n\n            void main() {\n              ivec4 coords = getOutputCoords();\n              float outputValue;\n              int batch = coords[0];\n              int x = coords[2];\n              int y = coords[1];\n              int channel = coords[3];\n              float xf = float(x);\n              float yf = float(y);\n              float a1 = getTransforms(batch, 0);\n              float a2 = getTransforms(batch, 1);\n              float a3 = getTransforms(batch, 2);\n              float b1 = getTransforms(batch, 3);\n              float b2 = getTransforms(batch, 4);\n              float b3 = getTransforms(batch, 5);\n              float c1 = getTransforms(batch, 6);\n              float c2 = getTransforms(batch, 7);\n              float projection = c1 * xf + c2 * yf + 1.0;\n              if (projection == 0.0) {\n                outputValue = float(${i});\n              } else {\n                float inX = (a1 * xf + a2 * yf + a3) / projection;\n                float inY = (b1 * xf + b2 * yf + b3) / projection;\n                float mapX = mapCoord(inX, float(${e}));\n                float mapY = mapCoord(inY, float(${t}));\n\n                if (${a} == 1) {\n                  int coordY = int(round(mapY));\n                  int coordX = int(round(mapX));\n                  outputValue = readWithFillValue(batch, coordY, coordX,\n                    channel);\n                } else {\n                  float yFloor = floor(mapY);\n                  float xFloor = floor(mapX);\n                  float yCeil = yFloor + 1.0;\n                  float xCeil = xFloor + 1.0;\n                  float valueYFloor = (xCeil - mapX) *\n                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);\n                  float valueYCeil = (xCeil - mapX) *\n                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);\n                  outputValue = (yCeil - mapY) * valueYFloor +\n                  (mapY - yFloor) * valueYCeil;\n                }\n              }\n              setOutput(outputValue);\n            }\n        `}}const ENe={kernelName:nI,backendName:"webgl",kernelFunc:function INe(n){const{inputs:t,backend:e,attrs:r}=n,{image:s,transforms:i}=t,{interpolation:o,fillMode:a,fillValue:u,outputShape:c}=r,[p,m,y,_]=s.shape,[w,T]=c??[m,y],O=new CNe(m,y,o,a,u,[p,w,T,_]);return e.runWebGLProgram(O,[s,i],"float32")}},ANe={kernelName:rI,backendName:"webgl",kernelFunc:function DNe(n){const{inputs:t,attrs:e,backend:r}=n,{axis:s}=e,{x:i}=t;Cg(i,"unique"),console.warn("WARNING: ","UI might be locked temporarily as data is being downloaded");const o=r.readSync(i.dataId),{outputValues:a,outputShape:u,indices:c}=TSe(o,s,i.shape,i.dtype);return[r.makeTensorInfo(u,i.dtype,a),r.makeTensorInfo([c.length],"int32",c)]}},NNe={kernelName:av,backendName:"webgl",kernelFunc:function kNe(n){const{inputs:t,backend:e,attrs:r}=n,{value:s}=t;let{axis:i}=r;i<0&&(i+=s.shape.length);const o=s,a=o.shape.length,u=s.shape[i],c=new Array(a-1);let p=0;for(let T=0;T<a;T++)T!==i&&(c[p++]=o.shape[T]);const m=[],y=new Array(a).fill(0),_=o.shape.slice();_[i]=1;const w=new Array(u);for(let T=0;T<w.length;T++){y[i]=T;const I=Zh({inputs:{x:o},backend:e,attrs:{begin:y,size:_}}),O=ut({inputs:{x:I},backend:e,attrs:{shape:c}});w[T]=O,m.push(I)}return m.forEach(T=>e.disposeIntermediateTensorInfo(T)),w}};class ONe{constructor(t,e){this.variableNames=["x","segmentIds"];const r=t.windowSize,s=t.batchSize,i=t.inSize,o=t.numSegments,a=o*Math.ceil(i/r);this.outputShape=[s,a];const p=4*Math.floor(r/4),m=r%4,y="\n        sumValue += dot(values, segFilter);\n    ";let _="";i%r>0&&(_=`\n        if (inIdx < 0 || inIdx >= ${i}) {\n          return initializationValue;\n        }\n      `);let w="";i%r>0&&(w=`\n        if (inIdx < 0 || inIdx >= ${i}) {\n          return -1.0;\n        }\n      `),this.userCode=`\n      const float initializationValue = 0.0;\n\n      float getValue(int batch, int inIdx) {\n        ${_}\n        return getX(batch, inIdx);\n      }\n\n      float getSegmentIdAtIndex(int inIdx) {\n        ${w}\n        return getSegmentIds(inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = int(floor(float(outIdx) / float(\n          ${o})) * float(${r}));\n        int currentSeg = int(mod(float(outIdx), float(${o})));\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ${p}; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0\n          );\n\n          ${y}\n        }\n\n        int inIdx = inOffset + ${p};\n        if (${1===m}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            0,\n            0,\n            0\n          );\n\n          ${y}\n        } else if (${2===m}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n              0,\n              0\n          );\n\n          ${y}\n        } else if (${3===m}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            0\n          );\n\n          ${y}\n        }\n        setOutput(sumValue);\n      }\n    `}}const PNe=[y1e,_1e,x1e,C1e,E1e,k1e,O1e,M1e,L1e,B1e,j1e,H1e,X1e,J1e,nCe,sCe,oCe,cCe,hCe,fCe,yCe,TCe,CCe,ECe,OCe,MCe,LCe,e1e,zCe,HCe,YCe,nIe,iIe,aIe,uIe,dIe,mIe,yIe,_Ie,wIe,TIe,CIe,DIe,kIe,MIe,FIe,VIe,UIe,GIe,HIe,XIe,ZIe,eEe,nEe,rEe,iEe,aEe,uEe,dEe,pEe,mEe,bEe,wEe,TEe,IEe,AEe,NEe,REe,JSe,PEe,GCe,$Ee,VEe,zEe,n1e,jEe,WEe,qEe,YEe,JEe,tDe,rDe,iDe,lDe,cDe,hDe,gDe,bDe,vDe,SDe,IDe,DDe,kDe,ODe,FDe,VDe,jDe,XDe,i1e,JDe,nAe,iAe,lAe,DCe,cAe,hAe,fAe,yAe,wAe,s1e,TAe,CAe,EAe,AAe,kAe,ACe,WDe,OAe,PAe,LAe,a1e,UAe,WAe,XAe,QAe,nke,ske,oke,lke,dke,fke,yke,vke,Tke,Cke,Ake,Nke,xCe,qDe,Rke,Mke,Fke,Lke,Bke,Uke,Gke,Hke,Kke,Yke,Qke,eNe,nNe,iNe,aNe,uNe,dNe,HDe,f1e,pNe,mNe,yNe,vNe,SNe,ENe,m1e,ANe,NNe,{kernelName:lv,backendName:"webgl",kernelFunc:function RNe(n){const{inputs:t,backend:e,attrs:r}=n,{x:s,segmentIds:i}=t,{numSegments:o}=r,a=s.shape.length,u=[];let c=0;const p=ur([c],a);let m=s;null!=p&&(m=Hs({inputs:{x:s},backend:e,attrs:{perm:p}}),u.push(m),c=Nr(1,a)[0]);const y=wB(m.shape,c,o),_=Fe([m.shape[c]]),w=ut({inputs:{x:m},backend:e,attrs:{shape:[-1,_]}});u.push(w);const T=cI(s.dtype),I=(z,G,Q,ne,oe)=>{const de=z.shape[0],pe=z.shape[1],Te=vB(pe,oe),Oe=new ONe({windowSize:Te,inSize:pe,batchSize:de,numSegments:oe},G),Me=e.compileAndRun(Oe,[z,Q],ne);if(u.push(Me),Me.shape[1]===oe)return Me;const Pe=Jj({backend:e,attrs:{start:0,stop:oe,step:1,dtype:"float32"}}),ve=nG({inputs:{x:Pe},backend:e,attrs:{reps:[pe/Te]}});return u.push(Pe),u.push(ve),I(Me,G,ve,ne,oe)},M=ut({inputs:{x:I(w,"unsortedSegmentSum",i,T,o)},backend:e,attrs:{shape:y}});let V=M;if(null!=p){u.push(M);const z=pu(p);V=Hs({inputs:{x:V},backend:e,attrs:{perm:z}})}return u.forEach(z=>e.disposeIntermediateTensorInfo(z)),V}},dAe];for(const n of PNe)oI(n);const $Ne={hipbreadthsitting:{.1:"assets/confidence_models/lightgbm_model_hipbreadthsitting_0.1_1-2-2024.onnx",.5:"assets/confidence_models/lightgbm_model_hipbreadthsitting_0.5_1-2-2024.onnx",.9:"assets/confidence_models/lightgbm_model_hipbreadthsitting_0.9_1-2-2024.onnx"},bideltoidbreadth:{.1:"assets/confidence_models/lightgbm_model_bideltoidbreadth_0.1_1-19-2024.onnx",.5:"assets/confidence_models/lightgbm_model_bideltoidbreadth_0.5_1-19-2024.onnx",.9:"assets/confidence_models/lightgbm_model_bideltoidbreadth_0.9_1-19-2024.onnx"},chestbreadth:{.1:"assets/confidence_models/lightgbm_model_chestbreadth_0.1_1-19-2024.onnx",.5:"assets/confidence_models/lightgbm_model_chestbreadth_0.5_1-19-2024.onnx",.9:"assets/confidence_models/lightgbm_model_chestbreadth_0.9_1-19-2024.onnx"},sittingheight:{.1:"assets/confidence_models/lightgbm_model_sittingheight_0.1_1-19-2024.onnx",.5:"assets/confidence_models/lightgbm_model_sittingheight_0.5_1-19-2024.onnx",.9:"assets/confidence_models/lightgbm_model_sittingheight_0.9_1-19-2024.onnx"},buttockpopliteallength:{.1:"assets/confidence_models/lightgbm_model_buttockpopliteallength_0.1_1-19-2024.onnx",.5:"assets/confidence_models/lightgbm_model_buttockpopliteallength_0.5_1-19-2024.onnx",.9:"assets/confidence_models/lightgbm_model_buttockpopliteallength_0.9_1-19-2024.onnx"},thighclearance:{.1:"assets/confidence_models/lightgbm_model_thighclearance_0.1_1-19-2024.onnx",.5:"assets/confidence_models/lightgbm_model_thighclearance_0.5_1-19-2024.onnx",.9:"assets/confidence_models/lightgbm_model_thighclearance_0.9_1-19-2024.onnx"},tibialheight:{.1:"assets/confidence_models/lightgbm_model_tibialheight_0.1_1-19-2024.onnx",.5:"assets/confidence_models/lightgbm_model_tibialheight_0.5_1-19-2024.onnx",.9:"assets/confidence_models/lightgbm_model_tibialheight_0.9_1-19-2024.onnx"},buttockkneelength:{.1:"assets/confidence_models/lightgbm_model_buttockkneelength_0.1_1-19-2024.onnx",.5:"assets/confidence_models/lightgbm_model_buttockkneelength_0.5_1-19-2024.onnx",.9:"assets/confidence_models/lightgbm_model_buttockkneelength_0.9_1-19-2024.onnx"},elbowrestheight:{.1:"assets/confidence_models/lightgbm_model_elbowrestheight_0.1_1-19-2024.onnx",.5:"assets/confidence_models/lightgbm_model_elbowrestheight_0.5_1-19-2024.onnx",.9:"assets/confidence_models/lightgbm_model_elbowrestheight_0.9_1-19-2024.onnx"},kneeheightsitting:{.1:"assets/confidence_models/lightgbm_model_kneeheightsitting_0.1_1-19-2024.onnx",.5:"assets/confidence_models/lightgbm_model_kneeheightsitting_0.5_1-19-2024.onnx",.9:"assets/confidence_models/lightgbm_model_kneeheightsitting_0.9_1-19-2024.onnx"}};class LNe{}function ia(n){return null!=n&&"false"!=`${n}`}function ci(n,t=0){return function VNe(n){return!isNaN(parseFloat(n))&&!isNaN(Number(n))}(n)?Number(n):t}function tw(n){return Array.isArray(n)?n:[n]}function ns(n){return null==n?"":"string"==typeof n?n:`${n}px`}function Jh(n){return n instanceof tr?n.nativeElement:n}const BNe=["addListener","removeListener"],zNe=["addEventListener","removeEventListener"],UNe=["on","off"];function UA(n,t,e,r){if(X(e)&&(r=e,e=void 0),r)return UA(n,t,e).pipe(b1(r));const[s,i]=function WNe(n){return X(n.addEventListener)&&X(n.removeEventListener)}(n)?zNe.map(o=>a=>n[o](t,a,e)):function jNe(n){return X(n.addListener)&&X(n.removeListener)}(n)?BNe.map(sG(n,t)):function GNe(n){return X(n.on)&&X(n.off)}(n)?UNe.map(sG(n,t)):[];if(!s&&up(n))return fr(o=>UA(o,t,e))(fs(n));if(!s)throw new TypeError("Invalid event target");return new Dn(o=>{const a=(...u)=>o.next(1<u.length?u:u[0]);return s(a),()=>i(a)})}function sG(n,t){return e=>r=>n[e](t,r)}class HNe extends ce{constructor(t,e){super()}schedule(t,e=0){return this}}const nw={setInterval(n,t,...e){const{delegate:r}=nw;return r?.setInterval?r.setInterval(n,t,...e):setInterval(n,t,...e)},clearInterval(n){const{delegate:t}=nw;return(t?.clearInterval||clearInterval)(n)},delegate:void 0};class jA extends HNe{constructor(t,e){super(t,e),this.scheduler=t,this.work=e,this.pending=!1}schedule(t,e=0){var r;if(this.closed)return this;this.state=t;const s=this.id,i=this.scheduler;return null!=s&&(this.id=this.recycleAsyncId(i,s,e)),this.pending=!0,this.delay=e,this.id=null!==(r=this.id)&&void 0!==r?r:this.requestAsyncId(i,this.id,e),this}requestAsyncId(t,e,r=0){return nw.setInterval(t.flush.bind(t,this),r)}recycleAsyncId(t,e,r=0){if(null!=r&&this.delay===r&&!1===this.pending)return e;null!=e&&nw.clearInterval(e)}execute(t,e){if(this.closed)return new Error("executing a cancelled action");this.pending=!1;const r=this._execute(t,e);if(r)return r;!1===this.pending&&null!=this.id&&(this.id=this.recycleAsyncId(this.scheduler,this.id,null))}_execute(t,e){let s,r=!1;try{this.work(t)}catch(i){r=!0,s=i||new Error("Scheduled action threw falsy error")}if(r)return this.unsubscribe(),s}unsubscribe(){if(!this.closed){const{id:t,scheduler:e}=this,{actions:r}=e;this.work=this.state=this.scheduler=null,this.pending=!1,ie(r,this),null!=t&&(this.id=this.recycleAsyncId(e,t,null)),this.delay=null,super.unsubscribe()}}}const Rg={schedule(n){let t=requestAnimationFrame,e=cancelAnimationFrame;const{delegate:r}=Rg;r&&(t=r.requestAnimationFrame,e=r.cancelAnimationFrame);const s=t(i=>{e=void 0,n(i)});return new ce(()=>e?.(s))},requestAnimationFrame(...n){const{delegate:t}=Rg;return(t?.requestAnimationFrame||requestAnimationFrame)(...n)},cancelAnimationFrame(...n){const{delegate:t}=Rg;return(t?.cancelAnimationFrame||cancelAnimationFrame)(...n)},delegate:void 0},iG={now:()=>(iG.delegate||Date).now(),delegate:void 0};class Mg{constructor(t,e=Mg.now){this.schedulerActionCtor=t,this.now=e}schedule(t,e=0,r){return new this.schedulerActionCtor(this,t).schedule(r,e)}}Mg.now=iG.now;class GA extends Mg{constructor(t,e=Mg.now){super(t,e),this.actions=[],this._active=!1}flush(t){const{actions:e}=this;if(this._active)return void e.push(t);let r;this._active=!0;do{if(r=t.execute(t.state,t.delay))break}while(t=e.shift());if(this._active=!1,r){for(;t=e.shift();)t.unsubscribe();throw r}}}new class KNe extends GA{flush(t){this._active=!0;const e=this._scheduled;this._scheduled=void 0;const{actions:r}=this;let s;t=t||r.shift();do{if(s=t.execute(t.state,t.delay))break}while((t=r[0])&&t.id===e&&r.shift());if(this._active=!1,s){for(;(t=r[0])&&t.id===e&&r.shift();)t.unsubscribe();throw s}}}(class qNe extends jA{constructor(t,e){super(t,e),this.scheduler=t,this.work=e}requestAsyncId(t,e,r=0){return null!==r&&r>0?super.requestAsyncId(t,e,r):(t.actions.push(this),t._scheduled||(t._scheduled=Rg.requestAnimationFrame(()=>t.flush(void 0))))}recycleAsyncId(t,e,r=0){var s;if(null!=r?r>0:this.delay>0)return super.recycleAsyncId(t,e,r);const{actions:i}=t;null!=e&&(null===(s=i[i.length-1])||void 0===s?void 0:s.id)!==e&&(Rg.cancelAnimationFrame(e),t._scheduled=void 0)}});let WA,YNe=1;const rw={};function oG(n){return n in rw&&(delete rw[n],!0)}const ZNe={setImmediate(n){const t=YNe++;return rw[t]=!0,WA||(WA=Promise.resolve()),WA.then(()=>oG(t)&&n()),t},clearImmediate(n){oG(n)}},{setImmediate:QNe,clearImmediate:JNe}=ZNe,sw={setImmediate(...n){const{delegate:t}=sw;return(t?.setImmediate||QNe)(...n)},clearImmediate(n){const{delegate:t}=sw;return(t?.clearImmediate||JNe)(n)},delegate:void 0},HA=(new class t2e extends GA{flush(t){this._active=!0;const e=this._scheduled;this._scheduled=void 0;const{actions:r}=this;let s;t=t||r.shift();do{if(s=t.execute(t.state,t.delay))break}while((t=r[0])&&t.id===e&&r.shift());if(this._active=!1,s){for(;(t=r[0])&&t.id===e&&r.shift();)t.unsubscribe();throw s}}}(class e2e extends jA{constructor(t,e){super(t,e),this.scheduler=t,this.work=e}requestAsyncId(t,e,r=0){return null!==r&&r>0?super.requestAsyncId(t,e,r):(t.actions.push(this),t._scheduled||(t._scheduled=sw.setImmediate(t.flush.bind(t,void 0))))}recycleAsyncId(t,e,r=0){var s;if(null!=r?r>0:this.delay>0)return super.recycleAsyncId(t,e,r);const{actions:i}=t;null!=e&&(null===(s=i[i.length-1])||void 0===s?void 0:s.id)!==e&&(sw.clearImmediate(e),t._scheduled===e&&(t._scheduled=void 0))}}),new GA(jA)),r2e=HA;function aG(n,t=HA){return function s2e(n){return An((t,e)=>{let r=!1,s=null,i=null,o=!1;const a=()=>{if(i?.unsubscribe(),i=null,r){r=!1;const c=s;s=null,e.next(c)}o&&e.complete()},u=()=>{i=null,o&&e.complete()};t.subscribe(Pn(e,c=>{r=!0,s=c,i||fs(n(c)).subscribe(i=Pn(e,a,u))},()=>{o=!0,(!r||!i||i.closed)&&e.complete()}))})}(()=>function o2e(n=0,t,e=r2e){let r=-1;return null!=t&&(od(t)?e=t:r=t),new Dn(s=>{let i=function i2e(n){return n instanceof Date&&!isNaN(n)}(n)?+n-e.now():n;i<0&&(i=0);let o=0;return e.schedule(function(){s.closed||(s.next(o++),0<=r?this.schedule(void 0,r):s.complete())},i)})}(n,t))}let qA;try{qA=typeof Intl<"u"&&Intl.v8BreakIterator}catch{qA=!1}let Pg,Gc,KA,No=(()=>{class n{constructor(e){this._platformId=e,this.isBrowser=this._platformId?function KQ(n){return n===qF}(this._platformId):"object"==typeof document&&!!document,this.EDGE=this.isBrowser&&/(edge)/i.test(navigator.userAgent),this.TRIDENT=this.isBrowser&&/(msie|trident)/i.test(navigator.userAgent),this.BLINK=this.isBrowser&&!(!window.chrome&&!qA)&&typeof CSS<"u"&&!this.EDGE&&!this.TRIDENT,this.WEBKIT=this.isBrowser&&/AppleWebKit/i.test(navigator.userAgent)&&!this.BLINK&&!this.EDGE&&!this.TRIDENT,this.IOS=this.isBrowser&&/iPad|iPhone|iPod/.test(navigator.userAgent)&&!("MSStream"in window),this.FIREFOX=this.isBrowser&&/(firefox|minefield)/i.test(navigator.userAgent),this.ANDROID=this.isBrowser&&/android/i.test(navigator.userAgent)&&!this.TRIDENT,this.SAFARI=this.isBrowser&&/safari/i.test(navigator.userAgent)&&this.WEBKIT}}return n.\u0275fac=function(e){return new(e||n)(Le(kd))},n.\u0275prov=ht({token:n,factory:n.\u0275fac,providedIn:"root"}),n})();function iw(n){return function a2e(){if(null==Pg&&typeof window<"u")try{window.addEventListener("test",null,Object.defineProperty({},"passive",{get:()=>Pg=!0}))}finally{Pg=Pg||!1}return Pg}()?n:!!n.capture}function l2e(){if(null==Gc){if("object"!=typeof document||!document||"function"!=typeof Element||!Element)return Gc=!1,Gc;if("scrollBehavior"in document.documentElement.style)Gc=!0;else{const n=Element.prototype.scrollTo;Gc=!!n&&!/\{\s*\[native code\]\s*\}/.test(n.toString())}}return Gc}function XA(){let n=typeof document<"u"&&document?document.activeElement:null;for(;n&&n.shadowRoot;){const t=n.shadowRoot.activeElement;if(t===n)break;n=t}return n}function Nu(n){return n.composedPath?n.composedPath()[0]:n.target}function YA(){return typeof __karma__<"u"&&!!__karma__||typeof jasmine<"u"&&!!jasmine||typeof jest<"u"&&!!jest||typeof Mocha<"u"&&!!Mocha}const d2e=new st("cdk-dir-doc",{providedIn:"root",factory:function h2e(){return Ct(xn)}}),p2e=/^(ar|ckb|dv|he|iw|fa|nqo|ps|sd|ug|ur|yi|.*[-_](Adlm|Arab|Hebr|Nkoo|Rohg|Thaa))(?!.*[-_](Latn|Cyrl)($|-|_))($|-|_)/i;let aw=(()=>{class n{constructor(e){this.value="ltr",this.change=new On,e&&(this.value=function f2e(n){const t=n?.toLowerCase()||"";return"auto"===t&&typeof navigator<"u"&&navigator?.language?p2e.test(navigator.language)?"rtl":"ltr":"rtl"===t?"rtl":"ltr"}((e.body?e.body.dir:null)||(e.documentElement?e.documentElement.dir:null)||"ltr"))}ngOnDestroy(){this.change.complete()}}return n.\u0275fac=function(e){return new(e||n)(Le(d2e,8))},n.\u0275prov=ht({token:n,factory:n.\u0275fac,providedIn:"root"}),n})(),Fg=(()=>{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275mod=ar({type:n}),n.\u0275inj=Jn({}),n})(),g2e=(()=>{class n{constructor(e,r,s){this._ngZone=e,this._platform=r,this._scrolled=new vn,this._globalSubscription=null,this._scrolledCount=0,this.scrollContainers=new Map,this._document=s}register(e){this.scrollContainers.has(e)||this.scrollContainers.set(e,e.elementScrolled().subscribe(()=>this._scrolled.next(e)))}deregister(e){const r=this.scrollContainers.get(e);r&&(r.unsubscribe(),this.scrollContainers.delete(e))}scrolled(e=20){return this._platform.isBrowser?new Dn(r=>{this._globalSubscription||this._addGlobalListener();const s=e>0?this._scrolled.pipe(aG(e)).subscribe(r):this._scrolled.subscribe(r);return this._scrolledCount++,()=>{s.unsubscribe(),this._scrolledCount--,this._scrolledCount||this._removeGlobalListener()}}):zt()}ngOnDestroy(){this._removeGlobalListener(),this.scrollContainers.forEach((e,r)=>this.deregister(r)),this._scrolled.complete()}ancestorScrolled(e,r){const s=this.getAncestorScrollContainers(e);return this.scrolled(r).pipe(ti(i=>!i||s.indexOf(i)>-1))}getAncestorScrollContainers(e){const r=[];return this.scrollContainers.forEach((s,i)=>{this._scrollableContainsElement(i,e)&&r.push(i)}),r}_getWindow(){return this._document.defaultView||window}_scrollableContainsElement(e,r){let s=Jh(r),i=e.getElementRef().nativeElement;do{if(s==i)return!0}while(s=s.parentElement);return!1}_addGlobalListener(){this._globalSubscription=this._ngZone.runOutsideAngular(()=>UA(this._getWindow().document,"scroll").subscribe(()=>this._scrolled.next()))}_removeGlobalListener(){this._globalSubscription&&(this._globalSubscription.unsubscribe(),this._globalSubscription=null)}}return n.\u0275fac=function(e){return new(e||n)(Le(Zt),Le(No),Le(xn,8))},n.\u0275prov=ht({token:n,factory:n.\u0275fac,providedIn:"root"}),n})(),uG=(()=>{class n{constructor(e,r,s){this._platform=e,this._change=new vn,this._changeListener=i=>{this._change.next(i)},this._document=s,r.runOutsideAngular(()=>{if(e.isBrowser){const i=this._getWindow();i.addEventListener("resize",this._changeListener),i.addEventListener("orientationchange",this._changeListener)}this.change().subscribe(()=>this._viewportSize=null)})}ngOnDestroy(){if(this._platform.isBrowser){const e=this._getWindow();e.removeEventListener("resize",this._changeListener),e.removeEventListener("orientationchange",this._changeListener)}this._change.complete()}getViewportSize(){this._viewportSize||this._updateViewportSize();const e={width:this._viewportSize.width,height:this._viewportSize.height};return this._platform.isBrowser||(this._viewportSize=null),e}getViewportRect(){const e=this.getViewportScrollPosition(),{width:r,height:s}=this.getViewportSize();return{top:e.top,left:e.left,bottom:e.top+s,right:e.left+r,height:s,width:r}}getViewportScrollPosition(){if(!this._platform.isBrowser)return{top:0,left:0};const e=this._document,r=this._getWindow(),s=e.documentElement,i=s.getBoundingClientRect();return{top:-i.top||e.body.scrollTop||r.scrollY||s.scrollTop||0,left:-i.left||e.body.scrollLeft||r.scrollX||s.scrollLeft||0}}change(e=20){return e>0?this._change.pipe(aG(e)):this._change}_getWindow(){return this._document.defaultView||window}_updateViewportSize(){const e=this._getWindow();this._viewportSize=this._platform.isBrowser?{width:e.innerWidth,height:e.innerHeight}:{width:0,height:0}}}return n.\u0275fac=function(e){return new(e||n)(Le(No),Le(Zt),Le(xn,8))},n.\u0275prov=ht({token:n,factory:n.\u0275fac,providedIn:"root"}),n})(),cG=(()=>{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275mod=ar({type:n}),n.\u0275inj=Jn({}),n})(),dG=(()=>{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275mod=ar({type:n}),n.\u0275inj=Jn({imports:[Fg,cG,Fg,cG]}),n})();function ZA(n){return An((t,e)=>{fs(n).subscribe(Pn(e,()=>e.complete(),wt)),!e.closed&&t.subscribe(e)})}class QA{attach(t){return this._attachedHost=t,t.attach(this)}detach(){let t=this._attachedHost;null!=t&&(this._attachedHost=null,t.detach())}get isAttached(){return null!=this._attachedHost}setAttachedHost(t){this._attachedHost=t}}class JA extends QA{constructor(t,e,r,s,i){super(),this.component=t,this.viewContainerRef=e,this.injector=r,this.componentFactoryResolver=s,this.projectableNodes=i}}class hG extends QA{constructor(t,e,r,s){super(),this.templateRef=t,this.viewContainerRef=e,this.context=r,this.injector=s}get origin(){return this.templateRef.elementRef}attach(t,e=this.context){return this.context=e,super.attach(t)}detach(){return this.context=void 0,super.detach()}}class b2e extends QA{constructor(t){super(),this.element=t instanceof tr?t.nativeElement:t}}class ek{constructor(){this._isDisposed=!1,this.attachDomPortal=null}hasAttached(){return!!this._attachedPortal}attach(t){return t instanceof JA?(this._attachedPortal=t,this.attachComponentPortal(t)):t instanceof hG?(this._attachedPortal=t,this.attachTemplatePortal(t)):this.attachDomPortal&&t instanceof b2e?(this._attachedPortal=t,this.attachDomPortal(t)):void 0}detach(){this._attachedPortal&&(this._attachedPortal.setAttachedHost(null),this._attachedPortal=null),this._invokeDisposeFn()}dispose(){this.hasAttached()&&this.detach(),this._invokeDisposeFn(),this._isDisposed=!0}setDisposeFn(t){this._disposeFn=t}_invokeDisposeFn(){this._disposeFn&&(this._disposeFn(),this._disposeFn=null)}}class _2e extends ek{constructor(t,e,r,s,i){super(),this.outletElement=t,this._componentFactoryResolver=e,this._appRef=r,this._defaultInjector=s,this.attachDomPortal=o=>{const a=o.element,u=this._document.createComment("dom-portal");a.parentNode.insertBefore(u,a),this.outletElement.appendChild(a),this._attachedPortal=o,super.setDisposeFn(()=>{u.parentNode&&u.parentNode.replaceChild(a,u)})},this._document=i}attachComponentPortal(t){const r=(t.componentFactoryResolver||this._componentFactoryResolver).resolveComponentFactory(t.component);let s;return t.viewContainerRef?(s=t.viewContainerRef.createComponent(r,t.viewContainerRef.length,t.injector||t.viewContainerRef.injector,t.projectableNodes||void 0),this.setDisposeFn(()=>s.destroy())):(s=r.create(t.injector||this._defaultInjector||Vs.NULL),this._appRef.attachView(s.hostView),this.setDisposeFn(()=>{this._appRef.viewCount>0&&this._appRef.detachView(s.hostView),s.destroy()})),this.outletElement.appendChild(this._getComponentRootNode(s)),this._attachedPortal=t,s}attachTemplatePortal(t){let e=t.viewContainerRef,r=e.createEmbeddedView(t.templateRef,t.context,{injector:t.injector});return r.rootNodes.forEach(s=>this.outletElement.appendChild(s)),r.detectChanges(),this.setDisposeFn(()=>{let s=e.indexOf(r);-1!==s&&e.remove(s)}),this._attachedPortal=t,r}dispose(){super.dispose(),this.outletElement.remove()}_getComponentRootNode(t){return t.hostView.rootNodes[0]}}let tk=(()=>{class n extends ek{constructor(e,r,s){super(),this._componentFactoryResolver=e,this._viewContainerRef=r,this._isInitialized=!1,this.attached=new On,this.attachDomPortal=i=>{const o=i.element,a=this._document.createComment("dom-portal");i.setAttachedHost(this),o.parentNode.insertBefore(a,o),this._getRootNode().appendChild(o),this._attachedPortal=i,super.setDisposeFn(()=>{a.parentNode&&a.parentNode.replaceChild(o,a)})},this._document=s}get portal(){return this._attachedPortal}set portal(e){this.hasAttached()&&!e&&!this._isInitialized||(this.hasAttached()&&super.detach(),e&&super.attach(e),this._attachedPortal=e||null)}get attachedRef(){return this._attachedRef}ngOnInit(){this._isInitialized=!0}ngOnDestroy(){super.dispose(),this._attachedRef=this._attachedPortal=null}attachComponentPortal(e){e.setAttachedHost(this);const r=null!=e.viewContainerRef?e.viewContainerRef:this._viewContainerRef,i=(e.componentFactoryResolver||this._componentFactoryResolver).resolveComponentFactory(e.component),o=r.createComponent(i,r.length,e.injector||r.injector,e.projectableNodes||void 0);return r!==this._viewContainerRef&&this._getRootNode().appendChild(o.hostView.rootNodes[0]),super.setDisposeFn(()=>o.destroy()),this._attachedPortal=e,this._attachedRef=o,this.attached.emit(o),o}attachTemplatePortal(e){e.setAttachedHost(this);const r=this._viewContainerRef.createEmbeddedView(e.templateRef,e.context,{injector:e.injector});return super.setDisposeFn(()=>this._viewContainerRef.clear()),this._attachedPortal=e,this._attachedRef=r,this.attached.emit(r),r}_getRootNode(){const e=this._viewContainerRef.element.nativeElement;return e.nodeType===e.ELEMENT_NODE?e:e.parentNode}}return n.\u0275fac=function(e){return new(e||n)(Ee(Nd),Ee(lo),Ee(xn))},n.\u0275dir=Pt({type:n,selectors:[["","cdkPortalOutlet",""]],inputs:{portal:["cdkPortalOutlet","portal"]},outputs:{attached:"attached"},exportAs:["cdkPortalOutlet"],features:[cn]}),n})(),lw=(()=>{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275mod=ar({type:n}),n.\u0275inj=Jn({}),n})();const pG=l2e();class v2e{constructor(t,e){this._viewportRuler=t,this._previousHTMLStyles={top:"",left:""},this._isEnabled=!1,this._document=e}attach(){}enable(){if(this._canBeEnabled()){const t=this._document.documentElement;this._previousScrollPosition=this._viewportRuler.getViewportScrollPosition(),this._previousHTMLStyles.left=t.style.left||"",this._previousHTMLStyles.top=t.style.top||"",t.style.left=ns(-this._previousScrollPosition.left),t.style.top=ns(-this._previousScrollPosition.top),t.classList.add("cdk-global-scrollblock"),this._isEnabled=!0}}disable(){if(this._isEnabled){const t=this._document.documentElement,r=t.style,s=this._document.body.style,i=r.scrollBehavior||"",o=s.scrollBehavior||"";this._isEnabled=!1,r.left=this._previousHTMLStyles.left,r.top=this._previousHTMLStyles.top,t.classList.remove("cdk-global-scrollblock"),pG&&(r.scrollBehavior=s.scrollBehavior="auto"),window.scroll(this._previousScrollPosition.left,this._previousScrollPosition.top),pG&&(r.scrollBehavior=i,s.scrollBehavior=o)}}_canBeEnabled(){if(this._document.documentElement.classList.contains("cdk-global-scrollblock")||this._isEnabled)return!1;const e=this._document.body,r=this._viewportRuler.getViewportSize();return e.scrollHeight>r.height||e.scrollWidth>r.width}}class w2e{constructor(t,e,r,s){this._scrollDispatcher=t,this._ngZone=e,this._viewportRuler=r,this._config=s,this._scrollSubscription=null,this._detach=()=>{this.disable(),this._overlayRef.hasAttached()&&this._ngZone.run(()=>this._overlayRef.detach())}}attach(t){this._overlayRef=t}enable(){if(this._scrollSubscription)return;const t=this._scrollDispatcher.scrolled(0).pipe(ti(e=>!e||!this._overlayRef.overlayElement.contains(e.getElementRef().nativeElement)));this._config&&this._config.threshold&&this._config.threshold>1?(this._initialScrollPosition=this._viewportRuler.getViewportScrollPosition().top,this._scrollSubscription=t.subscribe(()=>{const e=this._viewportRuler.getViewportScrollPosition().top;Math.abs(e-this._initialScrollPosition)>this._config.threshold?this._detach():this._overlayRef.updatePosition()})):this._scrollSubscription=t.subscribe(this._detach)}disable(){this._scrollSubscription&&(this._scrollSubscription.unsubscribe(),this._scrollSubscription=null)}detach(){this.disable(),this._overlayRef=null}}class fG{enable(){}disable(){}attach(){}}function nk(n,t){return t.some(e=>n.bottom<e.top||n.top>e.bottom||n.right<e.left||n.left>e.right)}function mG(n,t){return t.some(e=>n.top<e.top||n.bottom>e.bottom||n.left<e.left||n.right>e.right)}class x2e{constructor(t,e,r,s){this._scrollDispatcher=t,this._viewportRuler=e,this._ngZone=r,this._config=s,this._scrollSubscription=null}attach(t){this._overlayRef=t}enable(){this._scrollSubscription||(this._scrollSubscription=this._scrollDispatcher.scrolled(this._config?this._config.scrollThrottle:0).subscribe(()=>{if(this._overlayRef.updatePosition(),this._config&&this._config.autoClose){const e=this._overlayRef.overlayElement.getBoundingClientRect(),{width:r,height:s}=this._viewportRuler.getViewportSize();nk(e,[{width:r,height:s,bottom:s,right:r,top:0,left:0}])&&(this.disable(),this._ngZone.run(()=>this._overlayRef.detach()))}}))}disable(){this._scrollSubscription&&(this._scrollSubscription.unsubscribe(),this._scrollSubscription=null)}detach(){this.disable(),this._overlayRef=null}}let T2e=(()=>{class n{constructor(e,r,s,i){this._scrollDispatcher=e,this._viewportRuler=r,this._ngZone=s,this.noop=()=>new fG,this.close=o=>new w2e(this._scrollDispatcher,this._ngZone,this._viewportRuler,o),this.block=()=>new v2e(this._viewportRuler,this._document),this.reposition=o=>new x2e(this._scrollDispatcher,this._viewportRuler,this._ngZone,o),this._document=i}}return n.\u0275fac=function(e){return new(e||n)(Le(g2e),Le(uG),Le(Zt),Le(xn))},n.\u0275prov=ht({token:n,factory:n.\u0275fac,providedIn:"root"}),n})();class gG{constructor(t){if(this.scrollStrategy=new fG,this.panelClass="",this.hasBackdrop=!1,this.backdropClass="cdk-overlay-dark-backdrop",this.disposeOnNavigation=!1,t){const e=Object.keys(t);for(const r of e)void 0!==t[r]&&(this[r]=t[r])}}}class S2e{constructor(t,e){this.connectionPair=t,this.scrollableViewProperties=e}}let yG=(()=>{class n{constructor(e){this._attachedOverlays=[],this._document=e}ngOnDestroy(){this.detach()}add(e){this.remove(e),this._attachedOverlays.push(e)}remove(e){const r=this._attachedOverlays.indexOf(e);r>-1&&this._attachedOverlays.splice(r,1),0===this._attachedOverlays.length&&this.detach()}}return n.\u0275fac=function(e){return new(e||n)(Le(xn))},n.\u0275prov=ht({token:n,factory:n.\u0275fac,providedIn:"root"}),n})(),C2e=(()=>{class n extends yG{constructor(e,r){super(e),this._ngZone=r,this._keydownListener=s=>{const i=this._attachedOverlays;for(let o=i.length-1;o>-1;o--)if(i[o]._keydownEvents.observers.length>0){const a=i[o]._keydownEvents;this._ngZone?this._ngZone.run(()=>a.next(s)):a.next(s);break}}}add(e){super.add(e),this._isAttached||(this._ngZone?this._ngZone.runOutsideAngular(()=>this._document.body.addEventListener("keydown",this._keydownListener)):this._document.body.addEventListener("keydown",this._keydownListener),this._isAttached=!0)}detach(){this._isAttached&&(this._document.body.removeEventListener("keydown",this._keydownListener),this._isAttached=!1)}}return n.\u0275fac=function(e){return new(e||n)(Le(xn),Le(Zt,8))},n.\u0275prov=ht({token:n,factory:n.\u0275fac,providedIn:"root"}),n})(),I2e=(()=>{class n extends yG{constructor(e,r,s){super(e),this._platform=r,this._ngZone=s,this._cursorStyleIsSet=!1,this._pointerDownListener=i=>{this._pointerDownEventTarget=Nu(i)},this._clickListener=i=>{const o=Nu(i),a="click"===i.type&&this._pointerDownEventTarget?this._pointerDownEventTarget:o;this._pointerDownEventTarget=null;const u=this._attachedOverlays.slice();for(let c=u.length-1;c>-1;c--){const p=u[c];if(p._outsidePointerEvents.observers.length<1||!p.hasAttached())continue;if(p.overlayElement.contains(o)||p.overlayElement.contains(a))break;const m=p._outsidePointerEvents;this._ngZone?this._ngZone.run(()=>m.next(i)):m.next(i)}}}add(e){if(super.add(e),!this._isAttached){const r=this._document.body;this._ngZone?this._ngZone.runOutsideAngular(()=>this._addEventListeners(r)):this._addEventListeners(r),this._platform.IOS&&!this._cursorStyleIsSet&&(this._cursorOriginalValue=r.style.cursor,r.style.cursor="pointer",this._cursorStyleIsSet=!0),this._isAttached=!0}}detach(){if(this._isAttached){const e=this._document.body;e.removeEventListener("pointerdown",this._pointerDownListener,!0),e.removeEventListener("click",this._clickListener,!0),e.removeEventListener("auxclick",this._clickListener,!0),e.removeEventListener("contextmenu",this._clickListener,!0),this._platform.IOS&&this._cursorStyleIsSet&&(e.style.cursor=this._cursorOriginalValue,this._cursorStyleIsSet=!1),this._isAttached=!1}}_addEventListeners(e){e.addEventListener("pointerdown",this._pointerDownListener,!0),e.addEventListener("click",this._clickListener,!0),e.addEventListener("auxclick",this._clickListener,!0),e.addEventListener("contextmenu",this._clickListener,!0)}}return n.\u0275fac=function(e){return new(e||n)(Le(xn),Le(No),Le(Zt,8))},n.\u0275prov=ht({token:n,factory:n.\u0275fac,providedIn:"root"}),n})(),uw=(()=>{class n{constructor(e,r){this._platform=r,this._document=e}ngOnDestroy(){this._containerElement?.remove()}getContainerElement(){return this._containerElement||this._createContainer(),this._containerElement}_createContainer(){const e="cdk-overlay-container";if(this._platform.isBrowser||YA()){const s=this._document.querySelectorAll(`.${e}[platform="server"], .${e}[platform="test"]`);for(let i=0;i<s.length;i++)s[i].remove()}const r=this._document.createElement("div");r.classList.add(e),YA()?r.setAttribute("platform","test"):this._platform.isBrowser||r.setAttribute("platform","server"),this._document.body.appendChild(r),this._containerElement=r}}return n.\u0275fac=function(e){return new(e||n)(Le(xn),Le(No))},n.\u0275prov=ht({token:n,factory:n.\u0275fac,providedIn:"root"}),n})();class $g{constructor(t,e,r,s,i,o,a,u,c,p=!1){this._portalOutlet=t,this._host=e,this._pane=r,this._config=s,this._ngZone=i,this._keyboardDispatcher=o,this._document=a,this._location=u,this._outsideClickDispatcher=c,this._animationsDisabled=p,this._backdropElement=null,this._backdropClick=new vn,this._attachments=new vn,this._detachments=new vn,this._locationChanges=ce.EMPTY,this._backdropClickHandler=m=>this._backdropClick.next(m),this._backdropTransitionendHandler=m=>{this._disposeBackdrop(m.target)},this._keydownEvents=new vn,this._outsidePointerEvents=new vn,s.scrollStrategy&&(this._scrollStrategy=s.scrollStrategy,this._scrollStrategy.attach(this)),this._positionStrategy=s.positionStrategy}get overlayElement(){return this._pane}get backdropElement(){return this._backdropElement}get hostElement(){return this._host}attach(t){!this._host.parentElement&&this._previousHostParent&&this._previousHostParent.appendChild(this._host);const e=this._portalOutlet.attach(t);return this._positionStrategy&&this._positionStrategy.attach(this),this._updateStackingOrder(),this._updateElementSize(),this._updateElementDirection(),this._scrollStrategy&&this._scrollStrategy.enable(),this._ngZone.onStable.pipe(mo(1)).subscribe(()=>{this.hasAttached()&&this.updatePosition()}),this._togglePointerEvents(!0),this._config.hasBackdrop&&this._attachBackdrop(),this._config.panelClass&&this._toggleClasses(this._pane,this._config.panelClass,!0),this._attachments.next(),this._keyboardDispatcher.add(this),this._config.disposeOnNavigation&&(this._locationChanges=this._location.subscribe(()=>this.dispose())),this._outsideClickDispatcher.add(this),"function"==typeof e?.onDestroy&&e.onDestroy(()=>{this.hasAttached()&&this._ngZone.runOutsideAngular(()=>Promise.resolve().then(()=>this.detach()))}),e}detach(){if(!this.hasAttached())return;this.detachBackdrop(),this._togglePointerEvents(!1),this._positionStrategy&&this._positionStrategy.detach&&this._positionStrategy.detach(),this._scrollStrategy&&this._scrollStrategy.disable();const t=this._portalOutlet.detach();return this._detachments.next(),this._keyboardDispatcher.remove(this),this._detachContentWhenStable(),this._locationChanges.unsubscribe(),this._outsideClickDispatcher.remove(this),t}dispose(){const t=this.hasAttached();this._positionStrategy&&this._positionStrategy.dispose(),this._disposeScrollStrategy(),this._disposeBackdrop(this._backdropElement),this._locationChanges.unsubscribe(),this._keyboardDispatcher.remove(this),this._portalOutlet.dispose(),this._attachments.complete(),this._backdropClick.complete(),this._keydownEvents.complete(),this._outsidePointerEvents.complete(),this._outsideClickDispatcher.remove(this),this._host?.remove(),this._previousHostParent=this._pane=this._host=null,t&&this._detachments.next(),this._detachments.complete()}hasAttached(){return this._portalOutlet.hasAttached()}backdropClick(){return this._backdropClick}attachments(){return this._attachments}detachments(){return this._detachments}keydownEvents(){return this._keydownEvents}outsidePointerEvents(){return this._outsidePointerEvents}getConfig(){return this._config}updatePosition(){this._positionStrategy&&this._positionStrategy.apply()}updatePositionStrategy(t){t!==this._positionStrategy&&(this._positionStrategy&&this._positionStrategy.dispose(),this._positionStrategy=t,this.hasAttached()&&(t.attach(this),this.updatePosition()))}updateSize(t){this._config={...this._config,...t},this._updateElementSize()}setDirection(t){this._config={...this._config,direction:t},this._updateElementDirection()}addPanelClass(t){this._pane&&this._toggleClasses(this._pane,t,!0)}removePanelClass(t){this._pane&&this._toggleClasses(this._pane,t,!1)}getDirection(){const t=this._config.direction;return t?"string"==typeof t?t:t.value:"ltr"}updateScrollStrategy(t){t!==this._scrollStrategy&&(this._disposeScrollStrategy(),this._scrollStrategy=t,this.hasAttached()&&(t.attach(this),t.enable()))}_updateElementDirection(){this._host.setAttribute("dir",this.getDirection())}_updateElementSize(){if(!this._pane)return;const t=this._pane.style;t.width=ns(this._config.width),t.height=ns(this._config.height),t.minWidth=ns(this._config.minWidth),t.minHeight=ns(this._config.minHeight),t.maxWidth=ns(this._config.maxWidth),t.maxHeight=ns(this._config.maxHeight)}_togglePointerEvents(t){this._pane.style.pointerEvents=t?"":"none"}_attachBackdrop(){const t="cdk-overlay-backdrop-showing";this._backdropElement=this._document.createElement("div"),this._backdropElement.classList.add("cdk-overlay-backdrop"),this._animationsDisabled&&this._backdropElement.classList.add("cdk-overlay-backdrop-noop-animation"),this._config.backdropClass&&this._toggleClasses(this._backdropElement,this._config.backdropClass,!0),this._host.parentElement.insertBefore(this._backdropElement,this._host),this._backdropElement.addEventListener("click",this._backdropClickHandler),!this._animationsDisabled&&typeof requestAnimationFrame<"u"?this._ngZone.runOutsideAngular(()=>{requestAnimationFrame(()=>{this._backdropElement&&this._backdropElement.classList.add(t)})}):this._backdropElement.classList.add(t)}_updateStackingOrder(){this._host.nextSibling&&this._host.parentNode.appendChild(this._host)}detachBackdrop(){const t=this._backdropElement;if(t){if(this._animationsDisabled)return void this._disposeBackdrop(t);t.classList.remove("cdk-overlay-backdrop-showing"),this._ngZone.runOutsideAngular(()=>{t.addEventListener("transitionend",this._backdropTransitionendHandler)}),t.style.pointerEvents="none",this._backdropTimeout=this._ngZone.runOutsideAngular(()=>setTimeout(()=>{this._disposeBackdrop(t)},500))}}_toggleClasses(t,e,r){const s=tw(e||[]).filter(i=>!!i);s.length&&(r?t.classList.add(...s):t.classList.remove(...s))}_detachContentWhenStable(){this._ngZone.runOutsideAngular(()=>{const t=this._ngZone.onStable.pipe(ZA(Dt(this._attachments,this._detachments))).subscribe(()=>{(!this._pane||!this._host||0===this._pane.children.length)&&(this._pane&&this._config.panelClass&&this._toggleClasses(this._pane,this._config.panelClass,!1),this._host&&this._host.parentElement&&(this._previousHostParent=this._host.parentElement,this._host.remove()),t.unsubscribe())})})}_disposeScrollStrategy(){const t=this._scrollStrategy;t&&(t.disable(),t.detach&&t.detach())}_disposeBackdrop(t){t&&(t.removeEventListener("click",this._backdropClickHandler),t.removeEventListener("transitionend",this._backdropTransitionendHandler),t.remove(),this._backdropElement===t&&(this._backdropElement=null)),this._backdropTimeout&&(clearTimeout(this._backdropTimeout),this._backdropTimeout=void 0)}}const bG="cdk-overlay-connected-position-bounding-box",E2e=/([A-Za-z%]+)$/;class D2e{get positions(){return this._preferredPositions}constructor(t,e,r,s,i){this._viewportRuler=e,this._document=r,this._platform=s,this._overlayContainer=i,this._lastBoundingBoxSize={width:0,height:0},this._isPushed=!1,this._canPush=!0,this._growAfterOpen=!1,this._hasFlexibleDimensions=!0,this._positionLocked=!1,this._viewportMargin=0,this._scrollables=[],this._preferredPositions=[],this._positionChanges=new vn,this._resizeSubscription=ce.EMPTY,this._offsetX=0,this._offsetY=0,this._appliedPanelClasses=[],this.positionChanges=this._positionChanges,this.setOrigin(t)}attach(t){this._validatePositions(),t.hostElement.classList.add(bG),this._overlayRef=t,this._boundingBox=t.hostElement,this._pane=t.overlayElement,this._isDisposed=!1,this._isInitialRender=!0,this._lastPosition=null,this._resizeSubscription.unsubscribe(),this._resizeSubscription=this._viewportRuler.change().subscribe(()=>{this._isInitialRender=!0,this.apply()})}apply(){if(this._isDisposed||!this._platform.isBrowser)return;if(!this._isInitialRender&&this._positionLocked&&this._lastPosition)return void this.reapplyLastPosition();this._clearPanelClasses(),this._resetOverlayElementStyles(),this._resetBoundingBoxStyles(),this._viewportRect=this._getNarrowedViewportRect(),this._originRect=this._getOriginRect(),this._overlayRect=this._pane.getBoundingClientRect(),this._containerRect=this._overlayContainer.getContainerElement().getBoundingClientRect();const t=this._originRect,e=this._overlayRect,r=this._viewportRect,s=this._containerRect,i=[];let o;for(let a of this._preferredPositions){let u=this._getOriginPoint(t,s,a),c=this._getOverlayPoint(u,e,a),p=this._getOverlayFit(c,e,r,a);if(p.isCompletelyWithinViewport)return this._isPushed=!1,void this._applyPosition(a,u);this._canFitWithFlexibleDimensions(p,c,r)?i.push({position:a,origin:u,overlayRect:e,boundingBoxRect:this._calculateBoundingBoxRect(u,a)}):(!o||o.overlayFit.visibleArea<p.visibleArea)&&(o={overlayFit:p,overlayPoint:c,originPoint:u,position:a,overlayRect:e})}if(i.length){let a=null,u=-1;for(const c of i){const p=c.boundingBoxRect.width*c.boundingBoxRect.height*(c.position.weight||1);p>u&&(u=p,a=c)}return this._isPushed=!1,void this._applyPosition(a.position,a.origin)}if(this._canPush)return this._isPushed=!0,void this._applyPosition(o.position,o.originPoint);this._applyPosition(o.position,o.originPoint)}detach(){this._clearPanelClasses(),this._lastPosition=null,this._previousPushAmount=null,this._resizeSubscription.unsubscribe()}dispose(){this._isDisposed||(this._boundingBox&&Wc(this._boundingBox.style,{top:"",left:"",right:"",bottom:"",height:"",width:"",alignItems:"",justifyContent:""}),this._pane&&this._resetOverlayElementStyles(),this._overlayRef&&this._overlayRef.hostElement.classList.remove(bG),this.detach(),this._positionChanges.complete(),this._overlayRef=this._boundingBox=null,this._isDisposed=!0)}reapplyLastPosition(){if(this._isDisposed||!this._platform.isBrowser)return;const t=this._lastPosition;if(t){this._originRect=this._getOriginRect(),this._overlayRect=this._pane.getBoundingClientRect(),this._viewportRect=this._getNarrowedViewportRect(),this._containerRect=this._overlayContainer.getContainerElement().getBoundingClientRect();const e=this._getOriginPoint(this._originRect,this._containerRect,t);this._applyPosition(t,e)}else this.apply()}withScrollableContainers(t){return this._scrollables=t,this}withPositions(t){return this._preferredPositions=t,-1===t.indexOf(this._lastPosition)&&(this._lastPosition=null),this._validatePositions(),this}withViewportMargin(t){return this._viewportMargin=t,this}withFlexibleDimensions(t=!0){return this._hasFlexibleDimensions=t,this}withGrowAfterOpen(t=!0){return this._growAfterOpen=t,this}withPush(t=!0){return this._canPush=t,this}withLockedPosition(t=!0){return this._positionLocked=t,this}setOrigin(t){return this._origin=t,this}withDefaultOffsetX(t){return this._offsetX=t,this}withDefaultOffsetY(t){return this._offsetY=t,this}withTransformOriginOn(t){return this._transformOriginSelector=t,this}_getOriginPoint(t,e,r){let s,i;if("center"==r.originX)s=t.left+t.width/2;else{const o=this._isRtl()?t.right:t.left,a=this._isRtl()?t.left:t.right;s="start"==r.originX?o:a}return e.left<0&&(s-=e.left),i="center"==r.originY?t.top+t.height/2:"top"==r.originY?t.top:t.bottom,e.top<0&&(i-=e.top),{x:s,y:i}}_getOverlayPoint(t,e,r){let s,i;return s="center"==r.overlayX?-e.width/2:"start"===r.overlayX?this._isRtl()?-e.width:0:this._isRtl()?0:-e.width,i="center"==r.overlayY?-e.height/2:"top"==r.overlayY?0:-e.height,{x:t.x+s,y:t.y+i}}_getOverlayFit(t,e,r,s){const i=vG(e);let{x:o,y:a}=t,u=this._getOffset(s,"x"),c=this._getOffset(s,"y");u&&(o+=u),c&&(a+=c);let y=0-a,_=a+i.height-r.height,w=this._subtractOverflows(i.width,0-o,o+i.width-r.width),T=this._subtractOverflows(i.height,y,_),I=w*T;return{visibleArea:I,isCompletelyWithinViewport:i.width*i.height===I,fitsInViewportVertically:T===i.height,fitsInViewportHorizontally:w==i.width}}_canFitWithFlexibleDimensions(t,e,r){if(this._hasFlexibleDimensions){const s=r.bottom-e.y,i=r.right-e.x,o=_G(this._overlayRef.getConfig().minHeight),a=_G(this._overlayRef.getConfig().minWidth);return(t.fitsInViewportVertically||null!=o&&o<=s)&&(t.fitsInViewportHorizontally||null!=a&&a<=i)}return!1}_pushOverlayOnScreen(t,e,r){if(this._previousPushAmount&&this._positionLocked)return{x:t.x+this._previousPushAmount.x,y:t.y+this._previousPushAmount.y};const s=vG(e),i=this._viewportRect,o=Math.max(t.x+s.width-i.width,0),a=Math.max(t.y+s.height-i.height,0),u=Math.max(i.top-r.top-t.y,0),c=Math.max(i.left-r.left-t.x,0);let p=0,m=0;return p=s.width<=i.width?c||-o:t.x<this._viewportMargin?i.left-r.left-t.x:0,m=s.height<=i.height?u||-a:t.y<this._viewportMargin?i.top-r.top-t.y:0,this._previousPushAmount={x:p,y:m},{x:t.x+p,y:t.y+m}}_applyPosition(t,e){if(this._setTransformOrigin(t),this._setOverlayElementStyles(e,t),this._setBoundingBoxStyles(e,t),t.panelClass&&this._addPanelClasses(t.panelClass),this._lastPosition=t,this._positionChanges.observers.length){const r=this._getScrollVisibility(),s=new S2e(t,r);this._positionChanges.next(s)}this._isInitialRender=!1}_setTransformOrigin(t){if(!this._transformOriginSelector)return;const e=this._boundingBox.querySelectorAll(this._transformOriginSelector);let r,s=t.overlayY;r="center"===t.overlayX?"center":this._isRtl()?"start"===t.overlayX?"right":"left":"start"===t.overlayX?"left":"right";for(let i=0;i<e.length;i++)e[i].style.transformOrigin=`${r} ${s}`}_calculateBoundingBoxRect(t,e){const r=this._viewportRect,s=this._isRtl();let i,o,a,p,m,y;if("top"===e.overlayY)o=t.y,i=r.height-o+this._viewportMargin;else if("bottom"===e.overlayY)a=r.height-t.y+2*this._viewportMargin,i=r.height-a+this._viewportMargin;else{const _=Math.min(r.bottom-t.y+r.top,t.y),w=this._lastBoundingBoxSize.height;i=2*_,o=t.y-_,i>w&&!this._isInitialRender&&!this._growAfterOpen&&(o=t.y-w/2)}if("end"===e.overlayX&&!s||"start"===e.overlayX&&s)y=r.width-t.x+this._viewportMargin,p=t.x-this._viewportMargin;else if("start"===e.overlayX&&!s||"end"===e.overlayX&&s)m=t.x,p=r.right-t.x;else{const _=Math.min(r.right-t.x+r.left,t.x),w=this._lastBoundingBoxSize.width;p=2*_,m=t.x-_,p>w&&!this._isInitialRender&&!this._growAfterOpen&&(m=t.x-w/2)}return{top:o,left:m,bottom:a,right:y,width:p,height:i}}_setBoundingBoxStyles(t,e){const r=this._calculateBoundingBoxRect(t,e);!this._isInitialRender&&!this._growAfterOpen&&(r.height=Math.min(r.height,this._lastBoundingBoxSize.height),r.width=Math.min(r.width,this._lastBoundingBoxSize.width));const s={};if(this._hasExactPosition())s.top=s.left="0",s.bottom=s.right=s.maxHeight=s.maxWidth="",s.width=s.height="100%";else{const i=this._overlayRef.getConfig().maxHeight,o=this._overlayRef.getConfig().maxWidth;s.height=ns(r.height),s.top=ns(r.top),s.bottom=ns(r.bottom),s.width=ns(r.width),s.left=ns(r.left),s.right=ns(r.right),s.alignItems="center"===e.overlayX?"center":"end"===e.overlayX?"flex-end":"flex-start",s.justifyContent="center"===e.overlayY?"center":"bottom"===e.overlayY?"flex-end":"flex-start",i&&(s.maxHeight=ns(i)),o&&(s.maxWidth=ns(o))}this._lastBoundingBoxSize=r,Wc(this._boundingBox.style,s)}_resetBoundingBoxStyles(){Wc(this._boundingBox.style,{top:"0",left:"0",right:"0",bottom:"0",height:"",width:"",alignItems:"",justifyContent:""})}_resetOverlayElementStyles(){Wc(this._pane.style,{top:"",left:"",bottom:"",right:"",position:"",transform:""})}_setOverlayElementStyles(t,e){const r={},s=this._hasExactPosition(),i=this._hasFlexibleDimensions,o=this._overlayRef.getConfig();if(s){const p=this._viewportRuler.getViewportScrollPosition();Wc(r,this._getExactOverlayY(e,t,p)),Wc(r,this._getExactOverlayX(e,t,p))}else r.position="static";let a="",u=this._getOffset(e,"x"),c=this._getOffset(e,"y");u&&(a+=`translateX(${u}px) `),c&&(a+=`translateY(${c}px)`),r.transform=a.trim(),o.maxHeight&&(s?r.maxHeight=ns(o.maxHeight):i&&(r.maxHeight="")),o.maxWidth&&(s?r.maxWidth=ns(o.maxWidth):i&&(r.maxWidth="")),Wc(this._pane.style,r)}_getExactOverlayY(t,e,r){let s={top:"",bottom:""},i=this._getOverlayPoint(e,this._overlayRect,t);return this._isPushed&&(i=this._pushOverlayOnScreen(i,this._overlayRect,r)),"bottom"===t.overlayY?s.bottom=this._document.documentElement.clientHeight-(i.y+this._overlayRect.height)+"px":s.top=ns(i.y),s}_getExactOverlayX(t,e,r){let o,s={left:"",right:""},i=this._getOverlayPoint(e,this._overlayRect,t);return this._isPushed&&(i=this._pushOverlayOnScreen(i,this._overlayRect,r)),o=this._isRtl()?"end"===t.overlayX?"left":"right":"end"===t.overlayX?"right":"left","right"===o?s.right=this._document.documentElement.clientWidth-(i.x+this._overlayRect.width)+"px":s.left=ns(i.x),s}_getScrollVisibility(){const t=this._getOriginRect(),e=this._pane.getBoundingClientRect(),r=this._scrollables.map(s=>s.getElementRef().nativeElement.getBoundingClientRect());return{isOriginClipped:mG(t,r),isOriginOutsideView:nk(t,r),isOverlayClipped:mG(e,r),isOverlayOutsideView:nk(e,r)}}_subtractOverflows(t,...e){return e.reduce((r,s)=>r-Math.max(s,0),t)}_getNarrowedViewportRect(){const t=this._document.documentElement.clientWidth,e=this._document.documentElement.clientHeight,r=this._viewportRuler.getViewportScrollPosition();return{top:r.top+this._viewportMargin,left:r.left+this._viewportMargin,right:r.left+t-this._viewportMargin,bottom:r.top+e-this._viewportMargin,width:t-2*this._viewportMargin,height:e-2*this._viewportMargin}}_isRtl(){return"rtl"===this._overlayRef.getDirection()}_hasExactPosition(){return!this._hasFlexibleDimensions||this._isPushed}_getOffset(t,e){return"x"===e?null==t.offsetX?this._offsetX:t.offsetX:null==t.offsetY?this._offsetY:t.offsetY}_validatePositions(){}_addPanelClasses(t){this._pane&&tw(t).forEach(e=>{""!==e&&-1===this._appliedPanelClasses.indexOf(e)&&(this._appliedPanelClasses.push(e),this._pane.classList.add(e))})}_clearPanelClasses(){this._pane&&(this._appliedPanelClasses.forEach(t=>{this._pane.classList.remove(t)}),this._appliedPanelClasses=[])}_getOriginRect(){const t=this._origin;if(t instanceof tr)return t.nativeElement.getBoundingClientRect();if(t instanceof Element)return t.getBoundingClientRect();const e=t.width||0,r=t.height||0;return{top:t.y,bottom:t.y+r,left:t.x,right:t.x+e,height:r,width:e}}}function Wc(n,t){for(let e in t)t.hasOwnProperty(e)&&(n[e]=t[e]);return n}function _G(n){if("number"!=typeof n&&null!=n){const[t,e]=n.split(E2e);return e&&"px"!==e?null:parseFloat(t)}return n||null}function vG(n){return{top:Math.floor(n.top),right:Math.floor(n.right),bottom:Math.floor(n.bottom),left:Math.floor(n.left),width:Math.floor(n.width),height:Math.floor(n.height)}}const wG="cdk-global-overlay-wrapper";class A2e{constructor(){this._cssPosition="static",this._topOffset="",this._bottomOffset="",this._alignItems="",this._xPosition="",this._xOffset="",this._width="",this._height="",this._isDisposed=!1}attach(t){const e=t.getConfig();this._overlayRef=t,this._width&&!e.width&&t.updateSize({width:this._width}),this._height&&!e.height&&t.updateSize({height:this._height}),t.hostElement.classList.add(wG),this._isDisposed=!1}top(t=""){return this._bottomOffset="",this._topOffset=t,this._alignItems="flex-start",this}left(t=""){return this._xOffset=t,this._xPosition="left",this}bottom(t=""){return this._topOffset="",this._bottomOffset=t,this._alignItems="flex-end",this}right(t=""){return this._xOffset=t,this._xPosition="right",this}start(t=""){return this._xOffset=t,this._xPosition="start",this}end(t=""){return this._xOffset=t,this._xPosition="end",this}width(t=""){return this._overlayRef?this._overlayRef.updateSize({width:t}):this._width=t,this}height(t=""){return this._overlayRef?this._overlayRef.updateSize({height:t}):this._height=t,this}centerHorizontally(t=""){return this.left(t),this._xPosition="center",this}centerVertically(t=""){return this.top(t),this._alignItems="center",this}apply(){if(!this._overlayRef||!this._overlayRef.hasAttached())return;const t=this._overlayRef.overlayElement.style,e=this._overlayRef.hostElement.style,r=this._overlayRef.getConfig(),{width:s,height:i,maxWidth:o,maxHeight:a}=r,u=!("100%"!==s&&"100vw"!==s||o&&"100%"!==o&&"100vw"!==o),c=!("100%"!==i&&"100vh"!==i||a&&"100%"!==a&&"100vh"!==a),p=this._xPosition,m=this._xOffset,y="rtl"===this._overlayRef.getConfig().direction;let _="",w="",T="";u?T="flex-start":"center"===p?(T="center",y?w=m:_=m):y?"left"===p||"end"===p?(T="flex-end",_=m):("right"===p||"start"===p)&&(T="flex-start",w=m):"left"===p||"start"===p?(T="flex-start",_=m):("right"===p||"end"===p)&&(T="flex-end",w=m),t.position=this._cssPosition,t.marginLeft=u?"0":_,t.marginTop=c?"0":this._topOffset,t.marginBottom=this._bottomOffset,t.marginRight=u?"0":w,e.justifyContent=T,e.alignItems=c?"flex-start":this._alignItems}dispose(){if(this._isDisposed||!this._overlayRef)return;const t=this._overlayRef.overlayElement.style,e=this._overlayRef.hostElement,r=e.style;e.classList.remove(wG),r.justifyContent=r.alignItems=t.marginTop=t.marginBottom=t.marginLeft=t.marginRight=t.position="",this._overlayRef=null,this._isDisposed=!0}}let k2e=(()=>{class n{constructor(e,r,s,i){this._viewportRuler=e,this._document=r,this._platform=s,this._overlayContainer=i}global(){return new A2e}flexibleConnectedTo(e){return new D2e(e,this._viewportRuler,this._document,this._platform,this._overlayContainer)}}return n.\u0275fac=function(e){return new(e||n)(Le(uG),Le(xn),Le(No),Le(uw))},n.\u0275prov=ht({token:n,factory:n.\u0275fac,providedIn:"root"}),n})(),N2e=0,tp=(()=>{class n{constructor(e,r,s,i,o,a,u,c,p,m,y,_){this.scrollStrategies=e,this._overlayContainer=r,this._componentFactoryResolver=s,this._positionBuilder=i,this._keyboardDispatcher=o,this._injector=a,this._ngZone=u,this._document=c,this._directionality=p,this._location=m,this._outsideClickDispatcher=y,this._animationsModuleType=_}create(e){const r=this._createHostElement(),s=this._createPaneElement(r),i=this._createPortalOutlet(s),o=new gG(e);return o.direction=o.direction||this._directionality.value,new $g(i,r,s,o,this._ngZone,this._keyboardDispatcher,this._document,this._location,this._outsideClickDispatcher,"NoopAnimations"===this._animationsModuleType)}position(){return this._positionBuilder}_createPaneElement(e){const r=this._document.createElement("div");return r.id="cdk-overlay-"+N2e++,r.classList.add("cdk-overlay-pane"),e.appendChild(r),r}_createHostElement(){const e=this._document.createElement("div");return this._overlayContainer.getContainerElement().appendChild(e),e}_createPortalOutlet(e){return this._appRef||(this._appRef=this._injector.get(Gl)),new _2e(e,this._componentFactoryResolver,this._appRef,this._injector,this._document)}}return n.\u0275fac=function(e){return new(e||n)(Le(T2e),Le(uw),Le(Nd),Le(k2e),Le(C2e),Le(Vs),Le(Zt),Le(xn),Le(aw),Le(wf),Le(I2e),Le(Vl,8))},n.\u0275prov=ht({token:n,factory:n.\u0275fac,providedIn:"root"}),n})();const M2e={provide:new st("cdk-connected-overlay-scroll-strategy"),deps:[tp],useFactory:function R2e(n){return()=>n.scrollStrategies.reposition()}};let xG=(()=>{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275mod=ar({type:n}),n.\u0275inj=Jn({providers:[tp,M2e],imports:[Fg,lw,dG,dG]}),n})();function SG(n,...t){return t.length?t.some(e=>n[e]):n.altKey||n.shiftKey||n.ctrlKey||n.metaKey}function CG(n){return ti((t,e)=>n<=e)}function z2e(n,t){return n===t}let U2e=(()=>{class n{create(e){return typeof MutationObserver>"u"?null:new MutationObserver(e)}}return n.\u0275fac=function(e){return new(e||n)},n.\u0275prov=ht({token:n,factory:n.\u0275fac,providedIn:"root"}),n})(),j2e=(()=>{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275mod=ar({type:n}),n.\u0275inj=Jn({providers:[U2e]}),n})();const IG=new Set;let Hc,W2e=(()=>{class n{constructor(e,r){this._platform=e,this._nonce=r,this._matchMedia=this._platform.isBrowser&&window.matchMedia?window.matchMedia.bind(window):q2e}matchMedia(e){return(this._platform.WEBKIT||this._platform.BLINK)&&function H2e(n,t){if(!IG.has(n))try{Hc||(Hc=document.createElement("style"),t&&(Hc.nonce=t),Hc.setAttribute("type","text/css"),document.head.appendChild(Hc)),Hc.sheet&&(Hc.sheet.insertRule(`@media ${n} {body{ }}`,0),IG.add(n))}catch(e){console.error(e)}}(e,this._nonce),this._matchMedia(e)}}return n.\u0275fac=function(e){return new(e||n)(Le(No),Le(cT,8))},n.\u0275prov=ht({token:n,factory:n.\u0275fac,providedIn:"root"}),n})();function q2e(n){return{matches:"all"===n||""===n,media:n,addListener:()=>{},removeListener:()=>{}}}let K2e=(()=>{class n{constructor(e,r){this._mediaMatcher=e,this._zone=r,this._queries=new Map,this._destroySubject=new vn}ngOnDestroy(){this._destroySubject.next(),this._destroySubject.complete()}isMatched(e){return EG(tw(e)).some(s=>this._registerQuery(s).mql.matches)}observe(e){let i=Bb(EG(tw(e)).map(o=>this._registerQuery(o).observable));return i=Ub(i.pipe(mo(1)),i.pipe(CG(1),function G2e(n,t=HA){return An((e,r)=>{let s=null,i=null,o=null;const a=()=>{if(s){s.unsubscribe(),s=null;const c=i;i=null,r.next(c)}};function u(){const c=o+n,p=t.now();if(p<c)return s=this.schedule(void 0,c-p),void r.add(s);a()}e.subscribe(Pn(r,c=>{i=c,o=t.now(),s||(s=t.schedule(u,n),r.add(s))},()=>{a(),r.complete()},void 0,()=>{i=s=null}))})}(0))),i.pipe(ct(o=>{const a={matches:!1,breakpoints:{}};return o.forEach(({matches:u,query:c})=>{a.matches=a.matches||u,a.breakpoints[c]=u}),a}))}_registerQuery(e){if(this._queries.has(e))return this._queries.get(e);const r=this._mediaMatcher.matchMedia(e),i={observable:new Dn(o=>{const a=u=>this._zone.run(()=>o.next(u));return r.addListener(a),()=>{r.removeListener(a)}}).pipe(Gb(r),ct(({matches:o})=>({query:e,matches:o})),ZA(this._destroySubject)),mql:r};return this._queries.set(e,i),i}}return n.\u0275fac=function(e){return new(e||n)(Le(W2e),Le(Zt))},n.\u0275prov=ht({token:n,factory:n.\u0275fac,providedIn:"root"}),n})();function EG(n){return n.map(t=>t.split(",")).reduce((t,e)=>t.concat(e)).map(t=>t.trim())}let cw=(()=>{class n{constructor(e){this._platform=e}isDisabled(e){return e.hasAttribute("disabled")}isVisible(e){return function Q2e(n){return!!(n.offsetWidth||n.offsetHeight||"function"==typeof n.getClientRects&&n.getClientRects().length)}(e)&&"visible"===getComputedStyle(e).visibility}isTabbable(e){if(!this._platform.isBrowser)return!1;const r=function Z2e(n){try{return n.frameElement}catch{return null}}(function oOe(n){return n.ownerDocument&&n.ownerDocument.defaultView||window}(e));if(r&&(-1===NG(r)||!this.isVisible(r)))return!1;let s=e.nodeName.toLowerCase(),i=NG(e);return e.hasAttribute("contenteditable")?-1!==i:!("iframe"===s||"object"===s||this._platform.WEBKIT&&this._platform.IOS&&!function sOe(n){let t=n.nodeName.toLowerCase(),e="input"===t&&n.type;return"text"===e||"password"===e||"select"===t||"textarea"===t}(e))&&("audio"===s?!!e.hasAttribute("controls")&&-1!==i:"video"===s?-1!==i&&(null!==i||this._platform.FIREFOX||e.hasAttribute("controls")):e.tabIndex>=0)}isFocusable(e,r){return function iOe(n){return!function eOe(n){return function nOe(n){return"input"==n.nodeName.toLowerCase()}(n)&&"hidden"==n.type}(n)&&(function J2e(n){let t=n.nodeName.toLowerCase();return"input"===t||"select"===t||"button"===t||"textarea"===t}(n)||function tOe(n){return function rOe(n){return"a"==n.nodeName.toLowerCase()}(n)&&n.hasAttribute("href")}(n)||n.hasAttribute("contenteditable")||kG(n))}(e)&&!this.isDisabled(e)&&(r?.ignoreVisibility||this.isVisible(e))}}return n.\u0275fac=function(e){return new(e||n)(Le(No))},n.\u0275prov=ht({token:n,factory:n.\u0275fac,providedIn:"root"}),n})();function kG(n){if(!n.hasAttribute("tabindex")||void 0===n.tabIndex)return!1;let t=n.getAttribute("tabindex");return!(!t||isNaN(parseInt(t,10)))}function NG(n){if(!kG(n))return null;const t=parseInt(n.getAttribute("tabindex")||"",10);return isNaN(t)?-1:t}class aOe{get enabled(){return this._enabled}set enabled(t){this._enabled=t,this._startAnchor&&this._endAnchor&&(this._toggleAnchorTabIndex(t,this._startAnchor),this._toggleAnchorTabIndex(t,this._endAnchor))}constructor(t,e,r,s,i=!1){this._element=t,this._checker=e,this._ngZone=r,this._document=s,this._hasAttached=!1,this.startAnchorListener=()=>this.focusLastTabbableElement(),this.endAnchorListener=()=>this.focusFirstTabbableElement(),this._enabled=!0,i||this.attachAnchors()}destroy(){const t=this._startAnchor,e=this._endAnchor;t&&(t.removeEventListener("focus",this.startAnchorListener),t.remove()),e&&(e.removeEventListener("focus",this.endAnchorListener),e.remove()),this._startAnchor=this._endAnchor=null,this._hasAttached=!1}attachAnchors(){return!!this._hasAttached||(this._ngZone.runOutsideAngular(()=>{this._startAnchor||(this._startAnchor=this._createAnchor(),this._startAnchor.addEventListener("focus",this.startAnchorListener)),this._endAnchor||(this._endAnchor=this._createAnchor(),this._endAnchor.addEventListener("focus",this.endAnchorListener))}),this._element.parentNode&&(this._element.parentNode.insertBefore(this._startAnchor,this._element),this._element.parentNode.insertBefore(this._endAnchor,this._element.nextSibling),this._hasAttached=!0),this._hasAttached)}focusInitialElementWhenReady(t){return new Promise(e=>{this._executeOnStable(()=>e(this.focusInitialElement(t)))})}focusFirstTabbableElementWhenReady(t){return new Promise(e=>{this._executeOnStable(()=>e(this.focusFirstTabbableElement(t)))})}focusLastTabbableElementWhenReady(t){return new Promise(e=>{this._executeOnStable(()=>e(this.focusLastTabbableElement(t)))})}_getRegionBoundary(t){const e=this._element.querySelectorAll(`[cdk-focus-region-${t}], [cdkFocusRegion${t}], [cdk-focus-${t}]`);return"start"==t?e.length?e[0]:this._getFirstTabbableElement(this._element):e.length?e[e.length-1]:this._getLastTabbableElement(this._element)}focusInitialElement(t){const e=this._element.querySelector("[cdk-focus-initial], [cdkFocusInitial]");if(e){if(!this._checker.isFocusable(e)){const r=this._getFirstTabbableElement(e);return r?.focus(t),!!r}return e.focus(t),!0}return this.focusFirstTabbableElement(t)}focusFirstTabbableElement(t){const e=this._getRegionBoundary("start");return e&&e.focus(t),!!e}focusLastTabbableElement(t){const e=this._getRegionBoundary("end");return e&&e.focus(t),!!e}hasAttached(){return this._hasAttached}_getFirstTabbableElement(t){if(this._checker.isFocusable(t)&&this._checker.isTabbable(t))return t;const e=t.children;for(let r=0;r<e.length;r++){const s=e[r].nodeType===this._document.ELEMENT_NODE?this._getFirstTabbableElement(e[r]):null;if(s)return s}return null}_getLastTabbableElement(t){if(this._checker.isFocusable(t)&&this._checker.isTabbable(t))return t;const e=t.children;for(let r=e.length-1;r>=0;r--){const s=e[r].nodeType===this._document.ELEMENT_NODE?this._getLastTabbableElement(e[r]):null;if(s)return s}return null}_createAnchor(){const t=this._document.createElement("div");return this._toggleAnchorTabIndex(this._enabled,t),t.classList.add("cdk-visually-hidden"),t.classList.add("cdk-focus-trap-anchor"),t.setAttribute("aria-hidden","true"),t}_toggleAnchorTabIndex(t,e){t?e.setAttribute("tabindex","0"):e.removeAttribute("tabindex")}toggleAnchors(t){this._startAnchor&&this._endAnchor&&(this._toggleAnchorTabIndex(t,this._startAnchor),this._toggleAnchorTabIndex(t,this._endAnchor))}_executeOnStable(t){this._ngZone.isStable?t():this._ngZone.onStable.pipe(mo(1)).subscribe(t)}}let rk=(()=>{class n{constructor(e,r,s){this._checker=e,this._ngZone=r,this._document=s}create(e,r=!1){return new aOe(e,this._checker,this._ngZone,this._document,r)}}return n.\u0275fac=function(e){return new(e||n)(Le(cw),Le(Zt),Le(xn))},n.\u0275prov=ht({token:n,factory:n.\u0275fac,providedIn:"root"}),n})();function OG(n){return 0===n.buttons||0===n.offsetX&&0===n.offsetY}function RG(n){const t=n.touches&&n.touches[0]||n.changedTouches&&n.changedTouches[0];return!(!t||-1!==t.identifier||null!=t.radiusX&&1!==t.radiusX||null!=t.radiusY&&1!==t.radiusY)}const lOe=new st("cdk-input-modality-detector-options"),uOe={ignoreKeys:[18,17,224,91,16]},np=iw({passive:!0,capture:!0});let cOe=(()=>{class n{get mostRecentModality(){return this._modality.value}constructor(e,r,s,i){this._platform=e,this._mostRecentTarget=null,this._modality=new fo(null),this._lastTouchMs=0,this._onKeydown=o=>{this._options?.ignoreKeys?.some(a=>a===o.keyCode)||(this._modality.next("keyboard"),this._mostRecentTarget=Nu(o))},this._onMousedown=o=>{Date.now()-this._lastTouchMs<650||(this._modality.next(OG(o)?"keyboard":"mouse"),this._mostRecentTarget=Nu(o))},this._onTouchstart=o=>{RG(o)?this._modality.next("keyboard"):(this._lastTouchMs=Date.now(),this._modality.next("touch"),this._mostRecentTarget=Nu(o))},this._options={...uOe,...i},this.modalityDetected=this._modality.pipe(CG(1)),this.modalityChanged=this.modalityDetected.pipe(function B2e(n,t=Ur){return n=n??z2e,An((e,r)=>{let s,i=!0;e.subscribe(Pn(r,o=>{const a=t(o);(i||!n(s,a))&&(i=!1,s=a,r.next(o))}))})}()),e.isBrowser&&r.runOutsideAngular(()=>{s.addEventListener("keydown",this._onKeydown,np),s.addEventListener("mousedown",this._onMousedown,np),s.addEventListener("touchstart",this._onTouchstart,np)})}ngOnDestroy(){this._modality.complete(),this._platform.isBrowser&&(document.removeEventListener("keydown",this._onKeydown,np),document.removeEventListener("mousedown",this._onMousedown,np),document.removeEventListener("touchstart",this._onTouchstart,np))}}return n.\u0275fac=function(e){return new(e||n)(Le(No),Le(Zt),Le(xn),Le(lOe,8))},n.\u0275prov=ht({token:n,factory:n.\u0275fac,providedIn:"root"}),n})();const hOe=new st("cdk-focus-monitor-default-options"),dw=iw({passive:!0,capture:!0});let hw=(()=>{class n{constructor(e,r,s,i,o){this._ngZone=e,this._platform=r,this._inputModalityDetector=s,this._origin=null,this._windowFocused=!1,this._originFromTouchInteraction=!1,this._elementInfo=new Map,this._monitoredElementCount=0,this._rootNodeFocusListenerCount=new Map,this._windowFocusListener=()=>{this._windowFocused=!0,this._windowFocusTimeoutId=window.setTimeout(()=>this._windowFocused=!1)},this._stopInputModalityDetector=new vn,this._rootNodeFocusAndBlurListener=a=>{for(let c=Nu(a);c;c=c.parentElement)"focus"===a.type?this._onFocus(a,c):this._onBlur(a,c)},this._document=i,this._detectionMode=o?.detectionMode||0}monitor(e,r=!1){const s=Jh(e);if(!this._platform.isBrowser||1!==s.nodeType)return zt(null);const i=function c2e(n){if(function u2e(){if(null==KA){const n=typeof document<"u"?document.head:null;KA=!(!n||!n.createShadowRoot&&!n.attachShadow)}return KA}()){const t=n.getRootNode?n.getRootNode():null;if(typeof ShadowRoot<"u"&&ShadowRoot&&t instanceof ShadowRoot)return t}return null}(s)||this._getDocument(),o=this._elementInfo.get(s);if(o)return r&&(o.checkChildren=!0),o.subject;const a={checkChildren:r,subject:new vn,rootNode:i};return this._elementInfo.set(s,a),this._registerGlobalListeners(a),a.subject}stopMonitoring(e){const r=Jh(e),s=this._elementInfo.get(r);s&&(s.subject.complete(),this._setClasses(r),this._elementInfo.delete(r),this._removeGlobalListeners(s))}focusVia(e,r,s){const i=Jh(e);i===this._getDocument().activeElement?this._getClosestElementsInfo(i).forEach(([a,u])=>this._originChanged(a,r,u)):(this._setOrigin(r),"function"==typeof i.focus&&i.focus(s))}ngOnDestroy(){this._elementInfo.forEach((e,r)=>this.stopMonitoring(r))}_getDocument(){return this._document||document}_getWindow(){return this._getDocument().defaultView||window}_getFocusOrigin(e){return this._origin?this._originFromTouchInteraction?this._shouldBeAttributedToTouch(e)?"touch":"program":this._origin:this._windowFocused&&this._lastFocusOrigin?this._lastFocusOrigin:e&&this._isLastInteractionFromInputLabel(e)?"mouse":"program"}_shouldBeAttributedToTouch(e){return 1===this._detectionMode||!!e?.contains(this._inputModalityDetector._mostRecentTarget)}_setClasses(e,r){e.classList.toggle("cdk-focused",!!r),e.classList.toggle("cdk-touch-focused","touch"===r),e.classList.toggle("cdk-keyboard-focused","keyboard"===r),e.classList.toggle("cdk-mouse-focused","mouse"===r),e.classList.toggle("cdk-program-focused","program"===r)}_setOrigin(e,r=!1){this._ngZone.runOutsideAngular(()=>{this._origin=e,this._originFromTouchInteraction="touch"===e&&r,0===this._detectionMode&&(clearTimeout(this._originTimeoutId),this._originTimeoutId=setTimeout(()=>this._origin=null,this._originFromTouchInteraction?650:1))})}_onFocus(e,r){const s=this._elementInfo.get(r),i=Nu(e);!s||!s.checkChildren&&r!==i||this._originChanged(r,this._getFocusOrigin(i),s)}_onBlur(e,r){const s=this._elementInfo.get(r);!s||s.checkChildren&&e.relatedTarget instanceof Node&&r.contains(e.relatedTarget)||(this._setClasses(r),this._emitOrigin(s,null))}_emitOrigin(e,r){e.subject.observers.length&&this._ngZone.run(()=>e.subject.next(r))}_registerGlobalListeners(e){if(!this._platform.isBrowser)return;const r=e.rootNode,s=this._rootNodeFocusListenerCount.get(r)||0;s||this._ngZone.runOutsideAngular(()=>{r.addEventListener("focus",this._rootNodeFocusAndBlurListener,dw),r.addEventListener("blur",this._rootNodeFocusAndBlurListener,dw)}),this._rootNodeFocusListenerCount.set(r,s+1),1==++this._monitoredElementCount&&(this._ngZone.runOutsideAngular(()=>{this._getWindow().addEventListener("focus",this._windowFocusListener)}),this._inputModalityDetector.modalityDetected.pipe(ZA(this._stopInputModalityDetector)).subscribe(i=>{this._setOrigin(i,!0)}))}_removeGlobalListeners(e){const r=e.rootNode;if(this._rootNodeFocusListenerCount.has(r)){const s=this._rootNodeFocusListenerCount.get(r);s>1?this._rootNodeFocusListenerCount.set(r,s-1):(r.removeEventListener("focus",this._rootNodeFocusAndBlurListener,dw),r.removeEventListener("blur",this._rootNodeFocusAndBlurListener,dw),this._rootNodeFocusListenerCount.delete(r))}--this._monitoredElementCount||(this._getWindow().removeEventListener("focus",this._windowFocusListener),this._stopInputModalityDetector.next(),clearTimeout(this._windowFocusTimeoutId),clearTimeout(this._originTimeoutId))}_originChanged(e,r,s){this._setClasses(e,r),this._emitOrigin(s,r),this._lastFocusOrigin=r}_getClosestElementsInfo(e){const r=[];return this._elementInfo.forEach((s,i)=>{(i===e||s.checkChildren&&i.contains(e))&&r.push([i,s])}),r}_isLastInteractionFromInputLabel(e){const{_mostRecentTarget:r,mostRecentModality:s}=this._inputModalityDetector;if("mouse"!==s||!r||r===e||"INPUT"!==e.nodeName&&"TEXTAREA"!==e.nodeName||e.disabled)return!1;const i=e.labels;if(i)for(let o=0;o<i.length;o++)if(i[o].contains(r))return!0;return!1}}return n.\u0275fac=function(e){return new(e||n)(Le(Zt),Le(No),Le(cOe),Le(xn,8),Le(hOe,8))},n.\u0275prov=ht({token:n,factory:n.\u0275fac,providedIn:"root"}),n})();const PG="cdk-high-contrast-black-on-white",FG="cdk-high-contrast-white-on-black",sk="cdk-high-contrast-active";let $G=(()=>{class n{constructor(e,r){this._platform=e,this._document=r,this._breakpointSubscription=Ct(K2e).observe("(forced-colors: active)").subscribe(()=>{this._hasCheckedHighContrastMode&&(this._hasCheckedHighContrastMode=!1,this._applyBodyHighContrastModeCssClasses())})}getHighContrastMode(){if(!this._platform.isBrowser)return 0;const e=this._document.createElement("div");e.style.backgroundColor="rgb(1,2,3)",e.style.position="absolute",this._document.body.appendChild(e);const r=this._document.defaultView||window,s=r&&r.getComputedStyle?r.getComputedStyle(e):null,i=(s&&s.backgroundColor||"").replace(/ /g,"");switch(e.remove(),i){case"rgb(0,0,0)":case"rgb(45,50,54)":case"rgb(32,32,32)":return 2;case"rgb(255,255,255)":case"rgb(255,250,239)":return 1}return 0}ngOnDestroy(){this._breakpointSubscription.unsubscribe()}_applyBodyHighContrastModeCssClasses(){if(!this._hasCheckedHighContrastMode&&this._platform.isBrowser&&this._document.body){const e=this._document.body.classList;e.remove(sk,PG,FG),this._hasCheckedHighContrastMode=!0;const r=this.getHighContrastMode();1===r?e.add(sk,PG):2===r&&e.add(sk,FG)}}}return n.\u0275fac=function(e){return new(e||n)(Le(No),Le(xn))},n.\u0275prov=ht({token:n,factory:n.\u0275fac,providedIn:"root"}),n})(),pOe=(()=>{class n{constructor(e){e._applyBodyHighContrastModeCssClasses()}}return n.\u0275fac=function(e){return new(e||n)(Le($G))},n.\u0275mod=ar({type:n}),n.\u0275inj=Jn({imports:[j2e]}),n})();function fOe(n,t){}class pw{constructor(){this.role="dialog",this.panelClass="",this.hasBackdrop=!0,this.backdropClass="",this.disableClose=!1,this.width="",this.height="",this.data=null,this.ariaDescribedBy=null,this.ariaLabelledBy=null,this.ariaLabel=null,this.ariaModal=!0,this.autoFocus="first-tabbable",this.restoreFocus=!0,this.closeOnNavigation=!0,this.closeOnDestroy=!0,this.closeOnOverlayDetachments=!0}}let LG=(()=>{class n extends ek{constructor(e,r,s,i,o,a,u,c){super(),this._elementRef=e,this._focusTrapFactory=r,this._config=i,this._interactivityChecker=o,this._ngZone=a,this._overlayRef=u,this._focusMonitor=c,this._elementFocusedBeforeDialogWasOpened=null,this._closeInteractionType=null,this.attachDomPortal=p=>{this._portalOutlet.hasAttached();const m=this._portalOutlet.attachDomPortal(p);return this._contentAttached(),m},this._ariaLabelledBy=this._config.ariaLabelledBy||null,this._document=s}_contentAttached(){this._initializeFocusTrap(),this._handleBackdropClicks(),this._captureInitialFocus()}_captureInitialFocus(){this._trapFocus()}ngOnDestroy(){this._restoreFocus()}attachComponentPortal(e){this._portalOutlet.hasAttached();const r=this._portalOutlet.attachComponentPortal(e);return this._contentAttached(),r}attachTemplatePortal(e){this._portalOutlet.hasAttached();const r=this._portalOutlet.attachTemplatePortal(e);return this._contentAttached(),r}_recaptureFocus(){this._containsFocus()||this._trapFocus()}_forceFocus(e,r){this._interactivityChecker.isFocusable(e)||(e.tabIndex=-1,this._ngZone.runOutsideAngular(()=>{const s=()=>{e.removeEventListener("blur",s),e.removeEventListener("mousedown",s),e.removeAttribute("tabindex")};e.addEventListener("blur",s),e.addEventListener("mousedown",s)})),e.focus(r)}_focusByCssSelector(e,r){let s=this._elementRef.nativeElement.querySelector(e);s&&this._forceFocus(s,r)}_trapFocus(){const e=this._elementRef.nativeElement;switch(this._config.autoFocus){case!1:case"dialog":this._containsFocus()||e.focus();break;case!0:case"first-tabbable":this._focusTrap.focusInitialElementWhenReady().then(r=>{r||this._focusDialogContainer()});break;case"first-heading":this._focusByCssSelector('h1, h2, h3, h4, h5, h6, [role="heading"]');break;default:this._focusByCssSelector(this._config.autoFocus)}}_restoreFocus(){const e=this._config.restoreFocus;let r=null;if("string"==typeof e?r=this._document.querySelector(e):"boolean"==typeof e?r=e?this._elementFocusedBeforeDialogWasOpened:null:e&&(r=e),this._config.restoreFocus&&r&&"function"==typeof r.focus){const s=XA(),i=this._elementRef.nativeElement;(!s||s===this._document.body||s===i||i.contains(s))&&(this._focusMonitor?(this._focusMonitor.focusVia(r,this._closeInteractionType),this._closeInteractionType=null):r.focus())}this._focusTrap&&this._focusTrap.destroy()}_focusDialogContainer(){this._elementRef.nativeElement.focus&&this._elementRef.nativeElement.focus()}_containsFocus(){const e=this._elementRef.nativeElement,r=XA();return e===r||e.contains(r)}_initializeFocusTrap(){this._focusTrap=this._focusTrapFactory.create(this._elementRef.nativeElement),this._document&&(this._elementFocusedBeforeDialogWasOpened=XA())}_handleBackdropClicks(){this._overlayRef.backdropClick().subscribe(()=>{this._config.disableClose&&this._recaptureFocus()})}}return n.\u0275fac=function(e){return new(e||n)(Ee(tr),Ee(rk),Ee(xn,8),Ee(pw),Ee(cw),Ee(Zt),Ee($g),Ee(hw))},n.\u0275cmp=Bo({type:n,selectors:[["cdk-dialog-container"]],viewQuery:function(e,r){if(1&e&&Ul(tk,7),2&e){let s;uo(s=co())&&(r._portalOutlet=s.first)}},hostAttrs:["tabindex","-1",1,"cdk-dialog-container"],hostVars:6,hostBindings:function(e,r){2&e&&Zs("id",r._config.id||null)("role",r._config.role)("aria-modal",r._config.ariaModal)("aria-labelledby",r._config.ariaLabel?null:r._ariaLabelledBy)("aria-label",r._config.ariaLabel)("aria-describedby",r._config.ariaDescribedBy||null)},features:[cn],decls:1,vars:0,consts:[["cdkPortalOutlet",""]],template:function(e,r){1&e&&ya(0,fOe,0,0,"ng-template",0)},dependencies:[tk],styles:[".cdk-dialog-container{display:block;width:100%;height:100%;min-height:inherit;max-height:inherit}"],encapsulation:2}),n})();class ik{constructor(t,e){this.overlayRef=t,this.config=e,this.closed=new vn,this.disableClose=e.disableClose,this.backdropClick=t.backdropClick(),this.keydownEvents=t.keydownEvents(),this.outsidePointerEvents=t.outsidePointerEvents(),this.id=e.id,this.keydownEvents.subscribe(r=>{27===r.keyCode&&!this.disableClose&&!SG(r)&&(r.preventDefault(),this.close(void 0,{focusOrigin:"keyboard"}))}),this.backdropClick.subscribe(()=>{this.disableClose||this.close(void 0,{focusOrigin:"mouse"})}),this._detachSubscription=t.detachments().subscribe(()=>{!1!==e.closeOnOverlayDetachments&&this.close()})}close(t,e){if(this.containerInstance){const r=this.closed;this.containerInstance._closeInteractionType=e?.focusOrigin||"program",this._detachSubscription.unsubscribe(),this.overlayRef.dispose(),r.next(t),r.complete(),this.componentInstance=this.containerInstance=null}}updatePosition(){return this.overlayRef.updatePosition(),this}updateSize(t="",e=""){return this.overlayRef.updateSize({width:t,height:e}),this}addPanelClass(t){return this.overlayRef.addPanelClass(t),this}removePanelClass(t){return this.overlayRef.removePanelClass(t),this}}const VG=new st("DialogScrollStrategy"),mOe=new st("DialogData"),gOe=new st("DefaultDialogConfig"),bOe={provide:VG,deps:[tp],useFactory:function yOe(n){return()=>n.scrollStrategies.block()}};let _Oe=0,BG=(()=>{class n{get openDialogs(){return this._parentDialog?this._parentDialog.openDialogs:this._openDialogsAtThisLevel}get afterOpened(){return this._parentDialog?this._parentDialog.afterOpened:this._afterOpenedAtThisLevel}constructor(e,r,s,i,o,a){this._overlay=e,this._injector=r,this._defaultOptions=s,this._parentDialog=i,this._overlayContainer=o,this._openDialogsAtThisLevel=[],this._afterAllClosedAtThisLevel=new vn,this._afterOpenedAtThisLevel=new vn,this._ariaHiddenElements=new Map,this.afterAllClosed=jb(()=>this.openDialogs.length?this._getAfterAllClosed():this._getAfterAllClosed().pipe(Gb(void 0))),this._scrollStrategy=a}open(e,r){(r={...this._defaultOptions||new pw,...r}).id=r.id||"cdk-dialog-"+_Oe++,r.id&&this.getDialogById(r.id);const i=this._getOverlayConfig(r),o=this._overlay.create(i),a=new ik(o,r),u=this._attachContainer(o,a,r);return a.containerInstance=u,this._attachDialogContent(e,a,u,r),this.openDialogs.length||this._hideNonDialogContentFromAssistiveTechnology(),this.openDialogs.push(a),a.closed.subscribe(()=>this._removeOpenDialog(a,!0)),this.afterOpened.next(a),a}closeAll(){ok(this.openDialogs,e=>e.close())}getDialogById(e){return this.openDialogs.find(r=>r.id===e)}ngOnDestroy(){ok(this._openDialogsAtThisLevel,e=>{!1===e.config.closeOnDestroy&&this._removeOpenDialog(e,!1)}),ok(this._openDialogsAtThisLevel,e=>e.close()),this._afterAllClosedAtThisLevel.complete(),this._afterOpenedAtThisLevel.complete(),this._openDialogsAtThisLevel=[]}_getOverlayConfig(e){const r=new gG({positionStrategy:e.positionStrategy||this._overlay.position().global().centerHorizontally().centerVertically(),scrollStrategy:e.scrollStrategy||this._scrollStrategy(),panelClass:e.panelClass,hasBackdrop:e.hasBackdrop,direction:e.direction,minWidth:e.minWidth,minHeight:e.minHeight,maxWidth:e.maxWidth,maxHeight:e.maxHeight,width:e.width,height:e.height,disposeOnNavigation:e.closeOnNavigation});return e.backdropClass&&(r.backdropClass=e.backdropClass),r}_attachContainer(e,r,s){const i=s.injector||s.viewContainerRef?.injector,o=[{provide:pw,useValue:s},{provide:ik,useValue:r},{provide:$g,useValue:e}];let a;s.container?"function"==typeof s.container?a=s.container:(a=s.container.type,o.push(...s.container.providers(s))):a=LG;const u=new JA(a,s.viewContainerRef,Vs.create({parent:i||this._injector,providers:o}),s.componentFactoryResolver);return e.attach(u).instance}_attachDialogContent(e,r,s,i){if(e instanceof wa){const o=this._createInjector(i,r,s,void 0);let a={$implicit:i.data,dialogRef:r};i.templateContext&&(a={...a,..."function"==typeof i.templateContext?i.templateContext():i.templateContext}),s.attachTemplatePortal(new hG(e,null,a,o))}else{const o=this._createInjector(i,r,s,this._injector),a=s.attachComponentPortal(new JA(e,i.viewContainerRef,o,i.componentFactoryResolver));r.componentInstance=a.instance}}_createInjector(e,r,s,i){const o=e.injector||e.viewContainerRef?.injector,a=[{provide:mOe,useValue:e.data},{provide:ik,useValue:r}];return e.providers&&("function"==typeof e.providers?a.push(...e.providers(r,e,s)):a.push(...e.providers)),e.direction&&(!o||!o.get(aw,null,{optional:!0}))&&a.push({provide:aw,useValue:{value:e.direction,change:zt()}}),Vs.create({parent:o||i,providers:a})}_removeOpenDialog(e,r){const s=this.openDialogs.indexOf(e);s>-1&&(this.openDialogs.splice(s,1),this.openDialogs.length||(this._ariaHiddenElements.forEach((i,o)=>{i?o.setAttribute("aria-hidden",i):o.removeAttribute("aria-hidden")}),this._ariaHiddenElements.clear(),r&&this._getAfterAllClosed().next()))}_hideNonDialogContentFromAssistiveTechnology(){const e=this._overlayContainer.getContainerElement();if(e.parentElement){const r=e.parentElement.children;for(let s=r.length-1;s>-1;s--){const i=r[s];i!==e&&"SCRIPT"!==i.nodeName&&"STYLE"!==i.nodeName&&!i.hasAttribute("aria-live")&&(this._ariaHiddenElements.set(i,i.getAttribute("aria-hidden")),i.setAttribute("aria-hidden","true"))}}}_getAfterAllClosed(){const e=this._parentDialog;return e?e._getAfterAllClosed():this._afterAllClosedAtThisLevel}}return n.\u0275fac=function(e){return new(e||n)(Le(tp),Le(Vs),Le(gOe,8),Le(n,12),Le(uw),Le(VG))},n.\u0275prov=ht({token:n,factory:n.\u0275fac}),n})();function ok(n,t){let e=n.length;for(;e--;)t(n[e])}let vOe=(()=>{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275mod=ar({type:n}),n.\u0275inj=Jn({providers:[BG,bOe],imports:[xG,lw,pOe,lw]}),n})();const xOe=new st("mat-sanity-checks",{providedIn:"root",factory:function wOe(){return!0}});let qc=(()=>{class n{constructor(e,r,s){this._sanityChecks=r,this._document=s,this._hasDoneGlobalChecks=!1,e._applyBodyHighContrastModeCssClasses(),this._hasDoneGlobalChecks||(this._hasDoneGlobalChecks=!0)}_checkIsEnabled(e){return!YA()&&("boolean"==typeof this._sanityChecks?this._sanityChecks:!!this._sanityChecks[e])}}return n.\u0275fac=function(e){return new(e||n)(Le($G),Le(xOe,8),Le(xn))},n.\u0275mod=ar({type:n}),n.\u0275inj=Jn({imports:[Fg,Fg]}),n})();function TOe(n,t){return class extends n{get color(){return this._color}set color(e){const r=e||this.defaultColor;r!==this._color&&(this._color&&this._elementRef.nativeElement.classList.remove(`mat-${this._color}`),r&&this._elementRef.nativeElement.classList.add(`mat-${r}`),this._color=r)}constructor(...e){super(...e),this.defaultColor=t,this.color=t}}}function jG(n){return class extends n{get disableRipple(){return this._disableRipple}set disableRipple(t){this._disableRipple=ia(t)}constructor(...t){super(...t),this._disableRipple=!1}}}class IOe{constructor(t,e,r,s=!1){this._renderer=t,this.element=e,this.config=r,this._animationForciblyDisabledThroughCss=s,this.state=3}fadeOut(){this._renderer.fadeOutRipple(this)}}const GG=iw({passive:!0,capture:!0});class EOe{constructor(){this._events=new Map,this._delegateEventHandler=t=>{const e=Nu(t);e&&this._events.get(t.type)?.forEach((r,s)=>{(s===e||s.contains(e))&&r.forEach(i=>i.handleEvent(t))})}}addHandler(t,e,r,s){const i=this._events.get(e);if(i){const o=i.get(r);o?o.add(s):i.set(r,new Set([s]))}else this._events.set(e,new Map([[r,new Set([s])]])),t.runOutsideAngular(()=>{document.addEventListener(e,this._delegateEventHandler,GG)})}removeHandler(t,e,r){const s=this._events.get(t);if(!s)return;const i=s.get(e);i&&(i.delete(r),0===i.size&&s.delete(e),0===s.size&&(this._events.delete(t),document.removeEventListener(t,this._delegateEventHandler,GG)))}}const WG={enterDuration:225,exitDuration:150},HG=iw({passive:!0,capture:!0}),qG=["mousedown","touchstart"],KG=["mouseup","mouseleave","touchend","touchcancel"];class Vg{constructor(t,e,r,s){this._target=t,this._ngZone=e,this._platform=s,this._isPointerDown=!1,this._activeRipples=new Map,this._pointerUpEventsRegistered=!1,s.isBrowser&&(this._containerElement=Jh(r))}fadeInRipple(t,e,r={}){const s=this._containerRect=this._containerRect||this._containerElement.getBoundingClientRect(),i={...WG,...r.animation};r.centered&&(t=s.left+s.width/2,e=s.top+s.height/2);const o=r.radius||function AOe(n,t,e){const r=Math.max(Math.abs(n-e.left),Math.abs(n-e.right)),s=Math.max(Math.abs(t-e.top),Math.abs(t-e.bottom));return Math.sqrt(r*r+s*s)}(t,e,s),a=t-s.left,u=e-s.top,c=i.enterDuration,p=document.createElement("div");p.classList.add("mat-ripple-element"),p.style.left=a-o+"px",p.style.top=u-o+"px",p.style.height=2*o+"px",p.style.width=2*o+"px",null!=r.color&&(p.style.backgroundColor=r.color),p.style.transitionDuration=`${c}ms`,this._containerElement.appendChild(p);const m=window.getComputedStyle(p),_=m.transitionDuration,w="none"===m.transitionProperty||"0s"===_||"0s, 0s"===_||0===s.width&&0===s.height,T=new IOe(this,p,r,w);p.style.transform="scale3d(1, 1, 1)",T.state=0,r.persistent||(this._mostRecentTransientRipple=T);let I=null;return!w&&(c||i.exitDuration)&&this._ngZone.runOutsideAngular(()=>{const O=()=>this._finishRippleTransition(T),M=()=>this._destroyRipple(T);p.addEventListener("transitionend",O),p.addEventListener("transitioncancel",M),I={onTransitionEnd:O,onTransitionCancel:M}}),this._activeRipples.set(T,I),(w||!c)&&this._finishRippleTransition(T),T}fadeOutRipple(t){if(2===t.state||3===t.state)return;const e=t.element,r={...WG,...t.config.animation};e.style.transitionDuration=`${r.exitDuration}ms`,e.style.opacity="0",t.state=2,(t._animationForciblyDisabledThroughCss||!r.exitDuration)&&this._finishRippleTransition(t)}fadeOutAll(){this._getActiveRipples().forEach(t=>t.fadeOut())}fadeOutAllNonPersistent(){this._getActiveRipples().forEach(t=>{t.config.persistent||t.fadeOut()})}setupTriggerEvents(t){const e=Jh(t);!this._platform.isBrowser||!e||e===this._triggerElement||(this._removeTriggerEvents(),this._triggerElement=e,qG.forEach(r=>{Vg._eventManager.addHandler(this._ngZone,r,e,this)}))}handleEvent(t){"mousedown"===t.type?this._onMousedown(t):"touchstart"===t.type?this._onTouchStart(t):this._onPointerUp(),this._pointerUpEventsRegistered||(this._ngZone.runOutsideAngular(()=>{KG.forEach(e=>{this._triggerElement.addEventListener(e,this,HG)})}),this._pointerUpEventsRegistered=!0)}_finishRippleTransition(t){0===t.state?this._startFadeOutTransition(t):2===t.state&&this._destroyRipple(t)}_startFadeOutTransition(t){const e=t===this._mostRecentTransientRipple,{persistent:r}=t.config;t.state=1,!r&&(!e||!this._isPointerDown)&&t.fadeOut()}_destroyRipple(t){const e=this._activeRipples.get(t)??null;this._activeRipples.delete(t),this._activeRipples.size||(this._containerRect=null),t===this._mostRecentTransientRipple&&(this._mostRecentTransientRipple=null),t.state=3,null!==e&&(t.element.removeEventListener("transitionend",e.onTransitionEnd),t.element.removeEventListener("transitioncancel",e.onTransitionCancel)),t.element.remove()}_onMousedown(t){const e=OG(t),r=this._lastTouchStartEvent&&Date.now()<this._lastTouchStartEvent+800;!this._target.rippleDisabled&&!e&&!r&&(this._isPointerDown=!0,this.fadeInRipple(t.clientX,t.clientY,this._target.rippleConfig))}_onTouchStart(t){if(!this._target.rippleDisabled&&!RG(t)){this._lastTouchStartEvent=Date.now(),this._isPointerDown=!0;const e=t.changedTouches;for(let r=0;r<e.length;r++)this.fadeInRipple(e[r].clientX,e[r].clientY,this._target.rippleConfig)}}_onPointerUp(){this._isPointerDown&&(this._isPointerDown=!1,this._getActiveRipples().forEach(t=>{!t.config.persistent&&(1===t.state||t.config.terminateOnPointerUp&&0===t.state)&&t.fadeOut()}))}_getActiveRipples(){return Array.from(this._activeRipples.keys())}_removeTriggerEvents(){const t=this._triggerElement;t&&(qG.forEach(e=>Vg._eventManager.removeHandler(e,t,this)),this._pointerUpEventsRegistered&&KG.forEach(e=>t.removeEventListener(e,this,HG)))}}Vg._eventManager=new EOe;const XG=new st("mat-ripple-global-options");let ak=(()=>{class n{get disabled(){return this._disabled}set disabled(e){e&&this.fadeOutAllNonPersistent(),this._disabled=e,this._setupTriggerEventsIfEnabled()}get trigger(){return this._trigger||this._elementRef.nativeElement}set trigger(e){this._trigger=e,this._setupTriggerEventsIfEnabled()}constructor(e,r,s,i,o){this._elementRef=e,this._animationMode=o,this.radius=0,this._disabled=!1,this._isInitialized=!1,this._globalOptions=i||{},this._rippleRenderer=new Vg(this,r,e,s)}ngOnInit(){this._isInitialized=!0,this._setupTriggerEventsIfEnabled()}ngOnDestroy(){this._rippleRenderer._removeTriggerEvents()}fadeOutAll(){this._rippleRenderer.fadeOutAll()}fadeOutAllNonPersistent(){this._rippleRenderer.fadeOutAllNonPersistent()}get rippleConfig(){return{centered:this.centered,radius:this.radius,color:this.color,animation:{...this._globalOptions.animation,..."NoopAnimations"===this._animationMode?{enterDuration:0,exitDuration:0}:{},...this.animation},terminateOnPointerUp:this._globalOptions.terminateOnPointerUp}}get rippleDisabled(){return this.disabled||!!this._globalOptions.disabled}_setupTriggerEventsIfEnabled(){!this.disabled&&this._isInitialized&&this._rippleRenderer.setupTriggerEvents(this.trigger)}launch(e,r=0,s){return"number"==typeof e?this._rippleRenderer.fadeInRipple(e,r,{...this.rippleConfig,...s}):this._rippleRenderer.fadeInRipple(0,0,{...this.rippleConfig,...e})}}return n.\u0275fac=function(e){return new(e||n)(Ee(tr),Ee(Zt),Ee(No),Ee(XG,8),Ee(Vl,8))},n.\u0275dir=Pt({type:n,selectors:[["","mat-ripple",""],["","matRipple",""]],hostAttrs:[1,"mat-ripple"],hostVars:2,hostBindings:function(e,r){2&e&&ba("mat-ripple-unbounded",r.unbounded)},inputs:{color:["matRippleColor","color"],unbounded:["matRippleUnbounded","unbounded"],centered:["matRippleCentered","centered"],radius:["matRippleRadius","radius"],animation:["matRippleAnimation","animation"],disabled:["matRippleDisabled","disabled"],trigger:["matRippleTrigger","trigger"]},exportAs:["matRipple"]}),n})(),YG=(()=>{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275mod=ar({type:n}),n.\u0275inj=Jn({imports:[qc,qc]}),n})();class ZG{}class kOe{}const Tl="*";function eW(n,t=null){return{type:2,steps:n,options:t}}function rp(n){return{type:6,styles:n,offset:null}}function iW(n){Promise.resolve().then(n)}class Bg{constructor(t=0,e=0){this._onDoneFns=[],this._onStartFns=[],this._onDestroyFns=[],this._originalOnDoneFns=[],this._originalOnStartFns=[],this._started=!1,this._destroyed=!1,this._finished=!1,this._position=0,this.parentPlayer=null,this.totalTime=t+e}_onFinish(){this._finished||(this._finished=!0,this._onDoneFns.forEach(t=>t()),this._onDoneFns=[])}onStart(t){this._originalOnStartFns.push(t),this._onStartFns.push(t)}onDone(t){this._originalOnDoneFns.push(t),this._onDoneFns.push(t)}onDestroy(t){this._onDestroyFns.push(t)}hasStarted(){return this._started}init(){}play(){this.hasStarted()||(this._onStart(),this.triggerMicrotask()),this._started=!0}triggerMicrotask(){iW(()=>this._onFinish())}_onStart(){this._onStartFns.forEach(t=>t()),this._onStartFns=[]}pause(){}restart(){}finish(){this._onFinish()}destroy(){this._destroyed||(this._destroyed=!0,this.hasStarted()||this._onStart(),this.finish(),this._onDestroyFns.forEach(t=>t()),this._onDestroyFns=[])}reset(){this._started=!1,this._finished=!1,this._onStartFns=this._originalOnStartFns,this._onDoneFns=this._originalOnDoneFns}setPosition(t){this._position=this.totalTime?t*this.totalTime:1}getPosition(){return this.totalTime?this._position/this.totalTime:1}triggerCallback(t){const e="start"==t?this._onStartFns:this._onDoneFns;e.forEach(r=>r()),e.length=0}}class oW{constructor(t){this._onDoneFns=[],this._onStartFns=[],this._finished=!1,this._started=!1,this._destroyed=!1,this._onDestroyFns=[],this.parentPlayer=null,this.totalTime=0,this.players=t;let e=0,r=0,s=0;const i=this.players.length;0==i?iW(()=>this._onFinish()):this.players.forEach(o=>{o.onDone(()=>{++e==i&&this._onFinish()}),o.onDestroy(()=>{++r==i&&this._onDestroy()}),o.onStart(()=>{++s==i&&this._onStart()})}),this.totalTime=this.players.reduce((o,a)=>Math.max(o,a.totalTime),0)}_onFinish(){this._finished||(this._finished=!0,this._onDoneFns.forEach(t=>t()),this._onDoneFns=[])}init(){this.players.forEach(t=>t.init())}onStart(t){this._onStartFns.push(t)}_onStart(){this.hasStarted()||(this._started=!0,this._onStartFns.forEach(t=>t()),this._onStartFns=[])}onDone(t){this._onDoneFns.push(t)}onDestroy(t){this._onDestroyFns.push(t)}hasStarted(){return this._started}play(){this.parentPlayer||this.init(),this._onStart(),this.players.forEach(t=>t.play())}pause(){this.players.forEach(t=>t.pause())}restart(){this.players.forEach(t=>t.restart())}finish(){this._onFinish(),this.players.forEach(t=>t.finish())}destroy(){this._onDestroy()}_onDestroy(){this._destroyed||(this._destroyed=!0,this._onFinish(),this.players.forEach(t=>t.destroy()),this._onDestroyFns.forEach(t=>t()),this._onDestroyFns=[])}reset(){this.players.forEach(t=>t.reset()),this._destroyed=!1,this._finished=!1,this._started=!1}setPosition(t){const e=t*this.totalTime;this.players.forEach(r=>{const s=r.totalTime?Math.min(1,e/r.totalTime):1;r.setPosition(s)})}getPosition(){const t=this.players.reduce((e,r)=>null===e||r.totalTime>e.totalTime?r:e,null);return null!=t?t.getPosition():0}beforeDestroy(){this.players.forEach(t=>{t.beforeDestroy&&t.beforeDestroy()})}triggerCallback(t){const e="start"==t?this._onStartFns:this._onDoneFns;e.forEach(r=>r()),e.length=0}}const lk="!";function OOe(n,t){}class fw{constructor(){this.role="dialog",this.panelClass="",this.hasBackdrop=!0,this.backdropClass="",this.disableClose=!1,this.width="",this.height="",this.maxWidth="80vw",this.data=null,this.ariaDescribedBy=null,this.ariaLabelledBy=null,this.ariaLabel=null,this.ariaModal=!0,this.autoFocus="first-tabbable",this.restoreFocus=!0,this.delayFocusTrap=!0,this.closeOnNavigation=!0}}const uk="mdc-dialog--open",aW="mdc-dialog--opening",lW="mdc-dialog--closing";let POe=(()=>{class n extends LG{constructor(e,r,s,i,o,a,u,c){super(e,r,s,i,o,a,u,c),this._animationStateChanged=new On}_captureInitialFocus(){this._config.delayFocusTrap||this._trapFocus()}_openAnimationDone(e){this._config.delayFocusTrap&&this._trapFocus(),this._animationStateChanged.next({state:"opened",totalTime:e})}}return n.\u0275fac=function(e){return new(e||n)(Ee(tr),Ee(rk),Ee(xn,8),Ee(fw),Ee(cw),Ee(Zt),Ee($g),Ee(hw))},n.\u0275cmp=Bo({type:n,selectors:[["ng-component"]],features:[cn],decls:0,vars:0,template:function(e,r){},encapsulation:2}),n})();const uW="--mat-dialog-transition-duration";function cW(n){return null==n?null:"number"==typeof n?n:n.endsWith("ms")?ci(n.substring(0,n.length-2)):n.endsWith("s")?1e3*ci(n.substring(0,n.length-1)):"0"===n?0:null}let FOe=(()=>{class n extends POe{constructor(e,r,s,i,o,a,u,c,p){super(e,r,s,i,o,a,u,p),this._animationMode=c,this._animationsEnabled="NoopAnimations"!==this._animationMode,this._hostElement=this._elementRef.nativeElement,this._openAnimationDuration=this._animationsEnabled?cW(this._config.enterAnimationDuration)??150:0,this._closeAnimationDuration=this._animationsEnabled?cW(this._config.exitAnimationDuration)??75:0,this._animationTimer=null,this._finishDialogOpen=()=>{this._clearAnimationClasses(),this._openAnimationDone(this._openAnimationDuration)},this._finishDialogClose=()=>{this._clearAnimationClasses(),this._animationStateChanged.emit({state:"closed",totalTime:this._closeAnimationDuration})}}_contentAttached(){super._contentAttached(),this._startOpenAnimation()}ngOnDestroy(){super.ngOnDestroy(),null!==this._animationTimer&&clearTimeout(this._animationTimer)}_startOpenAnimation(){this._animationStateChanged.emit({state:"opening",totalTime:this._openAnimationDuration}),this._animationsEnabled?(this._hostElement.style.setProperty(uW,`${this._openAnimationDuration}ms`),this._requestAnimationFrame(()=>this._hostElement.classList.add(aW,uk)),this._waitForAnimationToComplete(this._openAnimationDuration,this._finishDialogOpen)):(this._hostElement.classList.add(uk),Promise.resolve().then(()=>this._finishDialogOpen()))}_startExitAnimation(){this._animationStateChanged.emit({state:"closing",totalTime:this._closeAnimationDuration}),this._hostElement.classList.remove(uk),this._animationsEnabled?(this._hostElement.style.setProperty(uW,`${this._openAnimationDuration}ms`),this._requestAnimationFrame(()=>this._hostElement.classList.add(lW)),this._waitForAnimationToComplete(this._closeAnimationDuration,this._finishDialogClose)):Promise.resolve().then(()=>this._finishDialogClose())}_clearAnimationClasses(){this._hostElement.classList.remove(aW,lW)}_waitForAnimationToComplete(e,r){null!==this._animationTimer&&clearTimeout(this._animationTimer),this._animationTimer=setTimeout(r,e)}_requestAnimationFrame(e){this._ngZone.runOutsideAngular(()=>{"function"==typeof requestAnimationFrame?requestAnimationFrame(e):e()})}}return n.\u0275fac=function(e){return new(e||n)(Ee(tr),Ee(rk),Ee(xn,8),Ee(fw),Ee(cw),Ee(Zt),Ee($g),Ee(Vl,8),Ee(hw))},n.\u0275cmp=Bo({type:n,selectors:[["mat-dialog-container"]],hostAttrs:["tabindex","-1",1,"mat-mdc-dialog-container","mdc-dialog"],hostVars:8,hostBindings:function(e,r){2&e&&(QT("id",r._config.id),Zs("aria-modal",r._config.ariaModal)("role",r._config.role)("aria-labelledby",r._config.ariaLabel?null:r._ariaLabelledBy)("aria-label",r._config.ariaLabel)("aria-describedby",r._config.ariaDescribedBy||null),ba("_mat-animation-noopable",!r._animationsEnabled))},features:[cn],decls:3,vars:0,consts:[[1,"mdc-dialog__container"],[1,"mat-mdc-dialog-surface","mdc-dialog__surface"],["cdkPortalOutlet",""]],template:function(e,r){1&e&&(nn(0,"div",0)(1,"div",1),ya(2,OOe,0,0,"ng-template",2),Yt()())},dependencies:[tk],styles:['.mdc-elevation-overlay{position:absolute;border-radius:inherit;pointer-events:none;opacity:var(--mdc-elevation-overlay-opacity, 0);transition:opacity 280ms cubic-bezier(0.4, 0, 0.2, 1)}.mdc-dialog,.mdc-dialog__scrim{position:fixed;top:0;left:0;align-items:center;justify-content:center;box-sizing:border-box;width:100%;height:100%}.mdc-dialog{display:none;z-index:var(--mdc-dialog-z-index, 7)}.mdc-dialog .mdc-dialog__content{padding:20px 24px 20px 24px}.mdc-dialog .mdc-dialog__surface{min-width:280px}@media(max-width: 592px){.mdc-dialog .mdc-dialog__surface{max-width:calc(100vw - 32px)}}@media(min-width: 592px){.mdc-dialog .mdc-dialog__surface{max-width:560px}}.mdc-dialog .mdc-dialog__surface{max-height:calc(100% - 32px)}.mdc-dialog.mdc-dialog--fullscreen .mdc-dialog__surface{max-width:none}@media(max-width: 960px){.mdc-dialog.mdc-dialog--fullscreen .mdc-dialog__surface{max-height:560px;width:560px}.mdc-dialog.mdc-dialog--fullscreen .mdc-dialog__surface .mdc-dialog__close{right:-12px}}@media(max-width: 720px)and (max-width: 672px){.mdc-dialog.mdc-dialog--fullscreen .mdc-dialog__surface{width:calc(100vw - 112px)}}@media(max-width: 720px)and (min-width: 672px){.mdc-dialog.mdc-dialog--fullscreen .mdc-dialog__surface{width:560px}}@media(max-width: 720px)and (max-height: 720px){.mdc-dialog.mdc-dialog--fullscreen .mdc-dialog__surface{max-height:calc(100vh - 160px)}}@media(max-width: 720px)and (min-height: 720px){.mdc-dialog.mdc-dialog--fullscreen .mdc-dialog__surface{max-height:560px}}@media(max-width: 720px){.mdc-dialog.mdc-dialog--fullscreen .mdc-dialog__surface .mdc-dialog__close{right:-12px}}@media(max-width: 720px)and (max-height: 400px),(max-width: 600px),(min-width: 720px)and (max-height: 400px){.mdc-dialog.mdc-dialog--fullscreen .mdc-dialog__surface{height:100%;max-height:100vh;max-width:100vw;width:100vw;border-radius:0}.mdc-dialog.mdc-dialog--fullscreen .mdc-dialog__surface .mdc-dialog__close{order:-1;left:-12px}.mdc-dialog.mdc-dialog--fullscreen .mdc-dialog__surface .mdc-dialog__header{padding:0 16px 9px;justify-content:flex-start}.mdc-dialog.mdc-dialog--fullscreen .mdc-dialog__surface .mdc-dialog__title{margin-left:calc(16px - 2 * 12px)}}@media(min-width: 960px){.mdc-dialog.mdc-dialog--fullscreen .mdc-dialog__surface{width:calc(100vw - 400px)}.mdc-dialog.mdc-dialog--fullscreen .mdc-dialog__surface .mdc-dialog__close{right:-12px}}.mdc-dialog.mdc-dialog__scrim--hidden .mdc-dialog__scrim{opacity:0}.mdc-dialog__scrim{opacity:0;z-index:-1}.mdc-dialog__container{display:flex;flex-direction:row;align-items:center;justify-content:space-around;box-sizing:border-box;height:100%;transform:scale(0.8);opacity:0;pointer-events:none}.mdc-dialog__surface{position:relative;display:flex;flex-direction:column;flex-grow:0;flex-shrink:0;box-sizing:border-box;max-width:100%;max-height:100%;pointer-events:auto;overflow-y:auto;outline:0}.mdc-dialog__surface .mdc-elevation-overlay{width:100%;height:100%;top:0;left:0}[dir=rtl] .mdc-dialog__surface,.mdc-dialog__surface[dir=rtl]{text-align:right}@media screen and (forced-colors: active),(-ms-high-contrast: active){.mdc-dialog__surface{outline:2px solid windowText}}.mdc-dialog__surface::before{position:absolute;box-sizing:border-box;width:100%;height:100%;top:0;left:0;border:2px solid rgba(0,0,0,0);border-radius:inherit;content:"";pointer-events:none}@media screen and (forced-colors: active){.mdc-dialog__surface::before{border-color:CanvasText}}@media screen and (-ms-high-contrast: active),screen and (-ms-high-contrast: none){.mdc-dialog__surface::before{content:none}}.mdc-dialog__title{display:block;margin-top:0;position:relative;flex-shrink:0;box-sizing:border-box;margin:0 0 1px;padding:0 24px 9px}.mdc-dialog__title::before{display:inline-block;width:0;height:40px;content:"";vertical-align:0}[dir=rtl] .mdc-dialog__title,.mdc-dialog__title[dir=rtl]{text-align:right}.mdc-dialog--scrollable .mdc-dialog__title{margin-bottom:1px;padding-bottom:15px}.mdc-dialog--fullscreen .mdc-dialog__header{align-items:baseline;border-bottom:1px solid rgba(0,0,0,0);display:inline-flex;justify-content:space-between;padding:0 24px 9px;z-index:1}@media screen and (forced-colors: active){.mdc-dialog--fullscreen .mdc-dialog__header{border-bottom-color:CanvasText}}.mdc-dialog--fullscreen .mdc-dialog__header .mdc-dialog__close{right:-12px}.mdc-dialog--fullscreen .mdc-dialog__title{margin-bottom:0;padding:0;border-bottom:0}.mdc-dialog--fullscreen.mdc-dialog--scrollable .mdc-dialog__title{border-bottom:0;margin-bottom:0}.mdc-dialog--fullscreen .mdc-dialog__close{top:5px}.mdc-dialog--fullscreen.mdc-dialog--scrollable .mdc-dialog__actions{border-top:1px solid rgba(0,0,0,0)}@media screen and (forced-colors: active){.mdc-dialog--fullscreen.mdc-dialog--scrollable .mdc-dialog__actions{border-top-color:CanvasText}}.mdc-dialog--fullscreen--titleless .mdc-dialog__close{margin-top:4px}.mdc-dialog--fullscreen--titleless.mdc-dialog--scrollable .mdc-dialog__close{margin-top:0}.mdc-dialog__content{flex-grow:1;box-sizing:border-box;margin:0;overflow:auto}.mdc-dialog__content>:first-child{margin-top:0}.mdc-dialog__content>:last-child{margin-bottom:0}.mdc-dialog__title+.mdc-dialog__content,.mdc-dialog__header+.mdc-dialog__content{padding-top:0}.mdc-dialog--scrollable .mdc-dialog__title+.mdc-dialog__content{padding-top:8px;padding-bottom:8px}.mdc-dialog__content .mdc-deprecated-list:first-child:last-child{padding:6px 0 0}.mdc-dialog--scrollable .mdc-dialog__content .mdc-deprecated-list:first-child:last-child{padding:0}.mdc-dialog__actions{display:flex;position:relative;flex-shrink:0;flex-wrap:wrap;align-items:center;justify-content:flex-end;box-sizing:border-box;min-height:52px;margin:0;padding:8px;border-top:1px solid rgba(0,0,0,0)}@media screen and (forced-colors: active){.mdc-dialog__actions{border-top-color:CanvasText}}.mdc-dialog--stacked .mdc-dialog__actions{flex-direction:column;align-items:flex-end}.mdc-dialog__button{margin-left:8px;margin-right:0;max-width:100%;text-align:right}[dir=rtl] .mdc-dialog__button,.mdc-dialog__button[dir=rtl]{margin-left:0;margin-right:8px}.mdc-dialog__button:first-child{margin-left:0;margin-right:0}[dir=rtl] .mdc-dialog__button:first-child,.mdc-dialog__button:first-child[dir=rtl]{margin-left:0;margin-right:0}[dir=rtl] .mdc-dialog__button,.mdc-dialog__button[dir=rtl]{text-align:left}.mdc-dialog--stacked .mdc-dialog__button:not(:first-child){margin-top:12px}.mdc-dialog--open,.mdc-dialog--opening,.mdc-dialog--closing{display:flex}.mdc-dialog--opening .mdc-dialog__scrim{transition:opacity 150ms linear}.mdc-dialog--opening .mdc-dialog__container{transition:opacity 75ms linear,transform 150ms 0ms cubic-bezier(0, 0, 0.2, 1)}.mdc-dialog--closing .mdc-dialog__scrim,.mdc-dialog--closing .mdc-dialog__container{transition:opacity 75ms linear}.mdc-dialog--closing .mdc-dialog__container{transform:none}.mdc-dialog--open .mdc-dialog__scrim{opacity:1}.mdc-dialog--open .mdc-dialog__container{transform:none;opacity:1}.mdc-dialog--open.mdc-dialog__surface-scrim--shown .mdc-dialog__surface-scrim{opacity:1}.mdc-dialog--open.mdc-dialog__surface-scrim--hiding .mdc-dialog__surface-scrim{transition:opacity 75ms linear}.mdc-dialog--open.mdc-dialog__surface-scrim--showing .mdc-dialog__surface-scrim{transition:opacity 150ms linear}.mdc-dialog__surface-scrim{display:none;opacity:0;position:absolute;width:100%;height:100%;z-index:1}.mdc-dialog__surface-scrim--shown .mdc-dialog__surface-scrim,.mdc-dialog__surface-scrim--showing .mdc-dialog__surface-scrim,.mdc-dialog__surface-scrim--hiding .mdc-dialog__surface-scrim{display:block}.mdc-dialog-scroll-lock{overflow:hidden}.mdc-dialog--no-content-padding .mdc-dialog__content{padding:0}.mdc-dialog--sheet .mdc-dialog__container .mdc-dialog__close{right:12px;top:9px;position:absolute;z-index:1}.mdc-dialog__scrim--removed{pointer-events:none}.mdc-dialog__scrim--removed .mdc-dialog__scrim,.mdc-dialog__scrim--removed .mdc-dialog__surface-scrim{display:none}.mat-mdc-dialog-content{max-height:65vh}.mat-mdc-dialog-container{position:static;display:block}.mat-mdc-dialog-container,.mat-mdc-dialog-container .mdc-dialog__container,.mat-mdc-dialog-container .mdc-dialog__surface{max-height:inherit;min-height:inherit;min-width:inherit;max-width:inherit}.mat-mdc-dialog-container .mdc-dialog__surface{display:block;width:100%;height:100%}.mat-mdc-dialog-container{--mdc-dialog-container-elevation-shadow:0px 11px 15px -7px rgba(0, 0, 0, 0.2), 0px 24px 38px 3px rgba(0, 0, 0, 0.14), 0px 9px 46px 8px rgba(0, 0, 0, 0.12);--mdc-dialog-container-shadow-color:#000;--mdc-dialog-container-shape:4px;--mdc-dialog-container-elevation: var(--mdc-dialog-container-elevation-shadow);outline:0}.mat-mdc-dialog-container .mdc-dialog__surface{background-color:var(--mdc-dialog-container-color, white)}.mat-mdc-dialog-container .mdc-dialog__surface{box-shadow:var(--mdc-dialog-container-elevation, 0px 11px 15px -7px rgba(0, 0, 0, 0.2), 0px 24px 38px 3px rgba(0, 0, 0, 0.14), 0px 9px 46px 8px rgba(0, 0, 0, 0.12))}.mat-mdc-dialog-container .mdc-dialog__surface{border-radius:var(--mdc-dialog-container-shape, 4px)}.mat-mdc-dialog-container .mdc-dialog__title{font-family:var(--mdc-dialog-subhead-font, Roboto, sans-serif);line-height:var(--mdc-dialog-subhead-line-height, 1.5rem);font-size:var(--mdc-dialog-subhead-size, 1rem);font-weight:var(--mdc-dialog-subhead-weight, 400);letter-spacing:var(--mdc-dialog-subhead-tracking, 0.03125em)}.mat-mdc-dialog-container .mdc-dialog__title{color:var(--mdc-dialog-subhead-color, rgba(0, 0, 0, 0.87))}.mat-mdc-dialog-container .mdc-dialog__content{font-family:var(--mdc-dialog-supporting-text-font, Roboto, sans-serif);line-height:var(--mdc-dialog-supporting-text-line-height, 1.5rem);font-size:var(--mdc-dialog-supporting-text-size, 1rem);font-weight:var(--mdc-dialog-supporting-text-weight, 400);letter-spacing:var(--mdc-dialog-supporting-text-tracking, 0.03125em)}.mat-mdc-dialog-container .mdc-dialog__content{color:var(--mdc-dialog-supporting-text-color, rgba(0, 0, 0, 0.6))}.mat-mdc-dialog-container .mdc-dialog__container{transition-duration:var(--mat-dialog-transition-duration, 0ms)}.mat-mdc-dialog-container._mat-animation-noopable .mdc-dialog__container{transition:none}.mat-mdc-dialog-content{display:block}.mat-mdc-dialog-actions{justify-content:start}.mat-mdc-dialog-actions.mat-mdc-dialog-actions-align-center,.mat-mdc-dialog-actions[align=center]{justify-content:center}.mat-mdc-dialog-actions.mat-mdc-dialog-actions-align-end,.mat-mdc-dialog-actions[align=end]{justify-content:flex-end}.mat-mdc-dialog-actions .mat-button-base+.mat-button-base,.mat-mdc-dialog-actions .mat-mdc-button-base+.mat-mdc-button-base{margin-left:8px}[dir=rtl] .mat-mdc-dialog-actions .mat-button-base+.mat-button-base,[dir=rtl] .mat-mdc-dialog-actions .mat-mdc-button-base+.mat-mdc-button-base{margin-left:0;margin-right:8px}'],encapsulation:2}),n})();class dW{constructor(t,e,r){this._ref=t,this._containerInstance=r,this._afterOpened=new vn,this._beforeClosed=new vn,this._state=0,this.disableClose=e.disableClose,this.id=t.id,r._animationStateChanged.pipe(ti(s=>"opened"===s.state),mo(1)).subscribe(()=>{this._afterOpened.next(),this._afterOpened.complete()}),r._animationStateChanged.pipe(ti(s=>"closed"===s.state),mo(1)).subscribe(()=>{clearTimeout(this._closeFallbackTimeout),this._finishDialogClose()}),t.overlayRef.detachments().subscribe(()=>{this._beforeClosed.next(this._result),this._beforeClosed.complete(),this._finishDialogClose()}),Dt(this.backdropClick(),this.keydownEvents().pipe(ti(s=>27===s.keyCode&&!this.disableClose&&!SG(s)))).subscribe(s=>{this.disableClose||(s.preventDefault(),function $Oe(n,t,e){n._closeInteractionType=t,n.close(e)}(this,"keydown"===s.type?"keyboard":"mouse"))})}close(t){this._result=t,this._containerInstance._animationStateChanged.pipe(ti(e=>"closing"===e.state),mo(1)).subscribe(e=>{this._beforeClosed.next(t),this._beforeClosed.complete(),this._ref.overlayRef.detachBackdrop(),this._closeFallbackTimeout=setTimeout(()=>this._finishDialogClose(),e.totalTime+100)}),this._state=1,this._containerInstance._startExitAnimation()}afterOpened(){return this._afterOpened}afterClosed(){return this._ref.closed}beforeClosed(){return this._beforeClosed}backdropClick(){return this._ref.backdropClick}keydownEvents(){return this._ref.keydownEvents}updatePosition(t){let e=this._ref.config.positionStrategy;return t&&(t.left||t.right)?t.left?e.left(t.left):e.right(t.right):e.centerHorizontally(),t&&(t.top||t.bottom)?t.top?e.top(t.top):e.bottom(t.bottom):e.centerVertically(),this._ref.updatePosition(),this}updateSize(t="",e=""){return this._ref.updateSize(t,e),this}addPanelClass(t){return this._ref.addPanelClass(t),this}removePanelClass(t){return this._ref.removePanelClass(t),this}getState(){return this._state}_finishDialogClose(){this._state=2,this._ref.close(this._result,{focusOrigin:this._closeInteractionType}),this.componentInstance=null}}const hW=new st("MatMdcDialogData"),LOe=new st("mat-mdc-dialog-default-options"),pW=new st("mat-mdc-dialog-scroll-strategy"),BOe={provide:pW,deps:[tp],useFactory:function VOe(n){return()=>n.scrollStrategies.block()}};let zOe=0,UOe=(()=>{class n{get openDialogs(){return this._parentDialog?this._parentDialog.openDialogs:this._openDialogsAtThisLevel}get afterOpened(){return this._parentDialog?this._parentDialog.afterOpened:this._afterOpenedAtThisLevel}_getAfterAllClosed(){const e=this._parentDialog;return e?e._getAfterAllClosed():this._afterAllClosedAtThisLevel}constructor(e,r,s,i,o,a,u,c,p,m){this._overlay=e,this._defaultOptions=s,this._parentDialog=i,this._dialogRefConstructor=u,this._dialogContainerType=c,this._dialogDataToken=p,this._openDialogsAtThisLevel=[],this._afterAllClosedAtThisLevel=new vn,this._afterOpenedAtThisLevel=new vn,this._idPrefix="mat-dialog-",this.dialogConfigClass=fw,this.afterAllClosed=jb(()=>this.openDialogs.length?this._getAfterAllClosed():this._getAfterAllClosed().pipe(Gb(void 0))),this._scrollStrategy=a,this._dialog=r.get(BG)}open(e,r){let s;(r={...this._defaultOptions||new fw,...r}).id=r.id||`${this._idPrefix}${zOe++}`,r.scrollStrategy=r.scrollStrategy||this._scrollStrategy();const i=this._dialog.open(e,{...r,positionStrategy:this._overlay.position().global().centerHorizontally().centerVertically(),disableClose:!0,closeOnDestroy:!1,closeOnOverlayDetachments:!1,container:{type:this._dialogContainerType,providers:()=>[{provide:this.dialogConfigClass,useValue:r},{provide:pw,useValue:r}]},templateContext:()=>({dialogRef:s}),providers:(o,a,u)=>(s=new this._dialogRefConstructor(o,r,u),s.updatePosition(r?.position),[{provide:this._dialogContainerType,useValue:u},{provide:this._dialogDataToken,useValue:a.data},{provide:this._dialogRefConstructor,useValue:s}])});return s.componentInstance=i.componentInstance,this.openDialogs.push(s),this.afterOpened.next(s),s.afterClosed().subscribe(()=>{const o=this.openDialogs.indexOf(s);o>-1&&(this.openDialogs.splice(o,1),this.openDialogs.length||this._getAfterAllClosed().next())}),s}closeAll(){this._closeDialogs(this.openDialogs)}getDialogById(e){return this.openDialogs.find(r=>r.id===e)}ngOnDestroy(){this._closeDialogs(this._openDialogsAtThisLevel),this._afterAllClosedAtThisLevel.complete(),this._afterOpenedAtThisLevel.complete()}_closeDialogs(e){let r=e.length;for(;r--;)e[r].close()}}return n.\u0275fac=function(e){eb()},n.\u0275prov=ht({token:n,factory:n.\u0275fac}),n})(),fW=(()=>{class n extends UOe{constructor(e,r,s,i,o,a,u,c){super(e,r,i,a,u,o,dW,FOe,hW,c),this._idPrefix="mat-mdc-dialog-"}}return n.\u0275fac=function(e){return new(e||n)(Le(tp),Le(Vs),Le(wf,8),Le(LOe,8),Le(pW),Le(n,12),Le(uw),Le(Vl,8))},n.\u0275prov=ht({token:n,factory:n.\u0275fac}),n})(),jOe=(()=>{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275mod=ar({type:n}),n.\u0275inj=Jn({providers:[fW,BOe],imports:[vOe,xG,lw,qc,qc]}),n})(),GOe=(()=>{class n{constructor(e,r){this.dialogRef=e,this.data=r}ngOnInit(){console.log(this.data)}}return n.\u0275fac=function(e){return new(e||n)(Ee(dW),Ee(hW))},n.\u0275cmp=Bo({type:n,selectors:[["app-image-dialog"]],decls:4,vars:2,consts:[[1,"text-xl","p-2","font-bold","text-center","text-gray-900"],[3,"src"]],template:function(e,r){1&e&&(nn(0,"div")(1,"h1",0),Er(2),Yt(),Qs(3,"img",1),Yt()),2&e&&(Sn(2),ic(" ",r.data.name," "),Sn(1),Ir("src",r.data.image,tT))}}),n})();var Oo=$(895);Oo.env.wasm.wasmPaths={"ort-wasm.wasm":"assets/onnx-wasm/ort-wasm.wasm","ort-wasm-simd.wasm":"assets/onnx-wasm/ort-wasm-simd.wasm","ort-wasm-threaded.wasm":"assets/onnx-wasm/ort-wasm-threaded.wasm"};let WOe=(()=>{class n{constructor(){}predict(e,r,s,i){var o=this;return Ve(function*(){o.session=yield Oo.InferenceSession.create("assets/onnx_models/wams-hip-1.onnx");const u=new Oo.Tensor(new Float32Array([e,r,s,i]),[1,4]);return(yield o.session.run({X:u})).variable.data[0]})()}}return n.\u0275fac=function(e){return new(e||n)},n.\u0275prov=ht({token:n,factory:n.\u0275fac,providedIn:"root"}),n})();Oo.env.wasm.wasmPaths={"ort-wasm.wasm":"assets/onnx-wasm/ort-wasm.wasm","ort-wasm-simd.wasm":"assets/onnx-wasm/ort-wasm-simd.wasm","ort-wasm-threaded.wasm":"assets/onnx-wasm/ort-wasm-threaded.wasm"};let HOe=(()=>{class n{constructor(){}getConfidenceModelURLs(e){return Ve(function*(){return $Ne[e]})()}predictConfidence(e,r,s,i,o){var a=this;return Ve(function*(){a.session=yield Oo.InferenceSession.create(e);const u=new Oo.Tensor(new Float32Array([s,i,r,o]),[1,4]);return(yield a.session.run({X:u})).variable.data[0]})()}predictBase(e,r,s,i){var o=this;return Ve(function*(){o.session=yield Oo.InferenceSession.create("assets/confidence_models/lightgbm_model_1-2-2024_0.5.onnx");const u=new Oo.Tensor(new Float32Array([r,s,e,i]),[1,4]);return(yield o.session.run({X:u})).variable.data[0]})()}predict10PercentQuantile(e,r,s,i){var o=this;return Ve(function*(){o.session=yield Oo.InferenceSession.create("assets/confidence_models/lightgbm_model_1-2-2024_0.1.onnx");const u=new Oo.Tensor(new Float32Array([r,s,e,i]),[1,4]);return(yield o.session.run({X:u})).variable.data[0]})()}predict90PercentQuantile(e,r,s,i){var o=this;return Ve(function*(){o.session=yield Oo.InferenceSession.create("assets/confidence_models/lightgbm_model_1-2-2024_0.9.onnx");const u=new Oo.Tensor(new Float32Array([r,s,e,i]),[1,4]);return(yield o.session.run({X:u})).variable.data[0]})()}}return n.\u0275fac=function(e){return new(e||n)},n.\u0275prov=ht({token:n,factory:n.\u0275fac,providedIn:"root"}),n})();const Qi=new st("NgValueAccessor"),qs=new st("NgValidators"),Ru=new st("NgAsyncValidators");function EW(n){return null!=n}function DW(n){return sf(n)?nt(n):n}function AW(n){let t={};return n.forEach(e=>{t=null!=e?{...t,...e}:t}),0===Object.keys(t).length?null:t}function kW(n,t){return t.map(e=>e(n))}function NW(n){return n.map(t=>function JOe(n){return!n.validate}(t)?t:e=>t.validate(e))}function dk(n){return null!=n?function OW(n){if(!n)return null;const t=n.filter(EW);return 0==t.length?null:function(e){return AW(kW(e,t))}}(NW(n)):null}function hk(n){return null!=n?function RW(n){if(!n)return null;const t=n.filter(EW);return 0==t.length?null:function(e){return function qOe(...n){const t=gp(n),{args:e,keys:r}=y$(n),s=new Dn(i=>{const{length:o}=e;if(!o)return void i.complete();const a=new Array(o);let u=o,c=o;for(let p=0;p<o;p++){let m=!1;fs(e[p]).subscribe(Pn(i,y=>{m||(m=!0,c--),a[p]=y},()=>u--,void 0,()=>{(!u||!m)&&(c||i.next(r?b$(r,a):a),i.complete())}))}});return t?s.pipe(b1(t)):s}(kW(e,t).map(DW)).pipe(ct(AW))}}(NW(n)):null}function MW(n,t){return null===n?[t]:Array.isArray(n)?[...n,t]:[n,t]}function pk(n){return n?Array.isArray(n)?n:[n]:[]}function gw(n,t){return Array.isArray(n)?n.includes(t):n===t}function $W(n,t){const e=pk(t);return pk(n).forEach(s=>{gw(e,s)||e.push(s)}),e}function LW(n,t){return pk(t).filter(e=>!gw(n,e))}class VW{constructor(){this._rawValidators=[],this._rawAsyncValidators=[],this._onDestroyCallbacks=[]}get value(){return this.control?this.control.value:null}get valid(){return this.control?this.control.valid:null}get invalid(){return this.control?this.control.invalid:null}get pending(){return this.control?this.control.pending:null}get disabled(){return this.control?this.control.disabled:null}get enabled(){return this.control?this.control.enabled:null}get errors(){return this.control?this.control.errors:null}get pristine(){return this.control?this.control.pristine:null}get dirty(){return this.control?this.control.dirty:null}get touched(){return this.control?this.control.touched:null}get status(){return this.control?this.control.status:null}get untouched(){return this.control?this.control.untouched:null}get statusChanges(){return this.control?this.control.statusChanges:null}get valueChanges(){return this.control?this.control.valueChanges:null}get path(){return null}_setValidators(t){this._rawValidators=t||[],this._composedValidatorFn=dk(this._rawValidators)}_setAsyncValidators(t){this._rawAsyncValidators=t||[],this._composedAsyncValidatorFn=hk(this._rawAsyncValidators)}get validator(){return this._composedValidatorFn||null}get asyncValidator(){return this._composedAsyncValidatorFn||null}_registerOnDestroy(t){this._onDestroyCallbacks.push(t)}_invokeOnDestroyCallbacks(){this._onDestroyCallbacks.forEach(t=>t()),this._onDestroyCallbacks=[]}reset(t=void 0){this.control&&this.control.reset(t)}hasError(t,e){return!!this.control&&this.control.hasError(t,e)}getError(t,e){return this.control?this.control.getError(t,e):null}}class di extends VW{get formDirective(){return null}get path(){return null}}class BW{constructor(t){this._cd=t}get isTouched(){return!!this._cd?.control?.touched}get isUntouched(){return!!this._cd?.control?.untouched}get isPristine(){return!!this._cd?.control?.pristine}get isDirty(){return!!this._cd?.control?.dirty}get isValid(){return!!this._cd?.control?.valid}get isInvalid(){return!!this._cd?.control?.invalid}get isPending(){return!!this._cd?.control?.pending}get isSubmitted(){return!!this._cd?.submitted}}let zW=(()=>{class n extends BW{constructor(e){super(e)}}return n.\u0275fac=function(e){return new(e||n)(Ee(di,10))},n.\u0275dir=Pt({type:n,selectors:[["","formGroupName",""],["","formArrayName",""],["","ngModelGroup",""],["","formGroup",""],["form",3,"ngNoForm",""],["","ngForm",""]],hostVars:16,hostBindings:function(e,r){2&e&&ba("ng-untouched",r.isUntouched)("ng-touched",r.isTouched)("ng-pristine",r.isPristine)("ng-dirty",r.isDirty)("ng-valid",r.isValid)("ng-invalid",r.isInvalid)("ng-pending",r.isPending)("ng-submitted",r.isSubmitted)},features:[cn]}),n})();const zg="VALID",bw="INVALID",sp="PENDING",Ug="DISABLED";function _w(n){return null!=n&&!Array.isArray(n)&&"object"==typeof n}class WW{constructor(t,e){this._pendingDirty=!1,this._hasOwnPendingAsyncValidator=!1,this._pendingTouched=!1,this._onCollectionChange=()=>{},this._parent=null,this.pristine=!0,this.touched=!1,this._onDisabledChange=[],this._assignValidators(t),this._assignAsyncValidators(e)}get validator(){return this._composedValidatorFn}set validator(t){this._rawValidators=this._composedValidatorFn=t}get asyncValidator(){return this._composedAsyncValidatorFn}set asyncValidator(t){this._rawAsyncValidators=this._composedAsyncValidatorFn=t}get parent(){return this._parent}get valid(){return this.status===zg}get invalid(){return this.status===bw}get pending(){return this.status==sp}get disabled(){return this.status===Ug}get enabled(){return this.status!==Ug}get dirty(){return!this.pristine}get untouched(){return!this.touched}get updateOn(){return this._updateOn?this._updateOn:this.parent?this.parent.updateOn:"change"}setValidators(t){this._assignValidators(t)}setAsyncValidators(t){this._assignAsyncValidators(t)}addValidators(t){this.setValidators($W(t,this._rawValidators))}addAsyncValidators(t){this.setAsyncValidators($W(t,this._rawAsyncValidators))}removeValidators(t){this.setValidators(LW(t,this._rawValidators))}removeAsyncValidators(t){this.setAsyncValidators(LW(t,this._rawAsyncValidators))}hasValidator(t){return gw(this._rawValidators,t)}hasAsyncValidator(t){return gw(this._rawAsyncValidators,t)}clearValidators(){this.validator=null}clearAsyncValidators(){this.asyncValidator=null}markAsTouched(t={}){this.touched=!0,this._parent&&!t.onlySelf&&this._parent.markAsTouched(t)}markAllAsTouched(){this.markAsTouched({onlySelf:!0}),this._forEachChild(t=>t.markAllAsTouched())}markAsUntouched(t={}){this.touched=!1,this._pendingTouched=!1,this._forEachChild(e=>{e.markAsUntouched({onlySelf:!0})}),this._parent&&!t.onlySelf&&this._parent._updateTouched(t)}markAsDirty(t={}){this.pristine=!1,this._parent&&!t.onlySelf&&this._parent.markAsDirty(t)}markAsPristine(t={}){this.pristine=!0,this._pendingDirty=!1,this._forEachChild(e=>{e.markAsPristine({onlySelf:!0})}),this._parent&&!t.onlySelf&&this._parent._updatePristine(t)}markAsPending(t={}){this.status=sp,!1!==t.emitEvent&&this.statusChanges.emit(this.status),this._parent&&!t.onlySelf&&this._parent.markAsPending(t)}disable(t={}){const e=this._parentMarkedDirty(t.onlySelf);this.status=Ug,this.errors=null,this._forEachChild(r=>{r.disable({...t,onlySelf:!0})}),this._updateValue(),!1!==t.emitEvent&&(this.valueChanges.emit(this.value),this.statusChanges.emit(this.status)),this._updateAncestors({...t,skipPristineCheck:e}),this._onDisabledChange.forEach(r=>r(!0))}enable(t={}){const e=this._parentMarkedDirty(t.onlySelf);this.status=zg,this._forEachChild(r=>{r.enable({...t,onlySelf:!0})}),this.updateValueAndValidity({onlySelf:!0,emitEvent:t.emitEvent}),this._updateAncestors({...t,skipPristineCheck:e}),this._onDisabledChange.forEach(r=>r(!1))}_updateAncestors(t){this._parent&&!t.onlySelf&&(this._parent.updateValueAndValidity(t),t.skipPristineCheck||this._parent._updatePristine(),this._parent._updateTouched())}setParent(t){this._parent=t}getRawValue(){return this.value}updateValueAndValidity(t={}){this._setInitialStatus(),this._updateValue(),this.enabled&&(this._cancelExistingSubscription(),this.errors=this._runValidator(),this.status=this._calculateStatus(),(this.status===zg||this.status===sp)&&this._runAsyncValidator(t.emitEvent)),!1!==t.emitEvent&&(this.valueChanges.emit(this.value),this.statusChanges.emit(this.status)),this._parent&&!t.onlySelf&&this._parent.updateValueAndValidity(t)}_updateTreeValidity(t={emitEvent:!0}){this._forEachChild(e=>e._updateTreeValidity(t)),this.updateValueAndValidity({onlySelf:!0,emitEvent:t.emitEvent})}_setInitialStatus(){this.status=this._allControlsDisabled()?Ug:zg}_runValidator(){return this.validator?this.validator(this):null}_runAsyncValidator(t){if(this.asyncValidator){this.status=sp,this._hasOwnPendingAsyncValidator=!0;const e=DW(this.asyncValidator(this));this._asyncValidationSubscription=e.subscribe(r=>{this._hasOwnPendingAsyncValidator=!1,this.setErrors(r,{emitEvent:t})})}}_cancelExistingSubscription(){this._asyncValidationSubscription&&(this._asyncValidationSubscription.unsubscribe(),this._hasOwnPendingAsyncValidator=!1)}setErrors(t,e={}){this.errors=t,this._updateControlsErrors(!1!==e.emitEvent)}get(t){let e=t;return null==e||(Array.isArray(e)||(e=e.split(".")),0===e.length)?null:e.reduce((r,s)=>r&&r._find(s),this)}getError(t,e){const r=e?this.get(e):this;return r&&r.errors?r.errors[t]:null}hasError(t,e){return!!this.getError(t,e)}get root(){let t=this;for(;t._parent;)t=t._parent;return t}_updateControlsErrors(t){this.status=this._calculateStatus(),t&&this.statusChanges.emit(this.status),this._parent&&this._parent._updateControlsErrors(t)}_initObservables(){this.valueChanges=new On,this.statusChanges=new On}_calculateStatus(){return this._allControlsDisabled()?Ug:this.errors?bw:this._hasOwnPendingAsyncValidator||this._anyControlsHaveStatus(sp)?sp:this._anyControlsHaveStatus(bw)?bw:zg}_anyControlsHaveStatus(t){return this._anyControls(e=>e.status===t)}_anyControlsDirty(){return this._anyControls(t=>t.dirty)}_anyControlsTouched(){return this._anyControls(t=>t.touched)}_updatePristine(t={}){this.pristine=!this._anyControlsDirty(),this._parent&&!t.onlySelf&&this._parent._updatePristine(t)}_updateTouched(t={}){this.touched=this._anyControlsTouched(),this._parent&&!t.onlySelf&&this._parent._updateTouched(t)}_registerOnCollectionChange(t){this._onCollectionChange=t}_setUpdateStrategy(t){_w(t)&&null!=t.updateOn&&(this._updateOn=t.updateOn)}_parentMarkedDirty(t){return!t&&!(!this._parent||!this._parent.dirty)&&!this._parent._anyControlsDirty()}_find(t){return null}_assignValidators(t){this._rawValidators=Array.isArray(t)?t.slice():t,this._composedValidatorFn=function sRe(n){return Array.isArray(n)?dk(n):n||null}(this._rawValidators)}_assignAsyncValidators(t){this._rawAsyncValidators=Array.isArray(t)?t.slice():t,this._composedAsyncValidatorFn=function iRe(n){return Array.isArray(n)?hk(n):n||null}(this._rawAsyncValidators)}}class bk extends WW{constructor(t,e,r){super(function gk(n){return(_w(n)?n.validators:n)||null}(e),function yk(n,t){return(_w(t)?t.asyncValidators:n)||null}(r,e)),this.controls=t,this._initObservables(),this._setUpdateStrategy(e),this._setUpControls(),this.updateValueAndValidity({onlySelf:!0,emitEvent:!!this.asyncValidator})}registerControl(t,e){return this.controls[t]?this.controls[t]:(this.controls[t]=e,e.setParent(this),e._registerOnCollectionChange(this._onCollectionChange),e)}addControl(t,e,r={}){this.registerControl(t,e),this.updateValueAndValidity({emitEvent:r.emitEvent}),this._onCollectionChange()}removeControl(t,e={}){this.controls[t]&&this.controls[t]._registerOnCollectionChange(()=>{}),delete this.controls[t],this.updateValueAndValidity({emitEvent:e.emitEvent}),this._onCollectionChange()}setControl(t,e,r={}){this.controls[t]&&this.controls[t]._registerOnCollectionChange(()=>{}),delete this.controls[t],e&&this.registerControl(t,e),this.updateValueAndValidity({emitEvent:r.emitEvent}),this._onCollectionChange()}contains(t){return this.controls.hasOwnProperty(t)&&this.controls[t].enabled}setValue(t,e={}){(function GW(n,t,e){n._forEachChild((r,s)=>{if(void 0===e[s])throw new je(1002,"")})})(this,0,t),Object.keys(t).forEach(r=>{(function jW(n,t,e){const r=n.controls;if(!(t?Object.keys(r):r).length)throw new je(1e3,"");if(!r[e])throw new je(1001,"")})(this,!0,r),this.controls[r].setValue(t[r],{onlySelf:!0,emitEvent:e.emitEvent})}),this.updateValueAndValidity(e)}patchValue(t,e={}){null!=t&&(Object.keys(t).forEach(r=>{const s=this.controls[r];s&&s.patchValue(t[r],{onlySelf:!0,emitEvent:e.emitEvent})}),this.updateValueAndValidity(e))}reset(t={},e={}){this._forEachChild((r,s)=>{r.reset(t[s],{onlySelf:!0,emitEvent:e.emitEvent})}),this._updatePristine(e),this._updateTouched(e),this.updateValueAndValidity(e)}getRawValue(){return this._reduceChildren({},(t,e,r)=>(t[r]=e.getRawValue(),t))}_syncPendingControls(){let t=this._reduceChildren(!1,(e,r)=>!!r._syncPendingControls()||e);return t&&this.updateValueAndValidity({onlySelf:!0}),t}_forEachChild(t){Object.keys(this.controls).forEach(e=>{const r=this.controls[e];r&&t(r,e)})}_setUpControls(){this._forEachChild(t=>{t.setParent(this),t._registerOnCollectionChange(this._onCollectionChange)})}_updateValue(){this.value=this._reduceValue()}_anyControls(t){for(const[e,r]of Object.entries(this.controls))if(this.contains(e)&&t(r))return!0;return!1}_reduceValue(){return this._reduceChildren({},(e,r,s)=>((r.enabled||this.disabled)&&(e[s]=r.value),e))}_reduceChildren(t,e){let r=t;return this._forEachChild((s,i)=>{r=e(r,s,i)}),r}_allControlsDisabled(){for(const t of Object.keys(this.controls))if(this.controls[t].enabled)return!1;return Object.keys(this.controls).length>0||this.disabled}_find(t){return this.controls.hasOwnProperty(t)?this.controls[t]:null}}const ip=new st("CallSetDisabledState",{providedIn:"root",factory:()=>vw}),vw="always";function Tw(n,t){n.forEach(e=>{e.registerOnValidatorChange&&e.registerOnValidatorChange(t)})}function _k(n,t){const e=function PW(n){return n._rawValidators}(n);null!==t.validator?n.setValidators(MW(e,t.validator)):"function"==typeof e&&n.setValidators([e]);const r=function FW(n){return n._rawAsyncValidators}(n);null!==t.asyncValidator?n.setAsyncValidators(MW(r,t.asyncValidator)):"function"==typeof r&&n.setAsyncValidators([r]);const s=()=>n.updateValueAndValidity();Tw(t._rawValidators,s),Tw(t._rawAsyncValidators,s)}function HW(n,t){n._pendingDirty&&n.markAsDirty(),n.setValue(n._pendingValue,{emitModelToViewChange:!1}),t.viewToModelUpdate(n._pendingValue),n._pendingChange=!1}const mRe={provide:di,useExisting:Et(()=>Cw)},Gg=(()=>Promise.resolve())();let Cw=(()=>{class n extends di{constructor(e,r,s){super(),this.callSetDisabledState=s,this.submitted=!1,this._directives=new Set,this.ngSubmit=new On,this.form=new bk({},dk(e),hk(r))}ngAfterViewInit(){this._setUpdateStrategy()}get formDirective(){return this}get control(){return this.form}get path(){return[]}get controls(){return this.form.controls}addControl(e){Gg.then(()=>{const r=this._findContainer(e.path);e.control=r.registerControl(e.name,e.control),function jg(n,t,e=vw){_k(n,t),t.valueAccessor.writeValue(n.value),(n.disabled||"always"===e)&&t.valueAccessor.setDisabledState?.(n.disabled),function lRe(n,t){t.valueAccessor.registerOnChange(e=>{n._pendingValue=e,n._pendingChange=!0,n._pendingDirty=!0,"change"===n.updateOn&&HW(n,t)})}(n,t),function cRe(n,t){const e=(r,s)=>{t.valueAccessor.writeValue(r),s&&t.viewToModelUpdate(r)};n.registerOnChange(e),t._registerOnDestroy(()=>{n._unregisterOnChange(e)})}(n,t),function uRe(n,t){t.valueAccessor.registerOnTouched(()=>{n._pendingTouched=!0,"blur"===n.updateOn&&n._pendingChange&&HW(n,t),"submit"!==n.updateOn&&n.markAsTouched()})}(n,t),function aRe(n,t){if(t.valueAccessor.setDisabledState){const e=r=>{t.valueAccessor.setDisabledState(r)};n.registerOnDisabledChange(e),t._registerOnDestroy(()=>{n._unregisterOnDisabledChange(e)})}}(n,t)}(e.control,e,this.callSetDisabledState),e.control.updateValueAndValidity({emitEvent:!1}),this._directives.add(e)})}getControl(e){return this.form.get(e.path)}removeControl(e){Gg.then(()=>{const r=this._findContainer(e.path);r&&r.removeControl(e.name),this._directives.delete(e)})}addFormGroup(e){Gg.then(()=>{const r=this._findContainer(e.path),s=new bk({});(function qW(n,t){_k(n,t)})(s,e),r.registerControl(e.name,s),s.updateValueAndValidity({emitEvent:!1})})}removeFormGroup(e){Gg.then(()=>{const r=this._findContainer(e.path);r&&r.removeControl(e.name)})}getFormGroup(e){return this.form.get(e.path)}updateModel(e,r){Gg.then(()=>{this.form.get(e.path).setValue(r)})}setValue(e){this.control.setValue(e)}onSubmit(e){return this.submitted=!0,function KW(n,t){n._syncPendingControls(),t.forEach(e=>{const r=e.control;"submit"===r.updateOn&&r._pendingChange&&(e.viewToModelUpdate(r._pendingValue),r._pendingChange=!1)})}(this.form,this._directives),this.ngSubmit.emit(e),"dialog"===e?.target?.method}onReset(){this.resetForm()}resetForm(e=void 0){this.form.reset(e),this.submitted=!1}_setUpdateStrategy(){this.options&&null!=this.options.updateOn&&(this.form._updateOn=this.options.updateOn)}_findContainer(e){return e.pop(),e.length?this.form.get(e):this.form}}return n.\u0275fac=function(e){return new(e||n)(Ee(qs,10),Ee(Ru,10),Ee(ip,8))},n.\u0275dir=Pt({type:n,selectors:[["form",3,"ngNoForm","",3,"formGroup",""],["ng-form"],["","ngForm",""]],hostBindings:function(e,r){1&e&&br("submit",function(i){return r.onSubmit(i)})("reset",function(){return r.onReset()})},inputs:{options:["ngFormOptions","options"]},outputs:{ngSubmit:"ngSubmit"},exportAs:["ngForm"],features:[Fn([mRe]),cn]}),n})(),n6=(()=>{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275dir=Pt({type:n,selectors:[["form",3,"ngNoForm","",3,"ngNativeValidate",""]],hostAttrs:["novalidate",""]}),n})(),s6=(()=>{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275mod=ar({type:n}),n.\u0275inj=Jn({}),n})(),URe=(()=>{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275mod=ar({type:n}),n.\u0275inj=Jn({imports:[s6]}),n})(),GRe=(()=>{class n{static withConfig(e){return{ngModule:n,providers:[{provide:ip,useValue:e.callSetDisabledState??vw}]}}}return n.\u0275fac=function(e){return new(e||n)},n.\u0275mod=ar({type:n}),n.\u0275inj=Jn({imports:[URe]}),n})();const WRe=["knob"],HRe=["valueIndicatorContainer"];function qRe(n,t){if(1&n&&(nn(0,"div",4,5)(2,"div",6)(3,"span",7),Er(4),Yt()()()),2&n){const e=Bl();Sn(4),sc(e.valueIndicatorText)}}const KRe=["trackActive"];function XRe(n,t){if(1&n&&Qs(0,"div"),2&n){const e=t.$implicit,r=t.index,s=Bl(3);QR(0===e?"mdc-slider__tick-mark--active":"mdc-slider__tick-mark--inactive"),XT("transform",s._calcTickMarkTransform(r))}}function YRe(n,t){if(1&n&&(db(0),ya(1,XRe,1,4,"div",11),hb()),2&n){const e=Bl(2);Sn(1),Ir("ngForOf",e._tickMarks)}}function ZRe(n,t){if(1&n&&(nn(0,"div",8,9),ya(2,YRe,2,1,"ng-container",10),Yt()),2&n){const e=Bl();Sn(2),Ir("ngIf",e._cachedWidth)}}function QRe(n,t){if(1&n&&Qs(0,"mat-slider-visual-thumb",7),2&n){const e=Bl();Ir("discrete",e.discrete)("thumbPosition",1)("valueIndicatorText",e.startValueIndicatorText)}}const JRe=["*"],Iw=new st("_MatSlider"),x6=new st("_MatSliderThumb"),T6=new st("_MatSliderRangeThumb"),S6=new st("_MatSliderVisualThumb");let eMe=(()=>{class n{constructor(e,r,s,i){this._cdr=e,this._ngZone=r,this._slider=i,this._isHovered=!1,this._isActive=!1,this._isValueIndicatorVisible=!1,this._onPointerMove=o=>{if(this._sliderInput._isFocused)return;const a=this._hostElement.getBoundingClientRect(),u=this._isSliderThumbHovered(o,a);this._isHovered=u,u?this._showHoverRipple():this._hideRipple(this._hoverRippleRef)},this._onMouseLeave=()=>{this._isHovered=!1,this._hideRipple(this._hoverRippleRef)},this._onFocus=()=>{this._hideRipple(this._hoverRippleRef),this._showFocusRipple(),this._hostElement.classList.add("mdc-slider__thumb--focused")},this._onBlur=()=>{this._isActive||this._hideRipple(this._focusRippleRef),this._isHovered&&this._showHoverRipple(),this._hostElement.classList.remove("mdc-slider__thumb--focused")},this._onDragStart=o=>{0===o.button&&(this._isActive=!0,this._showActiveRipple())},this._onDragEnd=()=>{this._isActive=!1,this._hideRipple(this._activeRippleRef),this._sliderInput._isFocused||this._hideRipple(this._focusRippleRef)},this._hostElement=s.nativeElement}ngAfterViewInit(){this._ripple.radius=24,this._sliderInput=this._slider._getInput(this.thumbPosition),this._sliderInputEl=this._sliderInput._hostElement;const e=this._sliderInputEl;this._ngZone.runOutsideAngular(()=>{e.addEventListener("pointermove",this._onPointerMove),e.addEventListener("pointerdown",this._onDragStart),e.addEventListener("pointerup",this._onDragEnd),e.addEventListener("pointerleave",this._onMouseLeave),e.addEventListener("focus",this._onFocus),e.addEventListener("blur",this._onBlur)})}ngOnDestroy(){const e=this._sliderInputEl;e.removeEventListener("pointermove",this._onPointerMove),e.removeEventListener("pointerdown",this._onDragStart),e.removeEventListener("pointerup",this._onDragEnd),e.removeEventListener("pointerleave",this._onMouseLeave),e.removeEventListener("focus",this._onFocus),e.removeEventListener("blur",this._onBlur)}_showHoverRipple(){this._isShowingRipple(this._hoverRippleRef)||(this._hoverRippleRef=this._showRipple({enterDuration:0,exitDuration:0}),this._hoverRippleRef?.element.classList.add("mat-mdc-slider-hover-ripple"))}_showFocusRipple(){this._isShowingRipple(this._focusRippleRef)||(this._focusRippleRef=this._showRipple({enterDuration:0,exitDuration:0},!0),this._focusRippleRef?.element.classList.add("mat-mdc-slider-focus-ripple"))}_showActiveRipple(){this._isShowingRipple(this._activeRippleRef)||(this._activeRippleRef=this._showRipple({enterDuration:225,exitDuration:400}),this._activeRippleRef?.element.classList.add("mat-mdc-slider-active-ripple"))}_isShowingRipple(e){return 0===e?.state||1===e?.state}_showRipple(e,r){if(!this._slider.disabled&&(this._showValueIndicator(),this._slider._isRange&&this._slider._getThumb(1===this.thumbPosition?2:1)._showValueIndicator(),!this._slider._globalRippleOptions?.disabled||r))return this._ripple.launch({animation:this._slider._noopAnimations?{enterDuration:0,exitDuration:0}:e,centered:!0,persistent:!0})}_hideRipple(e){if(e?.fadeOut(),this._isShowingAnyRipple())return;this._slider._isRange||this._hideValueIndicator();const r=this._getSibling();r._isShowingAnyRipple()||(this._hideValueIndicator(),r._hideValueIndicator())}_showValueIndicator(){this._hostElement.classList.add("mdc-slider__thumb--with-indicator")}_hideValueIndicator(){this._hostElement.classList.remove("mdc-slider__thumb--with-indicator")}_getSibling(){return this._slider._getThumb(1===this.thumbPosition?2:1)}_getValueIndicatorContainer(){return this._valueIndicatorContainer?.nativeElement}_getKnob(){return this._knob.nativeElement}_isShowingAnyRipple(){return this._isShowingRipple(this._hoverRippleRef)||this._isShowingRipple(this._focusRippleRef)||this._isShowingRipple(this._activeRippleRef)}_isSliderThumbHovered(e,r){const s=r.width/2,u=e.clientY-(r.y+s);return Math.pow(e.clientX-(r.x+s),2)+Math.pow(u,2)<Math.pow(s,2)}}return n.\u0275fac=function(e){return new(e||n)(Ee(Ta),Ee(Zt),Ee(tr),Ee(Iw))},n.\u0275cmp=Bo({type:n,selectors:[["mat-slider-visual-thumb"]],viewQuery:function(e,r){if(1&e&&(Ul(ak,5),Ul(WRe,5),Ul(HRe,5)),2&e){let s;uo(s=co())&&(r._ripple=s.first),uo(s=co())&&(r._knob=s.first),uo(s=co())&&(r._valueIndicatorContainer=s.first)}},hostAttrs:[1,"mdc-slider__thumb","mat-mdc-slider-visual-thumb"],inputs:{discrete:"discrete",thumbPosition:"thumbPosition",valueIndicatorText:"valueIndicatorText"},features:[Fn([{provide:S6,useExisting:n}])],decls:4,vars:2,consts:[["class","mdc-slider__value-indicator-container",4,"ngIf"],[1,"mdc-slider__thumb-knob"],["knob",""],["matRipple","",1,"mat-mdc-focus-indicator",3,"matRippleDisabled"],[1,"mdc-slider__value-indicator-container"],["valueIndicatorContainer",""],[1,"mdc-slider__value-indicator"],[1,"mdc-slider__value-indicator-text"]],template:function(e,r){1&e&&(ya(0,qRe,5,1,"div",0),Qs(1,"div",1,2)(3,"div",3)),2&e&&(Ir("ngIf",r.discrete),Sn(3),Ir("matRippleDisabled",!0))},dependencies:[Fb,ak],styles:[".mat-mdc-slider-visual-thumb .mat-ripple{height:100%;width:100%}.mat-mdc-slider .mdc-slider__tick-marks{justify-content:start}.mat-mdc-slider .mdc-slider__tick-marks .mdc-slider__tick-mark--active,.mat-mdc-slider .mdc-slider__tick-marks .mdc-slider__tick-mark--inactive{position:absolute;left:2px}"],encapsulation:2,changeDetection:0}),n})();const tMe=TOe(jG(class{constructor(n){this._elementRef=n}}),"primary");let nMe=(()=>{class n extends tMe{get disabled(){return this._disabled}set disabled(e){this._disabled=ia(e);const r=this._getInput(2),s=this._getInput(1);r&&(r.disabled=this._disabled),s&&(s.disabled=this._disabled)}get discrete(){return this._discrete}set discrete(e){this._discrete=ia(e),this._updateValueIndicatorUIs()}get showTickMarks(){return this._showTickMarks}set showTickMarks(e){this._showTickMarks=ia(e)}get min(){return this._min}set min(e){const r=ci(e,this._min);this._min!==r&&this._updateMin(r)}_updateMin(e){const r=this._min;this._min=e,this._isRange?this._updateMinRange({old:r,new:e}):this._updateMinNonRange(e),this._onMinMaxOrStepChange()}_updateMinRange(e){const r=this._getInput(2),s=this._getInput(1),i=r.value,o=s.value;s.min=e.new,r.min=Math.max(e.new,s.value),s.max=Math.min(r.max,r.value),s._updateWidthInactive(),r._updateWidthInactive(),e.new<e.old?this._onTranslateXChangeBySideEffect(r,s):this._onTranslateXChangeBySideEffect(s,r),i!==r.value&&this._onValueChange(r),o!==s.value&&this._onValueChange(s)}_updateMinNonRange(e){const r=this._getInput(2);if(r){const s=r.value;r.min=e,r._updateThumbUIByValue(),this._updateTrackUI(r),s!==r.value&&this._onValueChange(r)}}get max(){return this._max}set max(e){const r=ci(e,this._max);this._max!==r&&this._updateMax(r)}_updateMax(e){const r=this._max;this._max=e,this._isRange?this._updateMaxRange({old:r,new:e}):this._updateMaxNonRange(e),this._onMinMaxOrStepChange()}_updateMaxRange(e){const r=this._getInput(2),s=this._getInput(1),i=r.value,o=s.value;r.max=e.new,s.max=Math.min(e.new,r.value),r.min=s.value,r._updateWidthInactive(),s._updateWidthInactive(),e.new>e.old?this._onTranslateXChangeBySideEffect(s,r):this._onTranslateXChangeBySideEffect(r,s),i!==r.value&&this._onValueChange(r),o!==s.value&&this._onValueChange(s)}_updateMaxNonRange(e){const r=this._getInput(2);if(r){const s=r.value;r.max=e,r._updateThumbUIByValue(),this._updateTrackUI(r),s!==r.value&&this._onValueChange(r)}}get step(){return this._step}set step(e){const r=ci(e,this._step);this._step!==r&&this._updateStep(r)}_updateStep(e){this._step=e,this._isRange?this._updateStepRange():this._updateStepNonRange(),this._onMinMaxOrStepChange()}_updateStepRange(){const e=this._getInput(2),r=this._getInput(1),s=e.value,i=r.value,o=r.value;e.min=this._min,r.max=this._max,e.step=this._step,r.step=this._step,this._platform.SAFARI&&(e.value=e.value,r.value=r.value),e.min=Math.max(this._min,r.value),r.max=Math.min(this._max,e.value),r._updateWidthInactive(),e._updateWidthInactive(),e.value<o?this._onTranslateXChangeBySideEffect(r,e):this._onTranslateXChangeBySideEffect(e,r),s!==e.value&&this._onValueChange(e),i!==r.value&&this._onValueChange(r)}_updateStepNonRange(){const e=this._getInput(2);if(e){const r=e.value;e.step=this._step,this._platform.SAFARI&&(e.value=e.value),e._updateThumbUIByValue(),r!==e.value&&this._onValueChange(e)}}constructor(e,r,s,i,o,a,u){super(i),this._ngZone=e,this._cdr=r,this._platform=s,this._dir=o,this._globalRippleOptions=a,this._disabled=!1,this._discrete=!1,this._showTickMarks=!1,this._min=0,this._max=100,this._step=0,this.displayWith=c=>`${c}`,this._rippleRadius=24,this.startValueIndicatorText="",this.endValueIndicatorText="",this._isRange=!1,this._isRtl=!1,this._hasViewInitialized=!1,this._tickMarkTrackWidth=0,this._hasAnimation=!1,this._resizeTimer=null,this._knobRadius=8,this._thumbsOverlap=!1,this._noopAnimations="NoopAnimations"===u,this._dirChangeSubscription=this._dir.change.subscribe(()=>this._onDirChange()),this._isRtl="rtl"===this._dir.value}ngAfterViewInit(){this._platform.isBrowser&&this._updateDimensions();const e=this._getInput(2),r=this._getInput(1);this._isRange=!!e&&!!r,this._cdr.detectChanges();const s=this._getThumb(2);this._rippleRadius=s._ripple.radius,this._inputPadding=this._rippleRadius-this._knobRadius,this._inputOffset=this._knobRadius,this._isRange?this._initUIRange(e,r):this._initUINonRange(e),this._updateTrackUI(e),this._updateTickMarkUI(),this._updateTickMarkTrackUI(),this._observeHostResize(),this._cdr.detectChanges()}_initUINonRange(e){e.initProps(),e.initUI(),this._updateValueIndicatorUI(e),this._hasViewInitialized=!0,e._updateThumbUIByValue()}_initUIRange(e,r){e.initProps(),e.initUI(),r.initProps(),r.initUI(),e._updateMinMax(),r._updateMinMax(),e._updateStaticStyles(),r._updateStaticStyles(),this._updateValueIndicatorUIs(),this._hasViewInitialized=!0,e._updateThumbUIByValue(),r._updateThumbUIByValue()}ngOnDestroy(){this._dirChangeSubscription.unsubscribe(),this._resizeObserver?.disconnect(),this._resizeObserver=null}_onDirChange(){this._isRtl="rtl"===this._dir.value,this._isRange?this._onDirChangeRange():this._onDirChangeNonRange(),this._updateTickMarkUI()}_onDirChangeRange(){const e=this._getInput(2),r=this._getInput(1);e._setIsLeftThumb(),r._setIsLeftThumb(),e.translateX=e._calcTranslateXByValue(),r.translateX=r._calcTranslateXByValue(),e._updateStaticStyles(),r._updateStaticStyles(),e._updateWidthInactive(),r._updateWidthInactive(),e._updateThumbUIByValue(),r._updateThumbUIByValue()}_onDirChangeNonRange(){this._getInput(2)._updateThumbUIByValue()}_observeHostResize(){typeof ResizeObserver>"u"||!ResizeObserver||this._ngZone.runOutsideAngular(()=>{this._resizeObserver=new ResizeObserver(()=>{this._isActive()||(this._resizeTimer&&clearTimeout(this._resizeTimer),this._onResize())}),this._resizeObserver.observe(this._elementRef.nativeElement)})}_isActive(){return this._getThumb(1)._isActive||this._getThumb(2)._isActive}_getValue(e=2){const r=this._getInput(e);return r?r.value:this.min}_skipUpdate(){return!(!this._getInput(1)?._skipUIUpdate&&!this._getInput(2)?._skipUIUpdate)}_updateDimensions(){this._cachedWidth=this._elementRef.nativeElement.offsetWidth,this._cachedLeft=this._elementRef.nativeElement.getBoundingClientRect().left}_setTrackActiveStyles(e){const r=this._trackActive.nativeElement.style;r.left=e.left,r.right=e.right,r.transformOrigin=e.transformOrigin,r.transform=e.transform}_calcTickMarkTransform(e){return`translateX(${e*(this._tickMarkTrackWidth/(this._tickMarks.length-1))}px`}_onTranslateXChange(e){this._hasViewInitialized&&(this._updateThumbUI(e),this._updateTrackUI(e),this._updateOverlappingThumbUI(e))}_onTranslateXChangeBySideEffect(e,r){this._hasViewInitialized&&(e._updateThumbUIByValue(),r._updateThumbUIByValue())}_onValueChange(e){this._hasViewInitialized&&(this._updateValueIndicatorUI(e),this._updateTickMarkUI(),this._cdr.detectChanges())}_onMinMaxOrStepChange(){this._hasViewInitialized&&(this._updateTickMarkUI(),this._updateTickMarkTrackUI(),this._cdr.markForCheck())}_onResize(){if(this._hasViewInitialized){if(this._updateDimensions(),this._isRange){const e=this._getInput(2),r=this._getInput(1);e._updateThumbUIByValue(),r._updateThumbUIByValue(),e._updateStaticStyles(),r._updateStaticStyles(),e._updateMinMax(),r._updateMinMax(),e._updateWidthInactive(),r._updateWidthInactive()}else{const e=this._getInput(2);e&&e._updateThumbUIByValue()}this._updateTickMarkUI(),this._updateTickMarkTrackUI(),this._cdr.detectChanges()}}_areThumbsOverlapping(){const e=this._getInput(1),r=this._getInput(2);return!(!e||!r)&&r.translateX-e.translateX<20}_updateOverlappingThumbClassNames(e){const r=e.getSibling(),s=this._getThumb(e.thumbPosition);this._getThumb(r.thumbPosition)._hostElement.classList.remove("mdc-slider__thumb--top"),s._hostElement.classList.toggle("mdc-slider__thumb--top",this._thumbsOverlap)}_updateOverlappingThumbUI(e){!this._isRange||this._skipUpdate()||this._thumbsOverlap!==this._areThumbsOverlapping()&&(this._thumbsOverlap=!this._thumbsOverlap,this._updateOverlappingThumbClassNames(e))}_updateThumbUI(e){this._skipUpdate()||(this._getThumb(2===e.thumbPosition?2:1)._hostElement.style.transform=`translateX(${e.translateX}px)`)}_updateValueIndicatorUI(e){if(this._skipUpdate())return;const r=this.displayWith(e.value);if(this._hasViewInitialized?e._valuetext=r:e._hostElement.setAttribute("aria-valuetext",r),this.discrete){1===e.thumbPosition?this.startValueIndicatorText=r:this.endValueIndicatorText=r;const s=this._getThumb(e.thumbPosition);r.length<3?s._hostElement.classList.add("mdc-slider__thumb--short-value"):s._hostElement.classList.remove("mdc-slider__thumb--short-value")}}_updateValueIndicatorUIs(){const e=this._getInput(2),r=this._getInput(1);e&&this._updateValueIndicatorUI(e),r&&this._updateValueIndicatorUI(r)}_updateTickMarkTrackUI(){if(!this.showTickMarks||this._skipUpdate())return;const e=this._step&&this._step>0?this._step:1,s=(Math.floor(this.max/e)*e-this.min)/(this.max-this.min);this._tickMarkTrackWidth=this._cachedWidth*s-6}_updateTrackUI(e){this._skipUpdate()||(this._isRange?this._updateTrackUIRange(e):this._updateTrackUINonRange(e))}_updateTrackUIRange(e){const r=e.getSibling();if(!r||!this._cachedWidth)return;const s=Math.abs(r.translateX-e.translateX)/this._cachedWidth;this._setTrackActiveStyles(e._isLeftThumb&&this._cachedWidth?{left:"auto",right:this._cachedWidth-r.translateX+"px",transformOrigin:"right",transform:`scaleX(${s})`}:{left:`${r.translateX}px`,right:"auto",transformOrigin:"left",transform:`scaleX(${s})`})}_updateTrackUINonRange(e){this._setTrackActiveStyles(this._isRtl?{left:"auto",right:"0px",transformOrigin:"right",transform:`scaleX(${1-e.fillPercentage})`}:{left:"0px",right:"auto",transformOrigin:"left",transform:`scaleX(${e.fillPercentage})`})}_updateTickMarkUI(){if(!this.showTickMarks||void 0===this.step||void 0===this.min||void 0===this.max)return;const e=this.step>0?this.step:1;this._isRange?this._updateTickMarkUIRange(e):this._updateTickMarkUINonRange(e),this._isRtl&&this._tickMarks.reverse()}_updateTickMarkUINonRange(e){const r=this._getValue();let s=Math.max(Math.round((r-this.min)/e),0),i=Math.max(Math.round((this.max-r)/e),0);this._isRtl?s++:i++,this._tickMarks=Array(s).fill(0).concat(Array(i).fill(1))}_updateTickMarkUIRange(e){const r=this._getValue(),s=this._getValue(1),i=Math.max(Math.floor((s-this.min)/e),0),o=Math.max(Math.floor((r-s)/e)+1,0),a=Math.max(Math.floor((this.max-r)/e),0);this._tickMarks=Array(i).fill(1).concat(Array(o).fill(0),Array(a).fill(1))}_getInput(e){return 2===e&&this._input?this._input:this._inputs?.length?1===e?this._inputs.first:this._inputs.last:void 0}_getThumb(e){return 2===e?this._thumbs?.last:this._thumbs?.first}_setTransition(e){this._hasAnimation=e&&!this._noopAnimations,this._elementRef.nativeElement.classList.toggle("mat-mdc-slider-with-animation",this._hasAnimation)}}return n.\u0275fac=function(e){return new(e||n)(Ee(Zt),Ee(Ta),Ee(No),Ee(tr),Ee(aw,8),Ee(XG,8),Ee(Vl,8))},n.\u0275cmp=Bo({type:n,selectors:[["mat-slider"]],contentQueries:function(e,r,s){if(1&e&&(bf(s,x6,5),bf(s,T6,4)),2&e){let i;uo(i=co())&&(r._input=i.first),uo(i=co())&&(r._inputs=i)}},viewQuery:function(e,r){if(1&e&&(Ul(KRe,5),Ul(S6,5)),2&e){let s;uo(s=co())&&(r._trackActive=s.first),uo(s=co())&&(r._thumbs=s)}},hostAttrs:[1,"mat-mdc-slider","mdc-slider"],hostVars:10,hostBindings:function(e,r){2&e&&ba("mdc-slider--range",r._isRange)("mdc-slider--disabled",r.disabled)("mdc-slider--discrete",r.discrete)("mdc-slider--tick-marks",r.showTickMarks)("_mat-animation-noopable",r._noopAnimations)},inputs:{color:"color",disableRipple:"disableRipple",disabled:"disabled",discrete:"discrete",showTickMarks:"showTickMarks",min:"min",max:"max",step:"step",displayWith:"displayWith"},exportAs:["matSlider"],features:[Fn([{provide:Iw,useExisting:n}]),cn],ngContentSelectors:JRe,decls:9,vars:5,consts:[[1,"mdc-slider__track"],[1,"mdc-slider__track--inactive"],[1,"mdc-slider__track--active"],[1,"mdc-slider__track--active_fill"],["trackActive",""],["class","mdc-slider__tick-marks",4,"ngIf"],[3,"discrete","thumbPosition","valueIndicatorText",4,"ngIf"],[3,"discrete","thumbPosition","valueIndicatorText"],[1,"mdc-slider__tick-marks"],["tickMarkContainer",""],[4,"ngIf"],[3,"class","transform",4,"ngFor","ngForOf"]],template:function(e,r){1&e&&(function jT(n){const t=Xe()[jr][$s];if(!t.projection){const r=t.projection=Rp(n?n.length:1,null),s=r.slice();let i=t.child;for(;null!==i;){const o=n?O9(i,n):0;null!==o&&(s[o]?s[o].projectionNext=i:r[o]=i,s[o]=i),i=i.next}}}(),GT(0),nn(1,"div",0),Qs(2,"div",1),nn(3,"div",2),Qs(4,"div",3,4),Yt(),ya(6,ZRe,3,1,"div",5),Yt(),ya(7,QRe,1,3,"mat-slider-visual-thumb",6),Qs(8,"mat-slider-visual-thumb",7)),2&e&&(Sn(6),Ir("ngIf",r.showTickMarks),Sn(1),Ir("ngIf",r._isRange),Sn(1),Ir("discrete",r.discrete)("thumbPosition",2)("valueIndicatorText",r.endValueIndicatorText))},dependencies:[e1,Fb,eMe],styles:['.mdc-slider{cursor:pointer;height:48px;margin:0 24px;position:relative;touch-action:pan-y}.mdc-slider .mdc-slider__track{position:absolute;top:50%;transform:translateY(-50%);width:100%}.mdc-slider .mdc-slider__track--active,.mdc-slider .mdc-slider__track--inactive{display:flex;height:100%;position:absolute;width:100%}.mdc-slider .mdc-slider__track--active{overflow:hidden}.mdc-slider .mdc-slider__track--active_fill{border-top-style:solid;box-sizing:border-box;height:100%;width:100%;position:relative;-webkit-transform-origin:left;transform-origin:left}[dir=rtl] .mdc-slider .mdc-slider__track--active_fill,.mdc-slider .mdc-slider__track--active_fill[dir=rtl]{-webkit-transform-origin:right;transform-origin:right}.mdc-slider .mdc-slider__track--inactive{left:0;top:0}.mdc-slider .mdc-slider__track--inactive::before{position:absolute;box-sizing:border-box;width:100%;height:100%;top:0;left:0;border:1px solid rgba(0,0,0,0);border-radius:inherit;content:"";pointer-events:none}@media screen and (forced-colors: active){.mdc-slider .mdc-slider__track--inactive::before{border-color:CanvasText}}.mdc-slider .mdc-slider__value-indicator-container{bottom:44px;left:var(--slider-value-indicator-container-left, 50%);pointer-events:none;position:absolute;right:var(--slider-value-indicator-container-right);transform:var(--slider-value-indicator-container-transform, translateX(-50%))}.mdc-slider .mdc-slider__value-indicator{transition:transform 100ms 0ms cubic-bezier(0.4, 0, 1, 1);align-items:center;border-radius:4px;display:flex;height:32px;padding:0 12px;transform:scale(0);transform-origin:bottom}.mdc-slider .mdc-slider__value-indicator::before{border-left:6px solid rgba(0,0,0,0);border-right:6px solid rgba(0,0,0,0);border-top:6px solid;bottom:-5px;content:"";height:0;left:var(--slider-value-indicator-caret-left, 50%);position:absolute;right:var(--slider-value-indicator-caret-right);transform:var(--slider-value-indicator-caret-transform, translateX(-50%));width:0}.mdc-slider .mdc-slider__value-indicator::after{position:absolute;box-sizing:border-box;width:100%;height:100%;top:0;left:0;border:1px solid rgba(0,0,0,0);border-radius:inherit;content:"";pointer-events:none}@media screen and (forced-colors: active){.mdc-slider .mdc-slider__value-indicator::after{border-color:CanvasText}}.mdc-slider .mdc-slider__thumb--with-indicator .mdc-slider__value-indicator-container{pointer-events:auto}.mdc-slider .mdc-slider__thumb--with-indicator .mdc-slider__value-indicator{transition:transform 100ms 0ms cubic-bezier(0, 0, 0.2, 1);transform:scale(1)}@media(prefers-reduced-motion){.mdc-slider .mdc-slider__value-indicator,.mdc-slider .mdc-slider__thumb--with-indicator .mdc-slider__value-indicator{transition:none}}.mdc-slider .mdc-slider__thumb{display:flex;left:-24px;outline:none;position:absolute;user-select:none;height:48px;width:48px}.mdc-slider .mdc-slider__thumb--top{z-index:1}.mdc-slider .mdc-slider__thumb--top .mdc-slider__thumb-knob,.mdc-slider .mdc-slider__thumb--top.mdc-slider__thumb:hover .mdc-slider__thumb-knob,.mdc-slider .mdc-slider__thumb--top.mdc-slider__thumb--focused .mdc-slider__thumb-knob{border-style:solid;border-width:1px;box-sizing:content-box}.mdc-slider .mdc-slider__thumb-knob{box-sizing:border-box;left:50%;position:absolute;top:50%;transform:translate(-50%, -50%)}.mdc-slider .mdc-slider__tick-marks{align-items:center;box-sizing:border-box;display:flex;height:100%;justify-content:space-between;padding:0 1px;position:absolute;width:100%}.mdc-slider--discrete .mdc-slider__thumb,.mdc-slider--discrete .mdc-slider__track--active_fill{transition:transform 80ms ease}@media(prefers-reduced-motion){.mdc-slider--discrete .mdc-slider__thumb,.mdc-slider--discrete .mdc-slider__track--active_fill{transition:none}}.mdc-slider--disabled{cursor:auto}.mdc-slider--disabled .mdc-slider__thumb{pointer-events:none}.mdc-slider__input{cursor:pointer;left:2px;margin:0;height:44px;opacity:0;pointer-events:none;position:absolute;top:2px;width:44px}.mat-mdc-slider{display:inline-block;box-sizing:border-box;outline:none;vertical-align:middle;margin-left:8px;margin-right:8px;width:auto;min-width:112px;-webkit-tap-highlight-color:rgba(0,0,0,0)}.mat-mdc-slider .mdc-slider__thumb-knob{background-color:var(--mdc-slider-handle-color, var(--mdc-theme-primary, #6200ee));border-color:var(--mdc-slider-handle-color, var(--mdc-theme-primary, #6200ee))}.mat-mdc-slider .mdc-slider__thumb--top .mdc-slider__thumb-knob,.mat-mdc-slider .mdc-slider__thumb--top.mdc-slider__thumb:hover .mdc-slider__thumb-knob,.mat-mdc-slider .mdc-slider__thumb--top.mdc-slider__thumb--focused .mdc-slider__thumb-knob{border-color:#fff}.mat-mdc-slider.mdc-slider--disabled .mdc-slider__thumb-knob{background-color:var(--mdc-slider-disabled-handle-color, var(--mdc-theme-on-surface, #000));border-color:var(--mdc-slider-disabled-handle-color, var(--mdc-theme-on-surface, #000))}.mat-mdc-slider.mdc-slider--disabled .mdc-slider__thumb--top .mdc-slider__thumb-knob,.mat-mdc-slider.mdc-slider--disabled .mdc-slider__thumb--top.mdc-slider__thumb:hover .mdc-slider__thumb-knob,.mat-mdc-slider.mdc-slider--disabled .mdc-slider__thumb--top.mdc-slider__thumb--focused .mdc-slider__thumb-knob{border-color:#fff}.mat-mdc-slider .mdc-slider__thumb::before,.mat-mdc-slider .mdc-slider__thumb::after{background-color:var(--mdc-slider-handle-color, var(--mdc-theme-primary, #6200ee))}.mat-mdc-slider .mdc-slider__thumb:hover::before,.mat-mdc-slider .mdc-slider__thumb.mdc-ripple-surface--hover::before{opacity:var(--mdc-ripple-hover-opacity, 0.04)}.mat-mdc-slider .mdc-slider__thumb.mdc-ripple-upgraded--background-focused::before,.mat-mdc-slider .mdc-slider__thumb:not(.mdc-ripple-upgraded):focus::before{transition-duration:75ms;opacity:var(--mdc-ripple-focus-opacity, 0.12)}.mat-mdc-slider .mdc-slider__thumb:not(.mdc-ripple-upgraded)::after{transition:opacity 150ms linear}.mat-mdc-slider .mdc-slider__thumb:not(.mdc-ripple-upgraded):active::after{transition-duration:75ms;opacity:var(--mdc-ripple-press-opacity, 0.12)}.mat-mdc-slider .mdc-slider__thumb.mdc-ripple-upgraded{--mdc-ripple-fg-opacity:var(--mdc-ripple-press-opacity, 0.12)}.mat-mdc-slider .mdc-slider__track--active_fill{border-color:var(--mdc-slider-active-track-color, var(--mdc-theme-primary, #6200ee))}.mat-mdc-slider.mdc-slider--disabled .mdc-slider__track--active_fill{border-color:var(--mdc-slider-disabled-active-track-color, var(--mdc-theme-on-surface, #000))}.mat-mdc-slider .mdc-slider__track--inactive{background-color:var(--mdc-slider-inactive-track-color, var(--mdc-theme-primary, #6200ee));opacity:.24}.mat-mdc-slider.mdc-slider--disabled .mdc-slider__track--inactive{background-color:var(--mdc-slider-disabled-inactive-track-color, var(--mdc-theme-on-surface, #000));opacity:.24}.mat-mdc-slider .mdc-slider__tick-mark--active{background-color:var(--mdc-slider-with-tick-marks-active-container-color, var(--mdc-theme-on-primary, #fff));opacity:var(--mdc-slider-with-tick-marks-active-container-opacity, 0.6)}.mat-mdc-slider.mdc-slider--disabled .mdc-slider__tick-mark--active{background-color:var(--mdc-slider-with-tick-marks-active-container-color, var(--mdc-theme-on-primary, #fff));opacity:var(--mdc-slider-with-tick-marks-active-container-opacity, 0.6)}.mat-mdc-slider .mdc-slider__tick-mark--inactive{background-color:var(--mdc-slider-with-tick-marks-inactive-container-color, var(--mdc-theme-primary, #6200ee));opacity:var(--mdc-slider-with-tick-marks-inactive-container-opacity, 0.6)}.mat-mdc-slider.mdc-slider--disabled .mdc-slider__tick-mark--inactive{background-color:var(--mdc-slider-with-tick-marks-disabled-container-color, var(--mdc-theme-on-surface, #000));opacity:var(--mdc-slider-with-tick-marks-inactive-container-opacity, 0.6)}.mat-mdc-slider .mdc-slider__value-indicator{background-color:var(--mdc-slider-label-container-color, #666666);opacity:1}.mat-mdc-slider .mdc-slider__value-indicator::before{border-top-color:var(--mdc-slider-label-container-color, #666666)}.mat-mdc-slider .mdc-slider__value-indicator{color:var(--mdc-slider-label-label-text-color, var(--mdc-theme-on-primary, #fff))}.mat-mdc-slider .mdc-slider__track{height:var(--mdc-slider-inactive-track-height, 4px)}.mat-mdc-slider .mdc-slider__track--active{height:var(--mdc-slider-active-track-height, 6px);top:calc((var(--mdc-slider-inactive-track-height, 4px) - var(--mdc-slider-active-track-height, 6px)) / 2)}.mat-mdc-slider .mdc-slider__track--active_fill{border-top-width:var(--mdc-slider-active-track-height, 6px)}.mat-mdc-slider .mdc-slider__track--inactive{height:var(--mdc-slider-inactive-track-height, 4px)}.mat-mdc-slider .mdc-slider__tick-mark--active,.mat-mdc-slider .mdc-slider__tick-mark--inactive{height:var(--mdc-slider-with-tick-marks-container-size, 2px);width:var(--mdc-slider-with-tick-marks-container-size, 2px)}.mat-mdc-slider.mdc-slider--disabled{opacity:0.38}.mat-mdc-slider .mdc-slider__value-indicator-text{letter-spacing:var(--mdc-slider-label-label-text-tracking, 0.0071428571em);font-size:var(--mdc-slider-label-label-text-size, 0.875rem);font-family:var(--mdc-slider-label-label-text-font, Roboto, sans-serif);font-weight:var(--mdc-slider-label-label-text-weight, 500);line-height:var(--mdc-slider-label-label-text-line-height, 1.375rem)}.mat-mdc-slider .mdc-slider__track--active{border-radius:var(--mdc-slider-active-track-shape, 9999px)}.mat-mdc-slider .mdc-slider__track--inactive{border-radius:var(--mdc-slider-inactive-track-shape, 9999px)}.mat-mdc-slider .mdc-slider__thumb-knob{border-radius:var(--mdc-slider-handle-shape, 50%);width:var(--mdc-slider-handle-width, 20px);height:var(--mdc-slider-handle-height, 20px);border-style:solid;border-width:calc(var(--mdc-slider-handle-height, 20px) / 2) calc(var(--mdc-slider-handle-width, 20px) / 2)}.mat-mdc-slider .mdc-slider__tick-mark--active,.mat-mdc-slider .mdc-slider__tick-mark--inactive{border-radius:var(--mdc-slider-with-tick-marks-container-shape, 50%)}.mat-mdc-slider .mdc-slider__thumb-knob{box-shadow:var(--mdc-slider-handle-elevation, 0px 2px 1px -1px rgba(0, 0, 0, 0.2), 0px 1px 1px 0px rgba(0, 0, 0, 0.14), 0px 1px 3px 0px rgba(0, 0, 0, 0.12))}.mat-mdc-slider .mdc-slider__thumb:hover .mdc-slider__thumb-knob{background-color:var(--mdc-slider-hover-handle-color, var(--mdc-theme-primary, #6200ee));border-color:var(--mdc-slider-hover-handle-color, var(--mdc-theme-primary, #6200ee))}.mat-mdc-slider .mdc-slider__thumb:hover .mdc-slider__thumb--top .mdc-slider__thumb-knob,.mat-mdc-slider .mdc-slider__thumb:hover .mdc-slider__thumb--top.mdc-slider__thumb:hover .mdc-slider__thumb-knob,.mat-mdc-slider .mdc-slider__thumb:hover .mdc-slider__thumb--top.mdc-slider__thumb--focused .mdc-slider__thumb-knob{border-color:#fff}.mat-mdc-slider .mdc-slider__thumb--focused .mdc-slider__thumb-knob{background-color:var(--mdc-slider-focus-handle-color, var(--mdc-theme-primary, #6200ee));border-color:var(--mdc-slider-focus-handle-color, var(--mdc-theme-primary, #6200ee))}.mat-mdc-slider .mdc-slider__thumb--focused .mdc-slider__thumb--top .mdc-slider__thumb-knob,.mat-mdc-slider .mdc-slider__thumb--focused .mdc-slider__thumb--top.mdc-slider__thumb:hover .mdc-slider__thumb-knob,.mat-mdc-slider .mdc-slider__thumb--focused .mdc-slider__thumb--top.mdc-slider__thumb--focused .mdc-slider__thumb-knob{border-color:#fff}.mat-mdc-slider .mdc-slider__thumb:not(:disabled):active .mdc-slider__thumb--top .mdc-slider__thumb-knob,.mat-mdc-slider .mdc-slider__thumb:not(:disabled):active .mdc-slider__thumb--top.mdc-slider__thumb:hover .mdc-slider__thumb-knob,.mat-mdc-slider .mdc-slider__thumb:not(:disabled):active .mdc-slider__thumb--top.mdc-slider__thumb--focused .mdc-slider__thumb-knob{border-color:#fff}.mat-mdc-slider .mdc-slider__thumb--top .mdc-slider__thumb-knob,.mat-mdc-slider .mdc-slider__thumb--top.mdc-slider__thumb:hover .mdc-slider__thumb-knob,.mat-mdc-slider .mdc-slider__thumb--top.mdc-slider__thumb--focused .mdc-slider__thumb-knob{border-color:var(--mdc-slider-with-overlap-handle-outline-color, #fff);border-width:var(--mdc-slider-with-overlap-handle-outline-width, 1px)}.mat-mdc-slider .mdc-slider__input{box-sizing:content-box;pointer-events:auto}.mat-mdc-slider .mdc-slider__input.mat-mdc-slider-input-no-pointer-events{pointer-events:none}.mat-mdc-slider .mdc-slider__input.mat-slider__right-input{left:auto;right:0}.mat-mdc-slider .mdc-slider__thumb,.mat-mdc-slider .mdc-slider__track--active_fill{transition-duration:0ms}.mat-mdc-slider.mat-mdc-slider-with-animation .mdc-slider__thumb,.mat-mdc-slider.mat-mdc-slider-with-animation .mdc-slider__track--active_fill{transition-duration:80ms}.mat-mdc-slider.mdc-slider--discrete .mdc-slider__thumb,.mat-mdc-slider.mdc-slider--discrete .mdc-slider__track--active_fill{transition-duration:0ms}.mat-mdc-slider.mat-mdc-slider-with-animation .mdc-slider__thumb,.mat-mdc-slider.mat-mdc-slider-with-animation .mdc-slider__track--active_fill{transition-duration:80ms}.mat-mdc-slider .mdc-slider__track,.mat-mdc-slider .mdc-slider__thumb{pointer-events:none}.mat-mdc-slider .mdc-slider__value-indicator{opacity:var(--mat-mdc-slider-value-indicator-opacity, 1)}.mat-mdc-slider .mat-ripple .mat-ripple-element{background-color:var(--mat-mdc-slider-ripple-color, transparent)}.mat-mdc-slider .mat-ripple .mat-mdc-slider-hover-ripple{background-color:var(--mat-mdc-slider-hover-ripple-color, transparent)}.mat-mdc-slider .mat-ripple .mat-mdc-slider-focus-ripple,.mat-mdc-slider .mat-ripple .mat-mdc-slider-active-ripple{background-color:var(--mat-mdc-slider-focus-ripple-color, transparent)}.mat-mdc-slider._mat-animation-noopable.mdc-slider--discrete .mdc-slider__thumb,.mat-mdc-slider._mat-animation-noopable.mdc-slider--discrete .mdc-slider__track--active_fill,.mat-mdc-slider._mat-animation-noopable .mdc-slider__value-indicator{transition:none}.mat-mdc-slider .mat-mdc-focus-indicator::before{border-radius:50%}.mdc-slider__thumb--focused .mat-mdc-focus-indicator::before{content:""}'],encapsulation:2,changeDetection:0}),n})();const sMe={provide:Qi,useExisting:Et(()=>Ak),multi:!0};let Ak=(()=>{class n{get value(){return ci(this._hostElement.value)}set value(e){const r=ci(e).toString();this._hasSetInitialValue?this._isActive||(this._hostElement.value=r,this._updateThumbUIByValue(),this._slider._onValueChange(this),this._cdr.detectChanges()):this._initialValue=r}get translateX(){return this._slider.min>=this._slider.max?(this._translateX=0,this._translateX):(void 0===this._translateX&&(this._translateX=this._calcTranslateXByValue()),this._translateX)}set translateX(e){this._translateX=e}get min(){return ci(this._hostElement.min)}set min(e){this._hostElement.min=ci(e).toString(),this._cdr.detectChanges()}get max(){return ci(this._hostElement.max)}set max(e){this._hostElement.max=ci(e).toString(),this._cdr.detectChanges()}get step(){return ci(this._hostElement.step)}set step(e){this._hostElement.step=ci(e).toString(),this._cdr.detectChanges()}get disabled(){return ia(this._hostElement.disabled)}set disabled(e){this._hostElement.disabled=ia(e),this._cdr.detectChanges(),this._slider.disabled!==this.disabled&&(this._slider.disabled=this.disabled)}get percentage(){return this._slider.min>=this._slider.max?this._slider._isRtl?1:0:(this.value-this._slider.min)/(this._slider.max-this._slider.min)}get fillPercentage(){return this._slider._cachedWidth?0===this._translateX?0:this.translateX/this._slider._cachedWidth:this._slider._isRtl?1:0}_setIsFocused(e){this._isFocused=e}constructor(e,r,s,i){this._ngZone=e,this._elementRef=r,this._cdr=s,this._slider=i,this.valueChange=new On,this.dragStart=new On,this.dragEnd=new On,this.thumbPosition=2,this._knobRadius=8,this._isActive=!1,this._isFocused=!1,this._hasSetInitialValue=!1,this._destroyed=new vn,this._skipUIUpdate=!1,this._onTouchedFn=()=>{},this._isControlInitialized=!1,this._hostElement=r.nativeElement,this._ngZone.runOutsideAngular(()=>{this._hostElement.addEventListener("pointerdown",this._onPointerDown.bind(this)),this._hostElement.addEventListener("pointermove",this._onPointerMove.bind(this)),this._hostElement.addEventListener("pointerup",this._onPointerUp.bind(this))})}ngOnDestroy(){this._hostElement.removeEventListener("pointerdown",this._onPointerDown),this._hostElement.removeEventListener("pointermove",this._onPointerMove),this._hostElement.removeEventListener("pointerup",this._onPointerUp),this._destroyed.next(),this._destroyed.complete(),this.dragStart.complete(),this.dragEnd.complete()}initProps(){this._updateWidthInactive(),this.disabled!==this._slider.disabled&&(this._slider.disabled=!0),this.step=this._slider.step,this.min=this._slider.min,this.max=this._slider.max,this._initValue()}initUI(){this._updateThumbUIByValue()}_initValue(){this._hasSetInitialValue=!0,void 0===this._initialValue?this.value=this._getDefaultValue():(this._hostElement.value=this._initialValue,this._updateThumbUIByValue(),this._slider._onValueChange(this),this._cdr.detectChanges())}_getDefaultValue(){return this.min}_onBlur(){this._setIsFocused(!1),this._onTouchedFn()}_onFocus(){this._setIsFocused(!0)}_onChange(){this.valueChange.emit(this.value),this._isActive&&this._updateThumbUIByValue({withAnimation:!0})}_onInput(){this._onChangeFn?.(this.value),(this._slider.step||!this._isActive)&&this._updateThumbUIByValue({withAnimation:!0}),this._slider._onValueChange(this)}_onNgControlValueChange(){(!this._isActive||!this._isFocused)&&(this._slider._onValueChange(this),this._updateThumbUIByValue()),this._slider.disabled=this._formControl.disabled}_onPointerDown(e){this.disabled||0!==e.button||(this._isActive=!0,this._setIsFocused(!0),this._updateWidthActive(),this._slider._updateDimensions(),this._slider.step||this._updateThumbUIByPointerEvent(e,{withAnimation:!0}),this.disabled||(this._handleValueCorrection(e),this.dragStart.emit({source:this,parent:this._slider,value:this.value})))}_handleValueCorrection(e){this._skipUIUpdate=!0,setTimeout(()=>{this._skipUIUpdate=!1,this._fixValue(e)},0)}_fixValue(e){const r=e.clientX-this._slider._cachedLeft,s=this._slider._cachedWidth,i=0===this._slider.step?1:this._slider.step,o=Math.floor((this._slider.max-this._slider.min)/i),c=Math.round((this._slider._isRtl?1-r/s:r/s)*o)/o*(this._slider.max-this._slider.min)+this._slider.min,p=Math.round(c/i)*i;if(p===this.value)return this._slider._onValueChange(this),void(this._slider.step>0?this._updateThumbUIByValue():this._updateThumbUIByPointerEvent(e,{withAnimation:this._slider._hasAnimation}));this.value=p,this.valueChange.emit(this.value),this._onChangeFn?.(this.value),this._slider._onValueChange(this),this._slider.step>0?this._updateThumbUIByValue():this._updateThumbUIByPointerEvent(e,{withAnimation:this._slider._hasAnimation})}_onPointerMove(e){!this._slider.step&&this._isActive&&this._updateThumbUIByPointerEvent(e)}_onPointerUp(){this._isActive&&(this._isActive=!1,this.dragEnd.emit({source:this,parent:this._slider,value:this.value}),setTimeout(()=>this._updateWidthInactive()))}_clamp(e){return Math.max(Math.min(e,this._slider._cachedWidth),0)}_calcTranslateXByValue(){return this._slider._isRtl?(1-this.percentage)*this._slider._cachedWidth:this.percentage*this._slider._cachedWidth}_calcTranslateXByPointerEvent(e){return e.clientX-this._slider._cachedLeft}_updateWidthActive(){this._hostElement.style.padding=`0 ${this._slider._inputPadding}px`,this._hostElement.style.width=`calc(100% + ${this._slider._inputPadding}px)`}_updateWidthInactive(){this._hostElement.style.padding="0px",this._hostElement.style.width="calc(100% + 48px)",this._hostElement.style.left="-24px"}_updateThumbUIByValue(e){this.translateX=this._clamp(this._calcTranslateXByValue()),this._updateThumbUI(e)}_updateThumbUIByPointerEvent(e,r){this.translateX=this._clamp(this._calcTranslateXByPointerEvent(e)),this._updateThumbUI(r)}_updateThumbUI(e){this._slider._setTransition(!!e?.withAnimation),this._slider._onTranslateXChange(this)}writeValue(e){(this._isControlInitialized||null!==e)&&(this.value=e)}registerOnChange(e){this._onChangeFn=e,this._isControlInitialized=!0}registerOnTouched(e){this._onTouchedFn=e}setDisabledState(e){this.disabled=e}focus(){this._hostElement.focus()}blur(){this._hostElement.blur()}}return n.\u0275fac=function(e){return new(e||n)(Ee(Zt),Ee(tr),Ee(Ta),Ee(Iw))},n.\u0275dir=Pt({type:n,selectors:[["input","matSliderThumb",""]],hostAttrs:["type","range",1,"mdc-slider__input"],hostVars:1,hostBindings:function(e,r){1&e&&br("change",function(){return r._onChange()})("input",function(){return r._onInput()})("blur",function(){return r._onBlur()})("focus",function(){return r._onFocus()}),2&e&&Zs("aria-valuetext",r._valuetext)},inputs:{value:"value"},outputs:{valueChange:"valueChange",dragStart:"dragStart",dragEnd:"dragEnd"},exportAs:["matSliderThumb"],features:[Fn([sMe,{provide:x6,useExisting:n}])]}),n})(),aMe=(()=>{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275mod=ar({type:n}),n.\u0275inj=Jn({imports:[qc,o1,YG]}),n})();const C6=function(n,t,e){return{boundItemGreen:n,boundItemYellow:t,boundItemRed:e}};function lMe(n,t){if(1&n&&(nn(0,"div")(1,"div",5)(2,"p",6),Er(3),mf(4,"number"),Yt(),nn(5,"p",7),Er(6),mf(7,"number"),Yt()(),nn(8,"p",8),Er(9,"confidence span"),Yt(),nn(10,"p",8),Er(11),mf(12,"number"),Yt()()),2&n){const e=Bl();Sn(2),Ir("ngClass",uS(14,C6,e.confidenceSpan<=2,e.confidenceSpan>2&&e.confidenceSpan<=4,e.confidenceSpan>4)),Sn(1),sc(gf(4,5,e.lower10Quantile,"1.2-2")),Sn(2),Ir("ngClass",uS(18,C6,e.confidenceSpan<=2,e.confidenceSpan>2&&e.confidenceSpan<=4,e.confidenceSpan>4)),Sn(1),sc(gf(7,8,e.upper90Quantile,"1.2-2")),Sn(5),sc(gf(12,11,e.confidenceSpan,"1.2-2"))}}let uMe=(()=>{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275cmp=Bo({type:n,selectors:[["app-prediction"]],inputs:{predictionTitle:"predictionTitle",predictionValue:"predictionValue",lower10Quantile:"lower10Quantile",upper90Quantile:"upper90Quantile",confidenceSpan:"confidenceSpan"},decls:10,vars:6,consts:[[1,"block","border","border-sky-500","justify-center","items-center","mb-3"],[1,"flex","justify-center","items-center","mb-3"],["data-tooltip-target","tooltip-default","id","prediction",1,"text-sm","font-bold","text-center","text-gray-900"],["id","prediction_value",1,"text-xl","p-2","font-bold","text-center","text-gray-900"],[4,"ngIf"],[1,"bound","float-root","justify-center","items-center"],[1,"float-left",3,"ngClass"],[1,"float-right",3,"ngClass"],[1,"font-bold","items-center","text-center"]],template:function(e,r){1&e&&(nn(0,"div",0)(1,"div",1)(2,"h2",2),Er(3),Yt(),nn(4,"h1",3),Er(5),mf(6,"number"),Yt(),nn(7,"p"),Er(8,"inches"),Yt()(),ya(9,lMe,13,22,"div",4),Yt()),2&e&&(Sn(3),ic("",r.predictionTitle,":"),Sn(2),sc(gf(6,3,r.predictionValue,"1.2-2")),Sn(4),Ir("ngIf",r.lower10Quantile||r.upper90Quantile))},dependencies:[BF,Fb,HF],styles:['p.boundItemRed[_ngcontent-%COMP%]{display:inline-block;border:4px solid red;padding:1em;position:relative}.boundItemRed[_ngcontent-%COMP%]:before, .boundItemRed[_ngcontent-%COMP%]:after{content:"";width:5em;border-bottom:4px solid red;position:absolute;top:50%}.boundItemRed[_ngcontent-%COMP%]:first-of-type:before, .boundItemRed[_ngcontent-%COMP%]:last-of-type:after{display:none}p.boundItemYellow[_ngcontent-%COMP%]{display:inline-block;border:4px solid yellow;padding:1em;position:relative}.boundItemYellow[_ngcontent-%COMP%]:before, .boundItemYellow[_ngcontent-%COMP%]:after{content:"";width:5em;border-bottom:4px solid yellow;position:absolute;top:50%}.boundItemYellow[_ngcontent-%COMP%]:first-of-type:before, .boundItemYellow[_ngcontent-%COMP%]:last-of-type:after{display:none}p.boundItemGreen[_ngcontent-%COMP%]{display:inline-block;border:4px solid green;padding:1em;position:relative}.boundItemGreen[_ngcontent-%COMP%]:before, .boundItemGreen[_ngcontent-%COMP%]:after{content:"";width:5em;border-bottom:4px solid green;position:absolute;top:50%}[_ngcontent-%COMP%]:after{left:100%}[_ngcontent-%COMP%]:before{right:100%}.boundItemGreen[_ngcontent-%COMP%]:first-of-type:before, .boundItemGreen[_ngcontent-%COMP%]:last-of-type:after{display:none}']}),n})();function cMe(n,t){if(1&n){const e=function NR(){return Xe()}();nn(0,"div")(1,"div",23)(2,"app-prediction",24),br("click",function(){const i=function WN(n){return Bt.lFrame.contextLView=n,n[Cr]}(e).$implicit;return function HN(n){return Bt.lFrame.contextLView=null,n}(Bl().onClickPrediction(i.target))}),Yt()()()}if(2&n){const e=t.$implicit;Sn(2),Ir("predictionTitle",e.target)("predictionValue",e[.5])("lower10Quantile",e[.1])("upper90Quantile",e[.9])("confidenceSpan",e.confidenceSpan)}}let dMe=(()=>{class n{constructor(e,r,s){this.onnxModel=e,this.onnxConfModel=r,this.dialog=s,this.title="wams-ml-app",this.heightInInches=68,this.heightInFeetAndInches="5'8\"",this.weightInPounds=170,this.age=30,this.gender="male",this.genderInt=1,this.modelButtons=[{name:"Linear Regression",ID:"reg"},{name:"LightGBM Conf",ID:"conf"}],this.targetPredictions=[],this.targetMeasures=["hipbreadthsitting","bideltoidbreadth","chestbreadth","sittingheight","buttockpopliteallength","thighclearance","tibialheight","buttockkneelength","elbowrestheight","kneeheightsitting"],this.chosenModel="LightGBM Conf"}ngOnInit(){var e=this;return Ve(function*(){yield e.loadHipModel(),yield e.loadUpperLegModel(),yield e.loadLowerLegModel(),e.predict()})()}onChangeHeight(e){this.heightInInches=+e.target.value,this.heightInFeetAndInches=this.convertInchesToFeetAndInches(this.heightInInches),this.predict()}convertInchesToFeetAndInches(e){return`${Math.floor(e/12)}'${e%12}"`}onChangeWeight(e){this.weightInPounds=+e.target.value,this.predict()}onChangeAge(e){this.age=+e.target.value,this.predict()}onChangeGender(e){this.gender=e.target.value,"male"===this.gender?this.genderInt=1:"female"===this.gender&&(this.genderInt=2),this.predict()}onChangeModel(e){this.chosenModel=e.value,"Linear Regression"===this.chosenModel&&(this.upper90Quantile=null,this.lower10Quantile=null,this.confidenceSpan=null),this.predict()}loadHipModel(){var e=this;return Ve(function*(){e.hipModel=yield oA("assets/hip_model/model.json")})()}loadUpperLegModel(){var e=this;return Ve(function*(){e.upperLegModel=yield oA("assets/upper_leg_model/model.json")})()}loadLowerLegModel(){var e=this;return Ve(function*(){e.lowerLegModel=yield oA("assets/lower_leg_model/model.json")})()}formatLabel(e){return Math.floor(e/12),`${e}`}predict(){var e=this;return Ve(function*(){const r=kh([e.age,e.heightInInches,e.weightInPounds,e.genderInt],[1,4]);if("Linear Regression"===e.chosenModel){const s=e.hipModel.predict(r);e.hipPredictionValue=e.roundToNearestQuarterInch(s.dataSync()[0]);const i=e.upperLegModel.predict(r);e.upperLegPredictionValue=e.roundToNearestQuarterInch(i.dataSync()[0]);const o=e.lowerLegModel.predict(r);e.lowerLegPredictionValue=e.roundToNearestQuarterInch(o.dataSync()[0])}else if("LightGBM"===e.chosenModel)yield e.onnxModel.predict(e.age,e.heightInInches,e.weightInPounds,e.genderInt).then(s=>{e.hipPredictionValue=e.roundToNearestQuarterInch(s),e.upperLegPredictionValue=null,e.lowerLegPredictionValue=null});else if("LightGBM Conf"===e.chosenModel){e.targetPredictions=[];for(const s of e.targetMeasures){const i=yield e.predictWithConfidence(s);e.targetPredictions.push(i)}}})()}predictWithConfidence(e){var r=this;return Ve(function*(){let s=null,i=new LNe;i.target=e,yield r.onnxConfModel.getConfidenceModelURLs(e).then(o=>{s=o});for(const[o,a]of Object.entries(s))yield r.onnxConfModel.predictConfidence(a,r.age,r.heightInInches,r.weightInPounds,r.genderInt).then(u=>{switch(o){case"0.1":i[.1]=u;break;case"0.5":i[.5]=u;break;case"0.9":i[.9]=u}i.confidenceSpan=i[.9]-i[.1]});return i})()}roundToNearestQuarterInch(e){return Math.round(4*e)/4}onClickPrediction(e){this.dialog.open(GOe,{width:"500px",height:"665px",data:{name:e,image:`assets/images/${e}.png`}}).afterClosed().subscribe(s=>{})}}return n.\u0275fac=function(e){return new(e||n)(Ee(WOe),Ee(HOe),Ee(fW))},n.\u0275cmp=Bo({type:n,selectors:[["app-root"]],decls:50,vars:11,consts:[[1,"bg-gradient-to-tr","from-fuchsia-300","to-sky-500"],["id","login",1,"p-4","flex","flex-col","justify-center","min-h-screen","max-w-md","mx-auto"],[1,"p-6","bg-sky-100","rounded"],["src","assets/images/wams_logo.jpeg","alt","WAMS Logo",1,"w-22","h-28","mx-auto"],[1,"flex","items-center","justify-center","font-black","m-3","mb-12"],["id","wams_form","action","api_login","method","POST",1,"flex","flex-col"],[1,"flex","justify-between","items-center","mb-3"],["for","height-range",1,"block","font-extrabold","mb-2","underline","text-sm","text-center","text-slate-700"],["for","height-range",1,"block","mb-2","text-sm","font-medium","text-slate-700"],["min","32","max","90","id","height-range","step","1","showTickMarks","","discrete","",3,"displayWith"],["matSliderThumb","",3,"value","change"],["min","90","max","400","id","height-range","step","1","showTickMarks","","discrete","",3,"displayWith"],["min","18","max","120","id","height-range","step","1","showTickMarks","","discrete","",3,"displayWith"],[1,"justify-between","w-full","mb-3","items-center"],["id","male-radio","type","radio","value","male","checked","","name","default-radio",1,"w-4","h-4","text-blue-600","bg-gray-100","border-gray-300","focus:ring-blue-500","dark:focus:ring-blue-600","dark:ring-offset-gray-800","focus:ring-2","dark:bg-gray-700","dark:border-gray-600",3,"change"],["for","default-radio-1",1,"ml-2","pr-5","text-sm","font-medium","text-gray-900"],["id","female-radio","type","radio","value","female","name","default-radio",1,"w-4","h-4","text-blue-600","bg-gray-100","border-gray-300","focus:ring-blue-500","dark:focus:ring-blue-600","dark:ring-offset-gray-800","focus:ring-2","dark:bg-gray-700","dark:border-gray-600",3,"change"],["id","other-radio","type","radio","value","other","name","default-radio",1,"w-4","h-4","text-blue-600","bg-gray-100","border-gray-300","focus:ring-blue-500","dark:focus:ring-blue-600","dark:ring-offset-gray-800","focus:ring-2","dark:bg-gray-700","dark:border-gray-600",3,"change"],[4,"ngFor","ngForOf"],["src","assets/images/recover-logo.png","alt","WAMS Logo",1,"w-22","h-28","mx-auto"],[1,"flex","justify-center","items-center","p-4"],[1,"text-gray-700","text-sm"],["href","https://www.openlab.psu.edu/ansur2/","target","_blank",1,"text-gray-700","hover:text-gray-900"],[1,"block","items-center","mb-3","w-full"],[3,"predictionTitle","predictionValue","lower10Quantile","upper90Quantile","confidenceSpan","click"]],template:function(e,r){1&e&&(nn(0,"div",0)(1,"section",1)(2,"div",2)(3,"div")(4,"h3"),Er(5,"Wheelchair Automated Measurement System"),Yt(),Qs(6,"img",3),Yt(),Qs(7,"div",4),nn(8,"form",5)(9,"div",6)(10,"label",7),Er(11,"Height:"),Yt(),nn(12,"label",8),Er(13),Yt()(),nn(14,"mat-slider",9)(15,"input",10),br("change",function(i){return r.onChangeHeight(i)}),Yt()(),nn(16,"div",6)(17,"label",7),Er(18,"Weight:"),Yt(),nn(19,"label",8),Er(20),Yt()(),nn(21,"mat-slider",11)(22,"input",10),br("change",function(i){return r.onChangeWeight(i)}),Yt()(),nn(23,"div",6)(24,"label",7),Er(25,"Age:"),Yt(),nn(26,"label",8),Er(27),Yt()(),nn(28,"mat-slider",12)(29,"input",10),br("change",function(i){return r.onChangeAge(i)}),Yt()(),nn(30,"div",6)(31,"label",7),Er(32,"Gender:"),Yt()(),nn(33,"div",13)(34,"input",14),br("change",function(i){return r.onChangeGender(i)}),Yt(),nn(35,"label",15),Er(36,"Male"),Yt(),nn(37,"input",16),br("change",function(i){return r.onChangeGender(i)}),Yt(),nn(38,"label",15),Er(39,"Female"),Yt(),nn(40,"input",17),br("change",function(i){return r.onChangeGender(i)}),Yt(),nn(41,"label",15),Er(42,"Other"),Yt()(),ya(43,cMe,3,5,"div",18),nn(44,"div"),Qs(45,"img",19),Yt()()()(),nn(46,"footer",20)(47,"p",21)(48,"a",22),Er(49,'Gordon, C.C., Blackwell, C.L., Bradtmiller, B., Parham, J.L., Barrientos, P., Paquette, S.P., Corner, B.D., Carson, J.M., Venezia, J.C., Rockwell, B.M., Mucher, M., Kristensen, S. (2014). "2012 Anthropometric Survey of U.S. Army Personnel: Methods and Summary Statistics." Final Report, U.S. Army Natick Soldier Research, Development and Engineering Center, Natick, Massachusetts. December 2014. Approved for public release; distribution is unlimited.'),Yt()()()()),2&e&&(Sn(13),ZT("",r.heightInInches," inches (",r.heightInFeetAndInches,")"),Sn(1),Ir("displayWith",r.formatLabel),Sn(1),af("value",r.heightInInches),Sn(5),ic("",r.weightInPounds," lbs"),Sn(1),Ir("displayWith",r.formatLabel),Sn(1),af("value",r.weightInPounds),Sn(5),ic("",r.age," y/o"),Sn(1),Ir("displayWith",r.formatLabel),Sn(1),af("value",r.age),Sn(14),Ir("ngForOf",r.targetPredictions))},dependencies:[e1,n6,zW,Cw,nMe,Ak,uMe]}),n})();function I6(n){return new je(3e3,!1)}function Pu(n){switch(n.length){case 0:return new Bg;case 1:return n[0];default:return new oW(n)}}function E6(n,t,e,r,s=new Map,i=new Map){const o=[],a=[];let u=-1,c=null;if(r.forEach(p=>{const m=p.get("offset"),y=m==u,_=y&&c||new Map;p.forEach((w,T)=>{let I=T,O=w;if("offset"!==T)switch(I=t.normalizePropertyName(I,o),O){case lk:O=s.get(T);break;case Tl:O=i.get(T);break;default:O=t.normalizeStyleValue(T,I,O,o)}_.set(I,O)}),y||a.push(_),c=_,u=m}),o.length)throw function MMe(n){return new je(3502,!1)}();return a}function kk(n,t,e,r){switch(t){case"start":n.onStart(()=>r(e&&Nk(e,"start",n)));break;case"done":n.onDone(()=>r(e&&Nk(e,"done",n)));break;case"destroy":n.onDestroy(()=>r(e&&Nk(e,"destroy",n)))}}function Nk(n,t,e){const i=Ok(n.element,n.triggerName,n.fromState,n.toState,t||n.phaseName,e.totalTime??n.totalTime,!!e.disabled),o=n._data;return null!=o&&(i._data=o),i}function Ok(n,t,e,r,s="",i=0,o){return{element:n,triggerName:t,fromState:e,toState:r,phaseName:s,totalTime:i,disabled:!!o}}function Ji(n,t,e){let r=n.get(t);return r||n.set(t,r=e),r}function D6(n){const t=n.indexOf(":");return[n.substring(1,t),n.slice(t+1)]}const HMe=(()=>typeof document>"u"?null:document.documentElement)();function Rk(n){const t=n.parentNode||n.host||null;return t===HMe?null:t}let Yc=null,A6=!1;function k6(n,t){for(;t;){if(t===n)return!0;t=Rk(t)}return!1}function N6(n,t,e){if(e)return Array.from(n.querySelectorAll(t));const r=n.querySelector(t);return r?[r]:[]}let O6=(()=>{class n{validateStyleProperty(e){return function KMe(n){Yc||(Yc=function XMe(){return typeof document<"u"?document.body:null}()||{},A6=!!Yc.style&&"WebkitAppearance"in Yc.style);let t=!0;return Yc.style&&!function qMe(n){return"ebkit"==n.substring(1,6)}(n)&&(t=n in Yc.style,!t&&A6&&(t="Webkit"+n.charAt(0).toUpperCase()+n.slice(1)in Yc.style)),t}(e)}matchesElement(e,r){return!1}containsElement(e,r){return k6(e,r)}getParentElement(e){return Rk(e)}query(e,r,s){return N6(e,r,s)}computeStyle(e,r,s){return s||""}animate(e,r,s,i,o,a=[],u){return new Bg(s,i)}}return n.\u0275fac=function(e){return new(e||n)},n.\u0275prov=ht({token:n,factory:n.\u0275fac}),n})(),Mk=(()=>{class n{}return n.NOOP=new O6,n})();const YMe=1e3,Pk="ng-enter",Ew="ng-leave",Dw="ng-trigger",Aw=".ng-trigger",M6="ng-animating",Fk=".ng-animating";function Sl(n){if("number"==typeof n)return n;const t=n.match(/^(-?[\.\d]+)(m?s)/);return!t||t.length<2?0:$k(parseFloat(t[1]),t[2])}function $k(n,t){return"s"===t?n*YMe:n}function kw(n,t,e){return n.hasOwnProperty("duration")?n:function QMe(n,t,e){let s,i=0,o="";if("string"==typeof n){const a=n.match(/^(-?[\.\d]+)(m?s)(?:\s+(-?[\.\d]+)(m?s))?(?:\s+([-a-z]+(?:\(.+?\))?))?$/i);if(null===a)return t.push(I6()),{duration:0,delay:0,easing:""};s=$k(parseFloat(a[1]),a[2]);const u=a[3];null!=u&&(i=$k(parseFloat(u),a[4]));const c=a[5];c&&(o=c)}else s=n;if(!e){let a=!1,u=t.length;s<0&&(t.push(function hMe(){return new je(3100,!1)}()),a=!0),i<0&&(t.push(function pMe(){return new je(3101,!1)}()),a=!0),a&&t.splice(u,0,I6())}return{duration:s,delay:i,easing:o}}(n,t,e)}function Wg(n,t={}){return Object.keys(n).forEach(e=>{t[e]=n[e]}),t}function P6(n){const t=new Map;return Object.keys(n).forEach(e=>{t.set(e,n[e])}),t}function Fu(n,t=new Map,e){if(e)for(let[r,s]of e)t.set(r,s);for(let[r,s]of n)t.set(r,s);return t}function Ga(n,t,e){t.forEach((r,s)=>{const i=Vk(s);e&&!e.has(s)&&e.set(s,n.style[i]),n.style[i]=r})}function Zc(n,t){t.forEach((e,r)=>{const s=Vk(r);n.style[s]=""})}function Hg(n){return Array.isArray(n)?1==n.length?n[0]:eW(n):n}const Lk=new RegExp("{{\\s*(.+?)\\s*}}","g");function $6(n){let t=[];if("string"==typeof n){let e;for(;e=Lk.exec(n);)t.push(e[1]);Lk.lastIndex=0}return t}function qg(n,t,e){const r=n.toString(),s=r.replace(Lk,(i,o)=>{let a=t[o];return null==a&&(e.push(function mMe(n){return new je(3003,!1)}()),a=""),a.toString()});return s==r?n:s}function Nw(n){const t=[];let e=n.next();for(;!e.done;)t.push(e.value),e=n.next();return t}const tPe=/-+([a-z0-9])/g;function Vk(n){return n.replace(tPe,(...t)=>t[1].toUpperCase())}function eo(n,t,e){switch(t.type){case 7:return n.visitTrigger(t,e);case 0:return n.visitState(t,e);case 1:return n.visitTransition(t,e);case 2:return n.visitSequence(t,e);case 3:return n.visitGroup(t,e);case 4:return n.visitAnimate(t,e);case 5:return n.visitKeyframes(t,e);case 6:return n.visitStyle(t,e);case 8:return n.visitReference(t,e);case 9:return n.visitAnimateChild(t,e);case 10:return n.visitAnimateRef(t,e);case 11:return n.visitQuery(t,e);case 12:return n.visitStagger(t,e);default:throw function gMe(n){return new je(3004,!1)}()}}function L6(n,t){return window.getComputedStyle(n)[t]}const Ow="*";function sPe(n,t){const e=[];return"string"==typeof n?n.split(/\s*,\s*/).forEach(r=>function iPe(n,t,e){if(":"==n[0]){const u=function oPe(n,t){switch(n){case":enter":return"void => *";case":leave":return"* => void";case":increment":return(e,r)=>parseFloat(r)>parseFloat(e);case":decrement":return(e,r)=>parseFloat(r)<parseFloat(e);default:return t.push(function kMe(n){return new je(3016,!1)}()),"* => *"}}(n,e);if("function"==typeof u)return void t.push(u);n=u}const r=n.match(/^(\*|[-\w]+)\s*(<?[=-]>)\s*(\*|[-\w]+)$/);if(null==r||r.length<4)return e.push(function AMe(n){return new je(3015,!1)}()),t;const s=r[1],i=r[2],o=r[3];t.push(V6(s,o));"<"==i[0]&&!(s==Ow&&o==Ow)&&t.push(V6(o,s))}(r,e,t)):e.push(n),e}const Rw=new Set(["true","1"]),Mw=new Set(["false","0"]);function V6(n,t){const e=Rw.has(n)||Mw.has(n),r=Rw.has(t)||Mw.has(t);return(s,i)=>{let o=n==Ow||n==s,a=t==Ow||t==i;return!o&&e&&"boolean"==typeof s&&(o=s?Rw.has(n):Mw.has(n)),!a&&r&&"boolean"==typeof i&&(a=i?Rw.has(t):Mw.has(t)),o&&a}}const aPe=new RegExp("s*:selfs*,?","g");function Bk(n,t,e,r){return new lPe(n).build(t,e,r)}class lPe{constructor(t){this._driver=t}build(t,e,r){const s=new dPe(e);return this._resetContextStyleTimingState(s),eo(this,Hg(t),s)}_resetContextStyleTimingState(t){t.currentQuerySelector="",t.collectedStyles=new Map,t.collectedStyles.set("",new Map),t.currentTime=0}visitTrigger(t,e){let r=e.queryCount=0,s=e.depCount=0;const i=[],o=[];return"@"==t.name.charAt(0)&&e.errors.push(function bMe(){return new je(3006,!1)}()),t.definitions.forEach(a=>{if(this._resetContextStyleTimingState(e),0==a.type){const u=a,c=u.name;c.toString().split(/\s*,\s*/).forEach(p=>{u.name=p,i.push(this.visitState(u,e))}),u.name=c}else if(1==a.type){const u=this.visitTransition(a,e);r+=u.queryCount,s+=u.depCount,o.push(u)}else e.errors.push(function _Me(){return new je(3007,!1)}())}),{type:7,name:t.name,states:i,transitions:o,queryCount:r,depCount:s,options:null}}visitState(t,e){const r=this.visitStyle(t.styles,e),s=t.options&&t.options.params||null;if(r.containsDynamicStyles){const i=new Set,o=s||{};r.styles.forEach(a=>{a instanceof Map&&a.forEach(u=>{$6(u).forEach(c=>{o.hasOwnProperty(c)||i.add(c)})})}),i.size&&(Nw(i.values()),e.errors.push(function vMe(n,t){return new je(3008,!1)}()))}return{type:0,name:t.name,style:r,options:s?{params:s}:null}}visitTransition(t,e){e.queryCount=0,e.depCount=0;const r=eo(this,Hg(t.animation),e);return{type:1,matchers:sPe(t.expr,e.errors),animation:r,queryCount:e.queryCount,depCount:e.depCount,options:Qc(t.options)}}visitSequence(t,e){return{type:2,steps:t.steps.map(r=>eo(this,r,e)),options:Qc(t.options)}}visitGroup(t,e){const r=e.currentTime;let s=0;const i=t.steps.map(o=>{e.currentTime=r;const a=eo(this,o,e);return s=Math.max(s,e.currentTime),a});return e.currentTime=s,{type:3,steps:i,options:Qc(t.options)}}visitAnimate(t,e){const r=function pPe(n,t){if(n.hasOwnProperty("duration"))return n;if("number"==typeof n)return zk(kw(n,t).duration,0,"");const e=n;if(e.split(/\s+/).some(i=>"{"==i.charAt(0)&&"{"==i.charAt(1))){const i=zk(0,0,"");return i.dynamic=!0,i.strValue=e,i}const s=kw(e,t);return zk(s.duration,s.delay,s.easing)}(t.timings,e.errors);e.currentAnimateTimings=r;let s,i=t.styles?t.styles:rp({});if(5==i.type)s=this.visitKeyframes(i,e);else{let o=t.styles,a=!1;if(!o){a=!0;const c={};r.easing&&(c.easing=r.easing),o=rp(c)}e.currentTime+=r.duration+r.delay;const u=this.visitStyle(o,e);u.isEmptyStep=a,s=u}return e.currentAnimateTimings=null,{type:4,timings:r,style:s,options:null}}visitStyle(t,e){const r=this._makeStyleAst(t,e);return this._validateStyleAst(r,e),r}_makeStyleAst(t,e){const r=[],s=Array.isArray(t.styles)?t.styles:[t.styles];for(let a of s)"string"==typeof a?a===Tl?r.push(a):e.errors.push(new je(3002,!1)):r.push(P6(a));let i=!1,o=null;return r.forEach(a=>{if(a instanceof Map&&(a.has("easing")&&(o=a.get("easing"),a.delete("easing")),!i))for(let u of a.values())if(u.toString().indexOf("{{")>=0){i=!0;break}}),{type:6,styles:r,easing:o,offset:t.offset,containsDynamicStyles:i,options:null}}_validateStyleAst(t,e){const r=e.currentAnimateTimings;let s=e.currentTime,i=e.currentTime;r&&i>0&&(i-=r.duration+r.delay),t.styles.forEach(o=>{"string"!=typeof o&&o.forEach((a,u)=>{const c=e.collectedStyles.get(e.currentQuerySelector),p=c.get(u);let m=!0;p&&(i!=s&&i>=p.startTime&&s<=p.endTime&&(e.errors.push(function xMe(n,t,e,r,s){return new je(3010,!1)}()),m=!1),i=p.startTime),m&&c.set(u,{startTime:i,endTime:s}),e.options&&function ePe(n,t,e){const r=t.params||{},s=$6(n);s.length&&s.forEach(i=>{r.hasOwnProperty(i)||e.push(function fMe(n){return new je(3001,!1)}())})}(a,e.options,e.errors)})})}visitKeyframes(t,e){const r={type:5,styles:[],options:null};if(!e.currentAnimateTimings)return e.errors.push(function TMe(){return new je(3011,!1)}()),r;let i=0;const o=[];let a=!1,u=!1,c=0;const p=t.steps.map(O=>{const M=this._makeStyleAst(O,e);let V=null!=M.offset?M.offset:function hPe(n){if("string"==typeof n)return null;let t=null;if(Array.isArray(n))n.forEach(e=>{if(e instanceof Map&&e.has("offset")){const r=e;t=parseFloat(r.get("offset")),r.delete("offset")}});else if(n instanceof Map&&n.has("offset")){const e=n;t=parseFloat(e.get("offset")),e.delete("offset")}return t}(M.styles),z=0;return null!=V&&(i++,z=M.offset=V),u=u||z<0||z>1,a=a||z<c,c=z,o.push(z),M});u&&e.errors.push(function SMe(){return new je(3012,!1)}()),a&&e.errors.push(function CMe(){return new je(3200,!1)}());const m=t.steps.length;let y=0;i>0&&i<m?e.errors.push(function IMe(){return new je(3202,!1)}()):0==i&&(y=1/(m-1));const _=m-1,w=e.currentTime,T=e.currentAnimateTimings,I=T.duration;return p.forEach((O,M)=>{const V=y>0?M==_?1:y*M:o[M],z=V*I;e.currentTime=w+T.delay+z,T.duration=z,this._validateStyleAst(O,e),O.offset=V,r.styles.push(O)}),r}visitReference(t,e){return{type:8,animation:eo(this,Hg(t.animation),e),options:Qc(t.options)}}visitAnimateChild(t,e){return e.depCount++,{type:9,options:Qc(t.options)}}visitAnimateRef(t,e){return{type:10,animation:this.visitReference(t.animation,e),options:Qc(t.options)}}visitQuery(t,e){const r=e.currentQuerySelector,s=t.options||{};e.queryCount++,e.currentQuery=t;const[i,o]=function uPe(n){const t=!!n.split(/\s*,\s*/).find(e=>":self"==e);return t&&(n=n.replace(aPe,"")),n=n.replace(/@\*/g,Aw).replace(/@\w+/g,e=>Aw+"-"+e.slice(1)).replace(/:animating/g,Fk),[n,t]}(t.selector);e.currentQuerySelector=r.length?r+" "+i:i,Ji(e.collectedStyles,e.currentQuerySelector,new Map);const a=eo(this,Hg(t.animation),e);return e.currentQuery=null,e.currentQuerySelector=r,{type:11,selector:i,limit:s.limit||0,optional:!!s.optional,includeSelf:o,animation:a,originalSelector:t.selector,options:Qc(t.options)}}visitStagger(t,e){e.currentQuery||e.errors.push(function EMe(){return new je(3013,!1)}());const r="full"===t.timings?{duration:0,delay:0,easing:"full"}:kw(t.timings,e.errors,!0);return{type:12,animation:eo(this,Hg(t.animation),e),timings:r,options:null}}}class dPe{constructor(t){this.errors=t,this.queryCount=0,this.depCount=0,this.currentTransition=null,this.currentQuery=null,this.currentQuerySelector=null,this.currentAnimateTimings=null,this.currentTime=0,this.collectedStyles=new Map,this.options=null,this.unsupportedCSSPropertiesFound=new Set}}function Qc(n){return n?(n=Wg(n)).params&&(n.params=function cPe(n){return n?Wg(n):null}(n.params)):n={},n}function zk(n,t,e){return{duration:n,delay:t,easing:e}}function Uk(n,t,e,r,s,i,o=null,a=!1){return{type:1,element:n,keyframes:t,preStyleProps:e,postStyleProps:r,duration:s,delay:i,totalTime:s+i,easing:o,subTimeline:a}}class Pw{constructor(){this._map=new Map}get(t){return this._map.get(t)||[]}append(t,e){let r=this._map.get(t);r||this._map.set(t,r=[]),r.push(...e)}has(t){return this._map.has(t)}clear(){this._map.clear()}}const gPe=new RegExp(":enter","g"),bPe=new RegExp(":leave","g");function jk(n,t,e,r,s,i=new Map,o=new Map,a,u,c=[]){return(new _Pe).buildKeyframes(n,t,e,r,s,i,o,a,u,c)}class _Pe{buildKeyframes(t,e,r,s,i,o,a,u,c,p=[]){c=c||new Pw;const m=new Gk(t,e,c,s,i,p,[]);m.options=u;const y=u.delay?Sl(u.delay):0;m.currentTimeline.delayNextStep(y),m.currentTimeline.setStyles([o],null,m.errors,u),eo(this,r,m);const _=m.timelines.filter(w=>w.containsAnimation());if(_.length&&a.size){let w;for(let T=_.length-1;T>=0;T--){const I=_[T];if(I.element===e){w=I;break}}w&&!w.allowOnlyTimelineStyles()&&w.setStyles([a],null,m.errors,u)}return _.length?_.map(w=>w.buildKeyframes()):[Uk(e,[],[],[],0,y,"",!1)]}visitTrigger(t,e){}visitState(t,e){}visitTransition(t,e){}visitAnimateChild(t,e){const r=e.subInstructions.get(e.element);if(r){const s=e.createSubContext(t.options),i=e.currentTimeline.currentTime,o=this._visitSubInstructions(r,s,s.options);i!=o&&e.transformIntoNewTimeline(o)}e.previousNode=t}visitAnimateRef(t,e){const r=e.createSubContext(t.options);r.transformIntoNewTimeline(),this._applyAnimationRefDelays([t.options,t.animation.options],e,r),this.visitReference(t.animation,r),e.transformIntoNewTimeline(r.currentTimeline.currentTime),e.previousNode=t}_applyAnimationRefDelays(t,e,r){for(const s of t){const i=s?.delay;if(i){const o="number"==typeof i?i:Sl(qg(i,s?.params??{},e.errors));r.delayNextStep(o)}}}_visitSubInstructions(t,e,r){let i=e.currentTimeline.currentTime;const o=null!=r.duration?Sl(r.duration):null,a=null!=r.delay?Sl(r.delay):null;return 0!==o&&t.forEach(u=>{const c=e.appendInstructionToTimeline(u,o,a);i=Math.max(i,c.duration+c.delay)}),i}visitReference(t,e){e.updateOptions(t.options,!0),eo(this,t.animation,e),e.previousNode=t}visitSequence(t,e){const r=e.subContextCount;let s=e;const i=t.options;if(i&&(i.params||i.delay)&&(s=e.createSubContext(i),s.transformIntoNewTimeline(),null!=i.delay)){6==s.previousNode.type&&(s.currentTimeline.snapshotCurrentStyles(),s.previousNode=Fw);const o=Sl(i.delay);s.delayNextStep(o)}t.steps.length&&(t.steps.forEach(o=>eo(this,o,s)),s.currentTimeline.applyStylesToKeyframe(),s.subContextCount>r&&s.transformIntoNewTimeline()),e.previousNode=t}visitGroup(t,e){const r=[];let s=e.currentTimeline.currentTime;const i=t.options&&t.options.delay?Sl(t.options.delay):0;t.steps.forEach(o=>{const a=e.createSubContext(t.options);i&&a.delayNextStep(i),eo(this,o,a),s=Math.max(s,a.currentTimeline.currentTime),r.push(a.currentTimeline)}),r.forEach(o=>e.currentTimeline.mergeTimelineCollectedStyles(o)),e.transformIntoNewTimeline(s),e.previousNode=t}_visitTiming(t,e){if(t.dynamic){const r=t.strValue;return kw(e.params?qg(r,e.params,e.errors):r,e.errors)}return{duration:t.duration,delay:t.delay,easing:t.easing}}visitAnimate(t,e){const r=e.currentAnimateTimings=this._visitTiming(t.timings,e),s=e.currentTimeline;r.delay&&(e.incrementTime(r.delay),s.snapshotCurrentStyles());const i=t.style;5==i.type?this.visitKeyframes(i,e):(e.incrementTime(r.duration),this.visitStyle(i,e),s.applyStylesToKeyframe()),e.currentAnimateTimings=null,e.previousNode=t}visitStyle(t,e){const r=e.currentTimeline,s=e.currentAnimateTimings;!s&&r.hasCurrentStyleProperties()&&r.forwardFrame();const i=s&&s.easing||t.easing;t.isEmptyStep?r.applyEmptyStep(i):r.setStyles(t.styles,i,e.errors,e.options),e.previousNode=t}visitKeyframes(t,e){const r=e.currentAnimateTimings,s=e.currentTimeline.duration,i=r.duration,a=e.createSubContext().currentTimeline;a.easing=r.easing,t.styles.forEach(u=>{a.forwardTime((u.offset||0)*i),a.setStyles(u.styles,u.easing,e.errors,e.options),a.applyStylesToKeyframe()}),e.currentTimeline.mergeTimelineCollectedStyles(a),e.transformIntoNewTimeline(s+i),e.previousNode=t}visitQuery(t,e){const r=e.currentTimeline.currentTime,s=t.options||{},i=s.delay?Sl(s.delay):0;i&&(6===e.previousNode.type||0==r&&e.currentTimeline.hasCurrentStyleProperties())&&(e.currentTimeline.snapshotCurrentStyles(),e.previousNode=Fw);let o=r;const a=e.invokeQuery(t.selector,t.originalSelector,t.limit,t.includeSelf,!!s.optional,e.errors);e.currentQueryTotal=a.length;let u=null;a.forEach((c,p)=>{e.currentQueryIndex=p;const m=e.createSubContext(t.options,c);i&&m.delayNextStep(i),c===e.element&&(u=m.currentTimeline),eo(this,t.animation,m),m.currentTimeline.applyStylesToKeyframe(),o=Math.max(o,m.currentTimeline.currentTime)}),e.currentQueryIndex=0,e.currentQueryTotal=0,e.transformIntoNewTimeline(o),u&&(e.currentTimeline.mergeTimelineCollectedStyles(u),e.currentTimeline.snapshotCurrentStyles()),e.previousNode=t}visitStagger(t,e){const r=e.parentContext,s=e.currentTimeline,i=t.timings,o=Math.abs(i.duration),a=o*(e.currentQueryTotal-1);let u=o*e.currentQueryIndex;switch(i.duration<0?"reverse":i.easing){case"reverse":u=a-u;break;case"full":u=r.currentStaggerTime}const p=e.currentTimeline;u&&p.delayNextStep(u);const m=p.currentTime;eo(this,t.animation,e),e.previousNode=t,r.currentStaggerTime=s.currentTime-m+(s.startTime-r.currentTimeline.startTime)}}const Fw={};class Gk{constructor(t,e,r,s,i,o,a,u){this._driver=t,this.element=e,this.subInstructions=r,this._enterClassName=s,this._leaveClassName=i,this.errors=o,this.timelines=a,this.parentContext=null,this.currentAnimateTimings=null,this.previousNode=Fw,this.subContextCount=0,this.options={},this.currentQueryIndex=0,this.currentQueryTotal=0,this.currentStaggerTime=0,this.currentTimeline=u||new $w(this._driver,e,0),a.push(this.currentTimeline)}get params(){return this.options.params}updateOptions(t,e){if(!t)return;const r=t;let s=this.options;null!=r.duration&&(s.duration=Sl(r.duration)),null!=r.delay&&(s.delay=Sl(r.delay));const i=r.params;if(i){let o=s.params;o||(o=this.options.params={}),Object.keys(i).forEach(a=>{(!e||!o.hasOwnProperty(a))&&(o[a]=qg(i[a],o,this.errors))})}}_copyOptions(){const t={};if(this.options){const e=this.options.params;if(e){const r=t.params={};Object.keys(e).forEach(s=>{r[s]=e[s]})}}return t}createSubContext(t=null,e,r){const s=e||this.element,i=new Gk(this._driver,s,this.subInstructions,this._enterClassName,this._leaveClassName,this.errors,this.timelines,this.currentTimeline.fork(s,r||0));return i.previousNode=this.previousNode,i.currentAnimateTimings=this.currentAnimateTimings,i.options=this._copyOptions(),i.updateOptions(t),i.currentQueryIndex=this.currentQueryIndex,i.currentQueryTotal=this.currentQueryTotal,i.parentContext=this,this.subContextCount++,i}transformIntoNewTimeline(t){return this.previousNode=Fw,this.currentTimeline=this.currentTimeline.fork(this.element,t),this.timelines.push(this.currentTimeline),this.currentTimeline}appendInstructionToTimeline(t,e,r){const s={duration:e??t.duration,delay:this.currentTimeline.currentTime+(r??0)+t.delay,easing:""},i=new vPe(this._driver,t.element,t.keyframes,t.preStyleProps,t.postStyleProps,s,t.stretchStartingKeyframe);return this.timelines.push(i),s}incrementTime(t){this.currentTimeline.forwardTime(this.currentTimeline.duration+t)}delayNextStep(t){t>0&&this.currentTimeline.delayNextStep(t)}invokeQuery(t,e,r,s,i,o){let a=[];if(s&&a.push(this.element),t.length>0){t=(t=t.replace(gPe,"."+this._enterClassName)).replace(bPe,"."+this._leaveClassName);let c=this._driver.query(this.element,t,1!=r);0!==r&&(c=r<0?c.slice(c.length+r,c.length):c.slice(0,r)),a.push(...c)}return!i&&0==a.length&&o.push(function DMe(n){return new je(3014,!1)}()),a}}class $w{constructor(t,e,r,s){this._driver=t,this.element=e,this.startTime=r,this._elementTimelineStylesLookup=s,this.duration=0,this.easing=null,this._previousKeyframe=new Map,this._currentKeyframe=new Map,this._keyframes=new Map,this._styleSummary=new Map,this._localTimelineStyles=new Map,this._pendingStyles=new Map,this._backFill=new Map,this._currentEmptyStepKeyframe=null,this._elementTimelineStylesLookup||(this._elementTimelineStylesLookup=new Map),this._globalTimelineStyles=this._elementTimelineStylesLookup.get(e),this._globalTimelineStyles||(this._globalTimelineStyles=this._localTimelineStyles,this._elementTimelineStylesLookup.set(e,this._localTimelineStyles)),this._loadKeyframe()}containsAnimation(){switch(this._keyframes.size){case 0:return!1;case 1:return this.hasCurrentStyleProperties();default:return!0}}hasCurrentStyleProperties(){return this._currentKeyframe.size>0}get currentTime(){return this.startTime+this.duration}delayNextStep(t){const e=1===this._keyframes.size&&this._pendingStyles.size;this.duration||e?(this.forwardTime(this.currentTime+t),e&&this.snapshotCurrentStyles()):this.startTime+=t}fork(t,e){return this.applyStylesToKeyframe(),new $w(this._driver,t,e||this.currentTime,this._elementTimelineStylesLookup)}_loadKeyframe(){this._currentKeyframe&&(this._previousKeyframe=this._currentKeyframe),this._currentKeyframe=this._keyframes.get(this.duration),this._currentKeyframe||(this._currentKeyframe=new Map,this._keyframes.set(this.duration,this._currentKeyframe))}forwardFrame(){this.duration+=1,this._loadKeyframe()}forwardTime(t){this.applyStylesToKeyframe(),this.duration=t,this._loadKeyframe()}_updateStyle(t,e){this._localTimelineStyles.set(t,e),this._globalTimelineStyles.set(t,e),this._styleSummary.set(t,{time:this.currentTime,value:e})}allowOnlyTimelineStyles(){return this._currentEmptyStepKeyframe!==this._currentKeyframe}applyEmptyStep(t){t&&this._previousKeyframe.set("easing",t);for(let[e,r]of this._globalTimelineStyles)this._backFill.set(e,r||Tl),this._currentKeyframe.set(e,Tl);this._currentEmptyStepKeyframe=this._currentKeyframe}setStyles(t,e,r,s){e&&this._previousKeyframe.set("easing",e);const i=s&&s.params||{},o=function wPe(n,t){const e=new Map;let r;return n.forEach(s=>{if("*"===s){r=r||t.keys();for(let i of r)e.set(i,Tl)}else Fu(s,e)}),e}(t,this._globalTimelineStyles);for(let[a,u]of o){const c=qg(u,i,r);this._pendingStyles.set(a,c),this._localTimelineStyles.has(a)||this._backFill.set(a,this._globalTimelineStyles.get(a)??Tl),this._updateStyle(a,c)}}applyStylesToKeyframe(){0!=this._pendingStyles.size&&(this._pendingStyles.forEach((t,e)=>{this._currentKeyframe.set(e,t)}),this._pendingStyles.clear(),this._localTimelineStyles.forEach((t,e)=>{this._currentKeyframe.has(e)||this._currentKeyframe.set(e,t)}))}snapshotCurrentStyles(){for(let[t,e]of this._localTimelineStyles)this._pendingStyles.set(t,e),this._updateStyle(t,e)}getFinalKeyframe(){return this._keyframes.get(this.duration)}get properties(){const t=[];for(let e in this._currentKeyframe)t.push(e);return t}mergeTimelineCollectedStyles(t){t._styleSummary.forEach((e,r)=>{const s=this._styleSummary.get(r);(!s||e.time>s.time)&&this._updateStyle(r,e.value)})}buildKeyframes(){this.applyStylesToKeyframe();const t=new Set,e=new Set,r=1===this._keyframes.size&&0===this.duration;let s=[];this._keyframes.forEach((a,u)=>{const c=Fu(a,new Map,this._backFill);c.forEach((p,m)=>{p===lk?t.add(m):p===Tl&&e.add(m)}),r||c.set("offset",u/this.duration),s.push(c)});const i=t.size?Nw(t.values()):[],o=e.size?Nw(e.values()):[];if(r){const a=s[0],u=new Map(a);a.set("offset",0),u.set("offset",1),s=[a,u]}return Uk(this.element,s,i,o,this.duration,this.startTime,this.easing,!1)}}class vPe extends $w{constructor(t,e,r,s,i,o,a=!1){super(t,e,o.delay),this.keyframes=r,this.preStyleProps=s,this.postStyleProps=i,this._stretchStartingKeyframe=a,this.timings={duration:o.duration,delay:o.delay,easing:o.easing}}containsAnimation(){return this.keyframes.length>1}buildKeyframes(){let t=this.keyframes,{delay:e,duration:r,easing:s}=this.timings;if(this._stretchStartingKeyframe&&e){const i=[],o=r+e,a=e/o,u=Fu(t[0]);u.set("offset",0),i.push(u);const c=Fu(t[0]);c.set("offset",U6(a)),i.push(c);const p=t.length-1;for(let m=1;m<=p;m++){let y=Fu(t[m]);const _=y.get("offset");y.set("offset",U6((e+_*r)/o)),i.push(y)}r=o,e=0,s="",t=i}return Uk(this.element,t,this.preStyleProps,this.postStyleProps,r,e,s,!0)}}function U6(n,t=3){const e=Math.pow(10,t-1);return Math.round(n*e)/e}class Wk{}const xPe=new Set(["width","height","minWidth","minHeight","maxWidth","maxHeight","left","top","bottom","right","fontSize","outlineWidth","outlineOffset","paddingTop","paddingLeft","paddingBottom","paddingRight","marginTop","marginLeft","marginBottom","marginRight","borderRadius","borderWidth","borderTopWidth","borderLeftWidth","borderRightWidth","borderBottomWidth","textIndent","perspective"]);class TPe extends Wk{normalizePropertyName(t,e){return Vk(t)}normalizeStyleValue(t,e,r,s){let i="";const o=r.toString().trim();if(xPe.has(e)&&0!==r&&"0"!==r)if("number"==typeof r)i="px";else{const a=r.match(/^[+-]?[\d\.]+([a-z]*)$/);a&&0==a[1].length&&s.push(function yMe(n,t){return new je(3005,!1)}())}return o+i}}function j6(n,t,e,r,s,i,o,a,u,c,p,m,y){return{type:0,element:n,triggerName:t,isRemovalTransition:s,fromState:e,fromStyles:i,toState:r,toStyles:o,timelines:a,queriedElements:u,preStyleProps:c,postStyleProps:p,totalTime:m,errors:y}}const Hk={};class G6{constructor(t,e,r){this._triggerName=t,this.ast=e,this._stateStyles=r}match(t,e,r,s){return function SPe(n,t,e,r,s){return n.some(i=>i(t,e,r,s))}(this.ast.matchers,t,e,r,s)}buildStyles(t,e,r){let s=this._stateStyles.get("*");return void 0!==t&&(s=this._stateStyles.get(t?.toString())||s),s?s.buildStyles(e,r):new Map}build(t,e,r,s,i,o,a,u,c,p){const m=[],y=this.ast.options&&this.ast.options.params||Hk,w=this.buildStyles(r,a&&a.params||Hk,m),T=u&&u.params||Hk,I=this.buildStyles(s,T,m),O=new Set,M=new Map,V=new Map,z="void"===s,G={params:CPe(T,y),delay:this.ast.options?.delay},Q=p?[]:jk(t,e,this.ast.animation,i,o,w,I,G,c,m);let ne=0;if(Q.forEach(de=>{ne=Math.max(de.duration+de.delay,ne)}),m.length)return j6(e,this._triggerName,r,s,z,w,I,[],[],M,V,ne,m);Q.forEach(de=>{const pe=de.element,Te=Ji(M,pe,new Set);de.preStyleProps.forEach(Oe=>Te.add(Oe));const Ae=Ji(V,pe,new Set);de.postStyleProps.forEach(Oe=>Ae.add(Oe)),pe!==e&&O.add(pe)});const oe=Nw(O.values());return j6(e,this._triggerName,r,s,z,w,I,Q,oe,M,V,ne)}}function CPe(n,t){const e=Wg(t);for(const r in n)n.hasOwnProperty(r)&&null!=n[r]&&(e[r]=n[r]);return e}class IPe{constructor(t,e,r){this.styles=t,this.defaultParams=e,this.normalizer=r}buildStyles(t,e){const r=new Map,s=Wg(this.defaultParams);return Object.keys(t).forEach(i=>{const o=t[i];null!==o&&(s[i]=o)}),this.styles.styles.forEach(i=>{"string"!=typeof i&&i.forEach((o,a)=>{o&&(o=qg(o,s,e));const u=this.normalizer.normalizePropertyName(a,e);o=this.normalizer.normalizeStyleValue(a,u,o,e),r.set(a,o)})}),r}}class DPe{constructor(t,e,r){this.name=t,this.ast=e,this._normalizer=r,this.transitionFactories=[],this.states=new Map,e.states.forEach(s=>{this.states.set(s.name,new IPe(s.style,s.options&&s.options.params||{},r))}),W6(this.states,"true","1"),W6(this.states,"false","0"),e.transitions.forEach(s=>{this.transitionFactories.push(new G6(t,s,this.states))}),this.fallbackTransition=function APe(n,t,e){return new G6(n,{type:1,animation:{type:2,steps:[],options:null},matchers:[(o,a)=>!0],options:null,queryCount:0,depCount:0},t)}(t,this.states)}get containsQueries(){return this.ast.queryCount>0}matchTransition(t,e,r,s){return this.transitionFactories.find(o=>o.match(t,e,r,s))||null}matchStyles(t,e,r){return this.fallbackTransition.buildStyles(t,e,r)}}function W6(n,t,e){n.has(t)?n.has(e)||n.set(e,n.get(t)):n.has(e)&&n.set(t,n.get(e))}const kPe=new Pw;class NPe{constructor(t,e,r){this.bodyNode=t,this._driver=e,this._normalizer=r,this._animations=new Map,this._playersById=new Map,this.players=[]}register(t,e){const r=[],i=Bk(this._driver,e,r,[]);if(r.length)throw function PMe(n){return new je(3503,!1)}();this._animations.set(t,i)}_buildPlayer(t,e,r){const s=t.element,i=E6(0,this._normalizer,0,t.keyframes,e,r);return this._driver.animate(s,i,t.duration,t.delay,t.easing,[],!0)}create(t,e,r={}){const s=[],i=this._animations.get(t);let o;const a=new Map;if(i?(o=jk(this._driver,e,i,Pk,Ew,new Map,new Map,r,kPe,s),o.forEach(p=>{const m=Ji(a,p.element,new Map);p.postStyleProps.forEach(y=>m.set(y,null))})):(s.push(function FMe(){return new je(3300,!1)}()),o=[]),s.length)throw function $Me(n){return new je(3504,!1)}();a.forEach((p,m)=>{p.forEach((y,_)=>{p.set(_,this._driver.computeStyle(m,_,Tl))})});const c=Pu(o.map(p=>{const m=a.get(p.element);return this._buildPlayer(p,new Map,m)}));return this._playersById.set(t,c),c.onDestroy(()=>this.destroy(t)),this.players.push(c),c}destroy(t){const e=this._getPlayer(t);e.destroy(),this._playersById.delete(t);const r=this.players.indexOf(e);r>=0&&this.players.splice(r,1)}_getPlayer(t){const e=this._playersById.get(t);if(!e)throw function LMe(n){return new je(3301,!1)}();return e}listen(t,e,r,s){const i=Ok(e,"","","");return kk(this._getPlayer(t),r,i,s),()=>{}}command(t,e,r,s){if("register"==r)return void this.register(t,s[0]);if("create"==r)return void this.create(t,e,s[0]||{});const i=this._getPlayer(t);switch(r){case"play":i.play();break;case"pause":i.pause();break;case"reset":i.reset();break;case"restart":i.restart();break;case"finish":i.finish();break;case"init":i.init();break;case"setPosition":i.setPosition(parseFloat(s[0]));break;case"destroy":this.destroy(t)}}}const H6="ng-animate-queued",qk="ng-animate-disabled",FPe=[],q6={namespaceId:"",setForRemoval:!1,setForMove:!1,hasAnimation:!1,removedBeforeQueried:!1},$Pe={namespaceId:"",setForMove:!1,setForRemoval:!1,hasAnimation:!1,removedBeforeQueried:!0},Ro="__ng_removed";class Kk{get params(){return this.options.params}constructor(t,e=""){this.namespaceId=e;const r=t&&t.hasOwnProperty("value");if(this.value=function zPe(n){return n??null}(r?t.value:t),r){const i=Wg(t);delete i.value,this.options=i}else this.options={};this.options.params||(this.options.params={})}absorbOptions(t){const e=t.params;if(e){const r=this.options.params;Object.keys(e).forEach(s=>{null==r[s]&&(r[s]=e[s])})}}}const Kg="void",Xk=new Kk(Kg);class LPe{constructor(t,e,r){this.id=t,this.hostElement=e,this._engine=r,this.players=[],this._triggers=new Map,this._queue=[],this._elementListeners=new Map,this._hostClassName="ng-tns-"+t,Mo(e,this._hostClassName)}listen(t,e,r,s){if(!this._triggers.has(e))throw function VMe(n,t){return new je(3302,!1)}();if(null==r||0==r.length)throw function BMe(n){return new je(3303,!1)}();if(!function UPe(n){return"start"==n||"done"==n}(r))throw function zMe(n,t){return new je(3400,!1)}();const i=Ji(this._elementListeners,t,[]),o={name:e,phase:r,callback:s};i.push(o);const a=Ji(this._engine.statesByElement,t,new Map);return a.has(e)||(Mo(t,Dw),Mo(t,Dw+"-"+e),a.set(e,Xk)),()=>{this._engine.afterFlush(()=>{const u=i.indexOf(o);u>=0&&i.splice(u,1),this._triggers.has(e)||a.delete(e)})}}register(t,e){return!this._triggers.has(t)&&(this._triggers.set(t,e),!0)}_getTrigger(t){const e=this._triggers.get(t);if(!e)throw function UMe(n){return new je(3401,!1)}();return e}trigger(t,e,r,s=!0){const i=this._getTrigger(e),o=new Yk(this.id,e,t);let a=this._engine.statesByElement.get(t);a||(Mo(t,Dw),Mo(t,Dw+"-"+e),this._engine.statesByElement.set(t,a=new Map));let u=a.get(e);const c=new Kk(r,this.id);if(!(r&&r.hasOwnProperty("value"))&&u&&c.absorbOptions(u.options),a.set(e,c),u||(u=Xk),c.value!==Kg&&u.value===c.value){if(!function WPe(n,t){const e=Object.keys(n),r=Object.keys(t);if(e.length!=r.length)return!1;for(let s=0;s<e.length;s++){const i=e[s];if(!t.hasOwnProperty(i)||n[i]!==t[i])return!1}return!0}(u.params,c.params)){const T=[],I=i.matchStyles(u.value,u.params,T),O=i.matchStyles(c.value,c.params,T);T.length?this._engine.reportError(T):this._engine.afterFlush(()=>{Zc(t,I),Ga(t,O)})}return}const y=Ji(this._engine.playersByElement,t,[]);y.forEach(T=>{T.namespaceId==this.id&&T.triggerName==e&&T.queued&&T.destroy()});let _=i.matchTransition(u.value,c.value,t,c.params),w=!1;if(!_){if(!s)return;_=i.fallbackTransition,w=!0}return this._engine.totalQueuedPlayers++,this._queue.push({element:t,triggerName:e,transition:_,fromState:u,toState:c,player:o,isFallbackTransition:w}),w||(Mo(t,H6),o.onStart(()=>{op(t,H6)})),o.onDone(()=>{let T=this.players.indexOf(o);T>=0&&this.players.splice(T,1);const I=this._engine.playersByElement.get(t);if(I){let O=I.indexOf(o);O>=0&&I.splice(O,1)}}),this.players.push(o),y.push(o),o}deregister(t){this._triggers.delete(t),this._engine.statesByElement.forEach(e=>e.delete(t)),this._elementListeners.forEach((e,r)=>{this._elementListeners.set(r,e.filter(s=>s.name!=t))})}clearElementCache(t){this._engine.statesByElement.delete(t),this._elementListeners.delete(t);const e=this._engine.playersByElement.get(t);e&&(e.forEach(r=>r.destroy()),this._engine.playersByElement.delete(t))}_signalRemovalForInnerTriggers(t,e){const r=this._engine.driver.query(t,Aw,!0);r.forEach(s=>{if(s[Ro])return;const i=this._engine.fetchNamespacesByElement(s);i.size?i.forEach(o=>o.triggerLeaveAnimation(s,e,!1,!0)):this.clearElementCache(s)}),this._engine.afterFlushAnimationsDone(()=>r.forEach(s=>this.clearElementCache(s)))}triggerLeaveAnimation(t,e,r,s){const i=this._engine.statesByElement.get(t),o=new Map;if(i){const a=[];if(i.forEach((u,c)=>{if(o.set(c,u.value),this._triggers.has(c)){const p=this.trigger(t,c,Kg,s);p&&a.push(p)}}),a.length)return this._engine.markElementAsRemoved(this.id,t,!0,e,o),r&&Pu(a).onDone(()=>this._engine.processLeaveNode(t)),!0}return!1}prepareLeaveAnimationListeners(t){const e=this._elementListeners.get(t),r=this._engine.statesByElement.get(t);if(e&&r){const s=new Set;e.forEach(i=>{const o=i.name;if(s.has(o))return;s.add(o);const u=this._triggers.get(o).fallbackTransition,c=r.get(o)||Xk,p=new Kk(Kg),m=new Yk(this.id,o,t);this._engine.totalQueuedPlayers++,this._queue.push({element:t,triggerName:o,transition:u,fromState:c,toState:p,player:m,isFallbackTransition:!0})})}}removeNode(t,e){const r=this._engine;if(t.childElementCount&&this._signalRemovalForInnerTriggers(t,e),this.triggerLeaveAnimation(t,e,!0))return;let s=!1;if(r.totalAnimations){const i=r.players.length?r.playersByQueriedElement.get(t):[];if(i&&i.length)s=!0;else{let o=t;for(;o=o.parentNode;)if(r.statesByElement.get(o)){s=!0;break}}}if(this.prepareLeaveAnimationListeners(t),s)r.markElementAsRemoved(this.id,t,!1,e);else{const i=t[Ro];(!i||i===q6)&&(r.afterFlush(()=>this.clearElementCache(t)),r.destroyInnerAnimations(t),r._onRemovalComplete(t,e))}}insertNode(t,e){Mo(t,this._hostClassName)}drainQueuedTransitions(t){const e=[];return this._queue.forEach(r=>{const s=r.player;if(s.destroyed)return;const i=r.element,o=this._elementListeners.get(i);o&&o.forEach(a=>{if(a.name==r.triggerName){const u=Ok(i,r.triggerName,r.fromState.value,r.toState.value);u._data=t,kk(r.player,a.phase,u,a.callback)}}),s.markedForDestroy?this._engine.afterFlush(()=>{s.destroy()}):e.push(r)}),this._queue=[],e.sort((r,s)=>{const i=r.transition.ast.depCount,o=s.transition.ast.depCount;return 0==i||0==o?i-o:this._engine.driver.containsElement(r.element,s.element)?1:-1})}destroy(t){this.players.forEach(e=>e.destroy()),this._signalRemovalForInnerTriggers(this.hostElement,t)}elementContainsData(t){let e=!1;return this._elementListeners.has(t)&&(e=!0),e=!!this._queue.find(r=>r.element===t)||e,e}}class VPe{_onRemovalComplete(t,e){this.onRemovalComplete(t,e)}constructor(t,e,r){this.bodyNode=t,this.driver=e,this._normalizer=r,this.players=[],this.newHostElements=new Map,this.playersByElement=new Map,this.playersByQueriedElement=new Map,this.statesByElement=new Map,this.disabledNodes=new Set,this.totalAnimations=0,this.totalQueuedPlayers=0,this._namespaceLookup={},this._namespaceList=[],this._flushFns=[],this._whenQuietFns=[],this.namespacesByHostElement=new Map,this.collectedEnterElements=[],this.collectedLeaveElements=[],this.onRemovalComplete=(s,i)=>{}}get queuedPlayers(){const t=[];return this._namespaceList.forEach(e=>{e.players.forEach(r=>{r.queued&&t.push(r)})}),t}createNamespace(t,e){const r=new LPe(t,e,this);return this.bodyNode&&this.driver.containsElement(this.bodyNode,e)?this._balanceNamespaceList(r,e):(this.newHostElements.set(e,r),this.collectEnterElement(e)),this._namespaceLookup[t]=r}_balanceNamespaceList(t,e){const r=this._namespaceList,s=this.namespacesByHostElement;if(r.length-1>=0){let o=!1,a=this.driver.getParentElement(e);for(;a;){const u=s.get(a);if(u){const c=r.indexOf(u);r.splice(c+1,0,t),o=!0;break}a=this.driver.getParentElement(a)}o||r.unshift(t)}else r.push(t);return s.set(e,t),t}register(t,e){let r=this._namespaceLookup[t];return r||(r=this.createNamespace(t,e)),r}registerTrigger(t,e,r){let s=this._namespaceLookup[t];s&&s.register(e,r)&&this.totalAnimations++}destroy(t,e){if(!t)return;const r=this._fetchNamespace(t);this.afterFlush(()=>{this.namespacesByHostElement.delete(r.hostElement),delete this._namespaceLookup[t];const s=this._namespaceList.indexOf(r);s>=0&&this._namespaceList.splice(s,1)}),this.afterFlushAnimationsDone(()=>r.destroy(e))}_fetchNamespace(t){return this._namespaceLookup[t]}fetchNamespacesByElement(t){const e=new Set,r=this.statesByElement.get(t);if(r)for(let s of r.values())if(s.namespaceId){const i=this._fetchNamespace(s.namespaceId);i&&e.add(i)}return e}trigger(t,e,r,s){if(Lw(e)){const i=this._fetchNamespace(t);if(i)return i.trigger(e,r,s),!0}return!1}insertNode(t,e,r,s){if(!Lw(e))return;const i=e[Ro];if(i&&i.setForRemoval){i.setForRemoval=!1,i.setForMove=!0;const o=this.collectedLeaveElements.indexOf(e);o>=0&&this.collectedLeaveElements.splice(o,1)}if(t){const o=this._fetchNamespace(t);o&&o.insertNode(e,r)}s&&this.collectEnterElement(e)}collectEnterElement(t){this.collectedEnterElements.push(t)}markElementAsDisabled(t,e){e?this.disabledNodes.has(t)||(this.disabledNodes.add(t),Mo(t,qk)):this.disabledNodes.has(t)&&(this.disabledNodes.delete(t),op(t,qk))}removeNode(t,e,r,s){if(Lw(e)){const i=t?this._fetchNamespace(t):null;if(i?i.removeNode(e,s):this.markElementAsRemoved(t,e,!1,s),r){const o=this.namespacesByHostElement.get(e);o&&o.id!==t&&o.removeNode(e,s)}}else this._onRemovalComplete(e,s)}markElementAsRemoved(t,e,r,s,i){this.collectedLeaveElements.push(e),e[Ro]={namespaceId:t,setForRemoval:s,hasAnimation:r,removedBeforeQueried:!1,previousTriggersValues:i}}listen(t,e,r,s,i){return Lw(e)?this._fetchNamespace(t).listen(e,r,s,i):()=>{}}_buildInstruction(t,e,r,s,i){return t.transition.build(this.driver,t.element,t.fromState.value,t.toState.value,r,s,t.fromState.options,t.toState.options,e,i)}destroyInnerAnimations(t){let e=this.driver.query(t,Aw,!0);e.forEach(r=>this.destroyActiveAnimationsForElement(r)),0!=this.playersByQueriedElement.size&&(e=this.driver.query(t,Fk,!0),e.forEach(r=>this.finishActiveQueriedAnimationOnElement(r)))}destroyActiveAnimationsForElement(t){const e=this.playersByElement.get(t);e&&e.forEach(r=>{r.queued?r.markedForDestroy=!0:r.destroy()})}finishActiveQueriedAnimationOnElement(t){const e=this.playersByQueriedElement.get(t);e&&e.forEach(r=>r.finish())}whenRenderingDone(){return new Promise(t=>{if(this.players.length)return Pu(this.players).onDone(()=>t());t()})}processLeaveNode(t){const e=t[Ro];if(e&&e.setForRemoval){if(t[Ro]=q6,e.namespaceId){this.destroyInnerAnimations(t);const r=this._fetchNamespace(e.namespaceId);r&&r.clearElementCache(t)}this._onRemovalComplete(t,e.setForRemoval)}t.classList?.contains(qk)&&this.markElementAsDisabled(t,!1),this.driver.query(t,".ng-animate-disabled",!0).forEach(r=>{this.markElementAsDisabled(r,!1)})}flush(t=-1){let e=[];if(this.newHostElements.size&&(this.newHostElements.forEach((r,s)=>this._balanceNamespaceList(r,s)),this.newHostElements.clear()),this.totalAnimations&&this.collectedEnterElements.length)for(let r=0;r<this.collectedEnterElements.length;r++)Mo(this.collectedEnterElements[r],"ng-star-inserted");if(this._namespaceList.length&&(this.totalQueuedPlayers||this.collectedLeaveElements.length)){const r=[];try{e=this._flushAnimations(r,t)}finally{for(let s=0;s<r.length;s++)r[s]()}}else for(let r=0;r<this.collectedLeaveElements.length;r++)this.processLeaveNode(this.collectedLeaveElements[r]);if(this.totalQueuedPlayers=0,this.collectedEnterElements.length=0,this.collectedLeaveElements.length=0,this._flushFns.forEach(r=>r()),this._flushFns=[],this._whenQuietFns.length){const r=this._whenQuietFns;this._whenQuietFns=[],e.length?Pu(e).onDone(()=>{r.forEach(s=>s())}):r.forEach(s=>s())}}reportError(t){throw function jMe(n){return new je(3402,!1)}()}_flushAnimations(t,e){const r=new Pw,s=[],i=new Map,o=[],a=new Map,u=new Map,c=new Map,p=new Set;this.disabledNodes.forEach(ve=>{p.add(ve);const Se=this.driver.query(ve,".ng-animate-queued",!0);for(let xe=0;xe<Se.length;xe++)p.add(Se[xe])});const m=this.bodyNode,y=Array.from(this.statesByElement.keys()),_=Y6(y,this.collectedEnterElements),w=new Map;let T=0;_.forEach((ve,Se)=>{const xe=Pk+T++;w.set(Se,xe),ve.forEach(ke=>Mo(ke,xe))});const I=[],O=new Set,M=new Set;for(let ve=0;ve<this.collectedLeaveElements.length;ve++){const Se=this.collectedLeaveElements[ve],xe=Se[Ro];xe&&xe.setForRemoval&&(I.push(Se),O.add(Se),xe.hasAnimation?this.driver.query(Se,".ng-star-inserted",!0).forEach(ke=>O.add(ke)):M.add(Se))}const V=new Map,z=Y6(y,Array.from(O));z.forEach((ve,Se)=>{const xe=Ew+T++;V.set(Se,xe),ve.forEach(ke=>Mo(ke,xe))}),t.push(()=>{_.forEach((ve,Se)=>{const xe=w.get(Se);ve.forEach(ke=>op(ke,xe))}),z.forEach((ve,Se)=>{const xe=V.get(Se);ve.forEach(ke=>op(ke,xe))}),I.forEach(ve=>{this.processLeaveNode(ve)})});const G=[],Q=[];for(let ve=this._namespaceList.length-1;ve>=0;ve--)this._namespaceList[ve].drainQueuedTransitions(e).forEach(xe=>{const ke=xe.player,We=xe.element;if(G.push(ke),this.collectedEnterElements.length){const ft=We[Ro];if(ft&&ft.setForMove){if(ft.previousTriggersValues&&ft.previousTriggersValues.has(xe.triggerName)){const kt=ft.previousTriggersValues.get(xe.triggerName),xt=this.statesByElement.get(xe.element);if(xt&&xt.has(xe.triggerName)){const jt=xt.get(xe.triggerName);jt.value=kt,xt.set(xe.triggerName,jt)}}return void ke.destroy()}}const Ke=!m||!this.driver.containsElement(m,We),et=V.get(We),Je=w.get(We),tt=this._buildInstruction(xe,r,Je,et,Ke);if(tt.errors&&tt.errors.length)return void Q.push(tt);if(Ke)return ke.onStart(()=>Zc(We,tt.fromStyles)),ke.onDestroy(()=>Ga(We,tt.toStyles)),void s.push(ke);if(xe.isFallbackTransition)return ke.onStart(()=>Zc(We,tt.fromStyles)),ke.onDestroy(()=>Ga(We,tt.toStyles)),void s.push(ke);const it=[];tt.timelines.forEach(ft=>{ft.stretchStartingKeyframe=!0,this.disabledNodes.has(ft.element)||it.push(ft)}),tt.timelines=it,r.append(We,tt.timelines),o.push({instruction:tt,player:ke,element:We}),tt.queriedElements.forEach(ft=>Ji(a,ft,[]).push(ke)),tt.preStyleProps.forEach((ft,kt)=>{if(ft.size){let xt=u.get(kt);xt||u.set(kt,xt=new Set),ft.forEach((jt,qt)=>xt.add(qt))}}),tt.postStyleProps.forEach((ft,kt)=>{let xt=c.get(kt);xt||c.set(kt,xt=new Set),ft.forEach((jt,qt)=>xt.add(qt))})});if(Q.length){const ve=[];Q.forEach(Se=>{ve.push(function GMe(n,t){return new je(3505,!1)}())}),G.forEach(Se=>Se.destroy()),this.reportError(ve)}const ne=new Map,oe=new Map;o.forEach(ve=>{const Se=ve.element;r.has(Se)&&(oe.set(Se,Se),this._beforeAnimationBuild(ve.player.namespaceId,ve.instruction,ne))}),s.forEach(ve=>{const Se=ve.element;this._getPreviousPlayers(Se,!1,ve.namespaceId,ve.triggerName,null).forEach(ke=>{Ji(ne,Se,[]).push(ke),ke.destroy()})});const de=I.filter(ve=>Q6(ve,u,c)),pe=new Map;X6(pe,this.driver,M,c,Tl).forEach(ve=>{Q6(ve,u,c)&&de.push(ve)});const Ae=new Map;_.forEach((ve,Se)=>{X6(Ae,this.driver,new Set(ve),u,lk)}),de.forEach(ve=>{const Se=pe.get(ve),xe=Ae.get(ve);pe.set(ve,new Map([...Array.from(Se?.entries()??[]),...Array.from(xe?.entries()??[])]))});const Oe=[],Me=[],Pe={};o.forEach(ve=>{const{element:Se,player:xe,instruction:ke}=ve;if(r.has(Se)){if(p.has(Se))return xe.onDestroy(()=>Ga(Se,ke.toStyles)),xe.disabled=!0,xe.overrideTotalTime(ke.totalTime),void s.push(xe);let We=Pe;if(oe.size>1){let et=Se;const Je=[];for(;et=et.parentNode;){const tt=oe.get(et);if(tt){We=tt;break}Je.push(et)}Je.forEach(tt=>oe.set(tt,We))}const Ke=this._buildAnimation(xe.namespaceId,ke,ne,i,Ae,pe);if(xe.setRealPlayer(Ke),We===Pe)Oe.push(xe);else{const et=this.playersByElement.get(We);et&&et.length&&(xe.parentPlayer=Pu(et)),s.push(xe)}}else Zc(Se,ke.fromStyles),xe.onDestroy(()=>Ga(Se,ke.toStyles)),Me.push(xe),p.has(Se)&&s.push(xe)}),Me.forEach(ve=>{const Se=i.get(ve.element);if(Se&&Se.length){const xe=Pu(Se);ve.setRealPlayer(xe)}}),s.forEach(ve=>{ve.parentPlayer?ve.syncPlayerEvents(ve.parentPlayer):ve.destroy()});for(let ve=0;ve<I.length;ve++){const Se=I[ve],xe=Se[Ro];if(op(Se,Ew),xe&&xe.hasAnimation)continue;let ke=[];if(a.size){let Ke=a.get(Se);Ke&&Ke.length&&ke.push(...Ke);let et=this.driver.query(Se,Fk,!0);for(let Je=0;Je<et.length;Je++){let tt=a.get(et[Je]);tt&&tt.length&&ke.push(...tt)}}const We=ke.filter(Ke=>!Ke.destroyed);We.length?jPe(this,Se,We):this.processLeaveNode(Se)}return I.length=0,Oe.forEach(ve=>{this.players.push(ve),ve.onDone(()=>{ve.destroy();const Se=this.players.indexOf(ve);this.players.splice(Se,1)}),ve.play()}),Oe}elementContainsData(t,e){let r=!1;const s=e[Ro];return s&&s.setForRemoval&&(r=!0),this.playersByElement.has(e)&&(r=!0),this.playersByQueriedElement.has(e)&&(r=!0),this.statesByElement.has(e)&&(r=!0),this._fetchNamespace(t).elementContainsData(e)||r}afterFlush(t){this._flushFns.push(t)}afterFlushAnimationsDone(t){this._whenQuietFns.push(t)}_getPreviousPlayers(t,e,r,s,i){let o=[];if(e){const a=this.playersByQueriedElement.get(t);a&&(o=a)}else{const a=this.playersByElement.get(t);if(a){const u=!i||i==Kg;a.forEach(c=>{c.queued||!u&&c.triggerName!=s||o.push(c)})}}return(r||s)&&(o=o.filter(a=>!(r&&r!=a.namespaceId||s&&s!=a.triggerName))),o}_beforeAnimationBuild(t,e,r){const i=e.element,o=e.isRemovalTransition?void 0:t,a=e.isRemovalTransition?void 0:e.triggerName;for(const u of e.timelines){const c=u.element,p=c!==i,m=Ji(r,c,[]);this._getPreviousPlayers(c,p,o,a,e.toState).forEach(_=>{const w=_.getRealPlayer();w.beforeDestroy&&w.beforeDestroy(),_.destroy(),m.push(_)})}Zc(i,e.fromStyles)}_buildAnimation(t,e,r,s,i,o){const a=e.triggerName,u=e.element,c=[],p=new Set,m=new Set,y=e.timelines.map(w=>{const T=w.element;p.add(T);const I=T[Ro];if(I&&I.removedBeforeQueried)return new Bg(w.duration,w.delay);const O=T!==u,M=function GPe(n){const t=[];return Z6(n,t),t}((r.get(T)||FPe).map(ne=>ne.getRealPlayer())).filter(ne=>!!ne.element&&ne.element===T),V=i.get(T),z=o.get(T),G=E6(0,this._normalizer,0,w.keyframes,V,z),Q=this._buildPlayer(w,G,M);if(w.subTimeline&&s&&m.add(T),O){const ne=new Yk(t,a,T);ne.setRealPlayer(Q),c.push(ne)}return Q});c.forEach(w=>{Ji(this.playersByQueriedElement,w.element,[]).push(w),w.onDone(()=>function BPe(n,t,e){let r=n.get(t);if(r){if(r.length){const s=r.indexOf(e);r.splice(s,1)}0==r.length&&n.delete(t)}return r}(this.playersByQueriedElement,w.element,w))}),p.forEach(w=>Mo(w,M6));const _=Pu(y);return _.onDestroy(()=>{p.forEach(w=>op(w,M6)),Ga(u,e.toStyles)}),m.forEach(w=>{Ji(s,w,[]).push(_)}),_}_buildPlayer(t,e,r){return e.length>0?this.driver.animate(t.element,e,t.duration,t.delay,t.easing,r):new Bg(t.duration,t.delay)}}class Yk{constructor(t,e,r){this.namespaceId=t,this.triggerName=e,this.element=r,this._player=new Bg,this._containsRealPlayer=!1,this._queuedCallbacks=new Map,this.destroyed=!1,this.parentPlayer=null,this.markedForDestroy=!1,this.disabled=!1,this.queued=!0,this.totalTime=0}setRealPlayer(t){this._containsRealPlayer||(this._player=t,this._queuedCallbacks.forEach((e,r)=>{e.forEach(s=>kk(t,r,void 0,s))}),this._queuedCallbacks.clear(),this._containsRealPlayer=!0,this.overrideTotalTime(t.totalTime),this.queued=!1)}getRealPlayer(){return this._player}overrideTotalTime(t){this.totalTime=t}syncPlayerEvents(t){const e=this._player;e.triggerCallback&&t.onStart(()=>e.triggerCallback("start")),t.onDone(()=>this.finish()),t.onDestroy(()=>this.destroy())}_queueEvent(t,e){Ji(this._queuedCallbacks,t,[]).push(e)}onDone(t){this.queued&&this._queueEvent("done",t),this._player.onDone(t)}onStart(t){this.queued&&this._queueEvent("start",t),this._player.onStart(t)}onDestroy(t){this.queued&&this._queueEvent("destroy",t),this._player.onDestroy(t)}init(){this._player.init()}hasStarted(){return!this.queued&&this._player.hasStarted()}play(){!this.queued&&this._player.play()}pause(){!this.queued&&this._player.pause()}restart(){!this.queued&&this._player.restart()}finish(){this._player.finish()}destroy(){this.destroyed=!0,this._player.destroy()}reset(){!this.queued&&this._player.reset()}setPosition(t){this.queued||this._player.setPosition(t)}getPosition(){return this.queued?0:this._player.getPosition()}triggerCallback(t){const e=this._player;e.triggerCallback&&e.triggerCallback(t)}}function Lw(n){return n&&1===n.nodeType}function K6(n,t){const e=n.style.display;return n.style.display=t??"none",e}function X6(n,t,e,r,s){const i=[];e.forEach(u=>i.push(K6(u)));const o=[];r.forEach((u,c)=>{const p=new Map;u.forEach(m=>{const y=t.computeStyle(c,m,s);p.set(m,y),(!y||0==y.length)&&(c[Ro]=$Pe,o.push(c))}),n.set(c,p)});let a=0;return e.forEach(u=>K6(u,i[a++])),o}function Y6(n,t){const e=new Map;if(n.forEach(a=>e.set(a,[])),0==t.length)return e;const r=1,s=new Set(t),i=new Map;function o(a){if(!a)return r;let u=i.get(a);if(u)return u;const c=a.parentNode;return u=e.has(c)?c:s.has(c)?r:o(c),i.set(a,u),u}return t.forEach(a=>{const u=o(a);u!==r&&e.get(u).push(a)}),e}function Mo(n,t){n.classList?.add(t)}function op(n,t){n.classList?.remove(t)}function jPe(n,t,e){Pu(e).onDone(()=>n.processLeaveNode(t))}function Z6(n,t){for(let e=0;e<n.length;e++){const r=n[e];r instanceof oW?Z6(r.players,t):t.push(r)}}function Q6(n,t,e){const r=e.get(n);if(!r)return!1;let s=t.get(n);return s?r.forEach(i=>s.add(i)):t.set(n,r),e.delete(n),!0}class Vw{constructor(t,e,r){this.bodyNode=t,this._driver=e,this._normalizer=r,this._triggerCache={},this.onRemovalComplete=(s,i)=>{},this._transitionEngine=new VPe(t,e,r),this._timelineEngine=new NPe(t,e,r),this._transitionEngine.onRemovalComplete=(s,i)=>this.onRemovalComplete(s,i)}registerTrigger(t,e,r,s,i){const o=t+"-"+s;let a=this._triggerCache[o];if(!a){const u=[],p=Bk(this._driver,i,u,[]);if(u.length)throw function RMe(n,t){return new je(3404,!1)}();a=function EPe(n,t,e){return new DPe(n,t,e)}(s,p,this._normalizer),this._triggerCache[o]=a}this._transitionEngine.registerTrigger(e,s,a)}register(t,e){this._transitionEngine.register(t,e)}destroy(t,e){this._transitionEngine.destroy(t,e)}onInsert(t,e,r,s){this._transitionEngine.insertNode(t,e,r,s)}onRemove(t,e,r,s){this._transitionEngine.removeNode(t,e,s||!1,r)}disableAnimations(t,e){this._transitionEngine.markElementAsDisabled(t,e)}process(t,e,r,s){if("@"==r.charAt(0)){const[i,o]=D6(r);this._timelineEngine.command(i,e,o,s)}else this._transitionEngine.trigger(t,e,r,s)}listen(t,e,r,s,i){if("@"==r.charAt(0)){const[o,a]=D6(r);return this._timelineEngine.listen(o,e,a,i)}return this._transitionEngine.listen(t,e,r,s,i)}flush(t=-1){this._transitionEngine.flush(t)}get players(){return this._transitionEngine.players.concat(this._timelineEngine.players)}whenRenderingDone(){return this._transitionEngine.whenRenderingDone()}}let qPe=(()=>{class n{constructor(e,r,s){this._element=e,this._startStyles=r,this._endStyles=s,this._state=0;let i=n.initialStylesByElement.get(e);i||n.initialStylesByElement.set(e,i=new Map),this._initialStyles=i}start(){this._state<1&&(this._startStyles&&Ga(this._element,this._startStyles,this._initialStyles),this._state=1)}finish(){this.start(),this._state<2&&(Ga(this._element,this._initialStyles),this._endStyles&&(Ga(this._element,this._endStyles),this._endStyles=null),this._state=1)}destroy(){this.finish(),this._state<3&&(n.initialStylesByElement.delete(this._element),this._startStyles&&(Zc(this._element,this._startStyles),this._endStyles=null),this._endStyles&&(Zc(this._element,this._endStyles),this._endStyles=null),Ga(this._element,this._initialStyles),this._state=3)}}return n.initialStylesByElement=new WeakMap,n})();function Zk(n){let t=null;return n.forEach((e,r)=>{(function KPe(n){return"display"===n||"position"===n})(r)&&(t=t||new Map,t.set(r,e))}),t}class J6{constructor(t,e,r,s){this.element=t,this.keyframes=e,this.options=r,this._specialStyles=s,this._onDoneFns=[],this._onStartFns=[],this._onDestroyFns=[],this._initialized=!1,this._finished=!1,this._started=!1,this._destroyed=!1,this._originalOnDoneFns=[],this._originalOnStartFns=[],this.time=0,this.parentPlayer=null,this.currentSnapshot=new Map,this._duration=r.duration,this._delay=r.delay||0,this.time=this._duration+this._delay}_onFinish(){this._finished||(this._finished=!0,this._onDoneFns.forEach(t=>t()),this._onDoneFns=[])}init(){this._buildPlayer(),this._preparePlayerBeforeStart()}_buildPlayer(){if(this._initialized)return;this._initialized=!0;const t=this.keyframes;this.domPlayer=this._triggerWebAnimation(this.element,t,this.options),this._finalKeyframe=t.length?t[t.length-1]:new Map,this.domPlayer.addEventListener("finish",()=>this._onFinish())}_preparePlayerBeforeStart(){this._delay?this._resetDomPlayerState():this.domPlayer.pause()}_convertKeyframesToObject(t){const e=[];return t.forEach(r=>{e.push(Object.fromEntries(r))}),e}_triggerWebAnimation(t,e,r){return t.animate(this._convertKeyframesToObject(e),r)}onStart(t){this._originalOnStartFns.push(t),this._onStartFns.push(t)}onDone(t){this._originalOnDoneFns.push(t),this._onDoneFns.push(t)}onDestroy(t){this._onDestroyFns.push(t)}play(){this._buildPlayer(),this.hasStarted()||(this._onStartFns.forEach(t=>t()),this._onStartFns=[],this._started=!0,this._specialStyles&&this._specialStyles.start()),this.domPlayer.play()}pause(){this.init(),this.domPlayer.pause()}finish(){this.init(),this._specialStyles&&this._specialStyles.finish(),this._onFinish(),this.domPlayer.finish()}reset(){this._resetDomPlayerState(),this._destroyed=!1,this._finished=!1,this._started=!1,this._onStartFns=this._originalOnStartFns,this._onDoneFns=this._originalOnDoneFns}_resetDomPlayerState(){this.domPlayer&&this.domPlayer.cancel()}restart(){this.reset(),this.play()}hasStarted(){return this._started}destroy(){this._destroyed||(this._destroyed=!0,this._resetDomPlayerState(),this._onFinish(),this._specialStyles&&this._specialStyles.destroy(),this._onDestroyFns.forEach(t=>t()),this._onDestroyFns=[])}setPosition(t){void 0===this.domPlayer&&this.init(),this.domPlayer.currentTime=t*this.time}getPosition(){return this.domPlayer.currentTime/this.time}get totalTime(){return this._delay+this._duration}beforeDestroy(){const t=new Map;this.hasStarted()&&this._finalKeyframe.forEach((r,s)=>{"offset"!==s&&t.set(s,this._finished?r:L6(this.element,s))}),this.currentSnapshot=t}triggerCallback(t){const e="start"===t?this._onStartFns:this._onDoneFns;e.forEach(r=>r()),e.length=0}}class XPe{validateStyleProperty(t){return!0}validateAnimatableStyleProperty(t){return!0}matchesElement(t,e){return!1}containsElement(t,e){return k6(t,e)}getParentElement(t){return Rk(t)}query(t,e,r){return N6(t,e,r)}computeStyle(t,e,r){return window.getComputedStyle(t)[e]}animate(t,e,r,s,i,o=[]){const u={duration:r,delay:s,fill:0==s?"both":"forwards"};i&&(u.easing=i);const c=new Map,p=o.filter(_=>_ instanceof J6);(function nPe(n,t){return 0===n||0===t})(r,s)&&p.forEach(_=>{_.currentSnapshot.forEach((w,T)=>c.set(T,w))});let m=function JMe(n){return n.length?n[0]instanceof Map?n:n.map(t=>P6(t)):[]}(e).map(_=>Fu(_));m=function rPe(n,t,e){if(e.size&&t.length){let r=t[0],s=[];if(e.forEach((i,o)=>{r.has(o)||s.push(o),r.set(o,i)}),s.length)for(let i=1;i<t.length;i++){let o=t[i];s.forEach(a=>o.set(a,L6(n,a)))}}return t}(t,m,c);const y=function HPe(n,t){let e=null,r=null;return Array.isArray(t)&&t.length?(e=Zk(t[0]),t.length>1&&(r=Zk(t[t.length-1]))):t instanceof Map&&(e=Zk(t)),e||r?new qPe(n,e,r):null}(t,m);return new J6(t,m,u,y)}}let YPe=(()=>{class n extends ZG{constructor(e,r){super(),this._nextAnimationId=0,this._renderer=e.createRenderer(r.body,{id:"0",encapsulation:pi.None,styles:[],data:{animation:[]}})}build(e){const r=this._nextAnimationId.toString();this._nextAnimationId++;const s=Array.isArray(e)?eW(e):e;return eH(this._renderer,null,r,"register",[s]),new ZPe(r,this._renderer)}}return n.\u0275fac=function(e){return new(e||n)(Le(qp),Le(xn))},n.\u0275prov=ht({token:n,factory:n.\u0275fac}),n})();class ZPe extends kOe{constructor(t,e){super(),this._id=t,this._renderer=e}create(t,e){return new QPe(this._id,t,e||{},this._renderer)}}class QPe{constructor(t,e,r,s){this.id=t,this.element=e,this._renderer=s,this.parentPlayer=null,this._started=!1,this.totalTime=0,this._command("create",r)}_listen(t,e){return this._renderer.listen(this.element,`@@${this.id}:${t}`,e)}_command(t,...e){return eH(this._renderer,this.element,this.id,t,e)}onDone(t){this._listen("done",t)}onStart(t){this._listen("start",t)}onDestroy(t){this._listen("destroy",t)}init(){this._command("init")}hasStarted(){return this._started}play(){this._command("play"),this._started=!0}pause(){this._command("pause")}restart(){this._command("restart")}finish(){this._command("finish")}destroy(){this._command("destroy")}reset(){this._command("reset"),this._started=!1}setPosition(t){this._command("setPosition",t)}getPosition(){return this._renderer.engine.players[+this.id]?.getPosition()??0}}function eH(n,t,e,r,s){return n.setProperty(t,`@@${e}:${r}`,s)}const tH="@.disabled";let JPe=(()=>{class n{constructor(e,r,s){this.delegate=e,this.engine=r,this._zone=s,this._currentId=0,this._microtaskId=1,this._animationCallbacksBuffer=[],this._rendererCache=new Map,this._cdRecurDepth=0,this.promise=Promise.resolve(0),r.onRemovalComplete=(i,o)=>{const a=o?.parentNode(i);a&&o.removeChild(a,i)}}createRenderer(e,r){const i=this.delegate.createRenderer(e,r);if(!(e&&r&&r.data&&r.data.animation)){let p=this._rendererCache.get(i);return p||(p=new nH("",i,this.engine,()=>this._rendererCache.delete(i)),this._rendererCache.set(i,p)),p}const o=r.id,a=r.id+"-"+this._currentId;this._currentId++,this.engine.register(a,e);const u=p=>{Array.isArray(p)?p.forEach(u):this.engine.registerTrigger(o,a,e,p.name,p)};return r.data.animation.forEach(u),new eFe(this,a,i,this.engine)}begin(){this._cdRecurDepth++,this.delegate.begin&&this.delegate.begin()}_scheduleCountTask(){this.promise.then(()=>{this._microtaskId++})}scheduleListenerCallback(e,r,s){e>=0&&e<this._microtaskId?this._zone.run(()=>r(s)):(0==this._animationCallbacksBuffer.length&&Promise.resolve(null).then(()=>{this._zone.run(()=>{this._animationCallbacksBuffer.forEach(i=>{const[o,a]=i;o(a)}),this._animationCallbacksBuffer=[]})}),this._animationCallbacksBuffer.push([r,s]))}end(){this._cdRecurDepth--,0==this._cdRecurDepth&&this._zone.runOutsideAngular(()=>{this._scheduleCountTask(),this.engine.flush(this._microtaskId)}),this.delegate.end&&this.delegate.end()}whenRenderingDone(){return this.engine.whenRenderingDone()}}return n.\u0275fac=function(e){return new(e||n)(Le(qp),Le(Vw),Le(Zt))},n.\u0275prov=ht({token:n,factory:n.\u0275fac}),n})();class nH{constructor(t,e,r,s){this.namespaceId=t,this.delegate=e,this.engine=r,this._onDestroy=s,this.destroyNode=this.delegate.destroyNode?i=>e.destroyNode(i):null}get data(){return this.delegate.data}destroy(){this.engine.destroy(this.namespaceId,this.delegate),this.delegate.destroy(),this._onDestroy?.()}createElement(t,e){return this.delegate.createElement(t,e)}createComment(t){return this.delegate.createComment(t)}createText(t){return this.delegate.createText(t)}appendChild(t,e){this.delegate.appendChild(t,e),this.engine.onInsert(this.namespaceId,e,t,!1)}insertBefore(t,e,r,s=!0){this.delegate.insertBefore(t,e,r),this.engine.onInsert(this.namespaceId,e,t,s)}removeChild(t,e,r){this.engine.onRemove(this.namespaceId,e,this.delegate,r)}selectRootElement(t,e){return this.delegate.selectRootElement(t,e)}parentNode(t){return this.delegate.parentNode(t)}nextSibling(t){return this.delegate.nextSibling(t)}setAttribute(t,e,r,s){this.delegate.setAttribute(t,e,r,s)}removeAttribute(t,e,r){this.delegate.removeAttribute(t,e,r)}addClass(t,e){this.delegate.addClass(t,e)}removeClass(t,e){this.delegate.removeClass(t,e)}setStyle(t,e,r,s){this.delegate.setStyle(t,e,r,s)}removeStyle(t,e,r){this.delegate.removeStyle(t,e,r)}setProperty(t,e,r){"@"==e.charAt(0)&&e==tH?this.disableAnimations(t,!!r):this.delegate.setProperty(t,e,r)}setValue(t,e){this.delegate.setValue(t,e)}listen(t,e,r){return this.delegate.listen(t,e,r)}disableAnimations(t,e){this.engine.disableAnimations(t,e)}}class eFe extends nH{constructor(t,e,r,s,i){super(e,r,s,i),this.factory=t,this.namespaceId=e}setProperty(t,e,r){"@"==e.charAt(0)?"."==e.charAt(1)&&e==tH?this.disableAnimations(t,r=void 0===r||!!r):this.engine.process(this.namespaceId,t,e.slice(1),r):this.delegate.setProperty(t,e,r)}listen(t,e,r){if("@"==e.charAt(0)){const s=function tFe(n){switch(n){case"body":return document.body;case"document":return document;case"window":return window;default:return n}}(t);let i=e.slice(1),o="";return"@"!=i.charAt(0)&&([i,o]=function nFe(n){const t=n.indexOf(".");return[n.substring(0,t),n.slice(t+1)]}(i)),this.engine.listen(this.namespaceId,s,i,o,a=>{this.factory.scheduleListenerCallback(a._data||-1,r,a)})}return this.delegate.listen(t,e,r)}}const rH=[{provide:ZG,useClass:YPe},{provide:Wk,useFactory:function sFe(){return new TPe}},{provide:Vw,useClass:(()=>{class n extends Vw{constructor(e,r,s,i){super(e.body,r,s)}ngOnDestroy(){this.flush()}}return n.\u0275fac=function(e){return new(e||n)(Le(xn),Le(Mk),Le(Wk),Le(Gl))},n.\u0275prov=ht({token:n,factory:n.\u0275fac}),n})()},{provide:qp,useFactory:function iFe(n,t,e){return new JPe(n,t,e)},deps:[f1,Vw,Zt]}],Qk=[{provide:Mk,useFactory:()=>new XPe},{provide:Vl,useValue:"BrowserAnimations"},...rH],sH=[{provide:Mk,useClass:O6},{provide:Vl,useValue:"NoopAnimations"},...rH];let oFe=(()=>{class n{static withConfig(e){return{ngModule:n,providers:e.disableAnimations?sH:Qk}}}return n.\u0275fac=function(e){return new(e||n)},n.\u0275mod=ar({type:n}),n.\u0275inj=Jn({providers:Qk,imports:[h$]}),n})(),_Fe=(()=>{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275mod=ar({type:n}),n.\u0275inj=Jn({imports:[qc,o1,YG,qc]}),n})(),vFe=(()=>{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275mod=ar({type:n,bootstrap:[dMe]}),n.\u0275inj=Jn({imports:[h$,GRe,Ane,oFe,aMe,_Fe,jOe]}),n})();WJ().bootstrapModule(vFe).catch(n=>console.error(n))},658:ge=>{ge.exports=$;var E=null;try{E=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch{}function $(se,Y,X){this.low=0|se,this.high=0|Y,this.unsigned=!!X}function F(se){return!0===(se&&se.__isLong__)}Object.defineProperty($.prototype,"__isLong__",{value:!0}),$.isLong=F;var N={},R={};function k(se,Y){var X,we,K;return Y?(K=0<=(se>>>=0)&&se<256)&&(we=R[se])?we:(X=C(se,(0|se)<0?-1:0,!0),K&&(R[se]=X),X):(K=-128<=(se|=0)&&se<128)&&(we=N[se])?we:(X=C(se,se<0?-1:0,!1),K&&(N[se]=X),X)}function S(se,Y){if(isNaN(se))return Y?L:P;if(Y){if(se<0)return L;if(se>=b)return re}else{if(se<=-x)return ue;if(se+1>=x)return H}return se<0?S(-se,Y).neg():C(se%f|0,se/f|0,Y)}function C(se,Y,X){return new $(se,Y,X)}$.fromInt=k,$.fromNumber=S,$.fromBits=C;var v=Math.pow;function g(se,Y,X){if(0===se.length)throw Error("empty string");if("NaN"===se||"Infinity"===se||"+Infinity"===se||"-Infinity"===se)return P;if("number"==typeof Y?(X=Y,Y=!1):Y=!!Y,(X=X||10)<2||36<X)throw RangeError("radix");var we;if((we=se.indexOf("-"))>0)throw Error("interior hyphen");if(0===we)return g(se.substring(1),Y,X).neg();for(var K=S(v(X,8)),ie=P,ce=0;ce<se.length;ce+=8){var qe=Math.min(8,se.length-ce),Be=parseInt(se.substring(ce,ce+qe),X);if(qe<8){var at=S(v(X,qe));ie=ie.mul(at).add(S(Be))}else ie=(ie=ie.mul(K)).add(S(Be))}return ie.unsigned=Y,ie}function h(se,Y){return"number"==typeof se?S(se,Y):"string"==typeof se?g(se,Y):C(se.low,se.high,"boolean"==typeof Y?Y:se.unsigned)}$.fromString=g,$.fromValue=h;var f=4294967296,b=f*f,x=b/2,D=k(1<<24),P=k(0);$.ZERO=P;var L=k(0,!0);$.UZERO=L;var B=k(1);$.ONE=B;var U=k(1,!0);$.UONE=U;var W=k(-1);$.NEG_ONE=W;var H=C(-1,2147483647,!1);$.MAX_VALUE=H;var re=C(-1,-1,!0);$.MAX_UNSIGNED_VALUE=re;var ue=C(0,-2147483648,!1);$.MIN_VALUE=ue;var te=$.prototype;te.toInt=function(){return this.unsigned?this.low>>>0:this.low},te.toNumber=function(){return this.unsigned?(this.high>>>0)*f+(this.low>>>0):this.high*f+(this.low>>>0)},te.toString=function(Y){if((Y=Y||10)<2||36<Y)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative()){if(this.eq(ue)){var X=S(Y),we=this.div(X),K=we.mul(X).sub(this);return we.toString(Y)+K.toInt().toString(Y)}return"-"+this.neg().toString(Y)}for(var ie=S(v(Y,6),this.unsigned),ce=this,qe="";;){var Be=ce.div(ie),rt=(ce.sub(Be.mul(ie)).toInt()>>>0).toString(Y);if((ce=Be).isZero())return rt+qe;for(;rt.length<6;)rt="0"+rt;qe=""+rt+qe}},te.getHighBits=function(){return this.high},te.getHighBitsUnsigned=function(){return this.high>>>0},te.getLowBits=function(){return this.low},te.getLowBitsUnsigned=function(){return this.low>>>0},te.getNumBitsAbs=function(){if(this.isNegative())return this.eq(ue)?64:this.neg().getNumBitsAbs();for(var Y=0!=this.high?this.high:this.low,X=31;X>0&&!(Y&1<<X);X--);return 0!=this.high?X+33:X+1},te.isZero=function(){return 0===this.high&&0===this.low},te.eqz=te.isZero,te.isNegative=function(){return!this.unsigned&&this.high<0},te.isPositive=function(){return this.unsigned||this.high>=0},te.isOdd=function(){return 1==(1&this.low)},te.isEven=function(){return 0==(1&this.low)},te.equals=function(Y){return F(Y)||(Y=h(Y)),(this.unsigned===Y.unsigned||this.high>>>31!=1||Y.high>>>31!=1)&&this.high===Y.high&&this.low===Y.low},te.eq=te.equals,te.notEquals=function(Y){return!this.eq(Y)},te.neq=te.notEquals,te.ne=te.notEquals,te.lessThan=function(Y){return this.comp(Y)<0},te.lt=te.lessThan,te.lessThanOrEqual=function(Y){return this.comp(Y)<=0},te.lte=te.lessThanOrEqual,te.le=te.lessThanOrEqual,te.greaterThan=function(Y){return this.comp(Y)>0},te.gt=te.greaterThan,te.greaterThanOrEqual=function(Y){return this.comp(Y)>=0},te.gte=te.greaterThanOrEqual,te.ge=te.greaterThanOrEqual,te.compare=function(Y){if(F(Y)||(Y=h(Y)),this.eq(Y))return 0;var X=this.isNegative(),we=Y.isNegative();return X&&!we?-1:!X&&we?1:this.unsigned?Y.high>>>0>this.high>>>0||Y.high===this.high&&Y.low>>>0>this.low>>>0?-1:1:this.sub(Y).isNegative()?-1:1},te.comp=te.compare,te.negate=function(){return!this.unsigned&&this.eq(ue)?ue:this.not().add(B)},te.neg=te.negate,te.add=function(Y){F(Y)||(Y=h(Y));var rt=0,ot=0,bt=0,wt=0;return bt+=(wt+=(65535&this.low)+(65535&Y.low))>>>16,ot+=(bt+=(this.low>>>16)+(Y.low>>>16))>>>16,rt+=(ot+=(65535&this.high)+(65535&Y.high))>>>16,rt+=(this.high>>>16)+(Y.high>>>16),C((bt&=65535)<<16|(wt&=65535),(rt&=65535)<<16|(ot&=65535),this.unsigned)},te.subtract=function(Y){return F(Y)||(Y=h(Y)),this.add(Y.neg())},te.sub=te.subtract,te.multiply=function(Y){if(this.isZero())return P;if(F(Y)||(Y=h(Y)),E)return C(E.mul(this.low,this.high,Y.low,Y.high),E.get_high(),this.unsigned);if(Y.isZero())return P;if(this.eq(ue))return Y.isOdd()?ue:P;if(Y.eq(ue))return this.isOdd()?ue:P;if(this.isNegative())return Y.isNegative()?this.neg().mul(Y.neg()):this.neg().mul(Y).neg();if(Y.isNegative())return this.mul(Y.neg()).neg();if(this.lt(D)&&Y.lt(D))return S(this.toNumber()*Y.toNumber(),this.unsigned);var K=65535&this.high,ie=this.low>>>16,ce=65535&this.low,Be=65535&Y.high,at=Y.low>>>16,rt=65535&Y.low,ot=0,bt=0,wt=0,Mt=0;return wt+=(Mt+=ce*rt)>>>16,bt+=(wt+=ie*rt)>>>16,wt&=65535,bt+=(wt+=ce*at)>>>16,ot+=(bt+=K*rt)>>>16,bt&=65535,ot+=(bt+=ie*at)>>>16,bt&=65535,ot+=(bt+=ce*Be)>>>16,ot+=(this.high>>>16)*rt+K*at+ie*Be+ce*(Y.high>>>16),C((wt&=65535)<<16|(Mt&=65535),(ot&=65535)<<16|(bt&=65535),this.unsigned)},te.mul=te.multiply,te.divide=function(Y){if(F(Y)||(Y=h(Y)),Y.isZero())throw Error("division by zero");var we,K,ie;if(E)return this.unsigned||-2147483648!==this.high||-1!==Y.low||-1!==Y.high?C((this.unsigned?E.div_u:E.div_s)(this.low,this.high,Y.low,Y.high),E.get_high(),this.unsigned):this;if(this.isZero())return this.unsigned?L:P;if(this.unsigned){if(Y.unsigned||(Y=Y.toUnsigned()),Y.gt(this))return L;if(Y.gt(this.shru(1)))return U;ie=L}else{if(this.eq(ue))return Y.eq(B)||Y.eq(W)?ue:Y.eq(ue)?B:(we=this.shr(1).div(Y).shl(1)).eq(P)?Y.isNegative()?B:W:(K=this.sub(Y.mul(we)),ie=we.add(K.div(Y)));if(Y.eq(ue))return this.unsigned?L:P;if(this.isNegative())return Y.isNegative()?this.neg().div(Y.neg()):this.neg().div(Y).neg();if(Y.isNegative())return this.div(Y.neg()).neg();ie=P}for(K=this;K.gte(Y);){we=Math.max(1,Math.floor(K.toNumber()/Y.toNumber()));for(var qe=Math.ceil(Math.log(we)/Math.LN2),Be=qe<=48?1:v(2,qe-48),at=S(we),rt=at.mul(Y);rt.isNegative()||rt.gt(K);)rt=(at=S(we-=Be,this.unsigned)).mul(Y);at.isZero()&&(at=B),ie=ie.add(at),K=K.sub(rt)}return ie},te.div=te.divide,te.modulo=function(Y){return F(Y)||(Y=h(Y)),E?C((this.unsigned?E.rem_u:E.rem_s)(this.low,this.high,Y.low,Y.high),E.get_high(),this.unsigned):this.sub(this.div(Y).mul(Y))},te.mod=te.modulo,te.rem=te.modulo,te.not=function(){return C(~this.low,~this.high,this.unsigned)},te.and=function(Y){return F(Y)||(Y=h(Y)),C(this.low&Y.low,this.high&Y.high,this.unsigned)},te.or=function(Y){return F(Y)||(Y=h(Y)),C(this.low|Y.low,this.high|Y.high,this.unsigned)},te.xor=function(Y){return F(Y)||(Y=h(Y)),C(this.low^Y.low,this.high^Y.high,this.unsigned)},te.shiftLeft=function(Y){return F(Y)&&(Y=Y.toInt()),0==(Y&=63)?this:Y<32?C(this.low<<Y,this.high<<Y|this.low>>>32-Y,this.unsigned):C(0,this.low<<Y-32,this.unsigned)},te.shl=te.shiftLeft,te.shiftRight=function(Y){return F(Y)&&(Y=Y.toInt()),0==(Y&=63)?this:Y<32?C(this.low>>>Y|this.high<<32-Y,this.high>>Y,this.unsigned):C(this.high>>Y-32,this.high>=0?0:-1,this.unsigned)},te.shr=te.shiftRight,te.shiftRightUnsigned=function(Y){if(F(Y)&&(Y=Y.toInt()),0==(Y&=63))return this;var X=this.high;return Y<32?C(this.low>>>Y|X<<32-Y,X>>>Y,this.unsigned):C(32===Y?X:X>>>Y-32,0,this.unsigned)},te.shru=te.shiftRightUnsigned,te.shr_u=te.shiftRightUnsigned,te.toSigned=function(){return this.unsigned?C(this.low,this.high,!1):this},te.toUnsigned=function(){return this.unsigned?this:C(this.low,this.high,!0)},te.toBytes=function(Y){return Y?this.toBytesLE():this.toBytesBE()},te.toBytesLE=function(){var Y=this.high,X=this.low;return[255&X,X>>>8&255,X>>>16&255,X>>>24,255&Y,Y>>>8&255,Y>>>16&255,Y>>>24]},te.toBytesBE=function(){var Y=this.high,X=this.low;return[Y>>>24,Y>>>16&255,Y>>>8&255,255&Y,X>>>24,X>>>16&255,X>>>8&255,255&X]},$.fromBytes=function(Y,X,we){return we?$.fromBytesLE(Y,X):$.fromBytesBE(Y,X)},$.fromBytesLE=function(Y,X){return new $(Y[0]|Y[1]<<8|Y[2]<<16|Y[3]<<24,Y[4]|Y[5]<<8|Y[6]<<16|Y[7]<<24,X)},$.fromBytesBE=function(Y,X){return new $(Y[4]<<24|Y[5]<<16|Y[6]<<8|Y[7],Y[0]<<24|Y[1]<<16|Y[2]<<8|Y[3],X)}},895:(module,__unused_webpack_exports,__webpack_require__)=>{var _asyncToGenerator=__webpack_require__(156).default,E;self,E=()=>(()=>{var __webpack_modules__={5716:(ge,E,$)=>{"use strict";E.R=void 0;const F=$(6027),N=$(1723);E.R=new class{init(){return _asyncToGenerator(function*(){})()}createSessionHandler(R,k){return _asyncToGenerator(function*(){const S=new F.Session(k);return yield S.loadModel(R),new N.OnnxjsSessionHandler(S)})()}}},2818:(ge,E,$)=>{"use strict";E.c8=E.rX=void 0;const F=$(2235),N=$(5381),R=$(9544),k=$(6640);E.rX=()=>{if(("number"!=typeof F.env.wasm.initTimeout||F.env.wasm.initTimeout<0)&&(F.env.wasm.initTimeout=0),"boolean"!=typeof F.env.wasm.simd&&(F.env.wasm.simd=!0),"boolean"!=typeof F.env.wasm.proxy&&(F.env.wasm.proxy=!1),"number"!=typeof F.env.wasm.numThreads||!Number.isInteger(F.env.wasm.numThreads)||F.env.wasm.numThreads<=0){const S=typeof navigator>"u"?(0,N.cpus)().length:navigator.hardwareConcurrency;F.env.wasm.numThreads=Math.min(4,Math.ceil((S||1)/2))}},E.c8=new class{init(){return _asyncToGenerator(function*(){(0,E.rX)(),yield(0,R.initializeWebAssemblyInstance)()})()}createSessionHandler(S,C){return _asyncToGenerator(function*(){const v=new k.OnnxruntimeWebAssemblySessionHandler;return yield v.loadModel(S,C),Promise.resolve(v)})()}}},1057:function(ge,E,$){"use strict";var F=this&&this.__createBinding||(Object.create?function(S,C,v,g){void 0===g&&(g=v);var h=Object.getOwnPropertyDescriptor(C,v);h&&!("get"in h?!C.__esModule:h.writable||h.configurable)||(h={enumerable:!0,get:function(){return C[v]}}),Object.defineProperty(S,g,h)}:function(S,C,v,g){void 0===g&&(g=v),S[g]=C[v]}),N=this&&this.__exportStar||function(S,C){for(var v in S)"default"===v||Object.prototype.hasOwnProperty.call(C,v)||F(C,S,v)};Object.defineProperty(E,"__esModule",{value:!0}),N($(2235),E);const R=$(2235),k=$(8408);{const S=$(5716).R;(0,R.registerBackend)("webgl",S,-10)}{const S=$(2818).c8;(0,R.registerBackend)("cpu",S,10),(0,R.registerBackend)("wasm",S,10),(0,R.registerBackend)("xnnpack",S,9),(0,R.registerBackend)("webnn",S,9)}R.env.versions.web=k.version},4910:(ge,E)=>{"use strict";Object.defineProperty(E,"__esModule",{value:!0}),E.createAttributeWithCacheKey=void 0;class ${constructor(N){Object.assign(this,N)}get cacheKey(){return this._cacheKey||(this._cacheKey=Object.getOwnPropertyNames(this).sort().map(N=>`${this[N]}`).join(";")),this._cacheKey}}E.createAttributeWithCacheKey=F=>new $(F)},6874:(ge,E,$)=>{"use strict";Object.defineProperty(E,"__esModule",{value:!0}),E.Attribute=void 0;const F=$(5127),N=$(2446),R=$(9240),k=$(7273);var S=F.onnxruntime.experimental.fbs;class C{constructor(g){if(this._attributes=new Map,null!=g){for(const h of g)h instanceof N.onnx.AttributeProto?this._attributes.set(h.name,[C.getValue(h),C.getType(h)]):h instanceof S.Attribute&&this._attributes.set(h.name(),[C.getValue(h),C.getType(h)]);if(this._attributes.size<g.length)throw new Error("duplicated attribute names")}}set(g,h,l){this._attributes.set(g,[l,h])}delete(g){this._attributes.delete(g)}getFloat(g,h){return this.get(g,"float",h)}getInt(g,h){return this.get(g,"int",h)}getString(g,h){return this.get(g,"string",h)}getTensor(g,h){return this.get(g,"tensor",h)}getFloats(g,h){return this.get(g,"floats",h)}getInts(g,h){return this.get(g,"ints",h)}getStrings(g,h){return this.get(g,"strings",h)}getTensors(g,h){return this.get(g,"tensors",h)}get(g,h,l){const d=this._attributes.get(g);if(void 0===d){if(void 0!==l)return l;throw new Error(`required attribute not found: ${g}`)}if(d[1]!==h)throw new Error(`type mismatch: expected ${h} but got ${d[1]}`);return d[0]}static getType(g){const h=g instanceof N.onnx.AttributeProto?g.type:g.type();switch(h){case N.onnx.AttributeProto.AttributeType.FLOAT:return"float";case N.onnx.AttributeProto.AttributeType.INT:return"int";case N.onnx.AttributeProto.AttributeType.STRING:return"string";case N.onnx.AttributeProto.AttributeType.TENSOR:return"tensor";case N.onnx.AttributeProto.AttributeType.FLOATS:return"floats";case N.onnx.AttributeProto.AttributeType.INTS:return"ints";case N.onnx.AttributeProto.AttributeType.STRINGS:return"strings";case N.onnx.AttributeProto.AttributeType.TENSORS:return"tensors";default:throw new Error(`attribute type is not supported yet: ${N.onnx.AttributeProto.AttributeType[h]}`)}}static getValue(g){const h=g instanceof N.onnx.AttributeProto?g.type:g.type();if(h===N.onnx.AttributeProto.AttributeType.GRAPH||h===N.onnx.AttributeProto.AttributeType.GRAPHS)throw new Error("graph attribute is not supported yet");const l=this.getValueNoCheck(g);if(h===N.onnx.AttributeProto.AttributeType.INT&&k.LongUtil.isLong(l))return k.LongUtil.longToNumber(l);if(h===N.onnx.AttributeProto.AttributeType.INTS){const d=l,f=new Array(d.length);for(let b=0;b<d.length;b++)f[b]=k.LongUtil.longToNumber(d[b]);return f}if(h===N.onnx.AttributeProto.AttributeType.TENSOR)return g instanceof N.onnx.AttributeProto?R.Tensor.fromProto(l):R.Tensor.fromOrtTensor(l);if(h===N.onnx.AttributeProto.AttributeType.TENSORS){if(g instanceof N.onnx.AttributeProto)return l.map(d=>R.Tensor.fromProto(d));if(g instanceof S.Attribute)return l.map(d=>R.Tensor.fromOrtTensor(d))}return h===N.onnx.AttributeProto.AttributeType.STRING&&g instanceof N.onnx.AttributeProto?(0,k.decodeUtf8String)(l):h===N.onnx.AttributeProto.AttributeType.STRINGS&&g instanceof N.onnx.AttributeProto?l.map(k.decodeUtf8String):l}static getValueNoCheck(g){return g instanceof N.onnx.AttributeProto?this.getValueNoCheckFromOnnxFormat(g):this.getValueNoCheckFromOrtFormat(g)}static getValueNoCheckFromOnnxFormat(g){switch(g.type){case N.onnx.AttributeProto.AttributeType.FLOAT:return g.f;case N.onnx.AttributeProto.AttributeType.INT:return g.i;case N.onnx.AttributeProto.AttributeType.STRING:return g.s;case N.onnx.AttributeProto.AttributeType.TENSOR:return g.t;case N.onnx.AttributeProto.AttributeType.GRAPH:return g.g;case N.onnx.AttributeProto.AttributeType.FLOATS:return g.floats;case N.onnx.AttributeProto.AttributeType.INTS:return g.ints;case N.onnx.AttributeProto.AttributeType.STRINGS:return g.strings;case N.onnx.AttributeProto.AttributeType.TENSORS:return g.tensors;case N.onnx.AttributeProto.AttributeType.GRAPHS:return g.graphs;default:throw new Error(`unsupported attribute type: ${N.onnx.AttributeProto.AttributeType[g.type]}`)}}static getValueNoCheckFromOrtFormat(g){switch(g.type()){case S.AttributeType.FLOAT:return g.f();case S.AttributeType.INT:return g.i();case S.AttributeType.STRING:return g.s();case S.AttributeType.TENSOR:return g.t();case S.AttributeType.GRAPH:return g.g();case S.AttributeType.FLOATS:return g.floatsArray();case S.AttributeType.INTS:{const h=[];for(let l=0;l<g.intsLength();l++)h.push(g.ints(l));return h}case S.AttributeType.STRINGS:{const h=[];for(let l=0;l<g.stringsLength();l++)h.push(g.strings(l));return h}case S.AttributeType.TENSORS:{const h=[];for(let l=0;l<g.tensorsLength();l++)h.push(g.tensors(l));return h}default:throw new Error(`unsupported attribute type: ${S.AttributeType[g.type()]}`)}}}E.Attribute=C},1975:(ge,E,$)=>{"use strict";Object.defineProperty(E,"__esModule",{value:!0}),E.resolveBackend=E.backend=void 0;const F=$(4418),N=new Map;function R(S){return k.apply(this,arguments)}function k(){return(k=_asyncToGenerator(function*(S){const C=E.backend;if(void 0!==C[S]&&"initialize"in(v=C[S])&&"function"==typeof v.initialize&&"createSessionHandler"in v&&"function"==typeof v.createSessionHandler&&"dispose"in v&&"function"==typeof v.dispose){const v=C[S];let g=v.initialize();if("object"==typeof g&&"then"in g&&(g=yield g),g)return N.set(S,v),v}var v})).apply(this,arguments)}E.backend={webgl:new F.WebGLBackend},E.resolveBackend=function(){var S=_asyncToGenerator(function*(v){if(!v)return C(["webgl"]);{const g="string"==typeof v?[v]:v;for(const h of g){const l=N.get(h);if(l)return l;const d=yield R(h);if(d)return d}}throw new Error("no available backend to use")});function C(v){return S.apply(this,arguments)}return C}()},4418:(ge,E,$)=>{"use strict";Object.defineProperty(E,"__esModule",{value:!0}),E.WebGLBackend=void 0;const F=$(2235),N=$(1315),R=$(2171),k=$(3389);E.WebGLBackend=class{get contextId(){return F.env.webgl.contextId}set contextId(S){F.env.webgl.contextId=S}get matmulMaxBatchSize(){return F.env.webgl.matmulMaxBatchSize}set matmulMaxBatchSize(S){F.env.webgl.matmulMaxBatchSize=S}get textureCacheMode(){return F.env.webgl.textureCacheMode}set textureCacheMode(S){F.env.webgl.textureCacheMode=S}get pack(){return F.env.webgl.pack}set pack(S){F.env.webgl.pack=S}get async(){return F.env.webgl.async}set async(S){F.env.webgl.async=S}initialize(){try{return this.glContext=(0,k.createWebGLContext)(this.contextId),"number"!=typeof this.matmulMaxBatchSize&&(this.matmulMaxBatchSize=16),"string"!=typeof this.textureCacheMode&&(this.textureCacheMode="full"),"boolean"!=typeof this.pack&&(this.pack=!1),"boolean"!=typeof this.async&&(this.async=!1),N.Logger.setWithEnv(F.env),N.Logger.verbose("WebGLBackend",`Created WebGLContext: ${typeof this.glContext} with matmulMaxBatchSize: ${this.matmulMaxBatchSize}; textureCacheMode: ${this.textureCacheMode}; pack: ${this.pack}; async: ${this.async}.`),!0}catch(S){return N.Logger.warning("WebGLBackend",`Unable to initialize WebGLBackend. ${S}`),!1}}createSessionHandler(S){return new R.WebGLSessionHandler(this,S)}dispose(){this.glContext.dispose()}}},6859:(ge,E,$)=>{"use strict";Object.defineProperty(E,"__esModule",{value:!0}),E.CoordsGlslLib=void 0;const F=$(7273),N=$(1997),R=$(6757),k=$(7618),S=$(432);E.CoordsGlslLib=class C extends N.GlslLib{constructor(g){super(g)}getFunctions(){return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({},this.offsetToCoords()),this.coordsToOffset()),this.toVec()),this.valueFrom()),this.getCommonUtilFuncs()),this.getInputsSamplingSnippets()),this.getOutputSamplingSnippet())}getCustomTypes(){return{}}offsetToCoords(){return{offsetToCoords:new N.GlslLibRoutine("\n      vec2 offsetToCoords(int offset, int width, int height) {\n        int t = offset / width;\n        int s = offset - t*width;\n        vec2 coords = (vec2(s,t) + vec2(0.5,0.5)) / vec2(width, height);\n        return coords;\n      }\n      ")}}coordsToOffset(){return{coordsToOffset:new N.GlslLibRoutine("\n      int coordsToOffset(vec2 coords, int width, int height) {\n        float s = coords.s * float(width);\n        float t = coords.t * float(height);\n        int offset = int(t) * width + int(s);\n        return offset;\n      }\n      ")}}getOutputSamplingSnippet(){const g=this.context.outputTextureLayout;return g.isPacked?this.getPackedOutputSamplingSnippet(g):this.getUnpackedOutputSamplingSnippet(g)}getPackedOutputSamplingSnippet(g){const h=g.unpackedShape,l=[g.width,g.height],d={},f="getOutputCoords";switch(h.length){case 0:d[f]=this.getOutputScalarCoords();break;case 1:d[f]=this.getOutputPacked1DCoords(h,l);break;case 2:d[f]=this.getOutputPacked2DCoords(h,l);break;case 3:d[f]=this.getOutputPacked3DCoords(h,l);break;default:d[f]=this.getOutputPackedNDCoords(h,l)}const b=`\n      void setOutput(vec4 val) {\n        ${(0,R.getGlsl)(this.context.glContext.version).output} = val;\n      }\n    `;return d.floatTextureSetRGBA=new N.GlslLibRoutine(b),d}getUnpackedOutputSamplingSnippet(g){const h=g.unpackedShape,l=[g.width,g.height],d={},f="getOutputCoords";switch(h.length){case 0:d[f]=this.getOutputScalarCoords();break;case 1:d[f]=this.getOutputUnpacked1DCoords(h,l);break;case 2:d[f]=this.getOutputUnpacked2DCoords(h,l);break;case 3:d[f]=this.getOutputUnpacked3DCoords(h,l);break;case 4:d[f]=this.getOutputUnpacked4DCoords(h,l);break;case 5:d[f]=this.getOutputUnpacked5DCoords(h,l);break;case 6:d[f]=this.getOutputUnpacked6DCoords(h,l);break;default:throw new Error(`Unsupported output dimensionality: ${h.length}`)}const b=`\n        void setOutput(float val) {\n          ${(0,R.getGlsl)(this.context.glContext.version).output} = vec4(val, 0, 0, 0);\n        }\n    `;return d.floatTextureSetR=new N.GlslLibRoutine(b),d}getOutputScalarCoords(){return new N.GlslLibRoutine("\n      int getOutputCoords() {\n        return 0;\n      }\n    ")}getOutputPacked1DCoords(g,h){const l=h;let d="";return 1===l[0]?(d=`\n          int getOutputCoords() {\n            return 2 * int(TexCoords.y * ${l[1]}.0);\n          }\n        `,new N.GlslLibRoutine(d)):1===l[1]?(d=`\n          int getOutputCoords() {\n            return 2 * int(TexCoords.x * ${l[0]}.0);\n          }\n        `,new N.GlslLibRoutine(d)):(d=`\n        int getOutputCoords() {\n          ivec2 resTexRC = ivec2(TexCoords.xy *\n                                 vec2(${l[0]}, ${l[1]}));\n          return 2 * (resTexRC.y * ${l[0]} + resTexRC.x);\n        }\n      `,new N.GlslLibRoutine(d))}getOutputPacked2DCoords(g,h){let l="";if(F.ArrayUtil.arraysEqual(g,h))return l=`\n        ivec2 getOutputCoords() {\n          return 2 * ivec2(TexCoords.xy * vec2(${h[0]}, ${h[1]}));\n        }\n      `,new N.GlslLibRoutine(l);const d=h,f=Math.ceil(g[1]/2);return l=`\n        ivec2 getOutputCoords() {\n          ivec2 resTexRC = ivec2(TexCoords.xy *\n                                vec2(${d[0]}, ${d[1]}));\n\n          int index = resTexRC.y * ${d[0]} + resTexRC.x;\n\n          // reverse r and c order for packed texture\n          int r = imod(index, ${f}) * 2;\n          int c = 2 * (index / ${f});\n\n          return ivec2(r, c);\n        }\n      `,new N.GlslLibRoutine(l)}getOutputPacked3DCoords(g,h){const l=[h[0],h[1]],d=Math.ceil(g[2]/2),f=d*Math.ceil(g[1]/2);return new N.GlslLibRoutine(`\n        ivec3 getOutputCoords() {\n          ivec2 resTexRC = ivec2(TexCoords.xy *\n                                vec2(${l[0]}, ${l[1]}));\n          int index = resTexRC.y * ${l[0]} + resTexRC.x;\n\n          int b = index / ${f};\n          index -= b * ${f};\n\n          // reverse r and c order for packed texture\n          int r = imod(index, ${d}) * 2;\n          int c = 2 * (index / ${d});\n\n          return ivec3(b, r, c);\n        }\n      `)}getOutputPackedNDCoords(g,h){const l=[h[0],h[1]],d=Math.ceil(g[g.length-1]/2),f=d*Math.ceil(g[g.length-2]/2);let b=f,x="",D="b, r, c";for(let L=2;L<g.length-1;L++)b*=g[g.length-L-1],x=`\n      int b${L} = index / ${b};\n      index -= b${L} * ${b};\n    `+x,D=`b${L}, `+D;return new N.GlslLibRoutine(`\n      ivec${g.length} getOutputCoords() {\n        ivec2 resTexRC = ivec2(TexCoords.xy *\n                              vec2(${l[0]}, ${l[1]}));\n        int index = resTexRC.y * ${l[0]} + resTexRC.x;\n\n        ${x}\n\n        int b = index / ${f};\n        index -= b * ${f};\n\n        // reverse r and c order for packed texture\n        int r = imod(index, ${d}) * 2;\n        int c = 2 * (index / ${d});\n\n        return ivec${g.length}(${D});\n      }\n    `)}getOutputUnpacked1DCoords(g,h){return new N.GlslLibRoutine(`\n        int getOutputCoords() {\n          ivec2 resTexRC = ivec2(TexCoords.xy *\n                                vec2(${h[0]}, ${h[1]}));\n          return resTexRC.y * ${h[0]} + resTexRC.x;\n        }\n      `)}getOutputUnpacked2DCoords(g,h){return new N.GlslLibRoutine(`\n        ivec2 getOutputCoords() {\n          ivec2 resTexRC = ivec2(TexCoords.xy *\n                                vec2(${h[0]}, ${h[1]}));\n          int index = resTexRC.y * ${h[0]} + resTexRC.x;\n          int r = index / ${g[1]};\n          int c = index - r * ${g[1]};\n          return ivec2(r, c);\n        }\n      `)}getOutputUnpacked3DCoords(g,h){let l="";const d=g.length;let f=null;d<2&&(f=[]),f=new Array(d-1),f[d-2]=g[d-1];for(let D=d-3;D>=0;--D)f[D]=f[D+1]*g[D+1];const b=["r","c","d"],x=f.map((D,P)=>`int ${b[P]} = index / ${D}; ${P===f.length-1?`int ${b[P+1]} = index - ${b[P]} * ${D}`:`index -= ${b[P]} * ${D}`};`).join("");return l=`\n        ivec3 getOutputCoords() {\n          ivec2 resTexRC = ivec2(TexCoords.xy *\n                                vec2(${h[0]}, ${h[1]}));\n          int index = resTexRC.y * ${h[0]} + resTexRC.x;\n          ${x}\n          return ivec3(r, c, d);\n        }\n      `,new N.GlslLibRoutine(l)}getOutputUnpacked4DCoords(g,h){let l="";const d=g.length;let f=null;d<2&&(f=[]),f=new Array(d-1),f[d-2]=g[d-1];for(let D=d-3;D>=0;--D)f[D]=f[D+1]*g[D+1];const b=["r","c","d","d2"],x=f.map((D,P)=>`int ${b[P]} = index / ${D}; ${P===f.length-1?`int ${b[P+1]} = index - ${b[P]} * ${D}`:`index -= ${b[P]} * ${D}`};`).join("");return l=`\n      ivec4 getOutputCoords() {\n          ivec2 resTexRC = ivec2(TexCoords.xy *\n                                vec2(${h[0]}, ${h[1]}));\n          int index = resTexRC.y * ${h[0]} + resTexRC.x;\n          ${x}\n          return ivec4(r, c, d, d2);\n        }\n      `,new N.GlslLibRoutine(l)}getOutputUnpacked5DCoords(g,h){let l="";const d=g.length;let f=null;d<2&&(f=[]),f=new Array(d-1),f[d-2]=g[d-1];for(let D=d-3;D>=0;--D)f[D]=f[D+1]*g[D+1];const b=["r","c","d","d2","d3"],x=f.map((D,P)=>`int ${b[P]} = index / ${D}; ${P===f.length-1?`int ${b[P+1]} = index - ${b[P]} * ${D}`:`index -= ${b[P]} * ${D}`};`).join("");return l=`\n      ivec5 getOutputCoords() {\n          ivec2 resTexRC = ivec2(TexCoords.xy *\n                                vec2(${h[0]}, ${h[1]}));\n          int index = resTexRC.y * ${h[0]} + resTexRC.x;\n          ${x}\n          return ivec5(r, c, d, d2, d3);\n        }\n      `,new N.GlslLibRoutine(l)}getOutputUnpacked6DCoords(g,h){let l="";const d=g.length;let f=null;d<2&&(f=[]),f=new Array(d-1),f[d-2]=g[d-1];for(let D=d-3;D>=0;--D)f[D]=f[D+1]*g[D+1];const b=["r","c","d","d2","d3","d4"],x=f.map((D,P)=>`int ${b[P]} = index / ${D}; ${P===f.length-1?`int ${b[P+1]} = index - ${b[P]} * ${D}`:`index -= ${b[P]} * ${D}`};`).join("");return l=`\n     ivec6 getOutputCoords() {\n         ivec2 resTexRC = ivec2(TexCoords.xy *\n                               vec2(${h[0]}, ${h[1]}));\n         int index = resTexRC.y * ${h[0]} + resTexRC.x;\n         ${x}\n         return ivec6(r, c, d, d2, d3, d4);\n       }\n     `,new N.GlslLibRoutine(l)}getCommonUtilFuncs(){const g={};let h="uvFromFlat";g[h]=new N.GlslLibRoutine("\n    vec2 uvFromFlat(int texNumR, int texNumC, int index) {\n      int texC = index / texNumR;\n      int texR = index - texC * texNumR;\n      // TODO: swap texR, texC order in following function so row is corresponding to u and column is corresponding to\n      //       v.\n      return (vec2(texR, texC) + halfCR) / vec2(texNumR, texNumC);\n    }\n    "),h="packedUVfrom1D",g[h]=new N.GlslLibRoutine("\n      vec2 packedUVfrom1D(int texNumR, int texNumC, int index) {\n        int texelIndex = index / 2;\n        int texR = texelIndex / texNumC;\n        int texC = texelIndex - texR * texNumC;\n        return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n      }\n      "),h="packedUVfrom2D",g[h]=new N.GlslLibRoutine("\n      vec2 packedUVfrom2D(int texNumR, int texNumC, int texelsInLogicalRow, int row, int col) {\n        int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);\n        int texR = texelIndex / texNumC;\n        int texC = texelIndex - texR * texNumC;\n        return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n      }\n      "),h="packedUVfrom3D",g[h]=new N.GlslLibRoutine("\n      vec2 packedUVfrom3D(int texNumR, int texNumC,\n          int texelsInBatch, int texelsInLogicalRow, int b,\n          int row, int col) {\n        int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);\n        int texR = index / texNumC;\n        int texC = index - texR * texNumC;\n        return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n      }\n      "),h="sampleTexture";const l=(0,R.getGlsl)(this.context.glContext.version);return g[h]=new N.GlslLibRoutine(`\n        float sampleTexture(sampler2D textureSampler, vec2 uv) {\n            return ${l.texture2D}(textureSampler, uv).r;\n        }`),g}getInputsSamplingSnippets(){const g={},h=this.context.outputTextureLayout;return this.context.programInfo.inputNames.forEach((l,d)=>{const f=this.context.inputTextureLayouts[d],b=(0,S.generateShaderFuncNameFromInputSamplerName)(l);g[b]=f.isPacked?this.getPackedSamplerFromInput(b,l,f):this.getUnpackedSamplerFromInput(b,l,f);const x=(0,S.generateShaderFuncNameFromInputSamplerNameAtOutCoords)(l);f.unpackedShape.length<=h.unpackedShape.length&&(g[x]=f.isPacked?this.getPackedSamplerAtOutputCoords(x,f,h,l):this.getUnpackedSamplerAtOutputCoords(x,f,h,l))}),g}getPackedSamplerAtOutputCoords(g,h,l,d){const f=h.unpackedShape,b=l.unpackedShape,D=(0,S.generateShaderFuncNameFromInputSamplerName)(d),P=f.length,L=b.length,B=F.BroadcastUtil.getBroadcastDims(f,b),U=(0,S.getCoordsDataType)(L),W=L-P;let H;const re=(0,S.getGlChannels)();H=0===P?"":L<2&&B.length>=1?"coords = 0;":B.map(we=>`coords.${re[we+W]} = 0;`).join("\n");let ue="";ue=L<2&&P>0?"coords":f.map((we,K)=>`coords.${re[K+W]}`).join(", ");let te="return outputValue;";const se=1===F.ShapeUtil.size(f),Y=1===F.ShapeUtil.size(b);if(1!==P||se||Y){if(se&&!Y)te=1===L?"\n          return vec4(outputValue.x, outputValue.x, 0., 0.);\n        ":"\n          return vec4(outputValue.x);\n        ";else if(B.length){const we=P-2,K=P-1;B.indexOf(we)>-1&&B.indexOf(K)>-1?te="return vec4(outputValue.x);":B.indexOf(we)>-1?te="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":B.indexOf(K)>-1&&(te="return vec4(outputValue.xx, outputValue.zz);")}}else te="\n        return vec4(outputValue.xy, outputValue.xy);\n      ";return new N.GlslLibRoutine(`\n      vec4 ${g}() {\n        ${U} coords = getOutputCoords();\n        \n        int lastDim = coords.${re[L-1]};\n        coords.${re[L-1]} = coords.${re[L-2]};\n        coords.${re[L-2]} = lastDim;\n      \n        ${H}\n        vec4 outputValue = ${D}(${ue});\n        ${te}\n      }\n    `,["coordinates.getOutputCoords"])}getUnpackedSamplerAtOutputCoords(g,h,l,d){const f=[l.width,l.height],b=[h.width,h.height],x=h.unpackedShape.length,D=l.unpackedShape.length,P=h.unpackedShape,L=l.unpackedShape,B=(0,S.generateShaderFuncNameFromInputSamplerName)(d);if(x===D&&F.ArrayUtil.arraysEqual(b,f))return new N.GlslLibRoutine(`\n          float ${g}() {\n            return sampleTexture(${d}, TexCoords);\n          }\n        `,["coordinates.sampleTexture"]);const U=(0,S.getCoordsDataType)(D),W=F.BroadcastUtil.getBroadcastDims(P,L),H=D-x;let re;const ue=(0,S.getGlChannels)();re=0===x?"":D<2&&W.length>=1?"coords = 0;":W.map(Y=>`coords.${ue[Y+H]} = 0;`).join("\n");let te="";return te=D<2&&x>0?"coords":h.unpackedShape.map((Y,X)=>`coords.${ue[X+H]}`).join(", "),new N.GlslLibRoutine(`\n        float ${g}() {\n          ${U} coords = getOutputCoords();\n          ${re}\n          return ${B}(${te});\n        }\n      `,["coordinates.getOutputCoords"])}getPackedSamplerFromInput(g,h,l){switch(l.unpackedShape.length){case 0:return this.getPackedSamplerScalar(g,h);case 1:return this.getPackedSampler1D(g,h,l);case 2:return this.getPackedSampler2D(g,h,l);case 3:return this.getPackedSampler3D(g,h,l);default:return this.getPackedSamplerND(g,h,l)}}getUnpackedSamplerFromInput(g,h,l){const d=l.unpackedShape;switch(d.length){case 0:return this.getUnpackedSamplerScalar(g,h,l);case 1:return this.getUnpackedSampler1D(g,h,l);case 2:return this.getUnpackedSampler2D(g,h,l);case 3:return this.getUnpackedSampler3D(g,h,l);case 4:return this.getUnpackedSampler4D(g,h,l);case 5:return this.getUnpackedSampler5D(g,h,l);case 6:return this.getUnpackedSampler6D(g,h,l);default:throw new Error(`Unsupported dimension ${d.length}-D`)}}getPackedSamplerScalar(g,h){const l=`\n          vec4 ${g}() {\n            return ${(0,R.getGlsl)(this.context.glContext.version).texture2D}(${h}, halfCR);\n          }\n        `;return new N.GlslLibRoutine(l)}getPackedSampler1D(g,h,l){const d=[l.width,l.height],f=[d[1],d[0]],b=(0,R.getGlsl)(this.context.glContext.version);return new N.GlslLibRoutine(`vec4 ${g}(int index) {\n      vec2 uv = packedUVfrom1D(\n      ${f[0]}, ${f[1]}, index);\n      return ${b.texture2D}(${h}, uv);\n    }`,["coordinates.packedUVfrom1D"])}getPackedSampler2D(g,h,l){const d=l.unpackedShape,f=[l.width,l.height],b=(0,R.getGlsl)(this.context.glContext.version),x=f[0],D=f[1];if(null!=f&&F.ArrayUtil.arraysEqual(d,f))return new N.GlslLibRoutine(`vec4 ${g}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${D}.0, ${x}.0);\n        return ${b.texture2D}(${h}, uv);\n      }`);const P=f,L=Math.ceil(d[1]/2);return new N.GlslLibRoutine(`vec4 ${g}(int row, int col) {\n      vec2 uv = packedUVfrom2D(${P[1]}, ${P[0]}, ${L}, row, col);\n      return ${b.texture2D}(${h}, uv);\n    }`,["coordinates.packedUVfrom2D"])}getPackedSampler3D(g,h,l){const d=l.unpackedShape,f=[l.width,l.height],b=[f[0],f[1]],x=(0,R.getGlsl)(this.context.glContext.version);if(1===d[0]){const U=d.slice(1),W=[1,2],H=(0,S.squeezeInputShape)(d,U),re=["b","row","col"],ue=JSON.parse(JSON.stringify(l));ue.unpackedShape=H;const te=this.getPackedSamplerFromInput(g,h,ue),se=`${te.routineBody}\n      vec4 ${g}(int b, int row, int col) {\n        return ${g}(${(0,S.getSqueezedParams)(re,W)});\n      } `;return new N.GlslLibRoutine(se,te.dependencies)}const D=b[0],P=b[1],L=Math.ceil(d[2]/2),B=`vec4 ${g}(int b, int row, int col) {\n      vec2 uv = packedUVfrom3D(\n        ${P}, ${D}, ${L*Math.ceil(d[1]/2)}, ${L}, b, row, col);\n      return ${x.texture2D}(${h}, uv);}`;return new N.GlslLibRoutine(B,["coordinates.packedUVfrom3D"])}getPackedSamplerND(g,h,l){const d=l.unpackedShape,f=d.length,b=[l.width,l.height],x=(0,R.getGlsl)(this.context.glContext.version),D=[b[0],b[1]],P=D[1],L=D[0],B=Math.ceil(d[f-1]/2);let U=B*Math.ceil(d[f-2]/2),W="int b, int row, int col",H=`b * ${U} + (row / 2) * ${B} + (col / 2)`;for(let ue=2;ue<f-1;ue++)W=`int b${ue}, `+W,U*=d[f-ue-1],H=`b${ue} * ${U} + `+H;return new N.GlslLibRoutine(`vec4 ${g}(${W}) {\n      int index = ${H};\n      int texR = index / ${L};\n      int texC = index - texR * ${L};\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${L}, ${P});\n      return ${x.texture2D}(${h}, uv);\n    }`)}getUnpackedSamplerScalar(g,h,l){const[d,f]=[l.width,l.height];return 1===d&&1===f?new N.GlslLibRoutine(`\n          float ${g}() {\n            return sampleTexture(${h}, halfCR);\n          }\n        `,["coordinates.sampleTexture"]):new N.GlslLibRoutine(`\n        float ${g}() {\n          int offset_${h} = coordsToOffset(TexCoords, ${d}, ${f});\n          vec2 uv = uvFromFlat(${d}, ${f}, offset_${h});\n          return sampleTexture(${h}, uv);\n        }\n      `,["coordinates.uvFromFlat","coordinates.sampleTexture","coordinates.coordsToOffset"])}getUnpackedSampler1D(g,h,l){const d=l.width,f=l.height;return 1===f&&1===d?new N.GlslLibRoutine(`\n        float ${g}(int index) {\n          return sampleTexture(${h}, halfCR);\n        }\n      `,["coordinates.sampleTexture"]):1===f?new N.GlslLibRoutine(`\n          float ${g}(int index) {\n            vec2 uv = vec2((float(index) + 0.5) / ${d}.0, 0.5);\n            return sampleTexture(${h}, uv);\n          }\n        `,["coordinates.sampleTexture"]):1===d?new N.GlslLibRoutine(`\n          float ${g}(int index) {\n            vec2 uv = vec2(0.5, (float(index) + 0.5) / ${f}.0);\n            return sampleTexture(${h}, uv);\n          }\n        `,["coordinates.sampleTexture"]):new N.GlslLibRoutine(`\n        float ${g}(int index) {\n          vec2 uv = uvFromFlat(${d}, ${f}, index);\n          return sampleTexture(${h}, uv);\n        }\n      `,["coordinates.uvFromFlat","coordinates.sampleTexture"])}getUnpackedSampler2D(g,h,l){const d=l.unpackedShape,f=[l.height,l.width];if(null!=f&&F.ArrayUtil.arraysEqual(d,f))return new N.GlslLibRoutine(`\n          float ${g}(int row, int col) {\n            vec2 uv = (vec2(row, col) + halfCR) / vec2(${f[1]}.0, ${f[0]}.0);\n            return sampleTexture(${h}, uv);\n          }\n        `,["coordinates.sampleTexture"]);const{newShape:b,keptDims:x}=(0,k.squeezeShape)(d);if(b.length<d.length){const U=(0,S.squeezeInputShape)(d,b),W=JSON.parse(JSON.stringify(l));W.unpackedShape=U;const H=["col","row"],re=`\n          ${this.getUnpackedSamplerFromInput(g,h,W).routineBody}\n          float ${g}(int row, int col) {\n            return ${g}(${(0,S.getSqueezedParams)(H,x)});\n          }\n        `;return new N.GlslLibRoutine(re,["coordinates.sampleTexture"])}const P=f[1],L=f[0];return 1===L?new N.GlslLibRoutine(`\n          float ${g}(int row, int col) {\n            int offset_${h} = coordsToOffset(TexCoords, ${P}, ${L});\n            float index = dot(vec3(row, col, offset_${h}), vec3(${d[1]}, 1, 1));\n            vec2 uv = vec2(0.5, (index + 0.5) / ${P}.0);\n            return sampleTexture(${h}, uv);\n          }\n        `,["coordinates.sampleTexture","coordinates.coordsToOffset"]):1===P?new N.GlslLibRoutine(`\n          float ${g}(int row, int col) {\n            int offset_${h} = coordsToOffset(TexCoords, ${P}, ${L});\n            float index = dot(vec3(row, col, offset_${h}), vec3(${d[1]}, 1, 1));\n            vec2 uv = vec2((index + 0.5) / ${L}.0, 0.5);\n            return sampleTexture(${h}, uv);\n          }\n        `,["coordinates.sampleTexture","coordinates.coordsToOffset"]):new N.GlslLibRoutine(`\n        float ${g}(int row, int col) {\n          int index = col * ${d[1]} + row;\n          vec2 uv = uvFromFlat(${P}, ${L}, index);\n          return sampleTexture(${h}, uv);\n        }\n      `,["coordinates.uvFromFlat","coordinates.sampleTexture","coordinates.coordsToOffset"])}getUnpackedSampler3D(g,h,l){const d=l.unpackedShape,f=d[1]*d[2],b=d[2],{newShape:x,keptDims:D}=(0,k.squeezeShape)(d);if(x.length<d.length){const B=(0,S.squeezeInputShape)(d,x),U=["batch","col","row"],W=JSON.parse(JSON.stringify(l));W.unpackedShape=B;const H=this.getUnpackedSamplerFromInput(g,h,W),re=D.reverse(),ue=`\n          ${H.routineBody}\n          float ${g}(int batch, int row, int col) {\n            return ${g}(${(0,S.getSqueezedParams)(U,re)});\n          }\n        `;return new N.GlslLibRoutine(ue,H.dependencies)}return new N.GlslLibRoutine(`\n          float ${g}(int depth, int row, int col) {\n            // Explicitly use integer operations as dot() only works on floats.\n            int index = depth * ${f} + col * ${b} + row;\n            vec2 uv = uvFromFlat(${l.width}, ${l.height}, index);\n            return sampleTexture(${h}, uv);\n          }\n      `,["coordinates.uvFromFlat","coordinates.sampleTexture","coordinates.coordsToOffset"])}getUnpackedSampler4D(g,h,l){const d=l.unpackedShape,f=d[3],b=d[2]*f;return new N.GlslLibRoutine(`\n        float ${g}(int row, int col, int depth, int depth2) {\n          int index = row * ${d[1]*b} + col * ${b} +\n              depth2 * ${f} + depth;\n          vec2 uv = uvFromFlat(${l.width}, ${l.height}, index);\n          return sampleTexture(${h}, uv);\n        }\n      `,["coordinates.uvFromFlat","coordinates.sampleTexture"])}getUnpackedSampler5D(g,h,l){const d=l.unpackedShape,f=d[4],b=d[3]*f,x=d[2]*b,D=d[1]*x,{newShape:P,keptDims:L}=(0,k.squeezeShape)(d);if(P.length<d.length){const U=(0,S.squeezeInputShape)(d,P),W=["row","col","depth","depth2","depth3"],H=JSON.parse(JSON.stringify(l));H.unpackedShape=U;const re=`\n          ${this.getUnpackedSamplerFromInput(g,h,H).routineBody}\n          float ${g}(int row, int col, int depth, int depth2, int depth3) {\n            return ${g}(${(0,S.getSqueezedParams)(W,L)});\n          }\n        `;return new N.GlslLibRoutine(re,["coordinates.sampleTexture","coordinates.uvFromFlat"])}return new N.GlslLibRoutine(`\n        float ${g}(int row, int col, int depth, int depth2, int depth3) {\n          int index = row * ${D} + col * ${x} + depth * ${b} +\n          depth3 * ${f} + depth2;\n          vec2 uv = uvFromFlat(${l.width}, ${l.height}, index);\n          return sampleTexture(${h}, uv);\n        }\n      `,["coordinates.sampleTexture","coordinates.uvFromFlat"])}getUnpackedSampler6D(g,h,l){const d=l.unpackedShape,f=d[5],b=d[4]*f,x=d[3]*b,D=d[2]*x,P=d[1]*D,{newShape:L,keptDims:B}=(0,k.squeezeShape)(d);if(L.length<d.length){const W=(0,S.squeezeInputShape)(d,L),H=["row","col","depth","depth2","depth3","depth4"],re=JSON.parse(JSON.stringify(l));re.unpackedShape=W;const ue=`\n            ${this.getUnpackedSamplerFromInput(g,h,re).routineBody}\n            float ${g}(int row, int col, int depth,\n              int depth2, int depth3, int depth4) {\n              return ${g}(${(0,S.getSqueezedParams)(H,B)});\n            }\n          `;return new N.GlslLibRoutine(ue,["coordinates.sampleTexture","coordinates.uvFromFlat"])}return new N.GlslLibRoutine(`\n          float ${g}(int row, int col, int depth,\n            int depth2, int depth3, int depth4) {\n            int index = row * ${P} + col * ${D} + depth * ${x} +\n            depth2 * ${b} + depth3 * ${f} + depth4;\n            vec2 uv = uvFromFlat(${l.width}, ${l.height}, index);\n            return sampleTexture(${h}, uv);\n          }\n        `,["coordinates.uvFromFlat","coordinates.sampleTexture","coordinates.coordsToOffset"])}toVec(){const g=this.context.outputTextureLayout,h=g.shape.length,l=g.strides,d=g.width,f=g.height,b=[];for(let D=0;D<h-1;++D)b.push(`\n        c[${D}] = offset / ${l[D]};`),b.push(`\n        offset -= c[${D}] * ${l[D]};`);b.push(`\n        c[${h-1}] = offset;`);const x=`\n      void toVec(vec2 texCoords, out int c[${h}]) {\n        int offset = coordsToOffset(texCoords, ${d}, ${f});\n        ${b.join("")}\n      }\n      void toVec(int offset, out int c[${h}]) {\n        ${b.join("")}\n      }\n    `;return{toVec:new N.GlslLibRoutine(x,["coordinates.coordsToOffset"])}}valueFrom(){const g={};return this.context.programInfo.inputNames.forEach((h,l)=>{const d=this.context.inputTextureLayouts[l],f=(d.unpackedShape.length>0?d.unpackedShape:d.shape).length;let b=`_${h}`;g[b]=new N.GlslLibRoutine(this.getValueFromSingle(h,f,d.width,d.height,!1),[`shapeUtils.indicesToOffset${b}`,"coordinates.offsetToCoords","fragcolor.getColorAsFloat"]),b+="_T",g[b]=new N.GlslLibRoutine(this.getValueFromSingle(h,f,d.width,d.height,!0),[`shapeUtils.indicesToOffset${b}`,"coordinates.offsetToCoords","fragcolor.getColorAsFloat"])}),g}getValueFromSingle(g,h,l,d,f){let b=`_${g}`;return f&&(b+="_T"),`\n        float ${b}(int m[${h}]) {\n          int offset = indicesToOffset${b}(m);\n          vec2 coords = offsetToCoords(offset, ${l}, ${d});\n          float value = getColorAsFloat(${(0,R.getGlsl)(this.context.glContext.version).texture2D}(${g}, coords));\n          return value;\n        }\n        `}getPackedValueFrom(g,h,l,d,f){let b=`_${g}_Pack`;return f&&(b+="_T"),`\n        vec4 ${b}(int m[${h}]) {\n          int offset = indicesToOffset_${g}(m);\n          vec2 coords = offsetToCoords(offset, ${l}, ${d});\n          return ${(0,R.getGlsl)(this.context.glContext.version).texture2D}(${g}, coords);\n        }\n        `}}},1997:(ge,E)=>{"use strict";var $;Object.defineProperty(E,"__esModule",{value:!0}),E.TopologicalSortGlslRoutines=E.GlslLibRoutineNode=E.GlslLibRoutine=E.GlslLib=E.GlslContext=E.FunctionType=void 0,($=E.FunctionType||(E.FunctionType={}))[$.ValueBased=0]="ValueBased",$[$.Positional=1]="Positional",E.GlslContext=class{constructor(F,N,R,k){this.glContext=F,this.programInfo=N,this.inputTextureLayouts=R,this.outputTextureLayout=k}},E.GlslLib=class{constructor(F){this.context=F}},E.GlslLibRoutine=class{constructor(F,N){this.routineBody=F,this.dependencies=N}},E.GlslLibRoutineNode=class{constructor(F,N,R){this.name=F,this.dependencies=R||[],N&&(this.routineBody=N)}addDependency(F){F&&this.dependencies.push(F)}},E.TopologicalSortGlslRoutines=class{static returnOrderedNodes(F){if(!F||0===F.length)return[];if(1===F.length)return F;const N=new Set,R=new Set,k=new Array;return this.createOrderedNodes(F,N,R,k),k}static createOrderedNodes(F,N,R,k){for(let S=0;S<F.length;++S)this.dfsTraverse(F[S],N,R,k)}static dfsTraverse(F,N,R,k){if(!F||R.has(F.name))return;if(N.has(F.name))throw new Error("Cyclic dependency detected. Can't topologically sort routines needed for shader.");N.add(F.name);const S=F.dependencies;if(S&&S.length>0)for(let C=0;C<S.length;++C)this.dfsTraverse(S[C],N,R,k);k.push(F),R.add(F.name),N.delete(F.name)}}},1371:(ge,E,$)=>{"use strict";Object.defineProperty(E,"__esModule",{value:!0}),E.EncodingGlslLib=void 0;const F=$(1997);class N extends F.GlslLib{constructor(k){super(k)}getFunctions(){return Object.assign(Object.assign({},this.encodeFloat32()),this.decodeFloat32())}getCustomTypes(){return{}}encodeFloat32(){return{encode:new F.GlslLibRoutine("highp vec4 encode(highp float f) {\n        return vec4(f, 0.0, 0.0, 0.0);\n      }\n        ")}}decodeFloat32(){return{decode:new F.GlslLibRoutine("highp float decode(highp vec4 rgba) {\n        return rgba.r;\n      }\n        ")}}encodeUint8(){const k=N.isLittleEndian()?"rgba.rgba=rgba.abgr;":"";return{encode:new F.GlslLibRoutine(`\n      highp vec4 encode(highp float f) {\n        highp float F = abs(f);\n        highp float Sign = step(0.0,-f);\n        highp float Exponent = floor(log2(F));\n        highp float Mantissa = (exp2(- Exponent) * F);\n        Exponent = floor(log2(F) + 127.0) + floor(log2(Mantissa));\n        highp vec4 rgba;\n        rgba[0] = 128.0 * Sign  + floor(Exponent*exp2(-1.0));\n        rgba[1] = 128.0 * mod(Exponent,2.0) + mod(floor(Mantissa*128.0),128.0);\n        rgba[2] = floor(mod(floor(Mantissa*exp2(23.0 -8.0)),exp2(8.0)));\n        rgba[3] = floor(exp2(23.0)*mod(Mantissa,exp2(-15.0)));\n        ${k}\n        rgba = rgba / 255.0; // values need to be normalized to [0,1]\n        return rgba;\n    }\n        `)}}decodeUint8(){const k=N.isLittleEndian()?"rgba.rgba=rgba.abgr;":"";return{decode:new F.GlslLibRoutine(`\n        highp float decode(highp vec4 rgba) {\n          rgba = rgba * 255.0; // values need to be de-normalized from [0,1] to [0,255]\n          ${k}\n          highp float Sign = 1.0 - step(128.0,rgba[0])*2.0;\n          highp float Exponent = 2.0 * mod(rgba[0],128.0) + step(128.0,rgba[1]) - 127.0;\n          highp float Mantissa = mod(rgba[1],128.0)*65536.0 + rgba[2]*256.0 +rgba[3] + float(0x800000);\n          highp float Result =  Sign * exp2(Exponent) * (Mantissa * exp2(-23.0 ));\n          return Result;\n      }\n        `)}}static isLittleEndian(){const k=new ArrayBuffer(4),S=new Uint32Array(k),C=new Uint8Array(k);if(S[0]=3735928559,239===C[0])return!0;if(222===C[0])return!1;throw new Error("unknown endianness")}}E.EncodingGlslLib=N},2691:(ge,E,$)=>{"use strict";Object.defineProperty(E,"__esModule",{value:!0}),E.FragColorGlslLib=void 0;const F=$(1997),N=$(6757);E.FragColorGlslLib=class R extends F.GlslLib{constructor(S){super(S)}getFunctions(){return Object.assign(Object.assign({},this.setFragColor()),this.getColorAsFloat())}getCustomTypes(){return{}}setFragColor(){const S=(0,N.getGlsl)(this.context.glContext.version);return{setFragColor:new F.GlslLibRoutine(`\n        void setFragColor(float value) {\n            ${S.output} = encode(value);\n        }\n        `,["encoding.encode"])}}getColorAsFloat(){return{getColorAsFloat:new F.GlslLibRoutine("\n        float getColorAsFloat(vec4 color) {\n            return decode(color);\n        }\n        ",["encoding.decode"])}}}},3878:(ge,E)=>{"use strict";Object.defineProperty(E,"__esModule",{value:!0}),E.replaceInlines=void 0;const $=/@inline[\s\n\r]+(\w+)[\s\n\r]+([0-9a-zA-Z_]+)\s*\(([^)]*)\)\s*{(([^}]|[\n\r])*)}/gm;E.replaceInlines=function(F){const N={};let R;for(;null!==(R=$.exec(F));){const k=R[3].split(",").map(S=>{const C=S.trim().split(" ");return C&&2===C.length?{type:C[0],name:C[1]}:null}).filter(S=>null!==S);N[R[2]]={params:k,body:R[4]}}for(const k in N){const S="(\\w+)?\\s+([_0-9a-zA-Z]+)\\s+=\\s+__FUNC__\\((.*)\\)\\s*;".replace("__FUNC__",k),C=new RegExp(S,"gm");for(;null!==(R=C.exec(F));){const v=R[1],g=R[2],h=R[3].split(","),l=v?`${v} ${g};`:"";let d=N[k].body,f="";N[k].params.forEach((x,D)=>{x&&(f+=`${x.type} ${x.name} = ${h[D]};\n`)}),d=`${f}\n ${d}`,d=d.replace("return",`${g} = `),F=F.replace(R[0],`\n      ${l}\n      {\n        ${d}\n      }\n      `)}}return F.replace($,"")}},8897:(ge,E,$)=>{"use strict";Object.defineProperty(E,"__esModule",{value:!0}),E.GlslPreprocessor=void 0;const F=$(1997),N=$(3878),R=$(1248),k=$(6757);E.GlslPreprocessor=class{constructor(S,C,v,g){this.libs={},this.glslLibRoutineDependencyGraph={},this.context=new F.GlslContext(S,C,v,g),Object.keys(R.glslRegistry).forEach(l=>{const d=new R.glslRegistry[l](this.context);this.libs[l]=d});const h=this.glslLibRoutineDependencyGraph;for(const l in this.libs){const d=this.libs[l].getFunctions();for(const f in d){const b=l+"."+f;let x;h[b]?(x=h[b],x.routineBody=d[f].routineBody):(x=new F.GlslLibRoutineNode(b,d[f].routineBody),h[b]=x);const D=d[f].dependencies;if(D)for(let P=0;P<D.length;++P)if(h[D[P]])x.addDependency(h[D[P]]);else{const L=new F.GlslLibRoutineNode(D[P]);h[D[P]]=L,x.addDependency(L)}}}}preprocess(){const S=this.context.programInfo;let C=S.shaderSource;return this.context.programInfo.hasMain||(C=`${C}\n      ${(0,k.getDefaultFragShaderMain)(this.context.glContext.version,this.context.outputTextureLayout.shape.length)}`),C=(0,N.replaceInlines)(C),`${(0,k.getFragShaderPreamble)(this.context.glContext.version)}\n    ${this.getUniforms(S.inputNames,S.variables)}\n    ${this.getImports(C)}\n    ${C}`}getImports(S){const C=this.selectGlslLibRoutinesToBeIncluded(S);if(0===C.length)return"";let v="";for(let g=0;g<C.length;++g){if(!C[g].routineBody)throw new Error(`Missing body for the Glsl Library routine: ${C[g].name}`);v+=C[g].routineBody+"\n"}return v}selectGlslLibRoutinesToBeIncluded(S){const C=[];return Object.keys(this.glslLibRoutineDependencyGraph).forEach(v=>{const g=v.split(".")[1];-1!==S.indexOf(g)&&C.push(this.glslLibRoutineDependencyGraph[v])}),F.TopologicalSortGlslRoutines.returnOrderedNodes(C)}getUniforms(S,C){const v=[];if(S)for(const g of S)v.push(`uniform sampler2D ${g};`);if(C)for(const g of C)v.push(`uniform ${g.type} ${g.name}${g.arrayLength?`[${g.arrayLength}]`:""};`);return v.join("\n")}}},1248:(ge,E,$)=>{"use strict";Object.defineProperty(E,"__esModule",{value:!0}),E.glslRegistry=void 0;const F=$(6859),N=$(1371),R=$(2691),k=$(9183),S=$(9314);E.glslRegistry={encoding:N.EncodingGlslLib,fragcolor:R.FragColorGlslLib,vec:S.VecGlslLib,shapeUtils:k.ShapeUtilsGlslLib,coordinates:F.CoordsGlslLib}},9183:(ge,E,$)=>{"use strict";Object.defineProperty(E,"__esModule",{value:!0}),E.ShapeUtilsGlslLib=void 0;const F=$(1997);class N extends F.GlslLib{constructor(k){super(k)}getFunctions(){return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({},this.bcastIndex()),this.bcastMatmulIndex()),this.offsetToIndices()),this.indicesToOffset()),this.incrementIndices())}getCustomTypes(){return{}}bcastIndex(){const k=this.context.outputTextureLayout.shape.length,S={};return this.context.programInfo.inputNames.forEach((C,v)=>{const g=this.context.inputTextureLayouts[v].unpackedShape;if(g.length<=k){const h=g.length,l=k-h,d=`bcastIndices_${C}`;let f="";for(let x=0;x<h;++x)f+=`\n          realIndices[${x}] = int( mod(float(bcastedIndices[${l+x}]), ${g[x]}.0) );\n          `;S[d]=new F.GlslLibRoutine(`\n        void ${d} (int bcastedIndices[${k}], out int realIndices[${h}]) {\n          ${f}\n        }\n        `)}}),S}bcastMatmulIndex(){const k=this.context.outputTextureLayout.shape.length,S={};return this.context.programInfo.inputNames.forEach((C,v)=>{const g=this.context.inputTextureLayouts[v].shape;if(!(g.length<2||g.length>k)){const h=g.length,l=k-h,d=`bcastMatmulIndices_${C}`;let f="";for(let x=0;x<h-2;++x)f+=`\n          realIndices[${x}] = int( mod(float(bcastedIndices[${l+x}]), ${g[x]}.0) );\n          `;S[d]=new F.GlslLibRoutine(`\n        void ${d}(int bcastedIndices[${k}], out int realIndices[${h}]) {\n          ${f}\n          realIndices[${h-1}] = bcastedIndices[${k-1}];\n          realIndices[${h-2}] = bcastedIndices[${k-2}];\n        }\n        `)}}),S}indicesToOffset(){const k={};return this.context.programInfo.inputNames.forEach((S,C)=>{const g=this.context.inputTextureLayouts[C].strides,h=this.context.inputTextureLayouts[C].shape.length;let l=`indicesToOffset_${S}`;k[l]=new F.GlslLibRoutine(N.indexToOffsetSingle(l,h,g)),l=`indicesToOffset_${S}_T`,k[l]=new F.GlslLibRoutine(N.indexToOffsetSingle(l,h,g.slice().reverse()))}),k}static indexToOffsetSingle(k,S,C){let v="";for(let g=S-1;g>=0;--g)v+=`\n        offset += indices[${g}] * ${C[g]};\n        `;return`\n      int ${k}(int indices[${S}]) {\n        int offset = 0;\n        ${v}\n        return offset;\n      }\n      `}offsetToIndices(){const k={};return this.context.programInfo.inputNames.forEach((S,C)=>{const g=this.context.inputTextureLayouts[C].strides,h=this.context.inputTextureLayouts[C].shape.length;let l=`offsetToIndices_${S}`;k[l]=new F.GlslLibRoutine(N.offsetToIndicesSingle(l,h,g)),l=`offsetToIndices_${S}_T`,k[l]=new F.GlslLibRoutine(N.offsetToIndicesSingle(l,h,g.slice().reverse()))}),k}static offsetToIndicesSingle(k,S,C){const v=[];for(let g=0;g<S-1;++g)v.push(`\n      indices[${g}] = offset / ${C[g]};`),v.push(`\n        offset -= indices[${g}] * ${C[g]};`);return v.push(`\n      indices[${S-1}] = offset;`),`\n      void ${k}(int offset, out int indices[${S}]) {\n        ${v.join("")}\n      }\n      `}incrementIndices(){const k={};return this.context.programInfo.inputNames.forEach((S,C)=>{const v=this.context.inputTextureLayouts[C].shape,g=v.length,h=`incrementIndices_${S}`;let l="";for(let f=0;f<g;++f)l+=`\n        shape[${f}] = ${v[f]};`;k[h]=new F.GlslLibRoutine(`\n        void ${h}(int axis, out int indices[${g}]) {\n          int shape[${g}];\n          ${l};\n          for(int i = ${g} -1 ; i >= 0; --i) {\n            if(i > axis) continue;\n            indices[i] += 1;\n            if(indices[i] < shape[i]) {\n              break;\n            }\n            indices[i] = 0;\n          }\n        }\n        `)}),k}}E.ShapeUtilsGlslLib=N},6757:(ge,E)=>{"use strict";Object.defineProperty(E,"__esModule",{value:!0}),E.getDefaultFragShaderMain=E.getFragShaderPreamble=E.getVertexShaderSource=E.getGlsl=void 0;const $={version:"",attribute:"attribute",varyingVertex:"varying",varyingFrag:"varying",texture2D:"texture2D",output:"gl_FragColor",outputDeclaration:""},F={version:"#version 300 es",attribute:"in",varyingVertex:"out",varyingFrag:"in",texture2D:"texture",output:"outputColor",outputDeclaration:"out vec4 outputColor;"};function N(R){return 1===R?$:F}E.getGlsl=N,E.getVertexShaderSource=function(R){const k=N(R);return`${k.version}\n      precision highp float;\n      ${k.attribute} vec3 position;\n      ${k.attribute} vec2 textureCoord;\n\n      ${k.varyingVertex} vec2 TexCoords;\n\n      void main()\n      {\n          gl_Position = vec4(position, 1.0);\n          TexCoords = textureCoord;\n      }`},E.getFragShaderPreamble=function(R){const k=N(R);return`${k.version}\n    precision highp float;\n    precision highp int;\n    precision highp sampler2D;\n    ${k.varyingFrag} vec2 TexCoords;\n    ${k.outputDeclaration}\n    const vec2 halfCR = vec2(0.5, 0.5);\n\n    // Custom vector types to handle higher dimenalities.\n    struct ivec5\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n    };\n\n    struct ivec6\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n      int v;\n    };\n\n    int imod(int x, int y) {\n      return x - y * (x / y);\n    }\n\n    `},E.getDefaultFragShaderMain=function(R,k){return`\n  void main() {\n    int indices[${k}];\n    toVec(TexCoords, indices);\n    vec4 result = vec4(process(indices));\n    ${N(R).output} = result;\n  }\n  `}},9314:(ge,E,$)=>{"use strict";Object.defineProperty(E,"__esModule",{value:!0}),E.VecGlslLib=void 0;const F=$(1997);E.VecGlslLib=class N extends F.GlslLib{constructor(k){super(k)}getCustomTypes(){return{}}getFunctions(){return Object.assign(Object.assign(Object.assign(Object.assign({},this.binaryVecFunctions()),this.copyVec()),this.setVecItem()),this.getVecItem())}binaryVecFunctions(){const k=this.context.outputTextureLayout.shape.length,S={add:"+=",sub:"-=",mul:"*=",div:"/="},C={};for(const v in S){const g=`${v}Vec`;let h="";for(let d=0;d<k;++d)h+=`\n          dest[${d}] ${S[v]} src[${d}];\n          `;C[g]=new F.GlslLibRoutine(`\n        void ${g}(int src[${k}], out int dest[${k}]) {\n          ${h}\n        }\n        `)}return C}copyVec(){const k=this.context.outputTextureLayout.shape.length;let S="";for(let v=0;v<k;++v)S+=`\n        dest[${v}] = src[${v}];\n        `;return{copyVec:new F.GlslLibRoutine(`\n      void copyVec(int src[${k}], out int dest[${k}]) {\n        ${S}\n      }\n      `)}}setVecItem(){const k=this.context.outputTextureLayout.shape.length;let S=`\n        if(index < 0)\n            index =${k} + index;\n        if (index == 0)\n            m[0] = value;\n        `;for(let v=1;v<k-1;++v)S+=`\n        else if (index == ${v})\n            m[${v}] = value;\n            `;return S+=`\n        else\n            m[${k-1}] = value;\n        `,{setVecItem:new F.GlslLibRoutine(`\n      void setVecItem(out int m[${k}], int index, int value) {\n        ${S}\n      }\n        `)}}getVecItem(){const k=this.context.outputTextureLayout.shape.length;let S=`\n        if(index < 0)\n            index = ${k} + index;\n        if (index == 0)\n            return m[0];\n      `;for(let v=1;v<k-1;++v)S+=`\n        else if (index == ${v})\n            return m[${v}];\n      `;return S+=`\n        else\n            return m[${k-1}];\n        `,{getVecItem:new F.GlslLibRoutine(`\n      int getVecItem(int m[${k}], int index) {\n        ${S}\n      }\n    `)}}}},7860:(ge,E,$)=>{"use strict";Object.defineProperty(E,"__esModule",{value:!0}),E.WebGLInferenceHandler=void 0;const F=$(1315),N=$(9240),R=$(7273),k=$(9),S=$(7379),C=$(2488),v=$(540),g=$(3314),h=$(5639);E.WebGLInferenceHandler=class{constructor(l){this.session=l,this.packedTextureDataCache=new Map,this.unpackedTextureDataCache=new Map}calculateTextureWidthAndHeight(l,d){return(0,g.calculateTextureWidthAndHeight)(this.session.layoutStrategy,l,d)}executeProgram(l,d){if(d.length<l.inputNames.length)throw new Error(`Input size mustn't be less than ${l.inputNames.length}.`);if(l.inputNames.length!==l.inputTypes.length)throw new Error("input names size does not match input types");const f=[];for(let B=0;B<l.inputNames.length;++B)f[B]=this.getOrCreateTextureData(d[B],l.inputTypes[B]);const b=((B,U)=>{const W=U.map(re=>`${re.unpackedShape.join(",")};${re.width}x${re.height}`).join("_");let H=B.name;return B.cacheHint&&(H+="["+B.cacheHint+"]"),H+=":"+W,H})(l,f);let x=this.session.programManager.getArtifact(b);const D=x?x.programInfo:"function"==typeof l.get?l.get():l,P=(0,g.createTextureLayoutFromTextureType)(this.session.layoutStrategy,D.output.dims,D.output.textureType),L=this.createTextureData(P,D.output.type);return x||(x=this.session.programManager.build(D,f,L),this.session.programManager.setArtifact(b,x)),this.runProgram(x,f,L),L}run(l,d){return this.executeProgram(l,d).tensor}runProgram(l,d,f){for(let b=0;b<d.length;++b)if(!!d[b].isPacked!=(l.programInfo.inputTypes[b]===h.TextureType.packed))throw new Error(`input[${b}] property packed inconsistent`);if(!!f.isPacked!=(l.programInfo.output.textureType===h.TextureType.packed))throw new Error("output property packed inconsistent");this.session.programManager.run(l,d,f)}getOrCreateTextureData(l,d){let f=this.getTextureData(l.dataId,d===h.TextureType.packed);if(!f&&(f=this.getTextureData(l.dataId,d!==h.TextureType.packed),f))return d===h.TextureType.packed?this.pack(f):this.unpack(f);if(!f){const b=(0,g.createTextureLayoutFromTextureType)(this.session.layoutStrategy,l.dims,d);if(d===h.TextureType.packedLastDimension){const P=l.dims;if(4===P.length){const L=[P[0],Math.ceil(P[1]*P[2]*P[3]/4)],B=(0,g.createTextureLayoutFromTextureType)(this.session.layoutStrategy,L,d);let U=l.numberData;if(P[1]*P[2]*P[3]%4!=0){const W=P[0],H=P[1]*P[2]*P[3],re=4*Math.ceil(1*H/4);U=new Float32Array(W*re);for(let ue=0;ue<W;++ue){const te=ue*H,se=ue*re+ue%1*H;U.set(l.numberData.subarray(te,te+H),se)}}return this.createTextureData(B,l.type,U,l,1)}}if(d===h.TextureType.packed){const x=(0,g.createTextureLayoutFromShape)(this.session.layoutStrategy,l.dims,1,[],{reverseWH:!0}),D=this.createTextureData(x,l.type,l.numberData,l,1);f=this.pack(D)}else f=this.createTextureData(b,l.type,l.numberData,l,1)}return f}createTextureDataFromLayoutBindTensor(l,d,f,b){return this.createTextureData(l,d,f,b,1)}createTextureData(l,d,f,b,x){F.Logger.verbose("InferenceHandler",`Creating TextureData: layout:[${JSON.stringify(l)}]`);const D=this.session.textureManager.createTextureFromLayout(d,l,f,x);return this.createTextureDataFromTexture(l,d,D,b)}reshapeUnpacked(l,d){const f=this.getOrCreateTextureData(l,h.TextureType.unpacked),b={channels:f.channels,height:f.height,width:f.width,shape:0!==d.length?d:[1],strides:R.ShapeUtil.computeStrides(d),unpackedShape:d};return this.createTextureDataFromTexture(b,l.type,f.texture).tensor}reshapePacked(l,d){const f=this.getOrCreateTextureData(l,h.TextureType.packed);if((0,S.isReshapeCheap)(l.dims,d)){const L={channels:f.channels,height:f.height,width:f.width,shape:0!==d.length?d:[1],strides:R.ShapeUtil.computeStrides(d),unpackedShape:d,isPacked:!0};return this.createTextureDataFromTexture(L,l.type,f.texture).tensor}const b=(0,S.processDims3D)(l.dims),x=(0,S.processDims3D)(d),D=this.reshapePacked(l,b),P=this.run((0,S.createPackedReshape3DProgramInfoLoader)(this,D,x),[D]);return this.reshapePacked(P,d)}cast(l,d){const f=this.getOrCreateTextureData(l,h.TextureType.unpacked);return this.createTextureDataFromTexture(f,d,f.texture).tensor}createTextureDataFromTexture(l,d,f,b,x){var D=this;const P=Object.assign(Object.assign({},l),{tensor:b||new N.Tensor(l.unpackedShape,d,L=>this.readTexture(P),function(){var L=_asyncToGenerator(function*(B){return D.readTextureAsync(P)});return function(B){return L.apply(this,arguments)}}(),void 0,x),texture:f});return this.setTextureData(P.tensor.dataId,P,l.isPacked),P}getTextureData(l,d=!1){return this.session.isInitializer(l)?this.session.getTextureData(l,d):d?this.packedTextureDataCache.get(l):this.unpackedTextureDataCache.get(l)}setTextureData(l,d,f=!1){this.session.isInitializer(l)?this.session.setTextureData(l,d,f):(f?this.packedTextureDataCache:this.unpackedTextureDataCache).set(l,d)}isTextureLayoutCached(l,d=!1){return!!this.getTextureData(l.dataId,d)}dispose(){this.session.textureManager.clearActiveTextures(),this.packedTextureDataCache.forEach(l=>this.session.textureManager.releaseTexture(l)),this.packedTextureDataCache=new Map,this.unpackedTextureDataCache.forEach(l=>this.session.textureManager.releaseTexture(l)),this.unpackedTextureDataCache=new Map}readTexture(l){return l.isPacked?this.readTexture(this.unpack(l)):this.session.backend.glContext.isFloat32DownloadSupported?this.session.textureManager.readTexture(l,l.tensor.type,l.channels):this.session.textureManager.readUint8TextureAsFloat((0,C.encodeAsUint8)(this,l))}readTextureAsync(l){var d=this;return _asyncToGenerator(function*(){return l.isPacked?d.readTextureAsync(d.unpack(l)):d.session.backend.glContext.isFloat32DownloadSupported?d.session.textureManager.readTextureAsync(l,l.tensor.type,l.channels):d.session.textureManager.readUint8TextureAsFloat((0,C.encodeAsUint8)(d,l))})()}pack(l){return this.executeProgram((0,k.createPackProgramInfoLoader)(this,l.tensor),[l.tensor])}unpack(l){return this.executeProgram((0,v.createUnpackProgramInfoLoader)(this,l.tensor),[l.tensor])}}},4110:function(ge,E,$){"use strict";var F=this&&this.__createBinding||(Object.create?function(at,rt,ot,bt){void 0===bt&&(bt=ot);var wt=Object.getOwnPropertyDescriptor(rt,ot);wt&&!("get"in wt?!rt.__esModule:wt.writable||wt.configurable)||(wt={enumerable:!0,get:function(){return rt[ot]}}),Object.defineProperty(at,bt,wt)}:function(at,rt,ot,bt){void 0===bt&&(bt=ot),at[bt]=rt[ot]}),N=this&&this.__setModuleDefault||(Object.create?function(at,rt){Object.defineProperty(at,"default",{enumerable:!0,value:rt})}:function(at,rt){at.default=rt}),R=this&&this.__importStar||function(at){if(at&&at.__esModule)return at;var rt={};if(null!=at)for(var ot in at)"default"!==ot&&Object.prototype.hasOwnProperty.call(at,ot)&&F(rt,at,ot);return N(rt,at),rt};Object.defineProperty(E,"__esModule",{value:!0}),E.WEBGL_OP_RESOLVE_RULES=void 0;const k=$(8817),S=R($(5194)),C=$(4752),v=$(6668),g=$(9754),h=$(5042),l=$(6742),d=$(4125),f=$(6149),b=$(5378),x=$(6981),D=$(7413),P=$(7006),L=$(8276),B=$(5565),U=$(2834),W=$(1010),H=$(8126),re=$(2801),ue=$(565),te=$(2444),se=$(815),Y=$(564),X=$(5416),we=$(1240),K=$(5944),ie=$(5707),ce=R($(9087)),qe=$(7862),Be=$(3980);E.WEBGL_OP_RESOLVE_RULES=[["Abs","","6+",ce.abs],["Acos","","7+",ce.acos],["Add","","7+",S.add],["And","","7+",S.and],["Asin","","7+",ce.asin],["Atan","","7+",ce.atan],["AveragePool","","7+",U.averagePool,U.parseAveragePoolAttributes],["BatchNormalization","","7+",k.batchNormalization,k.parseBatchNormalizationAttributes],["Cast","","6+",C.cast,C.parseCastAttributes],["Ceil","","6+",ce.ceil],["Clip","","6-10",ce.clip,ce.parseClipAttributes],["Clip","","11+",ce.clipV11],["Concat","","4+",v.concat,v.parseConcatAttributes],["Conv","","1+",g.conv,g.parseConvAttributes],["ConvTranspose","","1+",h.convTranspose,h.parseConvTransposeAttributes],["Cos","","7+",ce.cos],["Div","","7+",S.div],["Dropout","","7+",ce.identity],["DepthToSpace","","1+",l.depthToSpace,l.parseDepthToSpaceAttributes],["Equal","","7+",S.equal],["Elu","","6+",ce.elu,ce.parseEluAttributes],["Exp","","6+",ce.exp],["Flatten","","1+",d.flatten,d.parseFlattenAttributes],["Floor","","6+",ce.floor],["FusedConv","com.microsoft","1+",g.conv,g.parseConvAttributes],["Gather","","1+",f.gather,f.parseGatherAttributes],["Gemm","","7-10",b.gemm,b.parseGemmAttributesV7],["Gemm","","11+",b.gemm,b.parseGemmAttributesV11],["GlobalAveragePool","","1+",U.globalAveragePool,U.parseGlobalAveragePoolAttributes],["GlobalMaxPool","","1+",U.globalMaxPool],["Greater","","7+",S.greater],["Identity","","1+",ce.identity],["ImageScaler","","1+",x.imageScaler,x.parseImageScalerAttributes],["InstanceNormalization","","6+",D.instanceNormalization,D.parseInstanceNormalizationAttributes],["LeakyRelu","","6+",ce.leakyRelu,ce.parseLeakyReluAttributes],["Less","","7+",S.less],["LRN","","1+",P.lrn,P.parseLrnAttributes],["Log","","6+",ce.log],["MatMul","","1+",L.matMul,L.parseMatMulAttributes],["MaxPool","","1+",U.maxPool,U.parseMaxPoolAttributes],["Mul","","7+",S.mul],["Neg","","6+",ce.neg],["Not","","1+",ce.not],["Or","","7+",S.or],["Pad","","2-10",B.padV2,B.parsePadAttributesV2],["Pad","","11+",B.padV11,B.parsePadAttributesV11],["Pow","","7+",S.pow],["PRelu","","7+",S.pRelu],["ReduceLogSum","","1+",W.reduceLogSum,W.parseReduceAttributes],["ReduceMax","","1+",W.reduceMax,W.parseReduceAttributes],["ReduceMean","","1+",W.reduceMean,W.parseReduceAttributes],["ReduceMin","","1+",W.reduceMin,W.parseReduceAttributes],["ReduceProd","","1+",W.reduceProd,W.parseReduceAttributes],["ReduceSum","","1-12",W.reduceSum,W.parseReduceAttributes],["ReduceSumSquare","","1+",W.reduceLogSumSquare,W.parseReduceAttributes],["Relu","","6+",ce.relu],["Reshape","","5+",H.reshape],["Resize","","10",re.resize,re.parseResizeAttributesV10],["Resize","","11+",re.resize,re.parseResizeAttributesV11],["Shape","","1+",ue.shape],["Sigmoid","","6+",ce.sigmoid],["Sin","","7+",ce.sin],["Slice","","10+",te.sliceV10],["Slice","","1-9",te.slice,te.parseSliceAttributes],["Softmax","","1-12",se.softmax,se.parseSoftmaxAttributes],["Softmax","","13+",se.softmaxV13,se.parseSoftmaxAttributesV13],["Split","","2-12",Y.split,Y.parseSplitAttributes],["Sqrt","","6+",ce.sqrt],["Squeeze","","1-12",X.squeeze,X.parseSqueezeAttributes],["Squeeze","","13+",X.squeezeV13],["Sub","","7+",S.sub],["Sum","","6+",we.sum],["Tan","","7+",ce.tan],["Tanh","","6+",ce.tanh],["Tile","","6+",K.tile],["Transpose","","1+",ie.transpose,ie.parseTransposeAttributes],["Upsample","","7-8",Be.upsample,Be.parseUpsampleAttributesV7],["Upsample","","9",Be.upsample,Be.parseUpsampleAttributesV9],["Unsqueeze","","1-12",qe.unsqueeze,qe.parseUnsqueezeAttributes],["Unsqueeze","","13+",qe.unsqueezeV13],["Xor","","7+",S.xor]]},8817:(ge,E,$)=>{"use strict";Object.defineProperty(E,"__esModule",{value:!0}),E.parseBatchNormalizationAttributes=E.batchNormalization=void 0;const F=$(4910),N=$(6757),R=$(5639),k={name:"BatchNormalization",inputNames:["A","Scale","B","Mean","Variance"],inputTypes:[R.TextureType.unpacked,R.TextureType.unpacked,R.TextureType.unpacked,R.TextureType.unpacked,R.TextureType.unpacked]};E.batchNormalization=(v,g,h)=>(C(g),[v.run(Object.assign(Object.assign({},k),{cacheHint:h.cacheKey,get:()=>S(v,g,h)}),g)]),E.parseBatchNormalizationAttributes=v=>{const g=v.attributes.getFloat("epsilon",1e-5),h=v.attributes.getFloat("momentum",.9),l=v.attributes.getInt("spatial",1);return(0,F.createAttributeWithCacheKey)({epsilon:g,momentum:h,spatial:l})};const S=(v,g,h)=>{const l=(0,N.getGlsl)(v.session.backend.glContext.version),d=g[0].dims.length,[f,b]=v.calculateTextureWidthAndHeight(g[1].dims,R.TextureType.unpacked),x=`\n  float process(int[${d}] indices) {\n    vec2 position = offsetToCoords(indices[1], ${f}, ${b});\n    float scale = getColorAsFloat(${l.texture2D}(Scale, position));\n    float mean = getColorAsFloat(${l.texture2D}(Mean, position));\n    float variance = getColorAsFloat(${l.texture2D}(Variance, position));\n    float b = getColorAsFloat(${l.texture2D}(B, position));\n\n    return scale * ( (_A(indices) - mean) / sqrt(variance + float(${h.epsilon})) ) + b;\n  }`;return Object.assign(Object.assign({},k),{output:{dims:g[0].dims,type:g[0].type,textureType:R.TextureType.unpacked},shaderSource:x})},C=v=>{if(!v||5!==v.length)throw new Error("BatchNormalization requires 5 inputs.");const g=v[0],h=v[1],l=v[2],d=v[3],f=v[4];if(g.dims.length<3||1!==h.dims.length||1!==l.dims.length||1!==d.dims.length||1!==f.dims.length)throw new Error("invalid input shape.");if(h.dims[0]!==g.dims[1]||l.dims[0]!==g.dims[1]||d.dims[0]!==g.dims[1]||f.dims[0]!==g.dims[1])throw new Error("invalid input shape.");if("float32"!==g.type&&"float64"!==g.type||"float32"!==h.type&&"float64"!==h.type||"float32"!==l.type&&"float64"!==l.type||"float32"!==d.type&&"float64"!==d.type||"float32"!==f.type&&"float64"!==f.type)throw new Error("invalid input tensor types.")}},5194:(ge,E,$)=>{"use strict";Object.defineProperty(E,"__esModule",{value:!0}),E.xor=E.sub=E.pRelu=E.pow=E.or=E.mul=E.less=E.greater=E.equal=E.div=E.and=E.add=E.glslPRelu=E.glslPow=E.glslXor=E.glslOr=E.glslAnd=E.glslLess=E.glslGreater=E.glslEqual=E.glslSub=E.glslMul=E.glslDiv=E.glslAdd=void 0;const F=$(7273),N=$(1997),R=$(6757),k=$(5639);function S(){const U="add_";return{body:`\n  float ${U}(float a, float b) {\n    return a + b;\n  }\n  vec4 ${U}(vec4 v1, vec4 v2) {\n    return v1 + v2;\n  }\n  `,name:U,type:N.FunctionType.ValueBased}}function C(){const U="div_";return{body:`\n  float ${U}(float a, float b) {\n    return a / b;\n  }\n  vec4 ${U}(vec4 v1, vec4 v2) {\n    return v1 / v2;\n  }\n  `,name:U,type:N.FunctionType.ValueBased}}function v(){const U="mul_";return{body:`\n  float ${U}(float a, float b) {\n    return a * b;\n  }\n  vec4 ${U}(vec4 v1, vec4 v2) {\n    return v1 * v2;\n  }\n  `,name:U,type:N.FunctionType.ValueBased}}function g(){const U="sub_";return{body:`\n  float ${U}(float a, float b) {\n    return a - b;\n  }\n  vec4 ${U}(vec4 v1, vec4 v2) {\n    return v1 - v2;\n  }\n  `,name:U,type:N.FunctionType.ValueBased}}function h(){const U="equal_";return{body:`\n  float ${U}(float a, float b) {\n    return float(a == b);\n  }\n  vec4 ${U}(vec4 v1, vec4 v2) {\n    return vec4(equal(v1, v2));\n  }\n  `,name:U,type:N.FunctionType.ValueBased}}function l(){const U="greater_";return{body:`\n  float ${U}(float a, float b) {\n    return float(a > b);\n  }\n  vec4 ${U}(vec4 v1, vec4 v2) {\n    return vec4( v1.r > v2.r ,\n      v1.g > v2.g,\n      v1.b > v2.b,\n      v1.a > v2.a );\n  }\n  `,name:U,type:N.FunctionType.ValueBased}}function d(){const U="less_";return{body:`\n  float ${U}(float a, float b) {\n    return float(a < b);\n  }\n  vec4 ${U}(vec4 v1, vec4 v2) {\n    return vec4( v1.r < v2.r ,\n                v1.g < v2.g,\n                v1.b < v2.b,\n                v1.a < v2.a );\n  }\n  `,name:U,type:N.FunctionType.ValueBased}}function f(){const U="and_";return{body:`\n  float ${U}(float a, float b) {\n    return float( bool(a) && bool(b) );\n  }\n  vec4 ${U}(vec4 v1, vec4 v2) {\n    bvec4 b1 = bvec4(v1);\n    bvec4 b2 = bvec4(v2);\n    return vec4( b1.r && b2.r ,\n                b1.g && b2.g,\n                b1.b && b2.b,\n                b1.a && b2.a );\n  }\n  `,name:U,type:N.FunctionType.ValueBased}}function b(){const U="or_";return{body:`\n  float ${U}(float a, float b) {\n    return float( bool(a) || bool(b) );\n  }\n  vec4 ${U}(vec4 v1, vec4 v2) {\n    bvec4 b1 = bvec4(v1);\n    bvec4 b2 = bvec4(v2);\n    return vec4( b1.r || b2.r ,\n                b1.g || b2.g,\n                b1.b || b2.b,\n                b1.a || b2.a );\n  }\n  `,name:U,type:N.FunctionType.ValueBased}}function x(){const U="xor_";return{body:`\n  float ${U}(float a, float b) {\n    return float( bool(a) ^^ bool(b) );\n  }\n  vec4 ${U}(vec4 v1, vec4 v2) {\n    bvec4 b1 = bvec4(v1);\n    bvec4 b2 = bvec4(v2);\n    return vec4( b1.r ^^ b2.r ,\n                b1.g ^^ b2.g,\n                b1.b ^^ b2.b,\n                b1.a ^^ b2.a );\n  }\n  `,name:U,type:N.FunctionType.ValueBased}}function D(){return function(U){const W=`${U}_`;return{body:`\n  float ${W}(float a, float b) {\n    return ${U}(a, b);\n  }\n  vec4 ${W}(vec4 v1, vec4 v2) {\n    return ${U}(v1, v2);\n  }\n  `,name:W,type:N.FunctionType.ValueBased}}("pow")}function P(){const U="prelu_";return{body:`\n  float ${U}(float a, float b) {\n    return a < 0.0 ? a * b: a;\n  }\n  vec4 ${U}(vec4 v1, vec4 v2) {\n    return vec4(\n      v1.r < 0.0 ? v1.r * v2.r: v1.r,\n      v1.g < 0.0 ? v1.g * v2.g: v1.g,\n      v1.b < 0.0 ? v1.b * v2.b: v1.b,\n      v1.a < 0.0 ? v1.a * v2.a: v1.a\n      );\n  }\n  `,name:U,type:N.FunctionType.ValueBased}}E.glslAdd=S,E.glslDiv=C,E.glslMul=v,E.glslSub=g,E.glslEqual=h,E.glslGreater=l,E.glslLess=d,E.glslAnd=f,E.glslOr=b,E.glslXor=x,E.glslPow=D,E.glslPRelu=P;const L=(U,W,H,re=W[0].type,ue)=>{const te=U.session.pack?k.TextureType.packed:k.TextureType.unpacked;return{name:H.name,inputNames:["A","B"],inputTypes:[te,te],cacheHint:ue,get:()=>B(U,W,H,re)}},B=(U,W,H,re=W[0].type)=>{const ue=U.session.pack?k.TextureType.packed:k.TextureType.unpacked,te=!F.ShapeUtil.areEqual(W[0].dims,W[1].dims);let se=W[0].dims;const Y=U.session.pack;if(te){const K=F.BroadcastUtil.calcShape(W[0].dims,W[1].dims,!1);if(!K)throw new Error("Can't perform binary op on the given tensors");se=K;const ie=se.length,ce=0!==W[0].dims.length?W[0].dims.length:1,qe=0!==W[1].dims.length?W[1].dims.length:1,Be=0!==W[0].dims.length?"bcastIndices_A(indices, aindices);":"aindices[0] = 0;",at=0!==W[1].dims.length?"bcastIndices_B(indices, bindices);":"bindices[0] = 0;",rt=(0,R.getGlsl)(U.session.backend.glContext.version);return{name:H.name,inputNames:["A","B"],inputTypes:[ue,ue],output:{dims:se,type:re,textureType:ue},shaderSource:Y?`\n      ${H.body}\n      void main() {\n        vec4 a = getAAtOutCoords();\n        vec4 b = getBAtOutCoords();\n        vec4 result = ${H.name}(a, b);\n        ${rt.output} = result;\n      }`:`\n      ${H.body}\n      float process(int indices[${ie}]) {\n        int aindices[${ce}];\n        int bindices[${qe}];\n        ${Be}\n        ${at}\n        return ${H.name}(_A(aindices), _B(bindices));\n      }`,hasMain:Y}}const X=(0,R.getGlsl)(U.session.backend.glContext.version);return{name:H.name,inputNames:["A","B"],inputTypes:[ue,ue],output:{dims:W[0].dims,type:re,textureType:ue},shaderSource:`\n    ${H.body}\n    void main() {\n      vec4 v1 = ${X.texture2D}(A, TexCoords);\n      vec4 v2 = ${X.texture2D}(B, TexCoords);\n      vec4 result = ${H.name}(v1, v2);\n      ${X.output} = result;\n    }\n    `,hasMain:!0}};E.add=(U,W)=>[U.run(L(U,W,S()),W)],E.and=(U,W)=>[U.run(L(U,W,f(),"bool"),W)],E.div=(U,W)=>[U.run(L(U,W,C()),W)],E.equal=(U,W)=>[U.run(L(U,W,h(),"bool"),W)],E.greater=(U,W)=>[U.run(L(U,W,l(),"bool"),W)],E.less=(U,W)=>[U.run(L(U,W,d(),"bool"),W)],E.mul=(U,W)=>[U.run(L(U,W,v()),W)],E.or=(U,W)=>[U.run(L(U,W,b(),"bool"),W)],E.pow=(U,W)=>[U.run(L(U,W,D()),W)],E.pRelu=(U,W)=>[U.run(L(U,W,P()),W)],E.sub=(U,W)=>[U.run(L(U,W,g()),W)],E.xor=(U,W)=>[U.run(L(U,W,x(),"bool"),W)]},4752:(ge,E,$)=>{"use strict";Object.defineProperty(E,"__esModule",{value:!0}),E.parseCastAttributes=E.cast=void 0;const F=$(7273);E.cast=(R,k,S)=>(N(k),[R.cast(k[0],S)]),E.parseCastAttributes=R=>F.ProtoUtil.tensorDataTypeFromProto(R.attributes.getInt("to"));const N=R=>{if(!R||1!==R.length)throw new Error("Cast requires 1 input.");if("string"===R[0].type)throw new Error("Invalid input type.")}},4595:(ge,E,$)=>{"use strict";Object.defineProperty(E,"__esModule",{value:!0}),E.createPackedConcatProgramInfoLoader=void 0;const F=$(6757),N=$(5639),R=$(432),k=$(5614);E.createPackedConcatProgramInfoLoader=(C,v,g)=>{const h=(l=v.length,d=g.cacheKey,{name:"Concat (packed)",inputNames:Array.from({length:l},(f,b)=>`X${b}`),inputTypes:Array(l).fill(N.TextureType.packed),cacheHint:d});var l,d;return Object.assign(Object.assign({},h),{get:()=>((f,b,x,D)=>{const P=x[0].dims.slice();if(D>=P.length||D<-1*P.length)throw new Error("axis specified for concat doesn't match input dimensionality");D<0&&(D=P.length+D);const L=P.slice(0);for(let Be=1;Be<x.length;Be++){const at=x[Be].dims.slice();for(let rt=0;rt<P.length;rt++)if(rt===D)L[D]+=at[rt];else if(P[rt]!==at[rt])throw new Error("non concat dimensions must match")}const B=L.length,U=(0,k.getChannels)("coords",B),W=(0,R.getCoordsDataType)(B),H=(0,k.unpackFromChannel)(),re=x.map(Be=>Be.dims),ue=(0,R.getGlChannels)(B),te=new Array(re.length-1);te[0]=re[0][D];for(let Be=1;Be<te.length;Be++)te[Be]=te[Be-1]+re[Be][D];const se=ue[D],Y=ue.slice(-2),X=ue.join();let we=`if (${se} < ${te[0]}) {\n        return getChannel(\n            getX0(${X}), vec2(${Y.join()}));\n        }`;for(let Be=1;Be<te.length;Be++){const at=te[Be-1];we+=`\n            if (${se} < ${te[Be]}  && ${se} >= ${te[Be-1]}) {\n              return getChannel(\n                getX${Be}(${S(ue,se,at)}),\n                vec2(${S(Y,se,at)}));\n            }`}const ie=te[te.length-1];we+=`\n            return getChannel(\n              getX${te.length}(${S(ue,se,ie)}),\n              vec2(${S(Y,se,ie)}));`;const ce=(0,F.getGlsl)(f.session.backend.glContext.version),qe=`\n          ${H}\n          float getValue(${ue.map(Be=>"int "+Be)}) {\n            ${we}\n          }\n\n          void main() {\n            ${W} coords = getOutputCoords();\n            int lastDim = coords.${ue[B-1]};\n            coords.${ue[B-1]} = coords.${ue[B-2]};\n            coords.${ue[B-2]} = lastDim;\n\n            vec4 result = vec4(getValue(${U}), 0., 0., 0.);\n\n            ${U[B-1]} = ${U[B-1]} + 1;\n            if (${U[B-1]} < ${L[B-1]}) {\n              result.g = getValue(${U});\n            }\n\n            ${U[B-2]} = ${U[B-2]} + 1;\n            if (${U[B-2]} < ${L[B-2]}) {\n              result.a = getValue(${U});\n            }\n\n            ${U[B-1]} = ${U[B-1]} - 1;\n            if (${U[B-2]} < ${L[B-2]} &&\n                ${U[B-1]} < ${L[B-1]}) {\n              result.b = getValue(${U});\n            }\n            ${ce.output} = result;\n          }\n        `;return Object.assign(Object.assign({},b),{output:{dims:L,type:x[0].type,textureType:N.TextureType.packed},shaderSource:qe,hasMain:!0})})(C,h,v,g.axis)})};const S=(C,v,g)=>{const h=C.indexOf(v);return C.map((l,d)=>d===h?`${l} - ${g}`:l).join()}},6668:(ge,E,$)=>{"use strict";Object.defineProperty(E,"__esModule",{value:!0}),E.parseConcatAttributes=E.concat=void 0;const F=$(4910),N=$(5639),R=$(4595);E.concat=(l,d,f)=>(h(d),l.session.pack&&d[0].dims.length>1?[l.run((0,R.createPackedConcatProgramInfoLoader)(l,d,f),d)]:[l.run(k(l,d,f),d)]);const k=(l,d,f)=>{const b=(x=d.length,D=f.cacheKey,{name:"Concat",inputNames:Array.from({length:x},(P,L)=>`X${L}`),inputTypes:Array(x).fill(N.TextureType.unpacked),cacheHint:D});var x,D;return Object.assign(Object.assign({},b),{get:()=>((P,L,B,U)=>{const W=B[0].dims.slice();if(U>=W.length||U<-1*W.length)throw new Error("axis specified for concat doesn't match input dimensionality");U<0&&(U=W.length+U);const H=W.slice(0);for(let X=1;X<B.length;X++){const we=B[X].dims.slice();for(let K=0;K<W.length;K++)if(K===U)H[U]+=we[K];else if(W[K]!==we[K])throw new Error("non concat dimensions must match")}const re=H.length,ue=new Array(B.length);let te=0;for(let X=0;X<ue.length;++X)te+=B[X].dims[U],ue[X]=te;let se="";se=B.length<5?S(ue):C(ue);const Y=`\n        ${v(B.length,re)}\n        ${g(ue)}\n        ${se}\n        float process(int indices[${re}]) {\n          int textureIndex = getTextureWhereDataResides (indices[${U}]);\n\n          if(textureIndex != 0) {\n            indices[${U}] = indices[${U}] - int(getSizeInConcatAxisValueFromIndex(textureIndex-int(1)));\n          }\n\n          return fetchDataFromCorrectTexture(textureIndex, indices);\n        }`;return Object.assign(Object.assign({},L),{output:{dims:H,type:B[0].type,textureType:N.TextureType.unpacked},shaderSource:Y})})(0,b,d,f.axis)})},S=l=>`int getTextureWhereDataResides(int index) {\n      ${l.map((d,f)=>`if(index<${d}) {return ${f};}\n`).join("")}\n    }`,C=l=>S(l),v=(l,d)=>{const f=[`float fetchDataFromCorrectTexture(int textureIndex, int indices[${d}]) {`];for(let b=0;b<l;++b)f.push(0===b?`\tif (textureIndex == ${b}) { return _X${b}(indices); }`:b===l-1?`\telse { return _X${b}(indices); }`:`\telse if (textureIndex == ${b}) { return _X${b}(indices); }`);return f.push("\t}"),f.join("\n")},g=l=>{const d=["int getSizeInConcatAxisValueFromIndex(int index) {"];for(let f=0;f<l.length;++f)d.push(0===f?`\tif (index == ${f}) { return ${l[f]}; }`:f===l.length-1?`\telse { return ${l[f]}; }`:`\telse if (index == ${f}) { return ${l[f]}; }`);return d.push("\t}"),d.join("\n")};E.parseConcatAttributes=l=>(0,F.createAttributeWithCacheKey)({axis:l.attributes.getInt("axis")});const h=l=>{if(!l||l.length<1)throw new Error("too few inputs");const d=l[0].type,f=l[0].dims.length;if("string"===d)throw new Error("string tensor is not supported yet");for(const b of l){if(b.type!==d)throw new Error("input tensors should be one type");if(b.dims.length!==f)throw new Error("input tensors should have the same shape")}}},7825:(ge,E,$)=>{"use strict";Object.defineProperty(E,"__esModule",{value:!0}),E.createUnpackedGroupedConvProgramInfoLoader=void 0;const F=$(1315),N=$(6757),R=$(5639),k=$(9754),S=$(2150);E.createUnpackedGroupedConvProgramInfoLoader=(C,v,g)=>{const h={name:"GroupedConv",inputNames:(l=v.length>2)?["X","W","Bias"]:["X","W"],inputTypes:l?[R.TextureType.unpacked,R.TextureType.unpacked,R.TextureType.unpacked]:[R.TextureType.unpacked,R.TextureType.unpacked],cacheHint:g.cacheKey};var l;return Object.assign(Object.assign({},h),{get:()=>((f,b,x,D)=>{const P=b.length>2?"value += getBias(output_channel);":"",L=b[0].dims.slice(),B=b[1].dims.slice(),U=B[0]/D.group;F.Logger.verbose("GroupedConv",`autpPad:${D.autoPad}, dilations:${D.dilations}, group:${D.group}, kernelShape:${D.kernelShape}, pads:${D.pads}, strides:${D.strides}`);const W=(0,k.calculateOutputShape)(L,B,D.dilations,D.pads,D.strides),H=(0,N.getGlsl)(f.session.backend.glContext.version),{activationFunction:re,applyActivation:ue}=(0,S.getActivationSnippet)(D),te=`\n  const ivec2 strides = ivec2(${D.strides[0]}, ${D.strides[1]});\n  const ivec2 pads = ivec2(${D.pads[0]}, ${D.pads[1]});\n  ${re}\n  void main() {\n    ivec4 coords = getOutputCoords();\n    int batch = coords.x;\n    int output_channel = coords.y;\n    ivec2 xRCCorner = coords.zw * strides - pads;\n    int group_id = output_channel / ${U};\n\n    float value = 0.0;\n    for (int wInChannel = 0; wInChannel < ${B[1]}; wInChannel++) {\n      int input_channel = group_id * ${B[1]} + wInChannel;\n      for (int wHeight = 0; wHeight < ${B[2]}; wHeight++) {\n        int xHeight = xRCCorner.x + wHeight * ${D.dilations[0]};\n\n        if (xHeight < 0 || xHeight >= ${L[2]}) {\n          continue;\n        }\n\n        for (int wWidth = 0; wWidth < ${B[3]}; wWidth++) {\n          int xWidth = xRCCorner.y + wWidth * ${D.dilations[1]};\n          if (xWidth < 0 || xWidth >= ${L[3]}) {\n            continue;\n          }\n\n          float xVal = getX(batch, input_channel, xWidth, xHeight);\n          float wVal = getW(output_channel, wInChannel, wWidth, wHeight);\n          value += xVal*wVal;\n        }\n      }\n    }\n    ${P}\n    ${ue}\n    ${H.output} = vec4(value, .0, .0, .0);\n  }\n`;return Object.assign(Object.assign({},x),{output:{dims:W,type:b[0].type,textureType:R.TextureType.unpacked},shaderSource:te,hasMain:!0})})(C,v,h,g)})}},7708:(ge,E,$)=>{"use strict";Object.defineProperty(E,"__esModule",{value:!0}),E.conv2DPacked=E.conv2DPackedPointwise=void 0;const F=$(9754),N=$(5950),R=$(5632);E.conv2DPackedPointwise=(k,S,C)=>{const v=S[0].dims,g=S[1].dims,h=(0,F.calculateOutputShape)(v,g,C.dilations,C.pads,C.strides),l=k.reshapePacked(S[0],[v[1],v[2]*v[3]]),d=k.reshapePacked(S[1],[g[0],g[1]]),f=S.length>2?[d,l,S[2]]:[d,l],b=k.run((0,R.createPackedMatmulProgramInfoLoader)(k,f,C),f);return k.reshapePacked(b,h)},E.conv2DPacked=(k,S,C)=>{const g=S[1].dims,h=(0,F.calculateOutputShape)(S[0].dims,g,C.dilations,C.pads,C.strides),l=k.run((0,N.createPackedIm2ColProgramInfoLoader)(k,S[0],S[1],h,C),[S[0]]),d=k.reshapePacked(S[1],[g[0],g[1]*g[2]*g[3]]),f=3===S.length?[d,l,S[2]]:[d,l],b=k.run((0,R.createPackedMatmulProgramInfoLoader)(k,f,C),f);return k.reshapePacked(b,h)}},5042:(ge,E,$)=>{"use strict";Object.defineProperty(E,"__esModule",{value:!0}),E.parseConvTransposeAttributes=E.convTranspose=void 0;const F=$(4910),N=$(6757),R=$(5639),k=$(2150),S=(d,f,b,x,D,P)=>(d-1)*f+b+(x-1)*D+1-P,C=(d,f,b,x,D)=>{const P=Math.floor(d/2);"SAME_UPPER"===f?(b[x]=P,b[D]=d-P):"SAME_LOWER"===f&&(b[x]=d-P,b[D]=P)};E.convTranspose=(d,f,b)=>(l(f,b),v(d,f,b));const v=(d,f,b)=>{const x=h(b,f);return[g(d,f,x)]},g=(d,f,b)=>d.run(((x,D,P)=>{const L={name:"ConvTranspose",inputNames:(B=D.length>2)?["X","W","B"]:["X","W"],inputTypes:B?[R.TextureType.unpacked,R.TextureType.unpacked,R.TextureType.unpacked]:[R.TextureType.unpacked,R.TextureType.unpacked],cacheHint:P.cacheKey};var B;return Object.assign(Object.assign({},L),{get:()=>((W,H,re,ue)=>{const te=H.length>2?"getB(output_channel)":"0.0",se=H[0].dims,Y=H[1].dims,X=Y[1],we=Y[0]/ue.group,K=[H[0].dims[0],H[1].dims[1]*ue.group,...ue.outputShape],ie=(0,N.getGlsl)(W.session.backend.glContext.version),{activationFunction:ce,applyActivation:qe}=(0,k.getActivationSnippet)(ue),Be=`\n  const ivec2 strides = ivec2(${ue.strides[0]}, ${ue.strides[1]});\n  const ivec2 pads = ivec2(${ue.pads[0]}, ${ue.pads[1]});\n  ${ce}\n  void main() {\n    ivec4 coords = getOutputCoords();\n    int batch = coords.x;\n    int output_channel = coords.y;\n\n    ivec2 loc = coords.zw + pads;\n\n    int group_id = output_channel / ${X};\n    int wOutChannel = output_channel - group_id * ${X};\n\n    float value = ${te};\n    for (int inChannelOffset = 0; inChannelOffset < ${we}; inChannelOffset++) {\n      int input_channel = group_id * ${we} + inChannelOffset;\n      for (int wWOff = 0; wWOff < ${Y[2]}; wWOff++) {\n        for (int wHOff = 0; wHOff < ${Y[3]}; wHOff++) {\n          ivec2 wOff = ivec2(wWOff * ${ue.dilations[0]}, wHOff * ${ue.dilations[1]});\n          ivec2 wLoc = loc - wOff;\n          ivec2 wLocIn = wLoc / strides;\n          if (\n            wLocIn * strides == wLoc &&\n            wLocIn.x >= 0 && wLocIn.x < ${se[2]} &&\n            wLocIn.y >= 0 && wLocIn.y < ${se[3]}\n          ) {\n            float xVal = getX(batch, input_channel, wLocIn.y, wLocIn.x);\n            float wVal = getW(input_channel, wOutChannel, wHOff, wWOff);\n            value += xVal * wVal;\n          }\n        }\n      }\n    }\n    ${qe}\n    ${ie.output} = vec4(value, .0, .0, .0);\n  }\n`;return Object.assign(Object.assign({},re),{output:{dims:K,type:H[0].type,textureType:R.TextureType.unpacked},shaderSource:Be,hasMain:!0})})(x,D,L,P)})})(d,f,b),f),h=(d,f)=>{const b=d.kernelShape.slice();if(0===d.kernelShape.length)for(let L=2;L<f[1].dims.length;++L)b.push(f[1].dims[L]);const x=d.pads.slice(),D=d.outputShape.slice();((L,B,U,W,H,re,ue,te)=>{const se=L.length-2,Y=0===te.length;for(let X=0;X<se;++X){const K=S(L[X+2],re[X],H[X],B[X],U[X],Y?L[X+2]*re[X]:te[X]);C(K,W,H,X,X+se),Y&&te.push(re[X]*(L[X+2]-1)+ue[X]+(B[X]-1)*U[X]+1-H[X]-H[X+se])}})(f[0].dims,b,d.dilations,d.autoPad,x,d.strides,d.outputPadding,D);const P=Object.assign({},d);return Object.assign(P,{kernelShape:b,pads:x,outputShape:D,cacheKey:d.cacheKey}),P};E.parseConvTransposeAttributes=d=>{const f=d.attributes,b=(0,k.parseInternalActivationAttributes)(f),x=f.getString("auto_pad","NOTSET"),D=f.getInts("dilations",[1,1]),P=f.getInt("group",1),L=f.getInts("kernel_shape",[]),B=f.getInts("output_padding",[0,0]),U=f.getInts("output_shape",[]),W=f.getInts("pads",[0,0,0,0]),H=f.getInts("strides",[1,1]);return(0,F.createAttributeWithCacheKey)(Object.assign({autoPad:x,dilations:D,group:P,kernelShape:L,outputPadding:B,outputShape:U,pads:W,strides:H},b))};const l=(d,f)=>{if(!d||2!==d.length&&3!==d.length)throw new Error("Conv requires 2 or 3 inputs");if(4!==d[0].dims.length||4!==d[1].dims.length)throw new Error("currently only support 2-dimensional conv");if(d[0].dims[1]!==d[1].dims[0])throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");if(3===d.length&&(1!==d[2].dims.length||d[2].dims[0]!==d[1].dims[1]*f.group))throw new Error("invalid bias");const x=d[0].dims.length-2;if(f.dilations.length!==x)throw new Error(`dilations should be ${x}D`);if(f.strides.length!==x)throw new Error(`strides should be ${x}D`);if(f.pads.length!==2*x)throw new Error(`pads should be ${2*x}D`);if(f.outputPadding.length!==x)throw new Error(`output_padding should be ${x}D`);if(0!==f.kernelShape.length&&f.kernelShape.length!==d[1].dims.length-2)throw new Error("invalid kernel shape");if(0!==f.outputShape.length&&f.outputShape.length!==d[0].dims.length-2)throw new Error("invalid output shape");if("float32"!==d[0].type||"float32"!==d[1].type)throw new Error("ConvTranspose input(X,W) should be float tensor");if(3===d.length&&"float32"!==d[2].type)throw new Error("ConvTranspose input(bias) should be float tensor")}},9754:(ge,E,$)=>{"use strict";Object.defineProperty(E,"__esModule",{value:!0}),E.parseConvAttributes=E.conv=E.calculateOutputShape=void 0;const F=$(4910),N=$(7273),R=$(7825),k=$(7708),S=$(3281),C=$(2150),v=$(1625),g=$(8276);E.calculateOutputShape=(x,D,P,L,B)=>{const U=x[0],W=x.slice(2),H=W.length,re=D[0],ue=D.slice(2).map((se,Y)=>se+(se-1)*(P[Y]-1)),te=W.map((se,Y)=>se+L[Y]+L[Y+H]).map((se,Y)=>Math.floor((se-ue[Y]+B[Y])/B[Y]));return[U,re].concat(...te)},E.conv=(x,D,P)=>(b(D,P),h(x,D,P));const h=(x,D,P)=>{const L=f(P,D),B=x.session.pack,U=1===L.kernelShape[0]&&1===L.kernelShape[1];return L.group>1?[x.run((0,R.createUnpackedGroupedConvProgramInfoLoader)(x,D,L),D)]:U&&B?[l(x,D,L)]:B&&4===D[0].dims.length&&1===D[0].dims[0]&&!U?[(0,k.conv2DPacked)(x,D,L)]:[d(x,D,L)]},l=(x,D,P)=>{const L=D[0].dims,B=D[1].dims,U=(0,E.calculateOutputShape)(L,B,P.dilations,P.pads,P.strides),W=x.reshapeUnpacked(D[0],[L[1],L[2]*L[3]]),H=x.reshapeUnpacked(D[1],[B[0],B[1]]),re=D.length>2?[H,W,D[2]]:[H,W],ue=x.run((0,g.createMatmulProgramInfoLoader)(re,P),re);return x.reshapeUnpacked(ue,U)},d=(x,D,P)=>{const U=(0,E.calculateOutputShape)(D[0].dims,D[1].dims,P.dilations,P.pads,P.strides),W=x.run((0,v.createIm2ColProgramInfoLoader)(x,D[0],D[1],U,P),[D[0]]),H=3===D.length?[W,D[1],D[2]]:[W,D[1]];return x.run((0,S.createDotProductProgramInfoLoader)(x,D,U,P),H)},f=(x,D)=>{const P=x.kernelShape.slice();if(0===x.kernelShape.length)for(let U=2;U<D[1].dims.length;++U)P.push(D[1].dims[U]);const L=x.pads.slice();N.PoolConvUtil.adjustPadsBasedOnAutoPad(D[0].dims,x.strides,x.dilations,P,L,x.autoPad);const B=Object.assign({},x);return Object.assign(B,{kernelShape:P,pads:L,cacheKey:x.cacheKey}),B};E.parseConvAttributes=x=>{const D=x.attributes,P=(0,C.parseInternalActivationAttributes)(D),L=D.getString("auto_pad","NOTSET"),B=D.getInts("dilations",[1,1]),U=D.getInt("group",1),W=D.getInts("kernel_shape",[]),H=D.getInts("pads",[0,0,0,0]),re=D.getInts("strides",[1,1]);return(0,F.createAttributeWithCacheKey)(Object.assign({autoPad:L,dilations:B,group:U,kernelShape:W,pads:H,strides:re},P))};const b=(x,D)=>{if(!x||2!==x.length&&3!==x.length)throw new Error("Conv requires 2 or 3 inputs");if(4!==x[0].dims.length||4!==x[1].dims.length)throw new Error("currently only support 2-dimensional conv");if(x[0].dims[1]!==x[1].dims[1]*D.group)throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");if(3===x.length&&(1!==x[2].dims.length||x[1].dims[0]!==x[2].dims[0]))throw new Error("invalid bias");const P=x[0].dims.length-2;if(D.dilations.length!==P)throw new Error(`dilations should be ${P}D`);if(D.strides.length!==P)throw new Error(`strides should be ${P}D`);if(D.pads.length!==2*P)throw new Error(`pads should be ${2*P}D`);if(0!==D.kernelShape.length&&D.kernelShape.length!==x[1].dims.length-2)throw new Error("invalid kernel shape");if("float32"!==x[0].type||"float32"!==x[1].type)throw new Error("Conv input(X,W) should be float tensor");if(3===x.length&&"float32"!==x[2].type)throw new Error("Conv input(bias) should be float tensor")}},6742:(ge,E,$)=>{"use strict";Object.defineProperty(E,"__esModule",{value:!0}),E.parseDepthToSpaceAttributes=E.depthToSpace=void 0;const F=$(5707);E.depthToSpace=(R,k,S)=>{N(k);const C=S.blocksize,v=C*C,g="DCR"===S.mode?[0,3,4,1,5,2]:[0,1,4,2,5,3],l=R.reshapeUnpacked(k[0],"DCR"===S.mode?[k[0].dims[0],C,C,k[0].dims[1]/v,k[0].dims[2],k[0].dims[3]]:[k[0].dims[0],k[0].dims[1]/v,C,C,k[0].dims[2],k[0].dims[3]]),d={perm:g,cacheKey:`${g}`},[f]=(0,F.transpose)(R,[l],d);return[R.reshapeUnpacked(f,[k[0].dims[0],k[0].dims[1]/v,k[0].dims[2]*C,k[0].dims[3]*C])]},E.parseDepthToSpaceAttributes=R=>{const k=R.attributes.getInt("blocksize");if(k<1)throw new Error(`blocksize must be >= 1, but got : ${k} for DepthToSpace`);const S=R.attributes.getString("mode","DCR");if("DCR"!==S&&"CRD"!==S)throw new Error(`unrecognized mode: ${S} for DepthToSpace`);return{mode:S,blocksize:k}};const N=R=>{if(1!==R.length)throw new Error(`DepthToSpace expect 1 inputs, but got ${R.length}`);if("string"===R[0].type||4!==R[0].dims.length)throw new TypeError("DepthToSpace input should be a 4-D numeric tensor")}},3281:(ge,E,$)=>{"use strict";Object.defineProperty(E,"__esModule",{value:!0}),E.createDotProductProgramInfoLoader=void 0;const F=$(7273),N=$(6757),R=$(5639),k=$(2150),S=$(1625);E.createDotProductProgramInfoLoader=(C,v,g,h)=>{const l={name:"ConvDotProduct",inputNames:(d=v.length>2)?["Im2Col","K","B"]:["Im2Col","K"],inputTypes:d?[R.TextureType.unpacked,R.TextureType.packedLastDimension,R.TextureType.unpacked]:[R.TextureType.unpacked,R.TextureType.packedLastDimension],cacheKey:h.activationCacheKey};var d;return Object.assign(Object.assign({},l),{get:()=>((d,f,b,x,D)=>{const P=b[0].dims,L=b[1].dims,B=[L[0],Math.ceil(P[1]*L[2]*L[3]/4)],U=(0,S.calculateIm2ColDims)(P,L,x),[W,H]=d.calculateTextureWidthAndHeight(B,R.TextureType.packedLastDimension),re=F.ShapeUtil.computeStrides(U),[ue,te]=d.calculateTextureWidthAndHeight(U,R.TextureType.packedLastDimension),se=x.length,Y=b.length<3?"0.0":"_B(b)",X=Math.ceil(P[1]*L[2]*L[3]/4),{activationFunction:we,applyActivation:K}=(0,k.getActivationSnippet)(D),ie=(0,N.getGlsl)(d.session.backend.glContext.version),ce=`\n${we}\nfloat process(int indices[${se}]) {\n  int b[1];\n  b[0] = indices[1];\n  int im2col[4];\n  im2col[0] = indices[0];\n  im2col[1] = indices[2];\n  im2col[2] = indices[3];\n  int im2colOffset = im2col[0] * ${re[0]} + im2col[1] * ${re[1]} + im2col[2] * ${re[2]};\n  int kernelOffset = indices[1] * ${B[1]};\n  float value = ${Y};\n  for (int i = 0; i < ${X}; ++i) {\n    vec2 im2colCoords = offsetToCoords(im2colOffset, ${ue}, ${te});\n    vec2 kernelCoords = offsetToCoords(kernelOffset, ${W}, ${H});\n    value += dot(${ie.texture2D}(Im2Col, im2colCoords), ${ie.texture2D}(K, kernelCoords));\n    ++im2colOffset;\n    ++kernelOffset;\n  }\n  ${K}\n  return value;\n}`;return Object.assign(Object.assign({},f),{output:{dims:x,type:b[0].type,textureType:R.TextureType.unpacked},shaderSource:ce})})(C,l,v,g,h)})}},4125:(ge,E,$)=>{"use strict";Object.defineProperty(E,"__esModule",{value:!0}),E.parseFlattenAttributes=E.flatten=void 0;const F=$(7273);E.flatten=(R,k,S)=>{N(k,S);const C=F.ShapeUtil.flattenShape(k[0].dims,S);return[R.reshapeUnpacked(k[0],C)]},E.parseFlattenAttributes=R=>R.attributes.getInt("axis",1);const N=(R,k)=>{if(!R||1!==R.length)throw new Error("Flatten requires 1 input.");const S=R[0].dims.length;if(0===S)throw new Error("scalar tensor is not supported.");if(k<-S||k>S)throw new Error("Invalid axis");if("string"===R[0].type)throw new Error("string tensor is not supported.")}},2150:(ge,E,$)=>{"use strict";Object.defineProperty(E,"__esModule",{value:!0}),E.parseInternalActivationAttributes=E.getActivationSnippet=void 0;const F=$(7273),N=$(9087);E.getActivationSnippet=function(R){let k;switch(R.activation){case"Relu":k=(0,N.glslRelu)();break;case"Sigmoid":k=(0,N.glslSigmoid)();break;case"Clip":k=(0,N.glslClip)(R.clipMin,R.clipMax);break;default:return{activationFunction:"",applyActivation:""}}return{activationFunction:k.body,applyActivation:`value = ${k.name}_(value);`}},E.parseInternalActivationAttributes=R=>{const k=R.getString("activation","");if("Clip"===k){const[S,C]=R.getFloats("activation_params",[F.MIN_CLIP,F.MAX_CLIP]);return{activation:k,clipMax:C,clipMin:S,activationCacheKey:`${k}:${S},${C}`}}return{activation:k,activationCacheKey:k}}},6149:(ge,E,$)=>{"use strict";Object.defineProperty(E,"__esModule",{value:!0}),E.parseGatherAttributes=E.gather=void 0;const F=$(4910),N=$(6145),R=$(7273),k=$(5639);E.gather=(g,h,l)=>(v(h,l.axis),[g.run(C(g,h,l),h)]),E.parseGatherAttributes=g=>(0,F.createAttributeWithCacheKey)({axis:g.attributes.getInt("axis",0)});const S={name:"Gather",inputNames:["A","B"],inputTypes:[k.TextureType.unpacked,k.TextureType.unpacked]},C=(g,h,l)=>{const d=Object.assign(Object.assign({},S),{cacheHint:l.cacheKey});return Object.assign(Object.assign({},d),{get:()=>((f,b,x,D)=>{const P=x[0].dims.slice(),L=x[1].dims.slice(),B=new Array(P.length+L.length-1);D=R.ShapeUtil.normalizeAxis(D,P.length);const U=[];for(let H=0;H<B.length;H++)H<D?(B[H]=P[H],U.push(`inputIdx[${H}] = outputIdx[${H}];`)):H<D+L.length?(B[H]=L[H-D],U.push(`indexDataIdx[${H-D}] = outputIdx[${H}];`)):(B[H]=P[H-L.length+1],U.push(`inputIdx[${H-L.length+1}] = outputIdx[${H}];`));const W=`\n      float process(int outputIdx[${B.length||1}]) {\n        int inputIdx[${P.length}];\n        int indexDataIdx[${L.length||1}];\n        indexDataIdx[0] = 0;\n        ${U.join("\n        ")}\n        int idx = int(_B(indexDataIdx));\n        inputIdx[${D}] = idx < 0 ? idx + ${P[D]} : idx;\n        return _A(inputIdx);\n      }`;return Object.assign(Object.assign({},b),{output:{dims:B,type:x[0].type,textureType:k.TextureType.unpacked},shaderSource:W})})(0,d,h,l.axis)})},v=(g,h)=>{if(!g||2!==g.length)throw new Error("Gather requires 2 inputs.");const l=g[0].dims.length;if(l<1)throw new Error("Invalid input shape.");if(h<-l||h>l-1)throw new Error("Invalid axis.");if(-1===N.NUMBER_TYPES.indexOf(g[0].type))throw new Error("Invaid input type.");if("int32"!==g[1].type&&"int16"!==g[1].type)throw new Error("Invaid input type.")}},5378:(ge,E,$)=>{"use strict";Object.defineProperty(E,"__esModule",{value:!0}),E.parseGemmAttributesV11=E.parseGemmAttributesV7=E.gemm=void 0;const F=$(4910),N=$(7273),R=$(5639);E.gemm=(g,h,l)=>(v(h,l),[g.run(S(h,l),h)]);const k=(g,h)=>{const l=0!==g.attributes.getInt("transA",0),d=0!==g.attributes.getInt("transB",0),f=g.attributes.getFloat("alpha",1),b=g.attributes.getFloat("beta",1);return(0,F.createAttributeWithCacheKey)({transA:l,transB:d,alpha:f,beta:b,isOptionalC:h})};E.parseGemmAttributesV7=g=>k(g,!1),E.parseGemmAttributesV11=g=>k(g,!0);const S=(g,h)=>{const l={name:"Gemm",inputNames:3===g.length?["A","B","C"]:["A","B"],inputTypes:3===g.length?[R.TextureType.unpacked,R.TextureType.unpacked,R.TextureType.unpacked]:[R.TextureType.unpacked,R.TextureType.unpacked],key:h.cacheKey};return Object.assign(Object.assign({},l),{get:()=>C(l,g,h)})},C=(g,h,l)=>{const d=h[0].dims.slice(),f=h[1].dims.slice(),[b,x]=N.GemmUtil.getShapeOfGemmResult(d,l.transA,f,l.transB,3===h.length?h[2].dims:void 0),D=[b,x];if(!D)throw new Error("Can't use gemm on the given tensors");let P=d[d.length-1],L="";l.transA&&(P=d[0]),l.transA&&l.transB?L="value += _A_T(a) * _B_T(b);":l.transA&&!l.transB?L="value += _A_T(a) * _B(b);":!l.transA&&l.transB?L="value += _A(a) * _B_T(b);":l.transA||l.transB||(L="value += _A(a) * _B(b);");const B=D.length,U=`\n      float process(int indices[${B}]) {\n          int a[${B}];\n          int b[${B}];\n          ${3===h.length?`int c[${h[2].dims.length}];`:""}\n\n          copyVec(indices, a);\n          copyVec(indices, b);\n          ${3===h.length?"bcastIndices_C(indices, c);":""}\n\n          float value = 0.0;\n          for (int k=0; k<${P}; ++k) {\n              a[${B-1}] = k;\n              b[${B-2}] = k;\n              ${L}\n          }\n\n          value = value * alpha;\n          ${3===h.length?"value += beta * _C(c);":""}\n          return value;\n      }`;return Object.assign(Object.assign({},g),{output:{dims:D,type:h[0].type,textureType:R.TextureType.unpacked},variables:[{name:"alpha",type:"float",data:l.alpha},{name:"beta",type:"float",data:l.beta}],shaderSource:U})},v=(g,h)=>{if(!g)throw new Error("Input is missing");if(h.isOptionalC&&(g.length<2||g.length>3))throw new Error("Invaid input shape.");if(!h.isOptionalC&&3!==g.length)throw new Error("Gemm requires 3 inputs");if(3===g.length&&1!==g[2].dims.length&&2!==g[2].dims.length)throw new Error("Invalid input shape of C");if("float32"!==g[0].type&&"float64"!==g[0].type||"float32"!==g[1].type&&"float64"!==g[1].type||3===g.length&&"float32"!==g[2].type&&"float64"!==g[2].type)throw new Error("Invalid input type.");if(g[0].type!==g[1].type||3===g.length&&g[0].type!==g[2].type)throw new Error("Input types are mismatched")}},5950:(ge,E,$)=>{"use strict";Object.defineProperty(E,"__esModule",{value:!0}),E.createPackedIm2ColProgramInfoLoader=void 0;const F=$(6757),N=$(5639),R=$(5614);E.createPackedIm2ColProgramInfoLoader=(k,S,C,v,g)=>{const h={name:"Im2Col (packed)",inputNames:["A"],inputTypes:[N.TextureType.packed],cacheHint:g.cacheKey};return Object.assign(Object.assign({},h),{get:()=>((d,f,b,x,D,P)=>{const L=b.dims,B=x.dims,U=D.length,W=[B[1]*B[2]*B[3],D[2]*D[3]],H=B[2]*B[3],re=(0,R.unpackFromChannel)(),ue=(0,F.getGlsl)(d.session.backend.glContext.version);let te="";for(let Y=0;Y<=1;Y++)for(let X=0;X<=1;X++)te+=`\n            blockIndex = rc.x + ${X};\n            pos = rc.y + ${Y};\n\n            if(blockIndex < ${W[1]} && pos < ${W[0]}) {\n              offsetY = int(blockIndex / (${D[U-1]})) * ${P.strides[0]} -\n                ${P.pads[0]};\n              d0 = offsetY + ${P.dilations[0]} * (imod(pos, ${H}) / ${B[2]});\n\n              if(d0 < ${L[2]} && d0 >= 0) {\n                offsetX = imod(blockIndex, ${D[U-1]}) * ${P.strides[1]} -\n                  ${P.pads[1]};\n                d1 = offsetX + ${P.dilations[1]} * imod(imod(pos, ${H}), ${B[2]});\n\n                if(d1 < ${L[3]} && d1 >= 0) {\n\n                  ch = int(float(pos)/ ${H}.);\n                    innerDims = vec2(d0, d1);\n                    result[${2*Y+X}] = getChannel(\n                      getA(0, ch, int(innerDims.x),\n                      int(innerDims.y)), innerDims);\n                }\n              }\n            }\n\n          `;const se=`\n      ${re}\n\n      void main() {\n        ivec2 rc = getOutputCoords();\n          vec4 result = vec4(0.0);\n          int blockIndex, pos, offsetY, d0, offsetX, d1, ch;\n          vec2 innerDims;\n          ${te}\n          ${ue.output} = result;\n      }\n            `;return Object.assign(Object.assign({},f),{output:{dims:W,type:b.type,textureType:N.TextureType.packed},shaderSource:se,hasMain:!0})})(k,h,S,C,v,g)})}},1625:(ge,E,$)=>{"use strict";Object.defineProperty(E,"__esModule",{value:!0}),E.calculateIm2ColDims=E.createIm2ColProgramInfoLoader=void 0;const F=$(5639);E.createIm2ColProgramInfoLoader=(N,R,k,S,C)=>{const v={name:"Im2Col",inputNames:["X"],inputTypes:[F.TextureType.unpacked],cacheHint:C.cacheKey};return Object.assign(Object.assign({},v),{get:()=>((h,l,d,f,b,x)=>{const D=d.dims,L=b.length,B=(0,E.calculateIm2ColDims)(D,f.dims,b,4),U=`\n        const int XC = ${D[1]};\n        const int XH = ${D[2]};\n        const int XW = ${D[3]};\n        const int KH = ${x.kernelShape[0]};\n        const int KW = ${x.kernelShape[1]};\n        const int dilationH = ${x.dilations[0]};\n        const int dilationW = ${x.dilations[1]};\n        const int strideH = ${x.strides[0]};\n        const int strideW = ${x.strides[1]};\n        const int padH = ${x.pads[0]};\n        const int padW = ${x.pads[1]};\n        const int KHKW = KH*KW;\n        const int XCKHKW = XC * KHKW;\n        const int outputChannels = 4;\n        vec4 process(int indices[${L}]) {\n          int b  = indices[0]; // batch size\n          int oh = indices[1] * strideH - padH; //output height\n          int ow = indices[2] * strideW - padW; //output width\n          int p = indices[3] * outputChannels; //patch\n          vec4 value = vec4(0.0);\n          for(int i=0; i < outputChannels; ++i) {\n            if(p < XCKHKW) {\n              int patchC = p / KHKW;\n              int patchH = (p - patchC*KHKW) / KW;\n              int patchW = (p - patchC*KHKW) - patchH * KW;\n              int xh2 = oh + patchH * dilationH;\n              int xw2 = ow + patchW * dilationW;\n              int x[${D.length}];\n              x[0] = b;\n              x[1] = patchC;\n              x[2] = xh2;\n              x[3] = xw2;\n              if(xh2 >= 0 &&\n                  xh2 < XH &&\n                  xw2 >= 0 &&\n                  xw2 < XW) {\n                value[i] = _X(x);\n              }\n            }\n            ++p;\n          }\n          return value;\n        }\n        `;return Object.assign(Object.assign({},l),{output:{dims:B,type:d.type,textureType:F.TextureType.packedLastDimension},shaderSource:U})})(0,v,R,k,S,C)})},E.calculateIm2ColDims=(N,R,k,S=4)=>[k[0],k[2],k[3],Math.ceil(N[1]*R[2]*R[3]/S)]},6981:(ge,E,$)=>{"use strict";Object.defineProperty(E,"__esModule",{value:!0}),E.parseImageScalerAttributes=E.imageScaler=void 0;const F=$(4910),N=$(5639);E.imageScaler=(v,g,h)=>(C(g),[v.run(k(v,g,h),g)]),E.parseImageScalerAttributes=v=>{const g=v.attributes.getFloat("scale"),h=v.attributes.getFloats("bias");return(0,F.createAttributeWithCacheKey)({scale:g,bias:h})};const R={name:"ImageScaler",inputNames:["X"],inputTypes:[N.TextureType.unpacked]},k=(v,g,h)=>{const l=Object.assign(Object.assign({},R),{cacheHint:h.cacheKey});return Object.assign(Object.assign({},l),{get:()=>((d,f,b,x)=>{const D=b[0].dims.slice(),P=D.length,L=`\n      ${S(x.bias.length)}\n      float process(int indices[${P}]) {\n        return _X(indices) * scale + getBias(bias, indices[1]);\n      }`;return Object.assign(Object.assign({},f),{output:{dims:D,type:b[0].type,textureType:N.TextureType.unpacked},variables:[{name:"bias",type:"float",arrayLength:x.bias.length,data:x.bias},{name:"scale",type:"float",data:x.scale}],shaderSource:L})})(0,l,g,h)})},S=v=>{const g=[`float getBias(float bias[${v}], int channel) {`];for(let h=0;h<v;++h)g.push(0===h?`\tif (channel == ${h}) { return bias[${h}]; }`:h===v-1?`\telse { return bias[${h}]; }`:`\telse if (channel == ${h}) { return bias[${h}]; }`);return g.push("\t}"),g.join("\n")},C=v=>{if(!v||1!==v.length)throw new Error("ImageScaler requires 1 input.");if(4!==v[0].dims.length)throw new Error("Invalid input shape.");if("float32"!==v[0].type&&"float64"!==v[0].type)throw new Error("Invalid input type.")}},7413:(ge,E,$)=>{"use strict";Object.defineProperty(E,"__esModule",{value:!0}),E.parseInstanceNormalizationAttributes=E.instanceNormalization=void 0;const F=$(6757),N=$(5639);E.instanceNormalization=(g,h,l)=>{v(h);const d=g.run(k(h[0]),h);return[g.run(C(g,h[0],l,d.dims),[h[0],d,h[1],h[2]])]},E.parseInstanceNormalizationAttributes=g=>g.attributes.getFloat("epsilon",1e-5);const R={name:"InstanceNormalization_MeanAndVariance",inputNames:["X"],inputTypes:[N.TextureType.unpacked]},k=g=>Object.assign(Object.assign({},R),{get:()=>((h,l)=>{const d=l.dims.slice(),b=d[2]*d[3],x=[d[0],d[1]],D=`\n      vec4 process(int[2] indices) {\n        vec4 v = vec4(0.0);\n        int a[4];\n        a[0] = indices[0];\n        a[1] = indices[1];\n        float temp = 0.0;\n        for(int a2=0; a2<${d[2]}; a2++) {\n          a[2] = a2;\n          for(int a3=0; a3<${d[3]}; a3++) {\n            a[3] = a3;\n            float x = _X(a);\n            temp += x;\n          }\n        }\n        float mean = temp / float(${b});\n        temp = 0.0;\n        for(int a2=0; a2<${d[2]}; a2++) {\n          a[2] = a2;\n          for(int a3=0; a3<${d[3]}; a3++) {\n            a[3] = a3;\n            float x = _X(a);\n            temp += (x - mean) * (x - mean);\n          }\n        }\n        v.r = mean;\n        v.g = temp / float(${b});\n\n        return v;\n      }`;return Object.assign(Object.assign({},h),{output:{dims:x,type:l.type,textureType:N.TextureType.packedLastDimension},shaderSource:D})})(R,g)}),S={name:"InstanceNormalization_ComputeOutput",inputNames:["X","MeanAndVariance","Scale","B"],inputTypes:[N.TextureType.unpacked,N.TextureType.packedLastDimension,N.TextureType.unpacked,N.TextureType.unpacked]},C=(g,h,l,d)=>{const f=Object.assign(Object.assign({},S),{cacheHint:`${l}`});return Object.assign(Object.assign({},f),{get:()=>((b,x,D,P,L)=>{const B=(0,F.getGlsl)(b.session.backend.glContext.version),[U,W]=b.calculateTextureWidthAndHeight(L,N.TextureType.packedLastDimension),[H,re]=[U/4,W],ue=`\n      vec4 get_MeanAndVariance(int[2] mv) {\n        int offset = indicesToOffset_MeanAndVariance(mv);\n        vec2 coords = offsetToCoords(offset, ${H}, ${re});\n        return ${B.texture2D}(MeanAndVariance, coords);\n      }\n\n      float process(int[4] indices) {\n        int mv[2];\n        mv[0] = indices[0];\n        mv[1] = indices[1];\n        vec4 mean_and_variance = get_MeanAndVariance(mv);\n        float mean = mean_and_variance.r;\n        float variance = mean_and_variance.g;\n\n        int sb[1];\n        sb[0] = indices[1];\n        float scale = _Scale(sb);\n        float b = _B(sb);\n\n        return scale * (_X(indices) - mean) / sqrt(variance + epsilon) + b;\n      }`;return Object.assign(Object.assign({},x),{output:{dims:D.dims,type:D.type,textureType:N.TextureType.unpacked},variables:[{name:"epsilon",type:"float",data:P}],shaderSource:ue})})(g,f,h,l,d)})},v=g=>{if(!g||3!==g.length)throw new Error("InstanceNormalization requires 3 inputs.");const h=g[0],l=g[1],d=g[2];if(h.dims.length<3||1!==l.dims.length||1!==d.dims.length)throw new Error("Invalid input shape.");if(l.dims[0]!==h.dims[1]||d.dims[0]!==h.dims[1])throw new Error("Input shapes are mismatched.");if("float32"!==h.type&&"float64"!==h.type||"float32"!==l.type&&"float64"!==l.type||"float32"!==d.type&&"float64"!==d.type)throw new Error("Invalid input type.");if(4!==g[0].dims.length)throw new Error("Only support 4-D input shape.")}},7006:(ge,E,$)=>{"use strict";Object.defineProperty(E,"__esModule",{value:!0}),E.createLrnProgramInfoLoader=E.parseLrnAttributes=E.lrn=void 0;const F=$(4910),N=$(5639);E.lrn=(C,v,g)=>(S(v),[C.run(k(v,g),v)]),E.parseLrnAttributes=C=>{const v=C.attributes.getFloat("alpha",1e-4),g=C.attributes.getFloat("beta",.75),h=C.attributes.getFloat("bias",1),l=C.attributes.getInt("size");return(0,F.createAttributeWithCacheKey)({alpha:v,beta:g,bias:h,size:l})};const R={name:"LRN",inputNames:["X"],inputTypes:[N.TextureType.unpacked]};function k(C,v){return Object.assign(Object.assign({},R),{cacheHint:v.cacheKey,get:()=>function(g,h){const l=g[0].dims[1],D=`\n    float process(int indices[${g[0].dims.length}]) {\n        int c = indices[1];\n        float x = _X(indices);\n        float square_sum = 0.0;\n\n        for (int i = ${-Math.floor((h.size-1)/2)}; i <= ${Math.ceil((h.size-1)/2)}; i++) {\n          int idx = c + i;\n          if (c >= 0 && c < ${l}) {\n            indices[1] = idx;\n            float j = _X(indices);\n            square_sum += j * j;\n          }\n        }\n        return x / pow(float(${h.bias}) + float(${h.alpha}) / float(${h.size}) * square_sum, float(${h.beta}));\n    }`;return Object.assign(Object.assign({},R),{cacheHint:h.cacheKey,output:{dims:g[0].dims,type:g[0].type,textureType:N.TextureType.unpacked},shaderSource:D})}(C,v)})}E.createLrnProgramInfoLoader=k;const S=C=>{if(!C||1!==C.length)throw new Error("LRN requires 1 input.");if(4!==C[0].dims.length)throw new Error('currently only support LRN for input with "NCHW" format');if("float32"!==C[0].type)throw new Error("input should be float type")}},5632:(ge,E,$)=>{"use strict";Object.defineProperty(E,"__esModule",{value:!0}),E.createPackedMatmulProgramInfoLoader=void 0;const F=$(7273),N=$(6757),R=$(5639),k=$(432),S=$(2150),C=$(8276);E.createPackedMatmulProgramInfoLoader=(v,g,h)=>{const l={name:"MatMul (packed)",inputNames:(d=g.length>2)?["A","B","Bias"]:["A","B"],inputTypes:d?[R.TextureType.packed,R.TextureType.packed,R.TextureType.packed]:[R.TextureType.packed,R.TextureType.packed],cacheHint:h.activationCacheKey};var d;return Object.assign(Object.assign({},l),{get:()=>((b,x,D,P)=>{const L=D.length>2,B=L?"value += getBiasForMatmul();":"",U=D[0].dims,W=D[1].dims,H=F.BroadcastUtil.calcShape(U,W,!0),re=!F.ShapeUtil.areEqual(D[0].dims,D[1].dims);if(!H)throw new Error("Can't use matmul on the given tensors");const te=Math.ceil(U[U.length-1]/2),se=U.length,Y=W.length,X=(0,N.getGlsl)(b.session.backend.glContext.version),we=(0,k.getCoordsDataType)(H.length),K=H.length,ie=(0,k.getGlChannels)(),{activationFunction:ce,applyActivation:qe}=(0,S.getActivationSnippet)(P),Be=L?`${(0,C.getBiasForMatmul)(we,ie,D[2].dims,H,!0)}`:"",at=re?`${function(wt,Mt,un,_n){let or=[],Tr=[];const Cs=un[0].dims,ki=un[1].dims,Br=Cs.length,Ni=ki.length,Cn=_n.length,Is=Cn-Br,Pr=Cn-Ni;or=Cs.map((Ur,Ks)=>`coords.${Mt[Ks+Is]}`),or[Br-1]="i*2",or.join(", "),Tr=ki.map((Ur,Ks)=>`coords.${Mt[Ks+Pr]}`),Tr[Ni-2]="i*2",Tr.join(", ");const zr=F.BroadcastUtil.getBroadcastDims(Cs,_n),Es=F.BroadcastUtil.getBroadcastDims(ki,_n),Oi=zr.map(Ur=>`coords.${Mt[Ur+Is]} = 0;`).join("\n"),Ms=Es.map(Ur=>`coords.${Mt[Ur+Pr]} = 0;`).join("\n"),no=`int lastDim = coords.${Mt[Cn-1]};\n  coords.${Mt[Cn-1]} = coords.${Mt[Cn-2]};\n  coords.${Mt[Cn-2]} = lastDim;`;return`\nvec4 getAAtOutCoordsMatmul(int i) {\n  ${wt} coords = getOutputCoords();\n  ${no}\n  ${Oi}\n  vec4 outputValue = getA(${or});\n  return outputValue;\n}\n\nvec4 getBAtOutCoordsMatmul(int i) {\n  ${wt} coords = getOutputCoords();\n  ${no}\n  ${Ms}\n  vec4 outputValue = getB(${Tr});\n  return outputValue;\n}`}(we,ie,D,H)}`:"",rt=re?"getAAtOutCoordsMatmul(i)":`getA(${function(wt,Mt){let un="";for(let _n=0;_n<Mt-2;_n++)un+=`rc.${wt[_n]}, `;return un+=`rc.${wt[Mt-2]}, i*2`,un}(ie,se)})`,ot=re?"getBAtOutCoordsMatmul(i)":`getB(${function(wt,Mt){let un="";for(let _n=0;_n<Mt-2;_n++)un+=`rc.${wt[_n]}, `;return un+=`i*2, rc.${wt[Mt-1]}`,un}(ie,Y)})`,bt=`\n            ${at}\n            ${Be}\n            ${ce}\n            void main() {\n              ${re?"":`${we} rc =\n          getOutputCoords(); int lastDim = rc.${ie[K-1]}; rc.${ie[K-1]} =\n          rc.${ie[K-2]}; rc.${ie[K-2]} = lastDim;\n      `}\n\n              vec4 value = vec4(0);\n              for (int i = 0; i < ${te}; i++) {\n                vec4 a = ${rt};\n                vec4 b = ${ot};\n\n                value += (a.rrbb * b.rgrg);\n                value += (a.ggaa * b.baba);\n              }\n              ${B}\n              ${qe}\n              ${X.output} = value;\n            }`;return Object.assign(Object.assign({},x),{output:{dims:H,type:D[0].type,textureType:R.TextureType.packed},shaderSource:bt,hasMain:!0})})(v,l,g,h)})}},8276:(ge,E,$)=>{"use strict";Object.defineProperty(E,"__esModule",{value:!0}),E.getBiasForMatmul=E.createMatmulProgramInfoLoader=E.parseMatMulAttributes=E.matMul=void 0;const F=$(7273),N=$(5639),R=$(432),k=$(2150),S=$(5632);E.matMul=(l,d,f)=>(g(d),l.session.pack?[l.run((0,S.createPackedMatmulProgramInfoLoader)(l,d,f),d)]:[l.run(v(d,f),d)]),E.parseMatMulAttributes=l=>(0,k.parseInternalActivationAttributes)(l.attributes);const C=(l,d)=>({name:"MatMul",inputNames:l?["A","B","Bias"]:["A","B"],inputTypes:l?[N.TextureType.unpacked,N.TextureType.unpacked,N.TextureType.unpacked]:[N.TextureType.unpacked,N.TextureType.unpacked],cacheHint:d});function v(l,d){const f=C(l.length>2,d.activationCacheKey);return Object.assign(Object.assign({},f),{get:()=>function(b,x,D){const P=x[0].dims,L=x[1].dims,B=F.BroadcastUtil.calcShape(P,L,!0);if(!B)throw new Error("Can't use matmul on the given tensors");const U=(0,R.getCoordsDataType)(B.length),W=(0,R.getGlChannels)(),{activationFunction:H,applyActivation:re}=(0,k.getActivationSnippet)(D),ue=x.length>2,te=ue?"value += getBiasForMatmul();":"",se=ue?`${h(U,W,x[2].dims,B,!1)}`:"",X=P.length,we=L.length,K=`\n    ${H}\n    ${se}\n    float process(int indices[${B.length}]) {\n        int a[${X}];\n        int b[${we}];\n        bcastMatmulIndices_A(indices, a);\n        bcastMatmulIndices_B(indices, b);\n\n        float value;\n        for (int k=0; k<${P[P.length-1]}; ++k) {\n            a[${X-1}] = k;\n            b[${we-2}] = k;\n            value += _A(a) * _B(b);\n        }\n        ${te}\n        ${re}\n        return value;\n    }`;return Object.assign(Object.assign({},b),{output:{dims:B,type:x[0].type,textureType:N.TextureType.unpacked},shaderSource:K})}(f,l,d)})}E.createMatmulProgramInfoLoader=v;const g=l=>{if(!l||2!==l.length)throw new Error("MatMul requires 2 inputs.");if(l[0].dims[l[0].dims.length-1]!==l[1].dims[l[1].dims.length-2])throw new Error("shared dimension does not match.");if("float32"!==l[0].type&&"float64"!==l[0].type||"float32"!==l[1].type&&"float64"!==l[1].type)throw new Error("inputs should be float type");if(l[0].type!==l[1].type)throw new Error("inputs types should match")};function h(l,d,f,b,x){let D="";const P=f.length,L=b.length,B=L-P;D=L<2&&P>0?"coords":f.map((H,re)=>`coords.${d[re+B]}`).join(", ");const U=F.BroadcastUtil.getBroadcastDims(f,b).map(H=>`coords.${d[H+B]} = 0;`).join("\n");let W="vec4(outputValue.xx, outputValue.yy)";return 1===F.ShapeUtil.size(f)&&(W="vec4(outputValue.x)"),x?`\nvec4 getBiasForMatmul() {\n  ${l} coords = getOutputCoords();\n  ${U}\n  vec4 outputValue = getBias(${D});\n  return ${W};\n}`:`\nfloat getBiasForMatmul() {\n  ${l} coords = getOutputCoords();\n  ${U}\n  return getBias(coords.x);\n}`}E.getBiasForMatmul=h},9:(ge,E,$)=>{"use strict";Object.defineProperty(E,"__esModule",{value:!0}),E.createPackProgramInfoLoader=void 0;const F=$(6757),N=$(5639),R=$(432),k=$(5614),S={name:"pack",inputNames:["A"],inputTypes:[N.TextureType.unpackedReversed]};E.createPackProgramInfoLoader=(C,v)=>Object.assign(Object.assign({},S),{get:()=>((g,h)=>{const l=(0,F.getGlsl)(g.session.backend.glContext.version),d=h.dims,f=d.length,b=h.dims.length,x=(0,R.getCoordsDataType)(b),D=(0,k.getChannels)("rc",b),P=(B=D,0===(L=b)||1===L?"":`\n    int r = ${B[L-2]};\n    int c = ${B[L-1]};\n    int rp1 = ${B[L-2]} + 1;\n    int cp1 = ${B[L-1]} + 1;\n    bool rEdge = rp1 >= ${d[d.length-1]};\n    bool cEdge = cp1 >= ${d[d.length-2]};\n    `);var L,B;let H;H=0===f?[1,1]:1===f?[d[0],1]:[d[b-1],d[b-2]];const re=function(se,Y,X){if(0===se)return"false";if(1===se)return`rc > ${Y[0]}`;let we="";for(let K=se-2;K<se;K++)we+=`${X[K]} >= ${Y[K-se+2]}`,K<se-1&&(we+="||");return we}(b,H,D),ue=function(se,Y){const X=se.length;if(0===X)return"getA(), 0, 0, 0";if(1===X)return`getA(rc),\n            rc + 1 >= ${se[0]} ? 0. : getA(rc + 1),\n            0, 0`;let we="";if(X>2)for(let K=0;K<X-2;++K)we+=`${Y[K]},`;return`getA(${we}r, c),\n          rEdge ? 0. : getA(${we}rp1, c),\n          cEdge ? 0. : getA(${we}r, cp1),\n          rEdge || cEdge ? 0. : getA(${we}rp1, cp1)`}(d,D),te=`\n        void main() {\n          ${x} rc = getOutputCoords();\n\n          if(${re}) {\n            ${l.output} = vec4(0);\n          } else {\n            ${P}\n\n            ${l.output} = vec4(${ue});\n          }\n        }\n      `;return Object.assign(Object.assign({},S),{hasMain:!0,output:{dims:h.dims,type:h.type,textureType:N.TextureType.packed},shaderSource:te})})(C,v)})},5614:(ge,E,$)=>{"use strict";Object.defineProperty(E,"__esModule",{value:!0}),E.unpackFromChannel=E.getChannels=E.getVecChannels=void 0;const F=$(432);function N(R,k){return(0,F.getGlChannels)(k).map(S=>`${R}.${S}`)}E.getVecChannels=N,E.getChannels=function(R,k){return 1===k?[R]:N(R,k)},E.unpackFromChannel=function(){return"\n    float getChannel(vec4 frag, int dim) {\n      int modCoord = imod(dim, 2);\n      return modCoord == 0 ? frag.r : frag.g;\n    }\n\n    float getChannel(vec4 frag, vec2 innerDims) {\n      vec2 modCoord = mod(innerDims, 2.);\n      return modCoord.x == 0. ?\n        (modCoord.y == 0. ? frag.r : frag.g) :\n        (modCoord.y == 0. ? frag.b : frag.a);\n    }\n  "}},5565:(ge,E,$)=>{"use strict";Object.defineProperty(E,"__esModule",{value:!0}),E.parsePadAttributesV11=E.padV11=E.parsePadAttributesV2=E.padV2=void 0;const F=$(4910),N=$(7273),R=$(6757),k=$(5639),S={name:"Pad",inputNames:["A"],inputTypes:[k.TextureType.unpacked]};E.padV2=(x,D,P)=>(g(D),[x.run(Object.assign(Object.assign({},S),{cacheHint:P.cacheKey,get:()=>v(x,D[0],P)}),D)]),E.parsePadAttributesV2=x=>{const D=x.attributes.getString("mode","constant"),P=x.attributes.getFloat("value",0),L=x.attributes.getInts("pads");return(0,F.createAttributeWithCacheKey)({mode:D,value:P,pads:L})},E.padV11=(x,D,P)=>{h(D);const L=C(x,D,P);return(0,E.padV2)(x,[D[0]],L)},E.parsePadAttributesV11=x=>x.attributes.getString("mode","constant");const C=(x,D,P)=>{if(!x.session.isInitializer(D[1].dataId)||D.length>=3&&!x.session.isInitializer(D[2].dataId))throw new Error("dynamic pad attributes are not allowed");const L=Array.from(D[1].integerData);return(0,F.createAttributeWithCacheKey)({mode:P,pads:L,value:D.length>=3?D[2].floatData[0]:0})},v=(x,D,P)=>{const L=N.ShapeUtil.padShape(D.dims.slice(),P.pads),B=L.length,U=`\n      ${l(x,D,P)}\n      float process(int[${B}] indices) {\n          return padA(indices);\n      }`;return{name:"Pad",inputNames:["A"],inputTypes:[k.TextureType.unpacked],output:{dims:L,type:D.type,textureType:k.TextureType.unpacked},shaderSource:U}},g=x=>{if(!x||1!==x.length)throw new Error("Pad requires 1 input");if("float32"!==x[0].type&&"float64"!==x[0].type)throw new Error("Invalid input type.")},h=x=>{if(!x||2!==x.length&&3!==x.length)throw new Error("Pad requires 2 or 3 inputs");if("int32"!==x[1].type)throw new Error("Invalid input type.");if(x.length>=3&&"string"===x[2].type)throw new Error("Invalid input type.")},l=(x,D,P)=>{const L=(0,R.getGlsl)(x.session.backend.glContext.version),[B,U]=x.calculateTextureWidthAndHeight(D.dims,k.TextureType.unpacked),W=N.ShapeUtil.computeStrides(D.dims);switch(P.mode){case"constant":return d(L,D.dims,W,B,U,P.pads,P.value);case"reflect":return f(L,D.dims,W,B,U,P.pads);case"edge":return b(L,D.dims,W,B,U,P.pads);default:throw new Error("Invalid mode")}},d=(x,D,P,L,B,U,W)=>{const H=D.length;let re="";for(let ue=H-1;ue>=0;--ue)re+=`\n        k = m[${ue}] - ${U[ue]};\n        if (k < 0)  return constant;\n        if (k >= ${D[ue]}) return constant;\n        offset += k * ${P[ue]};\n        `;return`\n      float padA(int m[${H}]) {\n        const float constant = float(${W});\n        int offset = 0;\n        int k = 0;\n        ${re}\n        vec2 coords = offsetToCoords(offset, ${L}, ${B});\n        float value = getColorAsFloat(${x.texture2D}(A, coords));\n        return value;\n      }\n      `},f=(x,D,P,L,B,U)=>{const W=D.length;let H="";for(let re=W-1;re>=0;--re)H+=`\n        k = m[${re}] - ${U[re]};\n        if (k < 0) { k = -k; }\n        {\n          const int _2n_1 = ${2*(D[re]-1)};\n          k = int( mod( float(k), float(_2n_1) ) ) ;\n          if(k >= ${D[re]}) { k = _2n_1 - k; }\n        }\n        offset += k * ${P[re]};\n        `;return`\n      float padA(int m[${W}]) {\n        int offset = 0;\n        int k = 0;\n        ${H}\n        vec2 coords = offsetToCoords(offset, ${L}, ${B});\n        float value = getColorAsFloat(${x.texture2D}(A, coords));\n        return value;\n      }\n      `},b=(x,D,P,L,B,U)=>{const W=D.length;let H="";for(let re=W-1;re>=0;--re)H+=`\n        k = m[${re}] - ${U[re]};\n        if (k < 0)  k = 0;\n        if (k >= ${D[re]}) k = ${D[re]-1};\n        offset += k * ${P[re]};\n      `;return`\n      float padA(int m[${W}]) {\n        int offset = 0;\n        int k = 0;\n        ${H}\n        vec2 coords = offsetToCoords(offset, ${L}, ${B});\n        float value = getColorAsFloat(${x.texture2D}(A, coords));\n        return value;\n      }\n      `}},2834:(ge,E,$)=>{"use strict";Object.defineProperty(E,"__esModule",{value:!0}),E.globalMaxPool=E.parseMaxPoolAttributes=E.maxPool=E.parseGlobalAveragePoolAttributes=E.globalAveragePool=E.parseAveragePoolAttributes=E.averagePool=void 0;const F=$(4910),N=$(7273),R=$(5639);E.averagePool=(b,x,D)=>{h(x);const P={name:"AveragePool",inputNames:["X"],inputTypes:[R.TextureType.unpacked],cacheHint:D.cacheKey};return[b.run(Object.assign(Object.assign({},P),{get:()=>k(x,P,!1,D)}),x)]},E.parseAveragePoolAttributes=b=>{const x=b.attributes.getString("auto_pad","NOTSET"),D=b.attributes.getInt("ceil_mode",0),P=0!==b.attributes.getInt("count_include_pad",0),L=b.attributes.getInts("kernel_shape"),B=b.attributes.getInts("strides",[]),U=b.attributes.getInts("pads",[]);if(0!==D)throw new Error("using ceil() in shape computation is not yet supported for AveragePool");return(0,F.createAttributeWithCacheKey)({autoPad:x,ceilMode:D,countIncludePad:P,kernelShape:L,strides:B,pads:U})};const k=(b,x,D,P)=>{const[L,B]=C(b,P,D),U=N.ShapeUtil.size(L.kernelShape);let W="";W+=L.countIncludePad?`value /= float(${U});`:`value /= float(${U} - pad);`;const H=`\n        ${l(b[0].dims,L,"value += _X(x);",W,"0.0")}\n      `;return Object.assign(Object.assign({},x),{output:{dims:B,type:b[0].type,textureType:R.TextureType.unpacked},shaderSource:H})};E.globalAveragePool=(b,x,D)=>{h(x);const P={name:"GlobalAveragePool",inputNames:["X"],inputTypes:[R.TextureType.unpacked],cacheHint:`${D.countIncludePad}`};return[b.run(Object.assign(Object.assign({},P),{get:()=>k(x,P,!0,D)}),x)]},E.parseGlobalAveragePoolAttributes=b=>{const x=0!==b.attributes.getInt("count_include_pad",0);return(0,F.createAttributeWithCacheKey)({autoPad:"",ceilMode:0,countIncludePad:x,kernelShape:[],strides:[],pads:[]})},E.maxPool=(b,x,D)=>{h(x);const P={name:"MaxPool",inputNames:["X"],inputTypes:[R.TextureType.unpacked],cacheHint:D.cacheKey};return[b.run(Object.assign(Object.assign({},P),{get:()=>S(x,P,!1,D)}),x)]},E.parseMaxPoolAttributes=b=>{const x=b.attributes.getString("auto_pad","NOTSET"),D=b.attributes.getInt("ceil_mode",0),P=b.attributes.getInts("kernel_shape"),L=b.attributes.getInts("strides",[]),B=b.attributes.getInts("pads",[]),U=b.attributes.getInt("storage_order",0),W=b.attributes.getInts("dilations",[]);if(0!==U)throw new Error("column major storage order is not yet supported for MaxPool");if(0!==D)throw new Error("using ceil() in shape computation is not yet supported for MaxPool");return(0,F.createAttributeWithCacheKey)({autoPad:x,ceilMode:D,countIncludePad:!1,kernelShape:P,strides:L,pads:B,storageOrder:U,dilations:W})};const S=(b,x,D,P)=>{const[L,B]=C(b,P,D),U=`\n      ${l(b[0].dims,L,"\n      value = max(_X(x), value);\n    ","","-1e5")}\n    `;return Object.assign(Object.assign({},x),{output:{dims:B,type:b[0].type,textureType:R.TextureType.unpacked},shaderSource:U})},C=(b,x,D)=>{const P=b[0].dims.slice(),L=Object.hasOwnProperty.call(x,"dilations"),B=x.kernelShape.slice(),U=x.strides.slice(),W=L?x.dilations.slice():[],H=x.pads.slice();N.PoolConvUtil.adjustPoolAttributes(D,P,B,U,W,H);const re=N.PoolConvUtil.computePoolOutputShape(D,P,U,W,B,H,x.autoPad),ue=Object.assign({},x);return Object.assign(ue,L?{kernelShape:B,strides:U,pads:H,dilations:W,cacheKey:x.cacheKey}:{kernelShape:B,strides:U,pads:H,cacheKey:x.cacheKey}),[ue,re]},v={autoPad:"",ceilMode:0,countIncludePad:!1,kernelShape:[],strides:[],pads:[],storageOrder:0,dilations:[],cacheKey:""},g={name:"GlobalMaxPool",inputNames:["X"],inputTypes:[R.TextureType.unpacked]};E.globalMaxPool=(b,x)=>(h(x),[b.run(Object.assign(Object.assign({},g),{get:()=>S(x,g,!0,v)}),x)]);const h=b=>{if(!b||1!==b.length)throw new Error("Pool ops requires 1 input.");if("float32"!==b[0].type&&"float64"!==b[0].type)throw new Error("Invalid input type.")},l=(b,x,D,P,L)=>{const B=b.length;if(x.kernelShape.length<=2){const U=x.kernelShape[x.kernelShape.length-1],W=x.strides[x.strides.length-1],H=x.pads[x.pads.length/2-1];let te="",se="",Y="";if(te=H+x.pads[x.pads.length-1]!==0?`\n          for (int i = 0; i < ${U}; i++) {\n            x[${B} - 1] = indices[${B} - 1] * ${W} - ${H} + i;\n            if (x[${B} - 1] < 0 || x[${B} - 1] >= ${b[B-1]}) {\n              pad++;\n              continue;\n            }\n            ${D}\n          }`:`\n          for (int i = 0; i < ${U}; i++) {\n            x[${B} - 1] = indices[${B} - 1] * ${W} - ${H} + i;\n            ${D}\n          }`,2===x.kernelShape.length){const X=x.kernelShape[x.kernelShape.length-2],we=x.strides[x.strides.length-2],K=x.pads[x.pads.length/2-2];se=K+x.pads[x.pads.length-2]!==0?`\n            for (int j = 0; j < ${X}; j++) {\n              x[${B} - 2] = indices[${B} - 2] * ${we} - ${K} + j;\n              if (x[${B} - 2] < 0 || x[${B} - 2] >= ${b[B-2]}) {\n                pad+= ${U};\n                continue;\n              }\n          `:`\n            for (int j = 0; j < ${X}; j++) {\n              x[${B} - 2] = indices[${B} - 2] * ${we} - ${K} + j;\n            `,Y="\n          }\n        "}return`\n        float process(int indices[${B}]) {\n          int x[${B}];\n          copyVec(indices, x);\n\n          float value = ${L};\n          int pad = 0;\n          ${se}\n          ${te}\n          ${Y}\n          ${P}\n          return value;\n        }\n      `}{const U=N.ShapeUtil.size(x.kernelShape),W=N.ShapeUtil.computeStrides(x.kernelShape),H=W.length,re=x.pads.length,ue=f(H),te=d(b,"inputDims"),se=d(x.pads,"pads"),Y=d(W,"kernelStrides"),X=d(x.strides,"strides");let we="";return we=x.pads.reduce((K,ie)=>K+ie)?`\n            if (x[j] >= inputDims[j] || x[j] < 0) {\n              pad++;\n              isPad = true;\n              break;\n            }\n          }\n          if (!isPad) {\n            ${D}\n          }`:`\n          }\n          ${D}\n        `,`\n        ${ue}\n        float process(int indices[${B}]) {\n          int x[${B}];\n          copyVec(indices, x);\n          int offset[${H}];\n          int pads[${re}];\n          int inputDims[${B}];\n          int kernelStrides[${H}];\n          int strides[${H}];\n          ${se}\n          ${te}\n          ${X}\n          ${Y}\n\n          float value = ${L};\n          int pad = 0;\n          bool isPad = false;\n          for (int i = 0; i < ${U}; i++) {\n            offsetToIndices(i, kernelStrides, offset);\n            isPad = false;\n            for (int j = ${B} - ${H}; j < ${B}; j++) {\n              x[j] = indices[j] * strides[j - ${B} + ${H}]\n                + offset[j - ${B} + ${H}] - pads[j - 2];\n              ${we}\n          }\n          ${P}\n\n          return value;\n        }\n      `}},d=(b,x)=>{let D="";for(let P=0;P<b.length;P++)D+=`\n      ${x}[${P}] = ${b[P]};\n    `;return D},f=b=>`\n  void offsetToIndices(int offset, int[${b}] strides, out int[${b}] indices) {\n    if (${b} == 0) {\n      return;\n    }\n    for (int i = 0; i < ${b} - 1; ++i) {\n      indices[i] = offset / strides[i];\n      offset -= indices[i] * strides[i];\n    }\n    indices[${b} - 1] = offset;\n  }`},1010:(ge,E,$)=>{"use strict";Object.defineProperty(E,"__esModule",{value:!0}),E.reduceLogSumSquare=E.reduceLogSum=E.reduceProd=E.reduceMin=E.reduceMax=E.reduceMean=E.reduceSum=E.parseReduceAttributes=void 0;const F=$(4910),N=$(6145),R=$(7273),k=$(5639),S=(g,h,l,d,f)=>{v(h);const b={name:d,inputNames:["A"],inputTypes:[k.TextureType.unpacked]};return[g.run(Object.assign(Object.assign({},b),{cacheHint:l.cacheKey,get:()=>C(g,h,l,d,f,b)}),h)]};E.parseReduceAttributes=g=>{const h=g.attributes.getInts("axes",[]),l=1===g.attributes.getInt("keepdims",1);return(0,F.createAttributeWithCacheKey)({axes:h,keepDims:l})};const C=(g,h,l,d,f,b)=>{const x=[],D=h[0].dims.length||1,P=[],L=R.ShapeUtil.normalizeAxes(l.axes,h[0].dims.length),B=f(h,L);let U=B[1];for(let H=0;H<h[0].dims.length;H++)L.indexOf(H)>=0||0===L.length?(l.keepDims&&x.push(1),U=`\n          for(int j${H} = 0; j${H} < ${h[0].dims[H]}; j${H}++) {\n            inputIdx[${H}] = j${H};\n            ${U}\n          }`):(P.push(`inputIdx[${H}] = outputIdx[${x.length}];`),x.push(h[0].dims[H]));const W=`\n      float process(int outputIdx[${x.length||1}]) {\n        float value;                 // final result\n        int inputIdx[${D}];      // addressing input data\n        ${P.join("\n")}\n        ${B[0]}       // init ops for reduce max/min\n        ${U}\n        ${B[2]}       // final computation for reduce mean\n        return value;\n      }`;return Object.assign(Object.assign({},b),{output:{dims:x,type:h[0].type,textureType:k.TextureType.unpacked},shaderSource:W})},v=g=>{if(!g||1!==g.length)throw new Error("Reduce op requires 1 input.");if(-1===N.NUMBER_TYPES.indexOf(g[0].type))throw new Error("Invalid input type.")};E.reduceSum=(g,h,l)=>S(g,h,l,"ReduceSum",()=>["value = 0.0;","value += _A(inputIdx);",""]),E.reduceMean=(g,h,l)=>S(g,h,l,"ReduceMean",(d,f)=>{let b=1;for(let x=0;x<d[0].dims.length;x++)(f.indexOf(x)>=0||0===f.length)&&(b*=d[0].dims[x]);return["value = 0.0;","value += _A(inputIdx);",`value /= ${b}.;`]}),E.reduceMax=(g,h,l)=>S(g,h,l,"ReduceMax",(d,f)=>{const b=[];for(let x=0;x<d[0].dims.length;x++)(f.indexOf(x)>=0||0===f.length)&&b.push(`inputIdx[${x}] = 0;`);return[`${b.join("\n")}\nvalue = _A(inputIdx);`,"value = max(value, _A(inputIdx));",""]}),E.reduceMin=(g,h,l)=>S(g,h,l,"ReduceMin",(d,f)=>{const b=[];for(let x=0;x<d[0].dims.length;x++)(f.indexOf(x)>=0||0===f.length)&&b.push(`inputIdx[${x}] = 0;`);return[`${b.join("\n")}\nvalue = _A(inputIdx);`,"value = min(value, _A(inputIdx));",""]}),E.reduceProd=(g,h,l)=>S(g,h,l,"ReduceProd",()=>["value = 1.0;","value *= _A(inputIdx);",""]),E.reduceLogSum=(g,h,l)=>S(g,h,l,"ReduceLogSum",()=>["value = 0.0;","value += _A(inputIdx);","value = log(value);"]),E.reduceLogSumSquare=(g,h,l)=>S(g,h,l,"ReduceLogSumSquare",()=>["float t; value = 0.0;","t = _A(inputIdx); value += t * t;",""])},7379:(ge,E,$)=>{"use strict";Object.defineProperty(E,"__esModule",{value:!0}),E.isReshapeCheap=E.processDims3D=E.createPackedReshape3DProgramInfoLoader=void 0;const F=$(7273),N=$(6757),R=$(5639),k=$(5614);E.createPackedReshape3DProgramInfoLoader=(S,C,v)=>{const g={name:"Reshape (packed)",inputTypes:[R.TextureType.packed],inputNames:["A"],cacheHint:`${v}`};return Object.assign(Object.assign({},g),{get:()=>((h,l,d,f)=>{const b=l.dims,x=f;let D="";for(let B=0;B<4;B++){let U="";switch(B){case 0:U="outputCoords = rc;";break;case 1:U="outputCoords = ivec3(rc.x, rc.y+1, rc.z);";break;case 2:U="outputCoords = ivec3(rc.x, rc.y, rc.z+1);";break;case 3:U="outputCoords = ivec3(rc.x, rc.y+1, rc.z+1);";break;default:throw new Error}D+=`\n        ${U}\n        ${B>0?"if(outputCoords.y < rows && outputCoords.z < cols){":""}\n          int flattenedIndex = getFlattenedIndex(outputCoords);\n\n          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flattenedIndex);\n          vec2 innerDims = vec2(float(inputRC.y),float(inputRC.z));\n\n          result[${B}] = getChannel(getA(inputRC.x, inputRC.y, inputRC.z), innerDims);\n\n        ${B>0?"}":""}\n      `}const P=(0,N.getGlsl)(h.session.backend.glContext.version),L=`\n      ${function(B){const U=F.ShapeUtil.computeStrides(B),W=["b","r","c"],H="index";return`\n    ivec3 inputCoordsFromReshapedOutCoords(int index) {\n      ${U.map((re,ue)=>`int ${W[ue]} = ${H} / ${re}; ${ue===U.length-1?`int ${W[ue+1]} = ${H} - ${W[ue]} * ${re}`:`index -= ${W[ue]} * ${re}`};`).join("")}\n      return ivec3(b, r, c);\n    }\n  `}(b)}\n      ${function(B){const U=F.ShapeUtil.computeStrides(B);return`\n  int getFlattenedIndex(ivec3 coords) {\n    // reverse y, z order\n    return coords.x * ${U[0]} + coords.z * ${U[1]} + coords.y;\n  }\n`}(x)}\n      ${(0,k.unpackFromChannel)()}\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0.0);\n\n        ivec3 outputCoords;\n        int rows = ${x[2]};\n        int cols = ${x[1]};\n\n        ${D}\n        ${P.output} = result;\n      }\n    `;return Object.assign(Object.assign({},d),{output:{dims:x,type:l.type,textureType:R.TextureType.packed},shaderSource:L,hasMain:!0})})(S,C,g,v)})},E.processDims3D=function(S){if(0===S.length)return[1,1,1];let C=1;for(let v=0;v<S.length-2;++v)C*=S[v];return[C,S.length>1?S[S.length-2]:1,S[S.length-1]]},E.isReshapeCheap=function(S,C){let v=!1;return v=0===S.length||0===C.length||(S.length<2||C.length<2?S[S.length-1]===C[C.length-1]:S[S.length-1]===C[C.length-1]&&S[S.length-2]===C[C.length-2]),v}},8126:(ge,E,$)=>{"use strict";Object.defineProperty(E,"__esModule",{value:!0}),E.reshape=void 0;const F=$(7273);E.reshape=(N,R)=>{const k=F.ShapeUtil.calculateReshapedDims(R[0].dims,R[1].integerData);return N.session.pack?[N.reshapePacked(R[0],k)]:[N.reshapeUnpacked(R[0],k)]}},2801:(ge,E,$)=>{"use strict";Object.defineProperty(E,"__esModule",{value:!0}),E.parseResizeAttributesV11=E.parseResizeAttributesV10=E.resize=void 0;const F=$(6757),N=$(5639),R=$(432),k=$(5614),S=$(3980),C={name:"Resize",inputNames:["A"],inputTypes:[N.TextureType.packed]};E.resize=(d,f,b)=>((0,S.validateInputs)(f,b),[d.run(Object.assign(Object.assign({},C),{cacheHint:b.cacheKey,get:()=>v(d,f,b)}),f)]),E.parseResizeAttributesV10=d=>(0,S.parseUpsampleAttributes)(d,10),E.parseResizeAttributesV11=d=>(0,S.parseUpsampleAttributes)(d,11);const v=(d,f,b)=>{const x=(0,F.getGlsl)(d.session.backend.glContext.version),[D,P]=g(f,b);if(D.every(we=>1===we)&&"tf_crop_and_resize"!==b.coordinateTransformMode)return Object.assign(Object.assign({},C),{output:{dims:P,type:f[0].type,textureType:N.TextureType.packed},hasMain:!0,shaderSource:`void main() {\n                    vec4 v = ${x.texture2D}(X, TexCoords);\n                    ${x.output} = v;\n                }`});const L=P.length;if(L<2)throw new Error(`output dimension should be at least 2, but got ${L}`);const B=P[L-2],U=P[L-1],W=f[0].dims;if(L!==W.length)throw new Error(`output dimension should match input ${W.length}, but got ${L}`);const H=W[L-2],re=W[L-1],ue=D[L-2],te=D[L-1];let se="";if("linear"!==b.mode)throw new Error(`resize (packed) does not support mode: '${b.mode}'`);switch(b.coordinateTransformMode){case"asymmetric":se="\n                    vec4 getSourceFracIndex(ivec4 coords) {\n                        return vec4(coords) / scaleWHWH;\n                    }\n                ";break;case"half_pixel":se="\n                    vec4 getSourceFracIndex(ivec4 coords) {\n                        return (vec4(coords) + 0.5) / scaleWHWH - 0.5;\n                    }\n                ";break;case"pytorch_half_pixel":se=`\n                    vec4 getSourceFracIndex(ivec4 coords) {\n                        vec4 fcoords = vec4(coords);\n                        return vec4(\n                            ${U}.0 > 1.0 ? (fcoords.x + 0.5) / scaleWHWH.x - 0.5 : 0.0,\n                            ${B}.0 > 1.0 ? (fcoords.y + 0.5) / scaleWHWH.y - 0.5 : 0.0,\n                            ${U}.0 > 1.0 ? (fcoords.z + 0.5) / scaleWHWH.z - 0.5 : 0.0,\n                            ${B}.0 > 1.0 ? (fcoords.w + 0.5) / scaleWHWH.w - 0.5 : 0.0\n                          );\n                    }\n                `;break;case"align_corners":se=`\n                    vec4 getSourceFracIndex(ivec4 coords) {\n                        vec4 resized = vec4(${U}.0 - 1.0, ${B}.0 - 1.0, ${U}.0 - 1.0,\n                            ${B}.0 - 1.0);\n                        vec4 original = vec4(${re}.0 - 1.0, ${H}.0 - 1.0, ${re}.0 - 1.0,\n                            ${H}.0 - 1.0);\n                        vec4 new_scale = original / resized;\n                        return vec4(coords) * new_scale;\n                    }\n                `;break;default:throw new Error(`resize (packed) does not support coordinateTransformMode:                                 '${b.coordinateTransformMode}'`)}const Y=(0,R.getCoordsDataType)(L),X=`\n            const vec2 inputWH = vec2(${H}.0, ${re}.0);\n            const vec4 scaleWHWH = vec4(float(${ue}), float(${te}), float(${ue}), float(${te}));\n            ${(0,k.unpackFromChannel)()}\n            ${se}\n            float getAValue(int x10, int r, int c, int d) {\n                return getChannel(getA(x10, r, c, d), vec2(c, d));\n            }\n            void main() {\n                ${Y} rc = getOutputCoords();\n\n                int batch = rc[0];\n                int depth = rc[1];\n\n                // retrieve the 4 coordinates that is used in the 4 packed output values.\n                ivec4 coords = ivec4(rc.wz, rc.w + 1, rc.z + 1);\n\n                // calculate the source index in fraction\n                vec4 sourceFrac = getSourceFracIndex(coords);\n\n                // get the lower and upper bound of the 4 values that will be packed into one texel.\n                ivec4 x00 = ivec4(max(sourceFrac.xy, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.xy)));\n                ivec4 x01 = ivec4(max(sourceFrac.xw, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.xw)));\n                ivec4 x10 = ivec4(max(sourceFrac.zy, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.zy)));\n                ivec4 x11 = ivec4(max(sourceFrac.zw, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.zw)));\n\n                bool hasNextRow = rc.w < ${B-1};\n                bool hasNextCol = rc.z < ${U-1};\n\n                // pack x00, x01, x10, x11's top-left corner into one vec4 structure\n                vec4 topLeft = vec4(\n                    getAValue(batch, depth, x00.x, x00.y),\n                    hasNextCol ? getAValue(batch, depth, x01.x, x01.y) : 0.0,\n                    hasNextRow ? getAValue(batch, depth, x10.x, x10.y) : 0.0,\n                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.x, x11.y) : 0.0);\n\n                // pack x00, x01, x10, x11's top-right corner into one vec4 structure\n                vec4 topRight = vec4(\n                    getAValue(batch, depth, x00.x, x00.w),\n                    hasNextCol ? getAValue(batch, depth, x01.x, x01.w) : 0.0,\n                    hasNextRow ? getAValue(batch, depth, x10.x, x10.w) : 0.0,\n                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.x, x11.w) : 0.0);\n\n                // pack x00, x01, x10, x11's bottom-left corner into one vec4 structure\n                vec4 bottomLeft = vec4(\n                    getAValue(batch, depth, x00.z, x00.y),\n                    hasNextCol ? getAValue(batch, depth, x01.z, x01.y) : 0.0,\n                    hasNextRow ? getAValue(batch, depth, x10.z, x10.y) : 0.0,\n                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.z, x11.y) : 0.0);\n\n                // pack x00, x01, x10, x11's bottom-right corner into one vec4 structure\n                vec4 bottomRight = vec4(\n                    getAValue(batch, depth, x00.z, x00.w),\n                    hasNextCol ? getAValue(batch, depth, x01.z, x01.w) : 0.0,\n                    hasNextRow ? getAValue(batch, depth, x10.z, x10.w) : 0.0,\n                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.z, x11.w) : 0.0);\n\n                // calculate the interpolation fraction on u and v direction\n                vec4 frac = vec4(sourceFrac) - floor(sourceFrac);\n                vec4 clampFrac = clamp(frac, vec4(0.0), vec4(1.0));\n\n                vec4 top = mix(topLeft, topRight, clampFrac.ywyw);\n                vec4 bottom = mix(bottomLeft, bottomRight, clampFrac.ywyw);\n                vec4 newValue = mix(top, bottom, clampFrac.xxzz);\n\n                ${x.output} = vec4(newValue);\n            }\n        `;return Object.assign(Object.assign({},C),{output:{dims:P,type:f[0].type,textureType:N.TextureType.packed},hasMain:!0,shaderSource:X})},g=(d,f)=>{const b=d[0].dims;let x,D=f.scales;if(0===D.length){const L=d[f.scalesInputIdx];if(L&&0!==L.size){if(d[f.sizesInputIdx])throw new Error("Only one of scales or sizes must be provided as input.");D=h(L,f.mode,f.isResize)}else{const B=d[f.sizesInputIdx];if(!B||0===B.size)throw new Error("Either scales or sizes MUST be provided as input.");x=Array.from(B.integerData),D=l(x,b,f.mode,f.isResize)}}else if(d[f.sizesInputIdx])throw new Error("Only one of scales or sizes must be provided as input.");const P=x||b.map((L,B)=>Math.floor(L*D[B]));return[D,P]},h=(d,f,b)=>{const x=Array.from(d.floatData);return(0,S.scalesValidation)(x,f,b),x},l=(d,f,b,x)=>{const D=f.length,P=new Array(D);for(let L=0,B=D;L<B;L++)if(0===f[L]){if(0!==d[L])throw new Error("Input dim is zero but required output dim is non-zero.");P[L]=1}else P[L]=d[L]/f[L];return(0,S.scalesValidation)(P,b,x),P}},565:(ge,E,$)=>{"use strict";Object.defineProperty(E,"__esModule",{value:!0}),E.shape=void 0;const F=$(9240);E.shape=(R,k)=>(N(k),[new F.Tensor([k[0].dims.length],"int32",void 0,void 0,new Int32Array(k[0].dims))]);const N=R=>{if(!R||1!==R.length)throw new Error("Shape requires 1 input.")}},2444:(ge,E,$)=>{"use strict";Object.defineProperty(E,"__esModule",{value:!0}),E.sliceV10=E.parseSliceAttributes=E.slice=void 0;const F=$(4910),N=$(6145),R=$(7273),k=$(5639),S={name:"Slice",inputNames:["A"],inputTypes:[k.TextureType.unpacked]};E.slice=(l,d,f)=>(v(d),[l.run(Object.assign(Object.assign({},S),{cacheHint:f.cacheKey,get:()=>C(l,d[0],f)}),d)]),E.parseSliceAttributes=l=>{const d=l.attributes.getInts("starts"),f=l.attributes.getInts("ends"),b=l.attributes.getInts("axes",[]);return(0,F.createAttributeWithCacheKey)({starts:d,ends:f,axes:b})};const C=(l,d,f)=>{const b=0===f.axes.length?d.dims.slice(0).map((W,H)=>H):f.axes,x=R.ShapeUtil.normalizeAxes(b,d.dims.length),D=f.starts.map((W,H)=>W>d.dims[x[H]]-1?d.dims[x[H]]:R.ShapeUtil.normalizeAxis(W,d.dims[x[H]])),P=f.ends.map((W,H)=>W>d.dims[x[H]]-1?d.dims[x[H]]:R.ShapeUtil.normalizeAxis(W,d.dims[x[H]])),L=d.dims.slice(),B=[];for(let W=0;W<x.length;W++)L[x[W]]=P[W]-D[W],D[W]>0&&B.push(`outputIdx[${x[W]}] += ${D[W]};`);const U=`\n      float process(int outputIdx[${L.length}]) {\n        ${B.join("\n      ")}\n        return _A(outputIdx);\n      }`;return Object.assign(Object.assign({},S),{output:{dims:L,type:d.type,textureType:k.TextureType.unpacked},shaderSource:U})},v=l=>{if(!l||1!==l.length)throw new Error("Slice requires 1 input.");if(-1===N.NUMBER_TYPES.indexOf(l[0].type))throw new Error("Invalid input type.")};E.sliceV10=(l,d)=>{h(d);const f=g(l,d);return[l.run(Object.assign(Object.assign({},S),{cacheHint:f.cacheKey,get:()=>C(l,d[0],f)}),[d[0]])]};const g=(l,d)=>{if(!l.session.isInitializer(d[1].dataId)||!l.session.isInitializer(d[2].dataId)||d.length>=4&&!l.session.isInitializer(d[3].dataId)||d.length>=5&&!l.session.isInitializer(d[4].dataId))throw new Error("dynamic slice attributes are not allowed");if(d.length>=5&&d[4].integerData.some(D=>1!==D))throw new Error("currently non-1 steps is not supported for Slice");const f=Array.from(d[1].integerData),b=Array.from(d[2].integerData),x=d.length>=4?Array.from(d[3].integerData):[];return{starts:f,ends:b,axes:x,cacheKey:`${x};${f};${b}`}},h=l=>{if(!l||l.length<3||l.length>5)throw new Error("Invalid input number.");if("int32"!==l[1].type||1!==l[1].dims.length)throw new Error("Invalid input type.");if("int32"!==l[2].type||1!==l[2].dims.length)throw new Error("Invalid input type.");if(l.length>=4&&("int32"!==l[3].type||1!==l[3].dims.length))throw new Error("Invalid input type.");if(l.length>=5&&("int32"!==l[4].type||1!==l[4].dims.length))throw new Error("Invalid input type.")}},815:(ge,E,$)=>{"use strict";Object.defineProperty(E,"__esModule",{value:!0}),E.softmaxV13=E.parseSoftmaxAttributesV13=E.parseSoftmaxAttributes=E.softmax=void 0;const F=$(4910),N=$(7273),R=$(6757),k=$(5639),S=$(5707),C={name:"SoftmaxComputeMax",inputNames:["A"],inputTypes:[k.TextureType.unpacked]},v={name:"SoftmaxComputeScale",inputNames:["A","Max"],inputTypes:[k.TextureType.unpacked,k.TextureType.unpacked]},g={name:"SoftMax",inputNames:["A","Max","Norm"],inputTypes:[k.TextureType.unpacked,k.TextureType.unpacked,k.TextureType.unpacked]};E.softmax=(x,D,P)=>{b(D);const L=D[0].dims.slice(),B=N.ShapeUtil.normalizeAxis(P.axis,L.length),U=N.ShapeUtil.sizeToDimension(L,B),W=N.ShapeUtil.sizeFromDimension(L,B);return h(x,D,P,U,W)},E.parseSoftmaxAttributes=x=>(0,F.createAttributeWithCacheKey)({axis:x.attributes.getInt("axis",1)}),E.parseSoftmaxAttributesV13=x=>(0,F.createAttributeWithCacheKey)({axis:x.attributes.getInt("axis",-1)}),E.softmaxV13=(x,D,P)=>{b(D);const L=D[0].dims.slice(),B=N.ShapeUtil.normalizeAxis(P.axis,L.length),U=L.length,W=B!==U-1,H=[];let re,ue=[],te=[];W&&(ue=Array.from({length:U}).map((we,K)=>K),ue[B]=U-1,ue[U-1]=B,ue.map(we=>H.push(L[we])),re=(0,F.createAttributeWithCacheKey)({perm:ue}),te=(0,S.transpose)(x,D,re));const se=N.ShapeUtil.sizeToDimension(W?H:L,U-1),Y=N.ShapeUtil.sizeFromDimension(W?H:L,U-1),X=h(x,W?te:D,P,se,Y);return W?(0,S.transpose)(x,X,re):X};const h=(x,D,P,L,B)=>{const U=l(x,D[0],L,B,[L]),W=x.run(Object.assign(Object.assign({},C),{cacheHint:P.cacheKey,get:()=>U}),D),H=d(x,D[0],L,B,U.output.dims,[L]),re=x.run(Object.assign(Object.assign({},v),{cacheHint:P.cacheKey,get:()=>H}),[D[0],W]),ue=f(x,D[0],L,B,U.output.dims,H.output.dims);return[x.run(Object.assign(Object.assign({},g),{cacheHint:P.cacheKey,get:()=>ue}),[D[0],W,re])]},l=(x,D,P,L,B)=>{const[U,W]=x.calculateTextureWidthAndHeight(D.dims,k.TextureType.unpacked),H=B.length;if(P<1||L<1)throw new Error("Logical row count N and feature count D must be greater than or equal to 1");if(1!==B.length)throw new Error("Dimensionality of the output should be 1");if(B[0]!==P)throw new Error("Shape of the output should be equal to logical row count");const re=(0,R.getGlsl)(x.session.backend.glContext.version),ue=`\n      float process(int[${H}] indices) {\n        int logical_row_start_offset = indices[0] * ${L};\n\n        float max = getColorAsFloat(${re.texture2D}(A, offsetToCoords(logical_row_start_offset, ${U},\n        ${W} )));\n        for(int i=1; i<${L}; ++i)\n        {\n          float current = getColorAsFloat(${re.texture2D}(A, offsetToCoords(logical_row_start_offset + i,\n            ${U}, ${W})));\n          if(current > max)\n          max = current;\n        }\n\n        return max;\n      }`;return Object.assign(Object.assign({},C),{output:{dims:B,type:D.type,textureType:k.TextureType.unpacked},shaderSource:ue})},d=(x,D,P,L,B,U)=>{const[W,H]=x.calculateTextureWidthAndHeight(D.dims,k.TextureType.unpacked),re=U.length;if(P<1||L<1)throw new Error("Logical row count N and feature count D must be greater than or equal to 1");if(1!==U.length)throw new Error("Dimensionality of the output should be 1");if(U[0]!==P)throw new Error("Shape of the output should be equal to logical row count");if(1!==B.length)throw new Error("Dimensionality of the intermediate results should be 1");if(B[0]!==P)throw new Error("Shape of the intermediate results should be equal to logical row count");const ue=`\n      float process(int[${re}] indices) {\n        int logical_row_start_offset = indices[0] * ${L};\n\n        float norm_factor = 0.0;\n        float max = _Max(indices);\n        for(int i=0; i<${L}; ++i)\n        {\n          norm_factor += exp(getColorAsFloat(${(0,R.getGlsl)(x.session.backend.glContext.version).texture2D}(A, offsetToCoords(logical_row_start_offset + i,\n            ${W}, ${H}))) - max);\n        }\n\n        return norm_factor;\n      }`;return Object.assign(Object.assign({},v),{output:{dims:U,type:D.type,textureType:k.TextureType.unpacked},shaderSource:ue})},f=(x,D,P,L,B,U)=>{const[W,H]=x.calculateTextureWidthAndHeight(D.dims,k.TextureType.unpacked),re=D.dims.length;if(P<1||L<1)throw new Error("Logical row count N and feature count D must be greater than or equal to 1");if(1!==B.length||1!==U.length)throw new Error("Dimensionality of the intermediate results should be 1");if(B[0]!==P||U[0]!==P)throw new Error("Shape of the intermediate results should be equal to logical row count");const ue=`\n      float process(int[${re}] indices) {\n\n      // get offset of current logical tensor index from the 2-D texture coordinates (TexCoords)\n      int offset = coordsToOffset(TexCoords, ${W}, ${H});\n\n      //determine the logical row for this index\n      int logical_row_index[1];\n      logical_row_index[0] = offset / ${L};\n\n      float norm_factor = _Norm(logical_row_index);\n\n      // avoid possible division by 0\n      // if norm_facor is 0, all elements are zero\n      // if so, return 0\n      if(norm_factor == 0.0)\n        return 0.0;\n\n      return exp(_A(indices) - _Max(logical_row_index)) / norm_factor;\n    }`;return Object.assign(Object.assign({},g),{output:{dims:D.dims,type:D.type,textureType:k.TextureType.unpacked},shaderSource:ue})},b=x=>{if(!x||1!==x.length)throw new Error("Softmax requires 1 input.");if("float32"!==x[0].type&&"float64"!==x[0].type)throw new Error("Invalid input type")}},564:(ge,E,$)=>{"use strict";Object.defineProperty(E,"__esModule",{value:!0}),E.parseSplitAttributes=E.split=void 0;const F=$(4910),N=$(7273),R=$(5639),k={name:"Split",inputNames:["A"],inputTypes:[R.TextureType.unpacked]};E.split=(g,h,l)=>{v(h);const d=N.ShapeUtil.normalizeAxis(l.axis,h[0].dims.length),f=S(g,h,d,l),b=[];for(let x=0;x<f;++x)b.push(g.run(Object.assign(Object.assign({},k),{cacheHint:`${l.cacheKey};${x}`,get:()=>C(g,h[0],l,d,x)}),h));return b},E.parseSplitAttributes=g=>{const h=g.attributes.getInt("axis",0),l=g.attributes.getInts("split",[]);return(0,F.createAttributeWithCacheKey)({axis:h,split:l,numOutputs:g.outputs.length})};const S=(g,h,l,d)=>{const[,f]=N.SplitUtil.splitShape(h[0].dims,l,d.split,d.numOutputs);return f.length},C=(g,h,l,d,f)=>{const[b,x]=N.SplitUtil.splitShape(h.dims,d,l.split,l.numOutputs),P=b[f],L=`\n      float process(int indices[${P.length}]) {\n        indices[${d}] += ${x[f]};\n        return _A(indices);\n      }\n    `;return Object.assign(Object.assign({},k),{cacheHint:`${l.cacheKey}:${f}`,output:{dims:P,type:h.type,textureType:R.TextureType.unpacked},shaderSource:L})},v=g=>{if(!g||1!==g.length)throw new Error("Split requires one input.");if("int8"!==g[0].type&&"uint8"!==g[0].type&&"int16"!==g[0].type&&"uint16"!==g[0].type&&"int32"!==g[0].type&&"uint32"!==g[0].type&&"float32"!==g[0].type&&"float64"!==g[0].type&&"bool"!==g[0].type)throw new Error("Invalid input type.")}},5416:(ge,E,$)=>{"use strict";Object.defineProperty(E,"__esModule",{value:!0}),E.parseSqueezeAttributes=E.squeezeV13=E.squeeze=void 0;const F=$(7273);E.squeeze=(k,S,C)=>{N(S);const v=F.ShapeUtil.squeezeShape(S[0].dims,C);return[k.reshapeUnpacked(S[0],v)]},E.squeezeV13=(k,S)=>(R(S),(0,E.squeeze)(k,[S[0]],Array.from(S[1].integerData))),E.parseSqueezeAttributes=k=>k.attributes.getInts("axes");const N=k=>{if(!k||1!==k.length)throw new Error("Squeeze requires 1 input.");if("string"===k[0].type)throw new Error("invalid input tensor types.")},R=k=>{if(!k||2!==k.length)throw new Error("Squeeze requires 2 inputs.");if("int32"!==k[1].type)throw new Error("Invalid input type.")}},1240:(ge,E,$)=>{"use strict";Object.defineProperty(E,"__esModule",{value:!0}),E.sum=void 0;const F=$(6757),N=$(5639);E.sum=(S,C)=>{k(C);const v={name:"Sum",inputNames:C.map((g,h)=>`X${h}`),inputTypes:new Array(C.length).fill(N.TextureType.unpacked)};return[S.run(Object.assign(Object.assign({},v),{get:()=>R(S,C,v)}),C)]};const R=(S,C,v)=>{const g=(0,F.getGlsl)(S.session.backend.glContext.version),h=C[0].dims.slice(),l=`\n      void main() {\n        vec4 result = ${C.map((d,f)=>`${g.texture2D}(X${f},TexCoords)`).join(" + ")};\n        ${g.output} = result;\n      }\n    `;return Object.assign(Object.assign({},v),{output:{dims:h,type:C[0].type,textureType:N.TextureType.unpacked},hasMain:!0,shaderSource:l})},k=S=>{if(!S||0===S.length)throw new Error("Sum requires inputs.");const C=S[0].dims.length;for(let v=1;v<S.length;v++){if(C!==S[v].dims.length)throw new Error("Input shapes are mismatched.");for(let g=0;g<C;g++)if(S[0].dims[g]!==S[v].dims[g])throw new Error("Input shapes are not matched.")}if("float32"!==S[0].type&&"float64"!==S[0].type)throw new Error("Invalid input type.");for(let v=1;v<S.length;v++)if(S[0].type!==S[v].type)throw new Error("Input types are not matched.")}},5944:(ge,E,$)=>{"use strict";Object.defineProperty(E,"__esModule",{value:!0}),E.tile=void 0;const F=$(6145),N=$(5639);E.tile=(S,C)=>{k(C);const v={name:"Tile",inputNames:["A"],inputTypes:[N.TextureType.unpacked]};return[S.run(Object.assign(Object.assign({},v),{get:()=>R(S,C,v)}),C)]};const R=(S,C,v)=>{const g=C[0].dims.slice(),h=new Array(g.length),l=[];for(let b=0;b<g.length;b++)h[b]=g[b]*C[1].numberData[b],l.push(`inputIdx[${b}] = int(mod(float(outputIdx[${b}]), ${g[b]}.));`);const d=h.length,f=`\n      float process(int outputIdx[${d}]) {\n        int inputIdx[${d}];\n        ${l.join("\n")}\n        return _A(inputIdx);\n      }\n    `;return Object.assign(Object.assign({},v),{output:{dims:h,type:C[0].type,textureType:N.TextureType.unpacked},shaderSource:f})},k=S=>{if(!S||2!==S.length)throw new Error("Tile requires 2 input.");if(1!==S[1].dims.length)throw new Error("The second input shape must 1 dimension.");if(S[1].dims[0]!==S[0].dims.length)throw new Error("Invalid input shape.");if(-1===F.NUMBER_TYPES.indexOf(S[0].type))throw new Error("Invalid input type.");if("int32"!==S[1].type&&"int16"!==S[1].type)throw new Error("Invalid repeat type.")}},5707:(ge,E,$)=>{"use strict";Object.defineProperty(E,"__esModule",{value:!0}),E.parseTransposeAttributes=E.transpose=void 0;const F=$(4910),N=$(7273),R=$(5639),k={name:"Transpose",inputNames:["A"],inputTypes:[R.TextureType.unpacked]};E.transpose=(l,d,f)=>(h(d),[l.run(Object.assign(Object.assign({},k),{cacheHint:f.cacheKey,get:()=>S(l,d[0],f.perm)}),d)]),E.parseTransposeAttributes=l=>(0,F.createAttributeWithCacheKey)({perm:l.attributes.getInts("perm",[])});const S=(l,d,f)=>{const b=d.dims;f=C(b,f);const x=v(b,f),D=b.length,P=`\n      ${g("perm",f,D)}\n      float process(int indices[${D}]) {\n        int a[${D}];\n        perm(a, indices);\n        return _A(a);\n      }`;return Object.assign(Object.assign({},k),{output:{dims:x,type:d.type,textureType:R.TextureType.unpacked},shaderSource:P})},C=(l,d)=>(d&&d.length!==l.length&&(d=[...l.keys()].reverse()),d),v=(l,d)=>(d=C(l,d),N.ShapeUtil.sortBasedOnPerm(l,d)),g=(l,d,f)=>{const b=[];b.push(`void ${l}(out int a[${f}], int src[${f}]) {`);for(let x=0;x<f;++x)b.push(`\ta[${d[x]}]=src[${x}];`);return b.push("\t}"),b.join("\n")},h=l=>{if(!l||1!==l.length)throw new Error("Transpose requires 1 input.");if("float32"!==l[0].type&&"float64"!==l[0].type)throw new Error("input should be float tensor")}},2488:(ge,E,$)=>{"use strict";Object.defineProperty(E,"__esModule",{value:!0}),E.encodeAsUint8=void 0;const F=$(6757),N=$(5639);E.encodeAsUint8=(R,k)=>{const S=k.shape,C=(0,F.getGlsl)(R.session.backend.glContext.version);return R.executeProgram({name:"Uint8Encode",inputTypes:[N.TextureType.unpacked],inputNames:["X"],output:{dims:S,type:k.tensor.type,textureType:N.TextureType.downloadUint8AsFloat},shaderSource:`\n    const float FLOAT_MAX = 1.70141184e38;\n    const float FLOAT_MIN = 1.17549435e-38;\n\n    bool isNaN(float val) {\n      return (val < 1.0 || 0.0 < val || val == 0.0) ? false : true;\n    }\n\n    highp vec4 encodeAsUint8(highp float v) {\n      if (isNaN(v)) {\n        return vec4(255, 255, 255, 255);\n      }\n\n      highp float av = abs(v);\n\n      if(av < FLOAT_MIN) {\n        return vec4(0.0, 0.0, 0.0, 0.0);\n      } else if(v > FLOAT_MAX) {\n        return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;\n      } else if(v < -FLOAT_MAX) {\n        return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;\n      }\n\n      highp vec4 c = vec4(0,0,0,0);\n\n      highp float e = floor(log2(av));\n      highp float m = exp2(fract(log2(av))) - 1.0;\n\n      c[2] = floor(128.0 * m);\n      m -= c[2] / 128.0;\n      c[1] = floor(32768.0 * m);\n      m -= c[1] / 32768.0;\n      c[0] = floor(8388608.0 * m);\n\n      highp float ebias = e + 127.0;\n      c[3] = floor(ebias / 2.0);\n      ebias -= c[3] * 2.0;\n      c[2] += floor(ebias) * 128.0;\n\n      c[3] += 128.0 * step(0.0, -v);\n\n      return c / 255.0;\n    }\n\n    void main() {\n      float value = ${C.texture2D}(X,TexCoords).r;\n      ${C.output} = encodeAsUint8(value);\n    }`,hasMain:!0},[k.tensor])}},9087:(ge,E,$)=>{"use strict";Object.defineProperty(E,"__esModule",{value:!0}),E.tanh=E.tan=E.sqrt=E.sin=E.sigmoid=E.relu=E.not=E.neg=E.log=E.parseLeakyReluAttributes=E.leakyRelu=E.identity=E.floor=E.exp=E.parseEluAttributes=E.elu=E.cos=E.ceil=E.clipV11=E.parseClipAttributes=E.clip=E.atan=E.asin=E.acos=E.abs=E.glslTanh=E.glslTan=E.glslSqrt=E.glslSigmoid=E.glslRelu=E.glslSin=E.glslNot=E.glslNeg=E.glslLog=E.glslLeakyRelu=E.glslIdentity=E.glslClip=E.glslFloor=E.glslExp=E.glslElu=E.glslCos=E.glslCeil=E.glslAtan=E.glslAsin=E.glslAcos=E.glslAbs=void 0;const F=$(4910),N=$(7273),R=$(1997),k=$(6757),S=$(5639);function C(){return X("abs")}function v(){return X("acos")}function g(){return X("asin")}function h(){return X("atan")}function l(){return X("ceil")}function d(){return X("cos")}function f(ie){const ce="elu";return{body:`\n  const float alpha = float(${ie});\n\n  float ${ce}_(float a) {\n    return a >= 0.0 ? a: (exp(a) - 1.0) * alpha;\n  }\n  vec4 ${ce}_(vec4 v) {\n    return vec4(${ce}_(v.x), ${ce}_(v.y), ${ce}_(v.z), ${ce}_(v.w));\n  }\n  `,name:ce,type:R.FunctionType.ValueBased}}function b(){return X("exp")}function x(){return X("floor")}function D(ie,ce){const qe="clip";return{body:`\n  const float min = float(${ie});\n  const float max = float(${ce});\n\n  float ${qe}_(float a) {\n    return clamp(a, min, max);\n  }\n  vec4 ${qe}_(vec4 v) {\n    return clamp(v, min, max);\n  }\n  `,name:qe,type:R.FunctionType.ValueBased}}function P(){const ie="indentity";return{body:`\n  float ${ie}_(float a) {\n    return a;\n  }\n  vec4 ${ie}_(vec4 v) {\n    return v;\n  }\n  `,name:ie,type:R.FunctionType.ValueBased}}function L(ie){const ce="leakyRelu";return{body:`\n  const float alpha = float(${ie});\n\n  float ${ce}_(float a) {\n    return a < 0.0 ? a * alpha : a;\n  }\n  vec4 ${ce}_(vec4 v) {\n    return vec4(${ce}_(v.x), ${ce}_(v.y), ${ce}_(v.z), ${ce}_(v.w));\n  }\n  `,name:ce,type:R.FunctionType.ValueBased}}function B(){return X("log")}function U(){return{body:"\n  float neg_(float a) {\n    return -a;\n  }\n  vec4 neg_(vec4 v) {\n    return -v;\n  }\n  ",name:"neg",type:R.FunctionType.ValueBased}}function W(){const ie="not";return{body:`\n  float ${ie}_(float a) {\n    return float( ! bool(a) );\n  }\n  bool ${ie}_(bool a) {\n    return !a;\n  }\n  vec4 ${ie}_(vec4 v) {\n    return vec4(!bool(v.x), !bool(v.y), !bool(v.z), !bool(v.w));\n  }\n  bvec4 ${ie}_(bvec4 v) {\n    return bvec4(!v.x, !v.y, !v.z, !v.w);\n  }\n  `,name:ie,type:R.FunctionType.ValueBased}}function H(){return X("sin")}function re(){const ie="relu";return{body:`\n  float ${ie}_(float a) {\n    return max( a, 0.0 );\n  }\n  vec4 ${ie}_(vec4 v) {\n    return max( v, 0.0 );\n  }\n  `,name:ie,type:R.FunctionType.ValueBased}}function ue(){const ie="sigmoid";return{body:`\n  float ${ie}_(float a) {\n    return 1.0 / (1.0 + exp(-a));\n  }\n  vec4 ${ie}_(vec4 v) {\n    return 1.0 / (1.0 + exp(-v));\n  }\n  `,name:ie,type:R.FunctionType.ValueBased}}function te(){return X("sqrt")}function se(){return X("tan")}function Y(){const ie="tanh";return{body:`\n  float ${ie}_(float a) {\n    a = clamp(a, -10., 10.);\n    a = exp(2.*a);\n    return (a - 1.) / (a + 1.);\n  }\n  vec4 ${ie}_(vec4 v) {\n    v = clamp(v, -10., 10.);\n    v = exp(2.*v);\n    return (v - 1.) / (v + 1.);\n  }\n  `,name:ie,type:R.FunctionType.ValueBased}}function X(ie){return{body:`\n  float ${ie}_(float a) {\n    return ${ie}(a);\n  }\n  vec4 ${ie}_(vec4 v) {\n    return ${ie}(v);\n  }\n  `,name:ie,type:R.FunctionType.ValueBased}}E.glslAbs=C,E.glslAcos=v,E.glslAsin=g,E.glslAtan=h,E.glslCeil=l,E.glslCos=d,E.glslElu=f,E.glslExp=b,E.glslFloor=x,E.glslClip=D,E.glslIdentity=P,E.glslLeakyRelu=L,E.glslLog=B,E.glslNeg=U,E.glslNot=W,E.glslSin=H,E.glslRelu=re,E.glslSigmoid=ue,E.glslSqrt=te,E.glslTan=se,E.glslTanh=Y;const we=(ie,ce,qe,Be)=>{const rt={name:qe.name,inputTypes:[ie.session.pack?S.TextureType.packed:S.TextureType.unpacked],inputNames:["A"],cacheHint:Be};return Object.assign(Object.assign({},rt),{get:()=>((ot,bt,wt,Mt)=>{const un=ot.session.pack?S.TextureType.packed:S.TextureType.unpacked,_n=(0,k.getGlsl)(ot.session.backend.glContext.version);return Object.assign(Object.assign({},bt),{output:{dims:wt.dims,type:wt.type,textureType:un},shaderSource:`\n     ${Mt.body}\n     void main() {\n       vec4 v = ${_n.texture2D}(A, TexCoords);\n       v = ${Mt.name}_(v);\n       ${_n.output} = v;\n     }\n     `,hasMain:!0})})(ie,rt,ce,qe)})};E.abs=(ie,ce)=>[ie.run(we(ie,ce[0],C()),ce)],E.acos=(ie,ce)=>[ie.run(we(ie,ce[0],v()),ce)],E.asin=(ie,ce)=>[ie.run(we(ie,ce[0],g()),ce)],E.atan=(ie,ce)=>[ie.run(we(ie,ce[0],h()),ce)],E.clip=(ie,ce,qe)=>[ie.run(we(ie,ce[0],D(qe.min,qe.max),qe.cacheKey),ce)],E.parseClipAttributes=ie=>(0,F.createAttributeWithCacheKey)({min:ie.attributes.getFloat("min",N.MIN_CLIP),max:ie.attributes.getFloat("max",N.MAX_CLIP)}),E.clipV11=(ie,ce)=>{const qe=K(ie,ce);return(0,E.clip)(ie,[ce[0]],qe)};const K=(ie,ce)=>{if(ce.length>=3&&(!ie.session.isInitializer(ce[1].dataId)||!ie.session.isInitializer(ce[2].dataId)))throw new Error("dynamic clip attributes are not allowed");return(0,F.createAttributeWithCacheKey)({min:ce.length>=3?ce[1].numberData[0]:N.MIN_CLIP,max:ce.length>=3?ce[2].numberData[0]:N.MAX_CLIP})};E.ceil=(ie,ce)=>[ie.run(we(ie,ce[0],l()),ce)],E.cos=(ie,ce)=>[ie.run(we(ie,ce[0],d()),ce)],E.elu=(ie,ce,qe)=>[ie.run(we(ie,ce[0],f(qe.alpha),qe.cacheKey),ce)],E.parseEluAttributes=ie=>(0,F.createAttributeWithCacheKey)({alpha:ie.attributes.getFloat("alpha",1)}),E.exp=(ie,ce)=>[ie.run(we(ie,ce[0],b()),ce)],E.floor=(ie,ce)=>[ie.run(we(ie,ce[0],x()),ce)],E.identity=(ie,ce)=>[ie.run(we(ie,ce[0],P()),ce)],E.leakyRelu=(ie,ce,qe)=>[ie.run(we(ie,ce[0],L(qe.alpha),qe.cacheKey),ce)],E.parseLeakyReluAttributes=ie=>(0,F.createAttributeWithCacheKey)({alpha:ie.attributes.getFloat("alpha",.01)}),E.log=(ie,ce)=>[ie.run(we(ie,ce[0],B()),ce)],E.neg=(ie,ce)=>[ie.run(we(ie,ce[0],U()),ce)],E.not=(ie,ce)=>[ie.run(we(ie,ce[0],W()),ce)],E.relu=(ie,ce)=>[ie.run(we(ie,ce[0],re()),ce)],E.sigmoid=(ie,ce)=>[ie.run(we(ie,ce[0],ue()),ce)],E.sin=(ie,ce)=>[ie.run(we(ie,ce[0],H()),ce)],E.sqrt=(ie,ce)=>[ie.run(we(ie,ce[0],te()),ce)],E.tan=(ie,ce)=>[ie.run(we(ie,ce[0],se()),ce)],E.tanh=(ie,ce)=>[ie.run(we(ie,ce[0],Y()),ce)]},540:(ge,E,$)=>{"use strict";Object.defineProperty(E,"__esModule",{value:!0}),E.createUnpackProgramInfoLoader=E.createUnpackProgramInfo=void 0;const F=$(6757),N=$(5639),R=$(432),k=$(5614),S={name:"unpack",inputNames:["A"],inputTypes:[N.TextureType.packed]};E.createUnpackProgramInfo=(C,v)=>{const g=v.dims.length,h=(0,k.getChannels)("rc",g),l=h.slice(-2),d=(0,R.getCoordsDataType)(g),f=(0,k.unpackFromChannel)(),b=0===v.dims.length?"":function(P,L){if(1===P)return"rc";let B="";for(let U=0;U<P;U++)B+=L[U],U<P-1&&(B+=",");return B}(g,h),x=g<=1?"rc":`vec2(${l.join(",")})`,D=`\n    ${f}\n    void main() {\n      ${d} rc = getOutputCoords();\n\n       // Sample the texture with the coords to get the rgba channel value.\n       vec4 packedInput = getA(${b});\n\n       ${(0,F.getGlsl)(C.session.backend.glContext.version).output} = vec4(getChannel(packedInput, ${x}), 0, 0, 0);\n     }\n   `;return Object.assign(Object.assign({},S),{hasMain:!0,output:{dims:v.dims,type:v.type,textureType:N.TextureType.unpacked},shaderSource:D})},E.createUnpackProgramInfoLoader=(C,v)=>Object.assign(Object.assign({},S),{get:()=>(0,E.createUnpackProgramInfo)(C,v)})},7862:(ge,E,$)=>{"use strict";Object.defineProperty(E,"__esModule",{value:!0}),E.parseUnsqueezeAttributes=E.unsqueezeV13=E.unsqueeze=void 0;const F=$(7273);E.unsqueeze=(k,S,C)=>{N(S);const v=F.ShapeUtil.unsqueezeShape(S[0].dims,C);return[k.reshapeUnpacked(S[0],v)]},E.unsqueezeV13=(k,S)=>(R(S),(0,E.unsqueeze)(k,[S[0]],Array.from(S[1].integerData))),E.parseUnsqueezeAttributes=k=>k.attributes.getInts("axes");const N=k=>{if(!k||1!==k.length)throw new Error("Unsqueeze requires 1 input.");if("string"===k[0].type)throw new Error("invalid input tensor types.")},R=k=>{if(!k||2!==k.length)throw new Error("Unsqueeze requires 2 inputs.");if("int32"!==k[1].type)throw new Error("Invalid input type.")}},3980:(ge,E,$)=>{"use strict";Object.defineProperty(E,"__esModule",{value:!0}),E.scalesValidation=E.validateInputs=E.parseUpsampleAttributes=E.parseUpsampleAttributesV9=E.parseUpsampleAttributesV7=E.upsample=void 0;const F=$(4910),N=$(6757),R=$(5639),k={name:"Upsample",inputNames:["X"],inputTypes:[R.TextureType.unpacked]};E.upsample=(C,v,g)=>((0,E.validateInputs)(v,g),[C.run(Object.assign(Object.assign({},k),{cacheHint:g.cacheKey,get:()=>S(C,v,g)}),v)]),E.parseUpsampleAttributesV7=C=>(0,E.parseUpsampleAttributes)(C,7),E.parseUpsampleAttributesV9=C=>(0,E.parseUpsampleAttributes)(C,9),E.parseUpsampleAttributes=(C,v)=>{const g=v>=10,h=C.attributes.getString("mode","nearest");if("nearest"!==h&&"linear"!==h&&(v<11||"cubic"!==h))throw new Error(`unrecognized mode: ${h}`);let l=[];v<9&&(l=C.attributes.getFloats("scales"),(0,E.scalesValidation)(l,h,g));const d=C.attributes.getFloat("extrapolation_value",0),f=v>10?C.attributes.getString("coordinate_transformation_mode","half_pixel"):"asymmetric";if(-1===["asymmetric","pytorch_half_pixel","tf_half_pixel_for_nn","align_corners","tf_crop_and_resize","half_pixel"].indexOf(f))throw new Error(`coordinate_transform_mode '${f}' is not supported`);const b="tf_crop_and_resize"===f,x=b,D="nearest"===h&&v>=11?C.attributes.getString("nearest_mode","round_prefer_floor"):"";if(-1===["round_prefer_floor","round_prefer_ceil","floor","ceil",""].indexOf(D))throw new Error(`nearest_mode '${D}' is not supported`);const P=C.attributes.getFloat("cubic_coeff_a",-.75),L=0!==C.attributes.getInt("exclude_outside",0);if(L&&"cubic"!==h)throw new Error("exclude_outside can be set to 1 only when mode is CUBIC.");let U=0,W=0,H=0;return v>10?C.inputs.length>2?(U=1,W=2,H=3):(W=1,H=2):9===v&&(W=1),(0,F.createAttributeWithCacheKey)({opset:v,isResize:g,mode:h,scales:l,extrapolationValue:d,coordinateTransformMode:f,useExtrapolation:x,needRoiInput:b,nearestMode:D,cubicCoefficientA:P,excludeOutside:L,useNearest2xOptimization:v<11||"nearest"===h&&"asymmetric"===f&&"floor"===D,roiInputIdx:U,scalesInputIdx:W,sizesInputIdx:H})};const S=(C,v,g)=>{const h=(0,N.getGlsl)(C.session.backend.glContext.version),[l,d]=C.calculateTextureWidthAndHeight(v[0].dims,R.TextureType.unpacked),f=v[0].dims.map((H,re)=>Math.floor(H*g.scales[re])),[b,x]=C.calculateTextureWidthAndHeight(f,R.TextureType.unpacked),D=f.length,P=new Array(D),L=new Array(D);let B=`\n      int output_pitches[${D}];\n      int input_pitches[${D}];\n      `;for(let H=D-1;H>=0;H--)P[H]=H===D-1?1:P[H+1]*f[H+1],L[H]=H===D-1?1:L[H+1]*v[0].dims[H+1],B+=`\n        output_pitches[${H}] = ${P[H]};\n        input_pitches[${H}] = ${L[H]};\n        `;const U=`\n      float getInputFloat(int index) {\n        vec2 coords = offsetToCoords(index, ${l}, ${d});\n        float value = getColorAsFloat(${h.texture2D}(X, coords));\n        return value;\n      }\n      `,W="nearest"===g.mode?`\n    ${U}\n    float process(int indices[${D}]) {\n      int input_index = 0;\n      int output_index = coordsToOffset(TexCoords, ${b}, ${x});\n\n      ${B}\n\n      int d, m;\n      for (int dim = 0; dim < ${D}; ++dim) {\n        d = output_index / output_pitches[dim];\n        m = output_index - d * output_pitches[dim];\n        output_index = m;\n\n        if (scales[dim] != 1 && d > 0) {\n          int d2 = d / scales[dim];\n          m = d - d2 * scales[dim];\n          d = d2;\n        }\n        input_index += input_pitches[dim] * d;\n      }\n\n      return getInputFloat(input_index);\n    }`:4===D?`\n    ${U}\n    float process(int indices[4]) {\n      int input_index = 0;\n      int output_index = coordsToOffset(TexCoords, ${b}, ${x});\n\n      ${B}\n\n      int m;\n      int index_of_dim0, index_of_dim1, index_of_dim2, index_of_dim3;\n      index_of_dim0 = output_index / output_pitches[0];\n      m = output_index - index_of_dim0 * output_pitches[0];\n      index_of_dim1 = m / output_pitches[1];\n      m = m - index_of_dim1 * output_pitches[1];\n      index_of_dim2 = m / output_pitches[2];\n      m = m - index_of_dim2 * output_pitches[2];\n      index_of_dim3 = m;\n\n      int index_of_input_dim2, index_of_input_dim3, x_offset, y_offset;\n      index_of_input_dim2 = index_of_dim2 / scales[2];\n      y_offset = index_of_dim2 - index_of_input_dim2 * scales[2];\n      index_of_input_dim3 = index_of_dim3 / scales[3];\n      x_offset = index_of_dim3 - index_of_input_dim3 * scales[3];\n\n      input_index = index_of_dim0 * input_pitches[0] +\n            index_of_dim1 * input_pitches[1] +\n            index_of_input_dim2 * input_pitches[2] +\n            index_of_input_dim3;\n\n      float x00 = getInputFloat(input_index);\n      float x10, x01, x11;\n\n      bool end_of_dim2 = false;\n      if (index_of_input_dim2 == (${v[0].dims[2]} - 1)) {\n        // It's the end in dimension 2\n        x01 = x00;\n        end_of_dim2 = true;\n      } else {\n        x01 = getInputFloat(input_index + input_pitches[2]);\n      }\n\n      if (index_of_input_dim3 == (input_pitches[2] - 1)) {\n        // It's the end in dimension 3\n        x10 = x00;\n        x11 = x01;\n      }\n      else {\n        x10 = getInputFloat(input_index + 1);\n        x11 = end_of_dim2 ? x10 : getInputFloat(input_index + input_pitches[2] + 1);\n      }\n\n      float y0 = x00 + float(y_offset) * (x01 - x00) / float(scales[2]);\n      float y1 = x10 + float(y_offset) * (x11 - x10) / float(scales[2]);\n      return y0 + float(x_offset) * (y1 - y0) / float(scales[3]);\n    }`:`\n    ${U}\n    float process(int indices[2]) {\n      int input_index = 0;\n      int output_index = coordsToOffset(TexCoords, ${b}, ${x});\n\n      ${B}\n\n      int m;\n      int index_of_dim0, index_of_dim1;\n      index_of_dim0 = output_index / output_pitches[0];\n      m = output_index - index_of_dim0 * output_pitches[0];\n      index_of_dim1 = m;\n\n      int index_of_input_dim0, index_of_input_dim1, x_offset, y_offset;\n      index_of_input_dim0 = index_of_dim0 / scales[0];\n      y_offset = index_of_dim0 - index_of_input_dim0 * scales[0];\n      index_of_input_dim1 = index_of_dim1 / scales[1];\n      x_offset = index_of_dim1 - index_of_input_dim1 * scales[1];\n\n      input_index = index_of_input_dim0 * input_pitches[0] + index_of_input_dim1;\n\n      float x00 = getInputFloat(input_index);\n      float x10, x01, x11;\n\n      bool end_of_dim0 = false;\n      if (index_of_input_dim0 == (${v[0].dims[0]} - 1)) {\n        // It's the end in dimension 0\n        x01 = x00;\n        end_of_dim0 = true;\n      } else {\n        x01 = getInputFloat(input_index + input_pitches[0]);\n      }\n\n      if (index_of_input_dim1 == (input_pitches[0] - 1)) {\n        // It's the end in dimension 1\n        x10 = x00;\n        x11 = x01;\n      }\n      else {\n        x10 = getInputFloat(input_index + 1);\n        x11 = end_of_dim0 ? x10 : getInputFloat(input_index + input_pitches[0] + 1);\n      }\n\n      float y0 = x00 + float(y_offset) * (x01 - x00) / float(scales[0]);\n      float y1 = x10 + float(y_offset) * (x11 - x10) / float(scales[0]);\n      return y0 + float(x_offset) * (y1 - y0) / float(scales[1]);\n    }`;return Object.assign(Object.assign({},k),{output:{dims:f,type:v[0].type,textureType:R.TextureType.unpacked},shaderSource:W,variables:[{name:"scales",type:"int",arrayLength:g.scales.length,data:g.scales.map(H=>Math.ceil(H))}]})};E.validateInputs=(C,v)=>{if(!C||v.opset<9&&1!==C.length||v.opset>=9&&v.opset<11&&2!==C.length||v.opset>=11&&C.length<2)throw new Error("invalid inputs.");if(v.scales.length>0&&C[0].dims.length!==v.scales.length)throw new Error("Invalid input shape.");if("string"===C[0].type)throw new Error("Invalid input tensor types.")},E.scalesValidation=(C,v,g)=>{if(g){for(const h of C)if(h<=0)throw new Error("Scale value should be greater than 0.")}else for(const h of C)if(h<1)throw new Error("Scale value should be greater than or equal to 1.");if(!("linear"!==v&&"cubic"!==v||2===C.length||4===C.length&&1===C[0]&&1===C[1]))throw new Error(`'Linear' mode and 'Cubic' mode only support 2-D inputs ('Bilinear', 'Bicubic')         or 4-D inputs with the corresponding outermost 2 scale values being 1         in the ${g?"Resize":"Upsample"} opeartor.`)}},2757:(ge,E,$)=>{"use strict";Object.defineProperty(E,"__esModule",{value:!0}),E.ProgramManager=void 0;const F=$(2235),N=$(1315),R=$(8897),k=$(6757);E.ProgramManager=class{constructor(S,C,v){this.profiler=S,this.glContext=C,this.textureLayoutStrategy=v,this.repo=new Map,this.attributesBound=!1}getArtifact(S){return this.repo.get(S)}setArtifact(S,C){this.repo.set(S,C)}run(S,C,v){var g;this.profiler.event("op",`ProgramManager.run ${null!==(g=S.programInfo.name)&&void 0!==g?g:"unknown kernel"}`,()=>{var h;this.glContext.gl.useProgram(S.program);try{this.bindOutput(v),this.attributesBound||this.bindAttributes(S.attribLocations),this.bindUniforms(S.uniformLocations,null!==(h=S.programInfo.variables)&&void 0!==h?h:[],C)}catch(f){throw N.Logger.error("ProgramManager",S.programInfo.shaderSource),f}this.profiler.event("backend","GlContext.draw()",()=>{this.glContext.draw()})},this.glContext)}dispose(){this.vertexShader&&this.glContext.deleteShader(this.vertexShader),this.repo.forEach(S=>this.glContext.deleteProgram(S.program))}build(S,C,v){return this.profiler.event("backend","ProgramManager.build",()=>{const g=new R.GlslPreprocessor(this.glContext,S,C,v),h=g.preprocess(),l=this.compile(h);return{programInfo:S,program:l,uniformLocations:this.getUniformLocations(l,g.context.programInfo.inputNames,g.context.programInfo.variables),attribLocations:this.getAttribLocations(l)}})}compile(S){if(!this.vertexShader){N.Logger.verbose("ProrgramManager","Compiling and caching Vertex shader for the first time");const g=(0,k.getVertexShaderSource)(this.glContext.version);this.vertexShader=this.glContext.compileShader(g,this.glContext.gl.VERTEX_SHADER)}F.env.debug&&N.Logger.verbose("ProrgramManager",`FragShader:\n${S}\n`);const C=this.glContext.compileShader(S,this.glContext.gl.FRAGMENT_SHADER),v=this.glContext.createProgram(this.vertexShader,C);return this.glContext.deleteShader(C),v}bindOutput(S){const C=S.width,v=S.height;N.Logger.verbose("ProrgramManager",`Binding output texture to Framebuffer: w/h=${C}/${v}, shape=${S.shape}, type=${S.tensor.type}`),this.glContext.attachFramebuffer(S.texture,C,v)}bindAttributes(S){this.glContext.setVertexAttributes(S.position,S.textureCoord),this.attributesBound=!0}bindUniforms(S,C,v){var g;const h=this.glContext.gl;let l=0;for(const{name:d,type:f,location:b,arrayLength:x}of S){const D=null===(g=C.find(P=>P.name===d))||void 0===g?void 0:g.data;if("sampler2D"!==f&&!D)throw new Error(`variable '${d}' does not have data defined in program info`);switch(f){case"sampler2D":this.bindTexture(v[l],b,l),l++;break;case"float":x?h.uniform1fv(b,D):h.uniform1f(b,D);break;case"int":x?h.uniform1iv(b,D):h.uniform1i(b,D);break;default:throw new Error(`Uniform not implemented: ${f}`)}}}bindTexture(S,C,v){this.glContext.bindTextureToUniform(S.texture,v,C)}getAttribLocations(S){return{position:this.getAttribLocation(S,"position"),textureCoord:this.getAttribLocation(S,"textureCoord")}}getUniformLocations(S,C,v){const g=[];if(C)for(const h of C)g.push({name:h,type:"sampler2D",location:this.getUniformLocation(S,h)});if(v)for(const h of v)g.push(Object.assign(Object.assign({},h),{location:this.getUniformLocation(S,h.name)}));return g}getUniformLocation(S,C){const v=this.glContext.gl.getUniformLocation(S,C);if(null===v)throw new Error(`Uniform ${C} not found.`);return v}getAttribLocation(S,C){return this.glContext.gl.getAttribLocation(S,C)}}},2171:(ge,E,$)=>{"use strict";Object.defineProperty(E,"__esModule",{value:!0}),E.WebGLSessionHandler=void 0;const F=$(1315),N=$(5881),R=$(7860),k=$(4110),S=$(2757),C=$(7618),v=$(5243);E.WebGLSessionHandler=class{constructor(g,h){this.backend=g,this.context=h,this.layoutStrategy=new C.PreferLogicalStrategy(g.glContext.maxTextureSize),this.programManager=new S.ProgramManager(this.context.profiler,g.glContext,this.layoutStrategy),this.textureManager=new v.TextureManager(g.glContext,this.layoutStrategy,this.context.profiler,{reuseTextures:"full"===g.textureCacheMode}),this.packedTextureDataCache=new Map,this.unpackedTextureDataCache=new Map,this.pack=g.pack,this.pack2unpackMap=new Map,this.unpack2packMap=new Map}createInferenceHandler(){return new R.WebGLInferenceHandler(this)}onGraphInitialized(g){const h=g.getValues().filter(l=>-1===l.from&&l.tensor).map(l=>l.tensor.dataId);this.initializers=new Set(h)}isInitializer(g){return!!this.initializers&&this.initializers.has(g)}addInitializer(g){this.initializers.add(g)}getTextureData(g,h){return h?this.packedTextureDataCache.get(g):this.unpackedTextureDataCache.get(g)}setTextureData(g,h,l=!1){F.Logger.verbose("WebGLSessionHandler","Storing Texture data in cache"),l?this.packedTextureDataCache.set(g,h):this.unpackedTextureDataCache.set(g,h)}dispose(){this.programManager.dispose(),this.textureManager.clearActiveTextures(),this.packedTextureDataCache.forEach(g=>this.textureManager.releaseTexture(g,!0)),this.packedTextureDataCache=new Map,this.unpackedTextureDataCache.forEach(g=>this.textureManager.releaseTexture(g,!0)),this.unpackedTextureDataCache=new Map}resolve(g,h,l){const d=(0,N.resolveOperator)(g,h,k.WEBGL_OP_RESOLVE_RULES);return{impl:d.opImpl,context:d.opInit?d.opInit(g,l):g}}}},9622:(ge,E,$)=>{"use strict";Object.defineProperty(E,"__esModule",{value:!0}),E.Uint8DataEncoder=E.RGBAFloatDataEncoder=E.RedFloat32DataEncoder=void 0;const F=$(1315);E.RedFloat32DataEncoder=class{constructor(N,R=1){if(1===R)this.internalFormat=N.R32F,this.format=N.RED,this.textureType=N.FLOAT,this.channelSize=R;else{if(4!==R)throw new Error(`Invalid number of channels: ${R}`);this.internalFormat=N.RGBA32F,this.format=N.RGBA,this.textureType=N.FLOAT,this.channelSize=R}}encode(N,R){let k,S;return N.constructor!==Float32Array&&(F.Logger.warning("Encoder","data was not of type Float32; creating new Float32Array"),S=new Float32Array(N)),R*this.channelSize>N.length?(F.Logger.warning("Encoder","Source data too small. Allocating larger array"),S=N,k=this.allocate(R*this.channelSize),S.forEach((C,v)=>k[v]=C)):(S=N,k=S),k}allocate(N){return new Float32Array(4*N)}decode(N,R){return 1===this.channelSize?N.filter((k,S)=>S%4==0).subarray(0,R):N.subarray(0,R)}},E.RGBAFloatDataEncoder=class{constructor(N,R=1,k){if(1!==R&&4!==R)throw new Error(`Invalid number of channels: ${R}`);this.internalFormat=N.RGBA,this.format=N.RGBA,this.channelSize=R,this.textureType=k||N.FLOAT}encode(N,R){let k=N;return 1===this.channelSize&&(F.Logger.verbose("Encoder","Exploding into a larger array"),k=this.allocate(R),N.forEach((S,C)=>k[4*C]=S)),k}allocate(N){return new Float32Array(4*N)}decode(N,R){return 1===this.channelSize?N.filter((k,S)=>S%4==0).subarray(0,R):N.subarray(0,R)}},E.Uint8DataEncoder=class{constructor(N,R=1){if(this.channelSize=4,1===R)this.internalFormat=N.ALPHA,this.format=N.ALPHA,this.textureType=N.UNSIGNED_BYTE,this.channelSize=R;else{if(4!==R)throw new Error(`Invalid number of channels: ${R}`);this.internalFormat=N.RGBA,this.format=N.RGBA,this.textureType=N.UNSIGNED_BYTE,this.channelSize=R}}encode(N,R){return new Uint8Array(N.buffer,N.byteOffset,N.byteLength)}allocate(N){return new Uint8Array(N*this.channelSize)}decode(N,R){if(N instanceof Uint8Array)return N.subarray(0,R);throw new Error(`Invalid array type: ${N.constructor}`)}}},7618:(ge,E,$)=>{"use strict";Object.defineProperty(E,"__esModule",{value:!0}),E.getBatchDim=E.sizeToSquarishShape=E.getRowsCols=E.sizeFromShape=E.isInt=E.parseAxisParam=E.squeezeShape=E.PreferLogicalStrategy=E.AlwaysKeepOriginalSizeStrategy=void 0;const F=$(1315),N=$(7273);function R(g,h){const l=[],d=[],f=null!=h&&Array.isArray(h)&&0===h.length,b=null==h||f?null:k(h,g).sort();let x=0;for(let D=0;D<g.length;++D){if(null!=b){if(b[x]===D&&1!==g[D])throw new Error(`Can't squeeze axis ${D} since its dim '${g[D]}' is not 1`);(null==b[x]||b[x]>D)&&1===g[D]&&(l.push(g[D]),d.push(D)),b[x]<=D&&x++}1!==g[D]&&(l.push(g[D]),d.push(D))}return{newShape:l,keptDims:d}}function k(g,h){const l=h.length;return g=null==g?h.map((d,f)=>f):[].concat(g),(0,N.assert)(g.every(d=>d>=-l&&d<l),()=>`All values in axis param must be in range [-${l}, ${l}) but got axis ${g}`),(0,N.assert)(g.every(S),()=>`All values in axis param must be integers but got axis ${g}`),g.map(d=>d<0?l+d:d)}function S(g){return g%1==0}function C(g){if(0===g.length)return 1;let h=g[0];for(let l=1;l<g.length;l++)h*=g[l];return h}function v(g){const h=Math.ceil(Math.sqrt(g));return[h,Math.ceil(g/h)]}E.AlwaysKeepOriginalSizeStrategy=class{constructor(g){this.maxTextureSize=g}computeTextureWH(g,h){if(0===g.length)return[1,1];const l=this.maxTextureSize;if(h&&void 0!==h.breakAxis){const b=h.breakAxis>=g.length?1:g.slice(h.breakAxis).reduce((D,P)=>D*P),x=h.breakAxis<=0?1:g.slice(0,h.breakAxis).reduce((D,P)=>D*P);if(!(b>l||x>l))return[b,x];F.Logger.verbose("TextureLayout",`Given width/height preferences were unattainable: shape:${g}, breakAxis:${h.breakAxis}`)}const d=g.reduce((b,x)=>b*x);let f=Math.floor(Math.sqrt(d));for(;f<l&&f<d&&d%f!=0;f++);if(f>=l||d%f!=0)throw new Error(`The given dimensions are outside this GPU's boundaries: ${g}`);return[f,d/f]}},E.PreferLogicalStrategy=class{constructor(g){this.maxTextureSize=g}computeTextureWH(g,h){const l=this.computeTexture(g,h);return h&&h.isPacked&&(l[0]/=2,l[1]/=2),h&&h.reverseWH?[l[1],l[0]]:l}computeTexture(g,h){const l=h&&h.isPacked;if(0===g.length)return l?[2,2]:[1,1];let d=this.maxTextureSize;if(h&&void 0!==h.breakAxis){const x=h.breakAxis>=g.length?1:g.slice(h.breakAxis).reduce((P,L)=>P*L),D=h.breakAxis<=0?1:g.slice(0,h.breakAxis).reduce((P,L)=>P*L);if(!(x>d||D>d))return[x,D];F.Logger.verbose("TextureLayout",`Given width/height preferences were unattainable: shape:${g}, breakAxis:${h.breakAxis}`)}let f=g.slice(0);l&&(d*=2,f=f.map((x,D)=>D>=f.length-2?f[D]%2==0?f[D]:f[D]+1:f[D]),1===f.length&&(f=[2,f[0]])),2!==f.length&&(f=R(f).newShape);const b=C(f);return f.length<=1&&b<=d?[1,b]:2===f.length&&f[0]<=d&&f[1]<=d?f:3===f.length&&f[0]*f[1]<=d&&f[2]<=d?[f[0]*f[1],f[2]]:3===f.length&&f[0]<=d&&f[1]*f[2]<=d?[f[0],f[1]*f[2]]:4===f.length&&f[0]*f[1]*f[2]<=d&&f[3]<=d?[f[0]*f[1]*f[2],f[3]]:4===f.length&&f[0]<=d&&f[1]*f[2]*f[3]<=d?[f[0],f[1]*f[2]*f[3]]:l?v(b/4).map(x=>2*x):v(b)}},E.squeezeShape=R,E.parseAxisParam=k,E.isInt=S,E.sizeFromShape=C,E.getRowsCols=function(g){if(0===g.length)throw Error("Cannot get rows and columns of an empty shape array.");return[g.length>1?g[g.length-2]:1,g[g.length-1]]},E.sizeToSquarishShape=v,E.getBatchDim=function(g,h=2){return C(g.slice(0,g.length-h))}},3314:(ge,E,$)=>{"use strict";Object.defineProperty(E,"__esModule",{value:!0}),E.createTextureLayoutFromShape=E.calculateTextureWidthAndHeight=E.createTextureLayoutFromTextureType=void 0;const F=$(7273),N=$(5639);E.createTextureLayoutFromTextureType=(R,k,S)=>{const C=S===N.TextureType.unpacked||S===N.TextureType.unpackedReversed?1:4,v=S===N.TextureType.packed,g=S===N.TextureType.unpackedReversed||S===N.TextureType.packed,h=S===N.TextureType.packedLastDimension?k.length-1:void 0,l=S===N.TextureType.packedLastDimension?k.map((d,f)=>f===k.length-1?4*d:d):void 0;return(0,E.createTextureLayoutFromShape)(R,k,C,l,{isPacked:v,reverseWH:g,breakAxis:h})},E.calculateTextureWidthAndHeight=(R,k,S)=>{const C=(0,E.createTextureLayoutFromTextureType)(R,k,S);return[C.width,C.height]},E.createTextureLayoutFromShape=(R,k,S=1,C,v)=>{const g=!(!v||!v.isPacked),[h,l]=R.computeTextureWH(g&&C||k,v),d=k.length;let f=k.slice(0);if(0===d&&(f=[1]),1===S)C=k;else if(g){if(4!==S)throw new Error("a packed texture must be 4-channel");C=k,d>0&&(f[d-1]=Math.ceil(f[d-1]/2)),d>1&&(f[d-2]=Math.ceil(f[d-2]/2))}else if(!C)throw new Error("Unpacked shape is needed when using channels > 1");return{width:h,height:l,channels:S,isPacked:g,shape:f,strides:F.ShapeUtil.computeStrides(f),unpackedShape:C,reversedWH:v&&v.reverseWH}}},5243:(ge,E,$)=>{"use strict";Object.defineProperty(E,"__esModule",{value:!0}),E.TextureManager=void 0;const F=$(1315);E.TextureManager=class{constructor(N,R,k,S){this.glContext=N,this.layoutStrategy=R,this.profiler=k,this.config=S,this.pendingRead=new Map,S.reuseTextures&&(this.inUseTextures=new Map,this.idleTextures=new Map,this.textureLookup=new Map)}createTextureFromLayout(N,R,k,S){const C=this.toEncoderType(N),v=this.glContext.getEncoder(C,R.channels||1,S);if(R.isPacked&&1===S)throw new Error("not implemented");const g=R.width,h=R.height;let l,d;if(this.config.reuseTextures){l=`${g}x${h}_${v.format}_${v.internalFormat}_${v.textureType}`,d=this.inUseTextures.get(l),d||(d=[],this.inUseTextures.set(l,d));const b=this.idleTextures.get(l);if(b&&b.length>0){const x=b.pop();return d.push(x),1===S&&this.glContext.updateTexture(x,g,h,v,this.toTextureData(N,k)),x}}F.Logger.verbose("TextureManager",`Creating new texture of size ${R.width}x${R.height}`);const f=this.glContext.allocateTexture(g,h,v,this.toTextureData(N,k));return this.config.reuseTextures&&(d.push(f),this.textureLookup.set(f,l)),f}readTexture(N,R,k){return k||(k=1),this.profiler.event("backend","TextureManager.readTexture",()=>{const S=N.shape.reduce((v,g)=>v*g)*k,C=this.glContext.readTexture(N.texture,N.width,N.height,S,this.toEncoderType(R),k);return this.toTensorData(R,C)})}readTextureAsync(N,R,k){var S=this;return _asyncToGenerator(function*(){const C=N.tensor.dataId;if(k||(k=1),S.pendingRead.has(C)){const v=S.pendingRead.get(C);return new Promise(g=>v?.push(g))}return S.profiler.event("backend","TextureManager.readTextureAsync",_asyncToGenerator(function*(){S.pendingRead.set(C,[]);const v=N.shape.reduce((d,f)=>d*f)*k;yield S.glContext.createAndWaitForFence();const g=S.glContext.readTexture(N.texture,N.width,N.height,v,S.toEncoderType(R),k),h=S.toTensorData(R,g),l=S.pendingRead.get(C);return S.pendingRead.delete(C),l?.forEach(d=>d(h)),h}))})()}readUint8TextureAsFloat(N){return this.profiler.event("backend","TextureManager.readUint8TextureAsFloat",()=>{const R=N.shape.reduce((S,C)=>S*C),k=this.glContext.readTexture(N.texture,N.width,N.height,4*R,"byte",4);return new Float32Array(k.buffer,k.byteOffset,R)})}releaseTexture(N,R){let k;if(this.config.reuseTextures&&(k=this.textureLookup.get(N.texture),k)){R&&this.textureLookup.delete(k);const S=this.inUseTextures.get(k);if(S){const C=S.indexOf(N.texture);if(-1!==C){S.splice(C,1);let v=this.idleTextures.get(k);v||(v=[],this.idleTextures.set(k,v)),v.push(N.texture)}}}k&&!R||(F.Logger.verbose("TextureManager",`Deleting texture of size ${N.width}x${N.height}`),this.glContext.deleteTexture(N.texture))}toTensorData(N,R){switch(N){case"int16":return R instanceof Int16Array?R:Int16Array.from(R);case"int32":return R instanceof Int32Array?R:Int32Array.from(R);case"int8":return R instanceof Int8Array?R:Int8Array.from(R);case"uint16":return R instanceof Uint16Array?R:Uint16Array.from(R);case"uint32":return R instanceof Uint32Array?R:Uint32Array.from(R);case"uint8":case"bool":return R instanceof Uint8Array?R:Uint8Array.from(R);case"float32":return R instanceof Float32Array?R:Float32Array.from(R);case"float64":return R instanceof Float64Array?R:Float64Array.from(R);default:throw new Error(`TensorData type ${N} is not supported`)}}toTextureData(N,R){if(R)return R instanceof Float32Array?R:new Float32Array(R)}toEncoderType(N){return"float"}clearActiveTextures(){this.glContext.clearActiveTextures()}}},5639:(ge,E)=>{"use strict";var $;Object.defineProperty(E,"__esModule",{value:!0}),E.TextureType=void 0,($=E.TextureType||(E.TextureType={}))[$.unpacked=0]="unpacked",$[$.unpackedReversed=1]="unpackedReversed",$[$.packed=2]="packed",$[$.downloadUint8AsFloat=3]="downloadUint8AsFloat",$[$.packedLastDimension=4]="packedLastDimension"},432:(ge,E,$)=>{"use strict";Object.defineProperty(E,"__esModule",{value:!0}),E.getGlChannels=E.getCoordsDataType=E.getSqueezedParams=E.squeezeInputShape=E.generateShaderFuncNameFromInputSamplerNameAtOutCoords=E.generateShaderFuncNameFromInputSamplerName=E.repeatedTry=E.getPackedShape=void 0;const F=$(7273);E.getPackedShape=function(N){const R=N.length;return N.slice(0,R-1).concat(N[R-1]/4)},E.repeatedTry=function(){var N=_asyncToGenerator(function*(R,k=(C=>0),S){return new Promise((C,v)=>{let g=0;const h=()=>{if(R())return void C();g++;const l=k(g);null!=S&&g>=S?v():setTimeout(h,l)};h()})});return function(R){return N.apply(this,arguments)}}(),E.generateShaderFuncNameFromInputSamplerName=function(N){return(0,F.assert)(void 0!==N&&0!==N.length,()=>"empty string found for sampler name"),"get"+N.charAt(0).toUpperCase()+N.slice(1)},E.generateShaderFuncNameFromInputSamplerNameAtOutCoords=function(N){return(0,F.assert)(void 0!==N&&0!==N.length,()=>"empty string found for sampler name"),"get"+N.charAt(0).toUpperCase()+N.slice(1)+"AtOutCoords"},E.squeezeInputShape=function(N,R){let k=JSON.parse(JSON.stringify(N));return k=R,k},E.getSqueezedParams=function(N,R){return R.map(k=>N[k]).join(", ")},E.getCoordsDataType=function(N){if(N<=1)return"int";if(2===N)return"ivec2";if(3===N)return"ivec3";if(4===N)return"ivec4";if(5===N)return"ivec5";if(6===N)return"ivec6";throw Error(`GPU for rank ${N} is not yet supported`)},E.getGlChannels=function(N=6){return["x","y","z","w","u","v"].slice(0,N)}},3389:(ge,E,$)=>{"use strict";Object.defineProperty(E,"__esModule",{value:!0}),E.createNewWebGLContext=E.createWebGLContext=void 0;const F=$(1315),N=$(3524),R={};function k(S,C){let v;const g={alpha:!1,depth:!1,antialias:!1,stencil:!1,preserveDrawingBuffer:!1,premultipliedAlpha:!1,failIfMajorPerformanceCaveat:!1};if((!C||"webgl2"===C)&&(v=S.getContext("webgl2",g),v))try{return new N.WebGLContext(v,2)}catch(h){F.Logger.warning("GlContextFactory",`failed to create WebGLContext using contextId 'webgl2'. Error: ${h}`)}if((!C||"webgl"===C)&&(v=S.getContext("webgl",g)||S.getContext("experimental-webgl",g),v))try{return new N.WebGLContext(v,1)}catch(h){F.Logger.warning("GlContextFactory",`failed to create WebGLContext using contextId 'webgl' or 'experimental-webgl'. Error: ${h}`)}throw new Error("WebGL is not supported")}E.createWebGLContext=function S(C){let v;if(C&&"webgl2"!==C||!("webgl2"in R)?C&&"webgl"!==C||!("webgl"in R)||(v=R.webgl):v=R.webgl2,!v)try{v=k(function(){if(typeof OffscreenCanvas>"u")throw new TypeError("failed to create offscreen canvas: OffscreenCanvas is not supported");return new OffscreenCanvas(1,1)}(),C)}catch{v=k(function(){if(typeof document>"u")throw new TypeError("failed to create canvas: document is not supported");const l=document.createElement("canvas");return l.width=1,l.height=1,l}(),C)}const g=v.gl;return R[C=C||1===v.version?"webgl":"webgl2"]=v,g.isContextLost()?(delete R[C],S(C)):(g.disable(g.DEPTH_TEST),g.disable(g.STENCIL_TEST),g.disable(g.BLEND),g.disable(g.DITHER),g.disable(g.POLYGON_OFFSET_FILL),g.disable(g.SAMPLE_COVERAGE),g.enable(g.SCISSOR_TEST),g.enable(g.CULL_FACE),g.cullFace(g.BACK),v)},E.createNewWebGLContext=k},3524:function(ge,E,$){"use strict";var F=this&&this.__createBinding||(Object.create?function(g,h,l,d){void 0===d&&(d=l);var f=Object.getOwnPropertyDescriptor(h,l);f&&!("get"in f?!h.__esModule:f.writable||f.configurable)||(f={enumerable:!0,get:function(){return h[l]}}),Object.defineProperty(g,d,f)}:function(g,h,l,d){void 0===d&&(d=l),g[d]=h[l]}),N=this&&this.__setModuleDefault||(Object.create?function(g,h){Object.defineProperty(g,"default",{enumerable:!0,value:h})}:function(g,h){g.default=h}),R=this&&this.__importStar||function(g){if(g&&g.__esModule)return g;var h={};if(null!=g)for(var l in g)"default"!==l&&Object.prototype.hasOwnProperty.call(g,l)&&F(h,g,l);return N(h,g),h};Object.defineProperty(E,"__esModule",{value:!0}),E.WebGLContext=E.linearSearchLastTrue=void 0;const k=$(2235),S=R($(9622)),C=$(432);function v(g){let h=0;for(;h<g.length&&g[h]();++h);return h-1}E.linearSearchLastTrue=v,E.WebGLContext=class{constructor(g,h){this.frameBufferBound=!1,this.itemsToPoll=[],this.gl=g,this.version=h,this.getExtensions(),this.vertexbuffer=this.createVertexbuffer(),this.framebuffer=this.createFramebuffer(),this.queryVitalParameters()}allocateTexture(g,h,l,d){const f=this.gl,b=f.createTexture();f.bindTexture(f.TEXTURE_2D,b),f.texParameteri(f.TEXTURE_2D,f.TEXTURE_MIN_FILTER,f.NEAREST),f.texParameteri(f.TEXTURE_2D,f.TEXTURE_MAG_FILTER,f.NEAREST),f.texParameteri(f.TEXTURE_2D,f.TEXTURE_WRAP_S,f.CLAMP_TO_EDGE),f.texParameteri(f.TEXTURE_2D,f.TEXTURE_WRAP_T,f.CLAMP_TO_EDGE);const x=d?l.encode(d,g*h):null;return f.texImage2D(f.TEXTURE_2D,0,l.internalFormat,g,h,0,l.format,l.textureType,x),this.checkError(),b}updateTexture(g,h,l,d,f){const b=this.gl;b.bindTexture(b.TEXTURE_2D,g);const x=d.encode(f,h*l);b.texSubImage2D(b.TEXTURE_2D,0,0,0,h,l,d.format,d.textureType,x),this.checkError()}attachFramebuffer(g,h,l){const d=this.gl;d.bindTexture(d.TEXTURE_2D,g),d.bindFramebuffer(d.FRAMEBUFFER,this.framebuffer),d.framebufferTexture2D(d.FRAMEBUFFER,d.COLOR_ATTACHMENT0,d.TEXTURE_2D,g,0),this.checkError(),d.viewport(0,0,h,l),d.scissor(0,0,h,l)}readTexture(g,h,l,d,f,b){const x=this.gl;b||(b=1),this.frameBufferBound||this.attachFramebuffer(g,h,l);const D=this.getEncoder(f,b),P=D.allocate(h*l);return x.bindTexture(x.TEXTURE_2D,g),x.framebufferTexture2D(x.FRAMEBUFFER,x.COLOR_ATTACHMENT0,x.TEXTURE_2D,g,0),x.readPixels(0,0,h,l,x.RGBA,D.textureType,P),this.checkError(),D.decode(P,d)}isFramebufferReady(){return!0}getActiveTexture(){const g=this.gl;return"TEXTURE"+(g.getParameter(this.gl.ACTIVE_TEXTURE)-g.TEXTURE0)}getTextureBinding(){return this.gl.getParameter(this.gl.TEXTURE_BINDING_2D)}getFramebufferBinding(){return this.gl.getParameter(this.gl.FRAMEBUFFER_BINDING)}setVertexAttributes(g,h){const l=this.gl;l.vertexAttribPointer(g,3,l.FLOAT,!1,20,0),l.enableVertexAttribArray(g),-1!==h&&(l.vertexAttribPointer(h,2,l.FLOAT,!1,20,12),l.enableVertexAttribArray(h)),this.checkError()}createProgram(g,h){const l=this.gl,d=l.createProgram();return l.attachShader(d,g),l.attachShader(d,h),l.linkProgram(d),d}compileShader(g,h){const l=this.gl,d=l.createShader(h);if(!d)throw new Error(`createShader() returned null with type ${h}`);if(l.shaderSource(d,g),l.compileShader(d),!1===l.getShaderParameter(d,l.COMPILE_STATUS))throw new Error(`Failed to compile shader: ${l.getShaderInfoLog(d)}\nShader source:\n${g}`);return d}deleteShader(g){this.gl.deleteShader(g)}bindTextureToUniform(g,h,l){const d=this.gl;d.activeTexture(d.TEXTURE0+h),this.checkError(),d.bindTexture(d.TEXTURE_2D,g),this.checkError(),d.uniform1i(l,h),this.checkError()}draw(){this.gl.drawArrays(this.gl.TRIANGLE_STRIP,0,4),this.checkError()}checkError(){if(k.env.debug){const g=this.gl,h=g.getError();let l="";switch(h){case g.NO_ERROR:return;case g.INVALID_ENUM:l="INVALID_ENUM";break;case g.INVALID_VALUE:l="INVALID_VALUE";break;case g.INVALID_OPERATION:l="INVALID_OPERATION";break;case g.INVALID_FRAMEBUFFER_OPERATION:l="INVALID_FRAMEBUFFER_OPERATION";break;case g.OUT_OF_MEMORY:l="OUT_OF_MEMORY";break;case g.CONTEXT_LOST_WEBGL:l="CONTEXT_LOST_WEBGL";break;default:l=`Unknown WebGL Error: ${h.toString(16)}`}throw new Error(l)}}deleteTexture(g){this.gl.deleteTexture(g)}deleteProgram(g){this.gl.deleteProgram(g)}getEncoder(g,h,l=0){if(2===this.version)return new S.RedFloat32DataEncoder(this.gl,h);switch(g){case"float":return 1===l||this.isRenderFloat32Supported?new S.RGBAFloatDataEncoder(this.gl,h):new S.RGBAFloatDataEncoder(this.gl,h,this.textureHalfFloatExtension.HALF_FLOAT_OES);case"int":throw new Error("not implemented");case"byte":return new S.Uint8DataEncoder(this.gl,h);default:throw new Error(`Invalid dataType: ${g}`)}}clearActiveTextures(){const g=this.gl;for(let h=0;h<this.maxTextureImageUnits;++h)g.activeTexture(g.TEXTURE0+h),g.bindTexture(g.TEXTURE_2D,null)}dispose(){if(this.disposed)return;const g=this.gl;g.bindFramebuffer(g.FRAMEBUFFER,null),g.deleteFramebuffer(this.framebuffer),g.bindBuffer(g.ARRAY_BUFFER,null),g.deleteBuffer(this.vertexbuffer),g.bindBuffer(g.ELEMENT_ARRAY_BUFFER,null),g.finish(),this.disposed=!0}createDefaultGeometry(){return new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0])}createVertexbuffer(){const g=this.gl,h=g.createBuffer();if(!h)throw new Error("createBuffer() returned null");const l=this.createDefaultGeometry();return g.bindBuffer(g.ARRAY_BUFFER,h),g.bufferData(g.ARRAY_BUFFER,l,g.STATIC_DRAW),this.checkError(),h}createFramebuffer(){const g=this.gl.createFramebuffer();if(!g)throw new Error("createFramebuffer returned null");return g}queryVitalParameters(){const g=this.gl;if(this.isFloatTextureAttachableToFrameBuffer=this.checkFloatTextureAttachableToFrameBuffer(),this.isRenderFloat32Supported=this.checkRenderFloat32(),this.isFloat32DownloadSupported=this.checkFloat32Download(),1===this.version&&!this.textureHalfFloatExtension&&!this.isRenderFloat32Supported)throw new Error("both float32 and float16 TextureType are not supported");this.isBlendSupported=!this.isRenderFloat32Supported||this.checkFloat32Blend(),this.maxTextureSize=g.getParameter(g.MAX_TEXTURE_SIZE),this.maxTextureImageUnits=g.getParameter(g.MAX_TEXTURE_IMAGE_UNITS)}getExtensions(){2===this.version?(this.colorBufferFloatExtension=this.gl.getExtension("EXT_color_buffer_float"),this.disjointTimerQueryWebgl2Extension=this.gl.getExtension("EXT_disjoint_timer_query_webgl2")):(this.textureFloatExtension=this.gl.getExtension("OES_texture_float"),this.textureHalfFloatExtension=this.gl.getExtension("OES_texture_half_float"))}checkFloatTextureAttachableToFrameBuffer(){const g=this.gl,h=g.createTexture();g.bindTexture(g.TEXTURE_2D,h),g.texImage2D(g.TEXTURE_2D,0,2===this.version?g.RGBA32F:g.RGBA,1,1,0,g.RGBA,g.FLOAT,null);const d=g.createFramebuffer();g.bindFramebuffer(g.FRAMEBUFFER,d),g.framebufferTexture2D(g.FRAMEBUFFER,g.COLOR_ATTACHMENT0,g.TEXTURE_2D,h,0);const f=g.checkFramebufferStatus(g.FRAMEBUFFER)===g.FRAMEBUFFER_COMPLETE;return g.bindTexture(g.TEXTURE_2D,null),g.bindFramebuffer(g.FRAMEBUFFER,null),g.deleteTexture(h),g.deleteFramebuffer(d),f}checkRenderFloat32(){if(2===this.version){if(!this.colorBufferFloatExtension)return!1}else if(!this.textureFloatExtension)return!1;return this.isFloatTextureAttachableToFrameBuffer}checkFloat32Download(){if(2===this.version){if(!this.colorBufferFloatExtension)return!1}else if(!this.textureFloatExtension||!this.gl.getExtension("WEBGL_color_buffer_float"))return!1;return this.isFloatTextureAttachableToFrameBuffer}checkFloat32Blend(){const g=this.gl;let h,l,d,f,b;try{return h=g.createTexture(),l=g.createFramebuffer(),g.bindTexture(g.TEXTURE_2D,h),g.texImage2D(g.TEXTURE_2D,0,2===this.version?g.RGBA32F:g.RGBA,1,1,0,g.RGBA,g.FLOAT,null),g.bindFramebuffer(g.FRAMEBUFFER,l),g.framebufferTexture2D(g.FRAMEBUFFER,g.COLOR_ATTACHMENT0,g.TEXTURE_2D,h,0),g.enable(g.BLEND),d=g.createShader(g.VERTEX_SHADER),!!d&&(g.shaderSource(d,"void main(){}"),g.compileShader(d),f=g.createShader(g.FRAGMENT_SHADER),!!f&&(g.shaderSource(f,"precision highp float;void main(){gl_FragColor=vec4(0.5);}"),g.compileShader(f),b=g.createProgram(),!!b&&(g.attachShader(b,d),g.attachShader(b,f),g.linkProgram(b),g.useProgram(b),g.drawArrays(g.POINTS,0,1),g.getError()===g.NO_ERROR)))}finally{g.disable(g.BLEND),b&&g.deleteProgram(b),d&&g.deleteShader(d),f&&g.deleteShader(f),l&&(g.bindFramebuffer(g.FRAMEBUFFER,null),g.deleteFramebuffer(l)),h&&(g.bindTexture(g.TEXTURE_2D,null),g.deleteTexture(h))}}beginTimer(){if(2===this.version&&this.disjointTimerQueryWebgl2Extension){const g=this.gl,h=this.disjointTimerQueryWebgl2Extension,l=g.createQuery();return g.beginQuery(h.TIME_ELAPSED_EXT,l),l}throw new Error("WebGL1 profiling currently not supported.")}endTimer(){if(2!==this.version||!this.disjointTimerQueryWebgl2Extension)throw new Error("WebGL1 profiling currently not supported");this.gl.endQuery(this.disjointTimerQueryWebgl2Extension.TIME_ELAPSED_EXT)}isTimerResultAvailable(g){let h=!1,l=!1;if(2!==this.version||!this.disjointTimerQueryWebgl2Extension)throw new Error("WebGL1 profiling currently not supported");{const d=this.gl,f=this.disjointTimerQueryWebgl2Extension;h=d.getQueryParameter(g,d.QUERY_RESULT_AVAILABLE),l=d.getParameter(f.GPU_DISJOINT_EXT)}return h&&!l}getTimerResult(g){let h=0;if(2!==this.version)throw new Error("WebGL1 profiling currently not supported");{const l=this.gl;h=l.getQueryParameter(g,l.QUERY_RESULT),l.deleteQuery(g)}return h/1e6}waitForQueryAndGetTime(g){var h=this;return _asyncToGenerator(function*(){return yield(0,C.repeatedTry)(()=>h.isTimerResultAvailable(g)),h.getTimerResult(g)})()}createAndWaitForFence(){var g=this;return _asyncToGenerator(function*(){const h=g.createFence(g.gl);return g.pollFence(h)})()}createFence(g){let h;const l=g,d=l.fenceSync(l.SYNC_GPU_COMMANDS_COMPLETE,0);return g.flush(),h=null===d?()=>!0:()=>{const f=l.clientWaitSync(d,0,0);return f===l.ALREADY_SIGNALED||f===l.CONDITION_SATISFIED},{query:d,isFencePassed:h}}pollFence(g){var h=this;return _asyncToGenerator(function*(){return new Promise(l=>{h.addItemToPoll(()=>g.isFencePassed(),()=>l())})})()}pollItems(){const g=v(this.itemsToPoll.map(h=>h.isDoneFn));for(let h=0;h<=g;++h){const{resolveFn:l}=this.itemsToPoll[h];l()}this.itemsToPoll=this.itemsToPoll.slice(g+1)}addItemToPoll(g,h){var l=this;return _asyncToGenerator(function*(){l.itemsToPoll.push({isDoneFn:g,resolveFn:h}),l.itemsToPoll.length>1||(yield(0,C.repeatedTry)(()=>(l.pollItems(),0===l.itemsToPoll.length)))})()}}},6496:(ge,E,$)=>{"use strict";Object.defineProperty(E,"__esModule",{value:!0}),E.ExecutionPlan=void 0;const F=$(1315);class N{constructor(k,S){this.op=k,this.node=S}}E.ExecutionPlan=class{constructor(R,k,S){this.graph=R,this.profiler=S,this.initialize(k)}initialize(R){this.profiler.event("session","ExecutionPlan.initialize",()=>{const k=this.graph.getNodes();if(k.length!==R.length)throw new Error("The size of nodes and OPs do not match.");this._ops=R.map((S,C)=>new N(S,k[C])),this.reset(),this._starter=[],this._ops.forEach((S,C)=>{let v=!0;for(const g of S.node.inputs)if(!this._values[g]&&-1===this.graph.getInputIndices().indexOf(g)){v=!1;break}v&&this._starter.push(C)})})}reset(){this._values=this.graph.getValues().map(R=>R.tensor)}execute(R,k){var S=this;return _asyncToGenerator(function*(){return S.profiler.event("session","ExecutionPlan.execute",_asyncToGenerator(function*(){S.reset();const C=R.createInferenceHandler(),v=S.graph.getInputIndices();if(k.length!==v.length)throw new Error(`number of input tensors don't match the number of inputs to the model: actual: ${k.length} expected: ${v.length}`);k.forEach((b,x)=>{S._values[v[x]]=b});const g=S._starter.slice(0),h=S.graph.getValues(),l=S.graph.getNodes();let d=0;for(;d<g.length;){const b=g[d++],x=S._ops[b],D=x.node.inputs.map(U=>S._values[U]);if(-1!==D.indexOf(void 0))throw new Error(`unresolved input detected: op: ${x.node}`);const P=D;F.Logger.verbose("ExecPlan",`Runing op:${x.node.name} (${P.map((U,W)=>`'${x.node.inputs[W]}': ${U.type}[${U.dims.join(",")}]`).join(", ")})`);const L=yield S.profiler.event("node",x.node.name,_asyncToGenerator(function*(){return x.op.impl(C,P,x.op.context)}));if(L.length!==x.node.outputs.length)throw new Error("the size of output does not match model definition.");L.forEach((U,W)=>{const H=x.node.outputs[W];if(S._values[H])throw new Error(`output [${H}] already has value: op:${x.node.name}`);S._values[H]=U});const B=new Set;L.forEach((U,W)=>{const H=x.node.outputs[W];for(const re of h[H].to){const ue=l[re];let te=!0;for(const se of ue.inputs)if(!S._values[se]){te=!1;break}te&&B.add(re)}}),g.push(...B)}const f=[];for(let b=0;b<S.graph.getOutputIndices().length;b++){const x=S.graph.getOutputIndices()[b],D=S._values[x];if(void 0===D)throw new Error(`required output [${x}] does not have value`);0===x&&(yield D.getData()),f.push(D)}return F.Logger.verbose("ExecPlan","disposing of inferenceHandler"),C.dispose(),f}))})()}}},4662:(ge,E,$)=>{"use strict";Object.defineProperty(E,"__esModule",{value:!0}),E.Graph=void 0;const F=$(6874),N=$(5127),R=$(2446),k=$(9240),S=$(7273);var C=N.onnxruntime.experimental.fbs;E.Graph={from:(l,d)=>new h(l,d)};class v{constructor(d){this._from=void 0,this._to=[],this.tensor=void 0,this.type=void 0,d&&(this.type=S.ProtoUtil.tensorValueTypeFromProto(d.type.tensorType))}get from(){return this._from}get to(){return this._to}}class g{constructor(d,f){d instanceof R.onnx.NodeProto?(this.name=d.name,this.opType=d.opType,this.attributes=new F.Attribute(d.attribute)):d instanceof C.Node&&(this.name=f??d.name(),this.opType=d.opType(),this.attributes=new F.Attribute(S.ProtoUtil.tensorAttributesFromORTFormat(d))),this.inputs=[],this.outputs=[],this.executeNode=!0}}class h{constructor(d,f){if(!d)throw new TypeError("graph is empty");this.buildGraph(d),this.transformGraph(f),this.checkIsAcyclic()}getInputIndices(){return this._allInputIndices}getInputNames(){return this._allInputNames}getOutputIndices(){return this._allOutputIndices}getOutputNames(){return this._allOutputNames}getValues(){return this._allData}getNodes(){return this._nodes}buildGraph(d){if(d instanceof R.onnx.GraphProto)this.buildGraphFromOnnxFormat(d);else{if(!(d instanceof C.Graph))throw new TypeError("Graph type is not supported.");this.buildGraphFromOrtFormat(d)}}buildGraphFromOnnxFormat(d){const f=new Map;this._allData=[],this._allInputIndices=[],this._allInputNames=[],this._allOutputIndices=[],this._allOutputNames=[],this._nodes=[];const b=new Map;if(!d.input)throw new Error("missing information in graph: input");const x=[];for(const D of d.input){if(f.has(D.name))throw new Error(`duplicated input name: ${D.name}`);const P=this._allData.push(new v(D))-1;f.set(D.name,P),x.push(D.name)}if(!d.initializer)throw new Error("missing information in graph: initializer");for(const D of d.initializer){let P=f.get(D.name);if(void 0===P){const L=new v;L.type={shape:{dims:S.ProtoUtil.tensorDimsFromProto(D.dims)},tensorType:S.ProtoUtil.tensorDataTypeFromProto(D.dataType)},P=this._allData.push(L)-1,f.set(D.name,P)}this._allData[P]._from=-1,this._allData[P].tensor=k.Tensor.fromProto(D)}for(let D=0;D<this._allData.length;D++)this._allData[D].tensor||(this._allInputIndices.push(D),this._allInputNames.push(x[D]));if(!d.output)throw new Error("missing information in graph: output");for(const D of d.output){if(f.has(D.name))throw new Error(`duplicated output name: ${D.name}`);const P=this._allData.push(new v(D))-1;f.set(D.name,P),this._allOutputIndices.push(P),this._allOutputNames.push(D.name)}if(!d.node)throw new Error("missing information in graph: node");for(const D of d.node){if(!D.name)for(let L=0;;L++){const B=`unnamed_${D.opType}_${L}`;if(!b.has(B)){D.name=B;break}}if(b.has(D.name))throw new Error(`duplicated node name: ${D.name}`);const P=this._nodes.push(new g(D))-1;b.set(D.name,P)}for(let D=0;D<this._nodes.length;D++){const P=this._nodes[D],L=d.node[D];if(!L.output)throw new Error(`missing output for node: ${L.name}`);for(const B of L.output){let U=f.get(B);if(void 0===U&&(U=this._allData.push(new v)-1,f.set(B,U)),P.outputs.push(U),void 0!==this._allData[U]._from)throw new Error(`multiple nodes output to one data value: ${U}`);if(this._allData[U]._from=D,"Constant"===L.opType){if(!L.attribute||1!==L.attribute.length||!L.attribute[0].t)throw new Error("missing attributes or missing tensor value in attributes for this Constant operator");if(!L.output||1!==L.output.length)throw new Error("missing output or incorrect number of outputs for this Constant operator");P.outputs.pop(),P.executeNode=!1,this._allData[U]._from=-1,this._allData[U].tensor=k.Tensor.fromProto(L.attribute[0].t)}}}for(let D=0;D<this._nodes.length;D++){const P=this._nodes[D],L=d.node[D];if(!L.input)throw new Error(`missing input for node: ${L.name}`);for(const B of L.input){const U=f.get(B);if(void 0===U){if(""===B&&(3===L.input.length||4===L.input.length)&&"Resize"===L.opType)continue;throw new Error(`unrecognized input '${B}' for node: ${L.name}`)}P.inputs.push(U),this._allData[U]._to.push(D)}}return!0}buildGraphFromOrtFormat(d){var f,b,x;const D=new Map;this._allData=[],this._allInputIndices=[],this._allInputNames=[],this._allOutputIndices=[],this._allOutputNames=[],this._nodes=[];const P=new Map,L=[];for(let B=0;B<d.inputsLength();B++){const U=d.inputs(B);if(D.has(U))throw new Error(`duplicated input name: ${U}`);for(let W=0;W<d.nodeArgsLength();W++)if((null===(f=d.nodeArgs(W))||void 0===f?void 0:f.name())===U){const H=new v;if((null===(x=null===(b=d.nodeArgs(W))||void 0===b?void 0:b.type())||void 0===x?void 0:x.valueType())!==C.TypeInfoValue.tensor_type)throw new Error("Unexpected value type for the nodeArg.");const re=d.nodeArgs(W).type().value(new C.TensorTypeAndShape),ue=S.ProtoUtil.tensorDataTypeFromProto(re.elemType()),te=re.shape(),se=[];for(let X=0;X<te.dimLength();X++)se.push(S.LongUtil.longToNumber(te.dim(X).value().dimValue()));H.type={shape:{dims:se},tensorType:ue};const Y=this._allData.push(H)-1;D.set(U,Y),L.push(U)}}for(let B=0;B<d.initializersLength();B++){const U=d.initializers(B);let W=D.get(U.name());if(void 0===W){const H=new v,re=S.ProtoUtil.tensorDimsFromORTFormat(U),ue=S.ProtoUtil.tensorDataTypeFromProto(U.dataType());H.type={shape:{dims:re},tensorType:ue},W=this._allData.push(H)-1,D.set(U.name(),W)}this._allData[W]._from=-1,this._allData[W].tensor=k.Tensor.fromOrtTensor(U)}for(let B=0;B<this._allData.length;B++)this._allData[B].tensor||(this._allInputIndices.push(B),this._allInputNames.push(L[B]));for(let B=0;B<d.outputsLength();B++){const U=d.outputs(B);if(D.has(U))throw new Error(`duplicated output name: ${U}`);const W=this._allData.push(new v)-1;D.set(U,W),this._allOutputIndices.push(W),this._allOutputNames.push(U)}if(!d.nodes)throw new Error("missing information in graph: node");for(let B=0;B<d.nodesLength();B++){const U=d.nodes(B);let W=U.name();if(!W)for(let re=0;W=`unnamed_${U.opType()}_${re}`,P.has(W);re++);if(P.has(W))throw new Error(`duplicated node name: ${W}`);const H=this._nodes.push(new g(U,W))-1;P.set(W,H)}for(let B=0;B<this._nodes.length;B++){const U=this._nodes[B],W=d.nodes(B);if(null==W)throw new Error(`No node exists at index ${B}`);if(0===W?.outputsLength())throw new Error(`missing output for node: ${W.name}`);for(let H=0;H<W?.outputsLength();H++){const re=W?.outputs(H);let ue=D.get(re);if(void 0===ue&&(ue=this._allData.push(new v)-1,D.set(re,ue)),U.outputs.push(ue),void 0!==this._allData[ue]._from)throw new Error(`multiple nodes output to one data value: ${ue}`);if(this._allData[ue]._from=B,"Constant"===W.opType()){if(1!==W.attributesLength()||!W.attributes(0).t())throw new Error("missing attributes or missing tensor value in attributes for this Constant operator");if(1!==W.outputsLength())throw new Error("missing output or incorrect number of outputs for this Constant operator");U.outputs.pop(),U.executeNode=!1,this._allData[ue]._from=-1,this._allData[ue].tensor=k.Tensor.fromOrtTensor(W.attributes(0).t())}}}for(let B=0;B<this._nodes.length;B++){const U=this._nodes[B],W=d.nodes(B);if(0===W.inputsLength())throw new Error(`missing input for node: ${W.name}`);for(let H=0;H<W.inputsLength();H++){const re=W.inputs(H),ue=D.get(re);if(void 0===ue)throw new Error(`unrecognized input '${re}' for node: ${W.name()}`);U.inputs.push(ue),this._allData[ue]._to.push(B)}}}checkIsAcyclic(){const d=new Set;this._allInputIndices.forEach(x=>{this._allData[x]._to.forEach(D=>{d.add(D)})});const f=Array.from(d),b=new Array(this._nodes.length).fill("white");for(;f.length>0;){const x=f.pop();"gray"===b[x]?b[x]="black":(f.push(x),b[x]="gray",this._nodes[x].outputs.forEach(D=>{const P=this._allData[D];if(void 0!==P.tensor)throw new Error("node outputs should not be initialized");if(P._from!==x)throw new Error("from property of the Value object doesn't match index of Node being processed");P._to.forEach(L=>{if("gray"===b[L])throw new Error("model graph is cyclic");"white"===b[L]&&f.push(L)})}))}}transformGraph(d){this.removeAllIdentityNodes(),this.removeAllDropoutNodes(),this.fuseConvActivationNodes(),d&&d.transformGraph(this),this.finalizeGraph()}finalizeGraph(){let d=0;const f=new Array(this._nodes.length,0);let b=0;for(let x=0;x<this._nodes.length;x++)f[x]=b,this._nodes[x].executeNode?(b!==x&&(this._nodes[b]=this._nodes[x]),b++):this._nodes[x].outputs.forEach(D=>{this._allData[D]._from=-2});this._nodes.splice(b,this._nodes.length-b);for(let x=0;x<this._allData.length;x++){const D=this._allData[x];void 0!==D._from&&-1!==D._from&&-2!==D._from&&(D._from=f[D._from]);for(let P=0;P<D._to.length;P++){if(!(D._to[P]>=0))throw new Error("Trying to update a removed node");D._to[P]=f[D._to[P]]}}d=0;for(let x=0;x<this._allData.length;x++)if(-2!==this._allData[x].from||-1!==this._allOutputIndices.indexOf(x+d)){if(d>0){let D=-1;void 0!==this._allData[x].from&&-1!==this._allData[x].from?(D=this._nodes[this._allData[x].from].outputs.indexOf(x+d),-1!==D&&(this._nodes[this._allData[x].from].outputs[D]=x)):(D=this._allInputIndices.indexOf(x+d),-1!==D&&(this._allInputIndices[D]=x)),this._allData[x].to.forEach(P=>{D=this._nodes[P].inputs.indexOf(x+d),-1!==D&&(this._nodes[P].inputs[D]=x)}),0===this._allData[x].to.length&&(D=this._allOutputIndices.indexOf(x+d),-1!==D&&(this._allOutputIndices[D]=x))}}else d++,this._allData.splice(x,1),x--}deleteNode(d){const f=this._nodes[d];if(f.outputs.length>1)for(let L=1;L<f.outputs.length;L++)if(this._allData[f.outputs[L]].to.length>0)throw new Error("Node deletion with more than one output connected to other nodes is not supported. ");f.executeNode=!1;const b=f.inputs[0],x=f.outputs[0],D=this._allData[x].to;for(let L=0;L<f.inputs.length;L++){const B=this._allData[f.inputs[L]].to.indexOf(d);if(-1===B)throw new Error("The Value object doesn't have the current Node in it's 'to' property ");this._allData[f.inputs[L]].to.splice(B,1)}this._allData[x]._to=[];const P=this._allOutputIndices.indexOf(x);if(-1!==P&&(this._allOutputIndices[P]=b),D&&D.length>0)for(const L of D){const B=this._nodes[L].inputs.indexOf(x);if(-1===B)throw new Error("The Node object doesn't have the output Value in it's 'inputs' property ");this._nodes[L].inputs[B]=b,this._allData[b].to.push(L)}}removeAllDropoutNodes(){let d=0;for(const f of this._nodes){if("Dropout"===f.opType){if(1!==f.inputs.length)throw new Error("Dropout nodes should only contain one input. ");if(1!==f.outputs.length&&2!==f.outputs.length)throw new Error("Dropout nodes should contain either 1 or 2 output(s)");if(2===f.outputs.length&&0!==this._allData[f.outputs[1]]._to.length)throw new Error("Dropout nodes's second output should not be referenced by other nodes");this.deleteNode(d)}d++}}removeAllIdentityNodes(){let d=0;for(const f of this._nodes)"Identity"===f.opType&&this.deleteNode(d),d++}isActivation(d){switch(d.opType){case"Relu":case"Sigmoid":case"Clip":return!0;default:return!1}}fuseConvActivationNodes(){for(const d of this._nodes)if("Conv"===d.opType){const f=this._allData[d.outputs[0]]._to;if(1===f.length&&this.isActivation(this._nodes[f[0]])){const b=this._nodes[f[0]];if("Clip"===b.opType)if(1===b.inputs.length)try{d.attributes.set("activation_params","floats",[b.attributes.getFloat("min"),b.attributes.getFloat("max")])}catch{d.attributes.set("activation_params","floats",[S.MIN_CLIP,S.MAX_CLIP])}else{if(!(b.inputs.length>=3&&void 0!==this._allData[b.inputs[1]].tensor&&void 0!==this._allData[b.inputs[2]].tensor))continue;d.attributes.set("activation_params","floats",[this._allData[b.inputs[1]].tensor.floatData[0],this._allData[b.inputs[2]].tensor.floatData[0]])}d.attributes.set("activation","string",b.opType),this.deleteNode(f[0])}}}}},1315:(ge,E)=>{"use strict";Object.defineProperty(E,"__esModule",{value:!0}),E.now=E.Profiler=E.Logger=void 0;const $={verbose:1e3,info:2e3,warning:4e3,error:5e3,fatal:6e3},F={none:new class{log(g,h,l){}},console:new class{log(g,h,l){console.log(`${this.color(g)} ${l?"\x1b[35m"+l+"\x1b[0m ":""}${h}`)}color(g){switch(g){case"verbose":return"\x1b[34;40mv\x1b[0m";case"info":return"\x1b[32mi\x1b[0m";case"warning":return"\x1b[30;43mw\x1b[0m";case"error":return"\x1b[31;40me\x1b[0m";case"fatal":return"\x1b[101mf\x1b[0m";default:throw new Error(`unsupported severity: ${g}`)}}}},N={provider:"console",minimalSeverity:"warning",logDateTime:!0,logSourceLocation:!1};let R={"":N};function k(g,h,l,d){if(void 0===h)return{verbose:k.verbose.bind(null,f=g),info:k.info.bind(null,f),warning:k.warning.bind(null,f),error:k.error.bind(null,f),fatal:k.fatal.bind(null,f)};if(void 0===l)S(g,h);else if("number"==typeof l&&void 0===d)S(g,h);else if("string"==typeof l&&void 0===d)S(g,l,0,h);else{if("string"!=typeof l||"number"!=typeof d)throw new TypeError("input is valid");S(g,l,0,h)}var f}function S(g,h,l,d){const f=R[d||""]||R[""];$[g]<$[f.minimalSeverity]||(f.logDateTime&&(h=`${(new Date).toISOString()}|${h}`),F[f.provider].log(g,h,d))}(function(g){function h(d){R={},l("",d||{})}function l(d,f){if("*"===d)h(f);else{const b=R[d]||N;R[d]={provider:f.provider||b.provider,minimalSeverity:f.minimalSeverity||b.minimalSeverity,logDateTime:void 0===f.logDateTime?b.logDateTime:f.logDateTime,logSourceLocation:void 0===f.logSourceLocation?b.logSourceLocation:f.logSourceLocation}}}g.verbose=function(d,f){g("verbose",d,f)},g.info=function(d,f){g("info",d,f)},g.warning=function(d,f){g("warning",d,f)},g.error=function(d,f){g("error",d,f)},g.fatal=function(d,f){g("fatal",d,f)},g.reset=h,g.set=l,g.setWithEnv=function(d){const f={};d.logLevel&&(f.minimalSeverity=d.logLevel),l("",f)}})(k||(k={})),E.Logger=k;class C{constructor(h,l,d,f,b,x){this.category=h,this.name=l,this.startTime=d,this.endCallback=f,this.timer=b,this.ctx=x}end(){var h=this;return _asyncToGenerator(function*(){return h.endCallback(h)})()}checkTimer(){var h=this;return _asyncToGenerator(function*(){if(void 0===h.ctx||void 0===h.timer)throw new Error("No webgl timer found");return h.ctx.endTimer(),h.ctx.waitForQueryAndGetTime(h.timer)})()}}class v{constructor(h,l,d,f){this.category=h,this.name=l,this.startTime=d,this.endTime=f}}E.Profiler=class{static create(g){return void 0===g?new this:new this(g.maxNumberEvents,g.flushBatchSize,g.flushIntervalInMilliseconds)}constructor(g,h,l){this._started=!1,this._flushPointer=0,this._started=!1,this._maxNumberEvents=void 0===g?1e4:g,this._flushBatchSize=void 0===h?10:h,this._flushIntervalInMilliseconds=void 0===l?5e3:l}start(){this._started=!0,this._timingEvents=[],this._flushTime=(0,E.now)(),this._flushPointer=0}stop(){for(this._started=!1;this._flushPointer<this._timingEvents.length;this._flushPointer++)this.logOneEvent(this._timingEvents[this._flushPointer])}event(g,h,l,d){const f=this._started?this.begin(g,h,d):void 0;let b=!1;const x=l();if(x&&"function"==typeof x.then)return b=!0,new Promise((D,P)=>{x.then(function(){var L=_asyncToGenerator(function*(B){f&&(yield f.end()),D(B)});return function(B){return L.apply(this,arguments)}}(),function(){var L=_asyncToGenerator(function*(B){f&&(yield f.end()),P(B)});return function(B){return L.apply(this,arguments)}}())});if(!b&&f){const D=f.end();if(D&&"function"==typeof D.then)return new Promise((P,L)=>{D.then(()=>{P(x)},B=>{L(B)})})}return x}begin(g,h,l){var d=this;if(!this._started)throw new Error("profiler is not started yet");if(void 0===l){const f=(0,E.now)();return this.flush(f),new C(g,h,f,b=>this.endSync(b))}{const f=l.beginTimer();return new C(g,h,0,function(){var b=_asyncToGenerator(function*(x){return d.end(x)});return function(x){return b.apply(this,arguments)}}(),f,l)}}end(g){var h=this;return _asyncToGenerator(function*(){const l=yield g.checkTimer();h._timingEvents.length<h._maxNumberEvents&&(h._timingEvents.push(new v(g.category,g.name,g.startTime,l)),h.flush(l))})()}endSync(g){const h=(0,E.now)();this._timingEvents.length<this._maxNumberEvents&&(this._timingEvents.push(new v(g.category,g.name,g.startTime,h)),this.flush(h))}logOneEvent(g){E.Logger.verbose(`Profiler.${g.category}`,`${(g.endTime-g.startTime).toFixed(2)}ms on event '${g.name}' at ${g.endTime.toFixed(2)}`)}flush(g){if(this._timingEvents.length-this._flushPointer>=this._flushBatchSize||g-this._flushTime>=this._flushIntervalInMilliseconds){for(const h=this._flushPointer;this._flushPointer<h+this._flushBatchSize&&this._flushPointer<this._timingEvents.length;this._flushPointer++)this.logOneEvent(this._timingEvents[this._flushPointer]);this._flushTime=(0,E.now)()}}get started(){return this._started}},E.now=typeof performance<"u"&&performance.now?()=>performance.now():Date.now},1745:(ge,E,$)=>{"use strict";Object.defineProperty(E,"__esModule",{value:!0}),E.Model=void 0;const F=$(5686),N=$(4662),R=$(5127),k=$(2446),S=$(7273);var C=R.onnxruntime.experimental.fbs;E.Model=class{constructor(){}load(v,g,h){if(!h)try{return void this.loadFromOnnxFormat(v,g)}catch(l){if(void 0!==h)throw l}this.loadFromOrtFormat(v,g)}loadFromOnnxFormat(v,g){const h=k.onnx.ModelProto.decode(v);if(S.LongUtil.longToNumber(h.irVersion)<3)throw new Error("only support ONNX model with IR_VERSION>=3");this._opsets=h.opsetImport.map(l=>({domain:l.domain,version:S.LongUtil.longToNumber(l.version)})),this._graph=N.Graph.from(h.graph,g)}loadFromOrtFormat(v,g){const h=new F.flatbuffers.ByteBuffer(v),l=C.InferenceSession.getRootAsInferenceSession(h).model();if(S.LongUtil.longToNumber(l.irVersion())<3)throw new Error("only support ONNX model with IR_VERSION>=3");this._opsets=[];for(let d=0;d<l.opsetImportLength();d++){const f=l.opsetImport(d);this._opsets.push({domain:f?.domain(),version:S.LongUtil.longToNumber(f.version())})}this._graph=N.Graph.from(l.graph(),g)}get graph(){return this._graph}get opsets(){return this._opsets}}},6145:(ge,E)=>{"use strict";Object.defineProperty(E,"__esModule",{value:!0}),E.FLOAT_TYPES=E.INT_TYPES=E.NUMBER_TYPES=void 0,E.NUMBER_TYPES=["float32","float64","int32","int16","int8","uint16","uint32","uint8"],E.INT_TYPES=["int32","int16","int8","uint16","uint32","uint8"],E.FLOAT_TYPES=["float32","float64"]},5881:(ge,E)=>{"use strict";function $(F,N){if(N.endsWith("+")){const R=Number.parseInt(N.substring(0,N.length-1),10);return!isNaN(R)&&R<=F}if(2===N.split("-").length){const R=N.split("-"),k=Number.parseInt(R[0],10),S=Number.parseInt(R[1],10);return!isNaN(k)&&!isNaN(S)&&k<=F&&F<=S}return Number.parseInt(N,10)===F}Object.defineProperty(E,"__esModule",{value:!0}),E.resolveOperator=void 0,E.resolveOperator=function(F,N,R){for(const k of R){const C=k[1],v=k[2],g=k[3],h=k[4];if(F.opType===k[0])for(const l of N)if((l.domain===C||"ai.onnx"===l.domain&&""===C)&&$(l.version,v))return{opImpl:g,opInit:h}}throw new TypeError(`cannot resolve operator '${F.opType}' with opsets: ${N.map(k=>`${k.domain||"ai.onnx"} v${k.version}`).join(", ")}`)}},5127:(ge,E,$)=>{"use strict";Object.defineProperty(E,"__esModule",{value:!0}),E.onnxruntime=void 0;const F=$(5686);var N,R,k,S;(function(k){let S;var C;(C=S=k.AttributeType||(k.AttributeType={}))[C.UNDEFINED=0]="UNDEFINED",C[C.FLOAT=1]="FLOAT",C[C.INT=2]="INT",C[C.STRING=3]="STRING",C[C.TENSOR=4]="TENSOR",C[C.GRAPH=5]="GRAPH",C[C.FLOATS=6]="FLOATS",C[C.INTS=7]="INTS",C[C.STRINGS=8]="STRINGS",C[C.TENSORS=9]="TENSORS",C[C.GRAPHS=10]="GRAPHS",C[C.SPARSE_TENSOR=11]="SPARSE_TENSOR",C[C.SPARSE_TENSORS=12]="SPARSE_TENSORS"})((R=(N=E.onnxruntime||(E.onnxruntime={})).experimental||(N.experimental={})).fbs||(R.fbs={})),function(C){let v;var g;(g=v=C.DimensionValueType||(C.DimensionValueType={}))[g.UNKNOWN=0]="UNKNOWN",g[g.VALUE=1]="VALUE",g[g.PARAM=2]="PARAM"}((S=(k=E.onnxruntime||(E.onnxruntime={})).experimental||(k.experimental={})).fbs||(S.fbs={})),function(k){!function(S){!function(C){let v;var g;(g=v=C.TensorDataType||(C.TensorDataType={}))[g.UNDEFINED=0]="UNDEFINED",g[g.FLOAT=1]="FLOAT",g[g.UINT8=2]="UINT8",g[g.INT8=3]="INT8",g[g.UINT16=4]="UINT16",g[g.INT16=5]="INT16",g[g.INT32=6]="INT32",g[g.INT64=7]="INT64",g[g.STRING=8]="STRING",g[g.BOOL=9]="BOOL",g[g.FLOAT16=10]="FLOAT16",g[g.DOUBLE=11]="DOUBLE",g[g.UINT32=12]="UINT32",g[g.UINT64=13]="UINT64",g[g.COMPLEX64=14]="COMPLEX64",g[g.COMPLEX128=15]="COMPLEX128",g[g.BFLOAT16=16]="BFLOAT16",g[g.FLOAT8E4M3FN=17]="FLOAT8E4M3FN",g[g.FLOAT8E4M3FNUZ=18]="FLOAT8E4M3FNUZ",g[g.FLOAT8E5M2=19]="FLOAT8E5M2",g[g.FLOAT8E5M2FNUZ=20]="FLOAT8E5M2FNUZ"}(S.fbs||(S.fbs={}))}(k.experimental||(k.experimental={}))}(E.onnxruntime||(E.onnxruntime={})),function(k){!function(S){!function(C){let v;var g;(g=v=C.NodeType||(C.NodeType={}))[g.Primitive=0]="Primitive",g[g.Fused=1]="Fused"}(S.fbs||(S.fbs={}))}(k.experimental||(k.experimental={}))}(E.onnxruntime||(E.onnxruntime={})),function(k){!function(S){!function(C){let v;var g;(g=v=C.TypeInfoValue||(C.TypeInfoValue={}))[g.NONE=0]="NONE",g[g.tensor_type=1]="tensor_type",g[g.sequence_type=2]="sequence_type",g[g.map_type=3]="map_type"}(S.fbs||(S.fbs={}))}(k.experimental||(k.experimental={}))}(E.onnxruntime||(E.onnxruntime={})),function(k){!function(S){!function(C){class v{constructor(){this.bb=null,this.bb_pos=0}__init(h,l){return this.bb_pos=h,this.bb=l,this}static getRootAsShape(h,l){return(l||new v).__init(h.readInt32(h.position())+h.position(),h)}static getSizePrefixedRootAsShape(h,l){return h.setPosition(h.position()+F.flatbuffers.SIZE_PREFIX_LENGTH),(l||new v).__init(h.readInt32(h.position())+h.position(),h)}dim(h,l){let d=this.bb.__offset(this.bb_pos,4);return d?(l||new k.experimental.fbs.Dimension).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+d)+4*h),this.bb):null}dimLength(){let h=this.bb.__offset(this.bb_pos,4);return h?this.bb.__vector_len(this.bb_pos+h):0}static startShape(h){h.startObject(1)}static addDim(h,l){h.addFieldOffset(0,l,0)}static createDimVector(h,l){h.startVector(4,l.length,4);for(let d=l.length-1;d>=0;d--)h.addOffset(l[d]);return h.endVector()}static startDimVector(h,l){h.startVector(4,l,4)}static endShape(h){return h.endObject()}static createShape(h,l){return v.startShape(h),v.addDim(h,l),v.endShape(h)}}C.Shape=v}(S.fbs||(S.fbs={}))}(k.experimental||(k.experimental={}))}(E.onnxruntime||(E.onnxruntime={})),function(k){!function(S){!function(C){class v{constructor(){this.bb=null,this.bb_pos=0}__init(h,l){return this.bb_pos=h,this.bb=l,this}static getRootAsDimension(h,l){return(l||new v).__init(h.readInt32(h.position())+h.position(),h)}static getSizePrefixedRootAsDimension(h,l){return h.setPosition(h.position()+F.flatbuffers.SIZE_PREFIX_LENGTH),(l||new v).__init(h.readInt32(h.position())+h.position(),h)}value(h){let l=this.bb.__offset(this.bb_pos,4);return l?(h||new k.experimental.fbs.DimensionValue).__init(this.bb.__indirect(this.bb_pos+l),this.bb):null}denotation(h){let l=this.bb.__offset(this.bb_pos,6);return l?this.bb.__string(this.bb_pos+l,h):null}static startDimension(h){h.startObject(2)}static addValue(h,l){h.addFieldOffset(0,l,0)}static addDenotation(h,l){h.addFieldOffset(1,l,0)}static endDimension(h){return h.endObject()}static createDimension(h,l,d){return v.startDimension(h),v.addValue(h,l),v.addDenotation(h,d),v.endDimension(h)}}C.Dimension=v}(S.fbs||(S.fbs={}))}(k.experimental||(k.experimental={}))}(E.onnxruntime||(E.onnxruntime={})),function(k){!function(S){!function(C){class v{constructor(){this.bb=null,this.bb_pos=0}__init(h,l){return this.bb_pos=h,this.bb=l,this}static getRootAsDimensionValue(h,l){return(l||new v).__init(h.readInt32(h.position())+h.position(),h)}static getSizePrefixedRootAsDimensionValue(h,l){return h.setPosition(h.position()+F.flatbuffers.SIZE_PREFIX_LENGTH),(l||new v).__init(h.readInt32(h.position())+h.position(),h)}dimType(){let h=this.bb.__offset(this.bb_pos,4);return h?this.bb.readInt8(this.bb_pos+h):k.experimental.fbs.DimensionValueType.UNKNOWN}dimValue(){let h=this.bb.__offset(this.bb_pos,6);return h?this.bb.readInt64(this.bb_pos+h):this.bb.createLong(0,0)}dimParam(h){let l=this.bb.__offset(this.bb_pos,8);return l?this.bb.__string(this.bb_pos+l,h):null}static startDimensionValue(h){h.startObject(3)}static addDimType(h,l){h.addFieldInt8(0,l,k.experimental.fbs.DimensionValueType.UNKNOWN)}static addDimValue(h,l){h.addFieldInt64(1,l,h.createLong(0,0))}static addDimParam(h,l){h.addFieldOffset(2,l,0)}static endDimensionValue(h){return h.endObject()}static createDimensionValue(h,l,d,f){return v.startDimensionValue(h),v.addDimType(h,l),v.addDimValue(h,d),v.addDimParam(h,f),v.endDimensionValue(h)}}C.DimensionValue=v}(S.fbs||(S.fbs={}))}(k.experimental||(k.experimental={}))}(E.onnxruntime||(E.onnxruntime={})),function(k){!function(S){!function(C){class v{constructor(){this.bb=null,this.bb_pos=0}__init(h,l){return this.bb_pos=h,this.bb=l,this}static getRootAsTensorTypeAndShape(h,l){return(l||new v).__init(h.readInt32(h.position())+h.position(),h)}static getSizePrefixedRootAsTensorTypeAndShape(h,l){return h.setPosition(h.position()+F.flatbuffers.SIZE_PREFIX_LENGTH),(l||new v).__init(h.readInt32(h.position())+h.position(),h)}elemType(){let h=this.bb.__offset(this.bb_pos,4);return h?this.bb.readInt32(this.bb_pos+h):k.experimental.fbs.TensorDataType.UNDEFINED}shape(h){let l=this.bb.__offset(this.bb_pos,6);return l?(h||new k.experimental.fbs.Shape).__init(this.bb.__indirect(this.bb_pos+l),this.bb):null}static startTensorTypeAndShape(h){h.startObject(2)}static addElemType(h,l){h.addFieldInt32(0,l,k.experimental.fbs.TensorDataType.UNDEFINED)}static addShape(h,l){h.addFieldOffset(1,l,0)}static endTensorTypeAndShape(h){return h.endObject()}static createTensorTypeAndShape(h,l,d){return v.startTensorTypeAndShape(h),v.addElemType(h,l),v.addShape(h,d),v.endTensorTypeAndShape(h)}}C.TensorTypeAndShape=v}(S.fbs||(S.fbs={}))}(k.experimental||(k.experimental={}))}(E.onnxruntime||(E.onnxruntime={})),function(k){!function(S){!function(C){class v{constructor(){this.bb=null,this.bb_pos=0}__init(h,l){return this.bb_pos=h,this.bb=l,this}static getRootAsMapType(h,l){return(l||new v).__init(h.readInt32(h.position())+h.position(),h)}static getSizePrefixedRootAsMapType(h,l){return h.setPosition(h.position()+F.flatbuffers.SIZE_PREFIX_LENGTH),(l||new v).__init(h.readInt32(h.position())+h.position(),h)}keyType(){let h=this.bb.__offset(this.bb_pos,4);return h?this.bb.readInt32(this.bb_pos+h):k.experimental.fbs.TensorDataType.UNDEFINED}valueType(h){let l=this.bb.__offset(this.bb_pos,6);return l?(h||new k.experimental.fbs.TypeInfo).__init(this.bb.__indirect(this.bb_pos+l),this.bb):null}static startMapType(h){h.startObject(2)}static addKeyType(h,l){h.addFieldInt32(0,l,k.experimental.fbs.TensorDataType.UNDEFINED)}static addValueType(h,l){h.addFieldOffset(1,l,0)}static endMapType(h){return h.endObject()}static createMapType(h,l,d){return v.startMapType(h),v.addKeyType(h,l),v.addValueType(h,d),v.endMapType(h)}}C.MapType=v}(S.fbs||(S.fbs={}))}(k.experimental||(k.experimental={}))}(E.onnxruntime||(E.onnxruntime={})),function(k){!function(S){!function(C){class v{constructor(){this.bb=null,this.bb_pos=0}__init(h,l){return this.bb_pos=h,this.bb=l,this}static getRootAsSequenceType(h,l){return(l||new v).__init(h.readInt32(h.position())+h.position(),h)}static getSizePrefixedRootAsSequenceType(h,l){return h.setPosition(h.position()+F.flatbuffers.SIZE_PREFIX_LENGTH),(l||new v).__init(h.readInt32(h.position())+h.position(),h)}elemType(h){let l=this.bb.__offset(this.bb_pos,4);return l?(h||new k.experimental.fbs.TypeInfo).__init(this.bb.__indirect(this.bb_pos+l),this.bb):null}static startSequenceType(h){h.startObject(1)}static addElemType(h,l){h.addFieldOffset(0,l,0)}static endSequenceType(h){return h.endObject()}static createSequenceType(h,l){return v.startSequenceType(h),v.addElemType(h,l),v.endSequenceType(h)}}C.SequenceType=v}(S.fbs||(S.fbs={}))}(k.experimental||(k.experimental={}))}(E.onnxruntime||(E.onnxruntime={})),function(k){!function(S){(S.fbs||(S.fbs={})).EdgeEnd=class{constructor(){this.bb=null,this.bb_pos=0}__init(C,v){return this.bb_pos=C,this.bb=v,this}nodeIndex(){return this.bb.readUint32(this.bb_pos)}srcArgIndex(){return this.bb.readInt32(this.bb_pos+4)}dstArgIndex(){return this.bb.readInt32(this.bb_pos+8)}static createEdgeEnd(C,v,g,h){return C.prep(4,12),C.writeInt32(h),C.writeInt32(g),C.writeInt32(v),C.offset()}}}(k.experimental||(k.experimental={}))}(E.onnxruntime||(E.onnxruntime={})),function(k){!function(S){!function(C){class v{constructor(){this.bb=null,this.bb_pos=0}__init(h,l){return this.bb_pos=h,this.bb=l,this}static getRootAsNodeEdge(h,l){return(l||new v).__init(h.readInt32(h.position())+h.position(),h)}static getSizePrefixedRootAsNodeEdge(h,l){return h.setPosition(h.position()+F.flatbuffers.SIZE_PREFIX_LENGTH),(l||new v).__init(h.readInt32(h.position())+h.position(),h)}nodeIndex(){let h=this.bb.__offset(this.bb_pos,4);return h?this.bb.readUint32(this.bb_pos+h):0}inputEdges(h,l){let d=this.bb.__offset(this.bb_pos,6);return d?(l||new k.experimental.fbs.EdgeEnd).__init(this.bb.__vector(this.bb_pos+d)+12*h,this.bb):null}inputEdgesLength(){let h=this.bb.__offset(this.bb_pos,6);return h?this.bb.__vector_len(this.bb_pos+h):0}outputEdges(h,l){let d=this.bb.__offset(this.bb_pos,8);return d?(l||new k.experimental.fbs.EdgeEnd).__init(this.bb.__vector(this.bb_pos+d)+12*h,this.bb):null}outputEdgesLength(){let h=this.bb.__offset(this.bb_pos,8);return h?this.bb.__vector_len(this.bb_pos+h):0}static startNodeEdge(h){h.startObject(3)}static addNodeIndex(h,l){h.addFieldInt32(0,l,0)}static addInputEdges(h,l){h.addFieldOffset(1,l,0)}static startInputEdgesVector(h,l){h.startVector(12,l,4)}static addOutputEdges(h,l){h.addFieldOffset(2,l,0)}static startOutputEdgesVector(h,l){h.startVector(12,l,4)}static endNodeEdge(h){return h.endObject()}static createNodeEdge(h,l,d,f){return v.startNodeEdge(h),v.addNodeIndex(h,l),v.addInputEdges(h,d),v.addOutputEdges(h,f),v.endNodeEdge(h)}}C.NodeEdge=v}(S.fbs||(S.fbs={}))}(k.experimental||(k.experimental={}))}(E.onnxruntime||(E.onnxruntime={})),function(k){!function(S){!function(C){class v{constructor(){this.bb=null,this.bb_pos=0}__init(h,l){return this.bb_pos=h,this.bb=l,this}static getRootAsNode(h,l){return(l||new v).__init(h.readInt32(h.position())+h.position(),h)}static getSizePrefixedRootAsNode(h,l){return h.setPosition(h.position()+F.flatbuffers.SIZE_PREFIX_LENGTH),(l||new v).__init(h.readInt32(h.position())+h.position(),h)}name(h){let l=this.bb.__offset(this.bb_pos,4);return l?this.bb.__string(this.bb_pos+l,h):null}docString(h){let l=this.bb.__offset(this.bb_pos,6);return l?this.bb.__string(this.bb_pos+l,h):null}domain(h){let l=this.bb.__offset(this.bb_pos,8);return l?this.bb.__string(this.bb_pos+l,h):null}sinceVersion(){let h=this.bb.__offset(this.bb_pos,10);return h?this.bb.readInt32(this.bb_pos+h):0}index(){let h=this.bb.__offset(this.bb_pos,12);return h?this.bb.readUint32(this.bb_pos+h):0}opType(h){let l=this.bb.__offset(this.bb_pos,14);return l?this.bb.__string(this.bb_pos+l,h):null}type(){let h=this.bb.__offset(this.bb_pos,16);return h?this.bb.readInt32(this.bb_pos+h):k.experimental.fbs.NodeType.Primitive}executionProviderType(h){let l=this.bb.__offset(this.bb_pos,18);return l?this.bb.__string(this.bb_pos+l,h):null}inputs(h,l){let d=this.bb.__offset(this.bb_pos,20);return d?this.bb.__string(this.bb.__vector(this.bb_pos+d)+4*h,l):null}inputsLength(){let h=this.bb.__offset(this.bb_pos,20);return h?this.bb.__vector_len(this.bb_pos+h):0}outputs(h,l){let d=this.bb.__offset(this.bb_pos,22);return d?this.bb.__string(this.bb.__vector(this.bb_pos+d)+4*h,l):null}outputsLength(){let h=this.bb.__offset(this.bb_pos,22);return h?this.bb.__vector_len(this.bb_pos+h):0}attributes(h,l){let d=this.bb.__offset(this.bb_pos,24);return d?(l||new k.experimental.fbs.Attribute).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+d)+4*h),this.bb):null}attributesLength(){let h=this.bb.__offset(this.bb_pos,24);return h?this.bb.__vector_len(this.bb_pos+h):0}inputArgCounts(h){let l=this.bb.__offset(this.bb_pos,26);return l?this.bb.readInt32(this.bb.__vector(this.bb_pos+l)+4*h):0}inputArgCountsLength(){let h=this.bb.__offset(this.bb_pos,26);return h?this.bb.__vector_len(this.bb_pos+h):0}inputArgCountsArray(){let h=this.bb.__offset(this.bb_pos,26);return h?new Int32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+h),this.bb.__vector_len(this.bb_pos+h)):null}implicitInputs(h,l){let d=this.bb.__offset(this.bb_pos,28);return d?this.bb.__string(this.bb.__vector(this.bb_pos+d)+4*h,l):null}implicitInputsLength(){let h=this.bb.__offset(this.bb_pos,28);return h?this.bb.__vector_len(this.bb_pos+h):0}static startNode(h){h.startObject(13)}static addName(h,l){h.addFieldOffset(0,l,0)}static addDocString(h,l){h.addFieldOffset(1,l,0)}static addDomain(h,l){h.addFieldOffset(2,l,0)}static addSinceVersion(h,l){h.addFieldInt32(3,l,0)}static addIndex(h,l){h.addFieldInt32(4,l,0)}static addOpType(h,l){h.addFieldOffset(5,l,0)}static addType(h,l){h.addFieldInt32(6,l,k.experimental.fbs.NodeType.Primitive)}static addExecutionProviderType(h,l){h.addFieldOffset(7,l,0)}static addInputs(h,l){h.addFieldOffset(8,l,0)}static createInputsVector(h,l){h.startVector(4,l.length,4);for(let d=l.length-1;d>=0;d--)h.addOffset(l[d]);return h.endVector()}static startInputsVector(h,l){h.startVector(4,l,4)}static addOutputs(h,l){h.addFieldOffset(9,l,0)}static createOutputsVector(h,l){h.startVector(4,l.length,4);for(let d=l.length-1;d>=0;d--)h.addOffset(l[d]);return h.endVector()}static startOutputsVector(h,l){h.startVector(4,l,4)}static addAttributes(h,l){h.addFieldOffset(10,l,0)}static createAttributesVector(h,l){h.startVector(4,l.length,4);for(let d=l.length-1;d>=0;d--)h.addOffset(l[d]);return h.endVector()}static startAttributesVector(h,l){h.startVector(4,l,4)}static addInputArgCounts(h,l){h.addFieldOffset(11,l,0)}static createInputArgCountsVector(h,l){h.startVector(4,l.length,4);for(let d=l.length-1;d>=0;d--)h.addInt32(l[d]);return h.endVector()}static startInputArgCountsVector(h,l){h.startVector(4,l,4)}static addImplicitInputs(h,l){h.addFieldOffset(12,l,0)}static createImplicitInputsVector(h,l){h.startVector(4,l.length,4);for(let d=l.length-1;d>=0;d--)h.addOffset(l[d]);return h.endVector()}static startImplicitInputsVector(h,l){h.startVector(4,l,4)}static endNode(h){return h.endObject()}static createNode(h,l,d,f,b,x,D,P,L,B,U,W,H,re){return v.startNode(h),v.addName(h,l),v.addDocString(h,d),v.addDomain(h,f),v.addSinceVersion(h,b),v.addIndex(h,x),v.addOpType(h,D),v.addType(h,P),v.addExecutionProviderType(h,L),v.addInputs(h,B),v.addOutputs(h,U),v.addAttributes(h,W),v.addInputArgCounts(h,H),v.addImplicitInputs(h,re),v.endNode(h)}}C.Node=v}(S.fbs||(S.fbs={}))}(k.experimental||(k.experimental={}))}(E.onnxruntime||(E.onnxruntime={})),function(k){!function(S){!function(C){class v{constructor(){this.bb=null,this.bb_pos=0}__init(h,l){return this.bb_pos=h,this.bb=l,this}static getRootAsValueInfo(h,l){return(l||new v).__init(h.readInt32(h.position())+h.position(),h)}static getSizePrefixedRootAsValueInfo(h,l){return h.setPosition(h.position()+F.flatbuffers.SIZE_PREFIX_LENGTH),(l||new v).__init(h.readInt32(h.position())+h.position(),h)}name(h){let l=this.bb.__offset(this.bb_pos,4);return l?this.bb.__string(this.bb_pos+l,h):null}docString(h){let l=this.bb.__offset(this.bb_pos,6);return l?this.bb.__string(this.bb_pos+l,h):null}type(h){let l=this.bb.__offset(this.bb_pos,8);return l?(h||new k.experimental.fbs.TypeInfo).__init(this.bb.__indirect(this.bb_pos+l),this.bb):null}static startValueInfo(h){h.startObject(3)}static addName(h,l){h.addFieldOffset(0,l,0)}static addDocString(h,l){h.addFieldOffset(1,l,0)}static addType(h,l){h.addFieldOffset(2,l,0)}static endValueInfo(h){return h.endObject()}static createValueInfo(h,l,d,f){return v.startValueInfo(h),v.addName(h,l),v.addDocString(h,d),v.addType(h,f),v.endValueInfo(h)}}C.ValueInfo=v}(S.fbs||(S.fbs={}))}(k.experimental||(k.experimental={}))}(E.onnxruntime||(E.onnxruntime={})),function(k){!function(S){!function(C){class v{constructor(){this.bb=null,this.bb_pos=0}__init(h,l){return this.bb_pos=h,this.bb=l,this}static getRootAsTypeInfo(h,l){return(l||new v).__init(h.readInt32(h.position())+h.position(),h)}static getSizePrefixedRootAsTypeInfo(h,l){return h.setPosition(h.position()+F.flatbuffers.SIZE_PREFIX_LENGTH),(l||new v).__init(h.readInt32(h.position())+h.position(),h)}denotation(h){let l=this.bb.__offset(this.bb_pos,4);return l?this.bb.__string(this.bb_pos+l,h):null}valueType(){let h=this.bb.__offset(this.bb_pos,6);return h?this.bb.readUint8(this.bb_pos+h):k.experimental.fbs.TypeInfoValue.NONE}value(h){let l=this.bb.__offset(this.bb_pos,8);return l?this.bb.__union(h,this.bb_pos+l):null}static startTypeInfo(h){h.startObject(3)}static addDenotation(h,l){h.addFieldOffset(0,l,0)}static addValueType(h,l){h.addFieldInt8(1,l,k.experimental.fbs.TypeInfoValue.NONE)}static addValue(h,l){h.addFieldOffset(2,l,0)}static endTypeInfo(h){return h.endObject()}static createTypeInfo(h,l,d,f){return v.startTypeInfo(h),v.addDenotation(h,l),v.addValueType(h,d),v.addValue(h,f),v.endTypeInfo(h)}}C.TypeInfo=v}(S.fbs||(S.fbs={}))}(k.experimental||(k.experimental={}))}(E.onnxruntime||(E.onnxruntime={})),function(k){!function(S){!function(C){class v{constructor(){this.bb=null,this.bb_pos=0}__init(h,l){return this.bb_pos=h,this.bb=l,this}static getRootAsOperatorSetId(h,l){return(l||new v).__init(h.readInt32(h.position())+h.position(),h)}static getSizePrefixedRootAsOperatorSetId(h,l){return h.setPosition(h.position()+F.flatbuffers.SIZE_PREFIX_LENGTH),(l||new v).__init(h.readInt32(h.position())+h.position(),h)}domain(h){let l=this.bb.__offset(this.bb_pos,4);return l?this.bb.__string(this.bb_pos+l,h):null}version(){let h=this.bb.__offset(this.bb_pos,6);return h?this.bb.readInt64(this.bb_pos+h):this.bb.createLong(0,0)}static startOperatorSetId(h){h.startObject(2)}static addDomain(h,l){h.addFieldOffset(0,l,0)}static addVersion(h,l){h.addFieldInt64(1,l,h.createLong(0,0))}static endOperatorSetId(h){return h.endObject()}static createOperatorSetId(h,l,d){return v.startOperatorSetId(h),v.addDomain(h,l),v.addVersion(h,d),v.endOperatorSetId(h)}}C.OperatorSetId=v}(S.fbs||(S.fbs={}))}(k.experimental||(k.experimental={}))}(E.onnxruntime||(E.onnxruntime={})),function(k){!function(S){!function(C){class v{constructor(){this.bb=null,this.bb_pos=0}__init(h,l){return this.bb_pos=h,this.bb=l,this}static getRootAsTensor(h,l){return(l||new v).__init(h.readInt32(h.position())+h.position(),h)}static getSizePrefixedRootAsTensor(h,l){return h.setPosition(h.position()+F.flatbuffers.SIZE_PREFIX_LENGTH),(l||new v).__init(h.readInt32(h.position())+h.position(),h)}name(h){let l=this.bb.__offset(this.bb_pos,4);return l?this.bb.__string(this.bb_pos+l,h):null}docString(h){let l=this.bb.__offset(this.bb_pos,6);return l?this.bb.__string(this.bb_pos+l,h):null}dims(h){let l=this.bb.__offset(this.bb_pos,8);return l?this.bb.readInt64(this.bb.__vector(this.bb_pos+l)+8*h):this.bb.createLong(0,0)}dimsLength(){let h=this.bb.__offset(this.bb_pos,8);return h?this.bb.__vector_len(this.bb_pos+h):0}dataType(){let h=this.bb.__offset(this.bb_pos,10);return h?this.bb.readInt32(this.bb_pos+h):k.experimental.fbs.TensorDataType.UNDEFINED}rawData(h){let l=this.bb.__offset(this.bb_pos,12);return l?this.bb.readUint8(this.bb.__vector(this.bb_pos+l)+h):0}rawDataLength(){let h=this.bb.__offset(this.bb_pos,12);return h?this.bb.__vector_len(this.bb_pos+h):0}rawDataArray(){let h=this.bb.__offset(this.bb_pos,12);return h?new Uint8Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+h),this.bb.__vector_len(this.bb_pos+h)):null}stringData(h,l){let d=this.bb.__offset(this.bb_pos,14);return d?this.bb.__string(this.bb.__vector(this.bb_pos+d)+4*h,l):null}stringDataLength(){let h=this.bb.__offset(this.bb_pos,14);return h?this.bb.__vector_len(this.bb_pos+h):0}static startTensor(h){h.startObject(6)}static addName(h,l){h.addFieldOffset(0,l,0)}static addDocString(h,l){h.addFieldOffset(1,l,0)}static addDims(h,l){h.addFieldOffset(2,l,0)}static createDimsVector(h,l){h.startVector(8,l.length,8);for(let d=l.length-1;d>=0;d--)h.addInt64(l[d]);return h.endVector()}static startDimsVector(h,l){h.startVector(8,l,8)}static addDataType(h,l){h.addFieldInt32(3,l,k.experimental.fbs.TensorDataType.UNDEFINED)}static addRawData(h,l){h.addFieldOffset(4,l,0)}static createRawDataVector(h,l){h.startVector(1,l.length,1);for(let d=l.length-1;d>=0;d--)h.addInt8(l[d]);return h.endVector()}static startRawDataVector(h,l){h.startVector(1,l,1)}static addStringData(h,l){h.addFieldOffset(5,l,0)}static createStringDataVector(h,l){h.startVector(4,l.length,4);for(let d=l.length-1;d>=0;d--)h.addOffset(l[d]);return h.endVector()}static startStringDataVector(h,l){h.startVector(4,l,4)}static endTensor(h){return h.endObject()}static createTensor(h,l,d,f,b,x,D){return v.startTensor(h),v.addName(h,l),v.addDocString(h,d),v.addDims(h,f),v.addDataType(h,b),v.addRawData(h,x),v.addStringData(h,D),v.endTensor(h)}}C.Tensor=v}(S.fbs||(S.fbs={}))}(k.experimental||(k.experimental={}))}(E.onnxruntime||(E.onnxruntime={})),function(k){!function(S){!function(C){class v{constructor(){this.bb=null,this.bb_pos=0}__init(h,l){return this.bb_pos=h,this.bb=l,this}static getRootAsSparseTensor(h,l){return(l||new v).__init(h.readInt32(h.position())+h.position(),h)}static getSizePrefixedRootAsSparseTensor(h,l){return h.setPosition(h.position()+F.flatbuffers.SIZE_PREFIX_LENGTH),(l||new v).__init(h.readInt32(h.position())+h.position(),h)}values(h){let l=this.bb.__offset(this.bb_pos,4);return l?(h||new k.experimental.fbs.Tensor).__init(this.bb.__indirect(this.bb_pos+l),this.bb):null}indices(h){let l=this.bb.__offset(this.bb_pos,6);return l?(h||new k.experimental.fbs.Tensor).__init(this.bb.__indirect(this.bb_pos+l),this.bb):null}dims(h){let l=this.bb.__offset(this.bb_pos,8);return l?this.bb.readInt64(this.bb.__vector(this.bb_pos+l)+8*h):this.bb.createLong(0,0)}dimsLength(){let h=this.bb.__offset(this.bb_pos,8);return h?this.bb.__vector_len(this.bb_pos+h):0}static startSparseTensor(h){h.startObject(3)}static addValues(h,l){h.addFieldOffset(0,l,0)}static addIndices(h,l){h.addFieldOffset(1,l,0)}static addDims(h,l){h.addFieldOffset(2,l,0)}static createDimsVector(h,l){h.startVector(8,l.length,8);for(let d=l.length-1;d>=0;d--)h.addInt64(l[d]);return h.endVector()}static startDimsVector(h,l){h.startVector(8,l,8)}static endSparseTensor(h){return h.endObject()}static createSparseTensor(h,l,d,f){return v.startSparseTensor(h),v.addValues(h,l),v.addIndices(h,d),v.addDims(h,f),v.endSparseTensor(h)}}C.SparseTensor=v}(S.fbs||(S.fbs={}))}(k.experimental||(k.experimental={}))}(E.onnxruntime||(E.onnxruntime={})),function(k){!function(S){!function(C){class v{constructor(){this.bb=null,this.bb_pos=0}__init(h,l){return this.bb_pos=h,this.bb=l,this}static getRootAsAttribute(h,l){return(l||new v).__init(h.readInt32(h.position())+h.position(),h)}static getSizePrefixedRootAsAttribute(h,l){return h.setPosition(h.position()+F.flatbuffers.SIZE_PREFIX_LENGTH),(l||new v).__init(h.readInt32(h.position())+h.position(),h)}name(h){let l=this.bb.__offset(this.bb_pos,4);return l?this.bb.__string(this.bb_pos+l,h):null}docString(h){let l=this.bb.__offset(this.bb_pos,6);return l?this.bb.__string(this.bb_pos+l,h):null}type(){let h=this.bb.__offset(this.bb_pos,8);return h?this.bb.readInt32(this.bb_pos+h):k.experimental.fbs.AttributeType.UNDEFINED}f(){let h=this.bb.__offset(this.bb_pos,10);return h?this.bb.readFloat32(this.bb_pos+h):0}i(){let h=this.bb.__offset(this.bb_pos,12);return h?this.bb.readInt64(this.bb_pos+h):this.bb.createLong(0,0)}s(h){let l=this.bb.__offset(this.bb_pos,14);return l?this.bb.__string(this.bb_pos+l,h):null}t(h){let l=this.bb.__offset(this.bb_pos,16);return l?(h||new k.experimental.fbs.Tensor).__init(this.bb.__indirect(this.bb_pos+l),this.bb):null}g(h){let l=this.bb.__offset(this.bb_pos,18);return l?(h||new k.experimental.fbs.Graph).__init(this.bb.__indirect(this.bb_pos+l),this.bb):null}floats(h){let l=this.bb.__offset(this.bb_pos,20);return l?this.bb.readFloat32(this.bb.__vector(this.bb_pos+l)+4*h):0}floatsLength(){let h=this.bb.__offset(this.bb_pos,20);return h?this.bb.__vector_len(this.bb_pos+h):0}floatsArray(){let h=this.bb.__offset(this.bb_pos,20);return h?new Float32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+h),this.bb.__vector_len(this.bb_pos+h)):null}ints(h){let l=this.bb.__offset(this.bb_pos,22);return l?this.bb.readInt64(this.bb.__vector(this.bb_pos+l)+8*h):this.bb.createLong(0,0)}intsLength(){let h=this.bb.__offset(this.bb_pos,22);return h?this.bb.__vector_len(this.bb_pos+h):0}strings(h,l){let d=this.bb.__offset(this.bb_pos,24);return d?this.bb.__string(this.bb.__vector(this.bb_pos+d)+4*h,l):null}stringsLength(){let h=this.bb.__offset(this.bb_pos,24);return h?this.bb.__vector_len(this.bb_pos+h):0}tensors(h,l){let d=this.bb.__offset(this.bb_pos,26);return d?(l||new k.experimental.fbs.Tensor).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+d)+4*h),this.bb):null}tensorsLength(){let h=this.bb.__offset(this.bb_pos,26);return h?this.bb.__vector_len(this.bb_pos+h):0}graphs(h,l){let d=this.bb.__offset(this.bb_pos,28);return d?(l||new k.experimental.fbs.Graph).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+d)+4*h),this.bb):null}graphsLength(){let h=this.bb.__offset(this.bb_pos,28);return h?this.bb.__vector_len(this.bb_pos+h):0}static startAttribute(h){h.startObject(13)}static addName(h,l){h.addFieldOffset(0,l,0)}static addDocString(h,l){h.addFieldOffset(1,l,0)}static addType(h,l){h.addFieldInt32(2,l,k.experimental.fbs.AttributeType.UNDEFINED)}static addF(h,l){h.addFieldFloat32(3,l,0)}static addI(h,l){h.addFieldInt64(4,l,h.createLong(0,0))}static addS(h,l){h.addFieldOffset(5,l,0)}static addT(h,l){h.addFieldOffset(6,l,0)}static addG(h,l){h.addFieldOffset(7,l,0)}static addFloats(h,l){h.addFieldOffset(8,l,0)}static createFloatsVector(h,l){h.startVector(4,l.length,4);for(let d=l.length-1;d>=0;d--)h.addFloat32(l[d]);return h.endVector()}static startFloatsVector(h,l){h.startVector(4,l,4)}static addInts(h,l){h.addFieldOffset(9,l,0)}static createIntsVector(h,l){h.startVector(8,l.length,8);for(let d=l.length-1;d>=0;d--)h.addInt64(l[d]);return h.endVector()}static startIntsVector(h,l){h.startVector(8,l,8)}static addStrings(h,l){h.addFieldOffset(10,l,0)}static createStringsVector(h,l){h.startVector(4,l.length,4);for(let d=l.length-1;d>=0;d--)h.addOffset(l[d]);return h.endVector()}static startStringsVector(h,l){h.startVector(4,l,4)}static addTensors(h,l){h.addFieldOffset(11,l,0)}static createTensorsVector(h,l){h.startVector(4,l.length,4);for(let d=l.length-1;d>=0;d--)h.addOffset(l[d]);return h.endVector()}static startTensorsVector(h,l){h.startVector(4,l,4)}static addGraphs(h,l){h.addFieldOffset(12,l,0)}static createGraphsVector(h,l){h.startVector(4,l.length,4);for(let d=l.length-1;d>=0;d--)h.addOffset(l[d]);return h.endVector()}static startGraphsVector(h,l){h.startVector(4,l,4)}static endAttribute(h){return h.endObject()}static createAttribute(h,l,d,f,b,x,D,P,L,B,U,W,H,re){return v.startAttribute(h),v.addName(h,l),v.addDocString(h,d),v.addType(h,f),v.addF(h,b),v.addI(h,x),v.addS(h,D),v.addT(h,P),v.addG(h,L),v.addFloats(h,B),v.addInts(h,U),v.addStrings(h,W),v.addTensors(h,H),v.addGraphs(h,re),v.endAttribute(h)}}C.Attribute=v}(S.fbs||(S.fbs={}))}(k.experimental||(k.experimental={}))}(E.onnxruntime||(E.onnxruntime={})),function(k){!function(S){!function(C){class v{constructor(){this.bb=null,this.bb_pos=0}__init(h,l){return this.bb_pos=h,this.bb=l,this}static getRootAsGraph(h,l){return(l||new v).__init(h.readInt32(h.position())+h.position(),h)}static getSizePrefixedRootAsGraph(h,l){return h.setPosition(h.position()+F.flatbuffers.SIZE_PREFIX_LENGTH),(l||new v).__init(h.readInt32(h.position())+h.position(),h)}initializers(h,l){let d=this.bb.__offset(this.bb_pos,4);return d?(l||new k.experimental.fbs.Tensor).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+d)+4*h),this.bb):null}initializersLength(){let h=this.bb.__offset(this.bb_pos,4);return h?this.bb.__vector_len(this.bb_pos+h):0}nodeArgs(h,l){let d=this.bb.__offset(this.bb_pos,6);return d?(l||new k.experimental.fbs.ValueInfo).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+d)+4*h),this.bb):null}nodeArgsLength(){let h=this.bb.__offset(this.bb_pos,6);return h?this.bb.__vector_len(this.bb_pos+h):0}nodes(h,l){let d=this.bb.__offset(this.bb_pos,8);return d?(l||new k.experimental.fbs.Node).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+d)+4*h),this.bb):null}nodesLength(){let h=this.bb.__offset(this.bb_pos,8);return h?this.bb.__vector_len(this.bb_pos+h):0}maxNodeIndex(){let h=this.bb.__offset(this.bb_pos,10);return h?this.bb.readUint32(this.bb_pos+h):0}nodeEdges(h,l){let d=this.bb.__offset(this.bb_pos,12);return d?(l||new k.experimental.fbs.NodeEdge).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+d)+4*h),this.bb):null}nodeEdgesLength(){let h=this.bb.__offset(this.bb_pos,12);return h?this.bb.__vector_len(this.bb_pos+h):0}inputs(h,l){let d=this.bb.__offset(this.bb_pos,14);return d?this.bb.__string(this.bb.__vector(this.bb_pos+d)+4*h,l):null}inputsLength(){let h=this.bb.__offset(this.bb_pos,14);return h?this.bb.__vector_len(this.bb_pos+h):0}outputs(h,l){let d=this.bb.__offset(this.bb_pos,16);return d?this.bb.__string(this.bb.__vector(this.bb_pos+d)+4*h,l):null}outputsLength(){let h=this.bb.__offset(this.bb_pos,16);return h?this.bb.__vector_len(this.bb_pos+h):0}sparseInitializers(h,l){let d=this.bb.__offset(this.bb_pos,18);return d?(l||new k.experimental.fbs.SparseTensor).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+d)+4*h),this.bb):null}sparseInitializersLength(){let h=this.bb.__offset(this.bb_pos,18);return h?this.bb.__vector_len(this.bb_pos+h):0}static startGraph(h){h.startObject(8)}static addInitializers(h,l){h.addFieldOffset(0,l,0)}static createInitializersVector(h,l){h.startVector(4,l.length,4);for(let d=l.length-1;d>=0;d--)h.addOffset(l[d]);return h.endVector()}static startInitializersVector(h,l){h.startVector(4,l,4)}static addNodeArgs(h,l){h.addFieldOffset(1,l,0)}static createNodeArgsVector(h,l){h.startVector(4,l.length,4);for(let d=l.length-1;d>=0;d--)h.addOffset(l[d]);return h.endVector()}static startNodeArgsVector(h,l){h.startVector(4,l,4)}static addNodes(h,l){h.addFieldOffset(2,l,0)}static createNodesVector(h,l){h.startVector(4,l.length,4);for(let d=l.length-1;d>=0;d--)h.addOffset(l[d]);return h.endVector()}static startNodesVector(h,l){h.startVector(4,l,4)}static addMaxNodeIndex(h,l){h.addFieldInt32(3,l,0)}static addNodeEdges(h,l){h.addFieldOffset(4,l,0)}static createNodeEdgesVector(h,l){h.startVector(4,l.length,4);for(let d=l.length-1;d>=0;d--)h.addOffset(l[d]);return h.endVector()}static startNodeEdgesVector(h,l){h.startVector(4,l,4)}static addInputs(h,l){h.addFieldOffset(5,l,0)}static createInputsVector(h,l){h.startVector(4,l.length,4);for(let d=l.length-1;d>=0;d--)h.addOffset(l[d]);return h.endVector()}static startInputsVector(h,l){h.startVector(4,l,4)}static addOutputs(h,l){h.addFieldOffset(6,l,0)}static createOutputsVector(h,l){h.startVector(4,l.length,4);for(let d=l.length-1;d>=0;d--)h.addOffset(l[d]);return h.endVector()}static startOutputsVector(h,l){h.startVector(4,l,4)}static addSparseInitializers(h,l){h.addFieldOffset(7,l,0)}static createSparseInitializersVector(h,l){h.startVector(4,l.length,4);for(let d=l.length-1;d>=0;d--)h.addOffset(l[d]);return h.endVector()}static startSparseInitializersVector(h,l){h.startVector(4,l,4)}static endGraph(h){return h.endObject()}static createGraph(h,l,d,f,b,x,D,P,L){return v.startGraph(h),v.addInitializers(h,l),v.addNodeArgs(h,d),v.addNodes(h,f),v.addMaxNodeIndex(h,b),v.addNodeEdges(h,x),v.addInputs(h,D),v.addOutputs(h,P),v.addSparseInitializers(h,L),v.endGraph(h)}}C.Graph=v}(S.fbs||(S.fbs={}))}(k.experimental||(k.experimental={}))}(E.onnxruntime||(E.onnxruntime={})),function(k){!function(S){!function(C){class v{constructor(){this.bb=null,this.bb_pos=0}__init(h,l){return this.bb_pos=h,this.bb=l,this}static getRootAsModel(h,l){return(l||new v).__init(h.readInt32(h.position())+h.position(),h)}static getSizePrefixedRootAsModel(h,l){return h.setPosition(h.position()+F.flatbuffers.SIZE_PREFIX_LENGTH),(l||new v).__init(h.readInt32(h.position())+h.position(),h)}irVersion(){let h=this.bb.__offset(this.bb_pos,4);return h?this.bb.readInt64(this.bb_pos+h):this.bb.createLong(0,0)}opsetImport(h,l){let d=this.bb.__offset(this.bb_pos,6);return d?(l||new k.experimental.fbs.OperatorSetId).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+d)+4*h),this.bb):null}opsetImportLength(){let h=this.bb.__offset(this.bb_pos,6);return h?this.bb.__vector_len(this.bb_pos+h):0}producerName(h){let l=this.bb.__offset(this.bb_pos,8);return l?this.bb.__string(this.bb_pos+l,h):null}producerVersion(h){let l=this.bb.__offset(this.bb_pos,10);return l?this.bb.__string(this.bb_pos+l,h):null}domain(h){let l=this.bb.__offset(this.bb_pos,12);return l?this.bb.__string(this.bb_pos+l,h):null}modelVersion(){let h=this.bb.__offset(this.bb_pos,14);return h?this.bb.readInt64(this.bb_pos+h):this.bb.createLong(0,0)}docString(h){let l=this.bb.__offset(this.bb_pos,16);return l?this.bb.__string(this.bb_pos+l,h):null}graph(h){let l=this.bb.__offset(this.bb_pos,18);return l?(h||new k.experimental.fbs.Graph).__init(this.bb.__indirect(this.bb_pos+l),this.bb):null}graphDocString(h){let l=this.bb.__offset(this.bb_pos,20);return l?this.bb.__string(this.bb_pos+l,h):null}static startModel(h){h.startObject(9)}static addIrVersion(h,l){h.addFieldInt64(0,l,h.createLong(0,0))}static addOpsetImport(h,l){h.addFieldOffset(1,l,0)}static createOpsetImportVector(h,l){h.startVector(4,l.length,4);for(let d=l.length-1;d>=0;d--)h.addOffset(l[d]);return h.endVector()}static startOpsetImportVector(h,l){h.startVector(4,l,4)}static addProducerName(h,l){h.addFieldOffset(2,l,0)}static addProducerVersion(h,l){h.addFieldOffset(3,l,0)}static addDomain(h,l){h.addFieldOffset(4,l,0)}static addModelVersion(h,l){h.addFieldInt64(5,l,h.createLong(0,0))}static addDocString(h,l){h.addFieldOffset(6,l,0)}static addGraph(h,l){h.addFieldOffset(7,l,0)}static addGraphDocString(h,l){h.addFieldOffset(8,l,0)}static endModel(h){return h.endObject()}static createModel(h,l,d,f,b,x,D,P,L,B){return v.startModel(h),v.addIrVersion(h,l),v.addOpsetImport(h,d),v.addProducerName(h,f),v.addProducerVersion(h,b),v.addDomain(h,x),v.addModelVersion(h,D),v.addDocString(h,P),v.addGraph(h,L),v.addGraphDocString(h,B),v.endModel(h)}}C.Model=v}(S.fbs||(S.fbs={}))}(k.experimental||(k.experimental={}))}(E.onnxruntime||(E.onnxruntime={})),function(k){!function(S){!function(C){class v{constructor(){this.bb=null,this.bb_pos=0}__init(h,l){return this.bb_pos=h,this.bb=l,this}static getRootAsKernelCreateInfos(h,l){return(l||new v).__init(h.readInt32(h.position())+h.position(),h)}static getSizePrefixedRootAsKernelCreateInfos(h,l){return h.setPosition(h.position()+F.flatbuffers.SIZE_PREFIX_LENGTH),(l||new v).__init(h.readInt32(h.position())+h.position(),h)}nodeIndices(h){let l=this.bb.__offset(this.bb_pos,4);return l?this.bb.readUint32(this.bb.__vector(this.bb_pos+l)+4*h):0}nodeIndicesLength(){let h=this.bb.__offset(this.bb_pos,4);return h?this.bb.__vector_len(this.bb_pos+h):0}nodeIndicesArray(){let h=this.bb.__offset(this.bb_pos,4);return h?new Uint32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+h),this.bb.__vector_len(this.bb_pos+h)):null}kernelDefHashes(h){let l=this.bb.__offset(this.bb_pos,6);return l?this.bb.readUint64(this.bb.__vector(this.bb_pos+l)+8*h):this.bb.createLong(0,0)}kernelDefHashesLength(){let h=this.bb.__offset(this.bb_pos,6);return h?this.bb.__vector_len(this.bb_pos+h):0}static startKernelCreateInfos(h){h.startObject(2)}static addNodeIndices(h,l){h.addFieldOffset(0,l,0)}static createNodeIndicesVector(h,l){h.startVector(4,l.length,4);for(let d=l.length-1;d>=0;d--)h.addInt32(l[d]);return h.endVector()}static startNodeIndicesVector(h,l){h.startVector(4,l,4)}static addKernelDefHashes(h,l){h.addFieldOffset(1,l,0)}static createKernelDefHashesVector(h,l){h.startVector(8,l.length,8);for(let d=l.length-1;d>=0;d--)h.addInt64(l[d]);return h.endVector()}static startKernelDefHashesVector(h,l){h.startVector(8,l,8)}static endKernelCreateInfos(h){return h.endObject()}static createKernelCreateInfos(h,l,d){return v.startKernelCreateInfos(h),v.addNodeIndices(h,l),v.addKernelDefHashes(h,d),v.endKernelCreateInfos(h)}}C.KernelCreateInfos=v}(S.fbs||(S.fbs={}))}(k.experimental||(k.experimental={}))}(E.onnxruntime||(E.onnxruntime={})),function(k){!function(S){!function(C){class v{constructor(){this.bb=null,this.bb_pos=0}__init(h,l){return this.bb_pos=h,this.bb=l,this}static getRootAsSubGraphSessionState(h,l){return(l||new v).__init(h.readInt32(h.position())+h.position(),h)}static getSizePrefixedRootAsSubGraphSessionState(h,l){return h.setPosition(h.position()+F.flatbuffers.SIZE_PREFIX_LENGTH),(l||new v).__init(h.readInt32(h.position())+h.position(),h)}graphId(h){let l=this.bb.__offset(this.bb_pos,4);return l?this.bb.__string(this.bb_pos+l,h):null}sessionState(h){let l=this.bb.__offset(this.bb_pos,6);return l?(h||new k.experimental.fbs.SessionState).__init(this.bb.__indirect(this.bb_pos+l),this.bb):null}static startSubGraphSessionState(h){h.startObject(2)}static addGraphId(h,l){h.addFieldOffset(0,l,0)}static addSessionState(h,l){h.addFieldOffset(1,l,0)}static endSubGraphSessionState(h){let l=h.endObject();return h.requiredField(l,4),l}static createSubGraphSessionState(h,l,d){return v.startSubGraphSessionState(h),v.addGraphId(h,l),v.addSessionState(h,d),v.endSubGraphSessionState(h)}}C.SubGraphSessionState=v}(S.fbs||(S.fbs={}))}(k.experimental||(k.experimental={}))}(E.onnxruntime||(E.onnxruntime={})),function(k){!function(S){!function(C){class v{constructor(){this.bb=null,this.bb_pos=0}__init(h,l){return this.bb_pos=h,this.bb=l,this}static getRootAsSessionState(h,l){return(l||new v).__init(h.readInt32(h.position())+h.position(),h)}static getSizePrefixedRootAsSessionState(h,l){return h.setPosition(h.position()+F.flatbuffers.SIZE_PREFIX_LENGTH),(l||new v).__init(h.readInt32(h.position())+h.position(),h)}kernels(h){let l=this.bb.__offset(this.bb_pos,4);return l?(h||new k.experimental.fbs.KernelCreateInfos).__init(this.bb.__indirect(this.bb_pos+l),this.bb):null}subGraphSessionStates(h,l){let d=this.bb.__offset(this.bb_pos,6);return d?(l||new k.experimental.fbs.SubGraphSessionState).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+d)+4*h),this.bb):null}subGraphSessionStatesLength(){let h=this.bb.__offset(this.bb_pos,6);return h?this.bb.__vector_len(this.bb_pos+h):0}static startSessionState(h){h.startObject(2)}static addKernels(h,l){h.addFieldOffset(0,l,0)}static addSubGraphSessionStates(h,l){h.addFieldOffset(1,l,0)}static createSubGraphSessionStatesVector(h,l){h.startVector(4,l.length,4);for(let d=l.length-1;d>=0;d--)h.addOffset(l[d]);return h.endVector()}static startSubGraphSessionStatesVector(h,l){h.startVector(4,l,4)}static endSessionState(h){return h.endObject()}static createSessionState(h,l,d){return v.startSessionState(h),v.addKernels(h,l),v.addSubGraphSessionStates(h,d),v.endSessionState(h)}}C.SessionState=v}(S.fbs||(S.fbs={}))}(k.experimental||(k.experimental={}))}(E.onnxruntime||(E.onnxruntime={})),function(k){!function(S){!function(C){class v{constructor(){this.bb=null,this.bb_pos=0}__init(h,l){return this.bb_pos=h,this.bb=l,this}static getRootAsInferenceSession(h,l){return(l||new v).__init(h.readInt32(h.position())+h.position(),h)}static getSizePrefixedRootAsInferenceSession(h,l){return h.setPosition(h.position()+F.flatbuffers.SIZE_PREFIX_LENGTH),(l||new v).__init(h.readInt32(h.position())+h.position(),h)}static bufferHasIdentifier(h){return h.__has_identifier("ORTM")}ortVersion(h){let l=this.bb.__offset(this.bb_pos,4);return l?this.bb.__string(this.bb_pos+l,h):null}model(h){let l=this.bb.__offset(this.bb_pos,6);return l?(h||new k.experimental.fbs.Model).__init(this.bb.__indirect(this.bb_pos+l),this.bb):null}sessionState(h){let l=this.bb.__offset(this.bb_pos,8);return l?(h||new k.experimental.fbs.SessionState).__init(this.bb.__indirect(this.bb_pos+l),this.bb):null}static startInferenceSession(h){h.startObject(3)}static addOrtVersion(h,l){h.addFieldOffset(0,l,0)}static addModel(h,l){h.addFieldOffset(1,l,0)}static addSessionState(h,l){h.addFieldOffset(2,l,0)}static endInferenceSession(h){return h.endObject()}static finishInferenceSessionBuffer(h,l){h.finish(l,"ORTM")}static finishSizePrefixedInferenceSessionBuffer(h,l){h.finish(l,"ORTM",!0)}static createInferenceSession(h,l,d,f){return v.startInferenceSession(h),v.addOrtVersion(h,l),v.addModel(h,d),v.addSessionState(h,f),v.endInferenceSession(h)}}C.InferenceSession=v}(S.fbs||(S.fbs={}))}(k.experimental||(k.experimental={}))}(E.onnxruntime||(E.onnxruntime={}))},1723:(ge,E,$)=>{"use strict";Object.defineProperty(E,"__esModule",{value:!0}),E.OnnxjsSessionHandler=void 0;const F=$(2235),N=$(9240);E.OnnxjsSessionHandler=class{constructor(R){this.session=R,this.inputNames=this.session.inputNames,this.outputNames=this.session.outputNames}dispose(){return _asyncToGenerator(function*(){})()}run(R,k,S){var C=this;return _asyncToGenerator(function*(){const v=new Map;for(const l in R)if(Object.hasOwnProperty.call(R,l)){const d=R[l];v.set(l,new N.Tensor(d.dims,d.type,void 0,void 0,d.data))}const g=yield C.session.run(v),h={};return g.forEach((l,d)=>{h[d]=new F.Tensor(l.type,l.data,l.dims)}),h})()}startProfiling(){this.session.startProfiling()}endProfiling(){this.session.endProfiling()}}},6027:(ge,E,$)=>{"use strict";Object.defineProperty(E,"__esModule",{value:!0}),E.Session=void 0;const F=$(7067),N=$(1296),R=$(1975),k=$(6496),S=$(1315),C=$(1745);E.Session=class{constructor(v={}){this._initialized=!1,this.backendHint=v.backendHint,this.profiler=S.Profiler.create(v.profiler),this.context={profiler:this.profiler,graphInputTypes:[],graphInputDims:[]}}get inputNames(){return this._model.graph.getInputNames()}get outputNames(){return this._model.graph.getOutputNames()}startProfiling(){this.profiler.start()}endProfiling(){this.profiler.stop()}loadModel(v,g,h){var l=this;return _asyncToGenerator(function*(){yield l.profiler.event("session","Session.loadModel",_asyncToGenerator(function*(){const d=yield(0,R.resolveBackend)(l.backendHint);if(l.sessionHandler=d.createSessionHandler(l.context),l._model=new C.Model,"string"==typeof v){const f=v.endsWith(".ort");if(typeof process<"u"&&process.versions&&process.versions.node){const b=yield(0,N.promisify)(F.readFile)(v);l.initialize(b,f)}else{const b=yield fetch(v),x=yield b.arrayBuffer();l.initialize(new Uint8Array(x),f)}}else if(ArrayBuffer.isView(v))l.initialize(v);else{const f=new Uint8Array(v,g||0,h||v.byteLength);l.initialize(f)}}))})()}initialize(v,g){if(this._initialized)throw new Error("already initialized");this.profiler.event("session","Session.initialize",()=>{this._model.load(v,this.sessionHandler.transformGraph?this.sessionHandler:void 0,g),this.sessionHandler.onGraphInitialized&&this.sessionHandler.onGraphInitialized(this._model.graph),this.initializeOps(this._model.graph),this._executionPlan=new k.ExecutionPlan(this._model.graph,this._ops,this.profiler)}),this._initialized=!0}run(v){var g=this;return _asyncToGenerator(function*(){if(!g._initialized)throw new Error("session not initialized yet");return g.profiler.event("session","Session.run",_asyncToGenerator(function*(){const h=g.normalizeAndValidateInputs(v),l=yield g._executionPlan.execute(g.sessionHandler,h);return g.createOutput(l)}))})()}normalizeAndValidateInputs(v){const g=this._model.graph.getInputNames();if(Array.isArray(v)){if(v.length!==g.length)throw new Error(`incorrect input array length: expected ${g.length} but got ${v.length}`)}else{if(v.size!==g.length)throw new Error(`incorrect input map size: expected ${g.length} but got ${v.size}`);const h=new Array(v.size);let l=0;for(let d=0;d<g.length;++d){const f=v.get(g[d]);if(!f)throw new Error(`missing input tensor for: '${name}'`);h[l++]=f}v=h}if(this.context.graphInputTypes&&0!==this.context.graphInputTypes.length&&this.context.graphInputDims&&0!==this.context.graphInputDims.length)this.validateInputTensorDims(this.context.graphInputDims,v,!1);else{const h=this._model.graph.getInputIndices(),l=this._model.graph.getValues(),d=new Array(h.length);for(let f=0;f<h.length;++f){const b=l[h[f]];d[f]=b.type.shape.dims,this.context.graphInputTypes.push(b.type.tensorType),this.context.graphInputDims.push(v[f].dims)}this.validateInputTensorDims(d,v,!0)}return this.validateInputTensorTypes(this.context.graphInputTypes,v),v}validateInputTensorTypes(v,g){for(let h=0;h<g.length;h++){const l=v[h],d=g[h].type;if(l!==d)throw new Error(`input tensor[${h}] check failed: expected type '${l}' but got ${d}`)}}validateInputTensorDims(v,g,h){for(let l=0;l<g.length;l++){const d=v[l],f=g[l].dims;if(!this.compareTensorDims(d,f,h))throw new Error(`input tensor[${l}] check failed: expected shape '[${d.join(",")}]' but got [${f.join(",")}]`)}}compareTensorDims(v,g,h){if(v.length!==g.length)return!1;for(let l=0;l<v.length;++l)if(v[l]!==g[l]&&(!h||0!==v[l]))return!1;return!0}createOutput(v){const g=this._model.graph.getOutputNames();if(v.length!==g.length)throw new Error("expected number of outputs do not match number of generated outputs");const h=new Map;for(let l=0;l<g.length;++l)h.set(g[l],v[l]);return h}initializeOps(v){const g=v.getNodes();this._ops=new Array(g.length);for(let h=0;h<g.length;h++)this._ops[h]=this.sessionHandler.resolve(g[h],this._model.opsets,v)}}},9240:function(ge,E,$){"use strict";var F=this&&this.__importDefault||function(b){return b&&b.__esModule?b:{default:b}};Object.defineProperty(E,"__esModule",{value:!0}),E.Tensor=void 0;const N=$(3442),R=F($(1583)),k=$(5127),S=$(2446),C=$(7273);var v=k.onnxruntime.experimental.fbs;class g{get data(){if(void 0===this.cache){const x=this.dataProvider(this.dataId);if(x.length!==this.size)throw new Error("Length of data provided by the Data Provider is inconsistent with the dims of this Tensor.");this.cache=x}return this.cache}get stringData(){if("string"!==this.type)throw new TypeError("data type is not string");return this.data}get integerData(){switch(this.type){case"uint8":case"int8":case"uint16":case"int16":case"int32":case"uint32":case"bool":return this.data;default:throw new TypeError("data type is not integer (uint8, int8, uint16, int16, int32, uint32, bool)")}}get floatData(){switch(this.type){case"float32":case"float64":return this.data;default:throw new TypeError("data type is not float (float32, float64)")}}get numberData(){if("string"!==this.type)return this.data;throw new TypeError("type cannot be non-number (string)")}get(x){return this.data[C.ShapeUtil.indicesToOffset(x,this.strides)]}set(x,D){this.data[C.ShapeUtil.indicesToOffset(x,this.strides)]=D}getData(){var x=this;return _asyncToGenerator(function*(){return void 0===x.cache&&(x.cache=yield x.asyncDataProvider(x.dataId)),x.cache})()}get strides(){return this._strides||(this._strides=C.ShapeUtil.computeStrides(this.dims)),this._strides}constructor(x,D,P,L,B,U=N.Guid.create()){this.dims=x,this.type=D,this.dataProvider=P,this.asyncDataProvider=L,this.cache=B,this.dataId=U,this.size=C.ShapeUtil.validateDimsAndCalcSize(x);const W=this.size,H=void 0===P&&void 0===L&&void 0===B;if(void 0!==B&&B.length!==W)throw new RangeError("Input dims doesn't match data length.");if("string"===D){if(!(void 0===B||Array.isArray(B)&&B.every(re=>"string"==typeof re)))throw new TypeError("cache should be a string array");H&&(this.cache=new Array(W))}else{if(void 0!==B){const re=l(D);if(!(B instanceof re))throw new TypeError(`cache should be type ${re.name}`)}if(H){const re=new ArrayBuffer(W*function(ue){switch(ue){case"bool":case"int8":case"uint8":return 1;case"int16":case"uint16":return 2;case"int32":case"uint32":case"float32":return 4;case"float64":return 8;default:throw new Error(`cannot calculate sizeof() on type ${ue}`)}}(D));this.cache=(ue=re,new(l(D))(ue))}}var ue}static fromProto(x){if(!x)throw new Error("cannot construct Value from an empty tensor");const D=C.ProtoUtil.tensorDataTypeFromProto(x.dataType),P=C.ProtoUtil.tensorDimsFromProto(x.dims),L=new g(P,D);if("string"===D)x.stringData.forEach((B,U)=>{L.data[U]=(0,C.decodeUtf8String)(B)});else if(x.rawData&&"number"==typeof x.rawData.byteLength&&x.rawData.byteLength>0){const B=L.data,U=new DataView(x.rawData.buffer,x.rawData.byteOffset,x.rawData.byteLength),W=h(x.dataType),H=x.rawData.byteLength/W;if(x.rawData.byteLength%W!=0)throw new Error("invalid buffer length");if(B.length!==H)throw new Error("buffer length mismatch");for(let re=0;re<H;re++){const ue=f(U,x.dataType,re*W);B[re]=ue}}else{let B;switch(x.dataType){case S.onnx.TensorProto.DataType.FLOAT:B=x.floatData;break;case S.onnx.TensorProto.DataType.INT32:case S.onnx.TensorProto.DataType.INT16:case S.onnx.TensorProto.DataType.UINT16:case S.onnx.TensorProto.DataType.INT8:case S.onnx.TensorProto.DataType.UINT8:case S.onnx.TensorProto.DataType.BOOL:B=x.int32Data;break;case S.onnx.TensorProto.DataType.INT64:B=x.int64Data;break;case S.onnx.TensorProto.DataType.DOUBLE:B=x.doubleData;break;case S.onnx.TensorProto.DataType.UINT32:case S.onnx.TensorProto.DataType.UINT64:B=x.uint64Data;break;default:throw new Error("unspecific error")}if(null==B)throw new Error("failed to populate data from a tensorproto value");const U=L.data;if(U.length!==B.length)throw new Error("array length mismatch");for(let W=0;W<B.length;W++){const H=B[W];U[W]=R.default.isLong(H)?d(H,x.dataType):H}}return L}static fromData(x,D,P){return new g(D,P,void 0,void 0,x)}static fromOrtTensor(x){if(!x)throw new Error("cannot construct Value from an empty tensor");const D=C.ProtoUtil.tensorDimsFromORTFormat(x),P=C.ProtoUtil.tensorDataTypeFromProto(x.dataType()),L=new g(D,P);if("string"===P)for(let B=0;B<x.stringDataLength();B++)L.data[B]=x.stringData(B);else if(x.rawDataArray()&&"number"==typeof x.rawDataLength()&&x.rawDataLength()>0){const B=L.data,U=new DataView(x.rawDataArray().buffer,x.rawDataArray().byteOffset,x.rawDataLength()),W=h(x.dataType()),H=x.rawDataLength()/W;if(x.rawDataLength()%W!=0)throw new Error("invalid buffer length");if(B.length!==H)throw new Error("buffer length mismatch");for(let re=0;re<H;re++){const ue=f(U,x.dataType(),re*W);B[re]=ue}}return L}}function h(b){switch(b){case S.onnx.TensorProto.DataType.UINT8:case S.onnx.TensorProto.DataType.INT8:case S.onnx.TensorProto.DataType.BOOL:return 1;case S.onnx.TensorProto.DataType.UINT16:case S.onnx.TensorProto.DataType.INT16:return 2;case S.onnx.TensorProto.DataType.FLOAT:case S.onnx.TensorProto.DataType.INT32:case S.onnx.TensorProto.DataType.UINT32:return 4;case S.onnx.TensorProto.DataType.INT64:case S.onnx.TensorProto.DataType.DOUBLE:case S.onnx.TensorProto.DataType.UINT64:return 8;default:throw new Error(`cannot calculate sizeof() on type ${S.onnx.TensorProto.DataType[b]}`)}}function l(b){switch(b){case"bool":case"uint8":return Uint8Array;case"int8":return Int8Array;case"int16":return Int16Array;case"uint16":return Uint16Array;case"int32":return Int32Array;case"uint32":return Uint32Array;case"int64":return BigInt64Array;case"float32":return Float32Array;case"float64":return Float64Array;default:throw new Error("unspecified error")}}function d(b,x){if(x===S.onnx.TensorProto.DataType.INT64||x===v.TensorDataType.INT64){if(b.greaterThanOrEqual(2147483648)||b.lessThan(-2147483648))throw new TypeError("int64 is not supported")}else{if(x!==S.onnx.TensorProto.DataType.UINT32&&x!==v.TensorDataType.UINT32&&x!==S.onnx.TensorProto.DataType.UINT64&&x!==v.TensorDataType.UINT64)throw new TypeError(`not a LONG type: ${S.onnx.TensorProto.DataType[x]}`);if(b.greaterThanOrEqual(4294967296)||b.lessThan(0))throw new TypeError("uint64 is not supported")}return b.toNumber()}function f(b,x,D){switch(x){case S.onnx.TensorProto.DataType.BOOL:case S.onnx.TensorProto.DataType.UINT8:return b.getUint8(D);case S.onnx.TensorProto.DataType.INT8:return b.getInt8(D);case S.onnx.TensorProto.DataType.UINT16:return b.getUint16(D,!0);case S.onnx.TensorProto.DataType.INT16:return b.getInt16(D,!0);case S.onnx.TensorProto.DataType.FLOAT:return b.getFloat32(D,!0);case S.onnx.TensorProto.DataType.INT32:return b.getInt32(D,!0);case S.onnx.TensorProto.DataType.UINT32:return b.getUint32(D,!0);case S.onnx.TensorProto.DataType.INT64:return d(R.default.fromBits(b.getUint32(D,!0),b.getUint32(D+4,!0),!1),x);case S.onnx.TensorProto.DataType.DOUBLE:return b.getFloat64(D,!0);case S.onnx.TensorProto.DataType.UINT64:return d(R.default.fromBits(b.getUint32(D,!0),b.getUint32(D+4,!0),!0),x);default:throw new Error(`cannot read from DataView for type ${S.onnx.TensorProto.DataType[x]}`)}}E.Tensor=g},7273:function(ge,E,$){"use strict";var F=this&&this.__importDefault||function(x){return x&&x.__esModule?x:{default:x}};Object.defineProperty(E,"__esModule",{value:!0}),E.decodeUtf8String=E.MAX_CLIP=E.MIN_CLIP=E.PoolConvUtil=E.ReduceUtil=E.SplitUtil=E.MathUtil=E.ShapeUtil=E.LongUtil=E.ProtoUtil=E.GemmUtil=E.arrayCopyHelper=E.BroadcastUtil=E.MatMulUtil=E.ArrayUtil=E.assert=E.checkInputsShape=void 0;const N=$(5686),R=F($(1583)),k=$(2446),S=$(9240);E.checkInputsShape=function(x,...D){if(!x||x.length!==D.length)return!1;for(let P=0;P<x.length;P++)if(!x[P].dims||x[P].dims.length!==D[P])return!1;return!0},E.assert=function(x,D){if(!x)throw new Error("string"==typeof D?D:D())},E.ArrayUtil=class{static arraysEqual(x,D){if(x.length!==D.length)return!1;for(let P=0;P<x.length;P++)if(x[P]!==D[P])return!1;return!0}};class C{static preprocessInputShapes(D,P){return[1===D.length?[1,D[0]]:D,1===P.length?[P[0],1]:P]}static postprocessOutputShape(D,P,L){1===P&&D.splice(D.length-2,1),1===L&&D.pop()}static calcMatMulShape(D,P){return D[1]!==P[0]?void 0:[D[0],P[1]]}}E.MatMulUtil=C;class v{static calcShape(D,P,L=!1){const B=D.length,U=P.length;if(0===B)return P;if(0===U)return D;const W=Math.max(D.length,P.length),H=new Array(W);if(L){if(B<2||U<2)return;const re=C.calcMatMulShape([D[B-2],D[B-1]],[P[U-2],P[U-1]]);if(void 0===re)return;[H[W-2],H[W-1]]=re}for(let re=L?3:1;re<=W;re++){const ue=B-re<0?1:D[B-re],te=U-re<0?1:P[U-re];if(ue!==te&&ue>1&&te>1)return;H[W-re]=Math.max(ue,te)}return H}static index(D,P){const L=new Array(P.length);return v.fillIndex(D,P,L),L}static fillIndex(D,P,L){const B=D.length-P.length;for(let U=0;U<P.length;U++)L[U]=D[B+U]%P[U]}static calc(D,P,L,B,U){const W=v.calcShape(D.dims,P.dims);if(W){if(B&&!l.areEqual(W,D.dims))return;const H=l.size(W),re=B?D:new S.Tensor(W,U||D.type);if(0===W.length)re.set([],L(D.get([]),P.get([])));else{const ue=new Array(W.length),te=new Array(D.dims.length),se=new Array(P.dims.length);let Y,X=0,we=0,K=!1,ie=!1;0===D.dims.length&&(X=D.get([]),K=!0),0===P.dims.length&&(we=P.get([]),ie=!0);for(let ce=0;ce<H;ce++){Y=ce;for(let qe=W.length-1;qe>=0;qe--)ue[qe]=Y%W[qe],Y=Math.floor(Y/W[qe]);K||(v.fillIndex(ue,D.dims,te),X=D.get(te)),ie||(v.fillIndex(ue,P.dims,se),we=P.get(se)),re.set(ue,L(X,we))}}return re}}static isValidBroadcast(D,P){const L=D.length,B=P.length;if(L>B)return!1;for(let U=1;U<=L;U++)if(1!==D[L-U]&&D[L-U]!==P[B-U])return!1;return!0}static getBroadcastDims(D,P){const L=D.length,B=[];for(let U=0;U<L;U++){const W=L-1-U;(P[P.length-1-U]||1)>1&&1===(D[W]||1)&&B.unshift(W)}return B}}E.BroadcastUtil=v,E.arrayCopyHelper=function(x,D,P,L,B){if(L<0||L>=D.length)throw new Error("sourceIndex out of bounds");if(P<0||P>=x.length)throw new Error("targetIndex out of bounds");if(L+B>D.length)throw new Error("source indices to be copied are outside bounds");if(P+B>x.length)throw new Error("target array is too small to hold result");for(let U=0;U<B;U++)x[P+U]=D[L+U]},E.GemmUtil=class{static getShapeOfGemmResult(x,D,P,L,B){if(2!==x.length||2!==P.length)throw new Error("shape need to be of size 2");let U,W,H;D?(U=x[1],W=x[0]):(U=x[0],W=x[1]);let re=-1;if(L?(H=P[0],re=1):(H=P[1],re=0),P[re]!==W)throw new Error("dimension mismatch");if(U<=0||H<=0||W<=0)throw new Error("invalid shape specified");if(B&&!v.isValidBroadcast(B,[U,H]))throw new Error("gemm: invalid bias shape for broadcast");return[U,H,W]}};class g{static tensorDataTypeFromProto(D){switch(D){case k.onnx.TensorProto.DataType.INT8:return"int8";case k.onnx.TensorProto.DataType.UINT8:return"uint8";case k.onnx.TensorProto.DataType.BOOL:return"bool";case k.onnx.TensorProto.DataType.INT16:return"int16";case k.onnx.TensorProto.DataType.UINT16:return"uint16";case k.onnx.TensorProto.DataType.INT32:return"int32";case k.onnx.TensorProto.DataType.UINT32:return"uint32";case k.onnx.TensorProto.DataType.FLOAT:return"float32";case k.onnx.TensorProto.DataType.DOUBLE:return"float64";case k.onnx.TensorProto.DataType.STRING:return"string";case k.onnx.TensorProto.DataType.INT64:return"int32";case k.onnx.TensorProto.DataType.UINT64:return"uint32";default:throw new Error(`unsupported data type: ${k.onnx.TensorProto.DataType[D]}`)}}static tensorDataTypeStringToEnum(D){switch(D){case"int8":return k.onnx.TensorProto.DataType.INT8;case"uint8":return k.onnx.TensorProto.DataType.UINT8;case"bool":return k.onnx.TensorProto.DataType.BOOL;case"int16":return k.onnx.TensorProto.DataType.INT16;case"uint16":return k.onnx.TensorProto.DataType.UINT16;case"int32":return k.onnx.TensorProto.DataType.INT32;case"uint32":return k.onnx.TensorProto.DataType.UINT32;case"float32":return k.onnx.TensorProto.DataType.FLOAT;case"float64":return k.onnx.TensorProto.DataType.DOUBLE;case"string":return k.onnx.TensorProto.DataType.STRING;case"int64":return k.onnx.TensorProto.DataType.INT64;case"uint64":return k.onnx.TensorProto.DataType.UINT64;default:throw new Error(`unsupported data type: ${D}`)}}static tensorDimsFromProto(D){return D.map(P=>R.default.isLong(P)?P.toNumber():P)}static tensorValueTypeFromProto(D){return{tensorType:g.tensorDataTypeFromProto(D.elemType),shape:{dims:g.tensorDimsFromProto(D.shape.dim.map(P=>P.dimValue))}}}static tensorDimsFromORTFormat(D){const P=[];for(let L=0;L<D.dimsLength();L++)P.push(h.longToNumber(D.dims(L)));return P}static tensorAttributesFromORTFormat(D){const P=[];for(let L=0;L<D.attributesLength();L++)P.push(D.attributes(L));return P}}E.ProtoUtil=g;class h{static longToNumber(D,P){return R.default.isLong(D)?D.toNumber():D instanceof N.flatbuffers.Long?R.default.fromValue({low:D.low,high:D.high,unsigned:null!=P&&P}).toNumber():D}static isLong(D){return R.default.isLong(D)||D instanceof N.flatbuffers.Long}}E.LongUtil=h;class l{static size(D){return l.getSizeFromDimensionRange(D,0,D.length)}static sizeFromDimension(D,P){if(P<0||P>D.length)throw new Error(`invalid dimension of ${P} for sizeFromDimension as Tensor has ${D.length} dimensions.`);return l.getSizeFromDimensionRange(D,P,D.length)}static sizeToDimension(D,P){if(P<0||P>D.length)throw new Error(`invalid dimension of ${P} for sizeToDimension as Tensor has ${D.length} dimensions.`);return l.getSizeFromDimensionRange(D,0,P)}static getSizeFromDimensionRange(D,P,L){let B=1;for(let U=P;U<L;U++){if(D[U]<=0)throw new Error("cannot get valid size from specified dimension range. Most likely the range contains 0 or negative values in them.");B*=D[U]}return B}static computeStrides(D){const P=D.length;if(0===P)return[];if(1===P)return[1];const L=new Array(P);L[P-1]=1,L[P-2]=D[P-1];for(let B=P-3;B>=0;--B)L[B]=L[B+1]*D[B+1];return L}static transpose(D){return D.slice().reverse()}static indicesToOffset(D,P,L){void 0===L&&(L=D.length);let B=0;for(let U=0;U<L;++U)B+=P[U]*D[U];return B}static offsetToIndices(D,P){const L=P.length;if(0===L)return[];if(1===L)return[D*P[0]];const B=new Array(P.length);for(let U=0;U<B.length-1;++U)B[U]=Math.floor(D/P[U]),D-=B[U]*P[U];return B[B.length-1]=D,B}static normalizeAxis(D,P){if(D<-P&&D>=P)throw new Error("unsupported axis for this operation.");return D<0?D+P:D}static normalizeAxes(D,P){return D.map(L=>this.normalizeAxis(L,P))}static incrementIndex(D,P,L){if(0===P.length||0===D.length)throw new Error("Index incrementing unsupported for scalar Tensor");if(void 0===L)L=P.length;else if(L<=0||L>P.length)throw new Error("Incorrect axis to increment on");for(let B=L-1;B>=0&&(D[B]++,!(D[B]<P[B]));--B)D[B]=0}static calculateReshapedDims(D,P){if(0===P.length){if(0===D.length||1===l.size(D))return[];throw new Error("cannot reshape to a scalar Tensor")}const L=P.length,B=new Array(L);let U=-1,W=1;for(let re=0;re<L;re++){if(P[re]<-1)throw new Error("a dimension in shape hints cannot be less than -1");if(-1===P[re]){if(-1!==U)throw new Error("at most one dimension in shape hints can be -1");U=re}else{if(0===P[re]){if(re>=D.length)throw new Error("the dimension with value zero exceeds the dimension size of the input tensor");B[re]=D[re]}else B[re]=P[re];W*=B[re]}}const H=l.size(D);if(-1!==U){if(H%W!=0)throw new Error(`the input tensor cannot be reshaped to the requested shape. Input shape: [${D}] Output shape: [${P}]`);B[U]=H/W}else if(W!==H)throw new Error("reshapedDims and originalDims don't have matching sizes");return B}static sortBasedOnPerm(D,P){return P?P.map(L=>D[L]):D.slice().reverse()}static padShape(D,P){const L=D.length;return D.map((B,U)=>B+P[U]+P[U+L])}static areEqual(D,P){return D.length===P.length&&D.every((L,B)=>L===P[B])}static validateDimsAndCalcSize(D){if(D.length>6)throw new TypeError("Only rank 0 to 6 is supported for tensor shape.");let P=1;for(const L of D){if(!Number.isInteger(L))throw new TypeError(`Invalid shape: ${L} is not an integer`);if(L<0||L>2147483647)throw new TypeError(`Invalid shape: length ${L} is not allowed`);P*=L}return P}static flattenShape(D,P){P<0&&(P+=D.length);const L=D.reduce((U,W)=>U*W,1),B=D.slice(P).reduce((U,W)=>U*W,1);return[L/B,B]}static squeezeShape(D,P){const L=new Array;P=l.normalizeAxes(P,D.length);for(let B=0;B<D.length;B++){const U=P.indexOf(B)>=0;if(U&&1!==D[B])throw new Error("squeeze an axis of size different than 1");(0===P.length&&D[B]>1||P.length>0&&!U)&&L.push(D[B])}return L}static unsqueezeShape(D,P){const L=new Array(D.length+P.length);L.fill(0);for(let U=0;U<P.length;U++){const W=l.normalizeAxis(P[U],L.length);if(W>=L.length)throw new Error("'axes' has an out of range axis");if(0!==L[W])throw new Error("'axes' has a duplicate axis");L[W]=1}let B=0;for(let U=0;U<L.length;U++)0===L[U]&&(L[U]=D[B++]);if(B!==D.length)throw new Error("the unsqueezed dimension could not be established");return L}}E.ShapeUtil=l,E.MathUtil=class{static sqr(x,D,P,L,B){if(L<0||L>=D.length)throw new Error("sourceIndex out of bounds");if(P<0||P>=x.length)throw new Error("targetIndex out of bounds");if(L+B>D.length)throw new Error("source indices to be copied are outside bounds");if(P+B>x.length)throw new Error("target array is too small to hold result");for(let U=0;U<B;U++)x[P+U]+=Math.pow(D[L+U],2)}static axpy(x,D,P,L,B,U){if(L<0||L>=D.length)throw new Error("sourceIndex out of bounds");if(P<0||P>=x.length)throw new Error("targetIndex out of bounds");if(L+B>D.length)throw new Error("source indices to be copied are outside bounds");if(P+B>x.length)throw new Error("target array is too small to hold result");for(let W=0;W<B;W++)x[P+W]+=U*D[L+W]}static powx(x,D,P,L,B,U){if(L<0||L>=D.length)throw new Error("sourceIndex out of bounds");if(P<0||P>=x.length)throw new Error("targetIndex out of bounds");if(L+B>D.length)throw new Error("source indices to be copied are outside bounds");if(P+B>x.length)throw new Error("target array is too small to hold result");for(let W=0;W<B;W++)x[P+W]=Math.pow(D[L+W],U)}static mul(x,D,P,L,B){if(L<0||L>=D.length)throw new Error("sourceIndex out of bounds");if(P<0||P>=x.length)throw new Error("targetIndex out of bounds");if(L+B>D.length)throw new Error("source indices to be copied are outside bounds");if(P+B>x.length)throw new Error("target array is too small to hold result");for(let U=0;U<B;U++)x[P+U]=D[L+U]*x[P+U]}};class d{static splitShape(D,P,L,B){if(0===L.length){if(!B)throw new Error("need to know number of outputs when the 'split' attribute is not specified");d.determineSplit(D[P],B,L)}const U=[],W=[0];for(let H=0;H<L.length;++H){0!==H&&W.push(W[H-1]+L[H-1]);const re=D.slice();re[P]=L[H],U.push(re)}return[U,W]}static determineSplit(D,P,L){if(D%P!=0)throw new Error("cannot split tensor to equal sized parts");for(let B=0;B<P;++B)L.push(D/P)}}E.SplitUtil=d;class f{static calcReduce(D,P,L,B,U){const W=D.dims.slice(0);0===P.length&&W.forEach((X,we)=>P.push(we));const H=f.calcReduceShape(W,P,!0),re=l.size(H),ue=new S.Tensor(H,D.type),te=l.computeStrides(H),se=l.computeStrides(W),Y=new Array(W.length);for(let X=0;X<re;X++){const we=l.offsetToIndices(X,te);v.fillIndex(we,W,Y),ue.set(we,f.calcReduceByAxis(D.numberData,P,W,0,l.indicesToOffset(Y,se),B,U))}return L?ue:new S.Tensor(f.calcReduceShape(W,P,L),ue.type,void 0,void 0,ue.data,ue.dataId)}static calcReduceByAxis(D,P,L,B,U,W,H){let re=0;if(B>=P.length)return W(D[U]);const ue=P[B],te=ue>=L.length?1:l.size(L.slice(ue+1));for(let se=0;se<L[ue];se++)re=0===se?f.calcReduceByAxis(D,P,L,B+1,U,W,H):H(re,f.calcReduceByAxis(D,P,L,B+1,U,W,H)),U+=te;return re}static calcReduceShape(D,P,L){const B=D.slice();for(let U=0;U<P.length;U++)B[P[U]]=L?1:0;return B.filter(U=>0!==U)}}E.ReduceUtil=f;class b{static adjustPoolAttributes(D,P,L,B,U,W){if(!D&&L.length!==P.length-2)throw new Error("length of specified kernel shapes should be 2 less than length of input dimensions");if(D)for(let H=0;H<P.length-2;H++)H>=L.length?L.push(P[H+2]):L[H]=P[H+2];for(let H=0;H<L.length;H++)if(H<B.length){if(B[H]<0)throw new Error("strides should be greater than or equal to 1")}else B.push(1);for(let H=0;H<L.length;H++)if(H<U.length){if(U[H]<0)throw new Error("dilations should be greater than or equal to 1")}else U.push(1);for(let H=0;H<2*L.length;H++)if(H<W.length){if(W[H]<0)throw new Error("pad should be greater than or equal to 1")}else W.push(0);for(let H=0;H<L.length;H++){if(L[H]<=0)throw new Error("kernel shapes need to be greater than 0");if(W[H]>=L[H]||W[H+L.length]>=L[H])throw new Error("pads should be smaller than kernel")}}static adjustPadsBasedOnAutoPad(D,P,L,B,U,W){if(W){if(U.length!==2*(D.length-2))throw new Error("length of pads should be twice the length of data dimensions");if(P.length!==D.length-2)throw new Error("length of strides should be the length of data dimensions");if(B.length!==D.length-2)throw new Error("length of kernel shapes should be the length of data dimensions");for(let H=0;H<D.length-2;H++)b.adjustPadAndReturnShape(D[H+2],P[H],L[H],B[H],U,H,H+D.length-2,W)}}static computePoolOutputShape(D,P,L,B,U,W,H){if(P.length<=0)throw new Error("input shape must be of size greater than 0");const re=[P[0],P[1]];return b.computeShapeHelper(D,P,re,L,B,U,W,H),re}static computeConvOutputShape(D,P,L,B,U,W,H){if(D.length<=0||P.length<=0)throw new Error("invalid input tensor dims or invalid filter tensor dims");const re=[D[0],P[0]];return b.computeShapeHelper(!1,D,re,L,B,U,W,H),re}static computeShapeHelper(D,P,L,B,U,W,H,re){if(D)for(let ue=0;ue<P.length-2;ue++)L.push(1);else for(let ue=0;ue<P.length-2;ue++)L.push(b.adjustPadAndReturnShape(P[ue+2],B[ue],U[ue],W[ue],H,ue,ue+P.length-2,re))}static adjustPadAndReturnShape(D,P,L,B,U,W,H,re){const ue=L*(B-1)+1;if(!re||"NOTSET"===re)return Math.floor((D+U[W]+U[H]-ue)/P+1);switch(re){case"VALID":return U[W]=0,U[H]=0,Math.floor((D-ue)/P+1);case"SAME_LOWER":case"SAME_UPPER":if(1!==L)throw new Error("Dilation not supported for SAME_UPPER or SAME_LOWER");{const te=((D+P-1)/P-1)*P+B-D;return U[W]=Math.floor("SAME_LOWER"===re?(te+1)/2:te/2),U[H]=te-U[W],Math.floor((D+te-B)/P+1)}default:throw new Error("Unsupported AutoPad type")}}}E.PoolConvUtil=b,E.MIN_CLIP=-34028234663852886e22,E.MAX_CLIP=34028234663852886e22,E.decodeUtf8String=function(x){return(new TextDecoder).decode(x)}},8408:(ge,E)=>{"use strict";Object.defineProperty(E,"__esModule",{value:!0}),E.version=void 0,E.version="1.16.3"},9544:function(ge,E,$){"use strict";var F,N=this&&this.__createBinding||(Object.create?function(te,se,Y,X){void 0===X&&(X=Y);var we=Object.getOwnPropertyDescriptor(se,Y);we&&!("get"in we?!se.__esModule:we.writable||we.configurable)||(we={enumerable:!0,get:function(){return se[Y]}}),Object.defineProperty(te,X,we)}:function(te,se,Y,X){void 0===X&&(X=Y),te[X]=se[Y]}),R=this&&this.__setModuleDefault||(Object.create?function(te,se){Object.defineProperty(te,"default",{enumerable:!0,value:se})}:function(te,se){te.default=se}),k=this&&this.__importStar||function(te){if(te&&te.__esModule)return te;var se={};if(null!=te)for(var Y in te)"default"!==Y&&Object.prototype.hasOwnProperty.call(te,Y)&&N(se,te,Y);return R(se,te),se};Object.defineProperty(E,"__esModule",{value:!0}),E.endProfiling=E.run=E.releaseSession=E.createSession=E.createSessionFinalize=E.createSessionAllocate=E.initializeRuntime=E.initializeWebAssemblyInstance=void 0;const S=$(2235),C=k($(1259)),v=$(263),g=()=>!!S.env.wasm.proxy&&typeof document<"u";let h,l,d,f=!1,b=!1,x=!1;const D=[],P=[],L=[],B=[],U=[],W=[],H=()=>{if(f||!b||x||!h)throw new Error("worker not ready")},re=te=>{switch(te.data.type){case"init-wasm":f=!1,te.data.err?(x=!0,l[1](te.data.err)):(b=!0,l[0]());break;case"init-ort":te.data.err?d[1](te.data.err):d[0]();break;case"create_allocate":te.data.err?D.shift()[1](te.data.err):D.shift()[0](te.data.out);break;case"create_finalize":te.data.err?P.shift()[1](te.data.err):P.shift()[0](te.data.out);break;case"create":te.data.err?L.shift()[1](te.data.err):L.shift()[0](te.data.out);break;case"release":te.data.err?B.shift()[1](te.data.err):B.shift()[0]();break;case"run":te.data.err?U.shift()[1](te.data.err):U.shift()[0](te.data.out);break;case"end-profiling":te.data.err?W.shift()[1](te.data.err):W.shift()[0]()}},ue=typeof document<"u"?null===(F=document?.currentScript)||void 0===F?void 0:F.src:void 0;E.initializeWebAssemblyInstance=_asyncToGenerator(function*(){if(g()){if(b)return;if(f)throw new Error("multiple calls to 'initWasm()' detected.");if(x)throw new Error("previous call to 'initWasm()' failed.");return f=!0,void 0===S.env.wasm.wasmPaths&&ue&&0!==ue.indexOf("blob:")&&(S.env.wasm.wasmPaths=ue.substr(0,+ue.lastIndexOf("/")+1)),new Promise((te,se)=>{h?.terminate(),h=$(8050).Z(),h.onmessage=re,l=[te,se],h.postMessage({type:"init-wasm",in:S.env.wasm})})}return(0,v.initializeWebAssembly)(S.env.wasm)}),E.initializeRuntime=function(){var te=_asyncToGenerator(function*(se){if(g())return H(),new Promise((Y,X)=>{d=[Y,X],h.postMessage({type:"init-ort",in:se})});yield C.initRuntime(se)});return function(se){return te.apply(this,arguments)}}(),E.createSessionAllocate=function(){var te=_asyncToGenerator(function*(se){return g()?(H(),new Promise((Y,X)=>{D.push([Y,X]),h.postMessage({type:"create_allocate",in:{model:se}},[se.buffer])})):C.createSessionAllocate(se)});return function(se){return te.apply(this,arguments)}}(),E.createSessionFinalize=function(){var te=_asyncToGenerator(function*(se,Y){return g()?(H(),new Promise((X,we)=>{P.push([X,we]),h.postMessage({type:"create_finalize",in:{modeldata:se,options:Y}})})):C.createSessionFinalize(se,Y)});return function(se,Y){return te.apply(this,arguments)}}(),E.createSession=function(){var te=_asyncToGenerator(function*(se,Y){return g()?(H(),new Promise((X,we)=>{L.push([X,we]),h.postMessage({type:"create",in:{model:se,options:Y}},[se.buffer])})):C.createSession(se,Y)});return function(se,Y){return te.apply(this,arguments)}}(),E.releaseSession=function(){var te=_asyncToGenerator(function*(se){if(g())return H(),new Promise((Y,X)=>{B.push([Y,X]),h.postMessage({type:"release",in:se})});C.releaseSession(se)});return function(se){return te.apply(this,arguments)}}(),E.run=function(){var te=_asyncToGenerator(function*(se,Y,X,we,K){return g()?(H(),new Promise((ie,ce)=>{U.push([ie,ce]),h.postMessage({type:"run",in:{sessionId:se,inputIndices:Y,inputs:X,outputIndices:we,options:K}},C.extractTransferableBuffers(X))})):C.run(se,Y,X,we,K)});return function(se,Y,X,we,K){return te.apply(this,arguments)}}(),E.endProfiling=function(){var te=_asyncToGenerator(function*(se){if(g())return H(),new Promise((Y,X)=>{W.push([Y,X]),h.postMessage({type:"end-profiling",in:se})});C.endProfiling(se)});return function(se){return te.apply(this,arguments)}}()},7918:(ge,E,$)=>{"use strict";Object.defineProperty(E,"__esModule",{value:!0}),E.setRunOptions=void 0;const F=$(263),N=$(1497);E.setRunOptions=R=>{const k=(0,F.getInstance)();let S=0;const C=[],v=R||{};try{if(void 0===R?.logSeverityLevel)v.logSeverityLevel=2;else if("number"!=typeof R.logSeverityLevel||!Number.isInteger(R.logSeverityLevel)||R.logSeverityLevel<0||R.logSeverityLevel>4)throw new Error(`log serverity level is not valid: ${R.logSeverityLevel}`);if(void 0===R?.logVerbosityLevel)v.logVerbosityLevel=0;else if("number"!=typeof R.logVerbosityLevel||!Number.isInteger(R.logVerbosityLevel))throw new Error(`log verbosity level is not valid: ${R.logVerbosityLevel}`);void 0===R?.terminate&&(v.terminate=!1);let g=0;return void 0!==R?.tag&&(g=(0,N.allocWasmString)(R.tag,C)),S=k._OrtCreateRunOptions(v.logSeverityLevel,v.logVerbosityLevel,!!v.terminate,g),0===S&&(0,N.checkLastError)("Can't create run options."),void 0!==R?.extra&&(0,N.iterateExtraOptions)(R.extra,"",new WeakSet,(h,l)=>{const d=(0,N.allocWasmString)(h,C),f=(0,N.allocWasmString)(l,C);0!==k._OrtAddRunConfigEntry(S,d,f)&&(0,N.checkLastError)(`Can't set a run config entry: ${h} - ${l}.`)}),[S,C]}catch(g){throw 0!==S&&k._OrtReleaseRunOptions(S),C.forEach(h=>k._free(h)),g}}},6640:(ge,E,$)=>{"use strict";Object.defineProperty(E,"__esModule",{value:!0}),E.OnnxruntimeWebAssemblySessionHandler=void 0;const F=$(2806),N=$(2235),R=$(2850),k=$(9544);let S;E.OnnxruntimeWebAssemblySessionHandler=class{createSessionAllocate(C){return _asyncToGenerator(function*(){const v=yield fetch(C);if(200!==v.status)throw new Error(`failed to load model: ${C}`);const g=yield v.arrayBuffer();return(0,k.createSessionAllocate)(new Uint8Array(g))})()}loadModel(C,v){var g=this;return _asyncToGenerator(function*(){if(S||(yield(0,k.initializeRuntime)(N.env),S=!0),"string"==typeof C)if(typeof process<"u"&&process.versions&&process.versions.node){const h=yield(0,R.promisify)(F.readFile)(C);[g.sessionId,g.inputNames,g.outputNames]=yield(0,k.createSession)(h,v)}else{const h=yield g.createSessionAllocate(C);[g.sessionId,g.inputNames,g.outputNames]=yield(0,k.createSessionFinalize)(h,v)}else[g.sessionId,g.inputNames,g.outputNames]=yield(0,k.createSession)(C,v)})()}dispose(){var C=this;return _asyncToGenerator(function*(){return(0,k.releaseSession)(C.sessionId)})()}run(C,v,g){var h=this;return _asyncToGenerator(function*(){const l=[],d=[];Object.entries(C).forEach(D=>{const P=D[0],L=D[1],B=h.inputNames.indexOf(P);if(-1===B)throw new Error(`invalid input '${P}'`);l.push(L),d.push(B)});const f=[];Object.entries(v).forEach(D=>{const P=D[0],L=h.outputNames.indexOf(P);if(-1===L)throw new Error(`invalid output '${P}'`);f.push(L)});const b=yield(0,k.run)(h.sessionId,d,l.map(D=>[D.type,D.dims,D.data]),f,g),x={};for(let D=0;D<b.length;D++)x[h.outputNames[f[D]]]=new N.Tensor(b[D][0],b[D][2],b[D][1]);return x})()}startProfiling(){}endProfiling(){(0,k.endProfiling)(this.sessionId)}}},7622:(ge,E,$)=>{"use strict";Object.defineProperty(E,"__esModule",{value:!0}),E.setSessionOptions=void 0;const F=$(263),N=$(1497);E.setSessionOptions=R=>{var k,S,C,v;const g=(0,F.getInstance)();let h=0;const l=[],d=R||{};(f=>{f.extra||(f.extra={}),f.extra.session||(f.extra.session={});const b=f.extra.session;b.use_ort_model_bytes_directly||(b.use_ort_model_bytes_directly="1"),f.executionProviders&&f.executionProviders.some(x=>"webgpu"===("string"==typeof x?x:x.name))&&(f.enableMemPattern=!1)})(d);try{const f=(B=>{switch(B){case"disabled":return 0;case"basic":return 1;case"extended":return 2;case"all":return 99;default:throw new Error(`unsupported graph optimization level: ${B}`)}})(null!==(k=d.graphOptimizationLevel)&&void 0!==k?k:"all"),b=(B=>{switch(B){case"sequential":return 0;case"parallel":return 1;default:throw new Error(`unsupported execution mode: ${B}`)}})(null!==(S=d.executionMode)&&void 0!==S?S:"sequential"),x="string"==typeof d.logId?(0,N.allocWasmString)(d.logId,l):0,D=null!==(C=d.logSeverityLevel)&&void 0!==C?C:2;if(!Number.isInteger(D)||D<0||D>4)throw new Error(`log serverity level is not valid: ${D}`);const P=null!==(v=d.logVerbosityLevel)&&void 0!==v?v:0;if(!Number.isInteger(P)||P<0||P>4)throw new Error(`log verbosity level is not valid: ${P}`);const L="string"==typeof d.optimizedModelFilePath?(0,N.allocWasmString)(d.optimizedModelFilePath,l):0;return h=g._OrtCreateSessionOptions(f,!!d.enableCpuMemArena,!!d.enableMemPattern,b,!!d.enableProfiling,0,x,D,P,L),0===h&&(0,N.checkLastError)("Can't create session options."),d.executionProviders&&((B,U,W)=>{for(const H of U){let re="string"==typeof H?H:H.name;switch(re){case"xnnpack":re="XNNPACK";break;case"webnn":if(re="WEBNN","string"!=typeof H){const te=H;if(te?.deviceType){const se=(0,N.allocWasmString)("deviceType",W),Y=(0,N.allocWasmString)(te.deviceType,W);0!==(0,F.getInstance)()._OrtAddSessionConfigEntry(B,se,Y)&&(0,N.checkLastError)(`Can't set a session config entry: 'deviceType' - ${te.deviceType}.`)}if(te?.powerPreference){const se=(0,N.allocWasmString)("powerPreference",W),Y=(0,N.allocWasmString)(te.powerPreference,W);0!==(0,F.getInstance)()._OrtAddSessionConfigEntry(B,se,Y)&&(0,N.checkLastError)(`Can't set a session config entry: 'powerPreference' - ${te.powerPreference}.`)}}break;case"webgpu":re="JS";break;case"wasm":case"cpu":continue;default:throw new Error(`not supported execution provider: ${re}`)}const ue=(0,N.allocWasmString)(re,W);0!==(0,F.getInstance)()._OrtAppendExecutionProvider(B,ue)&&(0,N.checkLastError)(`Can't append execution provider: ${re}.`)}})(h,d.executionProviders,l),void 0!==d.extra&&(0,N.iterateExtraOptions)(d.extra,"",new WeakSet,(B,U)=>{const W=(0,N.allocWasmString)(B,l),H=(0,N.allocWasmString)(U,l);0!==g._OrtAddSessionConfigEntry(h,W,H)&&(0,N.checkLastError)(`Can't set a session config entry: ${B} - ${U}.`)}),[h,l]}catch(f){throw 0!==h&&g._OrtReleaseSessionOptions(h),l.forEach(b=>g._free(b)),f}}},7917:(ge,E)=>{"use strict";Object.defineProperty(E,"__esModule",{value:!0}),E.logLevelStringToEnum=E.tensorTypeToTypedArrayConstructor=E.getTensorElementSize=E.tensorDataTypeEnumToString=E.tensorDataTypeStringToEnum=void 0,E.tensorDataTypeStringToEnum=$=>{switch($){case"int8":return 3;case"uint8":return 2;case"bool":return 9;case"int16":return 5;case"uint16":return 4;case"int32":return 6;case"uint32":return 12;case"float16":return 10;case"float32":return 1;case"float64":return 11;case"string":return 8;case"int64":return 7;case"uint64":return 13;default:throw new Error(`unsupported data type: ${$}`)}},E.tensorDataTypeEnumToString=$=>{switch($){case 3:return"int8";case 2:return"uint8";case 9:return"bool";case 5:return"int16";case 4:return"uint16";case 6:return"int32";case 12:return"uint32";case 10:return"float16";case 1:return"float32";case 11:return"float64";case 8:return"string";case 7:return"int64";case 13:return"uint64";default:throw new Error(`unsupported data type: ${$}`)}},E.getTensorElementSize=$=>[void 0,4,1,1,2,2,4,8,void 0,1,2,8,4,8,void 0,void 0,void 0][$],E.tensorTypeToTypedArrayConstructor=$=>{switch($){case"float16":case"uint16":return Uint16Array;case"float32":return Float32Array;case"uint8":case"bool":return Uint8Array;case"int8":return Int8Array;case"int16":return Int16Array;case"int32":return Int32Array;case"float64":return Float64Array;case"uint32":return Uint32Array;case"int64":return BigInt64Array;case"uint64":return BigUint64Array;default:throw new Error(`unsupported type: ${$}`)}},E.logLevelStringToEnum=$=>{switch($){case"verbose":return 0;case"info":return 1;case"warning":return 2;case"error":return 3;case"fatal":return 4;default:throw new Error(`unsupported logging level: ${$}`)}}},1259:(ge,E,$)=>{"use strict";Object.defineProperty(E,"__esModule",{value:!0}),E.extractTransferableBuffers=E.endProfiling=E.run=E.releaseSession=E.createSession=E.createSessionFinalize=E.createSessionAllocate=E.initRuntime=void 0;const F=$(7918),N=$(7622),R=$(7917),k=$(263),S=$(1497);E.initRuntime=function(){var v=_asyncToGenerator(function*(g){var h,l;h=g.wasm.numThreads,l=(0,R.logLevelStringToEnum)(g.logLevel),0!==(0,k.getInstance)()._OrtInit(h,l)&&(0,S.checkLastError)("Can't initialize onnxruntime.")});return function(g){return v.apply(this,arguments)}}();const C=new Map;E.createSessionAllocate=v=>{const g=(0,k.getInstance)(),h=g._malloc(v.byteLength);if(0===h)throw new Error(`Can't create a session. failed to allocate a buffer of size ${v.byteLength}.`);return g.HEAPU8.set(v,h),[h,v.byteLength]},E.createSessionFinalize=(v,g)=>{const h=(0,k.getInstance)();let l=0,d=0,f=[];const b=[],x=[];try{[d,f]=(0,N.setSessionOptions)(g),l=h._OrtCreateSession(v[0],v[1],d),0===l&&(0,S.checkLastError)("Can't create a session.");const[D,P]=(U=>{const W=(0,k.getInstance)(),H=W.stackSave();try{const re=W.stackAlloc(8);return 0!==W._OrtGetInputOutputCount(U,re,re+4)&&(0,S.checkLastError)("Can't get session input/output count."),[W.HEAP32[re/4],W.HEAP32[re/4+1]]}finally{W.stackRestore(H)}})(l),L=[],B=[];for(let U=0;U<D;U++){const W=h._OrtGetInputName(l,U);0===W&&(0,S.checkLastError)("Can't get an input name."),b.push(W),L.push(h.UTF8ToString(W))}for(let U=0;U<P;U++){const W=h._OrtGetOutputName(l,U);0===W&&(0,S.checkLastError)("Can't get an output name."),x.push(W),B.push(h.UTF8ToString(W))}return C.set(l,[l,b,x]),[l,L,B]}catch(D){throw b.forEach(P=>h._OrtFree(P)),x.forEach(P=>h._OrtFree(P)),0!==l&&h._OrtReleaseSession(l),D}finally{h._free(v[0]),0!==d&&h._OrtReleaseSessionOptions(d),f.forEach(D=>h._free(D))}},E.createSession=(v,g)=>{const h=(0,E.createSessionAllocate)(v);return(0,E.createSessionFinalize)(h,g)},E.releaseSession=v=>{const g=(0,k.getInstance)(),h=C.get(v);if(!h)throw new Error(`cannot release session. invalid session id: ${v}`);const[l,d,f]=h;d.forEach(b=>g._OrtFree(b)),f.forEach(b=>g._OrtFree(b)),g._OrtReleaseSession(l),C.delete(v)},E.run=function(){var v=_asyncToGenerator(function*(g,h,l,d,f){const b=(0,k.getInstance)(),x=C.get(g);if(!x)throw new Error(`cannot run inference. invalid session id: ${g}`);const[D,P,L]=x,B=h.length,U=d.length;let W=0,H=[];const re=[],ue=[];try{[W,H]=(0,F.setRunOptions)(f);for(let K=0;K<B;K++){const ie=l[K][0],ce=l[K][1],qe=l[K][2];let Be,at;if(Array.isArray(qe)){at=4*qe.length,Be=b._malloc(at),ue.push(Be);let bt=Be/4;for(let wt=0;wt<qe.length;wt++){if("string"!=typeof qe[wt])throw new TypeError(`tensor data at index ${wt} is not a string`);b.HEAPU32[bt++]=(0,S.allocWasmString)(qe[wt],ue)}}else at=qe.byteLength,Be=b._malloc(at),ue.push(Be),b.HEAPU8.set(new Uint8Array(qe.buffer,qe.byteOffset,at),Be);const rt=b.stackSave(),ot=b.stackAlloc(4*ce.length);try{let bt=ot/4;ce.forEach(Mt=>b.HEAP32[bt++]=Mt);const wt=b._OrtCreateTensor((0,R.tensorDataTypeStringToEnum)(ie),Be,at,ot,ce.length);0===wt&&(0,S.checkLastError)(`Can't create tensor for input[${K}].`),re.push(wt)}finally{b.stackRestore(rt)}}const te=b.stackSave(),se=b.stackAlloc(4*B),Y=b.stackAlloc(4*B),X=b.stackAlloc(4*U),we=b.stackAlloc(4*U);try{let K=se/4,ie=Y/4,ce=X/4,qe=we/4;for(let ot=0;ot<B;ot++)b.HEAPU32[K++]=re[ot],b.HEAPU32[ie++]=P[h[ot]];for(let ot=0;ot<U;ot++)b.HEAPU32[ce++]=0,b.HEAPU32[qe++]=L[d[ot]];let Be=b._OrtRun(D,Y,se,B,we,U,X,W);const at=b.jsepRunPromise;at&&void 0!==at.then&&(Be=yield at);const rt=[];0!==Be&&(0,S.checkLastError)("failed to call OrtRun().");for(let ot=0;ot<U;ot++){const bt=b.HEAPU32[X/4+ot],wt=b.stackSave(),Mt=b.stackAlloc(16);let un,_n=0;try{Be=b._OrtGetTensorData(bt,Mt,Mt+4,Mt+8,Mt+12),0!==Be&&(0,S.checkLastError)(`Can't access output tensor data on index ${ot}.`);let or=Mt/4;const Tr=b.HEAPU32[or++];_n=b.HEAPU32[or++];const Cs=b.HEAPU32[or++],ki=b.HEAPU32[or++],Br=[];for(let Cn=0;Cn<ki;Cn++)Br.push(b.HEAPU32[Cs/4+Cn]);b._OrtFree(Cs);const Ni=0===Br.length?1:Br.reduce((Cn,Is)=>Cn*Is);if(un=(0,R.tensorDataTypeEnumToString)(Tr),"string"===un){const Cn=[];let Is=_n/4;for(let Pr=0;Pr<Ni;Pr++){const zr=b.HEAPU32[Is++];Cn.push(b.UTF8ToString(zr,Pr===Ni-1?void 0:b.HEAPU32[Is]-zr))}rt.push([un,Br,Cn])}else{const Cn=new((0,R.tensorTypeToTypedArrayConstructor)(un))(Ni);new Uint8Array(Cn.buffer,Cn.byteOffset,Cn.byteLength).set(b.HEAPU8.subarray(_n,_n+Cn.byteLength)),rt.push([un,Br,Cn])}}finally{b.stackRestore(wt),"string"===un&&_n&&b._free(_n),b._OrtReleaseTensor(bt)}}return rt}finally{b.stackRestore(te)}}finally{re.forEach(te=>b._OrtReleaseTensor(te)),ue.forEach(te=>b._free(te)),0!==W&&b._OrtReleaseRunOptions(W),H.forEach(te=>b._free(te))}});return function(g,h,l,d,f){return v.apply(this,arguments)}}(),E.endProfiling=v=>{const g=(0,k.getInstance)(),h=C.get(v);if(!h)throw new Error("invalid session id");const d=g._OrtEndProfiling(h[0]);0===d&&(0,S.checkLastError)("Can't get an profile file name."),g._OrtFree(d)},E.extractTransferableBuffers=v=>{const g=[];for(const h of v){const l=h[2];!Array.isArray(l)&&l.buffer&&g.push(l.buffer)}return g}},263:function(ge,E,$){"use strict";var F=this&&this.__createBinding||(Object.create?function(d,f,b,x){void 0===x&&(x=b);var D=Object.getOwnPropertyDescriptor(f,b);D&&!("get"in D?!f.__esModule:D.writable||D.configurable)||(D={enumerable:!0,get:function(){return f[b]}}),Object.defineProperty(d,x,D)}:function(d,f,b,x){void 0===x&&(x=b),d[x]=f[b]}),N=this&&this.__setModuleDefault||(Object.create?function(d,f){Object.defineProperty(d,"default",{enumerable:!0,value:f})}:function(d,f){d.default=f}),R=this&&this.__importStar||function(d){if(d&&d.__esModule)return d;var f={};if(null!=d)for(var b in d)"default"!==b&&Object.prototype.hasOwnProperty.call(d,b)&&F(f,d,b);return N(f,d),f};Object.defineProperty(E,"__esModule",{value:!0}),E.dispose=E.getInstance=E.initializeWebAssembly=void 0;const k=R($(6449)),S=$(932),C=$(3474);let v,g=!1,h=!1,l=!1;E.initializeWebAssembly=function(){var d=_asyncToGenerator(function*(f){if(g)return Promise.resolve();if(h)throw new Error("multiple calls to 'initializeWebAssembly()' detected.");if(l)throw new Error("previous call to 'initializeWebAssembly()' failed.");h=!0;const b=f.initTimeout,D=f.simd,P=f.numThreads>1&&(()=>{try{return typeof SharedArrayBuffer<"u"&&(typeof MessageChannel<"u"&&(new MessageChannel).port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11])))}catch{return!1}})(),L=D&&(()=>{try{return WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,30,1,28,0,65,0,253,15,253,12,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,253,186,1,26,11]))}catch{return!1}})(),B=f.wasmPaths,U="string"==typeof B?B:void 0,W=(te=L,P?te?"ort-wasm-simd-threaded.wasm":"ort-wasm-threaded.wasm":te?"ort-wasm-simd.wasm":"ort-wasm.wasm"),H="object"==typeof B?B[W]:void 0;var te;let re=!1;const ue=[];if(b>0&&ue.push(new Promise(te=>{setTimeout(()=>{re=!0,te()},b)})),ue.push(new Promise((te,se)=>{const Y=P?C:S,X={locateFile:(we,K)=>P&&we.endsWith(".worker.js")&&typeof Blob<"u"?URL.createObjectURL(new Blob([$(4154)],{type:"text/javascript"})):we.endsWith(".wasm")?H||(U??K)+W:K+we};if(P)if(typeof Blob>"u")X.mainScriptUrlOrBlob=k.join(__dirname,"ort-wasm-threaded.js");else{const we=`var ortWasmThreaded=(function(){var _scriptDir;return ${Y.toString()}})();`;X.mainScriptUrlOrBlob=new Blob([we],{type:"text/javascript"})}Y(X).then(we=>{h=!1,g=!0,v=we,te()},we=>{h=!1,l=!0,se(we)})})),yield Promise.race(ue),re)throw new Error(`WebAssembly backend initializing failed due to timeout: ${b}ms`)});return function(f){return d.apply(this,arguments)}}(),E.getInstance=()=>{if(g&&v)return v;throw new Error("WebAssembly is not initialized yet.")},E.dispose=()=>{var d;!g||h||l||(h=!0,null===(d=v.PThread)||void 0===d||d.terminateAllThreads(),v=void 0,h=!1,g=!1,l=!0)}},1497:(ge,E,$)=>{"use strict";Object.defineProperty(E,"__esModule",{value:!0}),E.checkLastError=E.iterateExtraOptions=E.allocWasmString=void 0;const F=$(263);E.allocWasmString=(N,R)=>{const k=(0,F.getInstance)(),S=k.lengthBytesUTF8(N)+1,C=k._malloc(S);return k.stringToUTF8(N,C,S),R.push(C),C},E.iterateExtraOptions=(N,R,k,S)=>{if("object"==typeof N&&null!==N){if(k.has(N))throw new Error("Circular reference in options");k.add(N)}Object.entries(N).forEach(([C,v])=>{const g=R?R+C:C;if("object"==typeof v)(0,E.iterateExtraOptions)(v,g+".",k,S);else if("string"==typeof v||"number"==typeof v)S(g,v.toString());else{if("boolean"!=typeof v)throw new Error("Can't handle extra config type: "+typeof v);S(g,v?"1":"0")}})},E.checkLastError=N=>{const R=(0,F.getInstance)(),k=R.stackSave();try{const S=R.stackAlloc(8);R._OrtGetLastError(S,S+4);const C=R.HEAP32[S/4],v=R.HEAPU32[S/4+1],g=v?R.UTF8ToString(v):"";throw new Error(`${N} ERROR_CODE: ${C}, ERROR_MESSAGE: ${g}`)}finally{R.stackRestore(k)}}},8050:(ge,E,$)=>{"use strict";$.d(E,{Z:()=>R});var F=$(6614),N=$.n(F);function R(){return N()('/*!\n* ONNX Runtime Web v1.16.3\n* Copyright (c) Microsoft Corporation. All rights reserved.\n* Licensed under the MIT License.\n*/\n(()=>{var e={918:(e,t,r)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.setRunOptions=void 0;const n=r(263),a=r(497);t.setRunOptions=e=>{const t=(0,n.getInstance)();let r=0;const o=[],i=e||{};try{if(void 0===(null==e?void 0:e.logSeverityLevel))i.logSeverityLevel=2;else if("number"!=typeof e.logSeverityLevel||!Number.isInteger(e.logSeverityLevel)||e.logSeverityLevel<0||e.logSeverityLevel>4)throw new Error(`log serverity level is not valid: ${e.logSeverityLevel}`);if(void 0===(null==e?void 0:e.logVerbosityLevel))i.logVerbosityLevel=0;else if("number"!=typeof e.logVerbosityLevel||!Number.isInteger(e.logVerbosityLevel))throw new Error(`log verbosity level is not valid: ${e.logVerbosityLevel}`);void 0===(null==e?void 0:e.terminate)&&(i.terminate=!1);let n=0;return void 0!==(null==e?void 0:e.tag)&&(n=(0,a.allocWasmString)(e.tag,o)),r=t._OrtCreateRunOptions(i.logSeverityLevel,i.logVerbosityLevel,!!i.terminate,n),0===r&&(0,a.checkLastError)("Can\'t create run options."),void 0!==(null==e?void 0:e.extra)&&(0,a.iterateExtraOptions)(e.extra,"",new WeakSet,((e,n)=>{const i=(0,a.allocWasmString)(e,o),s=(0,a.allocWasmString)(n,o);0!==t._OrtAddRunConfigEntry(r,i,s)&&(0,a.checkLastError)(`Can\'t set a run config entry: ${e} - ${n}.`)})),[r,o]}catch(e){throw 0!==r&&t._OrtReleaseRunOptions(r),o.forEach((e=>t._free(e))),e}}},622:(e,t,r)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.setSessionOptions=void 0;const n=r(263),a=r(497);t.setSessionOptions=e=>{var t,r,o,i;const s=(0,n.getInstance)();let u=0;const c=[],l=e||{};(e=>{e.extra||(e.extra={}),e.extra.session||(e.extra.session={});const t=e.extra.session;t.use_ort_model_bytes_directly||(t.use_ort_model_bytes_directly="1"),e.executionProviders&&e.executionProviders.some((e=>"webgpu"===("string"==typeof e?e:e.name)))&&(e.enableMemPattern=!1)})(l);try{const e=(e=>{switch(e){case"disabled":return 0;case"basic":return 1;case"extended":return 2;case"all":return 99;default:throw new Error(`unsupported graph optimization level: ${e}`)}})(null!==(t=l.graphOptimizationLevel)&&void 0!==t?t:"all"),f=(e=>{switch(e){case"sequential":return 0;case"parallel":return 1;default:throw new Error(`unsupported execution mode: ${e}`)}})(null!==(r=l.executionMode)&&void 0!==r?r:"sequential"),d="string"==typeof l.logId?(0,a.allocWasmString)(l.logId,c):0,p=null!==(o=l.logSeverityLevel)&&void 0!==o?o:2;if(!Number.isInteger(p)||p<0||p>4)throw new Error(`log serverity level is not valid: ${p}`);const g=null!==(i=l.logVerbosityLevel)&&void 0!==i?i:0;if(!Number.isInteger(g)||g<0||g>4)throw new Error(`log verbosity level is not valid: ${g}`);const h="string"==typeof l.optimizedModelFilePath?(0,a.allocWasmString)(l.optimizedModelFilePath,c):0;return u=s._OrtCreateSessionOptions(e,!!l.enableCpuMemArena,!!l.enableMemPattern,f,!!l.enableProfiling,0,d,p,g,h),0===u&&(0,a.checkLastError)("Can\'t create session options."),l.executionProviders&&((e,t,r)=>{for(const o of t){let t="string"==typeof o?o:o.name;switch(t){case"xnnpack":t="XNNPACK";break;case"webnn":if(t="WEBNN","string"!=typeof o){const t=o;if(null==t?void 0:t.deviceType){const o=(0,a.allocWasmString)("deviceType",r),i=(0,a.allocWasmString)(t.deviceType,r);0!==(0,n.getInstance)()._OrtAddSessionConfigEntry(e,o,i)&&(0,a.checkLastError)(`Can\'t set a session config entry: \'deviceType\' - ${t.deviceType}.`)}if(null==t?void 0:t.powerPreference){const o=(0,a.allocWasmString)("powerPreference",r),i=(0,a.allocWasmString)(t.powerPreference,r);0!==(0,n.getInstance)()._OrtAddSessionConfigEntry(e,o,i)&&(0,a.checkLastError)(`Can\'t set a session config entry: \'powerPreference\' - ${t.powerPreference}.`)}}break;case"webgpu":t="JS";break;case"wasm":case"cpu":continue;default:throw new Error(`not supported execution provider: ${t}`)}const i=(0,a.allocWasmString)(t,r);0!==(0,n.getInstance)()._OrtAppendExecutionProvider(e,i)&&(0,a.checkLastError)(`Can\'t append execution provider: ${t}.`)}})(u,l.executionProviders,c),void 0!==l.extra&&(0,a.iterateExtraOptions)(l.extra,"",new WeakSet,((e,t)=>{const r=(0,a.allocWasmString)(e,c),n=(0,a.allocWasmString)(t,c);0!==s._OrtAddSessionConfigEntry(u,r,n)&&(0,a.checkLastError)(`Can\'t set a session config entry: ${e} - ${t}.`)})),[u,c]}catch(e){throw 0!==u&&s._OrtReleaseSessionOptions(u),c.forEach((e=>s._free(e))),e}}},917:(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.logLevelStringToEnum=t.tensorTypeToTypedArrayConstructor=t.getTensorElementSize=t.tensorDataTypeEnumToString=t.tensorDataTypeStringToEnum=void 0,t.tensorDataTypeStringToEnum=e=>{switch(e){case"int8":return 3;case"uint8":return 2;case"bool":return 9;case"int16":return 5;case"uint16":return 4;case"int32":return 6;case"uint32":return 12;case"float16":return 10;case"float32":return 1;case"float64":return 11;case"string":return 8;case"int64":return 7;case"uint64":return 13;default:throw new Error(`unsupported data type: ${e}`)}},t.tensorDataTypeEnumToString=e=>{switch(e){case 3:return"int8";case 2:return"uint8";case 9:return"bool";case 5:return"int16";case 4:return"uint16";case 6:return"int32";case 12:return"uint32";case 10:return"float16";case 1:return"float32";case 11:return"float64";case 8:return"string";case 7:return"int64";case 13:return"uint64";default:throw new Error(`unsupported data type: ${e}`)}},t.getTensorElementSize=e=>[void 0,4,1,1,2,2,4,8,void 0,1,2,8,4,8,void 0,void 0,void 0][e],t.tensorTypeToTypedArrayConstructor=e=>{switch(e){case"float16":case"uint16":return Uint16Array;case"float32":return Float32Array;case"uint8":case"bool":return Uint8Array;case"int8":return Int8Array;case"int16":return Int16Array;case"int32":return Int32Array;case"float64":return Float64Array;case"uint32":return Uint32Array;case"int64":return BigInt64Array;case"uint64":return BigUint64Array;default:throw new Error(`unsupported type: ${e}`)}},t.logLevelStringToEnum=e=>{switch(e){case"verbose":return 0;case"info":return 1;case"warning":return 2;case"error":return 3;case"fatal":return 4;default:throw new Error(`unsupported logging level: ${e}`)}}},259:(e,t,r)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.extractTransferableBuffers=t.endProfiling=t.run=t.releaseSession=t.createSession=t.createSessionFinalize=t.createSessionAllocate=t.initRuntime=void 0;const n=r(918),a=r(622),o=r(917),i=r(263),s=r(497);t.initRuntime=async e=>{var t,r;t=e.wasm.numThreads,r=(0,o.logLevelStringToEnum)(e.logLevel),0!==(0,i.getInstance)()._OrtInit(t,r)&&(0,s.checkLastError)("Can\'t initialize onnxruntime.")};const u=new Map;t.createSessionAllocate=e=>{const t=(0,i.getInstance)(),r=t._malloc(e.byteLength);if(0===r)throw new Error(`Can\'t create a session. failed to allocate a buffer of size ${e.byteLength}.`);return t.HEAPU8.set(e,r),[r,e.byteLength]},t.createSessionFinalize=(e,t)=>{const r=(0,i.getInstance)();let n=0,o=0,c=[];const l=[],f=[];try{[o,c]=(0,a.setSessionOptions)(t),n=r._OrtCreateSession(e[0],e[1],o),0===n&&(0,s.checkLastError)("Can\'t create a session.");const[d,p]=(e=>{const t=(0,i.getInstance)(),r=t.stackSave();try{const r=t.stackAlloc(8);return 0!==t._OrtGetInputOutputCount(e,r,r+4)&&(0,s.checkLastError)("Can\'t get session input/output count."),[t.HEAP32[r/4],t.HEAP32[r/4+1]]}finally{t.stackRestore(r)}})(n),g=[],h=[];for(let e=0;e<d;e++){const t=r._OrtGetInputName(n,e);0===t&&(0,s.checkLastError)("Can\'t get an input name."),l.push(t),g.push(r.UTF8ToString(t))}for(let e=0;e<p;e++){const t=r._OrtGetOutputName(n,e);0===t&&(0,s.checkLastError)("Can\'t get an output name."),f.push(t),h.push(r.UTF8ToString(t))}return u.set(n,[n,l,f]),[n,g,h]}catch(e){throw l.forEach((e=>r._OrtFree(e))),f.forEach((e=>r._OrtFree(e))),0!==n&&r._OrtReleaseSession(n),e}finally{r._free(e[0]),0!==o&&r._OrtReleaseSessionOptions(o),c.forEach((e=>r._free(e)))}},t.createSession=(e,r)=>{const n=(0,t.createSessionAllocate)(e);return(0,t.createSessionFinalize)(n,r)},t.releaseSession=e=>{const t=(0,i.getInstance)(),r=u.get(e);if(!r)throw new Error(`cannot release session. invalid session id: ${e}`);const[n,a,o]=r;a.forEach((e=>t._OrtFree(e))),o.forEach((e=>t._OrtFree(e))),t._OrtReleaseSession(n),u.delete(e)},t.run=async(e,t,r,a,c)=>{const l=(0,i.getInstance)(),f=u.get(e);if(!f)throw new Error(`cannot run inference. invalid session id: ${e}`);const[d,p,g]=f,h=t.length,m=a.length;let y=0,v=[];const b=[],w=[];try{[y,v]=(0,n.setRunOptions)(c);for(let e=0;e<h;e++){const t=r[e][0],n=r[e][1],a=r[e][2];let i,u;if(Array.isArray(a)){u=4*a.length,i=l._malloc(u),w.push(i);let e=i/4;for(let t=0;t<a.length;t++){if("string"!=typeof a[t])throw new TypeError(`tensor data at index ${t} is not a string`);l.HEAPU32[e++]=(0,s.allocWasmString)(a[t],w)}}else u=a.byteLength,i=l._malloc(u),w.push(i),l.HEAPU8.set(new Uint8Array(a.buffer,a.byteOffset,u),i);const c=l.stackSave(),f=l.stackAlloc(4*n.length);try{let r=f/4;n.forEach((e=>l.HEAP32[r++]=e));const a=l._OrtCreateTensor((0,o.tensorDataTypeStringToEnum)(t),i,u,f,n.length);0===a&&(0,s.checkLastError)(`Can\'t create tensor for input[${e}].`),b.push(a)}finally{l.stackRestore(c)}}const e=l.stackSave(),i=l.stackAlloc(4*h),u=l.stackAlloc(4*h),f=l.stackAlloc(4*m),_=l.stackAlloc(4*m);try{let e=i/4,r=u/4,n=f/4,c=_/4;for(let n=0;n<h;n++)l.HEAPU32[e++]=b[n],l.HEAPU32[r++]=p[t[n]];for(let e=0;e<m;e++)l.HEAPU32[n++]=0,l.HEAPU32[c++]=g[a[e]];let v=l._OrtRun(d,u,i,h,_,m,f,y);const w=l.jsepRunPromise;w&&void 0!==w.then&&(v=await w);const O=[];0!==v&&(0,s.checkLastError)("failed to call OrtRun().");for(let e=0;e<m;e++){const t=l.HEAPU32[f/4+e],r=l.stackSave(),n=l.stackAlloc(16);let a,i=0;try{v=l._OrtGetTensorData(t,n,n+4,n+8,n+12),0!==v&&(0,s.checkLastError)(`Can\'t access output tensor data on index ${e}.`);let r=n/4;const u=l.HEAPU32[r++];i=l.HEAPU32[r++];const c=l.HEAPU32[r++],f=l.HEAPU32[r++],d=[];for(let e=0;e<f;e++)d.push(l.HEAPU32[c/4+e]);l._OrtFree(c);const p=0===d.length?1:d.reduce(((e,t)=>e*t));if(a=(0,o.tensorDataTypeEnumToString)(u),"string"===a){const e=[];let t=i/4;for(let r=0;r<p;r++){const n=l.HEAPU32[t++],a=r===p-1?void 0:l.HEAPU32[t]-n;e.push(l.UTF8ToString(n,a))}O.push([a,d,e])}else{const e=new((0,o.tensorTypeToTypedArrayConstructor)(a))(p);new Uint8Array(e.buffer,e.byteOffset,e.byteLength).set(l.HEAPU8.subarray(i,i+e.byteLength)),O.push([a,d,e])}}finally{l.stackRestore(r),"string"===a&&i&&l._free(i),l._OrtReleaseTensor(t)}}return O}finally{l.stackRestore(e)}}finally{b.forEach((e=>l._OrtReleaseTensor(e))),w.forEach((e=>l._free(e))),0!==y&&l._OrtReleaseRunOptions(y),v.forEach((e=>l._free(e)))}},t.endProfiling=e=>{const t=(0,i.getInstance)(),r=u.get(e);if(!r)throw new Error("invalid session id");const n=r[0],a=t._OrtEndProfiling(n);0===a&&(0,s.checkLastError)("Can\'t get an profile file name."),t._OrtFree(a)},t.extractTransferableBuffers=e=>{const t=[];for(const r of e){const e=r[2];!Array.isArray(e)&&e.buffer&&t.push(e.buffer)}return t}},263:function(e,t,r){"use strict";var n=this&&this.__createBinding||(Object.create?function(e,t,r,n){void 0===n&&(n=r);var a=Object.getOwnPropertyDescriptor(t,r);a&&!("get"in a?!t.__esModule:a.writable||a.configurable)||(a={enumerable:!0,get:function(){return t[r]}}),Object.defineProperty(e,n,a)}:function(e,t,r,n){void 0===n&&(n=r),e[n]=t[r]}),a=this&&this.__setModuleDefault||(Object.create?function(e,t){Object.defineProperty(e,"default",{enumerable:!0,value:t})}:function(e,t){e.default=t}),o=this&&this.__importStar||function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var r in e)"default"!==r&&Object.prototype.hasOwnProperty.call(e,r)&&n(t,e,r);return a(t,e),t};Object.defineProperty(t,"__esModule",{value:!0}),t.dispose=t.getInstance=t.initializeWebAssembly=void 0;const i=o(r(449)),s=r(932),u=r(474);let c,l=!1,f=!1,d=!1;t.initializeWebAssembly=async e=>{if(l)return Promise.resolve();if(f)throw new Error("multiple calls to \'initializeWebAssembly()\' detected.");if(d)throw new Error("previous call to \'initializeWebAssembly()\' failed.");f=!0;const t=e.initTimeout,n=e.numThreads,a=e.simd,o=n>1&&(()=>{try{return"undefined"!=typeof SharedArrayBuffer&&("undefined"!=typeof MessageChannel&&(new MessageChannel).port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11])))}catch(e){return!1}})(),p=a&&(()=>{try{return WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,30,1,28,0,65,0,253,15,253,12,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,253,186,1,26,11]))}catch(e){return!1}})(),g=e.wasmPaths,h="string"==typeof g?g:void 0,m=((e,t)=>t?e?"ort-wasm-simd-threaded.wasm":"ort-wasm-threaded.wasm":e?"ort-wasm-simd.wasm":"ort-wasm.wasm")(p,o),y="object"==typeof g?g[m]:void 0;let v=!1;const b=[];if(t>0&&b.push(new Promise((e=>{setTimeout((()=>{v=!0,e()}),t)}))),b.push(new Promise(((e,t)=>{const n=o?u:s,a={locateFile:(e,t)=>o&&e.endsWith(".worker.js")&&"undefined"!=typeof Blob?URL.createObjectURL(new Blob([r(154)],{type:"text/javascript"})):e.endsWith(".wasm")?y||(null!=h?h:t)+m:t+e};if(o)if("undefined"==typeof Blob)a.mainScriptUrlOrBlob=i.join(__dirname,"ort-wasm-threaded.js");else{const e=`var ortWasmThreaded=(function(){var _scriptDir;return ${n.toString()}})();`;a.mainScriptUrlOrBlob=new Blob([e],{type:"text/javascript"})}n(a).then((t=>{f=!1,l=!0,c=t,e()}),(e=>{f=!1,d=!0,t(e)}))}))),await Promise.race(b),v)throw new Error(`WebAssembly backend initializing failed due to timeout: ${t}ms`)},t.getInstance=()=>{if(l&&c)return c;throw new Error("WebAssembly is not initialized yet.")},t.dispose=()=>{var e;!l||f||d||(f=!0,null===(e=c.PThread)||void 0===e||e.terminateAllThreads(),c=void 0,f=!1,l=!1,d=!0)}},497:(e,t,r)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.checkLastError=t.iterateExtraOptions=t.allocWasmString=void 0;const n=r(263);t.allocWasmString=(e,t)=>{const r=(0,n.getInstance)(),a=r.lengthBytesUTF8(e)+1,o=r._malloc(a);return r.stringToUTF8(e,o,a),t.push(o),o},t.iterateExtraOptions=(e,r,n,a)=>{if("object"==typeof e&&null!==e){if(n.has(e))throw new Error("Circular reference in options");n.add(e)}Object.entries(e).forEach((([e,o])=>{const i=r?r+e:e;if("object"==typeof o)(0,t.iterateExtraOptions)(o,i+".",n,a);else if("string"==typeof o||"number"==typeof o)a(i,o.toString());else{if("boolean"!=typeof o)throw new Error("Can\'t handle extra config type: "+typeof o);a(i,o?"1":"0")}}))},t.checkLastError=e=>{const t=(0,n.getInstance)(),r=t.stackSave();try{const r=t.stackAlloc(8);t._OrtGetLastError(r,r+4);const n=t.HEAP32[r/4],a=t.HEAPU32[r/4+1],o=a?t.UTF8ToString(a):"";throw new Error(`${e} ERROR_CODE: ${n}, ERROR_MESSAGE: ${o}`)}finally{t.stackRestore(r)}}},474:(e,t,r)=>{var _scriptDir,n=(_scriptDir="undefined"!=typeof document&&document.currentScript?document.currentScript.src:void 0,"undefined"!=typeof __filename&&(_scriptDir=_scriptDir||__filename),function(e={}){function t(){return k.buffer!=x.buffer&&Y(),x}function n(){return k.buffer!=x.buffer&&Y(),I}function a(){return k.buffer!=x.buffer&&Y(),U}function o(){return k.buffer!=x.buffer&&Y(),L}function i(){return k.buffer!=x.buffer&&Y(),W}var s,u,c=e;c.ready=new Promise(((e,t)=>{s=e,u=t}));var l,f,d,p=Object.assign({},c),g="./this.program",h=(e,t)=>{throw t},m="object"==typeof window,y="function"==typeof importScripts,v="object"==typeof process&&"object"==typeof process.versions&&"string"==typeof process.versions.node,b=c.ENVIRONMENT_IS_PTHREAD||!1,w="";function _(e){return c.locateFile?c.locateFile(e,w):w+e}if(v){var O=r(384),S=r(908);let t;w=y?S.dirname(w)+"/":__dirname+"/",l=(e,t)=>(e=e.startsWith("file://")?new URL(e):S.normalize(e),O.readFileSync(e,t?void 0:"utf8")),d=e=>((e=l(e,!0)).buffer||(e=new Uint8Array(e)),e),f=(e,t,r,n=!0)=>{e=e.startsWith("file://")?new URL(e):S.normalize(e),O.readFile(e,n?void 0:"utf8",((e,a)=>{e?r(e):t(n?a.buffer:a)}))},!c.thisProgram&&1<process.argv.length&&(g=process.argv[1].replace(/\\\\/g,"/")),process.argv.slice(2),h=(e,t)=>{throw process.exitCode=e,t},c.inspect=()=>"[Emscripten Module object]";try{t=r(925)}catch(e){throw console.error(\'The "worker_threads" module is not supported in this node.js build - perhaps a newer version is needed?\'),e}global.Worker=t.Worker}else(m||y)&&(y?w=self.location.href:"undefined"!=typeof document&&document.currentScript&&(w=document.currentScript.src),_scriptDir&&(w=_scriptDir),w=0!==w.indexOf("blob:")?w.substr(0,w.replace(/[?#].*/,"").lastIndexOf("/")+1):"",v||(l=e=>{var t=new XMLHttpRequest;return t.open("GET",e,!1),t.send(null),t.responseText},y&&(d=e=>{var t=new XMLHttpRequest;return t.open("GET",e,!1),t.responseType="arraybuffer",t.send(null),new Uint8Array(t.response)}),f=(e,t,r)=>{var n=new XMLHttpRequest;n.open("GET",e,!0),n.responseType="arraybuffer",n.onload=()=>{200==n.status||0==n.status&&n.response?t(n.response):r()},n.onerror=r,n.send(null)}));v&&"undefined"==typeof performance&&(global.performance=r(953).performance);var E=console.log.bind(console),A=console.error.bind(console);v&&(E=(...e)=>O.writeSync(1,e.join(" ")+"\\n"),A=(...e)=>O.writeSync(2,e.join(" ")+"\\n"));var T,M=c.print||E,R=c.printErr||A;Object.assign(c,p),p=null,c.thisProgram&&(g=c.thisProgram),c.quit&&(h=c.quit),c.wasmBinary&&(T=c.wasmBinary);var F=c.noExitRuntime||!0;"object"!=typeof WebAssembly&&te("no native wasm support detected");var k,C,P,D,x,I,U,L,W,H=!1;function Y(){var e=k.buffer;c.HEAP8=x=new Int8Array(e),c.HEAP16=new Int16Array(e),c.HEAP32=U=new Int32Array(e),c.HEAPU8=I=new Uint8Array(e),c.HEAPU16=new Uint16Array(e),c.HEAPU32=L=new Uint32Array(e),c.HEAPF32=new Float32Array(e),c.HEAPF64=W=new Float64Array(e)}var j=c.INITIAL_MEMORY||16777216;if(5242880<=j||te("INITIAL_MEMORY should be larger than STACK_SIZE, was "+j+"! (STACK_SIZE=5242880)"),b)k=c.wasmMemory;else if(c.wasmMemory)k=c.wasmMemory;else if(!((k=new WebAssembly.Memory({initial:j/65536,maximum:65536,shared:!0})).buffer instanceof SharedArrayBuffer))throw R("requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag"),v&&R("(on node you may need: --experimental-wasm-threads --experimental-wasm-bulk-memory and/or recent version)"),Error("bad memory");Y(),j=k.buffer.byteLength;var z,G=[],N=[],B=[],$=0;function q(){return F||0<$}var V,J,X=0,K=null,Z=null;function Q(){X++,c.monitorRunDependencies&&c.monitorRunDependencies(X)}function ee(){if(X--,c.monitorRunDependencies&&c.monitorRunDependencies(X),0==X&&(null!==K&&(clearInterval(K),K=null),Z)){var e=Z;Z=null,e()}}function te(e){throw c.onAbort&&c.onAbort(e),R(e="Aborted("+e+")"),H=!0,D=1,e=new WebAssembly.RuntimeError(e+". Build with -sASSERTIONS for more info."),u(e),e}function re(e){return e.startsWith("data:application/octet-stream;base64,")}function ne(e){if(e==V&&T)return new Uint8Array(T);if(d)return d(e);throw"both async and sync fetching of the wasm failed"}function ae(e,t,r){return function(e){if(!T&&(m||y)){if("function"==typeof fetch&&!e.startsWith("file://"))return fetch(e,{credentials:"same-origin"}).then((t=>{if(!t.ok)throw"failed to load wasm binary file at \'"+e+"\'";return t.arrayBuffer()})).catch((()=>ne(e)));if(f)return new Promise(((t,r)=>{f(e,(e=>t(new Uint8Array(e))),r)}))}return Promise.resolve().then((()=>ne(e)))}(e).then((e=>WebAssembly.instantiate(e,t))).then((e=>e)).then(r,(e=>{R("failed to asynchronously prepare wasm: "+e),te(e)}))}function oe(e){this.name="ExitStatus",this.message=`Program terminated with exit(${e})`,this.status=e}function ie(e){e.terminate(),e.onmessage=()=>{}}function se(e){(e=ge.Fa[e])||te(),ge.fb(e)}function ue(e){var t=ge.Za();if(!t)return 6;ge.Ia.push(t),ge.Fa[e.Ha]=t,t.Ha=e.Ha;var r={cmd:"run",start_routine:e.gb,arg:e.Ya,pthread_ptr:e.Ha};return v&&t.unref(),t.postMessage(r,e.mb),0}re(V="ort-wasm-threaded.wasm")||(V=_(V));var ce="undefined"!=typeof TextDecoder?new TextDecoder("utf8"):void 0,le=(e,t,r)=>{var n=(t>>>=0)+r;for(r=t;e[r]&&!(r>=n);)++r;if(16<r-t&&e.buffer&&ce)return ce.decode(e.buffer instanceof SharedArrayBuffer?e.slice(t,r):e.subarray(t,r));for(n="";t<r;){var a=e[t++];if(128&a){var o=63&e[t++];if(192==(224&a))n+=String.fromCharCode((31&a)<<6|o);else{var i=63&e[t++];65536>(a=224==(240&a)?(15&a)<<12|o<<6|i:(7&a)<<18|o<<12|i<<6|63&e[t++])?n+=String.fromCharCode(a):(a-=65536,n+=String.fromCharCode(55296|a>>10,56320|1023&a))}}else n+=String.fromCharCode(a)}return n},fe=(e,t)=>(e>>>=0)?le(n(),e,t):"";function de(e){if(b)return qe(1,1,e);D=e,q()||(ge.hb(),c.onExit&&c.onExit(e),H=!0),h(e,new oe(e))}var pe=e=>{if(D=e,b)throw me(e),"unwind";de(e)},ge={La:[],Ia:[],Ta:[],Fa:{},Pa:function(){b?ge.ab():ge.$a()},$a:function(){G.unshift((()=>{Q(),ge.bb((()=>ee()))}))},ab:function(){ge.receiveObjectTransfer=ge.eb,ge.threadInitTLS=ge.Sa,ge.setExitStatus=ge.Ra,F=!1},Ra:function(e){D=e},rb:["$terminateWorker"],hb:function(){for(var e of ge.Ia)ie(e);for(e of ge.La)ie(e);ge.La=[],ge.Ia=[],ge.Fa=[]},fb:function(e){var t=e.Ha;delete ge.Fa[t],ge.La.push(e),ge.Ia.splice(ge.Ia.indexOf(e),1),e.Ha=0,yt(t)},eb:function(){},Sa:function(){ge.Ta.forEach((e=>e()))},cb:e=>new Promise((t=>{e.onmessage=r=>{var n=(r=r.data).cmd;if(r.targetThread&&r.targetThread!=dt()){var a=ge.Fa[r.qb];a?a.postMessage(r,r.transferList):R(\'Internal error! Worker sent a message "\'+n+\'" to target pthread \'+r.targetThread+", but that thread no longer exists!")}else"checkMailbox"===n?He():"spawnThread"===n?ue(r):"cleanupThread"===n?se(r.thread):"killThread"===n?(r=r.thread,n=ge.Fa[r],delete ge.Fa[r],ie(n),yt(r),ge.Ia.splice(ge.Ia.indexOf(n),1),n.Ha=0):"cancelThread"===n?ge.Fa[r.thread].postMessage({cmd:"cancel"}):"loaded"===n?(e.loaded=!0,t(e)):"alert"===n?alert("Thread "+r.threadId+": "+r.text):"setimmediate"===r.target?e.postMessage(r):"callHandler"===n?c[r.handler](...r.args):n&&R("worker sent an unknown command "+n)},e.onerror=e=>{throw R("worker sent an error! "+e.filename+":"+e.lineno+": "+e.message),e},v&&(e.on("message",(function(t){e.onmessage({data:t})})),e.on("error",(function(t){e.onerror(t)})));var r,n=[];for(r of["onExit","onAbort","print","printErr"])c.hasOwnProperty(r)&&n.push(r);e.postMessage({cmd:"load",handlers:n,urlOrBlob:c.mainScriptUrlOrBlob||_scriptDir,wasmMemory:k,wasmModule:P})})),bb:function(e){e()},Xa:function(){var e=_("ort-wasm-threaded.worker.js");e=new Worker(e),ge.La.push(e)},Za:function(){return 0==ge.La.length&&(ge.Xa(),ge.cb(ge.La[0])),ge.La.pop()}};c.PThread=ge;var he=e=>{for(;0<e.length;)e.shift()(c)};function me(e){if(b)return qe(2,0,e);pe(e)}c.establishStackSpace=function(){var e=dt(),t=a()[e+52>>2>>>0];e=a()[e+56>>2>>>0],_t(t,t-e),St(t)};var ye=[];function ve(e){this.Oa=e-24,this.Wa=function(e){o()[this.Oa+4>>2>>>0]=e},this.Va=function(e){o()[this.Oa+8>>2>>>0]=e},this.Pa=function(e,t){this.Ua(),this.Wa(e),this.Va(t)},this.Ua=function(){o()[this.Oa+16>>2>>>0]=0}}function be(e,t,r,n){return b?qe(3,1,e,t,r,n):we(e,t,r,n)}function we(e,t,r,n){if(e>>>=0,t>>>=0,r>>>=0,n>>>=0,"undefined"==typeof SharedArrayBuffer)return R("Current environment does not support SharedArrayBuffer, pthreads are not available!"),6;var a=[];return b&&0===a.length?be(e,t,r,n):(e={gb:r,Ha:e,Ya:n,mb:a},b?(e.ob="spawnThread",postMessage(e,a),0):ue(e))}function _e(e,t,r){return b?qe(4,1,e,t,r):0}function Oe(e,t){if(b)return qe(5,1,e,t)}c.invokeEntryPoint=function(e,t){var r=ye[e];r||(e>=ye.length&&(ye.length=e+1),ye[e]=r=z.get(e)),e=r(t),q()?ge.Ra(e):vt(e)};var Se=e=>{for(var t=0,r=0;r<e.length;++r){var n=e.charCodeAt(r);127>=n?t++:2047>=n?t+=2:55296<=n&&57343>=n?(t+=4,++r):t+=3}return t},Ee=(e,t,r,n)=>{if(!(0<n))return 0;var a=r>>>=0;n=r+n-1;for(var o=0;o<e.length;++o){var i=e.charCodeAt(o);if(55296<=i&&57343>=i&&(i=65536+((1023&i)<<10)|1023&e.charCodeAt(++o)),127>=i){if(r>=n)break;t[r++>>>0]=i}else{if(2047>=i){if(r+1>=n)break;t[r++>>>0]=192|i>>6}else{if(65535>=i){if(r+2>=n)break;t[r++>>>0]=224|i>>12}else{if(r+3>=n)break;t[r++>>>0]=240|i>>18,t[r++>>>0]=128|i>>12&63}t[r++>>>0]=128|i>>6&63}t[r++>>>0]=128|63&i}}return t[r>>>0]=0,r-a},Ae=(e,t,r)=>Ee(e,n(),t,r);function Te(e,t){if(b)return qe(6,1,e,t)}function Me(e,t,r){if(b)return qe(7,1,e,t,r)}function Re(e,t,r){return b?qe(8,1,e,t,r):0}function Fe(e,t){if(b)return qe(9,1,e,t)}function ke(e,t,r){if(b)return qe(10,1,e,t,r)}function Ce(e,t,r,n){if(b)return qe(11,1,e,t,r,n)}function Pe(e,t,r,n){if(b)return qe(12,1,e,t,r,n)}function De(e,t,r,n){if(b)return qe(13,1,e,t,r,n)}function xe(e){if(b)return qe(14,1,e)}function Ie(e,t){if(b)return qe(15,1,e,t)}function Ue(e,t,r){if(b)return qe(16,1,e,t,r)}var Le=e=>{if(!H)try{if(e(),!q())try{b?vt(D):pe(D)}catch(e){e instanceof oe||"unwind"==e||h(1,e)}}catch(e){e instanceof oe||"unwind"==e||h(1,e)}};function We(e){e>>>=0,"function"==typeof Atomics.nb&&(Atomics.nb(a(),e>>2,e).value.then(He),e+=128,Atomics.store(a(),e>>2,1))}function He(){var e=dt();e&&(We(e),Le((()=>bt())))}c.__emscripten_thread_mailbox_await=We,c.checkMailbox=He;var Ye=e=>0==e%4&&(0!=e%100||0==e%400),je=[0,31,60,91,121,152,182,213,244,274,305,335],ze=[0,31,59,90,120,151,181,212,243,273,304,334];function Ge(e,t,r,n,a,o,i,s){return b?qe(17,1,e,t,r,n,a,o,i,s):-52}function Ne(e,t,r,n,a,o,i){if(b)return qe(18,1,e,t,r,n,a,o,i)}var Be=e=>{var t=Se(e)+1,r=pt(t);return r&&Ae(e,r,t),r},$e=e=>{var t=Ot();return e=e(),St(t),e};function qe(e,t){var r=arguments.length-2,n=arguments;return $e((()=>{for(var a=Et(8*r),o=a>>3,s=0;s<r;s++){var u=n[2+s];i()[o+s>>>0]=u}return mt(e,r,a,t)}))}var Ve,Je=[],Xe={},Ke=()=>{if(!Ve){var e,t={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:("object"==typeof navigator&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:g||"./this.program"};for(e in Xe)void 0===Xe[e]?delete t[e]:t[e]=Xe[e];var r=[];for(e in t)r.push(`${e}=${t[e]}`);Ve=r}return Ve};function Ze(e,r){if(b)return qe(19,1,e,r);e>>>=0,r>>>=0;var n=0;return Ke().forEach((function(a,i){var s=r+n;for(i=o()[e+4*i>>2>>>0]=s,s=0;s<a.length;++s)t()[i++>>0>>>0]=a.charCodeAt(s);t()[i>>0>>>0]=0,n+=a.length+1})),0}function Qe(e,t){if(b)return qe(20,1,e,t);e>>>=0,t>>>=0;var r=Ke();o()[e>>2>>>0]=r.length;var n=0;return r.forEach((function(e){n+=e.length+1})),o()[t>>2>>>0]=n,0}function et(e){return b?qe(21,1,e):52}function tt(e,t,r,n){return b?qe(22,1,e,t,r,n):52}function rt(e,t,r,n,a){return b?qe(23,1,e,t,r,n,a):70}var nt=[null,[],[]];function at(e,t,r,a){if(b)return qe(24,1,e,t,r,a);t>>>=0,r>>>=0,a>>>=0;for(var i=0,s=0;s<r;s++){var u=o()[t>>2>>>0],c=o()[t+4>>2>>>0];t+=8;for(var l=0;l<c;l++){var f=n()[u+l>>>0],d=nt[e];0===f||10===f?((1===e?M:R)(le(d,0)),d.length=0):d.push(f)}i+=c}return o()[a>>2>>>0]=i,0}var ot=e=>(ot=(()=>{if("object"==typeof crypto&&"function"==typeof crypto.getRandomValues)return e=>(e.set(crypto.getRandomValues(new Uint8Array(e.byteLength))),e);if(v)try{var e=r(760);if(e.randomFillSync)return t=>e.randomFillSync(t);var t=e.randomBytes;return e=>(e.set(t(e.byteLength)),e)}catch(e){}te("initRandomDevice")})())(e),it=[31,29,31,30,31,30,31,31,30,31,30,31],st=[31,28,31,30,31,30,31,31,30,31,30,31],ut=(e,r)=>{t().set(e,r>>>0)};function ct(e,t,r,n){function o(e,t,r){for(e="number"==typeof e?e.toString():e||"";e.length<t;)e=r[0]+e;return e}function i(e,t){return o(e,t,"0")}function s(e,t){function r(e){return 0>e?-1:0<e?1:0}var n;return 0===(n=r(e.getFullYear()-t.getFullYear()))&&0===(n=r(e.getMonth()-t.getMonth()))&&(n=r(e.getDate()-t.getDate())),n}function u(e){switch(e.getDay()){case 0:return new Date(e.getFullYear()-1,11,29);case 1:return e;case 2:return new Date(e.getFullYear(),0,3);case 3:return new Date(e.getFullYear(),0,2);case 4:return new Date(e.getFullYear(),0,1);case 5:return new Date(e.getFullYear()-1,11,31);case 6:return new Date(e.getFullYear()-1,11,30)}}function c(e){var t=e.Ja;for(e=new Date(new Date(e.Ka+1900,0,1).getTime());0<t;){var r=e.getMonth(),n=(Ye(e.getFullYear())?it:st)[r];if(!(t>n-e.getDate())){e.setDate(e.getDate()+t);break}t-=n-e.getDate()+1,e.setDate(1),11>r?e.setMonth(r+1):(e.setMonth(0),e.setFullYear(e.getFullYear()+1))}return r=new Date(e.getFullYear()+1,0,4),t=u(new Date(e.getFullYear(),0,4)),r=u(r),0>=s(t,e)?0>=s(r,e)?e.getFullYear()+1:e.getFullYear():e.getFullYear()-1}e>>>=0,t>>>=0,r>>>=0,n>>>=0;var l=a()[n+40>>2>>>0];for(var f in n={kb:a()[n>>2>>>0],jb:a()[n+4>>2>>>0],Ma:a()[n+8>>2>>>0],Qa:a()[n+12>>2>>>0],Na:a()[n+16>>2>>>0],Ka:a()[n+20>>2>>>0],Ga:a()[n+24>>2>>>0],Ja:a()[n+28>>2>>>0],sb:a()[n+32>>2>>>0],ib:a()[n+36>>2>>>0],lb:l?fe(l):""},r=fe(r),l={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"})r=r.replace(new RegExp(f,"g"),l[f]);var d="Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),p="January February March April May June July August September October November December".split(" ");for(f in l={"%a":e=>d[e.Ga].substring(0,3),"%A":e=>d[e.Ga],"%b":e=>p[e.Na].substring(0,3),"%B":e=>p[e.Na],"%C":e=>i((e.Ka+1900)/100|0,2),"%d":e=>i(e.Qa,2),"%e":e=>o(e.Qa,2," "),"%g":e=>c(e).toString().substring(2),"%G":e=>c(e),"%H":e=>i(e.Ma,2),"%I":e=>(0==(e=e.Ma)?e=12:12<e&&(e-=12),i(e,2)),"%j":e=>{for(var t=0,r=0;r<=e.Na-1;t+=(Ye(e.Ka+1900)?it:st)[r++]);return i(e.Qa+t,3)},"%m":e=>i(e.Na+1,2),"%M":e=>i(e.jb,2),"%n":()=>"\\n","%p":e=>0<=e.Ma&&12>e.Ma?"AM":"PM","%S":e=>i(e.kb,2),"%t":()=>"\\t","%u":e=>e.Ga||7,"%U":e=>i(Math.floor((e.Ja+7-e.Ga)/7),2),"%V":e=>{var t=Math.floor((e.Ja+7-(e.Ga+6)%7)/7);if(2>=(e.Ga+371-e.Ja-2)%7&&t++,t)53==t&&(4==(r=(e.Ga+371-e.Ja)%7)||3==r&&Ye(e.Ka)||(t=1));else{t=52;var r=(e.Ga+7-e.Ja-1)%7;(4==r||5==r&&Ye(e.Ka%400-1))&&t++}return i(t,2)},"%w":e=>e.Ga,"%W":e=>i(Math.floor((e.Ja+7-(e.Ga+6)%7)/7),2),"%y":e=>(e.Ka+1900).toString().substring(2),"%Y":e=>e.Ka+1900,"%z":e=>{var t=0<=(e=e.ib);return e=Math.abs(e)/60,(t?"+":"-")+String("0000"+(e/60*100+e%60)).slice(-4)},"%Z":e=>e.lb,"%%":()=>"%"},r=r.replace(/%%/g,"\\0\\0"),l)r.includes(f)&&(r=r.replace(new RegExp(f,"g"),l[f](n)));return f=function(e){var t=Array(Se(e)+1);return Ee(e,t,0,t.length),t}(r=r.replace(/\\0\\0/g,"%")),f.length>t?0:(ut(f,e),f.length-1)}ge.Pa();var lt=[null,de,me,be,_e,Oe,Te,Me,Re,Fe,ke,Ce,Pe,De,xe,Ie,Ue,Ge,Ne,Ze,Qe,et,tt,rt,at],ft={b:function(e,t,r){throw new ve(e>>>=0).Pa(t>>>0,r>>>0),e},N:function(e){gt(e>>>0,!y,1,!m,131072,!1),ge.Sa()},k:function(e){e>>>=0,b?postMessage({cmd:"cleanupThread",thread:e}):se(e)},I:we,h:_e,T:Oe,E:Te,G:Me,U:Re,R:Fe,J:ke,Q:Ce,o:Pe,F:De,C:xe,S:Ie,D:Ue,q:()=>!0,A:function(e,t){(e>>>=0)==t>>>0?setTimeout((()=>He())):b?postMessage({targetThread:e,cmd:"checkMailbox"}):(e=ge.Fa[e])&&e.postMessage({cmd:"checkMailbox"})},L:function(){return-1},M:We,p:function(e){v&&ge.Fa[e>>>0].ref()},t:function(e,t,r){e=t+2097152>>>0<4194305-!!e?(e>>>0)+4294967296*t:NaN,r>>>=0,e=new Date(1e3*e),a()[r>>2>>>0]=e.getUTCSeconds(),a()[r+4>>2>>>0]=e.getUTCMinutes(),a()[r+8>>2>>>0]=e.getUTCHours(),a()[r+12>>2>>>0]=e.getUTCDate(),a()[r+16>>2>>>0]=e.getUTCMonth(),a()[r+20>>2>>>0]=e.getUTCFullYear()-1900,a()[r+24>>2>>>0]=e.getUTCDay(),e=(e.getTime()-Date.UTC(e.getUTCFullYear(),0,1,0,0,0,0))/864e5|0,a()[r+28>>2>>>0]=e},u:function(e,t,r){e=t+2097152>>>0<4194305-!!e?(e>>>0)+4294967296*t:NaN,r>>>=0,e=new Date(1e3*e),a()[r>>2>>>0]=e.getSeconds(),a()[r+4>>2>>>0]=e.getMinutes(),a()[r+8>>2>>>0]=e.getHours(),a()[r+12>>2>>>0]=e.getDate(),a()[r+16>>2>>>0]=e.getMonth(),a()[r+20>>2>>>0]=e.getFullYear()-1900,a()[r+24>>2>>>0]=e.getDay(),t=(Ye(e.getFullYear())?je:ze)[e.getMonth()]+e.getDate()-1|0,a()[r+28>>2>>>0]=t,a()[r+36>>2>>>0]=-60*e.getTimezoneOffset(),t=new Date(e.getFullYear(),6,1).getTimezoneOffset();var n=new Date(e.getFullYear(),0,1).getTimezoneOffset();e=0|(t!=n&&e.getTimezoneOffset()==Math.min(n,t)),a()[r+32>>2>>>0]=e},v:function(e){e>>>=0;var t=new Date(a()[e+20>>2>>>0]+1900,a()[e+16>>2>>>0],a()[e+12>>2>>>0],a()[e+8>>2>>>0],a()[e+4>>2>>>0],a()[e>>2>>>0],0),r=a()[e+32>>2>>>0],n=t.getTimezoneOffset(),o=new Date(t.getFullYear(),6,1).getTimezoneOffset(),i=new Date(t.getFullYear(),0,1).getTimezoneOffset(),s=Math.min(i,o);return 0>r?a()[e+32>>2>>>0]=Number(o!=i&&s==n):0<r!=(s==n)&&(o=Math.max(i,o),t.setTime(t.getTime()+6e4*((0<r?s:o)-n))),a()[e+24>>2>>>0]=t.getDay(),r=(Ye(t.getFullYear())?je:ze)[t.getMonth()]+t.getDate()-1|0,a()[e+28>>2>>>0]=r,a()[e>>2>>>0]=t.getSeconds(),a()[e+4>>2>>>0]=t.getMinutes(),a()[e+8>>2>>>0]=t.getHours(),a()[e+12>>2>>>0]=t.getDate(),a()[e+16>>2>>>0]=t.getMonth(),a()[e+20>>2>>>0]=t.getYear(),e=t.getTime()/1e3,wt((J=e,1<=+Math.abs(J)?0<J?+Math.floor(J/4294967296)>>>0:~~+Math.ceil((J-+(~~J>>>0))/4294967296)>>>0:0)),e>>>0},r:Ge,s:Ne,z:function(e,t,r){function n(e){return(e=e.toTimeString().match(/\\(([A-Za-z ]+)\\)$/))?e[1]:"GMT"}e>>>=0,t>>>=0,r>>>=0;var i=(new Date).getFullYear(),s=new Date(i,0,1),u=new Date(i,6,1);i=s.getTimezoneOffset();var c=u.getTimezoneOffset(),l=Math.max(i,c);o()[e>>2>>>0]=60*l,a()[t>>2>>>0]=Number(i!=c),e=n(s),t=n(u),e=Be(e),t=Be(t),c<i?(o()[r>>2>>>0]=e,o()[r+4>>2>>>0]=t):(o()[r>>2>>>0]=t,o()[r+4>>2>>>0]=e)},c:()=>{te("")},l:function(){},i:function(){return Date.now()},V:()=>{throw $+=1,"unwind"},B:function(){return 4294901760},e:()=>performance.timeOrigin+performance.now(),f:function(){return v?r(993).cpus().length:navigator.hardwareConcurrency},K:function(e,t,r,n){for(ge.pb=t>>>0,Je.length=r,t=n>>>0>>3,n=0;n<r;n++)Je[n]=i()[t+n>>>0];return lt[e].apply(null,Je)},y:function(e){e>>>=0;var t=n().length;if(e<=t||4294901760<e)return!1;for(var r=1;4>=r;r*=2){var a=t*(1+.2/r);a=Math.min(a,e+100663296);var o=Math;a=Math.max(e,a);e:{o=o.min.call(o,4294901760,a+(65536-a%65536)%65536)-k.buffer.byteLength+65535>>>16;try{k.grow(o),Y();var i=1;break e}catch(e){}i=void 0}if(i)return!0}return!1},O:Ze,P:Qe,j:pe,g:et,n:tt,w:rt,m:at,x:function(e,t){return e>>>=0,t>>>=0,ot(n().subarray(e>>>0,e+t>>>0)),0},a:k||c.wasmMemory,H:ct,d:function(e,t,r,n){return ct(e>>>0,t>>>0,r>>>0,n>>>0)}};!function(){function e(e,t){return e=e.exports,C=e=function(e){var t=e=>()=>e()>>>0,r=e=>t=>e(t)>>>0;return(e=Object.assign({},e)).__errno_location=t(e.__errno_location),e.pthread_self=t(e.pthread_self),e.malloc=r(e.malloc),e.stackSave=t(e.stackSave),e.stackAlloc=r(e.stackAlloc),e}(e),ge.Ta.push(C.sa),z=C.ta,N.unshift(C.W),P=t,ee(),e}var t={a:ft};if(Q(),c.instantiateWasm)try{return c.instantiateWasm(t,e)}catch(e){R("Module.instantiateWasm callback failed with error: "+e),u(e)}(function(e,t){var r=V;return T||"function"!=typeof WebAssembly.instantiateStreaming||re(r)||r.startsWith("file://")||v||"function"!=typeof fetch?ae(r,e,t):fetch(r,{credentials:"same-origin"}).then((n=>WebAssembly.instantiateStreaming(n,e).then(t,(function(n){return R("wasm streaming compile failed: "+n),R("falling back to ArrayBuffer instantiation"),ae(r,e,t)}))))})(t,(function(t){e(t.instance,t.module)})).catch(u)}(),c._OrtInit=(e,t)=>(c._OrtInit=C.X)(e,t),c._OrtGetLastError=(e,t)=>(c._OrtGetLastError=C.Y)(e,t),c._OrtCreateSessionOptions=(e,t,r,n,a,o,i,s,u,l)=>(c._OrtCreateSessionOptions=C.Z)(e,t,r,n,a,o,i,s,u,l),c._OrtAppendExecutionProvider=(e,t)=>(c._OrtAppendExecutionProvider=C._)(e,t),c._OrtAddSessionConfigEntry=(e,t,r)=>(c._OrtAddSessionConfigEntry=C.$)(e,t,r),c._OrtReleaseSessionOptions=e=>(c._OrtReleaseSessionOptions=C.aa)(e),c._OrtCreateSession=(e,t,r)=>(c._OrtCreateSession=C.ba)(e,t,r),c._OrtReleaseSession=e=>(c._OrtReleaseSession=C.ca)(e),c._OrtGetInputOutputCount=(e,t,r)=>(c._OrtGetInputOutputCount=C.da)(e,t,r),c._OrtGetInputName=(e,t)=>(c._OrtGetInputName=C.ea)(e,t),c._OrtGetOutputName=(e,t)=>(c._OrtGetOutputName=C.fa)(e,t),c._OrtFree=e=>(c._OrtFree=C.ga)(e),c._OrtCreateTensor=(e,t,r,n,a)=>(c._OrtCreateTensor=C.ha)(e,t,r,n,a),c._OrtGetTensorData=(e,t,r,n,a)=>(c._OrtGetTensorData=C.ia)(e,t,r,n,a),c._OrtReleaseTensor=e=>(c._OrtReleaseTensor=C.ja)(e),c._OrtCreateRunOptions=(e,t,r,n)=>(c._OrtCreateRunOptions=C.ka)(e,t,r,n),c._OrtAddRunConfigEntry=(e,t,r)=>(c._OrtAddRunConfigEntry=C.la)(e,t,r),c._OrtReleaseRunOptions=e=>(c._OrtReleaseRunOptions=C.ma)(e),c._OrtRun=(e,t,r,n,a,o,i,s)=>(c._OrtRun=C.na)(e,t,r,n,a,o,i,s),c._OrtEndProfiling=e=>(c._OrtEndProfiling=C.oa)(e);var dt=c._pthread_self=()=>(dt=c._pthread_self=C.pa)(),pt=c._malloc=e=>(pt=c._malloc=C.qa)(e);c._free=e=>(c._free=C.ra)(e),c.__emscripten_tls_init=()=>(c.__emscripten_tls_init=C.sa)();var gt=c.__emscripten_thread_init=(e,t,r,n,a,o)=>(gt=c.__emscripten_thread_init=C.ua)(e,t,r,n,a,o);c.__emscripten_thread_crashed=()=>(c.__emscripten_thread_crashed=C.va)();var ht,mt=(e,t,r,n)=>(mt=C.wa)(e,t,r,n),yt=e=>(yt=C.xa)(e),vt=c.__emscripten_thread_exit=e=>(vt=c.__emscripten_thread_exit=C.ya)(e),bt=c.__emscripten_check_mailbox=()=>(bt=c.__emscripten_check_mailbox=C.za)(),wt=e=>(wt=C.Aa)(e),_t=(e,t)=>(_t=C.Ba)(e,t),Ot=()=>(Ot=C.Ca)(),St=e=>(St=C.Da)(e),Et=e=>(Et=C.Ea)(e);function At(){function e(){if(!ht&&(ht=!0,c.calledRun=!0,!H)&&(b||he(N),s(c),c.onRuntimeInitialized&&c.onRuntimeInitialized(),!b)){if(c.postRun)for("function"==typeof c.postRun&&(c.postRun=[c.postRun]);c.postRun.length;){var e=c.postRun.shift();B.unshift(e)}he(B)}}if(!(0<X))if(b)s(c),b||he(N),startWorker(c);else{if(c.preRun)for("function"==typeof c.preRun&&(c.preRun=[c.preRun]);c.preRun.length;)G.unshift(c.preRun.shift());he(G),0<X||(c.setStatus?(c.setStatus("Running..."),setTimeout((function(){setTimeout((function(){c.setStatus("")}),1),e()}),1)):e())}}if(c.keepRuntimeAlive=q,c.wasmMemory=k,c.stackAlloc=Et,c.stackSave=Ot,c.stackRestore=St,c.UTF8ToString=fe,c.stringToUTF8=Ae,c.lengthBytesUTF8=Se,c.ExitStatus=oe,c.PThread=ge,Z=function e(){ht||At(),ht||(Z=e)},c.preInit)for("function"==typeof c.preInit&&(c.preInit=[c.preInit]);0<c.preInit.length;)c.preInit.pop()();return At(),e.ready});e.exports=n},932:(e,t,r)=>{var _scriptDir,n=(_scriptDir="undefined"!=typeof document&&document.currentScript?document.currentScript.src:void 0,"undefined"!=typeof __filename&&(_scriptDir=_scriptDir||__filename),function(e={}){var t,n,a=e;a.ready=new Promise(((e,r)=>{t=e,n=r}));var o,i,s,u=Object.assign({},a),c="./this.program",l=(e,t)=>{throw t},f="object"==typeof window,d="function"==typeof importScripts,p="object"==typeof process&&"object"==typeof process.versions&&"string"==typeof process.versions.node,g="";if(p){var h=r(384),m=r(908);g=d?m.dirname(g)+"/":__dirname+"/",o=(e,t)=>(e=e.startsWith("file://")?new URL(e):m.normalize(e),h.readFileSync(e,t?void 0:"utf8")),s=e=>((e=o(e,!0)).buffer||(e=new Uint8Array(e)),e),i=(e,t,r,n=!0)=>{e=e.startsWith("file://")?new URL(e):m.normalize(e),h.readFile(e,n?void 0:"utf8",((e,a)=>{e?r(e):t(n?a.buffer:a)}))},!a.thisProgram&&1<process.argv.length&&(c=process.argv[1].replace(/\\\\/g,"/")),process.argv.slice(2),l=(e,t)=>{throw process.exitCode=e,t},a.inspect=()=>"[Emscripten Module object]"}else(f||d)&&(d?g=self.location.href:"undefined"!=typeof document&&document.currentScript&&(g=document.currentScript.src),_scriptDir&&(g=_scriptDir),g=0!==g.indexOf("blob:")?g.substr(0,g.replace(/[?#].*/,"").lastIndexOf("/")+1):"",o=e=>{var t=new XMLHttpRequest;return t.open("GET",e,!1),t.send(null),t.responseText},d&&(s=e=>{var t=new XMLHttpRequest;return t.open("GET",e,!1),t.responseType="arraybuffer",t.send(null),new Uint8Array(t.response)}),i=(e,t,r)=>{var n=new XMLHttpRequest;n.open("GET",e,!0),n.responseType="arraybuffer",n.onload=()=>{200==n.status||0==n.status&&n.response?t(n.response):r()},n.onerror=r,n.send(null)});var y,v=a.print||console.log.bind(console),b=a.printErr||console.error.bind(console);Object.assign(a,u),u=null,a.thisProgram&&(c=a.thisProgram),a.quit&&(l=a.quit),a.wasmBinary&&(y=a.wasmBinary);var w=a.noExitRuntime||!0;"object"!=typeof WebAssembly&&W("no native wasm support detected");var _,O,S,E,A,T,M=!1;function R(){var e=_.buffer;a.HEAP8=S=new Int8Array(e),a.HEAP16=new Int16Array(e),a.HEAP32=A=new Int32Array(e),a.HEAPU8=E=new Uint8Array(e),a.HEAPU16=new Uint16Array(e),a.HEAPU32=T=new Uint32Array(e),a.HEAPF32=new Float32Array(e),a.HEAPF64=new Float64Array(e)}var F=[],k=[],C=[];function P(){var e=a.preRun.shift();F.unshift(e)}var D,x,I=0,U=null,L=null;function W(e){throw a.onAbort&&a.onAbort(e),b(e="Aborted("+e+")"),M=!0,e=new WebAssembly.RuntimeError(e+". Build with -sASSERTIONS for more info."),n(e),e}function H(e){return e.startsWith("data:application/octet-stream;base64,")}if(!H(D="ort-wasm.wasm")){var Y=D;D=a.locateFile?a.locateFile(Y,g):g+Y}function j(e){if(e==D&&y)return new Uint8Array(y);if(s)return s(e);throw"both async and sync fetching of the wasm failed"}function z(e,t,r){return function(e){if(!y&&(f||d)){if("function"==typeof fetch&&!e.startsWith("file://"))return fetch(e,{credentials:"same-origin"}).then((t=>{if(!t.ok)throw"failed to load wasm binary file at \'"+e+"\'";return t.arrayBuffer()})).catch((()=>j(e)));if(i)return new Promise(((t,r)=>{i(e,(e=>t(new Uint8Array(e))),r)}))}return Promise.resolve().then((()=>j(e)))}(e).then((e=>WebAssembly.instantiate(e,t))).then((e=>e)).then(r,(e=>{b("failed to asynchronously prepare wasm: "+e),W(e)}))}function G(e){this.name="ExitStatus",this.message=`Program terminated with exit(${e})`,this.status=e}var N=e=>{for(;0<e.length;)e.shift()(a)};function B(e){this.qa=e-24,this.va=function(e){T[this.qa+4>>2>>>0]=e},this.ua=function(e){T[this.qa+8>>2>>>0]=e},this.sa=function(e,t){this.ta(),this.va(e),this.ua(t)},this.ta=function(){T[this.qa+16>>2>>>0]=0}}var $,q="undefined"!=typeof TextDecoder?new TextDecoder("utf8"):void 0,V=(e,t,r)=>{var n=(t>>>=0)+r;for(r=t;e[r]&&!(r>=n);)++r;if(16<r-t&&e.buffer&&q)return q.decode(e.subarray(t,r));for(n="";t<r;){var a=e[t++];if(128&a){var o=63&e[t++];if(192==(224&a))n+=String.fromCharCode((31&a)<<6|o);else{var i=63&e[t++];65536>(a=224==(240&a)?(15&a)<<12|o<<6|i:(7&a)<<18|o<<12|i<<6|63&e[t++])?n+=String.fromCharCode(a):(a-=65536,n+=String.fromCharCode(55296|a>>10,56320|1023&a))}}else n+=String.fromCharCode(a)}return n},J=(e,t)=>(e>>>=0)?V(E,e,t):"",X=e=>{for(var t=0,r=0;r<e.length;++r){var n=e.charCodeAt(r);127>=n?t++:2047>=n?t+=2:55296<=n&&57343>=n?(t+=4,++r):t+=3}return t},K=(e,t,r,n)=>{if(!(0<n))return 0;var a=r>>>=0;n=r+n-1;for(var o=0;o<e.length;++o){var i=e.charCodeAt(o);if(55296<=i&&57343>=i&&(i=65536+((1023&i)<<10)|1023&e.charCodeAt(++o)),127>=i){if(r>=n)break;t[r++>>>0]=i}else{if(2047>=i){if(r+1>=n)break;t[r++>>>0]=192|i>>6}else{if(65535>=i){if(r+2>=n)break;t[r++>>>0]=224|i>>12}else{if(r+3>=n)break;t[r++>>>0]=240|i>>18,t[r++>>>0]=128|i>>12&63}t[r++>>>0]=128|i>>6&63}t[r++>>>0]=128|63&i}}return t[r>>>0]=0,r-a},Z=e=>0==e%4&&(0!=e%100||0==e%400),Q=[0,31,60,91,121,152,182,213,244,274,305,335],ee=[0,31,59,90,120,151,181,212,243,273,304,334],te=e=>{var t=X(e)+1,r=le(t);return r&&K(e,E,r,t),r},re={},ne=()=>{if(!$){var e,t={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:("object"==typeof navigator&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:c||"./this.program"};for(e in re)void 0===re[e]?delete t[e]:t[e]=re[e];var r=[];for(e in t)r.push(`${e}=${t[e]}`);$=r}return $},ae=[null,[],[]],oe=e=>(oe=(()=>{if("object"==typeof crypto&&"function"==typeof crypto.getRandomValues)return e=>crypto.getRandomValues(e);if(p)try{var e=r(760);if(e.randomFillSync)return t=>e.randomFillSync(t);var t=e.randomBytes;return e=>(e.set(t(e.byteLength)),e)}catch(e){}W("initRandomDevice")})())(e),ie=[31,29,31,30,31,30,31,31,30,31,30,31],se=[31,28,31,30,31,30,31,31,30,31,30,31];function ue(e,t,r,n){function a(e,t,r){for(e="number"==typeof e?e.toString():e||"";e.length<t;)e=r[0]+e;return e}function o(e,t){return a(e,t,"0")}function i(e,t){function r(e){return 0>e?-1:0<e?1:0}var n;return 0===(n=r(e.getFullYear()-t.getFullYear()))&&0===(n=r(e.getMonth()-t.getMonth()))&&(n=r(e.getDate()-t.getDate())),n}function s(e){switch(e.getDay()){case 0:return new Date(e.getFullYear()-1,11,29);case 1:return e;case 2:return new Date(e.getFullYear(),0,3);case 3:return new Date(e.getFullYear(),0,2);case 4:return new Date(e.getFullYear(),0,1);case 5:return new Date(e.getFullYear()-1,11,31);case 6:return new Date(e.getFullYear()-1,11,30)}}function u(e){var t=e.ma;for(e=new Date(new Date(e.na+1900,0,1).getTime());0<t;){var r=e.getMonth(),n=(Z(e.getFullYear())?ie:se)[r];if(!(t>n-e.getDate())){e.setDate(e.getDate()+t);break}t-=n-e.getDate()+1,e.setDate(1),11>r?e.setMonth(r+1):(e.setMonth(0),e.setFullYear(e.getFullYear()+1))}return r=new Date(e.getFullYear()+1,0,4),t=s(new Date(e.getFullYear(),0,4)),r=s(r),0>=i(t,e)?0>=i(r,e)?e.getFullYear()+1:e.getFullYear():e.getFullYear()-1}e>>>=0,t>>>=0,r>>>=0;var c=A[40+(n>>>=0)>>2>>>0];for(var l in n={ya:A[n>>2>>>0],xa:A[n+4>>2>>>0],oa:A[n+8>>2>>>0],ra:A[n+12>>2>>>0],pa:A[n+16>>2>>>0],na:A[n+20>>2>>>0],ha:A[n+24>>2>>>0],ma:A[n+28>>2>>>0],Aa:A[n+32>>2>>>0],wa:A[n+36>>2>>>0],za:c?J(c):""},r=J(r),c={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"})r=r.replace(new RegExp(l,"g"),c[l]);var f="Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),d="January February March April May June July August September October November December".split(" ");for(l in c={"%a":e=>f[e.ha].substring(0,3),"%A":e=>f[e.ha],"%b":e=>d[e.pa].substring(0,3),"%B":e=>d[e.pa],"%C":e=>o((e.na+1900)/100|0,2),"%d":e=>o(e.ra,2),"%e":e=>a(e.ra,2," "),"%g":e=>u(e).toString().substring(2),"%G":e=>u(e),"%H":e=>o(e.oa,2),"%I":e=>(0==(e=e.oa)?e=12:12<e&&(e-=12),o(e,2)),"%j":e=>{for(var t=0,r=0;r<=e.pa-1;t+=(Z(e.na+1900)?ie:se)[r++]);return o(e.ra+t,3)},"%m":e=>o(e.pa+1,2),"%M":e=>o(e.xa,2),"%n":()=>"\\n","%p":e=>0<=e.oa&&12>e.oa?"AM":"PM","%S":e=>o(e.ya,2),"%t":()=>"\\t","%u":e=>e.ha||7,"%U":e=>o(Math.floor((e.ma+7-e.ha)/7),2),"%V":e=>{var t=Math.floor((e.ma+7-(e.ha+6)%7)/7);if(2>=(e.ha+371-e.ma-2)%7&&t++,t)53==t&&(4==(r=(e.ha+371-e.ma)%7)||3==r&&Z(e.na)||(t=1));else{t=52;var r=(e.ha+7-e.ma-1)%7;(4==r||5==r&&Z(e.na%400-1))&&t++}return o(t,2)},"%w":e=>e.ha,"%W":e=>o(Math.floor((e.ma+7-(e.ha+6)%7)/7),2),"%y":e=>(e.na+1900).toString().substring(2),"%Y":e=>e.na+1900,"%z":e=>{var t=0<=(e=e.wa);return e=Math.abs(e)/60,(t?"+":"-")+String("0000"+(e/60*100+e%60)).slice(-4)},"%Z":e=>e.za,"%%":()=>"%"},r=r.replace(/%%/g,"\\0\\0"),c)r.includes(l)&&(r=r.replace(new RegExp(l,"g"),c[l](n)));return l=function(e){var t=Array(X(e)+1);return K(e,t,0,t.length),t}(r=r.replace(/\\0\\0/g,"%")),l.length>t?0:(S.set(l,e>>>0),l.length-1)}var ce={a:function(e,t,r){throw new B(e>>>=0).sa(t>>>0,r>>>0),e},e:function(){return 0},I:function(){},y:function(){},A:function(){},K:function(){return 0},G:function(){},B:function(){},F:function(){},g:function(){},z:function(){},w:function(){},H:function(){},x:function(){},k:()=>!0,n:function(e,t,r){e=t+2097152>>>0<4194305-!!e?(e>>>0)+4294967296*t:NaN,r>>>=0,e=new Date(1e3*e),A[r>>2>>>0]=e.getUTCSeconds(),A[r+4>>2>>>0]=e.getUTCMinutes(),A[r+8>>2>>>0]=e.getUTCHours(),A[r+12>>2>>>0]=e.getUTCDate(),A[r+16>>2>>>0]=e.getUTCMonth(),A[r+20>>2>>>0]=e.getUTCFullYear()-1900,A[r+24>>2>>>0]=e.getUTCDay(),A[r+28>>2>>>0]=(e.getTime()-Date.UTC(e.getUTCFullYear(),0,1,0,0,0,0))/864e5|0},o:function(e,t,r){e=t+2097152>>>0<4194305-!!e?(e>>>0)+4294967296*t:NaN,r>>>=0,e=new Date(1e3*e),A[r>>2>>>0]=e.getSeconds(),A[r+4>>2>>>0]=e.getMinutes(),A[r+8>>2>>>0]=e.getHours(),A[r+12>>2>>>0]=e.getDate(),A[r+16>>2>>>0]=e.getMonth(),A[r+20>>2>>>0]=e.getFullYear()-1900,A[r+24>>2>>>0]=e.getDay(),A[r+28>>2>>>0]=(Z(e.getFullYear())?Q:ee)[e.getMonth()]+e.getDate()-1|0,A[r+36>>2>>>0]=-60*e.getTimezoneOffset(),t=new Date(e.getFullYear(),6,1).getTimezoneOffset();var n=new Date(e.getFullYear(),0,1).getTimezoneOffset();A[r+32>>2>>>0]=0|(t!=n&&e.getTimezoneOffset()==Math.min(n,t))},p:function(e){e>>>=0;var t=new Date(A[e+20>>2>>>0]+1900,A[e+16>>2>>>0],A[e+12>>2>>>0],A[e+8>>2>>>0],A[e+4>>2>>>0],A[e>>2>>>0],0),r=A[e+32>>2>>>0],n=t.getTimezoneOffset(),a=new Date(t.getFullYear(),6,1).getTimezoneOffset(),o=new Date(t.getFullYear(),0,1).getTimezoneOffset(),i=Math.min(o,a);return 0>r?A[e+32>>2>>>0]=Number(a!=o&&i==n):0<r!=(i==n)&&(a=Math.max(o,a),t.setTime(t.getTime()+6e4*((0<r?i:a)-n))),A[e+24>>2>>>0]=t.getDay(),A[e+28>>2>>>0]=(Z(t.getFullYear())?Q:ee)[t.getMonth()]+t.getDate()-1|0,A[e>>2>>>0]=t.getSeconds(),A[e+4>>2>>>0]=t.getMinutes(),A[e+8>>2>>>0]=t.getHours(),A[e+12>>2>>>0]=t.getDate(),A[e+16>>2>>>0]=t.getMonth(),A[e+20>>2>>>0]=t.getYear(),e=t.getTime()/1e3,de((x=e,1<=+Math.abs(x)?0<x?+Math.floor(x/4294967296)>>>0:~~+Math.ceil((x-+(~~x>>>0))/4294967296)>>>0:0)),e>>>0},l:function(){return-52},m:function(){},u:function(e,t,r){function n(e){return(e=e.toTimeString().match(/\\(([A-Za-z ]+)\\)$/))?e[1]:"GMT"}r>>>=0;var a=(new Date).getFullYear(),o=new Date(a,0,1),i=new Date(a,6,1);a=o.getTimezoneOffset();var s=i.getTimezoneOffset();T[e>>>0>>2>>>0]=60*Math.max(a,s),A[t>>>0>>2>>>0]=Number(a!=s),e=n(o),t=n(i),e=te(e),t=te(t),s<a?(T[r>>2>>>0]=e,T[r+4>>2>>>0]=t):(T[r>>2>>>0]=t,T[r+4>>2>>>0]=e)},d:()=>{W("")},h:function(){return Date.now()},v:function(){return 4294901760},b:()=>performance.now(),J:function(e,t,r){return t>>>=0,E.copyWithin(e>>>0>>>0,t>>>0,t+(r>>>0)>>>0)},t:function(e){e>>>=0;var t=E.length;if(4294901760<e)return!1;for(var r=1;4>=r;r*=2){var n=t*(1+.2/r);n=Math.min(n,e+100663296);var a=Math;n=Math.max(e,n);e:{a=a.min.call(a,4294901760,n+(65536-n%65536)%65536)-_.buffer.byteLength+65535>>>16;try{_.grow(a),R();var o=1;break e}catch(e){}o=void 0}if(o)return!0}return!1},D:function(e,t){e>>>=0,t>>>=0;var r=0;return ne().forEach((function(n,a){var o=t+r;for(a=T[e+4*a>>2>>>0]=o,o=0;o<n.length;++o)S[a++>>0>>>0]=n.charCodeAt(o);S[a>>0>>>0]=0,r+=n.length+1})),0},E:function(e,t){e>>>=0,t>>>=0;var r=ne();T[e>>2>>>0]=r.length;var n=0;return r.forEach((function(e){n+=e.length+1})),T[t>>2>>>0]=n,0},s:e=>{w||(a.onExit&&a.onExit(e),M=!0),l(e,new G(e))},f:()=>52,j:function(){return 52},q:function(){return 70},i:function(e,t,r,n){t>>>=0,r>>>=0,n>>>=0;for(var a=0,o=0;o<r;o++){var i=T[t>>2>>>0],s=T[t+4>>2>>>0];t+=8;for(var u=0;u<s;u++){var c=E[i+u>>>0],l=ae[e];0===c||10===c?((1===e?v:b)(V(l,0)),l.length=0):l.push(c)}a+=s}return T[n>>2>>>0]=a,0},r:function(e,t){return e>>>=0,oe(E.subarray(e>>>0,e+(t>>>0)>>>0)),0},C:ue,c:function(e,t,r,n){return ue(e>>>0,t>>>0,r>>>0,n>>>0)}};!function(){function e(e){if(e=e.exports,O=e=function(e){var t=e=>()=>e()>>>0,r=e=>t=>e(t)>>>0;return(e=Object.assign({},e)).__errno_location=t(e.__errno_location),e.malloc=r(e.malloc),e.stackSave=t(e.stackSave),e.stackAlloc=r(e.stackAlloc),e}(e),_=O.L,R(),k.unshift(O.M),I--,a.monitorRunDependencies&&a.monitorRunDependencies(I),0==I&&(null!==U&&(clearInterval(U),U=null),L)){var t=L;L=null,t()}return e}var t={a:ce};if(I++,a.monitorRunDependencies&&a.monitorRunDependencies(I),a.instantiateWasm)try{return a.instantiateWasm(t,e)}catch(e){b("Module.instantiateWasm callback failed with error: "+e),n(e)}(function(e,t){var r=D;return y||"function"!=typeof WebAssembly.instantiateStreaming||H(r)||r.startsWith("file://")||p||"function"!=typeof fetch?z(r,e,t):fetch(r,{credentials:"same-origin"}).then((n=>WebAssembly.instantiateStreaming(n,e).then(t,(function(n){return b("wasm streaming compile failed: "+n),b("falling back to ArrayBuffer instantiation"),z(r,e,t)}))))})(t,(function(t){e(t.instance)})).catch(n)}(),a._OrtInit=(e,t)=>(a._OrtInit=O.N)(e,t),a._OrtGetLastError=(e,t)=>(a._OrtGetLastError=O.O)(e,t),a._OrtCreateSessionOptions=(e,t,r,n,o,i,s,u,c,l)=>(a._OrtCreateSessionOptions=O.P)(e,t,r,n,o,i,s,u,c,l),a._OrtAppendExecutionProvider=(e,t)=>(a._OrtAppendExecutionProvider=O.Q)(e,t),a._OrtAddSessionConfigEntry=(e,t,r)=>(a._OrtAddSessionConfigEntry=O.R)(e,t,r),a._OrtReleaseSessionOptions=e=>(a._OrtReleaseSessionOptions=O.S)(e),a._OrtCreateSession=(e,t,r)=>(a._OrtCreateSession=O.T)(e,t,r),a._OrtReleaseSession=e=>(a._OrtReleaseSession=O.U)(e),a._OrtGetInputOutputCount=(e,t,r)=>(a._OrtGetInputOutputCount=O.V)(e,t,r),a._OrtGetInputName=(e,t)=>(a._OrtGetInputName=O.W)(e,t),a._OrtGetOutputName=(e,t)=>(a._OrtGetOutputName=O.X)(e,t),a._OrtFree=e=>(a._OrtFree=O.Y)(e),a._OrtCreateTensor=(e,t,r,n,o)=>(a._OrtCreateTensor=O.Z)(e,t,r,n,o),a._OrtGetTensorData=(e,t,r,n,o)=>(a._OrtGetTensorData=O._)(e,t,r,n,o),a._OrtReleaseTensor=e=>(a._OrtReleaseTensor=O.$)(e),a._OrtCreateRunOptions=(e,t,r,n)=>(a._OrtCreateRunOptions=O.aa)(e,t,r,n),a._OrtAddRunConfigEntry=(e,t,r)=>(a._OrtAddRunConfigEntry=O.ba)(e,t,r),a._OrtReleaseRunOptions=e=>(a._OrtReleaseRunOptions=O.ca)(e),a._OrtRun=(e,t,r,n,o,i,s,u)=>(a._OrtRun=O.da)(e,t,r,n,o,i,s,u),a._OrtEndProfiling=e=>(a._OrtEndProfiling=O.ea)(e);var le=a._malloc=e=>(le=a._malloc=O.fa)(e);a._free=e=>(a._free=O.ga)(e);var fe,de=e=>(de=O.ia)(e),pe=()=>(pe=O.ja)(),ge=e=>(ge=O.ka)(e),he=e=>(he=O.la)(e);function me(){function e(){if(!fe&&(fe=!0,a.calledRun=!0,!M)){if(N(k),t(a),a.onRuntimeInitialized&&a.onRuntimeInitialized(),a.postRun)for("function"==typeof a.postRun&&(a.postRun=[a.postRun]);a.postRun.length;){var e=a.postRun.shift();C.unshift(e)}N(C)}}if(!(0<I)){if(a.preRun)for("function"==typeof a.preRun&&(a.preRun=[a.preRun]);a.preRun.length;)P();N(F),0<I||(a.setStatus?(a.setStatus("Running..."),setTimeout((function(){setTimeout((function(){a.setStatus("")}),1),e()}),1)):e())}}if(a.stackAlloc=he,a.stackSave=pe,a.stackRestore=ge,a.UTF8ToString=J,a.stringToUTF8=(e,t,r)=>K(e,E,t,r),a.lengthBytesUTF8=X,L=function e(){fe||me(),fe||(L=e)},a.preInit)for("function"==typeof a.preInit&&(a.preInit=[a.preInit]);0<a.preInit.length;)a.preInit.pop()();return me(),e.ready});e.exports=n},154:e=>{"use strict";e.exports=\'"use strict";var e={},a="object"==typeof process&&"object"==typeof process.versions&&"string"==typeof process.versions.node;if(a){var r=require("worker_threads"),t=r.parentPort;t.on("message",(e=>onmessage({data:e})));var s=require("fs");Object.assign(global,{self:global,require:require,Module:e,location:{href:__filename},Worker:r.Worker,importScripts:e=>(0,eval)(s.readFileSync(e,"utf8")+"//# sourceURL="+e),postMessage:e=>t.postMessage(e),performance:global.performance||{now:Date.now}})}var o=!1,d=function(){var e=Array.prototype.slice.call(arguments).join(" ");a?s.writeSync(2,e+"\\\\n"):console.error(e)};self.alert=function(){var a=Array.prototype.slice.call(arguments).join(" ");postMessage({cmd:"alert",text:a,threadId:e._pthread_self()})},e.instantiateWasm=(a,r)=>{var t=e.wasmModule;return e.wasmModule=null,r(new WebAssembly.Instance(t,a))},self.onunhandledrejection=e=>{throw e.reason??e},self.onmessage=function a(r){try{if("load"===r.data.cmd){let s=[];self.onmessage=e=>s.push(e),self.startWorker=r=>{e=r,postMessage({cmd:"loaded"});for(let e of s)a(e);self.onmessage=a},e.wasmModule=r.data.wasmModule;for(const a of r.data.handlers)e[a]=(...e)=>{postMessage({cmd:"callHandler",handler:a,args:e})};if(e.wasmMemory=r.data.wasmMemory,e.buffer=e.wasmMemory.buffer,e.ENVIRONMENT_IS_PTHREAD=!0,"string"==typeof r.data.urlOrBlob)importScripts(r.data.urlOrBlob);else{var t=URL.createObjectURL(r.data.urlOrBlob);importScripts(t),URL.revokeObjectURL(t)}ortWasmThreaded(e)}else if("run"===r.data.cmd){e.__emscripten_thread_init(r.data.pthread_ptr,0,0,1),e.__emscripten_thread_mailbox_await(r.data.pthread_ptr),e.establishStackSpace(),e.PThread.receiveObjectTransfer(r.data),e.PThread.threadInitTLS(),o||(o=!0);try{e.invokeEntryPoint(r.data.start_routine,r.data.arg)}catch(e){if("unwind"!=e)throw e}}else"cancel"===r.data.cmd?e._pthread_self()&&e.__emscripten_thread_exit(-1):"setimmediate"===r.data.target||("checkMailbox"===r.data.cmd?o&&e.checkMailbox():r.data.cmd&&(d("worker.js received unknown command "+r.data.cmd),d(r.data)))}catch(a){throw e.__emscripten_thread_crashed&&e.__emscripten_thread_crashed(),a}};\\n\'},760:()=>{},384:()=>{},993:()=>{},908:()=>{},953:()=>{},925:()=>{},449:()=>{}},t={};function r(n){var a=t[n];if(void 0!==a)return a.exports;var o=t[n]={exports:{}};return e[n].call(o.exports,o,o.exports,r),o.exports}(()=>{"use strict";const e=r(259),t=r(263);self.onmessage=r=>{switch(r.data.type){case"init-wasm":try{(0,t.initializeWebAssembly)(r.data.in).then((()=>postMessage({type:"init-wasm"})),(e=>postMessage({type:"init-wasm",err:e})))}catch(e){postMessage({type:"init-wasm",err:e})}break;case"init-ort":try{(0,e.initRuntime)(r.data.in).then((()=>postMessage({type:"init-ort"})),(e=>postMessage({type:"init-ort",err:e}))),postMessage({type:"init-ort"})}catch(e){postMessage({type:"init-ort",err:e})}break;case"create_allocate":try{const{model:t}=r.data.in,n=(0,e.createSessionAllocate)(t);postMessage({type:"create_allocate",out:n})}catch(e){postMessage({type:"create_allocate",err:e})}break;case"create_finalize":try{const{modeldata:t,options:n}=r.data.in,a=(0,e.createSessionFinalize)(t,n);postMessage({type:"create_finalize",out:a})}catch(e){postMessage({type:"create_finalize",err:e})}break;case"create":try{const{model:t,options:n}=r.data.in,a=(0,e.createSession)(t,n);postMessage({type:"create",out:a})}catch(e){postMessage({type:"create",err:e})}break;case"release":try{const t=r.data.in;(0,e.releaseSession)(t),postMessage({type:"release"})}catch(e){postMessage({type:"release",err:e})}break;case"run":try{const{sessionId:t,inputIndices:n,inputs:a,outputIndices:o,options:i}=r.data.in;(0,e.run)(t,n,a,o,i).then((t=>{postMessage({type:"run",out:t},(0,e.extractTransferableBuffers)(t))}),(e=>{postMessage({type:"run",err:e})}))}catch(e){postMessage({type:"run",err:e})}break;case"end-profiling":try{const t=r.data.in;(0,e.endProfiling)(t),postMessage({type:"end-profiling"})}catch(e){postMessage({type:"end-profiling",err:e})}}}})()})();\n',"Worker",void 0,void 0)}},6614:ge=>{"use strict";ge.exports=function(E,$,F,N){var R=self||window;try{try{var k;try{k=new R.Blob([E])}catch{(k=new(R.BlobBuilder||R.WebKitBlobBuilder||R.MozBlobBuilder||R.MSBlobBuilder)).append(E),k=k.getBlob()}var S=R.URL||R.webkitURL,C=S.createObjectURL(k),v=new R[$](C,F);return S.revokeObjectURL(C),v}catch{return new R[$]("data:application/javascript,".concat(encodeURIComponent(E)),F)}}catch{if(!N)throw Error("Inline worker is not supported");return new R[$](N,F)}}},2446:(ge,E,$)=>{"use strict";var F,N,R,h,l,k=$(2100),S=k.Reader,C=k.Writer,v=k.util,g=k.roots.default||(k.roots.default={});g.onnx=((R={}).Version=(F={},(N=Object.create(F))[F[0]="_START_VERSION"]=0,N[F[1]="IR_VERSION_2017_10_10"]=1,N[F[2]="IR_VERSION_2017_10_30"]=2,N[F[3]="IR_VERSION_2017_11_3"]=3,N[F[4]="IR_VERSION_2019_1_22"]=4,N[F[5]="IR_VERSION_2019_3_18"]=5,N[F[6]="IR_VERSION_2019_9_19"]=6,N[F[7]="IR_VERSION_2020_5_8"]=7,N[F[8]="IR_VERSION_2021_7_30"]=8,N[F[9]="IR_VERSION"]=9,N),R.AttributeProto=function(){function h(l){if(this.floats=[],this.ints=[],this.strings=[],this.tensors=[],this.graphs=[],this.sparseTensors=[],this.typeProtos=[],l)for(var d=Object.keys(l),f=0;f<d.length;++f)null!=l[d[f]]&&(this[d[f]]=l[d[f]])}return h.prototype.name="",h.prototype.refAttrName="",h.prototype.docString="",h.prototype.type=0,h.prototype.f=0,h.prototype.i=v.Long?v.Long.fromBits(0,0,!1):0,h.prototype.s=v.newBuffer([]),h.prototype.t=null,h.prototype.g=null,h.prototype.sparseTensor=null,h.prototype.tp=null,h.prototype.floats=v.emptyArray,h.prototype.ints=v.emptyArray,h.prototype.strings=v.emptyArray,h.prototype.tensors=v.emptyArray,h.prototype.graphs=v.emptyArray,h.prototype.sparseTensors=v.emptyArray,h.prototype.typeProtos=v.emptyArray,h.create=function(l){return new h(l)},h.encode=function(l,d){if(d||(d=C.create()),null!=l.name&&Object.hasOwnProperty.call(l,"name")&&d.uint32(10).string(l.name),null!=l.f&&Object.hasOwnProperty.call(l,"f")&&d.uint32(21).float(l.f),null!=l.i&&Object.hasOwnProperty.call(l,"i")&&d.uint32(24).int64(l.i),null!=l.s&&Object.hasOwnProperty.call(l,"s")&&d.uint32(34).bytes(l.s),null!=l.t&&Object.hasOwnProperty.call(l,"t")&&g.onnx.TensorProto.encode(l.t,d.uint32(42).fork()).ldelim(),null!=l.g&&Object.hasOwnProperty.call(l,"g")&&g.onnx.GraphProto.encode(l.g,d.uint32(50).fork()).ldelim(),null!=l.floats&&l.floats.length){d.uint32(58).fork();for(var f=0;f<l.floats.length;++f)d.float(l.floats[f]);d.ldelim()}if(null!=l.ints&&l.ints.length){for(d.uint32(66).fork(),f=0;f<l.ints.length;++f)d.int64(l.ints[f]);d.ldelim()}if(null!=l.strings&&l.strings.length)for(f=0;f<l.strings.length;++f)d.uint32(74).bytes(l.strings[f]);if(null!=l.tensors&&l.tensors.length)for(f=0;f<l.tensors.length;++f)g.onnx.TensorProto.encode(l.tensors[f],d.uint32(82).fork()).ldelim();if(null!=l.graphs&&l.graphs.length)for(f=0;f<l.graphs.length;++f)g.onnx.GraphProto.encode(l.graphs[f],d.uint32(90).fork()).ldelim();if(null!=l.docString&&Object.hasOwnProperty.call(l,"docString")&&d.uint32(106).string(l.docString),null!=l.tp&&Object.hasOwnProperty.call(l,"tp")&&g.onnx.TypeProto.encode(l.tp,d.uint32(114).fork()).ldelim(),null!=l.typeProtos&&l.typeProtos.length)for(f=0;f<l.typeProtos.length;++f)g.onnx.TypeProto.encode(l.typeProtos[f],d.uint32(122).fork()).ldelim();if(null!=l.type&&Object.hasOwnProperty.call(l,"type")&&d.uint32(160).int32(l.type),null!=l.refAttrName&&Object.hasOwnProperty.call(l,"refAttrName")&&d.uint32(170).string(l.refAttrName),null!=l.sparseTensor&&Object.hasOwnProperty.call(l,"sparseTensor")&&g.onnx.SparseTensorProto.encode(l.sparseTensor,d.uint32(178).fork()).ldelim(),null!=l.sparseTensors&&l.sparseTensors.length)for(f=0;f<l.sparseTensors.length;++f)g.onnx.SparseTensorProto.encode(l.sparseTensors[f],d.uint32(186).fork()).ldelim();return d},h.encodeDelimited=function(l,d){return this.encode(l,d).ldelim()},h.decode=function(l,d){l instanceof S||(l=S.create(l));for(var f=void 0===d?l.len:l.pos+d,b=new g.onnx.AttributeProto;l.pos<f;){var x=l.uint32();switch(x>>>3){case 1:b.name=l.string();break;case 21:b.refAttrName=l.string();break;case 13:b.docString=l.string();break;case 20:b.type=l.int32();break;case 2:b.f=l.float();break;case 3:b.i=l.int64();break;case 4:b.s=l.bytes();break;case 5:b.t=g.onnx.TensorProto.decode(l,l.uint32());break;case 6:b.g=g.onnx.GraphProto.decode(l,l.uint32());break;case 22:b.sparseTensor=g.onnx.SparseTensorProto.decode(l,l.uint32());break;case 14:b.tp=g.onnx.TypeProto.decode(l,l.uint32());break;case 7:if(b.floats&&b.floats.length||(b.floats=[]),2==(7&x))for(var D=l.uint32()+l.pos;l.pos<D;)b.floats.push(l.float());else b.floats.push(l.float());break;case 8:if(b.ints&&b.ints.length||(b.ints=[]),2==(7&x))for(D=l.uint32()+l.pos;l.pos<D;)b.ints.push(l.int64());else b.ints.push(l.int64());break;case 9:b.strings&&b.strings.length||(b.strings=[]),b.strings.push(l.bytes());break;case 10:b.tensors&&b.tensors.length||(b.tensors=[]),b.tensors.push(g.onnx.TensorProto.decode(l,l.uint32()));break;case 11:b.graphs&&b.graphs.length||(b.graphs=[]),b.graphs.push(g.onnx.GraphProto.decode(l,l.uint32()));break;case 23:b.sparseTensors&&b.sparseTensors.length||(b.sparseTensors=[]),b.sparseTensors.push(g.onnx.SparseTensorProto.decode(l,l.uint32()));break;case 15:b.typeProtos&&b.typeProtos.length||(b.typeProtos=[]),b.typeProtos.push(g.onnx.TypeProto.decode(l,l.uint32()));break;default:l.skipType(7&x)}}return b},h.decodeDelimited=function(l){return l instanceof S||(l=new S(l)),this.decode(l,l.uint32())},h.verify=function(l){if("object"!=typeof l||null===l)return"object expected";if(null!=l.name&&l.hasOwnProperty("name")&&!v.isString(l.name))return"name: string expected";if(null!=l.refAttrName&&l.hasOwnProperty("refAttrName")&&!v.isString(l.refAttrName))return"refAttrName: string expected";if(null!=l.docString&&l.hasOwnProperty("docString")&&!v.isString(l.docString))return"docString: string expected";if(null!=l.type&&l.hasOwnProperty("type"))switch(l.type){default:return"type: enum value expected";case 0:case 1:case 2:case 3:case 4:case 5:case 11:case 13:case 6:case 7:case 8:case 9:case 10:case 12:case 14:}if(null!=l.f&&l.hasOwnProperty("f")&&"number"!=typeof l.f)return"f: number expected";if(null!=l.i&&l.hasOwnProperty("i")&&!(v.isInteger(l.i)||l.i&&v.isInteger(l.i.low)&&v.isInteger(l.i.high)))return"i: integer|Long expected";if(null!=l.s&&l.hasOwnProperty("s")&&!(l.s&&"number"==typeof l.s.length||v.isString(l.s)))return"s: buffer expected";if(null!=l.t&&l.hasOwnProperty("t")&&(f=g.onnx.TensorProto.verify(l.t)))return"t."+f;if(null!=l.g&&l.hasOwnProperty("g")&&(f=g.onnx.GraphProto.verify(l.g)))return"g."+f;if(null!=l.sparseTensor&&l.hasOwnProperty("sparseTensor")&&(f=g.onnx.SparseTensorProto.verify(l.sparseTensor)))return"sparseTensor."+f;if(null!=l.tp&&l.hasOwnProperty("tp")&&(f=g.onnx.TypeProto.verify(l.tp)))return"tp."+f;if(null!=l.floats&&l.hasOwnProperty("floats")){if(!Array.isArray(l.floats))return"floats: array expected";for(var d=0;d<l.floats.length;++d)if("number"!=typeof l.floats[d])return"floats: number[] expected"}if(null!=l.ints&&l.hasOwnProperty("ints")){if(!Array.isArray(l.ints))return"ints: array expected";for(d=0;d<l.ints.length;++d)if(!(v.isInteger(l.ints[d])||l.ints[d]&&v.isInteger(l.ints[d].low)&&v.isInteger(l.ints[d].high)))return"ints: integer|Long[] expected"}if(null!=l.strings&&l.hasOwnProperty("strings")){if(!Array.isArray(l.strings))return"strings: array expected";for(d=0;d<l.strings.length;++d)if(!(l.strings[d]&&"number"==typeof l.strings[d].length||v.isString(l.strings[d])))return"strings: buffer[] expected"}if(null!=l.tensors&&l.hasOwnProperty("tensors")){if(!Array.isArray(l.tensors))return"tensors: array expected";for(d=0;d<l.tensors.length;++d)if(f=g.onnx.TensorProto.verify(l.tensors[d]))return"tensors."+f}if(null!=l.graphs&&l.hasOwnProperty("graphs")){if(!Array.isArray(l.graphs))return"graphs: array expected";for(d=0;d<l.graphs.length;++d)if(f=g.onnx.GraphProto.verify(l.graphs[d]))return"graphs."+f}if(null!=l.sparseTensors&&l.hasOwnProperty("sparseTensors")){if(!Array.isArray(l.sparseTensors))return"sparseTensors: array expected";for(d=0;d<l.sparseTensors.length;++d)if(f=g.onnx.SparseTensorProto.verify(l.sparseTensors[d]))return"sparseTensors."+f}if(null!=l.typeProtos&&l.hasOwnProperty("typeProtos")){if(!Array.isArray(l.typeProtos))return"typeProtos: array expected";for(d=0;d<l.typeProtos.length;++d){var f;if(f=g.onnx.TypeProto.verify(l.typeProtos[d]))return"typeProtos."+f}}return null},h.fromObject=function(l){if(l instanceof g.onnx.AttributeProto)return l;var d=new g.onnx.AttributeProto;switch(null!=l.name&&(d.name=String(l.name)),null!=l.refAttrName&&(d.refAttrName=String(l.refAttrName)),null!=l.docString&&(d.docString=String(l.docString)),l.type){default:if("number"==typeof l.type){d.type=l.type;break}break;case"UNDEFINED":case 0:d.type=0;break;case"FLOAT":case 1:d.type=1;break;case"INT":case 2:d.type=2;break;case"STRING":case 3:d.type=3;break;case"TENSOR":case 4:d.type=4;break;case"GRAPH":case 5:d.type=5;break;case"SPARSE_TENSOR":case 11:d.type=11;break;case"TYPE_PROTO":case 13:d.type=13;break;case"FLOATS":case 6:d.type=6;break;case"INTS":case 7:d.type=7;break;case"STRINGS":case 8:d.type=8;break;case"TENSORS":case 9:d.type=9;break;case"GRAPHS":case 10:d.type=10;break;case"SPARSE_TENSORS":case 12:d.type=12;break;case"TYPE_PROTOS":case 14:d.type=14}if(null!=l.f&&(d.f=Number(l.f)),null!=l.i&&(v.Long?(d.i=v.Long.fromValue(l.i)).unsigned=!1:"string"==typeof l.i?d.i=parseInt(l.i,10):"number"==typeof l.i?d.i=l.i:"object"==typeof l.i&&(d.i=new v.LongBits(l.i.low>>>0,l.i.high>>>0).toNumber())),null!=l.s&&("string"==typeof l.s?v.base64.decode(l.s,d.s=v.newBuffer(v.base64.length(l.s)),0):l.s.length>=0&&(d.s=l.s)),null!=l.t){if("object"!=typeof l.t)throw TypeError(".onnx.AttributeProto.t: object expected");d.t=g.onnx.TensorProto.fromObject(l.t)}if(null!=l.g){if("object"!=typeof l.g)throw TypeError(".onnx.AttributeProto.g: object expected");d.g=g.onnx.GraphProto.fromObject(l.g)}if(null!=l.sparseTensor){if("object"!=typeof l.sparseTensor)throw TypeError(".onnx.AttributeProto.sparseTensor: object expected");d.sparseTensor=g.onnx.SparseTensorProto.fromObject(l.sparseTensor)}if(null!=l.tp){if("object"!=typeof l.tp)throw TypeError(".onnx.AttributeProto.tp: object expected");d.tp=g.onnx.TypeProto.fromObject(l.tp)}if(l.floats){if(!Array.isArray(l.floats))throw TypeError(".onnx.AttributeProto.floats: array expected");d.floats=[];for(var f=0;f<l.floats.length;++f)d.floats[f]=Number(l.floats[f])}if(l.ints){if(!Array.isArray(l.ints))throw TypeError(".onnx.AttributeProto.ints: array expected");for(d.ints=[],f=0;f<l.ints.length;++f)v.Long?(d.ints[f]=v.Long.fromValue(l.ints[f])).unsigned=!1:"string"==typeof l.ints[f]?d.ints[f]=parseInt(l.ints[f],10):"number"==typeof l.ints[f]?d.ints[f]=l.ints[f]:"object"==typeof l.ints[f]&&(d.ints[f]=new v.LongBits(l.ints[f].low>>>0,l.ints[f].high>>>0).toNumber())}if(l.strings){if(!Array.isArray(l.strings))throw TypeError(".onnx.AttributeProto.strings: array expected");for(d.strings=[],f=0;f<l.strings.length;++f)"string"==typeof l.strings[f]?v.base64.decode(l.strings[f],d.strings[f]=v.newBuffer(v.base64.length(l.strings[f])),0):l.strings[f].length>=0&&(d.strings[f]=l.strings[f])}if(l.tensors){if(!Array.isArray(l.tensors))throw TypeError(".onnx.AttributeProto.tensors: array expected");for(d.tensors=[],f=0;f<l.tensors.length;++f){if("object"!=typeof l.tensors[f])throw TypeError(".onnx.AttributeProto.tensors: object expected");d.tensors[f]=g.onnx.TensorProto.fromObject(l.tensors[f])}}if(l.graphs){if(!Array.isArray(l.graphs))throw TypeError(".onnx.AttributeProto.graphs: array expected");for(d.graphs=[],f=0;f<l.graphs.length;++f){if("object"!=typeof l.graphs[f])throw TypeError(".onnx.AttributeProto.graphs: object expected");d.graphs[f]=g.onnx.GraphProto.fromObject(l.graphs[f])}}if(l.sparseTensors){if(!Array.isArray(l.sparseTensors))throw TypeError(".onnx.AttributeProto.sparseTensors: array expected");for(d.sparseTensors=[],f=0;f<l.sparseTensors.length;++f){if("object"!=typeof l.sparseTensors[f])throw TypeError(".onnx.AttributeProto.sparseTensors: object expected");d.sparseTensors[f]=g.onnx.SparseTensorProto.fromObject(l.sparseTensors[f])}}if(l.typeProtos){if(!Array.isArray(l.typeProtos))throw TypeError(".onnx.AttributeProto.typeProtos: array expected");for(d.typeProtos=[],f=0;f<l.typeProtos.length;++f){if("object"!=typeof l.typeProtos[f])throw TypeError(".onnx.AttributeProto.typeProtos: object expected");d.typeProtos[f]=g.onnx.TypeProto.fromObject(l.typeProtos[f])}}return d},h.toObject=function(l,d){d||(d={});var f={};if((d.arrays||d.defaults)&&(f.floats=[],f.ints=[],f.strings=[],f.tensors=[],f.graphs=[],f.typeProtos=[],f.sparseTensors=[]),d.defaults){if(f.name="",f.f=0,v.Long){var b=new v.Long(0,0,!1);f.i=d.longs===String?b.toString():d.longs===Number?b.toNumber():b}else f.i=d.longs===String?"0":0;d.bytes===String?f.s="":(f.s=[],d.bytes!==Array&&(f.s=v.newBuffer(f.s))),f.t=null,f.g=null,f.docString="",f.tp=null,f.type=d.enums===String?"UNDEFINED":0,f.refAttrName="",f.sparseTensor=null}if(null!=l.name&&l.hasOwnProperty("name")&&(f.name=l.name),null!=l.f&&l.hasOwnProperty("f")&&(f.f=d.json&&!isFinite(l.f)?String(l.f):l.f),null!=l.i&&l.hasOwnProperty("i")&&(f.i="number"==typeof l.i?d.longs===String?String(l.i):l.i:d.longs===String?v.Long.prototype.toString.call(l.i):d.longs===Number?new v.LongBits(l.i.low>>>0,l.i.high>>>0).toNumber():l.i),null!=l.s&&l.hasOwnProperty("s")&&(f.s=d.bytes===String?v.base64.encode(l.s,0,l.s.length):d.bytes===Array?Array.prototype.slice.call(l.s):l.s),null!=l.t&&l.hasOwnProperty("t")&&(f.t=g.onnx.TensorProto.toObject(l.t,d)),null!=l.g&&l.hasOwnProperty("g")&&(f.g=g.onnx.GraphProto.toObject(l.g,d)),l.floats&&l.floats.length){f.floats=[];for(var x=0;x<l.floats.length;++x)f.floats[x]=d.json&&!isFinite(l.floats[x])?String(l.floats[x]):l.floats[x]}if(l.ints&&l.ints.length)for(f.ints=[],x=0;x<l.ints.length;++x)f.ints[x]="number"==typeof l.ints[x]?d.longs===String?String(l.ints[x]):l.ints[x]:d.longs===String?v.Long.prototype.toString.call(l.ints[x]):d.longs===Number?new v.LongBits(l.ints[x].low>>>0,l.ints[x].high>>>0).toNumber():l.ints[x];if(l.strings&&l.strings.length)for(f.strings=[],x=0;x<l.strings.length;++x)f.strings[x]=d.bytes===String?v.base64.encode(l.strings[x],0,l.strings[x].length):d.bytes===Array?Array.prototype.slice.call(l.strings[x]):l.strings[x];if(l.tensors&&l.tensors.length)for(f.tensors=[],x=0;x<l.tensors.length;++x)f.tensors[x]=g.onnx.TensorProto.toObject(l.tensors[x],d);if(l.graphs&&l.graphs.length)for(f.graphs=[],x=0;x<l.graphs.length;++x)f.graphs[x]=g.onnx.GraphProto.toObject(l.graphs[x],d);if(null!=l.docString&&l.hasOwnProperty("docString")&&(f.docString=l.docString),null!=l.tp&&l.hasOwnProperty("tp")&&(f.tp=g.onnx.TypeProto.toObject(l.tp,d)),l.typeProtos&&l.typeProtos.length)for(f.typeProtos=[],x=0;x<l.typeProtos.length;++x)f.typeProtos[x]=g.onnx.TypeProto.toObject(l.typeProtos[x],d);if(null!=l.type&&l.hasOwnProperty("type")&&(f.type=d.enums===String?void 0===g.onnx.AttributeProto.AttributeType[l.type]?l.type:g.onnx.AttributeProto.AttributeType[l.type]:l.type),null!=l.refAttrName&&l.hasOwnProperty("refAttrName")&&(f.refAttrName=l.refAttrName),null!=l.sparseTensor&&l.hasOwnProperty("sparseTensor")&&(f.sparseTensor=g.onnx.SparseTensorProto.toObject(l.sparseTensor,d)),l.sparseTensors&&l.sparseTensors.length)for(f.sparseTensors=[],x=0;x<l.sparseTensors.length;++x)f.sparseTensors[x]=g.onnx.SparseTensorProto.toObject(l.sparseTensors[x],d);return f},h.prototype.toJSON=function(){return this.constructor.toObject(this,k.util.toJSONOptions)},h.getTypeUrl=function(l){return void 0===l&&(l="type.googleapis.com"),l+"/onnx.AttributeProto"},h.AttributeType=(l={},(d=Object.create(l))[l[0]="UNDEFINED"]=0,d[l[1]="FLOAT"]=1,d[l[2]="INT"]=2,d[l[3]="STRING"]=3,d[l[4]="TENSOR"]=4,d[l[5]="GRAPH"]=5,d[l[11]="SPARSE_TENSOR"]=11,d[l[13]="TYPE_PROTO"]=13,d[l[6]="FLOATS"]=6,d[l[7]="INTS"]=7,d[l[8]="STRINGS"]=8,d[l[9]="TENSORS"]=9,d[l[10]="GRAPHS"]=10,d[l[12]="SPARSE_TENSORS"]=12,d[l[14]="TYPE_PROTOS"]=14,d),h;var l,d}(),R.ValueInfoProto=function(){function h(l){if(l)for(var d=Object.keys(l),f=0;f<d.length;++f)null!=l[d[f]]&&(this[d[f]]=l[d[f]])}return h.prototype.name="",h.prototype.type=null,h.prototype.docString="",h.create=function(l){return new h(l)},h.encode=function(l,d){return d||(d=C.create()),null!=l.name&&Object.hasOwnProperty.call(l,"name")&&d.uint32(10).string(l.name),null!=l.type&&Object.hasOwnProperty.call(l,"type")&&g.onnx.TypeProto.encode(l.type,d.uint32(18).fork()).ldelim(),null!=l.docString&&Object.hasOwnProperty.call(l,"docString")&&d.uint32(26).string(l.docString),d},h.encodeDelimited=function(l,d){return this.encode(l,d).ldelim()},h.decode=function(l,d){l instanceof S||(l=S.create(l));for(var f=void 0===d?l.len:l.pos+d,b=new g.onnx.ValueInfoProto;l.pos<f;){var x=l.uint32();switch(x>>>3){case 1:b.name=l.string();break;case 2:b.type=g.onnx.TypeProto.decode(l,l.uint32());break;case 3:b.docString=l.string();break;default:l.skipType(7&x)}}return b},h.decodeDelimited=function(l){return l instanceof S||(l=new S(l)),this.decode(l,l.uint32())},h.verify=function(l){if("object"!=typeof l||null===l)return"object expected";if(null!=l.name&&l.hasOwnProperty("name")&&!v.isString(l.name))return"name: string expected";if(null!=l.type&&l.hasOwnProperty("type")){var d=g.onnx.TypeProto.verify(l.type);if(d)return"type."+d}return null!=l.docString&&l.hasOwnProperty("docString")&&!v.isString(l.docString)?"docString: string expected":null},h.fromObject=function(l){if(l instanceof g.onnx.ValueInfoProto)return l;var d=new g.onnx.ValueInfoProto;if(null!=l.name&&(d.name=String(l.name)),null!=l.type){if("object"!=typeof l.type)throw TypeError(".onnx.ValueInfoProto.type: object expected");d.type=g.onnx.TypeProto.fromObject(l.type)}return null!=l.docString&&(d.docString=String(l.docString)),d},h.toObject=function(l,d){d||(d={});var f={};return d.defaults&&(f.name="",f.type=null,f.docString=""),null!=l.name&&l.hasOwnProperty("name")&&(f.name=l.name),null!=l.type&&l.hasOwnProperty("type")&&(f.type=g.onnx.TypeProto.toObject(l.type,d)),null!=l.docString&&l.hasOwnProperty("docString")&&(f.docString=l.docString),f},h.prototype.toJSON=function(){return this.constructor.toObject(this,k.util.toJSONOptions)},h.getTypeUrl=function(l){return void 0===l&&(l="type.googleapis.com"),l+"/onnx.ValueInfoProto"},h}(),R.NodeProto=function(){function h(l){if(this.input=[],this.output=[],this.attribute=[],l)for(var d=Object.keys(l),f=0;f<d.length;++f)null!=l[d[f]]&&(this[d[f]]=l[d[f]])}return h.prototype.input=v.emptyArray,h.prototype.output=v.emptyArray,h.prototype.name="",h.prototype.opType="",h.prototype.domain="",h.prototype.attribute=v.emptyArray,h.prototype.docString="",h.create=function(l){return new h(l)},h.encode=function(l,d){if(d||(d=C.create()),null!=l.input&&l.input.length)for(var f=0;f<l.input.length;++f)d.uint32(10).string(l.input[f]);if(null!=l.output&&l.output.length)for(f=0;f<l.output.length;++f)d.uint32(18).string(l.output[f]);if(null!=l.name&&Object.hasOwnProperty.call(l,"name")&&d.uint32(26).string(l.name),null!=l.opType&&Object.hasOwnProperty.call(l,"opType")&&d.uint32(34).string(l.opType),null!=l.attribute&&l.attribute.length)for(f=0;f<l.attribute.length;++f)g.onnx.AttributeProto.encode(l.attribute[f],d.uint32(42).fork()).ldelim();return null!=l.docString&&Object.hasOwnProperty.call(l,"docString")&&d.uint32(50).string(l.docString),null!=l.domain&&Object.hasOwnProperty.call(l,"domain")&&d.uint32(58).string(l.domain),d},h.encodeDelimited=function(l,d){return this.encode(l,d).ldelim()},h.decode=function(l,d){l instanceof S||(l=S.create(l));for(var f=void 0===d?l.len:l.pos+d,b=new g.onnx.NodeProto;l.pos<f;){var x=l.uint32();switch(x>>>3){case 1:b.input&&b.input.length||(b.input=[]),b.input.push(l.string());break;case 2:b.output&&b.output.length||(b.output=[]),b.output.push(l.string());break;case 3:b.name=l.string();break;case 4:b.opType=l.string();break;case 7:b.domain=l.string();break;case 5:b.attribute&&b.attribute.length||(b.attribute=[]),b.attribute.push(g.onnx.AttributeProto.decode(l,l.uint32()));break;case 6:b.docString=l.string();break;default:l.skipType(7&x)}}return b},h.decodeDelimited=function(l){return l instanceof S||(l=new S(l)),this.decode(l,l.uint32())},h.verify=function(l){if("object"!=typeof l||null===l)return"object expected";if(null!=l.input&&l.hasOwnProperty("input")){if(!Array.isArray(l.input))return"input: array expected";for(var d=0;d<l.input.length;++d)if(!v.isString(l.input[d]))return"input: string[] expected"}if(null!=l.output&&l.hasOwnProperty("output")){if(!Array.isArray(l.output))return"output: array expected";for(d=0;d<l.output.length;++d)if(!v.isString(l.output[d]))return"output: string[] expected"}if(null!=l.name&&l.hasOwnProperty("name")&&!v.isString(l.name))return"name: string expected";if(null!=l.opType&&l.hasOwnProperty("opType")&&!v.isString(l.opType))return"opType: string expected";if(null!=l.domain&&l.hasOwnProperty("domain")&&!v.isString(l.domain))return"domain: string expected";if(null!=l.attribute&&l.hasOwnProperty("attribute")){if(!Array.isArray(l.attribute))return"attribute: array expected";for(d=0;d<l.attribute.length;++d){var f=g.onnx.AttributeProto.verify(l.attribute[d]);if(f)return"attribute."+f}}return null!=l.docString&&l.hasOwnProperty("docString")&&!v.isString(l.docString)?"docString: string expected":null},h.fromObject=function(l){if(l instanceof g.onnx.NodeProto)return l;var d=new g.onnx.NodeProto;if(l.input){if(!Array.isArray(l.input))throw TypeError(".onnx.NodeProto.input: array expected");d.input=[];for(var f=0;f<l.input.length;++f)d.input[f]=String(l.input[f])}if(l.output){if(!Array.isArray(l.output))throw TypeError(".onnx.NodeProto.output: array expected");for(d.output=[],f=0;f<l.output.length;++f)d.output[f]=String(l.output[f])}if(null!=l.name&&(d.name=String(l.name)),null!=l.opType&&(d.opType=String(l.opType)),null!=l.domain&&(d.domain=String(l.domain)),l.attribute){if(!Array.isArray(l.attribute))throw TypeError(".onnx.NodeProto.attribute: array expected");for(d.attribute=[],f=0;f<l.attribute.length;++f){if("object"!=typeof l.attribute[f])throw TypeError(".onnx.NodeProto.attribute: object expected");d.attribute[f]=g.onnx.AttributeProto.fromObject(l.attribute[f])}}return null!=l.docString&&(d.docString=String(l.docString)),d},h.toObject=function(l,d){d||(d={});var f={};if((d.arrays||d.defaults)&&(f.input=[],f.output=[],f.attribute=[]),d.defaults&&(f.name="",f.opType="",f.docString="",f.domain=""),l.input&&l.input.length){f.input=[];for(var b=0;b<l.input.length;++b)f.input[b]=l.input[b]}if(l.output&&l.output.length)for(f.output=[],b=0;b<l.output.length;++b)f.output[b]=l.output[b];if(null!=l.name&&l.hasOwnProperty("name")&&(f.name=l.name),null!=l.opType&&l.hasOwnProperty("opType")&&(f.opType=l.opType),l.attribute&&l.attribute.length)for(f.attribute=[],b=0;b<l.attribute.length;++b)f.attribute[b]=g.onnx.AttributeProto.toObject(l.attribute[b],d);return null!=l.docString&&l.hasOwnProperty("docString")&&(f.docString=l.docString),null!=l.domain&&l.hasOwnProperty("domain")&&(f.domain=l.domain),f},h.prototype.toJSON=function(){return this.constructor.toObject(this,k.util.toJSONOptions)},h.getTypeUrl=function(l){return void 0===l&&(l="type.googleapis.com"),l+"/onnx.NodeProto"},h}(),R.TrainingInfoProto=function(){function h(l){if(this.initializationBinding=[],this.updateBinding=[],l)for(var d=Object.keys(l),f=0;f<d.length;++f)null!=l[d[f]]&&(this[d[f]]=l[d[f]])}return h.prototype.initialization=null,h.prototype.algorithm=null,h.prototype.initializationBinding=v.emptyArray,h.prototype.updateBinding=v.emptyArray,h.create=function(l){return new h(l)},h.encode=function(l,d){if(d||(d=C.create()),null!=l.initialization&&Object.hasOwnProperty.call(l,"initialization")&&g.onnx.GraphProto.encode(l.initialization,d.uint32(10).fork()).ldelim(),null!=l.algorithm&&Object.hasOwnProperty.call(l,"algorithm")&&g.onnx.GraphProto.encode(l.algorithm,d.uint32(18).fork()).ldelim(),null!=l.initializationBinding&&l.initializationBinding.length)for(var f=0;f<l.initializationBinding.length;++f)g.onnx.StringStringEntryProto.encode(l.initializationBinding[f],d.uint32(26).fork()).ldelim();if(null!=l.updateBinding&&l.updateBinding.length)for(f=0;f<l.updateBinding.length;++f)g.onnx.StringStringEntryProto.encode(l.updateBinding[f],d.uint32(34).fork()).ldelim();return d},h.encodeDelimited=function(l,d){return this.encode(l,d).ldelim()},h.decode=function(l,d){l instanceof S||(l=S.create(l));for(var f=void 0===d?l.len:l.pos+d,b=new g.onnx.TrainingInfoProto;l.pos<f;){var x=l.uint32();switch(x>>>3){case 1:b.initialization=g.onnx.GraphProto.decode(l,l.uint32());break;case 2:b.algorithm=g.onnx.GraphProto.decode(l,l.uint32());break;case 3:b.initializationBinding&&b.initializationBinding.length||(b.initializationBinding=[]),b.initializationBinding.push(g.onnx.StringStringEntryProto.decode(l,l.uint32()));break;case 4:b.updateBinding&&b.updateBinding.length||(b.updateBinding=[]),b.updateBinding.push(g.onnx.StringStringEntryProto.decode(l,l.uint32()));break;default:l.skipType(7&x)}}return b},h.decodeDelimited=function(l){return l instanceof S||(l=new S(l)),this.decode(l,l.uint32())},h.verify=function(l){if("object"!=typeof l||null===l)return"object expected";if(null!=l.initialization&&l.hasOwnProperty("initialization")&&(f=g.onnx.GraphProto.verify(l.initialization)))return"initialization."+f;if(null!=l.algorithm&&l.hasOwnProperty("algorithm")&&(f=g.onnx.GraphProto.verify(l.algorithm)))return"algorithm."+f;if(null!=l.initializationBinding&&l.hasOwnProperty("initializationBinding")){if(!Array.isArray(l.initializationBinding))return"initializationBinding: array expected";for(var d=0;d<l.initializationBinding.length;++d)if(f=g.onnx.StringStringEntryProto.verify(l.initializationBinding[d]))return"initializationBinding."+f}if(null!=l.updateBinding&&l.hasOwnProperty("updateBinding")){if(!Array.isArray(l.updateBinding))return"updateBinding: array expected";for(d=0;d<l.updateBinding.length;++d){var f;if(f=g.onnx.StringStringEntryProto.verify(l.updateBinding[d]))return"updateBinding."+f}}return null},h.fromObject=function(l){if(l instanceof g.onnx.TrainingInfoProto)return l;var d=new g.onnx.TrainingInfoProto;if(null!=l.initialization){if("object"!=typeof l.initialization)throw TypeError(".onnx.TrainingInfoProto.initialization: object expected");d.initialization=g.onnx.GraphProto.fromObject(l.initialization)}if(null!=l.algorithm){if("object"!=typeof l.algorithm)throw TypeError(".onnx.TrainingInfoProto.algorithm: object expected");d.algorithm=g.onnx.GraphProto.fromObject(l.algorithm)}if(l.initializationBinding){if(!Array.isArray(l.initializationBinding))throw TypeError(".onnx.TrainingInfoProto.initializationBinding: array expected");d.initializationBinding=[];for(var f=0;f<l.initializationBinding.length;++f){if("object"!=typeof l.initializationBinding[f])throw TypeError(".onnx.TrainingInfoProto.initializationBinding: object expected");d.initializationBinding[f]=g.onnx.StringStringEntryProto.fromObject(l.initializationBinding[f])}}if(l.updateBinding){if(!Array.isArray(l.updateBinding))throw TypeError(".onnx.TrainingInfoProto.updateBinding: array expected");for(d.updateBinding=[],f=0;f<l.updateBinding.length;++f){if("object"!=typeof l.updateBinding[f])throw TypeError(".onnx.TrainingInfoProto.updateBinding: object expected");d.updateBinding[f]=g.onnx.StringStringEntryProto.fromObject(l.updateBinding[f])}}return d},h.toObject=function(l,d){d||(d={});var f={};if((d.arrays||d.defaults)&&(f.initializationBinding=[],f.updateBinding=[]),d.defaults&&(f.initialization=null,f.algorithm=null),null!=l.initialization&&l.hasOwnProperty("initialization")&&(f.initialization=g.onnx.GraphProto.toObject(l.initialization,d)),null!=l.algorithm&&l.hasOwnProperty("algorithm")&&(f.algorithm=g.onnx.GraphProto.toObject(l.algorithm,d)),l.initializationBinding&&l.initializationBinding.length){f.initializationBinding=[];for(var b=0;b<l.initializationBinding.length;++b)f.initializationBinding[b]=g.onnx.StringStringEntryProto.toObject(l.initializationBinding[b],d)}if(l.updateBinding&&l.updateBinding.length)for(f.updateBinding=[],b=0;b<l.updateBinding.length;++b)f.updateBinding[b]=g.onnx.StringStringEntryProto.toObject(l.updateBinding[b],d);return f},h.prototype.toJSON=function(){return this.constructor.toObject(this,k.util.toJSONOptions)},h.getTypeUrl=function(l){return void 0===l&&(l="type.googleapis.com"),l+"/onnx.TrainingInfoProto"},h}(),R.ModelProto=function(){function h(l){if(this.opsetImport=[],this.metadataProps=[],this.trainingInfo=[],this.functions=[],l)for(var d=Object.keys(l),f=0;f<d.length;++f)null!=l[d[f]]&&(this[d[f]]=l[d[f]])}return h.prototype.irVersion=v.Long?v.Long.fromBits(0,0,!1):0,h.prototype.opsetImport=v.emptyArray,h.prototype.producerName="",h.prototype.producerVersion="",h.prototype.domain="",h.prototype.modelVersion=v.Long?v.Long.fromBits(0,0,!1):0,h.prototype.docString="",h.prototype.graph=null,h.prototype.metadataProps=v.emptyArray,h.prototype.trainingInfo=v.emptyArray,h.prototype.functions=v.emptyArray,h.create=function(l){return new h(l)},h.encode=function(l,d){if(d||(d=C.create()),null!=l.irVersion&&Object.hasOwnProperty.call(l,"irVersion")&&d.uint32(8).int64(l.irVersion),null!=l.producerName&&Object.hasOwnProperty.call(l,"producerName")&&d.uint32(18).string(l.producerName),null!=l.producerVersion&&Object.hasOwnProperty.call(l,"producerVersion")&&d.uint32(26).string(l.producerVersion),null!=l.domain&&Object.hasOwnProperty.call(l,"domain")&&d.uint32(34).string(l.domain),null!=l.modelVersion&&Object.hasOwnProperty.call(l,"modelVersion")&&d.uint32(40).int64(l.modelVersion),null!=l.docString&&Object.hasOwnProperty.call(l,"docString")&&d.uint32(50).string(l.docString),null!=l.graph&&Object.hasOwnProperty.call(l,"graph")&&g.onnx.GraphProto.encode(l.graph,d.uint32(58).fork()).ldelim(),null!=l.opsetImport&&l.opsetImport.length)for(var f=0;f<l.opsetImport.length;++f)g.onnx.OperatorSetIdProto.encode(l.opsetImport[f],d.uint32(66).fork()).ldelim();if(null!=l.metadataProps&&l.metadataProps.length)for(f=0;f<l.metadataProps.length;++f)g.onnx.StringStringEntryProto.encode(l.metadataProps[f],d.uint32(114).fork()).ldelim();if(null!=l.trainingInfo&&l.trainingInfo.length)for(f=0;f<l.trainingInfo.length;++f)g.onnx.TrainingInfoProto.encode(l.trainingInfo[f],d.uint32(162).fork()).ldelim();if(null!=l.functions&&l.functions.length)for(f=0;f<l.functions.length;++f)g.onnx.FunctionProto.encode(l.functions[f],d.uint32(202).fork()).ldelim();return d},h.encodeDelimited=function(l,d){return this.encode(l,d).ldelim()},h.decode=function(l,d){l instanceof S||(l=S.create(l));for(var f=void 0===d?l.len:l.pos+d,b=new g.onnx.ModelProto;l.pos<f;){var x=l.uint32();switch(x>>>3){case 1:b.irVersion=l.int64();break;case 8:b.opsetImport&&b.opsetImport.length||(b.opsetImport=[]),b.opsetImport.push(g.onnx.OperatorSetIdProto.decode(l,l.uint32()));break;case 2:b.producerName=l.string();break;case 3:b.producerVersion=l.string();break;case 4:b.domain=l.string();break;case 5:b.modelVersion=l.int64();break;case 6:b.docString=l.string();break;case 7:b.graph=g.onnx.GraphProto.decode(l,l.uint32());break;case 14:b.metadataProps&&b.metadataProps.length||(b.metadataProps=[]),b.metadataProps.push(g.onnx.StringStringEntryProto.decode(l,l.uint32()));break;case 20:b.trainingInfo&&b.trainingInfo.length||(b.trainingInfo=[]),b.trainingInfo.push(g.onnx.TrainingInfoProto.decode(l,l.uint32()));break;case 25:b.functions&&b.functions.length||(b.functions=[]),b.functions.push(g.onnx.FunctionProto.decode(l,l.uint32()));break;default:l.skipType(7&x)}}return b},h.decodeDelimited=function(l){return l instanceof S||(l=new S(l)),this.decode(l,l.uint32())},h.verify=function(l){if("object"!=typeof l||null===l)return"object expected";if(null!=l.irVersion&&l.hasOwnProperty("irVersion")&&!(v.isInteger(l.irVersion)||l.irVersion&&v.isInteger(l.irVersion.low)&&v.isInteger(l.irVersion.high)))return"irVersion: integer|Long expected";if(null!=l.opsetImport&&l.hasOwnProperty("opsetImport")){if(!Array.isArray(l.opsetImport))return"opsetImport: array expected";for(var d=0;d<l.opsetImport.length;++d)if(f=g.onnx.OperatorSetIdProto.verify(l.opsetImport[d]))return"opsetImport."+f}if(null!=l.producerName&&l.hasOwnProperty("producerName")&&!v.isString(l.producerName))return"producerName: string expected";if(null!=l.producerVersion&&l.hasOwnProperty("producerVersion")&&!v.isString(l.producerVersion))return"producerVersion: string expected";if(null!=l.domain&&l.hasOwnProperty("domain")&&!v.isString(l.domain))return"domain: string expected";if(null!=l.modelVersion&&l.hasOwnProperty("modelVersion")&&!(v.isInteger(l.modelVersion)||l.modelVersion&&v.isInteger(l.modelVersion.low)&&v.isInteger(l.modelVersion.high)))return"modelVersion: integer|Long expected";if(null!=l.docString&&l.hasOwnProperty("docString")&&!v.isString(l.docString))return"docString: string expected";if(null!=l.graph&&l.hasOwnProperty("graph")&&(f=g.onnx.GraphProto.verify(l.graph)))return"graph."+f;if(null!=l.metadataProps&&l.hasOwnProperty("metadataProps")){if(!Array.isArray(l.metadataProps))return"metadataProps: array expected";for(d=0;d<l.metadataProps.length;++d)if(f=g.onnx.StringStringEntryProto.verify(l.metadataProps[d]))return"metadataProps."+f}if(null!=l.trainingInfo&&l.hasOwnProperty("trainingInfo")){if(!Array.isArray(l.trainingInfo))return"trainingInfo: array expected";for(d=0;d<l.trainingInfo.length;++d)if(f=g.onnx.TrainingInfoProto.verify(l.trainingInfo[d]))return"trainingInfo."+f}if(null!=l.functions&&l.hasOwnProperty("functions")){if(!Array.isArray(l.functions))return"functions: array expected";for(d=0;d<l.functions.length;++d){var f;if(f=g.onnx.FunctionProto.verify(l.functions[d]))return"functions."+f}}return null},h.fromObject=function(l){if(l instanceof g.onnx.ModelProto)return l;var d=new g.onnx.ModelProto;if(null!=l.irVersion&&(v.Long?(d.irVersion=v.Long.fromValue(l.irVersion)).unsigned=!1:"string"==typeof l.irVersion?d.irVersion=parseInt(l.irVersion,10):"number"==typeof l.irVersion?d.irVersion=l.irVersion:"object"==typeof l.irVersion&&(d.irVersion=new v.LongBits(l.irVersion.low>>>0,l.irVersion.high>>>0).toNumber())),l.opsetImport){if(!Array.isArray(l.opsetImport))throw TypeError(".onnx.ModelProto.opsetImport: array expected");d.opsetImport=[];for(var f=0;f<l.opsetImport.length;++f){if("object"!=typeof l.opsetImport[f])throw TypeError(".onnx.ModelProto.opsetImport: object expected");d.opsetImport[f]=g.onnx.OperatorSetIdProto.fromObject(l.opsetImport[f])}}if(null!=l.producerName&&(d.producerName=String(l.producerName)),null!=l.producerVersion&&(d.producerVersion=String(l.producerVersion)),null!=l.domain&&(d.domain=String(l.domain)),null!=l.modelVersion&&(v.Long?(d.modelVersion=v.Long.fromValue(l.modelVersion)).unsigned=!1:"string"==typeof l.modelVersion?d.modelVersion=parseInt(l.modelVersion,10):"number"==typeof l.modelVersion?d.modelVersion=l.modelVersion:"object"==typeof l.modelVersion&&(d.modelVersion=new v.LongBits(l.modelVersion.low>>>0,l.modelVersion.high>>>0).toNumber())),null!=l.docString&&(d.docString=String(l.docString)),null!=l.graph){if("object"!=typeof l.graph)throw TypeError(".onnx.ModelProto.graph: object expected");d.graph=g.onnx.GraphProto.fromObject(l.graph)}if(l.metadataProps){if(!Array.isArray(l.metadataProps))throw TypeError(".onnx.ModelProto.metadataProps: array expected");for(d.metadataProps=[],f=0;f<l.metadataProps.length;++f){if("object"!=typeof l.metadataProps[f])throw TypeError(".onnx.ModelProto.metadataProps: object expected");d.metadataProps[f]=g.onnx.StringStringEntryProto.fromObject(l.metadataProps[f])}}if(l.trainingInfo){if(!Array.isArray(l.trainingInfo))throw TypeError(".onnx.ModelProto.trainingInfo: array expected");for(d.trainingInfo=[],f=0;f<l.trainingInfo.length;++f){if("object"!=typeof l.trainingInfo[f])throw TypeError(".onnx.ModelProto.trainingInfo: object expected");d.trainingInfo[f]=g.onnx.TrainingInfoProto.fromObject(l.trainingInfo[f])}}if(l.functions){if(!Array.isArray(l.functions))throw TypeError(".onnx.ModelProto.functions: array expected");for(d.functions=[],f=0;f<l.functions.length;++f){if("object"!=typeof l.functions[f])throw TypeError(".onnx.ModelProto.functions: object expected");d.functions[f]=g.onnx.FunctionProto.fromObject(l.functions[f])}}return d},h.toObject=function(l,d){d||(d={});var f={};if((d.arrays||d.defaults)&&(f.opsetImport=[],f.metadataProps=[],f.trainingInfo=[],f.functions=[]),d.defaults){if(v.Long){var b=new v.Long(0,0,!1);f.irVersion=d.longs===String?b.toString():d.longs===Number?b.toNumber():b}else f.irVersion=d.longs===String?"0":0;f.producerName="",f.producerVersion="",f.domain="",v.Long?(b=new v.Long(0,0,!1),f.modelVersion=d.longs===String?b.toString():d.longs===Number?b.toNumber():b):f.modelVersion=d.longs===String?"0":0,f.docString="",f.graph=null}if(null!=l.irVersion&&l.hasOwnProperty("irVersion")&&(f.irVersion="number"==typeof l.irVersion?d.longs===String?String(l.irVersion):l.irVersion:d.longs===String?v.Long.prototype.toString.call(l.irVersion):d.longs===Number?new v.LongBits(l.irVersion.low>>>0,l.irVersion.high>>>0).toNumber():l.irVersion),null!=l.producerName&&l.hasOwnProperty("producerName")&&(f.producerName=l.producerName),null!=l.producerVersion&&l.hasOwnProperty("producerVersion")&&(f.producerVersion=l.producerVersion),null!=l.domain&&l.hasOwnProperty("domain")&&(f.domain=l.domain),null!=l.modelVersion&&l.hasOwnProperty("modelVersion")&&(f.modelVersion="number"==typeof l.modelVersion?d.longs===String?String(l.modelVersion):l.modelVersion:d.longs===String?v.Long.prototype.toString.call(l.modelVersion):d.longs===Number?new v.LongBits(l.modelVersion.low>>>0,l.modelVersion.high>>>0).toNumber():l.modelVersion),null!=l.docString&&l.hasOwnProperty("docString")&&(f.docString=l.docString),null!=l.graph&&l.hasOwnProperty("graph")&&(f.graph=g.onnx.GraphProto.toObject(l.graph,d)),l.opsetImport&&l.opsetImport.length){f.opsetImport=[];for(var x=0;x<l.opsetImport.length;++x)f.opsetImport[x]=g.onnx.OperatorSetIdProto.toObject(l.opsetImport[x],d)}if(l.metadataProps&&l.metadataProps.length)for(f.metadataProps=[],x=0;x<l.metadataProps.length;++x)f.metadataProps[x]=g.onnx.StringStringEntryProto.toObject(l.metadataProps[x],d);if(l.trainingInfo&&l.trainingInfo.length)for(f.trainingInfo=[],x=0;x<l.trainingInfo.length;++x)f.trainingInfo[x]=g.onnx.TrainingInfoProto.toObject(l.trainingInfo[x],d);if(l.functions&&l.functions.length)for(f.functions=[],x=0;x<l.functions.length;++x)f.functions[x]=g.onnx.FunctionProto.toObject(l.functions[x],d);return f},h.prototype.toJSON=function(){return this.constructor.toObject(this,k.util.toJSONOptions)},h.getTypeUrl=function(l){return void 0===l&&(l="type.googleapis.com"),l+"/onnx.ModelProto"},h}(),R.StringStringEntryProto=function(){function h(l){if(l)for(var d=Object.keys(l),f=0;f<d.length;++f)null!=l[d[f]]&&(this[d[f]]=l[d[f]])}return h.prototype.key="",h.prototype.value="",h.create=function(l){return new h(l)},h.encode=function(l,d){return d||(d=C.create()),null!=l.key&&Object.hasOwnProperty.call(l,"key")&&d.uint32(10).string(l.key),null!=l.value&&Object.hasOwnProperty.call(l,"value")&&d.uint32(18).string(l.value),d},h.encodeDelimited=function(l,d){return this.encode(l,d).ldelim()},h.decode=function(l,d){l instanceof S||(l=S.create(l));for(var f=void 0===d?l.len:l.pos+d,b=new g.onnx.StringStringEntryProto;l.pos<f;){var x=l.uint32();switch(x>>>3){case 1:b.key=l.string();break;case 2:b.value=l.string();break;default:l.skipType(7&x)}}return b},h.decodeDelimited=function(l){return l instanceof S||(l=new S(l)),this.decode(l,l.uint32())},h.verify=function(l){return"object"!=typeof l||null===l?"object expected":null!=l.key&&l.hasOwnProperty("key")&&!v.isString(l.key)?"key: string expected":null!=l.value&&l.hasOwnProperty("value")&&!v.isString(l.value)?"value: string expected":null},h.fromObject=function(l){if(l instanceof g.onnx.StringStringEntryProto)return l;var d=new g.onnx.StringStringEntryProto;return null!=l.key&&(d.key=String(l.key)),null!=l.value&&(d.value=String(l.value)),d},h.toObject=function(l,d){d||(d={});var f={};return d.defaults&&(f.key="",f.value=""),null!=l.key&&l.hasOwnProperty("key")&&(f.key=l.key),null!=l.value&&l.hasOwnProperty("value")&&(f.value=l.value),f},h.prototype.toJSON=function(){return this.constructor.toObject(this,k.util.toJSONOptions)},h.getTypeUrl=function(l){return void 0===l&&(l="type.googleapis.com"),l+"/onnx.StringStringEntryProto"},h}(),R.TensorAnnotation=function(){function h(l){if(this.quantParameterTensorNames=[],l)for(var d=Object.keys(l),f=0;f<d.length;++f)null!=l[d[f]]&&(this[d[f]]=l[d[f]])}return h.prototype.tensorName="",h.prototype.quantParameterTensorNames=v.emptyArray,h.create=function(l){return new h(l)},h.encode=function(l,d){if(d||(d=C.create()),null!=l.tensorName&&Object.hasOwnProperty.call(l,"tensorName")&&d.uint32(10).string(l.tensorName),null!=l.quantParameterTensorNames&&l.quantParameterTensorNames.length)for(var f=0;f<l.quantParameterTensorNames.length;++f)g.onnx.StringStringEntryProto.encode(l.quantParameterTensorNames[f],d.uint32(18).fork()).ldelim();return d},h.encodeDelimited=function(l,d){return this.encode(l,d).ldelim()},h.decode=function(l,d){l instanceof S||(l=S.create(l));for(var f=void 0===d?l.len:l.pos+d,b=new g.onnx.TensorAnnotation;l.pos<f;){var x=l.uint32();switch(x>>>3){case 1:b.tensorName=l.string();break;case 2:b.quantParameterTensorNames&&b.quantParameterTensorNames.length||(b.quantParameterTensorNames=[]),b.quantParameterTensorNames.push(g.onnx.StringStringEntryProto.decode(l,l.uint32()));break;default:l.skipType(7&x)}}return b},h.decodeDelimited=function(l){return l instanceof S||(l=new S(l)),this.decode(l,l.uint32())},h.verify=function(l){if("object"!=typeof l||null===l)return"object expected";if(null!=l.tensorName&&l.hasOwnProperty("tensorName")&&!v.isString(l.tensorName))return"tensorName: string expected";if(null!=l.quantParameterTensorNames&&l.hasOwnProperty("quantParameterTensorNames")){if(!Array.isArray(l.quantParameterTensorNames))return"quantParameterTensorNames: array expected";for(var d=0;d<l.quantParameterTensorNames.length;++d){var f=g.onnx.StringStringEntryProto.verify(l.quantParameterTensorNames[d]);if(f)return"quantParameterTensorNames."+f}}return null},h.fromObject=function(l){if(l instanceof g.onnx.TensorAnnotation)return l;var d=new g.onnx.TensorAnnotation;if(null!=l.tensorName&&(d.tensorName=String(l.tensorName)),l.quantParameterTensorNames){if(!Array.isArray(l.quantParameterTensorNames))throw TypeError(".onnx.TensorAnnotation.quantParameterTensorNames: array expected");d.quantParameterTensorNames=[];for(var f=0;f<l.quantParameterTensorNames.length;++f){if("object"!=typeof l.quantParameterTensorNames[f])throw TypeError(".onnx.TensorAnnotation.quantParameterTensorNames: object expected");d.quantParameterTensorNames[f]=g.onnx.StringStringEntryProto.fromObject(l.quantParameterTensorNames[f])}}return d},h.toObject=function(l,d){d||(d={});var f={};if((d.arrays||d.defaults)&&(f.quantParameterTensorNames=[]),d.defaults&&(f.tensorName=""),null!=l.tensorName&&l.hasOwnProperty("tensorName")&&(f.tensorName=l.tensorName),l.quantParameterTensorNames&&l.quantParameterTensorNames.length){f.quantParameterTensorNames=[];for(var b=0;b<l.quantParameterTensorNames.length;++b)f.quantParameterTensorNames[b]=g.onnx.StringStringEntryProto.toObject(l.quantParameterTensorNames[b],d)}return f},h.prototype.toJSON=function(){return this.constructor.toObject(this,k.util.toJSONOptions)},h.getTypeUrl=function(l){return void 0===l&&(l="type.googleapis.com"),l+"/onnx.TensorAnnotation"},h}(),R.GraphProto=function(){function h(l){if(this.node=[],this.initializer=[],this.sparseInitializer=[],this.input=[],this.output=[],this.valueInfo=[],this.quantizationAnnotation=[],l)for(var d=Object.keys(l),f=0;f<d.length;++f)null!=l[d[f]]&&(this[d[f]]=l[d[f]])}return h.prototype.node=v.emptyArray,h.prototype.name="",h.prototype.initializer=v.emptyArray,h.prototype.sparseInitializer=v.emptyArray,h.prototype.docString="",h.prototype.input=v.emptyArray,h.prototype.output=v.emptyArray,h.prototype.valueInfo=v.emptyArray,h.prototype.quantizationAnnotation=v.emptyArray,h.create=function(l){return new h(l)},h.encode=function(l,d){if(d||(d=C.create()),null!=l.node&&l.node.length)for(var f=0;f<l.node.length;++f)g.onnx.NodeProto.encode(l.node[f],d.uint32(10).fork()).ldelim();if(null!=l.name&&Object.hasOwnProperty.call(l,"name")&&d.uint32(18).string(l.name),null!=l.initializer&&l.initializer.length)for(f=0;f<l.initializer.length;++f)g.onnx.TensorProto.encode(l.initializer[f],d.uint32(42).fork()).ldelim();if(null!=l.docString&&Object.hasOwnProperty.call(l,"docString")&&d.uint32(82).string(l.docString),null!=l.input&&l.input.length)for(f=0;f<l.input.length;++f)g.onnx.ValueInfoProto.encode(l.input[f],d.uint32(90).fork()).ldelim();if(null!=l.output&&l.output.length)for(f=0;f<l.output.length;++f)g.onnx.ValueInfoProto.encode(l.output[f],d.uint32(98).fork()).ldelim();if(null!=l.valueInfo&&l.valueInfo.length)for(f=0;f<l.valueInfo.length;++f)g.onnx.ValueInfoProto.encode(l.valueInfo[f],d.uint32(106).fork()).ldelim();if(null!=l.quantizationAnnotation&&l.quantizationAnnotation.length)for(f=0;f<l.quantizationAnnotation.length;++f)g.onnx.TensorAnnotation.encode(l.quantizationAnnotation[f],d.uint32(114).fork()).ldelim();if(null!=l.sparseInitializer&&l.sparseInitializer.length)for(f=0;f<l.sparseInitializer.length;++f)g.onnx.SparseTensorProto.encode(l.sparseInitializer[f],d.uint32(122).fork()).ldelim();return d},h.encodeDelimited=function(l,d){return this.encode(l,d).ldelim()},h.decode=function(l,d){l instanceof S||(l=S.create(l));for(var f=void 0===d?l.len:l.pos+d,b=new g.onnx.GraphProto;l.pos<f;){var x=l.uint32();switch(x>>>3){case 1:b.node&&b.node.length||(b.node=[]),b.node.push(g.onnx.NodeProto.decode(l,l.uint32()));break;case 2:b.name=l.string();break;case 5:b.initializer&&b.initializer.length||(b.initializer=[]),b.initializer.push(g.onnx.TensorProto.decode(l,l.uint32()));break;case 15:b.sparseInitializer&&b.sparseInitializer.length||(b.sparseInitializer=[]),b.sparseInitializer.push(g.onnx.SparseTensorProto.decode(l,l.uint32()));break;case 10:b.docString=l.string();break;case 11:b.input&&b.input.length||(b.input=[]),b.input.push(g.onnx.ValueInfoProto.decode(l,l.uint32()));break;case 12:b.output&&b.output.length||(b.output=[]),b.output.push(g.onnx.ValueInfoProto.decode(l,l.uint32()));break;case 13:b.valueInfo&&b.valueInfo.length||(b.valueInfo=[]),b.valueInfo.push(g.onnx.ValueInfoProto.decode(l,l.uint32()));break;case 14:b.quantizationAnnotation&&b.quantizationAnnotation.length||(b.quantizationAnnotation=[]),b.quantizationAnnotation.push(g.onnx.TensorAnnotation.decode(l,l.uint32()));break;default:l.skipType(7&x)}}return b},h.decodeDelimited=function(l){return l instanceof S||(l=new S(l)),this.decode(l,l.uint32())},h.verify=function(l){if("object"!=typeof l||null===l)return"object expected";if(null!=l.node&&l.hasOwnProperty("node")){if(!Array.isArray(l.node))return"node: array expected";for(var d=0;d<l.node.length;++d)if(f=g.onnx.NodeProto.verify(l.node[d]))return"node."+f}if(null!=l.name&&l.hasOwnProperty("name")&&!v.isString(l.name))return"name: string expected";if(null!=l.initializer&&l.hasOwnProperty("initializer")){if(!Array.isArray(l.initializer))return"initializer: array expected";for(d=0;d<l.initializer.length;++d)if(f=g.onnx.TensorProto.verify(l.initializer[d]))return"initializer."+f}if(null!=l.sparseInitializer&&l.hasOwnProperty("sparseInitializer")){if(!Array.isArray(l.sparseInitializer))return"sparseInitializer: array expected";for(d=0;d<l.sparseInitializer.length;++d)if(f=g.onnx.SparseTensorProto.verify(l.sparseInitializer[d]))return"sparseInitializer."+f}if(null!=l.docString&&l.hasOwnProperty("docString")&&!v.isString(l.docString))return"docString: string expected";if(null!=l.input&&l.hasOwnProperty("input")){if(!Array.isArray(l.input))return"input: array expected";for(d=0;d<l.input.length;++d)if(f=g.onnx.ValueInfoProto.verify(l.input[d]))return"input."+f}if(null!=l.output&&l.hasOwnProperty("output")){if(!Array.isArray(l.output))return"output: array expected";for(d=0;d<l.output.length;++d)if(f=g.onnx.ValueInfoProto.verify(l.output[d]))return"output."+f}if(null!=l.valueInfo&&l.hasOwnProperty("valueInfo")){if(!Array.isArray(l.valueInfo))return"valueInfo: array expected";for(d=0;d<l.valueInfo.length;++d)if(f=g.onnx.ValueInfoProto.verify(l.valueInfo[d]))return"valueInfo."+f}if(null!=l.quantizationAnnotation&&l.hasOwnProperty("quantizationAnnotation")){if(!Array.isArray(l.quantizationAnnotation))return"quantizationAnnotation: array expected";for(d=0;d<l.quantizationAnnotation.length;++d){var f;if(f=g.onnx.TensorAnnotation.verify(l.quantizationAnnotation[d]))return"quantizationAnnotation."+f}}return null},h.fromObject=function(l){if(l instanceof g.onnx.GraphProto)return l;var d=new g.onnx.GraphProto;if(l.node){if(!Array.isArray(l.node))throw TypeError(".onnx.GraphProto.node: array expected");d.node=[];for(var f=0;f<l.node.length;++f){if("object"!=typeof l.node[f])throw TypeError(".onnx.GraphProto.node: object expected");d.node[f]=g.onnx.NodeProto.fromObject(l.node[f])}}if(null!=l.name&&(d.name=String(l.name)),l.initializer){if(!Array.isArray(l.initializer))throw TypeError(".onnx.GraphProto.initializer: array expected");for(d.initializer=[],f=0;f<l.initializer.length;++f){if("object"!=typeof l.initializer[f])throw TypeError(".onnx.GraphProto.initializer: object expected");d.initializer[f]=g.onnx.TensorProto.fromObject(l.initializer[f])}}if(l.sparseInitializer){if(!Array.isArray(l.sparseInitializer))throw TypeError(".onnx.GraphProto.sparseInitializer: array expected");for(d.sparseInitializer=[],f=0;f<l.sparseInitializer.length;++f){if("object"!=typeof l.sparseInitializer[f])throw TypeError(".onnx.GraphProto.sparseInitializer: object expected");d.sparseInitializer[f]=g.onnx.SparseTensorProto.fromObject(l.sparseInitializer[f])}}if(null!=l.docString&&(d.docString=String(l.docString)),l.input){if(!Array.isArray(l.input))throw TypeError(".onnx.GraphProto.input: array expected");for(d.input=[],f=0;f<l.input.length;++f){if("object"!=typeof l.input[f])throw TypeError(".onnx.GraphProto.input: object expected");d.input[f]=g.onnx.ValueInfoProto.fromObject(l.input[f])}}if(l.output){if(!Array.isArray(l.output))throw TypeError(".onnx.GraphProto.output: array expected");for(d.output=[],f=0;f<l.output.length;++f){if("object"!=typeof l.output[f])throw TypeError(".onnx.GraphProto.output: object expected");d.output[f]=g.onnx.ValueInfoProto.fromObject(l.output[f])}}if(l.valueInfo){if(!Array.isArray(l.valueInfo))throw TypeError(".onnx.GraphProto.valueInfo: array expected");for(d.valueInfo=[],f=0;f<l.valueInfo.length;++f){if("object"!=typeof l.valueInfo[f])throw TypeError(".onnx.GraphProto.valueInfo: object expected");d.valueInfo[f]=g.onnx.ValueInfoProto.fromObject(l.valueInfo[f])}}if(l.quantizationAnnotation){if(!Array.isArray(l.quantizationAnnotation))throw TypeError(".onnx.GraphProto.quantizationAnnotation: array expected");for(d.quantizationAnnotation=[],f=0;f<l.quantizationAnnotation.length;++f){if("object"!=typeof l.quantizationAnnotation[f])throw TypeError(".onnx.GraphProto.quantizationAnnotation: object expected");d.quantizationAnnotation[f]=g.onnx.TensorAnnotation.fromObject(l.quantizationAnnotation[f])}}return d},h.toObject=function(l,d){d||(d={});var f={};if((d.arrays||d.defaults)&&(f.node=[],f.initializer=[],f.input=[],f.output=[],f.valueInfo=[],f.quantizationAnnotation=[],f.sparseInitializer=[]),d.defaults&&(f.name="",f.docString=""),l.node&&l.node.length){f.node=[];for(var b=0;b<l.node.length;++b)f.node[b]=g.onnx.NodeProto.toObject(l.node[b],d)}if(null!=l.name&&l.hasOwnProperty("name")&&(f.name=l.name),l.initializer&&l.initializer.length)for(f.initializer=[],b=0;b<l.initializer.length;++b)f.initializer[b]=g.onnx.TensorProto.toObject(l.initializer[b],d);if(null!=l.docString&&l.hasOwnProperty("docString")&&(f.docString=l.docString),l.input&&l.input.length)for(f.input=[],b=0;b<l.input.length;++b)f.input[b]=g.onnx.ValueInfoProto.toObject(l.input[b],d);if(l.output&&l.output.length)for(f.output=[],b=0;b<l.output.length;++b)f.output[b]=g.onnx.ValueInfoProto.toObject(l.output[b],d);if(l.valueInfo&&l.valueInfo.length)for(f.valueInfo=[],b=0;b<l.valueInfo.length;++b)f.valueInfo[b]=g.onnx.ValueInfoProto.toObject(l.valueInfo[b],d);if(l.quantizationAnnotation&&l.quantizationAnnotation.length)for(f.quantizationAnnotation=[],b=0;b<l.quantizationAnnotation.length;++b)f.quantizationAnnotation[b]=g.onnx.TensorAnnotation.toObject(l.quantizationAnnotation[b],d);if(l.sparseInitializer&&l.sparseInitializer.length)for(f.sparseInitializer=[],b=0;b<l.sparseInitializer.length;++b)f.sparseInitializer[b]=g.onnx.SparseTensorProto.toObject(l.sparseInitializer[b],d);return f},h.prototype.toJSON=function(){return this.constructor.toObject(this,k.util.toJSONOptions)},h.getTypeUrl=function(l){return void 0===l&&(l="type.googleapis.com"),l+"/onnx.GraphProto"},h}(),R.TensorProto=function(){function h(l){if(this.dims=[],this.floatData=[],this.int32Data=[],this.stringData=[],this.int64Data=[],this.externalData=[],this.doubleData=[],this.uint64Data=[],l)for(var d=Object.keys(l),f=0;f<d.length;++f)null!=l[d[f]]&&(this[d[f]]=l[d[f]])}return h.prototype.dims=v.emptyArray,h.prototype.dataType=0,h.prototype.segment=null,h.prototype.floatData=v.emptyArray,h.prototype.int32Data=v.emptyArray,h.prototype.stringData=v.emptyArray,h.prototype.int64Data=v.emptyArray,h.prototype.name="",h.prototype.docString="",h.prototype.rawData=v.newBuffer([]),h.prototype.externalData=v.emptyArray,h.prototype.dataLocation=0,h.prototype.doubleData=v.emptyArray,h.prototype.uint64Data=v.emptyArray,h.create=function(l){return new h(l)},h.encode=function(l,d){if(d||(d=C.create()),null!=l.dims&&l.dims.length){d.uint32(10).fork();for(var f=0;f<l.dims.length;++f)d.int64(l.dims[f]);d.ldelim()}if(null!=l.dataType&&Object.hasOwnProperty.call(l,"dataType")&&d.uint32(16).int32(l.dataType),null!=l.segment&&Object.hasOwnProperty.call(l,"segment")&&g.onnx.TensorProto.Segment.encode(l.segment,d.uint32(26).fork()).ldelim(),null!=l.floatData&&l.floatData.length){for(d.uint32(34).fork(),f=0;f<l.floatData.length;++f)d.float(l.floatData[f]);d.ldelim()}if(null!=l.int32Data&&l.int32Data.length){for(d.uint32(42).fork(),f=0;f<l.int32Data.length;++f)d.int32(l.int32Data[f]);d.ldelim()}if(null!=l.stringData&&l.stringData.length)for(f=0;f<l.stringData.length;++f)d.uint32(50).bytes(l.stringData[f]);if(null!=l.int64Data&&l.int64Data.length){for(d.uint32(58).fork(),f=0;f<l.int64Data.length;++f)d.int64(l.int64Data[f]);d.ldelim()}if(null!=l.name&&Object.hasOwnProperty.call(l,"name")&&d.uint32(66).string(l.name),null!=l.rawData&&Object.hasOwnProperty.call(l,"rawData")&&d.uint32(74).bytes(l.rawData),null!=l.doubleData&&l.doubleData.length){for(d.uint32(82).fork(),f=0;f<l.doubleData.length;++f)d.double(l.doubleData[f]);d.ldelim()}if(null!=l.uint64Data&&l.uint64Data.length){for(d.uint32(90).fork(),f=0;f<l.uint64Data.length;++f)d.uint64(l.uint64Data[f]);d.ldelim()}if(null!=l.docString&&Object.hasOwnProperty.call(l,"docString")&&d.uint32(98).string(l.docString),null!=l.externalData&&l.externalData.length)for(f=0;f<l.externalData.length;++f)g.onnx.StringStringEntryProto.encode(l.externalData[f],d.uint32(106).fork()).ldelim();return null!=l.dataLocation&&Object.hasOwnProperty.call(l,"dataLocation")&&d.uint32(112).int32(l.dataLocation),d},h.encodeDelimited=function(l,d){return this.encode(l,d).ldelim()},h.decode=function(l,d){l instanceof S||(l=S.create(l));for(var f=void 0===d?l.len:l.pos+d,b=new g.onnx.TensorProto;l.pos<f;){var x=l.uint32();switch(x>>>3){case 1:if(b.dims&&b.dims.length||(b.dims=[]),2==(7&x))for(var D=l.uint32()+l.pos;l.pos<D;)b.dims.push(l.int64());else b.dims.push(l.int64());break;case 2:b.dataType=l.int32();break;case 3:b.segment=g.onnx.TensorProto.Segment.decode(l,l.uint32());break;case 4:if(b.floatData&&b.floatData.length||(b.floatData=[]),2==(7&x))for(D=l.uint32()+l.pos;l.pos<D;)b.floatData.push(l.float());else b.floatData.push(l.float());break;case 5:if(b.int32Data&&b.int32Data.length||(b.int32Data=[]),2==(7&x))for(D=l.uint32()+l.pos;l.pos<D;)b.int32Data.push(l.int32());else b.int32Data.push(l.int32());break;case 6:b.stringData&&b.stringData.length||(b.stringData=[]),b.stringData.push(l.bytes());break;case 7:if(b.int64Data&&b.int64Data.length||(b.int64Data=[]),2==(7&x))for(D=l.uint32()+l.pos;l.pos<D;)b.int64Data.push(l.int64());else b.int64Data.push(l.int64());break;case 8:b.name=l.string();break;case 12:b.docString=l.string();break;case 9:b.rawData=l.bytes();break;case 13:b.externalData&&b.externalData.length||(b.externalData=[]),b.externalData.push(g.onnx.StringStringEntryProto.decode(l,l.uint32()));break;case 14:b.dataLocation=l.int32();break;case 10:if(b.doubleData&&b.doubleData.length||(b.doubleData=[]),2==(7&x))for(D=l.uint32()+l.pos;l.pos<D;)b.doubleData.push(l.double());else b.doubleData.push(l.double());break;case 11:if(b.uint64Data&&b.uint64Data.length||(b.uint64Data=[]),2==(7&x))for(D=l.uint32()+l.pos;l.pos<D;)b.uint64Data.push(l.uint64());else b.uint64Data.push(l.uint64());break;default:l.skipType(7&x)}}return b},h.decodeDelimited=function(l){return l instanceof S||(l=new S(l)),this.decode(l,l.uint32())},h.verify=function(l){if("object"!=typeof l||null===l)return"object expected";if(null!=l.dims&&l.hasOwnProperty("dims")){if(!Array.isArray(l.dims))return"dims: array expected";for(var d=0;d<l.dims.length;++d)if(!(v.isInteger(l.dims[d])||l.dims[d]&&v.isInteger(l.dims[d].low)&&v.isInteger(l.dims[d].high)))return"dims: integer|Long[] expected"}if(null!=l.dataType&&l.hasOwnProperty("dataType")&&!v.isInteger(l.dataType))return"dataType: integer expected";if(null!=l.segment&&l.hasOwnProperty("segment")&&(f=g.onnx.TensorProto.Segment.verify(l.segment)))return"segment."+f;if(null!=l.floatData&&l.hasOwnProperty("floatData")){if(!Array.isArray(l.floatData))return"floatData: array expected";for(d=0;d<l.floatData.length;++d)if("number"!=typeof l.floatData[d])return"floatData: number[] expected"}if(null!=l.int32Data&&l.hasOwnProperty("int32Data")){if(!Array.isArray(l.int32Data))return"int32Data: array expected";for(d=0;d<l.int32Data.length;++d)if(!v.isInteger(l.int32Data[d]))return"int32Data: integer[] expected"}if(null!=l.stringData&&l.hasOwnProperty("stringData")){if(!Array.isArray(l.stringData))return"stringData: array expected";for(d=0;d<l.stringData.length;++d)if(!(l.stringData[d]&&"number"==typeof l.stringData[d].length||v.isString(l.stringData[d])))return"stringData: buffer[] expected"}if(null!=l.int64Data&&l.hasOwnProperty("int64Data")){if(!Array.isArray(l.int64Data))return"int64Data: array expected";for(d=0;d<l.int64Data.length;++d)if(!(v.isInteger(l.int64Data[d])||l.int64Data[d]&&v.isInteger(l.int64Data[d].low)&&v.isInteger(l.int64Data[d].high)))return"int64Data: integer|Long[] expected"}if(null!=l.name&&l.hasOwnProperty("name")&&!v.isString(l.name))return"name: string expected";if(null!=l.docString&&l.hasOwnProperty("docString")&&!v.isString(l.docString))return"docString: string expected";if(null!=l.rawData&&l.hasOwnProperty("rawData")&&!(l.rawData&&"number"==typeof l.rawData.length||v.isString(l.rawData)))return"rawData: buffer expected";if(null!=l.externalData&&l.hasOwnProperty("externalData")){if(!Array.isArray(l.externalData))return"externalData: array expected";for(d=0;d<l.externalData.length;++d){var f;if(f=g.onnx.StringStringEntryProto.verify(l.externalData[d]))return"externalData."+f}}if(null!=l.dataLocation&&l.hasOwnProperty("dataLocation"))switch(l.dataLocation){default:return"dataLocation: enum value expected";case 0:case 1:}if(null!=l.doubleData&&l.hasOwnProperty("doubleData")){if(!Array.isArray(l.doubleData))return"doubleData: array expected";for(d=0;d<l.doubleData.length;++d)if("number"!=typeof l.doubleData[d])return"doubleData: number[] expected"}if(null!=l.uint64Data&&l.hasOwnProperty("uint64Data")){if(!Array.isArray(l.uint64Data))return"uint64Data: array expected";for(d=0;d<l.uint64Data.length;++d)if(!(v.isInteger(l.uint64Data[d])||l.uint64Data[d]&&v.isInteger(l.uint64Data[d].low)&&v.isInteger(l.uint64Data[d].high)))return"uint64Data: integer|Long[] expected"}return null},h.fromObject=function(l){if(l instanceof g.onnx.TensorProto)return l;var d=new g.onnx.TensorProto;if(l.dims){if(!Array.isArray(l.dims))throw TypeError(".onnx.TensorProto.dims: array expected");d.dims=[];for(var f=0;f<l.dims.length;++f)v.Long?(d.dims[f]=v.Long.fromValue(l.dims[f])).unsigned=!1:"string"==typeof l.dims[f]?d.dims[f]=parseInt(l.dims[f],10):"number"==typeof l.dims[f]?d.dims[f]=l.dims[f]:"object"==typeof l.dims[f]&&(d.dims[f]=new v.LongBits(l.dims[f].low>>>0,l.dims[f].high>>>0).toNumber())}if(null!=l.dataType&&(d.dataType=0|l.dataType),null!=l.segment){if("object"!=typeof l.segment)throw TypeError(".onnx.TensorProto.segment: object expected");d.segment=g.onnx.TensorProto.Segment.fromObject(l.segment)}if(l.floatData){if(!Array.isArray(l.floatData))throw TypeError(".onnx.TensorProto.floatData: array expected");for(d.floatData=[],f=0;f<l.floatData.length;++f)d.floatData[f]=Number(l.floatData[f])}if(l.int32Data){if(!Array.isArray(l.int32Data))throw TypeError(".onnx.TensorProto.int32Data: array expected");for(d.int32Data=[],f=0;f<l.int32Data.length;++f)d.int32Data[f]=0|l.int32Data[f]}if(l.stringData){if(!Array.isArray(l.stringData))throw TypeError(".onnx.TensorProto.stringData: array expected");for(d.stringData=[],f=0;f<l.stringData.length;++f)"string"==typeof l.stringData[f]?v.base64.decode(l.stringData[f],d.stringData[f]=v.newBuffer(v.base64.length(l.stringData[f])),0):l.stringData[f].length>=0&&(d.stringData[f]=l.stringData[f])}if(l.int64Data){if(!Array.isArray(l.int64Data))throw TypeError(".onnx.TensorProto.int64Data: array expected");for(d.int64Data=[],f=0;f<l.int64Data.length;++f)v.Long?(d.int64Data[f]=v.Long.fromValue(l.int64Data[f])).unsigned=!1:"string"==typeof l.int64Data[f]?d.int64Data[f]=parseInt(l.int64Data[f],10):"number"==typeof l.int64Data[f]?d.int64Data[f]=l.int64Data[f]:"object"==typeof l.int64Data[f]&&(d.int64Data[f]=new v.LongBits(l.int64Data[f].low>>>0,l.int64Data[f].high>>>0).toNumber())}if(null!=l.name&&(d.name=String(l.name)),null!=l.docString&&(d.docString=String(l.docString)),null!=l.rawData&&("string"==typeof l.rawData?v.base64.decode(l.rawData,d.rawData=v.newBuffer(v.base64.length(l.rawData)),0):l.rawData.length>=0&&(d.rawData=l.rawData)),l.externalData){if(!Array.isArray(l.externalData))throw TypeError(".onnx.TensorProto.externalData: array expected");for(d.externalData=[],f=0;f<l.externalData.length;++f){if("object"!=typeof l.externalData[f])throw TypeError(".onnx.TensorProto.externalData: object expected");d.externalData[f]=g.onnx.StringStringEntryProto.fromObject(l.externalData[f])}}switch(l.dataLocation){default:if("number"==typeof l.dataLocation){d.dataLocation=l.dataLocation;break}break;case"DEFAULT":case 0:d.dataLocation=0;break;case"EXTERNAL":case 1:d.dataLocation=1}if(l.doubleData){if(!Array.isArray(l.doubleData))throw TypeError(".onnx.TensorProto.doubleData: array expected");for(d.doubleData=[],f=0;f<l.doubleData.length;++f)d.doubleData[f]=Number(l.doubleData[f])}if(l.uint64Data){if(!Array.isArray(l.uint64Data))throw TypeError(".onnx.TensorProto.uint64Data: array expected");for(d.uint64Data=[],f=0;f<l.uint64Data.length;++f)v.Long?(d.uint64Data[f]=v.Long.fromValue(l.uint64Data[f])).unsigned=!0:"string"==typeof l.uint64Data[f]?d.uint64Data[f]=parseInt(l.uint64Data[f],10):"number"==typeof l.uint64Data[f]?d.uint64Data[f]=l.uint64Data[f]:"object"==typeof l.uint64Data[f]&&(d.uint64Data[f]=new v.LongBits(l.uint64Data[f].low>>>0,l.uint64Data[f].high>>>0).toNumber(!0))}return d},h.toObject=function(l,d){d||(d={});var f={};if((d.arrays||d.defaults)&&(f.dims=[],f.floatData=[],f.int32Data=[],f.stringData=[],f.int64Data=[],f.doubleData=[],f.uint64Data=[],f.externalData=[]),d.defaults&&(f.dataType=0,f.segment=null,f.name="",d.bytes===String?f.rawData="":(f.rawData=[],d.bytes!==Array&&(f.rawData=v.newBuffer(f.rawData))),f.docString="",f.dataLocation=d.enums===String?"DEFAULT":0),l.dims&&l.dims.length){f.dims=[];for(var b=0;b<l.dims.length;++b)f.dims[b]="number"==typeof l.dims[b]?d.longs===String?String(l.dims[b]):l.dims[b]:d.longs===String?v.Long.prototype.toString.call(l.dims[b]):d.longs===Number?new v.LongBits(l.dims[b].low>>>0,l.dims[b].high>>>0).toNumber():l.dims[b]}if(null!=l.dataType&&l.hasOwnProperty("dataType")&&(f.dataType=l.dataType),null!=l.segment&&l.hasOwnProperty("segment")&&(f.segment=g.onnx.TensorProto.Segment.toObject(l.segment,d)),l.floatData&&l.floatData.length)for(f.floatData=[],b=0;b<l.floatData.length;++b)f.floatData[b]=d.json&&!isFinite(l.floatData[b])?String(l.floatData[b]):l.floatData[b];if(l.int32Data&&l.int32Data.length)for(f.int32Data=[],b=0;b<l.int32Data.length;++b)f.int32Data[b]=l.int32Data[b];if(l.stringData&&l.stringData.length)for(f.stringData=[],b=0;b<l.stringData.length;++b)f.stringData[b]=d.bytes===String?v.base64.encode(l.stringData[b],0,l.stringData[b].length):d.bytes===Array?Array.prototype.slice.call(l.stringData[b]):l.stringData[b];if(l.int64Data&&l.int64Data.length)for(f.int64Data=[],b=0;b<l.int64Data.length;++b)f.int64Data[b]="number"==typeof l.int64Data[b]?d.longs===String?String(l.int64Data[b]):l.int64Data[b]:d.longs===String?v.Long.prototype.toString.call(l.int64Data[b]):d.longs===Number?new v.LongBits(l.int64Data[b].low>>>0,l.int64Data[b].high>>>0).toNumber():l.int64Data[b];if(null!=l.name&&l.hasOwnProperty("name")&&(f.name=l.name),null!=l.rawData&&l.hasOwnProperty("rawData")&&(f.rawData=d.bytes===String?v.base64.encode(l.rawData,0,l.rawData.length):d.bytes===Array?Array.prototype.slice.call(l.rawData):l.rawData),l.doubleData&&l.doubleData.length)for(f.doubleData=[],b=0;b<l.doubleData.length;++b)f.doubleData[b]=d.json&&!isFinite(l.doubleData[b])?String(l.doubleData[b]):l.doubleData[b];if(l.uint64Data&&l.uint64Data.length)for(f.uint64Data=[],b=0;b<l.uint64Data.length;++b)f.uint64Data[b]="number"==typeof l.uint64Data[b]?d.longs===String?String(l.uint64Data[b]):l.uint64Data[b]:d.longs===String?v.Long.prototype.toString.call(l.uint64Data[b]):d.longs===Number?new v.LongBits(l.uint64Data[b].low>>>0,l.uint64Data[b].high>>>0).toNumber(!0):l.uint64Data[b];if(null!=l.docString&&l.hasOwnProperty("docString")&&(f.docString=l.docString),l.externalData&&l.externalData.length)for(f.externalData=[],b=0;b<l.externalData.length;++b)f.externalData[b]=g.onnx.StringStringEntryProto.toObject(l.externalData[b],d);return null!=l.dataLocation&&l.hasOwnProperty("dataLocation")&&(f.dataLocation=d.enums===String?void 0===g.onnx.TensorProto.DataLocation[l.dataLocation]?l.dataLocation:g.onnx.TensorProto.DataLocation[l.dataLocation]:l.dataLocation),f},h.prototype.toJSON=function(){return this.constructor.toObject(this,k.util.toJSONOptions)},h.getTypeUrl=function(l){return void 0===l&&(l="type.googleapis.com"),l+"/onnx.TensorProto"},h.DataType=(l={},(d=Object.create(l))[l[0]="UNDEFINED"]=0,d[l[1]="FLOAT"]=1,d[l[2]="UINT8"]=2,d[l[3]="INT8"]=3,d[l[4]="UINT16"]=4,d[l[5]="INT16"]=5,d[l[6]="INT32"]=6,d[l[7]="INT64"]=7,d[l[8]="STRING"]=8,d[l[9]="BOOL"]=9,d[l[10]="FLOAT16"]=10,d[l[11]="DOUBLE"]=11,d[l[12]="UINT32"]=12,d[l[13]="UINT64"]=13,d[l[14]="COMPLEX64"]=14,d[l[15]="COMPLEX128"]=15,d[l[16]="BFLOAT16"]=16,d[l[17]="FLOAT8E4M3FN"]=17,d[l[18]="FLOAT8E4M3FNUZ"]=18,d[l[19]="FLOAT8E5M2"]=19,d[l[20]="FLOAT8E5M2FNUZ"]=20,d),h.Segment=function(){function l(d){if(d)for(var f=Object.keys(d),b=0;b<f.length;++b)null!=d[f[b]]&&(this[f[b]]=d[f[b]])}return l.prototype.begin=v.Long?v.Long.fromBits(0,0,!1):0,l.prototype.end=v.Long?v.Long.fromBits(0,0,!1):0,l.create=function(d){return new l(d)},l.encode=function(d,f){return f||(f=C.create()),null!=d.begin&&Object.hasOwnProperty.call(d,"begin")&&f.uint32(8).int64(d.begin),null!=d.end&&Object.hasOwnProperty.call(d,"end")&&f.uint32(16).int64(d.end),f},l.encodeDelimited=function(d,f){return this.encode(d,f).ldelim()},l.decode=function(d,f){d instanceof S||(d=S.create(d));for(var b=void 0===f?d.len:d.pos+f,x=new g.onnx.TensorProto.Segment;d.pos<b;){var D=d.uint32();switch(D>>>3){case 1:x.begin=d.int64();break;case 2:x.end=d.int64();break;default:d.skipType(7&D)}}return x},l.decodeDelimited=function(d){return d instanceof S||(d=new S(d)),this.decode(d,d.uint32())},l.verify=function(d){return"object"!=typeof d||null===d?"object expected":null!=d.begin&&d.hasOwnProperty("begin")&&!(v.isInteger(d.begin)||d.begin&&v.isInteger(d.begin.low)&&v.isInteger(d.begin.high))?"begin: integer|Long expected":null!=d.end&&d.hasOwnProperty("end")&&!(v.isInteger(d.end)||d.end&&v.isInteger(d.end.low)&&v.isInteger(d.end.high))?"end: integer|Long expected":null},l.fromObject=function(d){if(d instanceof g.onnx.TensorProto.Segment)return d;var f=new g.onnx.TensorProto.Segment;return null!=d.begin&&(v.Long?(f.begin=v.Long.fromValue(d.begin)).unsigned=!1:"string"==typeof d.begin?f.begin=parseInt(d.begin,10):"number"==typeof d.begin?f.begin=d.begin:"object"==typeof d.begin&&(f.begin=new v.LongBits(d.begin.low>>>0,d.begin.high>>>0).toNumber())),null!=d.end&&(v.Long?(f.end=v.Long.fromValue(d.end)).unsigned=!1:"string"==typeof d.end?f.end=parseInt(d.end,10):"number"==typeof d.end?f.end=d.end:"object"==typeof d.end&&(f.end=new v.LongBits(d.end.low>>>0,d.end.high>>>0).toNumber())),f},l.toObject=function(d,f){f||(f={});var b={};if(f.defaults){if(v.Long){var x=new v.Long(0,0,!1);b.begin=f.longs===String?x.toString():f.longs===Number?x.toNumber():x}else b.begin=f.longs===String?"0":0;v.Long?(x=new v.Long(0,0,!1),b.end=f.longs===String?x.toString():f.longs===Number?x.toNumber():x):b.end=f.longs===String?"0":0}return null!=d.begin&&d.hasOwnProperty("begin")&&(b.begin="number"==typeof d.begin?f.longs===String?String(d.begin):d.begin:f.longs===String?v.Long.prototype.toString.call(d.begin):f.longs===Number?new v.LongBits(d.begin.low>>>0,d.begin.high>>>0).toNumber():d.begin),null!=d.end&&d.hasOwnProperty("end")&&(b.end="number"==typeof d.end?f.longs===String?String(d.end):d.end:f.longs===String?v.Long.prototype.toString.call(d.end):f.longs===Number?new v.LongBits(d.end.low>>>0,d.end.high>>>0).toNumber():d.end),b},l.prototype.toJSON=function(){return this.constructor.toObject(this,k.util.toJSONOptions)},l.getTypeUrl=function(d){return void 0===d&&(d="type.googleapis.com"),d+"/onnx.TensorProto.Segment"},l}(),h.DataLocation=function(){var l={},d=Object.create(l);return d[l[0]="DEFAULT"]=0,d[l[1]="EXTERNAL"]=1,d}(),h;var l,d}(),R.SparseTensorProto=function(){function h(l){if(this.dims=[],l)for(var d=Object.keys(l),f=0;f<d.length;++f)null!=l[d[f]]&&(this[d[f]]=l[d[f]])}return h.prototype.values=null,h.prototype.indices=null,h.prototype.dims=v.emptyArray,h.create=function(l){return new h(l)},h.encode=function(l,d){if(d||(d=C.create()),null!=l.values&&Object.hasOwnProperty.call(l,"values")&&g.onnx.TensorProto.encode(l.values,d.uint32(10).fork()).ldelim(),null!=l.indices&&Object.hasOwnProperty.call(l,"indices")&&g.onnx.TensorProto.encode(l.indices,d.uint32(18).fork()).ldelim(),null!=l.dims&&l.dims.length){d.uint32(26).fork();for(var f=0;f<l.dims.length;++f)d.int64(l.dims[f]);d.ldelim()}return d},h.encodeDelimited=function(l,d){return this.encode(l,d).ldelim()},h.decode=function(l,d){l instanceof S||(l=S.create(l));for(var f=void 0===d?l.len:l.pos+d,b=new g.onnx.SparseTensorProto;l.pos<f;){var x=l.uint32();switch(x>>>3){case 1:b.values=g.onnx.TensorProto.decode(l,l.uint32());break;case 2:b.indices=g.onnx.TensorProto.decode(l,l.uint32());break;case 3:if(b.dims&&b.dims.length||(b.dims=[]),2==(7&x))for(var D=l.uint32()+l.pos;l.pos<D;)b.dims.push(l.int64());else b.dims.push(l.int64());break;default:l.skipType(7&x)}}return b},h.decodeDelimited=function(l){return l instanceof S||(l=new S(l)),this.decode(l,l.uint32())},h.verify=function(l){if("object"!=typeof l||null===l)return"object expected";var d;if(null!=l.values&&l.hasOwnProperty("values")&&(d=g.onnx.TensorProto.verify(l.values)))return"values."+d;if(null!=l.indices&&l.hasOwnProperty("indices")&&(d=g.onnx.TensorProto.verify(l.indices)))return"indices."+d;if(null!=l.dims&&l.hasOwnProperty("dims")){if(!Array.isArray(l.dims))return"dims: array expected";for(var f=0;f<l.dims.length;++f)if(!(v.isInteger(l.dims[f])||l.dims[f]&&v.isInteger(l.dims[f].low)&&v.isInteger(l.dims[f].high)))return"dims: integer|Long[] expected"}return null},h.fromObject=function(l){if(l instanceof g.onnx.SparseTensorProto)return l;var d=new g.onnx.SparseTensorProto;if(null!=l.values){if("object"!=typeof l.values)throw TypeError(".onnx.SparseTensorProto.values: object expected");d.values=g.onnx.TensorProto.fromObject(l.values)}if(null!=l.indices){if("object"!=typeof l.indices)throw TypeError(".onnx.SparseTensorProto.indices: object expected");d.indices=g.onnx.TensorProto.fromObject(l.indices)}if(l.dims){if(!Array.isArray(l.dims))throw TypeError(".onnx.SparseTensorProto.dims: array expected");d.dims=[];for(var f=0;f<l.dims.length;++f)v.Long?(d.dims[f]=v.Long.fromValue(l.dims[f])).unsigned=!1:"string"==typeof l.dims[f]?d.dims[f]=parseInt(l.dims[f],10):"number"==typeof l.dims[f]?d.dims[f]=l.dims[f]:"object"==typeof l.dims[f]&&(d.dims[f]=new v.LongBits(l.dims[f].low>>>0,l.dims[f].high>>>0).toNumber())}return d},h.toObject=function(l,d){d||(d={});var f={};if((d.arrays||d.defaults)&&(f.dims=[]),d.defaults&&(f.values=null,f.indices=null),null!=l.values&&l.hasOwnProperty("values")&&(f.values=g.onnx.TensorProto.toObject(l.values,d)),null!=l.indices&&l.hasOwnProperty("indices")&&(f.indices=g.onnx.TensorProto.toObject(l.indices,d)),l.dims&&l.dims.length){f.dims=[];for(var b=0;b<l.dims.length;++b)f.dims[b]="number"==typeof l.dims[b]?d.longs===String?String(l.dims[b]):l.dims[b]:d.longs===String?v.Long.prototype.toString.call(l.dims[b]):d.longs===Number?new v.LongBits(l.dims[b].low>>>0,l.dims[b].high>>>0).toNumber():l.dims[b]}return f},h.prototype.toJSON=function(){return this.constructor.toObject(this,k.util.toJSONOptions)},h.getTypeUrl=function(l){return void 0===l&&(l="type.googleapis.com"),l+"/onnx.SparseTensorProto"},h}(),R.TensorShapeProto=function(){function h(l){if(this.dim=[],l)for(var d=Object.keys(l),f=0;f<d.length;++f)null!=l[d[f]]&&(this[d[f]]=l[d[f]])}return h.prototype.dim=v.emptyArray,h.create=function(l){return new h(l)},h.encode=function(l,d){if(d||(d=C.create()),null!=l.dim&&l.dim.length)for(var f=0;f<l.dim.length;++f)g.onnx.TensorShapeProto.Dimension.encode(l.dim[f],d.uint32(10).fork()).ldelim();return d},h.encodeDelimited=function(l,d){return this.encode(l,d).ldelim()},h.decode=function(l,d){l instanceof S||(l=S.create(l));for(var f=void 0===d?l.len:l.pos+d,b=new g.onnx.TensorShapeProto;l.pos<f;){var x=l.uint32();x>>>3==1?(b.dim&&b.dim.length||(b.dim=[]),b.dim.push(g.onnx.TensorShapeProto.Dimension.decode(l,l.uint32()))):l.skipType(7&x)}return b},h.decodeDelimited=function(l){return l instanceof S||(l=new S(l)),this.decode(l,l.uint32())},h.verify=function(l){if("object"!=typeof l||null===l)return"object expected";if(null!=l.dim&&l.hasOwnProperty("dim")){if(!Array.isArray(l.dim))return"dim: array expected";for(var d=0;d<l.dim.length;++d){var f=g.onnx.TensorShapeProto.Dimension.verify(l.dim[d]);if(f)return"dim."+f}}return null},h.fromObject=function(l){if(l instanceof g.onnx.TensorShapeProto)return l;var d=new g.onnx.TensorShapeProto;if(l.dim){if(!Array.isArray(l.dim))throw TypeError(".onnx.TensorShapeProto.dim: array expected");d.dim=[];for(var f=0;f<l.dim.length;++f){if("object"!=typeof l.dim[f])throw TypeError(".onnx.TensorShapeProto.dim: object expected");d.dim[f]=g.onnx.TensorShapeProto.Dimension.fromObject(l.dim[f])}}return d},h.toObject=function(l,d){d||(d={});var f={};if((d.arrays||d.defaults)&&(f.dim=[]),l.dim&&l.dim.length){f.dim=[];for(var b=0;b<l.dim.length;++b)f.dim[b]=g.onnx.TensorShapeProto.Dimension.toObject(l.dim[b],d)}return f},h.prototype.toJSON=function(){return this.constructor.toObject(this,k.util.toJSONOptions)},h.getTypeUrl=function(l){return void 0===l&&(l="type.googleapis.com"),l+"/onnx.TensorShapeProto"},h.Dimension=function(){function l(f){if(f)for(var b=Object.keys(f),x=0;x<b.length;++x)null!=f[b[x]]&&(this[b[x]]=f[b[x]])}var d;return l.prototype.dimValue=null,l.prototype.dimParam=null,l.prototype.denotation="",Object.defineProperty(l.prototype,"value",{get:v.oneOfGetter(d=["dimValue","dimParam"]),set:v.oneOfSetter(d)}),l.create=function(f){return new l(f)},l.encode=function(f,b){return b||(b=C.create()),null!=f.dimValue&&Object.hasOwnProperty.call(f,"dimValue")&&b.uint32(8).int64(f.dimValue),null!=f.dimParam&&Object.hasOwnProperty.call(f,"dimParam")&&b.uint32(18).string(f.dimParam),null!=f.denotation&&Object.hasOwnProperty.call(f,"denotation")&&b.uint32(26).string(f.denotation),b},l.encodeDelimited=function(f,b){return this.encode(f,b).ldelim()},l.decode=function(f,b){f instanceof S||(f=S.create(f));for(var x=void 0===b?f.len:f.pos+b,D=new g.onnx.TensorShapeProto.Dimension;f.pos<x;){var P=f.uint32();switch(P>>>3){case 1:D.dimValue=f.int64();break;case 2:D.dimParam=f.string();break;case 3:D.denotation=f.string();break;default:f.skipType(7&P)}}return D},l.decodeDelimited=function(f){return f instanceof S||(f=new S(f)),this.decode(f,f.uint32())},l.verify=function(f){if("object"!=typeof f||null===f)return"object expected";var b={};if(null!=f.dimValue&&f.hasOwnProperty("dimValue")&&(b.value=1,!(v.isInteger(f.dimValue)||f.dimValue&&v.isInteger(f.dimValue.low)&&v.isInteger(f.dimValue.high))))return"dimValue: integer|Long expected";if(null!=f.dimParam&&f.hasOwnProperty("dimParam")){if(1===b.value)return"value: multiple values";if(b.value=1,!v.isString(f.dimParam))return"dimParam: string expected"}return null!=f.denotation&&f.hasOwnProperty("denotation")&&!v.isString(f.denotation)?"denotation: string expected":null},l.fromObject=function(f){if(f instanceof g.onnx.TensorShapeProto.Dimension)return f;var b=new g.onnx.TensorShapeProto.Dimension;return null!=f.dimValue&&(v.Long?(b.dimValue=v.Long.fromValue(f.dimValue)).unsigned=!1:"string"==typeof f.dimValue?b.dimValue=parseInt(f.dimValue,10):"number"==typeof f.dimValue?b.dimValue=f.dimValue:"object"==typeof f.dimValue&&(b.dimValue=new v.LongBits(f.dimValue.low>>>0,f.dimValue.high>>>0).toNumber())),null!=f.dimParam&&(b.dimParam=String(f.dimParam)),null!=f.denotation&&(b.denotation=String(f.denotation)),b},l.toObject=function(f,b){b||(b={});var x={};return b.defaults&&(x.denotation=""),null!=f.dimValue&&f.hasOwnProperty("dimValue")&&(x.dimValue="number"==typeof f.dimValue?b.longs===String?String(f.dimValue):f.dimValue:b.longs===String?v.Long.prototype.toString.call(f.dimValue):b.longs===Number?new v.LongBits(f.dimValue.low>>>0,f.dimValue.high>>>0).toNumber():f.dimValue,b.oneofs&&(x.value="dimValue")),null!=f.dimParam&&f.hasOwnProperty("dimParam")&&(x.dimParam=f.dimParam,b.oneofs&&(x.value="dimParam")),null!=f.denotation&&f.hasOwnProperty("denotation")&&(x.denotation=f.denotation),x},l.prototype.toJSON=function(){return this.constructor.toObject(this,k.util.toJSONOptions)},l.getTypeUrl=function(f){return void 0===f&&(f="type.googleapis.com"),f+"/onnx.TensorShapeProto.Dimension"},l}(),h}(),R.TypeProto=function(){function h(d){if(d)for(var f=Object.keys(d),b=0;b<f.length;++b)null!=d[f[b]]&&(this[f[b]]=d[f[b]])}var l;return h.prototype.tensorType=null,h.prototype.sequenceType=null,h.prototype.mapType=null,h.prototype.optionalType=null,h.prototype.sparseTensorType=null,h.prototype.denotation="",Object.defineProperty(h.prototype,"value",{get:v.oneOfGetter(l=["tensorType","sequenceType","mapType","optionalType","sparseTensorType"]),set:v.oneOfSetter(l)}),h.create=function(d){return new h(d)},h.encode=function(d,f){return f||(f=C.create()),null!=d.tensorType&&Object.hasOwnProperty.call(d,"tensorType")&&g.onnx.TypeProto.Tensor.encode(d.tensorType,f.uint32(10).fork()).ldelim(),null!=d.sequenceType&&Object.hasOwnProperty.call(d,"sequenceType")&&g.onnx.TypeProto.Sequence.encode(d.sequenceType,f.uint32(34).fork()).ldelim(),null!=d.mapType&&Object.hasOwnProperty.call(d,"mapType")&&g.onnx.TypeProto.Map.encode(d.mapType,f.uint32(42).fork()).ldelim(),null!=d.denotation&&Object.hasOwnProperty.call(d,"denotation")&&f.uint32(50).string(d.denotation),null!=d.sparseTensorType&&Object.hasOwnProperty.call(d,"sparseTensorType")&&g.onnx.TypeProto.SparseTensor.encode(d.sparseTensorType,f.uint32(66).fork()).ldelim(),null!=d.optionalType&&Object.hasOwnProperty.call(d,"optionalType")&&g.onnx.TypeProto.Optional.encode(d.optionalType,f.uint32(74).fork()).ldelim(),f},h.encodeDelimited=function(d,f){return this.encode(d,f).ldelim()},h.decode=function(d,f){d instanceof S||(d=S.create(d));for(var b=void 0===f?d.len:d.pos+f,x=new g.onnx.TypeProto;d.pos<b;){var D=d.uint32();switch(D>>>3){case 1:x.tensorType=g.onnx.TypeProto.Tensor.decode(d,d.uint32());break;case 4:x.sequenceType=g.onnx.TypeProto.Sequence.decode(d,d.uint32());break;case 5:x.mapType=g.onnx.TypeProto.Map.decode(d,d.uint32());break;case 9:x.optionalType=g.onnx.TypeProto.Optional.decode(d,d.uint32());break;case 8:x.sparseTensorType=g.onnx.TypeProto.SparseTensor.decode(d,d.uint32());break;case 6:x.denotation=d.string();break;default:d.skipType(7&D)}}return x},h.decodeDelimited=function(d){return d instanceof S||(d=new S(d)),this.decode(d,d.uint32())},h.verify=function(d){if("object"!=typeof d||null===d)return"object expected";var f={};if(null!=d.tensorType&&d.hasOwnProperty("tensorType")&&(f.value=1,b=g.onnx.TypeProto.Tensor.verify(d.tensorType)))return"tensorType."+b;if(null!=d.sequenceType&&d.hasOwnProperty("sequenceType")){if(1===f.value)return"value: multiple values";if(f.value=1,b=g.onnx.TypeProto.Sequence.verify(d.sequenceType))return"sequenceType."+b}if(null!=d.mapType&&d.hasOwnProperty("mapType")){if(1===f.value)return"value: multiple values";if(f.value=1,b=g.onnx.TypeProto.Map.verify(d.mapType))return"mapType."+b}if(null!=d.optionalType&&d.hasOwnProperty("optionalType")){if(1===f.value)return"value: multiple values";if(f.value=1,b=g.onnx.TypeProto.Optional.verify(d.optionalType))return"optionalType."+b}if(null!=d.sparseTensorType&&d.hasOwnProperty("sparseTensorType")){if(1===f.value)return"value: multiple values";var b;if(f.value=1,b=g.onnx.TypeProto.SparseTensor.verify(d.sparseTensorType))return"sparseTensorType."+b}return null!=d.denotation&&d.hasOwnProperty("denotation")&&!v.isString(d.denotation)?"denotation: string expected":null},h.fromObject=function(d){if(d instanceof g.onnx.TypeProto)return d;var f=new g.onnx.TypeProto;if(null!=d.tensorType){if("object"!=typeof d.tensorType)throw TypeError(".onnx.TypeProto.tensorType: object expected");f.tensorType=g.onnx.TypeProto.Tensor.fromObject(d.tensorType)}if(null!=d.sequenceType){if("object"!=typeof d.sequenceType)throw TypeError(".onnx.TypeProto.sequenceType: object expected");f.sequenceType=g.onnx.TypeProto.Sequence.fromObject(d.sequenceType)}if(null!=d.mapType){if("object"!=typeof d.mapType)throw TypeError(".onnx.TypeProto.mapType: object expected");f.mapType=g.onnx.TypeProto.Map.fromObject(d.mapType)}if(null!=d.optionalType){if("object"!=typeof d.optionalType)throw TypeError(".onnx.TypeProto.optionalType: object expected");f.optionalType=g.onnx.TypeProto.Optional.fromObject(d.optionalType)}if(null!=d.sparseTensorType){if("object"!=typeof d.sparseTensorType)throw TypeError(".onnx.TypeProto.sparseTensorType: object expected");f.sparseTensorType=g.onnx.TypeProto.SparseTensor.fromObject(d.sparseTensorType)}return null!=d.denotation&&(f.denotation=String(d.denotation)),f},h.toObject=function(d,f){f||(f={});var b={};return f.defaults&&(b.denotation=""),null!=d.tensorType&&d.hasOwnProperty("tensorType")&&(b.tensorType=g.onnx.TypeProto.Tensor.toObject(d.tensorType,f),f.oneofs&&(b.value="tensorType")),null!=d.sequenceType&&d.hasOwnProperty("sequenceType")&&(b.sequenceType=g.onnx.TypeProto.Sequence.toObject(d.sequenceType,f),f.oneofs&&(b.value="sequenceType")),null!=d.mapType&&d.hasOwnProperty("mapType")&&(b.mapType=g.onnx.TypeProto.Map.toObject(d.mapType,f),f.oneofs&&(b.value="mapType")),null!=d.denotation&&d.hasOwnProperty("denotation")&&(b.denotation=d.denotation),null!=d.sparseTensorType&&d.hasOwnProperty("sparseTensorType")&&(b.sparseTensorType=g.onnx.TypeProto.SparseTensor.toObject(d.sparseTensorType,f),f.oneofs&&(b.value="sparseTensorType")),null!=d.optionalType&&d.hasOwnProperty("optionalType")&&(b.optionalType=g.onnx.TypeProto.Optional.toObject(d.optionalType,f),f.oneofs&&(b.value="optionalType")),b},h.prototype.toJSON=function(){return this.constructor.toObject(this,k.util.toJSONOptions)},h.getTypeUrl=function(d){return void 0===d&&(d="type.googleapis.com"),d+"/onnx.TypeProto"},h.Tensor=function(){function d(f){if(f)for(var b=Object.keys(f),x=0;x<b.length;++x)null!=f[b[x]]&&(this[b[x]]=f[b[x]])}return d.prototype.elemType=0,d.prototype.shape=null,d.create=function(f){return new d(f)},d.encode=function(f,b){return b||(b=C.create()),null!=f.elemType&&Object.hasOwnProperty.call(f,"elemType")&&b.uint32(8).int32(f.elemType),null!=f.shape&&Object.hasOwnProperty.call(f,"shape")&&g.onnx.TensorShapeProto.encode(f.shape,b.uint32(18).fork()).ldelim(),b},d.encodeDelimited=function(f,b){return this.encode(f,b).ldelim()},d.decode=function(f,b){f instanceof S||(f=S.create(f));for(var x=void 0===b?f.len:f.pos+b,D=new g.onnx.TypeProto.Tensor;f.pos<x;){var P=f.uint32();switch(P>>>3){case 1:D.elemType=f.int32();break;case 2:D.shape=g.onnx.TensorShapeProto.decode(f,f.uint32());break;default:f.skipType(7&P)}}return D},d.decodeDelimited=function(f){return f instanceof S||(f=new S(f)),this.decode(f,f.uint32())},d.verify=function(f){if("object"!=typeof f||null===f)return"object expected";if(null!=f.elemType&&f.hasOwnProperty("elemType")&&!v.isInteger(f.elemType))return"elemType: integer expected";if(null!=f.shape&&f.hasOwnProperty("shape")){var b=g.onnx.TensorShapeProto.verify(f.shape);if(b)return"shape."+b}return null},d.fromObject=function(f){if(f instanceof g.onnx.TypeProto.Tensor)return f;var b=new g.onnx.TypeProto.Tensor;if(null!=f.elemType&&(b.elemType=0|f.elemType),null!=f.shape){if("object"!=typeof f.shape)throw TypeError(".onnx.TypeProto.Tensor.shape: object expected");b.shape=g.onnx.TensorShapeProto.fromObject(f.shape)}return b},d.toObject=function(f,b){b||(b={});var x={};return b.defaults&&(x.elemType=0,x.shape=null),null!=f.elemType&&f.hasOwnProperty("elemType")&&(x.elemType=f.elemType),null!=f.shape&&f.hasOwnProperty("shape")&&(x.shape=g.onnx.TensorShapeProto.toObject(f.shape,b)),x},d.prototype.toJSON=function(){return this.constructor.toObject(this,k.util.toJSONOptions)},d.getTypeUrl=function(f){return void 0===f&&(f="type.googleapis.com"),f+"/onnx.TypeProto.Tensor"},d}(),h.Sequence=function(){function d(f){if(f)for(var b=Object.keys(f),x=0;x<b.length;++x)null!=f[b[x]]&&(this[b[x]]=f[b[x]])}return d.prototype.elemType=null,d.create=function(f){return new d(f)},d.encode=function(f,b){return b||(b=C.create()),null!=f.elemType&&Object.hasOwnProperty.call(f,"elemType")&&g.onnx.TypeProto.encode(f.elemType,b.uint32(10).fork()).ldelim(),b},d.encodeDelimited=function(f,b){return this.encode(f,b).ldelim()},d.decode=function(f,b){f instanceof S||(f=S.create(f));for(var x=void 0===b?f.len:f.pos+b,D=new g.onnx.TypeProto.Sequence;f.pos<x;){var P=f.uint32();P>>>3==1?D.elemType=g.onnx.TypeProto.decode(f,f.uint32()):f.skipType(7&P)}return D},d.decodeDelimited=function(f){return f instanceof S||(f=new S(f)),this.decode(f,f.uint32())},d.verify=function(f){if("object"!=typeof f||null===f)return"object expected";if(null!=f.elemType&&f.hasOwnProperty("elemType")){var b=g.onnx.TypeProto.verify(f.elemType);if(b)return"elemType."+b}return null},d.fromObject=function(f){if(f instanceof g.onnx.TypeProto.Sequence)return f;var b=new g.onnx.TypeProto.Sequence;if(null!=f.elemType){if("object"!=typeof f.elemType)throw TypeError(".onnx.TypeProto.Sequence.elemType: object expected");b.elemType=g.onnx.TypeProto.fromObject(f.elemType)}return b},d.toObject=function(f,b){b||(b={});var x={};return b.defaults&&(x.elemType=null),null!=f.elemType&&f.hasOwnProperty("elemType")&&(x.elemType=g.onnx.TypeProto.toObject(f.elemType,b)),x},d.prototype.toJSON=function(){return this.constructor.toObject(this,k.util.toJSONOptions)},d.getTypeUrl=function(f){return void 0===f&&(f="type.googleapis.com"),f+"/onnx.TypeProto.Sequence"},d}(),h.Map=function(){function d(f){if(f)for(var b=Object.keys(f),x=0;x<b.length;++x)null!=f[b[x]]&&(this[b[x]]=f[b[x]])}return d.prototype.keyType=0,d.prototype.valueType=null,d.create=function(f){return new d(f)},d.encode=function(f,b){return b||(b=C.create()),null!=f.keyType&&Object.hasOwnProperty.call(f,"keyType")&&b.uint32(8).int32(f.keyType),null!=f.valueType&&Object.hasOwnProperty.call(f,"valueType")&&g.onnx.TypeProto.encode(f.valueType,b.uint32(18).fork()).ldelim(),b},d.encodeDelimited=function(f,b){return this.encode(f,b).ldelim()},d.decode=function(f,b){f instanceof S||(f=S.create(f));for(var x=void 0===b?f.len:f.pos+b,D=new g.onnx.TypeProto.Map;f.pos<x;){var P=f.uint32();switch(P>>>3){case 1:D.keyType=f.int32();break;case 2:D.valueType=g.onnx.TypeProto.decode(f,f.uint32());break;default:f.skipType(7&P)}}return D},d.decodeDelimited=function(f){return f instanceof S||(f=new S(f)),this.decode(f,f.uint32())},d.verify=function(f){if("object"!=typeof f||null===f)return"object expected";if(null!=f.keyType&&f.hasOwnProperty("keyType")&&!v.isInteger(f.keyType))return"keyType: integer expected";if(null!=f.valueType&&f.hasOwnProperty("valueType")){var b=g.onnx.TypeProto.verify(f.valueType);if(b)return"valueType."+b}return null},d.fromObject=function(f){if(f instanceof g.onnx.TypeProto.Map)return f;var b=new g.onnx.TypeProto.Map;if(null!=f.keyType&&(b.keyType=0|f.keyType),null!=f.valueType){if("object"!=typeof f.valueType)throw TypeError(".onnx.TypeProto.Map.valueType: object expected");b.valueType=g.onnx.TypeProto.fromObject(f.valueType)}return b},d.toObject=function(f,b){b||(b={});var x={};return b.defaults&&(x.keyType=0,x.valueType=null),null!=f.keyType&&f.hasOwnProperty("keyType")&&(x.keyType=f.keyType),null!=f.valueType&&f.hasOwnProperty("valueType")&&(x.valueType=g.onnx.TypeProto.toObject(f.valueType,b)),x},d.prototype.toJSON=function(){return this.constructor.toObject(this,k.util.toJSONOptions)},d.getTypeUrl=function(f){return void 0===f&&(f="type.googleapis.com"),f+"/onnx.TypeProto.Map"},d}(),h.Optional=function(){function d(f){if(f)for(var b=Object.keys(f),x=0;x<b.length;++x)null!=f[b[x]]&&(this[b[x]]=f[b[x]])}return d.prototype.elemType=null,d.create=function(f){return new d(f)},d.encode=function(f,b){return b||(b=C.create()),null!=f.elemType&&Object.hasOwnProperty.call(f,"elemType")&&g.onnx.TypeProto.encode(f.elemType,b.uint32(10).fork()).ldelim(),b},d.encodeDelimited=function(f,b){return this.encode(f,b).ldelim()},d.decode=function(f,b){f instanceof S||(f=S.create(f));for(var x=void 0===b?f.len:f.pos+b,D=new g.onnx.TypeProto.Optional;f.pos<x;){var P=f.uint32();P>>>3==1?D.elemType=g.onnx.TypeProto.decode(f,f.uint32()):f.skipType(7&P)}return D},d.decodeDelimited=function(f){return f instanceof S||(f=new S(f)),this.decode(f,f.uint32())},d.verify=function(f){if("object"!=typeof f||null===f)return"object expected";if(null!=f.elemType&&f.hasOwnProperty("elemType")){var b=g.onnx.TypeProto.verify(f.elemType);if(b)return"elemType."+b}return null},d.fromObject=function(f){if(f instanceof g.onnx.TypeProto.Optional)return f;var b=new g.onnx.TypeProto.Optional;if(null!=f.elemType){if("object"!=typeof f.elemType)throw TypeError(".onnx.TypeProto.Optional.elemType: object expected");b.elemType=g.onnx.TypeProto.fromObject(f.elemType)}return b},d.toObject=function(f,b){b||(b={});var x={};return b.defaults&&(x.elemType=null),null!=f.elemType&&f.hasOwnProperty("elemType")&&(x.elemType=g.onnx.TypeProto.toObject(f.elemType,b)),x},d.prototype.toJSON=function(){return this.constructor.toObject(this,k.util.toJSONOptions)},d.getTypeUrl=function(f){return void 0===f&&(f="type.googleapis.com"),f+"/onnx.TypeProto.Optional"},d}(),h.SparseTensor=function(){function d(f){if(f)for(var b=Object.keys(f),x=0;x<b.length;++x)null!=f[b[x]]&&(this[b[x]]=f[b[x]])}return d.prototype.elemType=0,d.prototype.shape=null,d.create=function(f){return new d(f)},d.encode=function(f,b){return b||(b=C.create()),null!=f.elemType&&Object.hasOwnProperty.call(f,"elemType")&&b.uint32(8).int32(f.elemType),null!=f.shape&&Object.hasOwnProperty.call(f,"shape")&&g.onnx.TensorShapeProto.encode(f.shape,b.uint32(18).fork()).ldelim(),b},d.encodeDelimited=function(f,b){return this.encode(f,b).ldelim()},d.decode=function(f,b){f instanceof S||(f=S.create(f));for(var x=void 0===b?f.len:f.pos+b,D=new g.onnx.TypeProto.SparseTensor;f.pos<x;){var P=f.uint32();switch(P>>>3){case 1:D.elemType=f.int32();break;case 2:D.shape=g.onnx.TensorShapeProto.decode(f,f.uint32());break;default:f.skipType(7&P)}}return D},d.decodeDelimited=function(f){return f instanceof S||(f=new S(f)),this.decode(f,f.uint32())},d.verify=function(f){if("object"!=typeof f||null===f)return"object expected";if(null!=f.elemType&&f.hasOwnProperty("elemType")&&!v.isInteger(f.elemType))return"elemType: integer expected";if(null!=f.shape&&f.hasOwnProperty("shape")){var b=g.onnx.TensorShapeProto.verify(f.shape);if(b)return"shape."+b}return null},d.fromObject=function(f){if(f instanceof g.onnx.TypeProto.SparseTensor)return f;var b=new g.onnx.TypeProto.SparseTensor;if(null!=f.elemType&&(b.elemType=0|f.elemType),null!=f.shape){if("object"!=typeof f.shape)throw TypeError(".onnx.TypeProto.SparseTensor.shape: object expected");b.shape=g.onnx.TensorShapeProto.fromObject(f.shape)}return b},d.toObject=function(f,b){b||(b={});var x={};return b.defaults&&(x.elemType=0,x.shape=null),null!=f.elemType&&f.hasOwnProperty("elemType")&&(x.elemType=f.elemType),null!=f.shape&&f.hasOwnProperty("shape")&&(x.shape=g.onnx.TensorShapeProto.toObject(f.shape,b)),x},d.prototype.toJSON=function(){return this.constructor.toObject(this,k.util.toJSONOptions)},d.getTypeUrl=function(f){return void 0===f&&(f="type.googleapis.com"),f+"/onnx.TypeProto.SparseTensor"},d}(),h}(),R.OperatorSetIdProto=function(){function h(l){if(l)for(var d=Object.keys(l),f=0;f<d.length;++f)null!=l[d[f]]&&(this[d[f]]=l[d[f]])}return h.prototype.domain="",h.prototype.version=v.Long?v.Long.fromBits(0,0,!1):0,h.create=function(l){return new h(l)},h.encode=function(l,d){return d||(d=C.create()),null!=l.domain&&Object.hasOwnProperty.call(l,"domain")&&d.uint32(10).string(l.domain),null!=l.version&&Object.hasOwnProperty.call(l,"version")&&d.uint32(16).int64(l.version),d},h.encodeDelimited=function(l,d){return this.encode(l,d).ldelim()},h.decode=function(l,d){l instanceof S||(l=S.create(l));for(var f=void 0===d?l.len:l.pos+d,b=new g.onnx.OperatorSetIdProto;l.pos<f;){var x=l.uint32();switch(x>>>3){case 1:b.domain=l.string();break;case 2:b.version=l.int64();break;default:l.skipType(7&x)}}return b},h.decodeDelimited=function(l){return l instanceof S||(l=new S(l)),this.decode(l,l.uint32())},h.verify=function(l){return"object"!=typeof l||null===l?"object expected":null!=l.domain&&l.hasOwnProperty("domain")&&!v.isString(l.domain)?"domain: string expected":null!=l.version&&l.hasOwnProperty("version")&&!(v.isInteger(l.version)||l.version&&v.isInteger(l.version.low)&&v.isInteger(l.version.high))?"version: integer|Long expected":null},h.fromObject=function(l){if(l instanceof g.onnx.OperatorSetIdProto)return l;var d=new g.onnx.OperatorSetIdProto;return null!=l.domain&&(d.domain=String(l.domain)),null!=l.version&&(v.Long?(d.version=v.Long.fromValue(l.version)).unsigned=!1:"string"==typeof l.version?d.version=parseInt(l.version,10):"number"==typeof l.version?d.version=l.version:"object"==typeof l.version&&(d.version=new v.LongBits(l.version.low>>>0,l.version.high>>>0).toNumber())),d},h.toObject=function(l,d){d||(d={});var f={};if(d.defaults)if(f.domain="",v.Long){var b=new v.Long(0,0,!1);f.version=d.longs===String?b.toString():d.longs===Number?b.toNumber():b}else f.version=d.longs===String?"0":0;return null!=l.domain&&l.hasOwnProperty("domain")&&(f.domain=l.domain),null!=l.version&&l.hasOwnProperty("version")&&(f.version="number"==typeof l.version?d.longs===String?String(l.version):l.version:d.longs===String?v.Long.prototype.toString.call(l.version):d.longs===Number?new v.LongBits(l.version.low>>>0,l.version.high>>>0).toNumber():l.version),f},h.prototype.toJSON=function(){return this.constructor.toObject(this,k.util.toJSONOptions)},h.getTypeUrl=function(l){return void 0===l&&(l="type.googleapis.com"),l+"/onnx.OperatorSetIdProto"},h}(),R.OperatorStatus=(h={},(l=Object.create(h))[h[0]="EXPERIMENTAL"]=0,l[h[1]="STABLE"]=1,l),R.FunctionProto=function(){function h(l){if(this.input=[],this.output=[],this.attribute=[],this.attributeProto=[],this.node=[],this.opsetImport=[],l)for(var d=Object.keys(l),f=0;f<d.length;++f)null!=l[d[f]]&&(this[d[f]]=l[d[f]])}return h.prototype.name="",h.prototype.input=v.emptyArray,h.prototype.output=v.emptyArray,h.prototype.attribute=v.emptyArray,h.prototype.attributeProto=v.emptyArray,h.prototype.node=v.emptyArray,h.prototype.docString="",h.prototype.opsetImport=v.emptyArray,h.prototype.domain="",h.create=function(l){return new h(l)},h.encode=function(l,d){if(d||(d=C.create()),null!=l.name&&Object.hasOwnProperty.call(l,"name")&&d.uint32(10).string(l.name),null!=l.input&&l.input.length)for(var f=0;f<l.input.length;++f)d.uint32(34).string(l.input[f]);if(null!=l.output&&l.output.length)for(f=0;f<l.output.length;++f)d.uint32(42).string(l.output[f]);if(null!=l.attribute&&l.attribute.length)for(f=0;f<l.attribute.length;++f)d.uint32(50).string(l.attribute[f]);if(null!=l.node&&l.node.length)for(f=0;f<l.node.length;++f)g.onnx.NodeProto.encode(l.node[f],d.uint32(58).fork()).ldelim();if(null!=l.docString&&Object.hasOwnProperty.call(l,"docString")&&d.uint32(66).string(l.docString),null!=l.opsetImport&&l.opsetImport.length)for(f=0;f<l.opsetImport.length;++f)g.onnx.OperatorSetIdProto.encode(l.opsetImport[f],d.uint32(74).fork()).ldelim();if(null!=l.domain&&Object.hasOwnProperty.call(l,"domain")&&d.uint32(82).string(l.domain),null!=l.attributeProto&&l.attributeProto.length)for(f=0;f<l.attributeProto.length;++f)g.onnx.AttributeProto.encode(l.attributeProto[f],d.uint32(90).fork()).ldelim();return d},h.encodeDelimited=function(l,d){return this.encode(l,d).ldelim()},h.decode=function(l,d){l instanceof S||(l=S.create(l));for(var f=void 0===d?l.len:l.pos+d,b=new g.onnx.FunctionProto;l.pos<f;){var x=l.uint32();switch(x>>>3){case 1:b.name=l.string();break;case 4:b.input&&b.input.length||(b.input=[]),b.input.push(l.string());break;case 5:b.output&&b.output.length||(b.output=[]),b.output.push(l.string());break;case 6:b.attribute&&b.attribute.length||(b.attribute=[]),b.attribute.push(l.string());break;case 11:b.attributeProto&&b.attributeProto.length||(b.attributeProto=[]),b.attributeProto.push(g.onnx.AttributeProto.decode(l,l.uint32()));break;case 7:b.node&&b.node.length||(b.node=[]),b.node.push(g.onnx.NodeProto.decode(l,l.uint32()));break;case 8:b.docString=l.string();break;case 9:b.opsetImport&&b.opsetImport.length||(b.opsetImport=[]),b.opsetImport.push(g.onnx.OperatorSetIdProto.decode(l,l.uint32()));break;case 10:b.domain=l.string();break;default:l.skipType(7&x)}}return b},h.decodeDelimited=function(l){return l instanceof S||(l=new S(l)),this.decode(l,l.uint32())},h.verify=function(l){if("object"!=typeof l||null===l)return"object expected";if(null!=l.name&&l.hasOwnProperty("name")&&!v.isString(l.name))return"name: string expected";if(null!=l.input&&l.hasOwnProperty("input")){if(!Array.isArray(l.input))return"input: array expected";for(var d=0;d<l.input.length;++d)if(!v.isString(l.input[d]))return"input: string[] expected"}if(null!=l.output&&l.hasOwnProperty("output")){if(!Array.isArray(l.output))return"output: array expected";for(d=0;d<l.output.length;++d)if(!v.isString(l.output[d]))return"output: string[] expected"}if(null!=l.attribute&&l.hasOwnProperty("attribute")){if(!Array.isArray(l.attribute))return"attribute: array expected";for(d=0;d<l.attribute.length;++d)if(!v.isString(l.attribute[d]))return"attribute: string[] expected"}if(null!=l.attributeProto&&l.hasOwnProperty("attributeProto")){if(!Array.isArray(l.attributeProto))return"attributeProto: array expected";for(d=0;d<l.attributeProto.length;++d)if(f=g.onnx.AttributeProto.verify(l.attributeProto[d]))return"attributeProto."+f}if(null!=l.node&&l.hasOwnProperty("node")){if(!Array.isArray(l.node))return"node: array expected";for(d=0;d<l.node.length;++d)if(f=g.onnx.NodeProto.verify(l.node[d]))return"node."+f}if(null!=l.docString&&l.hasOwnProperty("docString")&&!v.isString(l.docString))return"docString: string expected";if(null!=l.opsetImport&&l.hasOwnProperty("opsetImport")){if(!Array.isArray(l.opsetImport))return"opsetImport: array expected";for(d=0;d<l.opsetImport.length;++d){var f;if(f=g.onnx.OperatorSetIdProto.verify(l.opsetImport[d]))return"opsetImport."+f}}return null!=l.domain&&l.hasOwnProperty("domain")&&!v.isString(l.domain)?"domain: string expected":null},h.fromObject=function(l){if(l instanceof g.onnx.FunctionProto)return l;var d=new g.onnx.FunctionProto;if(null!=l.name&&(d.name=String(l.name)),l.input){if(!Array.isArray(l.input))throw TypeError(".onnx.FunctionProto.input: array expected");d.input=[];for(var f=0;f<l.input.length;++f)d.input[f]=String(l.input[f])}if(l.output){if(!Array.isArray(l.output))throw TypeError(".onnx.FunctionProto.output: array expected");for(d.output=[],f=0;f<l.output.length;++f)d.output[f]=String(l.output[f])}if(l.attribute){if(!Array.isArray(l.attribute))throw TypeError(".onnx.FunctionProto.attribute: array expected");for(d.attribute=[],f=0;f<l.attribute.length;++f)d.attribute[f]=String(l.attribute[f])}if(l.attributeProto){if(!Array.isArray(l.attributeProto))throw TypeError(".onnx.FunctionProto.attributeProto: array expected");for(d.attributeProto=[],f=0;f<l.attributeProto.length;++f){if("object"!=typeof l.attributeProto[f])throw TypeError(".onnx.FunctionProto.attributeProto: object expected");d.attributeProto[f]=g.onnx.AttributeProto.fromObject(l.attributeProto[f])}}if(l.node){if(!Array.isArray(l.node))throw TypeError(".onnx.FunctionProto.node: array expected");for(d.node=[],f=0;f<l.node.length;++f){if("object"!=typeof l.node[f])throw TypeError(".onnx.FunctionProto.node: object expected");d.node[f]=g.onnx.NodeProto.fromObject(l.node[f])}}if(null!=l.docString&&(d.docString=String(l.docString)),l.opsetImport){if(!Array.isArray(l.opsetImport))throw TypeError(".onnx.FunctionProto.opsetImport: array expected");for(d.opsetImport=[],f=0;f<l.opsetImport.length;++f){if("object"!=typeof l.opsetImport[f])throw TypeError(".onnx.FunctionProto.opsetImport: object expected");d.opsetImport[f]=g.onnx.OperatorSetIdProto.fromObject(l.opsetImport[f])}}return null!=l.domain&&(d.domain=String(l.domain)),d},h.toObject=function(l,d){d||(d={});var f={};if((d.arrays||d.defaults)&&(f.input=[],f.output=[],f.attribute=[],f.node=[],f.opsetImport=[],f.attributeProto=[]),d.defaults&&(f.name="",f.docString="",f.domain=""),null!=l.name&&l.hasOwnProperty("name")&&(f.name=l.name),l.input&&l.input.length){f.input=[];for(var b=0;b<l.input.length;++b)f.input[b]=l.input[b]}if(l.output&&l.output.length)for(f.output=[],b=0;b<l.output.length;++b)f.output[b]=l.output[b];if(l.attribute&&l.attribute.length)for(f.attribute=[],b=0;b<l.attribute.length;++b)f.attribute[b]=l.attribute[b];if(l.node&&l.node.length)for(f.node=[],b=0;b<l.node.length;++b)f.node[b]=g.onnx.NodeProto.toObject(l.node[b],d);if(null!=l.docString&&l.hasOwnProperty("docString")&&(f.docString=l.docString),l.opsetImport&&l.opsetImport.length)for(f.opsetImport=[],b=0;b<l.opsetImport.length;++b)f.opsetImport[b]=g.onnx.OperatorSetIdProto.toObject(l.opsetImport[b],d);if(null!=l.domain&&l.hasOwnProperty("domain")&&(f.domain=l.domain),l.attributeProto&&l.attributeProto.length)for(f.attributeProto=[],b=0;b<l.attributeProto.length;++b)f.attributeProto[b]=g.onnx.AttributeProto.toObject(l.attributeProto[b],d);return f},h.prototype.toJSON=function(){return this.constructor.toObject(this,k.util.toJSONOptions)},h.getTypeUrl=function(l){return void 0===l&&(l="type.googleapis.com"),l+"/onnx.FunctionProto"},h}(),R),ge.exports=g},3474:(ge,E,$)=>{var F,N=(F=typeof document<"u"&&document.currentScript?document.currentScript.src:void 0,typeof __filename<"u"&&(F=F||__filename),function(R={}){function k(){return qe.buffer!=ot.buffer&&or(),ot}function S(){return qe.buffer!=ot.buffer&&or(),bt}function C(){return qe.buffer!=ot.buffer&&or(),wt}function v(){return qe.buffer!=ot.buffer&&or(),Mt}function g(){return qe.buffer!=ot.buffer&&or(),un}var h,l,d=R;d.ready=new Promise((q,ae)=>{h=q,l=ae});var f,b,x,D=Object.assign({},d),P="./this.program",L=(q,ae)=>{throw ae},B="object"==typeof window,U="function"==typeof importScripts,W="object"==typeof process&&"object"==typeof process.versions&&"string"==typeof process.versions.node,H=d.ENVIRONMENT_IS_PTHREAD||!1,re="";function ue(q){return d.locateFile?d.locateFile(q,re):re+q}if(W){var te=$(1384),se=$(908);let q;re=U?se.dirname(re)+"/":__dirname+"/",f=(ae,ye)=>(ae=ae.startsWith("file://")?new URL(ae):se.normalize(ae),te.readFileSync(ae,ye?void 0:"utf8")),x=ae=>((ae=f(ae,!0)).buffer||(ae=new Uint8Array(ae)),ae),b=(ae,ye,Ne,ze=!0)=>{ae=ae.startsWith("file://")?new URL(ae):se.normalize(ae),te.readFile(ae,ze?void 0:"utf8",(nt,Dt)=>{nt?Ne(nt):ye(ze?Dt.buffer:Dt)})},!d.thisProgram&&1<process.argv.length&&(P=process.argv[1].replace(/\\/g,"/")),process.argv.slice(2),L=(ae,ye)=>{throw process.exitCode=ae,ye},d.inspect=()=>"[Emscripten Module object]";try{q=$(9925)}catch(ae){throw console.error('The "worker_threads" module is not supported in this node.js build - perhaps a newer version is needed?'),ae}global.Worker=q.Worker}else(B||U)&&(U?re=self.location.href:typeof document<"u"&&document.currentScript&&(re=document.currentScript.src),F&&(re=F),re=0!==re.indexOf("blob:")?re.substr(0,re.replace(/[?#].*/,"").lastIndexOf("/")+1):"",W||(f=q=>{var ae=new XMLHttpRequest;return ae.open("GET",q,!1),ae.send(null),ae.responseText},U&&(x=q=>{var ae=new XMLHttpRequest;return ae.open("GET",q,!1),ae.responseType="arraybuffer",ae.send(null),new Uint8Array(ae.response)}),b=(q,ae,ye)=>{var Ne=new XMLHttpRequest;Ne.open("GET",q,!0),Ne.responseType="arraybuffer",Ne.onload=()=>{200==Ne.status||0==Ne.status&&Ne.response?ae(Ne.response):ye()},Ne.onerror=ye,Ne.send(null)}));W&&typeof performance>"u"&&(global.performance=$(6953).performance);var Y=console.log.bind(console),X=console.error.bind(console);W&&(Y=(...q)=>te.writeSync(1,q.join(" ")+"\n"),X=(...q)=>te.writeSync(2,q.join(" ")+"\n"));var we,K=d.print||Y,ie=d.printErr||X;Object.assign(d,D),D=null,d.thisProgram&&(P=d.thisProgram),d.quit&&(L=d.quit),d.wasmBinary&&(we=d.wasmBinary);var ce=d.noExitRuntime||!0;"object"!=typeof WebAssembly&&Ks("no native wasm support detected");var qe,Be,at,rt,ot,bt,wt,Mt,un,_n=!1;function or(){var q=qe.buffer;d.HEAP8=ot=new Int8Array(q),d.HEAP16=new Int16Array(q),d.HEAP32=wt=new Int32Array(q),d.HEAPU8=bt=new Uint8Array(q),d.HEAPU16=new Uint16Array(q),d.HEAPU32=Mt=new Uint32Array(q),d.HEAPF32=new Float32Array(q),d.HEAPF64=un=new Float64Array(q)}var Tr=d.INITIAL_MEMORY||16777216;if(5242880<=Tr||Ks("INITIAL_MEMORY should be larger than STACK_SIZE, was "+Tr+"! (STACK_SIZE=5242880)"),H)qe=d.wasmMemory;else if(d.wasmMemory)qe=d.wasmMemory;else if(!((qe=new WebAssembly.Memory({initial:Tr/65536,maximum:65536,shared:!0})).buffer instanceof SharedArrayBuffer))throw ie("requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag"),W&&ie("(on node you may need: --experimental-wasm-threads --experimental-wasm-bulk-memory and/or recent version)"),Error("bad memory");or(),Tr=qe.buffer.byteLength;var Cs,ki=[],Br=[],Ni=[],Cn=0;function Is(){return ce||0<Cn}var Pr,zr,Es=0,Oi=null,Ms=null;function no(){Es++,d.monitorRunDependencies&&d.monitorRunDependencies(Es)}function Ur(){if(Es--,d.monitorRunDependencies&&d.monitorRunDependencies(Es),0==Es&&(null!==Oi&&(clearInterval(Oi),Oi=null),Ms)){var q=Ms;Ms=null,q()}}function Ks(q){throw d.onAbort&&d.onAbort(q),ie(q="Aborted("+q+")"),_n=!0,rt=1,q=new WebAssembly.RuntimeError(q+". Build with -sASSERTIONS for more info."),l(q),q}function Wa(q){return q.startsWith("data:application/octet-stream;base64,")}function Dn(q){if(q==Pr&&we)return new Uint8Array(we);if(x)return x(q);throw"both async and sync fetching of the wasm failed"}function zu(q,ae,ye){return function(Ne){if(!we&&(B||U)){if("function"==typeof fetch&&!Ne.startsWith("file://"))return fetch(Ne,{credentials:"same-origin"}).then(ze=>{if(!ze.ok)throw"failed to load wasm binary file at '"+Ne+"'";return ze.arrayBuffer()}).catch(()=>Dn(Ne));if(b)return new Promise((ze,nt)=>{b(Ne,Dt=>ze(new Uint8Array(Dt)),nt)})}return Promise.resolve().then(()=>Dn(Ne))}(q).then(Ne=>WebAssembly.instantiate(Ne,ae)).then(Ne=>Ne).then(ye,Ne=>{ie("failed to asynchronously prepare wasm: "+Ne),Ks(Ne)})}function Ha(q){this.name="ExitStatus",this.message=`Program terminated with exit(${q})`,this.status=q}function El(q){q.terminate(),q.onmessage=()=>{}}function Uu(q){(q=ct.Fa[q])||Ks(),ct.fb(q)}function vn(q){var ae=ct.Za();if(!ae)return 6;ct.Ia.push(ae),ct.Fa[q.Ha]=ae,ae.Ha=q.Ha;var ye={cmd:"run",start_routine:q.gb,arg:q.Ya,pthread_ptr:q.Ha};return W&&ae.unref(),ae.postMessage(ye,q.mb),0}Wa(Pr="ort-wasm-threaded.wasm")||(Pr=ue(Pr));var ju=typeof TextDecoder<"u"?new TextDecoder("utf8"):void 0,Dl=(q,ae,ye)=>{var Ne=(ae>>>=0)+ye;for(ye=ae;q[ye]&&!(ye>=Ne);)++ye;if(16<ye-ae&&q.buffer&&ju)return ju.decode(q.buffer instanceof SharedArrayBuffer?q.slice(ae,ye):q.subarray(ae,ye));for(Ne="";ae<ye;){var ze=q[ae++];if(128&ze){var nt=63&q[ae++];if(192==(224&ze))Ne+=String.fromCharCode((31&ze)<<6|nt);else{var Dt=63&q[ae++];65536>(ze=224==(240&ze)?(15&ze)<<12|nt<<6|Dt:(7&ze)<<18|nt<<12|Dt<<6|63&q[ae++])?Ne+=String.fromCharCode(ze):(ze-=65536,Ne+=String.fromCharCode(55296|ze>>10,56320|1023&ze))}}else Ne+=String.fromCharCode(ze)}return Ne},An=(q,ae)=>(q>>>=0)?Dl(S(),q,ae):"";function Pn(q){if(H)return jn(1,1,q);rt=q,Is()||(ct.hb(),d.onExit&&d.onExit(q),_n=!0),L(q,new Ha(q))}var Al=q=>{if(rt=q,H)throw ed(q),"unwind";Pn(q)},ct={La:[],Ia:[],Ta:[],Fa:{},Pa:function(){H?ct.ab():ct.$a()},$a:function(){ki.unshift(()=>{no(),ct.bb(()=>Ur())})},ab:function(){ct.receiveObjectTransfer=ct.eb,ct.threadInitTLS=ct.Sa,ct.setExitStatus=ct.Ra,ce=!1},Ra:function(q){rt=q},rb:["$terminateWorker"],hb:function(){for(var q of ct.Ia)El(q);for(q of ct.La)El(q);ct.La=[],ct.Ia=[],ct.Fa=[]},fb:function(q){var ae=q.Ha;delete ct.Fa[ae],ct.La.push(q),ct.Ia.splice(ct.Ia.indexOf(q),1),q.Ha=0,od(ae)},eb:function(){},Sa:function(){ct.Ta.forEach(q=>q())},cb:q=>new Promise(ae=>{q.onmessage=ze=>{var nt=(ze=ze.data).cmd;if(ze.targetThread&&ze.targetThread!=fr()){var Dt=ct.Fa[ze.qb];Dt?Dt.postMessage(ze,ze.transferList):ie('Internal error! Worker sent a message "'+nt+'" to target pthread '+ze.targetThread+", but that thread no longer exists!")}else"checkMailbox"===nt?lp():"spawnThread"===nt?vn(ze):"cleanupThread"===nt?Uu(ze.thread):"killThread"===nt?(nt=ct.Fa[ze=ze.thread],delete ct.Fa[ze],El(nt),od(ze),ct.Ia.splice(ct.Ia.indexOf(nt),1),nt.Ha=0):"cancelThread"===nt?ct.Fa[ze.thread].postMessage({cmd:"cancel"}):"loaded"===nt?(q.loaded=!0,ae(q)):"alert"===nt?alert("Thread "+ze.threadId+": "+ze.text):"setimmediate"===ze.target?q.postMessage(ze):"callHandler"===nt?d[ze.handler](...ze.args):nt&&ie("worker sent an unknown command "+nt)},q.onerror=ze=>{throw ie("worker sent an error! "+ze.filename+":"+ze.lineno+": "+ze.message),ze},W&&(q.on("message",function(ze){q.onmessage({data:ze})}),q.on("error",function(ze){q.onerror(ze)}));var ye,Ne=[];for(ye of["onExit","onAbort","print","printErr"])d.hasOwnProperty(ye)&&Ne.push(ye);q.postMessage({cmd:"load",handlers:Ne,urlOrBlob:d.mainScriptUrlOrBlob||F,wasmMemory:qe,wasmModule:at})}),bb:function(q){q()},Xa:function(){var q=ue("ort-wasm-threaded.worker.js");q=new Worker(q),ct.La.push(q)},Za:function(){return 0==ct.La.length&&(ct.Xa(),ct.cb(ct.La[0])),ct.La.pop()}};d.PThread=ct;var Po=q=>{for(;0<q.length;)q.shift()(d)};function ed(q){if(H)return jn(2,0,q);Al(q)}d.establishStackSpace=function(){var q=fr(),ae=C()[q+52>>2>>>0];q=C()[q+56>>2>>>0],ry(ae,ae-q),Wu(ae)};var le=[];function Ie(q){this.Oa=q-24,this.Wa=function(ae){v()[this.Oa+4>>2>>>0]=ae},this.Va=function(ae){v()[this.Oa+8>>2>>>0]=ae},this.Pa=function(ae,ye){this.Ua(),this.Wa(ae),this.Va(ye)},this.Ua=function(){v()[this.Oa+16>>2>>>0]=0}}function Re(q,ae,ye,Ne){return H?jn(3,1,q,ae,ye,Ne):He(q,ae,ye,Ne)}function He(q,ae,ye,Ne){if(q>>>=0,ae>>>=0,ye>>>=0,Ne>>>=0,typeof SharedArrayBuffer>"u")return ie("Current environment does not support SharedArrayBuffer, pthreads are not available!"),6;var ze=[];return H&&0===ze.length?Re(q,ae,ye,Ne):(q={gb:ye,Ha:q,Ya:Ne,mb:ze},H?(q.ob="spawnThread",postMessage(q,ze),0):vn(q))}function lt(q,ae,ye){return H?jn(4,1,q,ae,ye):0}function Ot(q,ae){if(H)return jn(5,1,q,ae)}d.invokeEntryPoint=function(q,ae){var ye=le[q];ye||(q>=le.length&&(le.length=q+1),le[q]=ye=Cs.get(q)),q=ye(ae),Is()?ct.Ra(q):Gu(q)};var Gt=q=>{for(var ae=0,ye=0;ye<q.length;++ye){var Ne=q.charCodeAt(ye);127>=Ne?ae++:2047>=Ne?ae+=2:55296<=Ne&&57343>=Ne?(ae+=4,++ye):ae+=3}return ae},Fr=(q,ae,ye,Ne)=>{if(!(0<Ne))return 0;var ze=ye>>>=0;Ne=ye+Ne-1;for(var nt=0;nt<q.length;++nt){var Dt=q.charCodeAt(nt);if(55296<=Dt&&57343>=Dt&&(Dt=65536+((1023&Dt)<<10)|1023&q.charCodeAt(++nt)),127>=Dt){if(ye>=Ne)break;ae[ye++>>>0]=Dt}else{if(2047>=Dt){if(ye+1>=Ne)break;ae[ye++>>>0]=192|Dt>>6}else{if(65535>=Dt){if(ye+2>=Ne)break;ae[ye++>>>0]=224|Dt>>12}else{if(ye+3>=Ne)break;ae[ye++>>>0]=240|Dt>>18,ae[ye++>>>0]=128|Dt>>12&63}ae[ye++>>>0]=128|Dt>>6&63}ae[ye++>>>0]=128|63&Dt}}return ae[ye>>>0]=0,ye-ze},ds=(q,ae,ye)=>Fr(q,S(),ae,ye);function hs(q,ae){if(H)return jn(6,1,q,ae)}function ps(q,ae,ye){if(H)return jn(7,1,q,ae,ye)}function kl(q,ae,ye){return H?jn(8,1,q,ae,ye):0}function td(q,ae){if(H)return jn(9,1,q,ae)}function Ue(q,ae,ye){if(H)return jn(10,1,q,ae,ye)}function pn(q,ae,ye,Ne){if(H)return jn(11,1,q,ae,ye,Ne)}function Qn(q,ae,ye,Ne){if(H)return jn(12,1,q,ae,ye,Ne)}function Fo(q,ae,ye,Ne){if(H)return jn(13,1,q,ae,ye,Ne)}function nd(q){if(H)return jn(14,1,q)}function aa(q,ae){if(H)return jn(15,1,q,ae)}function Yg(q,ae,ye){if(H)return jn(16,1,q,ae,ye)}var tN=q=>{if(!_n)try{if(q(),!Is())try{H?Gu(rt):Al(rt)}catch(ae){ae instanceof Ha||"unwind"==ae||L(1,ae)}}catch(ae){ae instanceof Ha||"unwind"==ae||L(1,ae)}};function ap(q){q>>>=0,"function"==typeof Atomics.nb&&(Atomics.nb(C(),q>>2,q).value.then(lp),q+=128,Atomics.store(C(),q>>2,1))}function lp(){var q=fr();q&&(ap(q),tN(()=>gp()))}d.__emscripten_thread_mailbox_await=ap,d.checkMailbox=lp;var Nl=q=>q%4==0&&(q%100!=0||q%400==0),Uw=[0,31,60,91,121,152,182,213,244,274,305,335],jw=[0,31,59,90,120,151,181,212,243,273,304,334];function Gw(q,ae,ye,Ne,ze,nt,Dt,mr){return H?jn(17,1,q,ae,ye,Ne,ze,nt,Dt,mr):-52}function Ww(q,ae,ye,Ne,ze,nt,Dt){if(H)return jn(18,1,q,ae,ye,Ne,ze,nt,Dt)}var Hw=q=>{var ae=Gt(q)+1,ye=qa(ae);return ye&&ds(q,ye,ae),ye},up=q=>{var ae=ad();return q=q(),Wu(ae),q};function jn(q,ae){var ye=arguments.length-2,Ne=arguments;return up(()=>{for(var ze=yp(8*ye),nt=ze>>3,Dt=0;Dt<ye;Dt++){var mr=Ne[2+Dt];g()[nt+Dt>>>0]=mr}return ny(q,ye,ze,ae)})}var rd,sd=[],id={},Zg=()=>{if(!rd){var q,ae={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:("object"==typeof navigator&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:P||"./this.program"};for(q in id)void 0===id[q]?delete ae[q]:ae[q]=id[q];var ye=[];for(q in ae)ye.push(`${q}=${ae[q]}`);rd=ye}return rd};function cp(q,ae){if(H)return jn(19,1,q,ae);q>>>=0,ae>>>=0;var ye=0;return Zg().forEach(function(Ne,ze){var nt=ae+ye;for(ze=v()[q+4*ze>>2>>>0]=nt,nt=0;nt<Ne.length;++nt)k()[ze++>>0>>>0]=Ne.charCodeAt(nt);k()[ze>>0>>>0]=0,ye+=Ne.length+1}),0}function dp(q,ae){if(H)return jn(20,1,q,ae);q>>>=0,ae>>>=0;var ye=Zg();v()[q>>2>>>0]=ye.length;var Ne=0;return ye.forEach(function(ze){Ne+=ze.length+1}),v()[ae>>2>>>0]=Ne,0}function hp(q){return H?jn(21,1,q):52}function pp(q,ae,ye,Ne){return H?jn(22,1,q,ae,ye,Ne):52}function fs(q,ae,ye,Ne,ze){return H?jn(23,1,q,ae,ye,Ne,ze):70}var qw=[null,[],[]];function Qg(q,ae,ye,Ne){if(H)return jn(24,1,q,ae,ye,Ne);ae>>>=0,ye>>>=0,Ne>>>=0;for(var ze=0,nt=0;nt<ye;nt++){var Dt=v()[ae>>2>>>0],mr=v()[ae+4>>2>>>0];ae+=8;for(var Ps=0;Ps<mr;Ps++){var Ut=S()[Dt+Ps>>>0],ms=qw[q];0===Ut||10===Ut?((1===q?K:ie)(Dl(ms,0)),ms.length=0):ms.push(Ut)}ze+=mr}return v()[Ne>>2>>>0]=ze,0}var Jg=q=>(Jg=(()=>{if("object"==typeof crypto&&"function"==typeof crypto.getRandomValues)return Ne=>(Ne.set(crypto.getRandomValues(new Uint8Array(Ne.byteLength))),Ne);if(W)try{var ae=$(760);if(ae.randomFillSync)return Ne=>ae.randomFillSync(Ne);var ye=ae.randomBytes;return Ne=>(Ne.set(ye(Ne.byteLength)),Ne)}catch{}Ks("initRandomDevice")})())(q),ey=[31,29,31,30,31,30,31,31,30,31,30,31],fp=[31,28,31,30,31,30,31,31,30,31,30,31];function ty(q,ae,ye,Ne){function ze(Ge,Et,_t){for(Ge="number"==typeof Ge?Ge.toString():Ge||"";Ge.length<Et;)Ge=_t[0]+Ge;return Ge}function nt(Ge,Et){return ze(Ge,Et,"0")}function Dt(Ge,Et){function _t(ud){return 0>ud?-1:0<ud?1:0}var Lo;return 0===(Lo=_t(Ge.getFullYear()-Et.getFullYear()))&&0===(Lo=_t(Ge.getMonth()-Et.getMonth()))&&(Lo=_t(Ge.getDate()-Et.getDate())),Lo}function mr(Ge){switch(Ge.getDay()){case 0:return new Date(Ge.getFullYear()-1,11,29);case 1:return Ge;case 2:return new Date(Ge.getFullYear(),0,3);case 3:return new Date(Ge.getFullYear(),0,2);case 4:return new Date(Ge.getFullYear(),0,1);case 5:return new Date(Ge.getFullYear()-1,11,31);case 6:return new Date(Ge.getFullYear()-1,11,30)}}function Ps(Ge){var Et=Ge.Ja;for(Ge=new Date(new Date(Ge.Ka+1900,0,1).getTime());0<Et;){var _t=Ge.getMonth(),Lo=(Nl(Ge.getFullYear())?ey:fp)[_t];if(!(Et>Lo-Ge.getDate())){Ge.setDate(Ge.getDate()+Et);break}Et-=Lo-Ge.getDate()+1,Ge.setDate(1),11>_t?Ge.setMonth(_t+1):(Ge.setMonth(0),Ge.setFullYear(Ge.getFullYear()+1))}return _t=new Date(Ge.getFullYear()+1,0,4),Et=mr(new Date(Ge.getFullYear(),0,4)),_t=mr(_t),0>=Dt(Et,Ge)?0>=Dt(_t,Ge)?Ge.getFullYear()+1:Ge.getFullYear():Ge.getFullYear()-1}q>>>=0,ae>>>=0,ye>>>=0,Ne>>>=0;var Ut=C()[Ne+40>>2>>>0];for(var ms in Ne={kb:C()[Ne>>2>>>0],jb:C()[Ne+4>>2>>>0],Ma:C()[Ne+8>>2>>>0],Qa:C()[Ne+12>>2>>>0],Na:C()[Ne+16>>2>>>0],Ka:C()[Ne+20>>2>>>0],Ga:C()[Ne+24>>2>>>0],Ja:C()[Ne+28>>2>>>0],sb:C()[Ne+32>>2>>>0],ib:C()[Ne+36>>2>>>0],lb:Ut?An(Ut):""},ye=An(ye),Ut={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"})ye=ye.replace(new RegExp(ms,"g"),Ut[ms]);var Ge,Et,Sr="Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),ld="January February March April May June July August September October November December".split(" ");for(ms in Ut={"%a":Ge=>Sr[Ge.Ga].substring(0,3),"%A":Ge=>Sr[Ge.Ga],"%b":Ge=>ld[Ge.Na].substring(0,3),"%B":Ge=>ld[Ge.Na],"%C":Ge=>nt((Ge.Ka+1900)/100|0,2),"%d":Ge=>nt(Ge.Qa,2),"%e":Ge=>ze(Ge.Qa,2," "),"%g":Ge=>Ps(Ge).toString().substring(2),"%G":Ge=>Ps(Ge),"%H":Ge=>nt(Ge.Ma,2),"%I":Ge=>(0==(Ge=Ge.Ma)?Ge=12:12<Ge&&(Ge-=12),nt(Ge,2)),"%j":Ge=>{for(var Et=0,_t=0;_t<=Ge.Na-1;Et+=(Nl(Ge.Ka+1900)?ey:fp)[_t++]);return nt(Ge.Qa+Et,3)},"%m":Ge=>nt(Ge.Na+1,2),"%M":Ge=>nt(Ge.jb,2),"%n":()=>"\n","%p":Ge=>0<=Ge.Ma&&12>Ge.Ma?"AM":"PM","%S":Ge=>nt(Ge.kb,2),"%t":()=>"\t","%u":Ge=>Ge.Ga||7,"%U":Ge=>nt(Math.floor((Ge.Ja+7-Ge.Ga)/7),2),"%V":Ge=>{var Et=Math.floor((Ge.Ja+7-(Ge.Ga+6)%7)/7);if(2>=(Ge.Ga+371-Ge.Ja-2)%7&&Et++,Et)53==Et&&(4==(_t=(Ge.Ga+371-Ge.Ja)%7)||3==_t&&Nl(Ge.Ka)||(Et=1));else{Et=52;var _t=(Ge.Ga+7-Ge.Ja-1)%7;(4==_t||5==_t&&Nl(Ge.Ka%400-1))&&Et++}return nt(Et,2)},"%w":Ge=>Ge.Ga,"%W":Ge=>nt(Math.floor((Ge.Ja+7-(Ge.Ga+6)%7)/7),2),"%y":Ge=>(Ge.Ka+1900).toString().substring(2),"%Y":Ge=>Ge.Ka+1900,"%z":Ge=>(0<=(Ge=Ge.ib)?"+":"-")+("0000"+((Ge=Math.abs(Ge)/60)/60*100+Ge%60)).slice(-4),"%Z":Ge=>Ge.lb,"%%":()=>"%"},ye=ye.replace(/%%/g,"\0\0"),Ut)ye.includes(ms)&&(ye=ye.replace(new RegExp(ms,"g"),Ut[ms](Ne)));return Ge=ye=ye.replace(/\0\0/g,"%"),Et=Array(Gt(Ge)+1),Fr(Ge,Et,0,Et.length),(ms=Et).length>ae?0:(((q,ae)=>{k().set(q,ae>>>0)})(ms,q),ms.length-1)}ct.Pa();var $o=[null,Pn,ed,Re,lt,Ot,hs,ps,kl,td,Ue,pn,Qn,Fo,nd,aa,Yg,Gw,Ww,cp,dp,hp,pp,fs,Qg],Xw={b:function(q,ae,ye){throw new Ie(q>>>=0).Pa(ae>>>0,ye>>>0),q},N:function(q){Ri(q>>>0,!U,1,!B,131072,!1),ct.Sa()},k:function(q){q>>>=0,H?postMessage({cmd:"cleanupThread",thread:q}):Uu(q)},I:He,h:lt,T:Ot,E:hs,G:ps,U:kl,R:td,J:Ue,Q:pn,o:Qn,F:Fo,C:nd,S:aa,D:Yg,q:()=>!0,A:function(q,ae){(q>>>=0)==ae>>>0?setTimeout(()=>lp()):H?postMessage({targetThread:q,cmd:"checkMailbox"}):(q=ct.Fa[q])&&q.postMessage({cmd:"checkMailbox"})},L:function(){return-1},M:ap,p:function(q){W&&ct.Fa[q>>>0].ref()},t:function(q,ae,ye){q=ae+2097152>>>0<4194305-!!q?(q>>>0)+4294967296*ae:NaN,ye>>>=0,q=new Date(1e3*q),C()[ye>>2>>>0]=q.getUTCSeconds(),C()[ye+4>>2>>>0]=q.getUTCMinutes(),C()[ye+8>>2>>>0]=q.getUTCHours(),C()[ye+12>>2>>>0]=q.getUTCDate(),C()[ye+16>>2>>>0]=q.getUTCMonth(),C()[ye+20>>2>>>0]=q.getUTCFullYear()-1900,C()[ye+24>>2>>>0]=q.getUTCDay(),q=(q.getTime()-Date.UTC(q.getUTCFullYear(),0,1,0,0,0,0))/864e5|0,C()[ye+28>>2>>>0]=q},u:function(q,ae,ye){q=ae+2097152>>>0<4194305-!!q?(q>>>0)+4294967296*ae:NaN,ye>>>=0,q=new Date(1e3*q),C()[ye>>2>>>0]=q.getSeconds(),C()[ye+4>>2>>>0]=q.getMinutes(),C()[ye+8>>2>>>0]=q.getHours(),C()[ye+12>>2>>>0]=q.getDate(),C()[ye+16>>2>>>0]=q.getMonth(),C()[ye+20>>2>>>0]=q.getFullYear()-1900,C()[ye+24>>2>>>0]=q.getDay(),ae=(Nl(q.getFullYear())?Uw:jw)[q.getMonth()]+q.getDate()-1|0,C()[ye+28>>2>>>0]=ae,C()[ye+36>>2>>>0]=-60*q.getTimezoneOffset(),ae=new Date(q.getFullYear(),6,1).getTimezoneOffset();var Ne=new Date(q.getFullYear(),0,1).getTimezoneOffset();q=0|(ae!=Ne&&q.getTimezoneOffset()==Math.min(Ne,ae)),C()[ye+32>>2>>>0]=q},v:function(q){q>>>=0;var ae=new Date(C()[q+20>>2>>>0]+1900,C()[q+16>>2>>>0],C()[q+12>>2>>>0],C()[q+8>>2>>>0],C()[q+4>>2>>>0],C()[q>>2>>>0],0),ye=C()[q+32>>2>>>0],Ne=ae.getTimezoneOffset(),ze=new Date(ae.getFullYear(),6,1).getTimezoneOffset(),nt=new Date(ae.getFullYear(),0,1).getTimezoneOffset(),Dt=Math.min(nt,ze);return 0>ye?C()[q+32>>2>>>0]=+(ze!=nt&&Dt==Ne):0<ye!=(Dt==Ne)&&(ze=Math.max(nt,ze),ae.setTime(ae.getTime()+6e4*((0<ye?Dt:ze)-Ne))),C()[q+24>>2>>>0]=ae.getDay(),ye=(Nl(ae.getFullYear())?Uw:jw)[ae.getMonth()]+ae.getDate()-1|0,C()[q+28>>2>>>0]=ye,C()[q>>2>>>0]=ae.getSeconds(),C()[q+4>>2>>>0]=ae.getMinutes(),C()[q+8>>2>>>0]=ae.getHours(),C()[q+12>>2>>>0]=ae.getDate(),C()[q+16>>2>>>0]=ae.getMonth(),C()[q+20>>2>>>0]=ae.getYear(),q=ae.getTime()/1e3,Ol((zr=q,1<=+Math.abs(zr)?0<zr?+Math.floor(zr/4294967296)>>>0:~~+Math.ceil((zr-+(~~zr>>>0))/4294967296)>>>0:0)),q>>>0},r:Gw,s:Ww,z:function(q,ae,ye){function Ne(Ut){return(Ut=Ut.toTimeString().match(/\(([A-Za-z ]+)\)$/))?Ut[1]:"GMT"}q>>>=0,ae>>>=0,ye>>>=0;var ze=(new Date).getFullYear(),nt=new Date(ze,0,1),Dt=new Date(ze,6,1);ze=nt.getTimezoneOffset();var mr=Dt.getTimezoneOffset(),Ps=Math.max(ze,mr);v()[q>>2>>>0]=60*Ps,C()[ae>>2>>>0]=+(ze!=mr),q=Ne(nt),ae=Ne(Dt),q=Hw(q),ae=Hw(ae),mr<ze?(v()[ye>>2>>>0]=q,v()[ye+4>>2>>>0]=ae):(v()[ye>>2>>>0]=ae,v()[ye+4>>2>>>0]=q)},c:()=>{Ks("")},l:function(){},i:function(){return Date.now()},V:()=>{throw Cn+=1,"unwind"},B:function(){return 4294901760},e:()=>performance.timeOrigin+performance.now(),f:function(){return W?$(3993).cpus().length:navigator.hardwareConcurrency},K:function(q,ae,ye,Ne){for(ct.pb=ae>>>0,sd.length=ye,ae=Ne>>>0>>3,Ne=0;Ne<ye;Ne++)sd[Ne]=g()[ae+Ne>>>0];return $o[q].apply(null,sd)},y:function(q){q>>>=0;var ae=S().length;if(q<=ae||4294901760<q)return!1;for(var ye=1;4>=ye;ye*=2){var Ne=ae*(1+.2/ye);Ne=Math.min(Ne,q+100663296);var ze=Math;Ne=Math.max(q,Ne);e:{ze=ze.min.call(ze,4294901760,Ne+(65536-Ne%65536)%65536)-qe.buffer.byteLength+65535>>>16;try{qe.grow(ze),or();var nt=1;break e}catch{}nt=void 0}if(nt)return!0}return!1},O:cp,P:dp,j:Al,g:hp,n:pp,w:fs,m:Qg,x:function(q,ae){return q>>>=0,ae>>>=0,Jg(S().subarray(q>>>0,q+ae>>>0)),0},a:qe||d.wasmMemory,H:ty,d:function(q,ae,ye,Ne){return ty(q>>>0,ae>>>0,ye>>>0,Ne>>>0)}};(function(){function q(ye,Ne){return ze=ye=ye.exports,nt=mr=>()=>mr()>>>0,Dt=mr=>Ps=>mr(Ps)>>>0,(ze=Object.assign({},ze)).__errno_location=nt(ze.__errno_location),ze.pthread_self=nt(ze.pthread_self),ze.malloc=Dt(ze.malloc),ze.stackSave=nt(ze.stackSave),ze.stackAlloc=Dt(ze.stackAlloc),Be=ye=ze,ct.Ta.push(Be.sa),Cs=Be.ta,Br.unshift(Be.W),at=Ne,Ur(),ye;var ze,nt,Dt}var ye,Ne,ze,ae={a:Xw};if(no(),d.instantiateWasm)try{return d.instantiateWasm(ae,q)}catch(ye){ie("Module.instantiateWasm callback failed with error: "+ye),l(ye)}(ye=ae,Ne=function(ye){q(ye.instance,ye.module)},ze=Pr,we||"function"!=typeof WebAssembly.instantiateStreaming||Wa(ze)||ze.startsWith("file://")||W||"function"!=typeof fetch?zu(ze,ye,Ne):fetch(ze,{credentials:"same-origin"}).then(nt=>WebAssembly.instantiateStreaming(nt,ye).then(Ne,function(Dt){return ie("wasm streaming compile failed: "+Dt),ie("falling back to ArrayBuffer instantiation"),zu(ze,ye,Ne)}))).catch(l)})(),d._OrtInit=(q,ae)=>(d._OrtInit=Be.X)(q,ae),d._OrtGetLastError=(q,ae)=>(d._OrtGetLastError=Be.Y)(q,ae),d._OrtCreateSessionOptions=(q,ae,ye,Ne,ze,nt,Dt,mr,Ps,Ut)=>(d._OrtCreateSessionOptions=Be.Z)(q,ae,ye,Ne,ze,nt,Dt,mr,Ps,Ut),d._OrtAppendExecutionProvider=(q,ae)=>(d._OrtAppendExecutionProvider=Be._)(q,ae),d._OrtAddSessionConfigEntry=(q,ae,ye)=>(d._OrtAddSessionConfigEntry=Be.$)(q,ae,ye),d._OrtReleaseSessionOptions=q=>(d._OrtReleaseSessionOptions=Be.aa)(q),d._OrtCreateSession=(q,ae,ye)=>(d._OrtCreateSession=Be.ba)(q,ae,ye),d._OrtReleaseSession=q=>(d._OrtReleaseSession=Be.ca)(q),d._OrtGetInputOutputCount=(q,ae,ye)=>(d._OrtGetInputOutputCount=Be.da)(q,ae,ye),d._OrtGetInputName=(q,ae)=>(d._OrtGetInputName=Be.ea)(q,ae),d._OrtGetOutputName=(q,ae)=>(d._OrtGetOutputName=Be.fa)(q,ae),d._OrtFree=q=>(d._OrtFree=Be.ga)(q),d._OrtCreateTensor=(q,ae,ye,Ne,ze)=>(d._OrtCreateTensor=Be.ha)(q,ae,ye,Ne,ze),d._OrtGetTensorData=(q,ae,ye,Ne,ze)=>(d._OrtGetTensorData=Be.ia)(q,ae,ye,Ne,ze),d._OrtReleaseTensor=q=>(d._OrtReleaseTensor=Be.ja)(q),d._OrtCreateRunOptions=(q,ae,ye,Ne)=>(d._OrtCreateRunOptions=Be.ka)(q,ae,ye,Ne),d._OrtAddRunConfigEntry=(q,ae,ye)=>(d._OrtAddRunConfigEntry=Be.la)(q,ae,ye),d._OrtReleaseRunOptions=q=>(d._OrtReleaseRunOptions=Be.ma)(q),d._OrtRun=(q,ae,ye,Ne,ze,nt,Dt,mr)=>(d._OrtRun=Be.na)(q,ae,ye,Ne,ze,nt,Dt,mr),d._OrtEndProfiling=q=>(d._OrtEndProfiling=Be.oa)(q);var fr=d._pthread_self=()=>(fr=d._pthread_self=Be.pa)(),qa=d._malloc=q=>(qa=d._malloc=Be.qa)(q);d._free=q=>(d._free=Be.ra)(q),d.__emscripten_tls_init=()=>(d.__emscripten_tls_init=Be.sa)();var Ri=d.__emscripten_thread_init=(q,ae,ye,Ne,ze,nt)=>(Ri=d.__emscripten_thread_init=Be.ua)(q,ae,ye,Ne,ze,nt);d.__emscripten_thread_crashed=()=>(d.__emscripten_thread_crashed=Be.va)();var mp,ny=(q,ae,ye,Ne)=>(ny=Be.wa)(q,ae,ye,Ne),od=q=>(od=Be.xa)(q),Gu=d.__emscripten_thread_exit=q=>(Gu=d.__emscripten_thread_exit=Be.ya)(q),gp=d.__emscripten_check_mailbox=()=>(gp=d.__emscripten_check_mailbox=Be.za)(),Ol=q=>(Ol=Be.Aa)(q),ry=(q,ae)=>(ry=Be.Ba)(q,ae),ad=()=>(ad=Be.Ca)(),Wu=q=>(Wu=Be.Da)(q),yp=q=>(yp=Be.Ea)(q);function sy(){function q(){if(!mp&&(mp=!0,d.calledRun=!0,!_n)&&(H||Po(Br),h(d),d.onRuntimeInitialized&&d.onRuntimeInitialized(),!H)){if(d.postRun)for("function"==typeof d.postRun&&(d.postRun=[d.postRun]);d.postRun.length;){var ae=d.postRun.shift();Ni.unshift(ae)}Po(Ni)}}if(!(0<Es))if(H)h(d),H||Po(Br),startWorker(d);else{if(d.preRun)for("function"==typeof d.preRun&&(d.preRun=[d.preRun]);d.preRun.length;)ki.unshift(d.preRun.shift());Po(ki),0<Es||(d.setStatus?(d.setStatus("Running..."),setTimeout(function(){setTimeout(function(){d.setStatus("")},1),q()},1)):q())}}if(d.keepRuntimeAlive=Is,d.wasmMemory=qe,d.stackAlloc=yp,d.stackSave=ad,d.stackRestore=Wu,d.UTF8ToString=An,d.stringToUTF8=ds,d.lengthBytesUTF8=Gt,d.ExitStatus=Ha,d.PThread=ct,Ms=function q(){mp||sy(),mp||(Ms=q)},d.preInit)for("function"==typeof d.preInit&&(d.preInit=[d.preInit]);0<d.preInit.length;)d.preInit.pop()();return sy(),R.ready});ge.exports=N},932:(ge,E,$)=>{var F,N=(F=typeof document<"u"&&document.currentScript?document.currentScript.src:void 0,typeof __filename<"u"&&(F=F||__filename),function(R={}){var k,S,C=R;C.ready=new Promise((le,Ie)=>{k=le,S=Ie});var v,g,h,l=Object.assign({},C),d="./this.program",f=(le,Ie)=>{throw Ie},b="object"==typeof window,x="function"==typeof importScripts,D="object"==typeof process&&"object"==typeof process.versions&&"string"==typeof process.versions.node,P="";if(D){var L=$(1384),B=$(908);P=x?B.dirname(P)+"/":__dirname+"/",v=(le,Ie)=>(le=le.startsWith("file://")?new URL(le):B.normalize(le),L.readFileSync(le,Ie?void 0:"utf8")),h=le=>((le=v(le,!0)).buffer||(le=new Uint8Array(le)),le),g=(le,Ie,Re,He=!0)=>{le=le.startsWith("file://")?new URL(le):B.normalize(le),L.readFile(le,He?void 0:"utf8",(lt,Ot)=>{lt?Re(lt):Ie(He?Ot.buffer:Ot)})},!C.thisProgram&&1<process.argv.length&&(d=process.argv[1].replace(/\\/g,"/")),process.argv.slice(2),f=(le,Ie)=>{throw process.exitCode=le,Ie},C.inspect=()=>"[Emscripten Module object]"}else(b||x)&&(x?P=self.location.href:typeof document<"u"&&document.currentScript&&(P=document.currentScript.src),F&&(P=F),P=0!==P.indexOf("blob:")?P.substr(0,P.replace(/[?#].*/,"").lastIndexOf("/")+1):"",v=le=>{var Ie=new XMLHttpRequest;return Ie.open("GET",le,!1),Ie.send(null),Ie.responseText},x&&(h=le=>{var Ie=new XMLHttpRequest;return Ie.open("GET",le,!1),Ie.responseType="arraybuffer",Ie.send(null),new Uint8Array(Ie.response)}),g=(le,Ie,Re)=>{var He=new XMLHttpRequest;He.open("GET",le,!0),He.responseType="arraybuffer",He.onload=()=>{200==He.status||0==He.status&&He.response?Ie(He.response):Re()},He.onerror=Re,He.send(null)});var U,W=C.print||console.log.bind(console),H=C.printErr||console.error.bind(console);Object.assign(C,l),l=null,C.thisProgram&&(d=C.thisProgram),C.quit&&(f=C.quit),C.wasmBinary&&(U=C.wasmBinary);var re=C.noExitRuntime||!0;"object"!=typeof WebAssembly&&un("no native wasm support detected");var ue,te,se,Y,X,we,K=!1;function ie(){var le=ue.buffer;C.HEAP8=se=new Int8Array(le),C.HEAP16=new Int16Array(le),C.HEAP32=X=new Int32Array(le),C.HEAPU8=Y=new Uint8Array(le),C.HEAPU16=new Uint16Array(le),C.HEAPU32=we=new Uint32Array(le),C.HEAPF32=new Float32Array(le),C.HEAPF64=new Float64Array(le)}var ce=[],qe=[],Be=[];function at(){var le=C.preRun.shift();ce.unshift(le)}var rt,ot,bt=0,wt=null,Mt=null;function un(le){throw C.onAbort&&C.onAbort(le),H(le="Aborted("+le+")"),K=!0,le=new WebAssembly.RuntimeError(le+". Build with -sASSERTIONS for more info."),S(le),le}function _n(le){return le.startsWith("data:application/octet-stream;base64,")}if(!_n(rt="ort-wasm.wasm")){var or=rt;rt=C.locateFile?C.locateFile(or,P):P+or}function Tr(le){if(le==rt&&U)return new Uint8Array(U);if(h)return h(le);throw"both async and sync fetching of the wasm failed"}function Cs(le,Ie,Re){return function(He){if(!U&&(b||x)){if("function"==typeof fetch&&!He.startsWith("file://"))return fetch(He,{credentials:"same-origin"}).then(lt=>{if(!lt.ok)throw"failed to load wasm binary file at '"+He+"'";return lt.arrayBuffer()}).catch(()=>Tr(He));if(g)return new Promise((lt,Ot)=>{g(He,Gt=>lt(new Uint8Array(Gt)),Ot)})}return Promise.resolve().then(()=>Tr(He))}(le).then(He=>WebAssembly.instantiate(He,Ie)).then(He=>He).then(Re,He=>{H("failed to asynchronously prepare wasm: "+He),un(He)})}function ki(le){this.name="ExitStatus",this.message=`Program terminated with exit(${le})`,this.status=le}var Br=le=>{for(;0<le.length;)le.shift()(C)};function Ni(le){this.qa=le-24,this.va=function(Ie){we[this.qa+4>>2>>>0]=Ie},this.ua=function(Ie){we[this.qa+8>>2>>>0]=Ie},this.sa=function(Ie,Re){this.ta(),this.va(Ie),this.ua(Re)},this.ta=function(){we[this.qa+16>>2>>>0]=0}}var Cn,Is=typeof TextDecoder<"u"?new TextDecoder("utf8"):void 0,Pr=(le,Ie,Re)=>{var He=(Ie>>>=0)+Re;for(Re=Ie;le[Re]&&!(Re>=He);)++Re;if(16<Re-Ie&&le.buffer&&Is)return Is.decode(le.subarray(Ie,Re));for(He="";Ie<Re;){var lt=le[Ie++];if(128&lt){var Ot=63&le[Ie++];if(192==(224&lt))He+=String.fromCharCode((31&lt)<<6|Ot);else{var Gt=63&le[Ie++];65536>(lt=224==(240&lt)?(15&lt)<<12|Ot<<6|Gt:(7&lt)<<18|Ot<<12|Gt<<6|63&le[Ie++])?He+=String.fromCharCode(lt):(lt-=65536,He+=String.fromCharCode(55296|lt>>10,56320|1023&lt))}}else He+=String.fromCharCode(lt)}return He},zr=(le,Ie)=>(le>>>=0)?Pr(Y,le,Ie):"",Es=le=>{for(var Ie=0,Re=0;Re<le.length;++Re){var He=le.charCodeAt(Re);127>=He?Ie++:2047>=He?Ie+=2:55296<=He&&57343>=He?(Ie+=4,++Re):Ie+=3}return Ie},Oi=(le,Ie,Re,He)=>{if(!(0<He))return 0;var lt=Re>>>=0;He=Re+He-1;for(var Ot=0;Ot<le.length;++Ot){var Gt=le.charCodeAt(Ot);if(55296<=Gt&&57343>=Gt&&(Gt=65536+((1023&Gt)<<10)|1023&le.charCodeAt(++Ot)),127>=Gt){if(Re>=He)break;Ie[Re++>>>0]=Gt}else{if(2047>=Gt){if(Re+1>=He)break;Ie[Re++>>>0]=192|Gt>>6}else{if(65535>=Gt){if(Re+2>=He)break;Ie[Re++>>>0]=224|Gt>>12}else{if(Re+3>=He)break;Ie[Re++>>>0]=240|Gt>>18,Ie[Re++>>>0]=128|Gt>>12&63}Ie[Re++>>>0]=128|Gt>>6&63}Ie[Re++>>>0]=128|63&Gt}}return Ie[Re>>>0]=0,Re-lt},Ms=le=>le%4==0&&(le%100!=0||le%400==0),no=[0,31,60,91,121,152,182,213,244,274,305,335],Ur=[0,31,59,90,120,151,181,212,243,273,304,334],Ks=le=>{var Ie=Es(le)+1,Re=Dl(Ie);return Re&&Oi(le,Y,Re,Ie),Re},Wa={},Dn=()=>{if(!Cn){var le,Ie={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:("object"==typeof navigator&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:d||"./this.program"};for(le in Wa)void 0===Wa[le]?delete Ie[le]:Ie[le]=Wa[le];var Re=[];for(le in Ie)Re.push(`${le}=${Ie[le]}`);Cn=Re}return Cn},zu=[null,[],[]],Ha=le=>(Ha=(()=>{if("object"==typeof crypto&&"function"==typeof crypto.getRandomValues)return He=>crypto.getRandomValues(He);if(D)try{var Ie=$(760);if(Ie.randomFillSync)return He=>Ie.randomFillSync(He);var Re=Ie.randomBytes;return He=>(He.set(Re(He.byteLength)),He)}catch{}un("initRandomDevice")})())(le),El=[31,29,31,30,31,30,31,31,30,31,30,31],Uu=[31,28,31,30,31,30,31,31,30,31,30,31];function vn(le,Ie,Re,He){function lt(Ue,pn,Qn){for(Ue="number"==typeof Ue?Ue.toString():Ue||"";Ue.length<pn;)Ue=Qn[0]+Ue;return Ue}function Ot(Ue,pn){return lt(Ue,pn,"0")}function Gt(Ue,pn){function Qn(nd){return 0>nd?-1:0<nd?1:0}var Fo;return 0===(Fo=Qn(Ue.getFullYear()-pn.getFullYear()))&&0===(Fo=Qn(Ue.getMonth()-pn.getMonth()))&&(Fo=Qn(Ue.getDate()-pn.getDate())),Fo}function Fr(Ue){switch(Ue.getDay()){case 0:return new Date(Ue.getFullYear()-1,11,29);case 1:return Ue;case 2:return new Date(Ue.getFullYear(),0,3);case 3:return new Date(Ue.getFullYear(),0,2);case 4:return new Date(Ue.getFullYear(),0,1);case 5:return new Date(Ue.getFullYear()-1,11,31);case 6:return new Date(Ue.getFullYear()-1,11,30)}}function ds(Ue){var pn=Ue.ma;for(Ue=new Date(new Date(Ue.na+1900,0,1).getTime());0<pn;){var Qn=Ue.getMonth(),Fo=(Ms(Ue.getFullYear())?El:Uu)[Qn];if(!(pn>Fo-Ue.getDate())){Ue.setDate(Ue.getDate()+pn);break}pn-=Fo-Ue.getDate()+1,Ue.setDate(1),11>Qn?Ue.setMonth(Qn+1):(Ue.setMonth(0),Ue.setFullYear(Ue.getFullYear()+1))}return Qn=new Date(Ue.getFullYear()+1,0,4),pn=Fr(new Date(Ue.getFullYear(),0,4)),Qn=Fr(Qn),0>=Gt(pn,Ue)?0>=Gt(Qn,Ue)?Ue.getFullYear()+1:Ue.getFullYear():Ue.getFullYear()-1}le>>>=0,Ie>>>=0,Re>>>=0;var hs=X[40+(He>>>=0)>>2>>>0];for(var ps in He={ya:X[He>>2>>>0],xa:X[He+4>>2>>>0],oa:X[He+8>>2>>>0],ra:X[He+12>>2>>>0],pa:X[He+16>>2>>>0],na:X[He+20>>2>>>0],ha:X[He+24>>2>>>0],ma:X[He+28>>2>>>0],Aa:X[He+32>>2>>>0],wa:X[He+36>>2>>>0],za:hs?zr(hs):""},Re=zr(Re),hs={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"})Re=Re.replace(new RegExp(ps,"g"),hs[ps]);var Ue,pn,kl="Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),td="January February March April May June July August September October November December".split(" ");for(ps in hs={"%a":Ue=>kl[Ue.ha].substring(0,3),"%A":Ue=>kl[Ue.ha],"%b":Ue=>td[Ue.pa].substring(0,3),"%B":Ue=>td[Ue.pa],"%C":Ue=>Ot((Ue.na+1900)/100|0,2),"%d":Ue=>Ot(Ue.ra,2),"%e":Ue=>lt(Ue.ra,2," "),"%g":Ue=>ds(Ue).toString().substring(2),"%G":Ue=>ds(Ue),"%H":Ue=>Ot(Ue.oa,2),"%I":Ue=>(0==(Ue=Ue.oa)?Ue=12:12<Ue&&(Ue-=12),Ot(Ue,2)),"%j":Ue=>{for(var pn=0,Qn=0;Qn<=Ue.pa-1;pn+=(Ms(Ue.na+1900)?El:Uu)[Qn++]);return Ot(Ue.ra+pn,3)},"%m":Ue=>Ot(Ue.pa+1,2),"%M":Ue=>Ot(Ue.xa,2),"%n":()=>"\n","%p":Ue=>0<=Ue.oa&&12>Ue.oa?"AM":"PM","%S":Ue=>Ot(Ue.ya,2),"%t":()=>"\t","%u":Ue=>Ue.ha||7,"%U":Ue=>Ot(Math.floor((Ue.ma+7-Ue.ha)/7),2),"%V":Ue=>{var pn=Math.floor((Ue.ma+7-(Ue.ha+6)%7)/7);if(2>=(Ue.ha+371-Ue.ma-2)%7&&pn++,pn)53==pn&&(4==(Qn=(Ue.ha+371-Ue.ma)%7)||3==Qn&&Ms(Ue.na)||(pn=1));else{pn=52;var Qn=(Ue.ha+7-Ue.ma-1)%7;(4==Qn||5==Qn&&Ms(Ue.na%400-1))&&pn++}return Ot(pn,2)},"%w":Ue=>Ue.ha,"%W":Ue=>Ot(Math.floor((Ue.ma+7-(Ue.ha+6)%7)/7),2),"%y":Ue=>(Ue.na+1900).toString().substring(2),"%Y":Ue=>Ue.na+1900,"%z":Ue=>(0<=(Ue=Ue.wa)?"+":"-")+("0000"+((Ue=Math.abs(Ue)/60)/60*100+Ue%60)).slice(-4),"%Z":Ue=>Ue.za,"%%":()=>"%"},Re=Re.replace(/%%/g,"\0\0"),hs)Re.includes(ps)&&(Re=Re.replace(new RegExp(ps,"g"),hs[ps](He)));return Ue=Re=Re.replace(/\0\0/g,"%"),pn=Array(Es(Ue)+1),Oi(Ue,pn,0,pn.length),(ps=pn).length>Ie?0:(se.set(ps,le>>>0),ps.length-1)}var ju={a:function(le,Ie,Re){throw new Ni(le>>>=0).sa(Ie>>>0,Re>>>0),le},e:function(){return 0},I:function(){},y:function(){},A:function(){},K:function(){return 0},G:function(){},B:function(){},F:function(){},g:function(){},z:function(){},w:function(){},H:function(){},x:function(){},k:()=>!0,n:function(le,Ie,Re){le=Ie+2097152>>>0<4194305-!!le?(le>>>0)+4294967296*Ie:NaN,Re>>>=0,le=new Date(1e3*le),X[Re>>2>>>0]=le.getUTCSeconds(),X[Re+4>>2>>>0]=le.getUTCMinutes(),X[Re+8>>2>>>0]=le.getUTCHours(),X[Re+12>>2>>>0]=le.getUTCDate(),X[Re+16>>2>>>0]=le.getUTCMonth(),X[Re+20>>2>>>0]=le.getUTCFullYear()-1900,X[Re+24>>2>>>0]=le.getUTCDay(),X[Re+28>>2>>>0]=(le.getTime()-Date.UTC(le.getUTCFullYear(),0,1,0,0,0,0))/864e5|0},o:function(le,Ie,Re){le=Ie+2097152>>>0<4194305-!!le?(le>>>0)+4294967296*Ie:NaN,Re>>>=0,le=new Date(1e3*le),X[Re>>2>>>0]=le.getSeconds(),X[Re+4>>2>>>0]=le.getMinutes(),X[Re+8>>2>>>0]=le.getHours(),X[Re+12>>2>>>0]=le.getDate(),X[Re+16>>2>>>0]=le.getMonth(),X[Re+20>>2>>>0]=le.getFullYear()-1900,X[Re+24>>2>>>0]=le.getDay(),X[Re+28>>2>>>0]=(Ms(le.getFullYear())?no:Ur)[le.getMonth()]+le.getDate()-1|0,X[Re+36>>2>>>0]=-60*le.getTimezoneOffset(),Ie=new Date(le.getFullYear(),6,1).getTimezoneOffset();var He=new Date(le.getFullYear(),0,1).getTimezoneOffset();X[Re+32>>2>>>0]=0|(Ie!=He&&le.getTimezoneOffset()==Math.min(He,Ie))},p:function(le){le>>>=0;var Ie=new Date(X[le+20>>2>>>0]+1900,X[le+16>>2>>>0],X[le+12>>2>>>0],X[le+8>>2>>>0],X[le+4>>2>>>0],X[le>>2>>>0],0),Re=X[le+32>>2>>>0],He=Ie.getTimezoneOffset(),lt=new Date(Ie.getFullYear(),6,1).getTimezoneOffset(),Ot=new Date(Ie.getFullYear(),0,1).getTimezoneOffset(),Gt=Math.min(Ot,lt);return 0>Re?X[le+32>>2>>>0]=+(lt!=Ot&&Gt==He):0<Re!=(Gt==He)&&(lt=Math.max(Ot,lt),Ie.setTime(Ie.getTime()+6e4*((0<Re?Gt:lt)-He))),X[le+24>>2>>>0]=Ie.getDay(),X[le+28>>2>>>0]=(Ms(Ie.getFullYear())?no:Ur)[Ie.getMonth()]+Ie.getDate()-1|0,X[le>>2>>>0]=Ie.getSeconds(),X[le+4>>2>>>0]=Ie.getMinutes(),X[le+8>>2>>>0]=Ie.getHours(),X[le+12>>2>>>0]=Ie.getDate(),X[le+16>>2>>>0]=Ie.getMonth(),X[le+20>>2>>>0]=Ie.getYear(),le=Ie.getTime()/1e3,Pn((ot=le,1<=+Math.abs(ot)?0<ot?+Math.floor(ot/4294967296)>>>0:~~+Math.ceil((ot-+(~~ot>>>0))/4294967296)>>>0:0)),le>>>0},l:function(){return-52},m:function(){},u:function(le,Ie,Re){function He(ds){return(ds=ds.toTimeString().match(/\(([A-Za-z ]+)\)$/))?ds[1]:"GMT"}Re>>>=0;var lt=(new Date).getFullYear(),Ot=new Date(lt,0,1),Gt=new Date(lt,6,1);lt=Ot.getTimezoneOffset();var Fr=Gt.getTimezoneOffset();we[le>>>0>>2>>>0]=60*Math.max(lt,Fr),X[Ie>>>0>>2>>>0]=+(lt!=Fr),le=He(Ot),Ie=He(Gt),le=Ks(le),Ie=Ks(Ie),Fr<lt?(we[Re>>2>>>0]=le,we[Re+4>>2>>>0]=Ie):(we[Re>>2>>>0]=Ie,we[Re+4>>2>>>0]=le)},d:()=>{un("")},h:function(){return Date.now()},v:function(){return 4294901760},b:()=>performance.now(),J:function(le,Ie,Re){return Y.copyWithin(le>>>0>>>0,(Ie>>>=0)>>>0,Ie+(Re>>>0)>>>0)},t:function(le){var Ie=Y.length;if(4294901760<(le>>>=0))return!1;for(var Re=1;4>=Re;Re*=2){var He=Ie*(1+.2/Re);He=Math.min(He,le+100663296);var lt=Math;He=Math.max(le,He);e:{lt=lt.min.call(lt,4294901760,He+(65536-He%65536)%65536)-ue.buffer.byteLength+65535>>>16;try{ue.grow(lt),ie();var Ot=1;break e}catch{}Ot=void 0}if(Ot)return!0}return!1},D:function(le,Ie){le>>>=0,Ie>>>=0;var Re=0;return Dn().forEach(function(He,lt){var Ot=Ie+Re;for(lt=we[le+4*lt>>2>>>0]=Ot,Ot=0;Ot<He.length;++Ot)se[lt++>>0>>>0]=He.charCodeAt(Ot);se[lt>>0>>>0]=0,Re+=He.length+1}),0},E:function(le,Ie){le>>>=0,Ie>>>=0;var Re=Dn();we[le>>2>>>0]=Re.length;var He=0;return Re.forEach(function(lt){He+=lt.length+1}),we[Ie>>2>>>0]=He,0},s:le=>{re||(C.onExit&&C.onExit(le),K=!0),f(le,new ki(le))},f:()=>52,j:function(){return 52},q:function(){return 70},i:function(le,Ie,Re,He){Ie>>>=0,Re>>>=0,He>>>=0;for(var lt=0,Ot=0;Ot<Re;Ot++){var Gt=we[Ie>>2>>>0],Fr=we[Ie+4>>2>>>0];Ie+=8;for(var ds=0;ds<Fr;ds++){var hs=Y[Gt+ds>>>0],ps=zu[le];0===hs||10===hs?((1===le?W:H)(Pr(ps,0)),ps.length=0):ps.push(hs)}lt+=Fr}return we[He>>2>>>0]=lt,0},r:function(le,Ie){return Ha(Y.subarray((le>>>=0)>>>0,le+(Ie>>>0)>>>0)),0},C:vn,c:function(le,Ie,Re,He){return vn(le>>>0,Ie>>>0,Re>>>0,He>>>0)}};(function(){function le(Re){if(lt=Re=Re.exports,Ot=Fr=>()=>Fr()>>>0,Gt=Fr=>ds=>Fr(ds)>>>0,(lt=Object.assign({},lt)).__errno_location=Ot(lt.__errno_location),lt.malloc=Gt(lt.malloc),lt.stackSave=Ot(lt.stackSave),lt.stackAlloc=Gt(lt.stackAlloc),te=Re=lt,ue=te.L,ie(),qe.unshift(te.M),bt--,C.monitorRunDependencies&&C.monitorRunDependencies(bt),0==bt&&(null!==wt&&(clearInterval(wt),wt=null),Mt)){var He=Mt;Mt=null,He()}var lt,Ot,Gt;return Re}var Re,He,lt,Ie={a:ju};if(bt++,C.monitorRunDependencies&&C.monitorRunDependencies(bt),C.instantiateWasm)try{return C.instantiateWasm(Ie,le)}catch(Re){H("Module.instantiateWasm callback failed with error: "+Re),S(Re)}(Re=Ie,He=function(Re){le(Re.instance)},lt=rt,U||"function"!=typeof WebAssembly.instantiateStreaming||_n(lt)||lt.startsWith("file://")||D||"function"!=typeof fetch?Cs(lt,Re,He):fetch(lt,{credentials:"same-origin"}).then(Ot=>WebAssembly.instantiateStreaming(Ot,Re).then(He,function(Gt){return H("wasm streaming compile failed: "+Gt),H("falling back to ArrayBuffer instantiation"),Cs(lt,Re,He)}))).catch(S)})(),C._OrtInit=(le,Ie)=>(C._OrtInit=te.N)(le,Ie),C._OrtGetLastError=(le,Ie)=>(C._OrtGetLastError=te.O)(le,Ie),C._OrtCreateSessionOptions=(le,Ie,Re,He,lt,Ot,Gt,Fr,ds,hs)=>(C._OrtCreateSessionOptions=te.P)(le,Ie,Re,He,lt,Ot,Gt,Fr,ds,hs),C._OrtAppendExecutionProvider=(le,Ie)=>(C._OrtAppendExecutionProvider=te.Q)(le,Ie),C._OrtAddSessionConfigEntry=(le,Ie,Re)=>(C._OrtAddSessionConfigEntry=te.R)(le,Ie,Re),C._OrtReleaseSessionOptions=le=>(C._OrtReleaseSessionOptions=te.S)(le),C._OrtCreateSession=(le,Ie,Re)=>(C._OrtCreateSession=te.T)(le,Ie,Re),C._OrtReleaseSession=le=>(C._OrtReleaseSession=te.U)(le),C._OrtGetInputOutputCount=(le,Ie,Re)=>(C._OrtGetInputOutputCount=te.V)(le,Ie,Re),C._OrtGetInputName=(le,Ie)=>(C._OrtGetInputName=te.W)(le,Ie),C._OrtGetOutputName=(le,Ie)=>(C._OrtGetOutputName=te.X)(le,Ie),C._OrtFree=le=>(C._OrtFree=te.Y)(le),C._OrtCreateTensor=(le,Ie,Re,He,lt)=>(C._OrtCreateTensor=te.Z)(le,Ie,Re,He,lt),C._OrtGetTensorData=(le,Ie,Re,He,lt)=>(C._OrtGetTensorData=te._)(le,Ie,Re,He,lt),C._OrtReleaseTensor=le=>(C._OrtReleaseTensor=te.$)(le),C._OrtCreateRunOptions=(le,Ie,Re,He)=>(C._OrtCreateRunOptions=te.aa)(le,Ie,Re,He),C._OrtAddRunConfigEntry=(le,Ie,Re)=>(C._OrtAddRunConfigEntry=te.ba)(le,Ie,Re),C._OrtReleaseRunOptions=le=>(C._OrtReleaseRunOptions=te.ca)(le),C._OrtRun=(le,Ie,Re,He,lt,Ot,Gt,Fr)=>(C._OrtRun=te.da)(le,Ie,Re,He,lt,Ot,Gt,Fr),C._OrtEndProfiling=le=>(C._OrtEndProfiling=te.ea)(le);var Dl=C._malloc=le=>(Dl=C._malloc=te.fa)(le);C._free=le=>(C._free=te.ga)(le);var An,Pn=le=>(Pn=te.ia)(le),Al=()=>(Al=te.ja)(),ct=le=>(ct=te.ka)(le),Po=le=>(Po=te.la)(le);function ed(){function le(){if(!An&&(An=!0,C.calledRun=!0,!K)){if(Br(qe),k(C),C.onRuntimeInitialized&&C.onRuntimeInitialized(),C.postRun)for("function"==typeof C.postRun&&(C.postRun=[C.postRun]);C.postRun.length;){var Ie=C.postRun.shift();Be.unshift(Ie)}Br(Be)}}if(!(0<bt)){if(C.preRun)for("function"==typeof C.preRun&&(C.preRun=[C.preRun]);C.preRun.length;)at();Br(ce),0<bt||(C.setStatus?(C.setStatus("Running..."),setTimeout(function(){setTimeout(function(){C.setStatus("")},1),le()},1)):le())}}if(C.stackAlloc=Po,C.stackSave=Al,C.stackRestore=ct,C.UTF8ToString=zr,C.stringToUTF8=(le,Ie,Re)=>Oi(le,Y,Ie,Re),C.lengthBytesUTF8=Es,Mt=function le(){An||ed(),An||(Mt=le)},C.preInit)for("function"==typeof C.preInit&&(C.preInit=[C.preInit]);0<C.preInit.length;)C.preInit.pop()();return ed(),R.ready});ge.exports=N},4537:ge=>{"use strict";ge.exports=function(E,$){for(var F=new Array(arguments.length-1),N=0,R=2,k=!0;R<arguments.length;)F[N++]=arguments[R++];return new Promise(function(S,C){F[N]=function(v){if(k)if(k=!1,v)C(v);else{for(var g=new Array(arguments.length-1),h=0;h<g.length;)g[h++]=arguments[h];S.apply(null,g)}};try{E.apply($||null,F)}catch(v){k&&(k=!1,C(v))}})}},7419:(ge,E)=>{"use strict";var $=E;$.length=function(S){var C=S.length;if(!C)return 0;for(var v=0;--C%4>1&&"="===S.charAt(C);)++v;return Math.ceil(3*S.length)/4-v};for(var F=new Array(64),N=new Array(123),R=0;R<64;)N[F[R]=R<26?R+65:R<52?R+71:R<62?R-4:R-59|43]=R++;$.encode=function(S,C,v){for(var g,h=null,l=[],d=0,f=0;C<v;){var b=S[C++];switch(f){case 0:l[d++]=F[b>>2],g=(3&b)<<4,f=1;break;case 1:l[d++]=F[g|b>>4],g=(15&b)<<2,f=2;break;case 2:l[d++]=F[g|b>>6],l[d++]=F[63&b],f=0}d>8191&&((h||(h=[])).push(String.fromCharCode.apply(String,l)),d=0)}return f&&(l[d++]=F[g],l[d++]=61,1===f&&(l[d++]=61)),h?(d&&h.push(String.fromCharCode.apply(String,l.slice(0,d))),h.join("")):String.fromCharCode.apply(String,l.slice(0,d))};var k="invalid encoding";$.decode=function(S,C,v){for(var g,h=v,l=0,d=0;d<S.length;){var f=S.charCodeAt(d++);if(61===f&&l>1)break;if(void 0===(f=N[f]))throw Error(k);switch(l){case 0:g=f,l=1;break;case 1:C[v++]=g<<2|(48&f)>>4,g=f,l=2;break;case 2:C[v++]=(15&g)<<4|(60&f)>>2,g=f,l=3;break;case 3:C[v++]=(3&g)<<6|f,l=0}}if(1===l)throw Error(k);return v-h},$.test=function(S){return/^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(S)}},9211:ge=>{"use strict";function E(){this._listeners={}}ge.exports=E,E.prototype.on=function($,F,N){return(this._listeners[$]||(this._listeners[$]=[])).push({fn:F,ctx:N||this}),this},E.prototype.off=function($,F){if(void 0===$)this._listeners={};else if(void 0===F)this._listeners[$]=[];else for(var N=this._listeners[$],R=0;R<N.length;)N[R].fn===F?N.splice(R,1):++R;return this},E.prototype.emit=function($){var F=this._listeners[$];if(F){for(var N=[],R=1;R<arguments.length;)N.push(arguments[R++]);for(R=0;R<F.length;)F[R].fn.apply(F[R++].ctx,N)}return this}},945:ge=>{"use strict";function E(k){return typeof Float32Array<"u"?function(){var S=new Float32Array([-0]),C=new Uint8Array(S.buffer),v=128===C[3];function g(f,b,x){S[0]=f,b[x]=C[0],b[x+1]=C[1],b[x+2]=C[2],b[x+3]=C[3]}function h(f,b,x){S[0]=f,b[x]=C[3],b[x+1]=C[2],b[x+2]=C[1],b[x+3]=C[0]}function l(f,b){return C[0]=f[b],C[1]=f[b+1],C[2]=f[b+2],C[3]=f[b+3],S[0]}function d(f,b){return C[3]=f[b],C[2]=f[b+1],C[1]=f[b+2],C[0]=f[b+3],S[0]}k.writeFloatLE=v?g:h,k.writeFloatBE=v?h:g,k.readFloatLE=v?l:d,k.readFloatBE=v?d:l}():function(){function S(v,g,h,l){var d=g<0?1:0;if(d&&(g=-g),0===g)v(1/g>0?0:2147483648,h,l);else if(isNaN(g))v(2143289344,h,l);else if(g>34028234663852886e22)v((d<<31|2139095040)>>>0,h,l);else if(g<11754943508222875e-54)v((d<<31|Math.round(g/1401298464324817e-60))>>>0,h,l);else{var f=Math.floor(Math.log(g)/Math.LN2);v((d<<31|f+127<<23|8388607&Math.round(g*Math.pow(2,-f)*8388608))>>>0,h,l)}}function C(v,g,h){var l=v(g,h),d=2*(l>>31)+1,f=l>>>23&255,b=8388607&l;return 255===f?b?NaN:d*(1/0):0===f?1401298464324817e-60*d*b:d*Math.pow(2,f-150)*(b+8388608)}k.writeFloatLE=S.bind(null,$),k.writeFloatBE=S.bind(null,F),k.readFloatLE=C.bind(null,N),k.readFloatBE=C.bind(null,R)}(),typeof Float64Array<"u"?function(){var S=new Float64Array([-0]),C=new Uint8Array(S.buffer),v=128===C[7];function g(f,b,x){S[0]=f,b[x]=C[0],b[x+1]=C[1],b[x+2]=C[2],b[x+3]=C[3],b[x+4]=C[4],b[x+5]=C[5],b[x+6]=C[6],b[x+7]=C[7]}function h(f,b,x){S[0]=f,b[x]=C[7],b[x+1]=C[6],b[x+2]=C[5],b[x+3]=C[4],b[x+4]=C[3],b[x+5]=C[2],b[x+6]=C[1],b[x+7]=C[0]}function l(f,b){return C[0]=f[b],C[1]=f[b+1],C[2]=f[b+2],C[3]=f[b+3],C[4]=f[b+4],C[5]=f[b+5],C[6]=f[b+6],C[7]=f[b+7],S[0]}function d(f,b){return C[7]=f[b],C[6]=f[b+1],C[5]=f[b+2],C[4]=f[b+3],C[3]=f[b+4],C[2]=f[b+5],C[1]=f[b+6],C[0]=f[b+7],S[0]}k.writeDoubleLE=v?g:h,k.writeDoubleBE=v?h:g,k.readDoubleLE=v?l:d,k.readDoubleBE=v?d:l}():function(){function S(v,g,h,l,d,f){var b=l<0?1:0;if(b&&(l=-l),0===l)v(0,d,f+g),v(1/l>0?0:2147483648,d,f+h);else if(isNaN(l))v(0,d,f+g),v(2146959360,d,f+h);else if(l>17976931348623157e292)v(0,d,f+g),v((b<<31|2146435072)>>>0,d,f+h);else{var x;if(l<22250738585072014e-324)v((x=l/5e-324)>>>0,d,f+g),v((b<<31|x/4294967296)>>>0,d,f+h);else{var D=Math.floor(Math.log(l)/Math.LN2);1024===D&&(D=1023),v(4503599627370496*(x=l*Math.pow(2,-D))>>>0,d,f+g),v((b<<31|D+1023<<20|1048576*x&1048575)>>>0,d,f+h)}}}function C(v,g,h,l,d){var f=v(l,d+g),b=v(l,d+h),x=2*(b>>31)+1,D=b>>>20&2047,P=4294967296*(1048575&b)+f;return 2047===D?P?NaN:x*(1/0):0===D?5e-324*x*P:x*Math.pow(2,D-1075)*(P+4503599627370496)}k.writeDoubleLE=S.bind(null,$,0,4),k.writeDoubleBE=S.bind(null,F,4,0),k.readDoubleLE=C.bind(null,N,0,4),k.readDoubleBE=C.bind(null,R,4,0)}(),k}function $(k,S,C){S[C]=255&k,S[C+1]=k>>>8&255,S[C+2]=k>>>16&255,S[C+3]=k>>>24}function F(k,S,C){S[C]=k>>>24,S[C+1]=k>>>16&255,S[C+2]=k>>>8&255,S[C+3]=255&k}function N(k,S){return(k[S]|k[S+1]<<8|k[S+2]<<16|k[S+3]<<24)>>>0}function R(k,S){return(k[S]<<24|k[S+1]<<16|k[S+2]<<8|k[S+3])>>>0}ge.exports=E(E)},7199:module=>{"use strict";function inquire(moduleName){try{var mod=eval("quire".replace(/^/,"re"))(moduleName);if(mod&&(mod.length||Object.keys(mod).length))return mod}catch(ge){}return null}module.exports=inquire},6662:ge=>{"use strict";ge.exports=function(E,$,F){var N=F||8192,R=N>>>1,k=null,S=N;return function(C){if(C<1||C>R)return E(C);S+C>N&&(k=E(N),S=0);var v=$.call(k,S,S+=C);return 7&S&&(S=1+(7|S)),v}}},4997:(ge,E)=>{"use strict";var $=E;$.length=function(F){for(var N=0,R=0,k=0;k<F.length;++k)(R=F.charCodeAt(k))<128?N+=1:R<2048?N+=2:55296==(64512&R)&&56320==(64512&F.charCodeAt(k+1))?(++k,N+=4):N+=3;return N},$.read=function(F,N,R){if(R-N<1)return"";for(var k,S=null,C=[],v=0;N<R;)(k=F[N++])<128?C[v++]=k:k>191&&k<224?C[v++]=(31&k)<<6|63&F[N++]:k>239&&k<365?(k=((7&k)<<18|(63&F[N++])<<12|(63&F[N++])<<6|63&F[N++])-65536,C[v++]=55296+(k>>10),C[v++]=56320+(1023&k)):C[v++]=(15&k)<<12|(63&F[N++])<<6|63&F[N++],v>8191&&((S||(S=[])).push(String.fromCharCode.apply(String,C)),v=0);return S?(v&&S.push(String.fromCharCode.apply(String,C.slice(0,v))),S.join("")):String.fromCharCode.apply(String,C.slice(0,v))},$.write=function(F,N,R){for(var k,S,C=R,v=0;v<F.length;++v)(k=F.charCodeAt(v))<128?N[R++]=k:k<2048?(N[R++]=k>>6|192,N[R++]=63&k|128):55296==(64512&k)&&56320==(64512&(S=F.charCodeAt(v+1)))?(++v,N[R++]=(k=65536+((1023&k)<<10)+(1023&S))>>18|240,N[R++]=k>>12&63|128,N[R++]=k>>6&63|128,N[R++]=63&k|128):(N[R++]=k>>12|224,N[R++]=k>>6&63|128,N[R++]=63&k|128);return R-C}},3442:(ge,E)=>{"use strict";E.__esModule=!0;var $=function(){function F(N){if(!N)throw new TypeError("Invalid argument; `value` has no value.");this.value=F.EMPTY,N&&F.isGuid(N)&&(this.value=N)}return F.isGuid=function(N){var R=N.toString();return N&&(N instanceof F||F.validator.test(R))},F.create=function(){return new F([F.gen(2),F.gen(1),F.gen(1),F.gen(1),F.gen(3)].join("-"))},F.createEmpty=function(){return new F("emptyguid")},F.parse=function(N){return new F(N)},F.raw=function(){return[F.gen(2),F.gen(1),F.gen(1),F.gen(1),F.gen(3)].join("-")},F.gen=function(N){for(var R="",k=0;k<N;k++)R+=(65536*(1+Math.random())|0).toString(16).substring(1);return R},F.prototype.equals=function(N){return F.isGuid(N)&&this.value===N.toString()},F.prototype.isEmpty=function(){return this.value===F.EMPTY},F.prototype.toString=function(){return this.value},F.prototype.toJSON=function(){return{value:this.value}},F.validator=new RegExp("^[a-z0-9]{8}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{12}$","i"),F.EMPTY="00000000-0000-0000-0000-000000000000",F}();E.Guid=$},2100:(ge,E,$)=>{"use strict";ge.exports=$(9482)},9482:(ge,E,$)=>{"use strict";var F=E;function N(){F.util._configure(),F.Writer._configure(F.BufferWriter),F.Reader._configure(F.BufferReader)}F.build="minimal",F.Writer=$(1173),F.BufferWriter=$(3155),F.Reader=$(1408),F.BufferReader=$(593),F.util=$(9693),F.rpc=$(5994),F.roots=$(5054),F.configure=N,N()},1408:(ge,E,$)=>{"use strict";ge.exports=C;var F,N=$(9693),R=N.LongBits,k=N.utf8;function S(b,x){return RangeError("index out of range: "+b.pos+" + "+(x||1)+" > "+b.len)}function C(b){this.buf=b,this.pos=0,this.len=b.length}var v,g=typeof Uint8Array<"u"?function(b){if(b instanceof Uint8Array||Array.isArray(b))return new C(b);throw Error("illegal buffer")}:function(b){if(Array.isArray(b))return new C(b);throw Error("illegal buffer")},h=function(){return N.Buffer?function(b){return(C.create=function(x){return N.Buffer.isBuffer(x)?new F(x):g(x)})(b)}:g};function l(){var b=new R(0,0),x=0;if(!(this.len-this.pos>4)){for(;x<3;++x){if(this.pos>=this.len)throw S(this);if(b.lo=(b.lo|(127&this.buf[this.pos])<<7*x)>>>0,this.buf[this.pos++]<128)return b}return b.lo=(b.lo|(127&this.buf[this.pos++])<<7*x)>>>0,b}for(;x<4;++x)if(b.lo=(b.lo|(127&this.buf[this.pos])<<7*x)>>>0,this.buf[this.pos++]<128)return b;if(b.lo=(b.lo|(127&this.buf[this.pos])<<28)>>>0,b.hi=(b.hi|(127&this.buf[this.pos])>>4)>>>0,this.buf[this.pos++]<128)return b;if(x=0,this.len-this.pos>4){for(;x<5;++x)if(b.hi=(b.hi|(127&this.buf[this.pos])<<7*x+3)>>>0,this.buf[this.pos++]<128)return b}else for(;x<5;++x){if(this.pos>=this.len)throw S(this);if(b.hi=(b.hi|(127&this.buf[this.pos])<<7*x+3)>>>0,this.buf[this.pos++]<128)return b}throw Error("invalid varint encoding")}function d(b,x){return(b[x-4]|b[x-3]<<8|b[x-2]<<16|b[x-1]<<24)>>>0}function f(){if(this.pos+8>this.len)throw S(this,8);return new R(d(this.buf,this.pos+=4),d(this.buf,this.pos+=4))}C.create=h(),C.prototype._slice=N.Array.prototype.subarray||N.Array.prototype.slice,C.prototype.uint32=(v=4294967295,function(){if(v=(127&this.buf[this.pos])>>>0,this.buf[this.pos++]<128||(v=(v|(127&this.buf[this.pos])<<7)>>>0,this.buf[this.pos++]<128)||(v=(v|(127&this.buf[this.pos])<<14)>>>0,this.buf[this.pos++]<128)||(v=(v|(127&this.buf[this.pos])<<21)>>>0,this.buf[this.pos++]<128)||(v=(v|(15&this.buf[this.pos])<<28)>>>0,this.buf[this.pos++]<128))return v;if((this.pos+=5)>this.len)throw this.pos=this.len,S(this,10);return v}),C.prototype.int32=function(){return 0|this.uint32()},C.prototype.sint32=function(){var b=this.uint32();return b>>>1^-(1&b)|0},C.prototype.bool=function(){return 0!==this.uint32()},C.prototype.fixed32=function(){if(this.pos+4>this.len)throw S(this,4);return d(this.buf,this.pos+=4)},C.prototype.sfixed32=function(){if(this.pos+4>this.len)throw S(this,4);return 0|d(this.buf,this.pos+=4)},C.prototype.float=function(){if(this.pos+4>this.len)throw S(this,4);var b=N.float.readFloatLE(this.buf,this.pos);return this.pos+=4,b},C.prototype.double=function(){if(this.pos+8>this.len)throw S(this,4);var b=N.float.readDoubleLE(this.buf,this.pos);return this.pos+=8,b},C.prototype.bytes=function(){var b=this.uint32(),x=this.pos,D=this.pos+b;if(D>this.len)throw S(this,b);return this.pos+=b,Array.isArray(this.buf)?this.buf.slice(x,D):x===D?new this.buf.constructor(0):this._slice.call(this.buf,x,D)},C.prototype.string=function(){var b=this.bytes();return k.read(b,0,b.length)},C.prototype.skip=function(b){if("number"==typeof b){if(this.pos+b>this.len)throw S(this,b);this.pos+=b}else do{if(this.pos>=this.len)throw S(this)}while(128&this.buf[this.pos++]);return this},C.prototype.skipType=function(b){switch(b){case 0:this.skip();break;case 1:this.skip(8);break;case 2:this.skip(this.uint32());break;case 3:for(;4!=(b=7&this.uint32());)this.skipType(b);break;case 5:this.skip(4);break;default:throw Error("invalid wire type "+b+" at offset "+this.pos)}return this},C._configure=function(b){F=b,C.create=h(),F._configure();var x=N.Long?"toLong":"toNumber";N.merge(C.prototype,{int64:function(){return l.call(this)[x](!1)},uint64:function(){return l.call(this)[x](!0)},sint64:function(){return l.call(this).zzDecode()[x](!1)},fixed64:function(){return f.call(this)[x](!0)},sfixed64:function(){return f.call(this)[x](!1)}})}},593:(ge,E,$)=>{"use strict";ge.exports=R;var F=$(1408);(R.prototype=Object.create(F.prototype)).constructor=R;var N=$(9693);function R(k){F.call(this,k)}R._configure=function(){N.Buffer&&(R.prototype._slice=N.Buffer.prototype.slice)},R.prototype.string=function(){var k=this.uint32();return this.buf.utf8Slice?this.buf.utf8Slice(this.pos,this.pos=Math.min(this.pos+k,this.len)):this.buf.toString("utf-8",this.pos,this.pos=Math.min(this.pos+k,this.len))},R._configure()},5054:ge=>{"use strict";ge.exports={}},5994:(ge,E,$)=>{"use strict";E.Service=$(7948)},7948:(ge,E,$)=>{"use strict";ge.exports=N;var F=$(9693);function N(R,k,S){if("function"!=typeof R)throw TypeError("rpcImpl must be a function");F.EventEmitter.call(this),this.rpcImpl=R,this.requestDelimited=!!k,this.responseDelimited=!!S}(N.prototype=Object.create(F.EventEmitter.prototype)).constructor=N,N.prototype.rpcCall=function R(k,S,C,v,g){if(!v)throw TypeError("request must be specified");var h=this;if(!g)return F.asPromise(R,h,k,S,C,v);if(h.rpcImpl)try{return h.rpcImpl(k,S[h.requestDelimited?"encodeDelimited":"encode"](v).finish(),function(l,d){if(l)return h.emit("error",l,k),g(l);if(null!==d){if(!(d instanceof C))try{d=C[h.responseDelimited?"decodeDelimited":"decode"](d)}catch(f){return h.emit("error",f,k),g(f)}return h.emit("data",d,k),g(null,d)}h.end(!0)})}catch(l){return h.emit("error",l,k),void setTimeout(function(){g(l)},0)}else setTimeout(function(){g(Error("already ended"))},0)},N.prototype.end=function(R){return this.rpcImpl&&(R||this.rpcImpl(null,null,null),this.rpcImpl=null,this.emit("end").off()),this}},1945:(ge,E,$)=>{"use strict";ge.exports=N;var F=$(9693);function N(C,v){this.lo=C>>>0,this.hi=v>>>0}var R=N.zero=new N(0,0);R.toNumber=function(){return 0},R.zzEncode=R.zzDecode=function(){return this},R.length=function(){return 1};var k=N.zeroHash="\0\0\0\0\0\0\0\0";N.fromNumber=function(C){if(0===C)return R;var v=C<0;v&&(C=-C);var g=C>>>0,h=(C-g)/4294967296>>>0;return v&&(h=~h>>>0,g=~g>>>0,++g>4294967295&&(g=0,++h>4294967295&&(h=0))),new N(g,h)},N.from=function(C){if("number"==typeof C)return N.fromNumber(C);if(F.isString(C)){if(!F.Long)return N.fromNumber(parseInt(C,10));C=F.Long.fromString(C)}return C.low||C.high?new N(C.low>>>0,C.high>>>0):R},N.prototype.toNumber=function(C){if(!C&&this.hi>>>31){var v=1+~this.lo>>>0,g=~this.hi>>>0;return v||(g=g+1>>>0),-(v+4294967296*g)}return this.lo+4294967296*this.hi},N.prototype.toLong=function(C){return F.Long?new F.Long(0|this.lo,0|this.hi,!!C):{low:0|this.lo,high:0|this.hi,unsigned:!!C}};var S=String.prototype.charCodeAt;N.fromHash=function(C){return C===k?R:new N((S.call(C,0)|S.call(C,1)<<8|S.call(C,2)<<16|S.call(C,3)<<24)>>>0,(S.call(C,4)|S.call(C,5)<<8|S.call(C,6)<<16|S.call(C,7)<<24)>>>0)},N.prototype.toHash=function(){return String.fromCharCode(255&this.lo,this.lo>>>8&255,this.lo>>>16&255,this.lo>>>24,255&this.hi,this.hi>>>8&255,this.hi>>>16&255,this.hi>>>24)},N.prototype.zzEncode=function(){var C=this.hi>>31;return this.hi=((this.hi<<1|this.lo>>>31)^C)>>>0,this.lo=(this.lo<<1^C)>>>0,this},N.prototype.zzDecode=function(){var C=-(1&this.lo);return this.lo=((this.lo>>>1|this.hi<<31)^C)>>>0,this.hi=(this.hi>>>1^C)>>>0,this},N.prototype.length=function(){var C=this.lo,v=(this.lo>>>28|this.hi<<4)>>>0,g=this.hi>>>24;return 0===g?0===v?C<16384?C<128?1:2:C<2097152?3:4:v<16384?v<128?5:6:v<2097152?7:8:g<128?9:10}},9693:function(ge,E,$){"use strict";var F=E;function N(k,S,C){for(var v=Object.keys(S),g=0;g<v.length;++g)void 0!==k[v[g]]&&C||(k[v[g]]=S[v[g]]);return k}function R(k){function S(C,v){if(!(this instanceof S))return new S(C,v);Object.defineProperty(this,"message",{get:function(){return C}}),Error.captureStackTrace?Error.captureStackTrace(this,S):Object.defineProperty(this,"stack",{value:(new Error).stack||""}),v&&N(this,v)}return S.prototype=Object.create(Error.prototype,{constructor:{value:S,writable:!0,enumerable:!1,configurable:!0},name:{get:function(){return k},set:void 0,enumerable:!1,configurable:!0},toString:{value:function(){return this.name+": "+this.message},writable:!0,enumerable:!1,configurable:!0}}),S}F.asPromise=$(4537),F.base64=$(7419),F.EventEmitter=$(9211),F.float=$(945),F.inquire=$(7199),F.utf8=$(4997),F.pool=$(6662),F.LongBits=$(1945),F.isNode=!!(typeof global<"u"&&global&&global.process&&global.process.versions&&global.process.versions.node),F.global=F.isNode&&global||typeof window<"u"&&window||typeof self<"u"&&self||this,F.emptyArray=Object.freeze?Object.freeze([]):[],F.emptyObject=Object.freeze?Object.freeze({}):{},F.isInteger=Number.isInteger||function(k){return"number"==typeof k&&isFinite(k)&&Math.floor(k)===k},F.isString=function(k){return"string"==typeof k||k instanceof String},F.isObject=function(k){return k&&"object"==typeof k},F.isset=F.isSet=function(k,S){var C=k[S];return!(null==C||!k.hasOwnProperty(S))&&("object"!=typeof C||(Array.isArray(C)?C.length:Object.keys(C).length)>0)},F.Buffer=function(){try{var k=F.inquire("buffer").Buffer;return k.prototype.utf8Write?k:null}catch{return null}}(),F._Buffer_from=null,F._Buffer_allocUnsafe=null,F.newBuffer=function(k){return"number"==typeof k?F.Buffer?F._Buffer_allocUnsafe(k):new F.Array(k):F.Buffer?F._Buffer_from(k):typeof Uint8Array>"u"?k:new Uint8Array(k)},F.Array=typeof Uint8Array<"u"?Uint8Array:Array,F.Long=F.global.dcodeIO&&F.global.dcodeIO.Long||F.global.Long||F.inquire("long"),F.key2Re=/^true|false|0|1$/,F.key32Re=/^-?(?:0|[1-9][0-9]*)$/,F.key64Re=/^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/,F.longToHash=function(k){return k?F.LongBits.from(k).toHash():F.LongBits.zeroHash},F.longFromHash=function(k,S){var C=F.LongBits.fromHash(k);return F.Long?F.Long.fromBits(C.lo,C.hi,S):C.toNumber(!!S)},F.merge=N,F.lcFirst=function(k){return k.charAt(0).toLowerCase()+k.substring(1)},F.newError=R,F.ProtocolError=R("ProtocolError"),F.oneOfGetter=function(k){for(var S={},C=0;C<k.length;++C)S[k[C]]=1;return function(){for(var v=Object.keys(this),g=v.length-1;g>-1;--g)if(1===S[v[g]]&&null!=this[v[g]])return v[g]}},F.oneOfSetter=function(k){return function(S){for(var C=0;C<k.length;++C)k[C]!==S&&delete this[k[C]]}},F.toJSONOptions={longs:String,enums:String,bytes:String,json:!0},F._configure=function(){var k=F.Buffer;k?(F._Buffer_from=k.from!==Uint8Array.from&&k.from||function(S,C){return new k(S,C)},F._Buffer_allocUnsafe=k.allocUnsafe||function(S){return new k(S)}):F._Buffer_from=F._Buffer_allocUnsafe=null}},1173:(ge,E,$)=>{"use strict";ge.exports=h;var F,N=$(9693),R=N.LongBits,k=N.base64,S=N.utf8;function C(P,L,B){this.fn=P,this.len=L,this.next=void 0,this.val=B}function v(){}function g(P){this.head=P.head,this.tail=P.tail,this.len=P.len,this.next=P.states}function h(){this.len=0,this.head=new C(v,0,0),this.tail=this.head,this.states=null}var l=function(){return N.Buffer?function(){return(h.create=function(){return new F})()}:function(){return new h}};function d(P,L,B){L[B]=255&P}function f(P,L){this.len=P,this.next=void 0,this.val=L}function b(P,L,B){for(;P.hi;)L[B++]=127&P.lo|128,P.lo=(P.lo>>>7|P.hi<<25)>>>0,P.hi>>>=7;for(;P.lo>127;)L[B++]=127&P.lo|128,P.lo=P.lo>>>7;L[B++]=P.lo}function x(P,L,B){L[B]=255&P,L[B+1]=P>>>8&255,L[B+2]=P>>>16&255,L[B+3]=P>>>24}h.create=l(),h.alloc=function(P){return new N.Array(P)},N.Array!==Array&&(h.alloc=N.pool(h.alloc,N.Array.prototype.subarray)),h.prototype._push=function(P,L,B){return this.tail=this.tail.next=new C(P,L,B),this.len+=L,this},(f.prototype=Object.create(C.prototype)).fn=function(P,L,B){for(;P>127;)L[B++]=127&P|128,P>>>=7;L[B]=P},h.prototype.uint32=function(P){return this.len+=(this.tail=this.tail.next=new f((P>>>=0)<128?1:P<16384?2:P<2097152?3:P<268435456?4:5,P)).len,this},h.prototype.int32=function(P){return P<0?this._push(b,10,R.fromNumber(P)):this.uint32(P)},h.prototype.sint32=function(P){return this.uint32((P<<1^P>>31)>>>0)},h.prototype.int64=h.prototype.uint64=function(P){var L=R.from(P);return this._push(b,L.length(),L)},h.prototype.sint64=function(P){var L=R.from(P).zzEncode();return this._push(b,L.length(),L)},h.prototype.bool=function(P){return this._push(d,1,P?1:0)},h.prototype.sfixed32=h.prototype.fixed32=function(P){return this._push(x,4,P>>>0)},h.prototype.sfixed64=h.prototype.fixed64=function(P){var L=R.from(P);return this._push(x,4,L.lo)._push(x,4,L.hi)},h.prototype.float=function(P){return this._push(N.float.writeFloatLE,4,P)},h.prototype.double=function(P){return this._push(N.float.writeDoubleLE,8,P)};var D=N.Array.prototype.set?function(P,L,B){L.set(P,B)}:function(P,L,B){for(var U=0;U<P.length;++U)L[B+U]=P[U]};h.prototype.bytes=function(P){var L=P.length>>>0;if(!L)return this._push(d,1,0);if(N.isString(P)){var B=h.alloc(L=k.length(P));k.decode(P,B,0),P=B}return this.uint32(L)._push(D,L,P)},h.prototype.string=function(P){var L=S.length(P);return L?this.uint32(L)._push(S.write,L,P):this._push(d,1,0)},h.prototype.fork=function(){return this.states=new g(this),this.head=this.tail=new C(v,0,0),this.len=0,this},h.prototype.reset=function(){return this.states?(this.head=this.states.head,this.tail=this.states.tail,this.len=this.states.len,this.states=this.states.next):(this.head=this.tail=new C(v,0,0),this.len=0),this},h.prototype.ldelim=function(){var P=this.head,L=this.tail,B=this.len;return this.reset().uint32(B),B&&(this.tail.next=P.next,this.tail=L,this.len+=B),this},h.prototype.finish=function(){for(var P=this.head.next,L=this.constructor.alloc(this.len),B=0;P;)P.fn(P.val,L,B),B+=P.len,P=P.next;return L},h._configure=function(P){F=P,h.create=l(),F._configure()}},3155:(ge,E,$)=>{"use strict";ge.exports=R;var F=$(1173);(R.prototype=Object.create(F.prototype)).constructor=R;var N=$(9693);function R(){F.call(this)}function k(S,C,v){S.length<40?N.utf8.write(S,C,v):C.utf8Write?C.utf8Write(S,v):C.write(S,v)}R._configure=function(){R.alloc=N._Buffer_allocUnsafe,R.writeBytesBuffer=N.Buffer&&N.Buffer.prototype instanceof Uint8Array&&"set"===N.Buffer.prototype.set.name?function(S,C,v){C.set(S,v)}:function(S,C,v){if(S.copy)S.copy(C,v,0,S.length);else for(var g=0;g<S.length;)C[v++]=S[g++]}},R.prototype.bytes=function(S){N.isString(S)&&(S=N._Buffer_from(S,"base64"));var C=S.length>>>0;return this.uint32(C),C&&this._push(R.writeBytesBuffer,C,S),this},R.prototype.string=function(S){var C=N.Buffer.byteLength(S);return this.uint32(C),C&&this._push(k,C,S),this},R._configure()},4154:ge=>{"use strict";ge.exports='"use strict";var e={},a="object"==typeof process&&"object"==typeof process.versions&&"string"==typeof process.versions.node;if(a){var r=require("worker_threads"),t=r.parentPort;t.on("message",(e=>onmessage({data:e})));var s=require("fs");Object.assign(global,{self:global,require:require,Module:e,location:{href:__filename},Worker:r.Worker,importScripts:e=>(0,eval)(s.readFileSync(e,"utf8")+"//# sourceURL="+e),postMessage:e=>t.postMessage(e),performance:global.performance||{now:Date.now}})}var o=!1,d=function(){var e=Array.prototype.slice.call(arguments).join(" ");a?s.writeSync(2,e+"\\n"):console.error(e)};self.alert=function(){var a=Array.prototype.slice.call(arguments).join(" ");postMessage({cmd:"alert",text:a,threadId:e._pthread_self()})},e.instantiateWasm=(a,r)=>{var t=e.wasmModule;return e.wasmModule=null,r(new WebAssembly.Instance(t,a))},self.onunhandledrejection=e=>{throw e.reason??e},self.onmessage=function a(r){try{if("load"===r.data.cmd){let s=[];self.onmessage=e=>s.push(e),self.startWorker=r=>{e=r,postMessage({cmd:"loaded"});for(let e of s)a(e);self.onmessage=a},e.wasmModule=r.data.wasmModule;for(const a of r.data.handlers)e[a]=(...e)=>{postMessage({cmd:"callHandler",handler:a,args:e})};if(e.wasmMemory=r.data.wasmMemory,e.buffer=e.wasmMemory.buffer,e.ENVIRONMENT_IS_PTHREAD=!0,"string"==typeof r.data.urlOrBlob)importScripts(r.data.urlOrBlob);else{var t=URL.createObjectURL(r.data.urlOrBlob);importScripts(t),URL.revokeObjectURL(t)}ortWasmThreaded(e)}else if("run"===r.data.cmd){e.__emscripten_thread_init(r.data.pthread_ptr,0,0,1),e.__emscripten_thread_mailbox_await(r.data.pthread_ptr),e.establishStackSpace(),e.PThread.receiveObjectTransfer(r.data),e.PThread.threadInitTLS(),o||(o=!0);try{e.invokeEntryPoint(r.data.start_routine,r.data.arg)}catch(e){if("unwind"!=e)throw e}}else"cancel"===r.data.cmd?e._pthread_self()&&e.__emscripten_thread_exit(-1):"setimmediate"===r.data.target||("checkMailbox"===r.data.cmd?o&&e.checkMailbox():r.data.cmd&&(d("worker.js received unknown command "+r.data.cmd),d(r.data)))}catch(a){throw e.__emscripten_thread_crashed&&e.__emscripten_thread_crashed(),a}};\n'},7067:()=>{},1296:()=>{},760:()=>{},1384:()=>{},3993:()=>{},908:()=>{},6953:()=>{},9925:()=>{},2806:()=>{},6449:()=>{},2850:()=>{},5381:()=>{},685:(ge,E)=>{"use strict";Object.defineProperty(E,"__esModule",{value:!0}),E.resolveBackend=E.registerBackend=void 0;const $={},F=[];E.registerBackend=(N,R,k)=>{if(!R||"function"!=typeof R.init||"function"!=typeof R.createSessionHandler)throw new TypeError("not a valid backend");{const S=$[N];if(void 0===S)$[N]={backend:R,priority:k};else{if(S.priority>k)return;if(S.priority===k&&S.backend!==R)throw new Error(`cannot register backend "${N}" using priority ${k}`)}if(k>=0){const C=F.indexOf(N);-1!==C&&F.splice(C,1);for(let v=0;v<F.length;v++)if($[F[v]].priority<=k)return void F.splice(v,0,N);F.push(N)}}},E.resolveBackend=function(){var N=_asyncToGenerator(function*(R){const k=0===R.length?F:R,S=[];for(const C of k){const v=$[C];if(v){if(v.initialized)return v.backend;if(v.aborted)continue;const g=!!v.initPromise;try{return g||(v.initPromise=v.backend.init()),yield v.initPromise,v.initialized=!0,v.backend}catch(h){g||S.push({name:C,err:h}),v.aborted=!0}finally{delete v.initPromise}}}throw new Error(`no available backend found. ERR: ${S.map(C=>`[${C.name}] ${C.err}`).join(", ")}`)});return function(R){return N.apply(this,arguments)}}()},4798:(ge,E,$)=>{"use strict";Object.defineProperty(E,"__esModule",{value:!0}),E.registerBackend=void 0;var F=$(685);Object.defineProperty(E,"registerBackend",{enumerable:!0,get:function(){return F.registerBackend}})},3121:(ge,E,$)=>{"use strict";Object.defineProperty(E,"__esModule",{value:!0}),E.env=void 0;const F=$(9104);let N="warning";E.env={wasm:{},webgl:{},webgpu:{},versions:{common:F.version},set logLevel(R){if(void 0!==R){if("string"!=typeof R||-1===["verbose","info","warning","error","fatal"].indexOf(R))throw new Error(`Unsupported logging level: ${R}`);N=R}},get logLevel(){return N}},Object.defineProperty(E.env,"logLevel",{enumerable:!0})},2457:(ge,E,$)=>{"use strict";Object.defineProperty(E,"__esModule",{value:!0}),E.env=void 0;const F=$(3121);E.env=F.env},2235:function(ge,E,$){"use strict";var F=this&&this.__createBinding||(Object.create?function(R,k,S,C){void 0===C&&(C=S);var v=Object.getOwnPropertyDescriptor(k,S);v&&!("get"in v?!k.__esModule:v.writable||v.configurable)||(v={enumerable:!0,get:function(){return k[S]}}),Object.defineProperty(R,C,v)}:function(R,k,S,C){void 0===C&&(C=S),R[C]=k[S]}),N=this&&this.__exportStar||function(R,k){for(var S in R)"default"===S||Object.prototype.hasOwnProperty.call(k,S)||F(k,R,S)};Object.defineProperty(E,"__esModule",{value:!0}),N($(4798),E),N($(2457),E),N($(3974),E),N($(963),E),N($(7852),E)},8036:(ge,E,$)=>{"use strict";Object.defineProperty(E,"__esModule",{value:!0}),E.InferenceSession=void 0;const F=$(685),N=$(963);class R{constructor(S){this.handler=S}run(S,C,v){var g=this;return _asyncToGenerator(function*(){const h={};let l={};if("object"!=typeof S||null===S||S instanceof N.Tensor||Array.isArray(S))throw new TypeError("'feeds' must be an object that use input names as keys and OnnxValue as corresponding values.");let d=!0;if("object"==typeof C){if(null===C)throw new TypeError("Unexpected argument[1]: cannot be null.");if(C instanceof N.Tensor)throw new TypeError("'fetches' cannot be a Tensor");if(Array.isArray(C)){if(0===C.length)throw new TypeError("'fetches' cannot be an empty array.");d=!1;for(const x of C){if("string"!=typeof x)throw new TypeError("'fetches' must be a string array or an object.");if(-1===g.outputNames.indexOf(x))throw new RangeError(`'fetches' contains invalid output name: ${x}.`);h[x]=null}if("object"==typeof v&&null!==v)l=v;else if(void 0!==v)throw new TypeError("'options' must be an object.")}else{let x=!1;const D=Object.getOwnPropertyNames(C);for(const P of g.outputNames)if(-1!==D.indexOf(P)){const L=C[P];(null===L||L instanceof N.Tensor)&&(x=!0,d=!1,h[P]=L)}if(x){if("object"==typeof v&&null!==v)l=v;else if(void 0!==v)throw new TypeError("'options' must be an object.")}else l=C}}else if(void 0!==C)throw new TypeError("Unexpected argument[1]: must be 'fetches' or 'options'.");for(const x of g.inputNames)if(void 0===S[x])throw new Error(`input '${x}' is missing in 'feeds'.`);if(d)for(const x of g.outputNames)h[x]=null;const f=yield g.handler.run(S,h,l),b={};for(const x in f)Object.hasOwnProperty.call(f,x)&&(b[x]=new N.Tensor(f[x].type,f[x].data,f[x].dims));return b})()}release(){var S=this;return _asyncToGenerator(function*(){return S.handler.dispose()})()}static create(S,C,v,g){return _asyncToGenerator(function*(){let h,l={};if("string"==typeof S){if(h=S,"object"==typeof C&&null!==C)l=C;else if(void 0!==C)throw new TypeError("'options' must be an object.")}else if(S instanceof Uint8Array){if(h=S,"object"==typeof C&&null!==C)l=C;else if(void 0!==C)throw new TypeError("'options' must be an object.")}else{if(!(S instanceof ArrayBuffer||typeof SharedArrayBuffer<"u"&&S instanceof SharedArrayBuffer))throw new TypeError("Unexpected argument[0]: must be 'path' or 'buffer'.");{const x=S;let D=0,P=S.byteLength;if("object"==typeof C&&null!==C)l=C;else if("number"==typeof C){if(D=C,!Number.isSafeInteger(D))throw new RangeError("'byteOffset' must be an integer.");if(D<0||D>=x.byteLength)throw new RangeError(`'byteOffset' is out of range [0, ${x.byteLength}).`);if(P=S.byteLength-D,"number"==typeof v){if(P=v,!Number.isSafeInteger(P))throw new RangeError("'byteLength' must be an integer.");if(P<=0||D+P>x.byteLength)throw new RangeError(`'byteLength' is out of range (0, ${x.byteLength-D}].`);if("object"==typeof g&&null!==g)l=g;else if(void 0!==g)throw new TypeError("'options' must be an object.")}else if(void 0!==v)throw new TypeError("'byteLength' must be a number.")}else if(void 0!==C)throw new TypeError("'options' must be an object.");h=new Uint8Array(x,D,P)}}const d=(l.executionProviders||[]).map(x=>"string"==typeof x?x:x.name),f=yield(0,F.resolveBackend)(d),b=yield f.createSessionHandler(h,l);return new R(b)})()}startProfiling(){this.handler.startProfiling()}endProfiling(){this.handler.endProfiling()}get inputNames(){return this.handler.inputNames}get outputNames(){return this.handler.outputNames}}E.InferenceSession=R},3974:(ge,E,$)=>{"use strict";Object.defineProperty(E,"__esModule",{value:!0}),E.InferenceSession=void 0;const F=$(8036);E.InferenceSession=F.InferenceSession},7852:(ge,E)=>{"use strict";Object.defineProperty(E,"__esModule",{value:!0})},2350:(ge,E)=>{"use strict";Object.defineProperty(E,"__esModule",{value:!0}),E.tensorToImageData=E.tensorToDataURL=void 0,E.tensorToDataURL=($,F)=>{const N=document.createElement("canvas");N.width=$.dims[3],N.height=$.dims[2];const R=N.getContext("2d");if(null!=R){let k,S;void 0!==F?.tensorLayout&&"NHWC"===F.tensorLayout?(k=$.dims[2],S=$.dims[3]):(k=$.dims[3],S=$.dims[2]);const C=void 0!==F?.format?F.format:"RGB",v=F?.norm;let g,h;void 0===v||void 0===v.mean?g=[255,255,255,255]:"number"==typeof v.mean?g=[v.mean,v.mean,v.mean,v.mean]:(g=[v.mean[0],v.mean[1],v.mean[2],0],void 0!==v.mean[3]&&(g[3]=v.mean[3])),void 0===v||void 0===v.bias?h=[0,0,0,0]:"number"==typeof v.bias?h=[v.bias,v.bias,v.bias,v.bias]:(h=[v.bias[0],v.bias[1],v.bias[2],0],void 0!==v.bias[3]&&(h[3]=v.bias[3]));const l=S*k;let d=0,f=l,b=2*l,x=-1;"RGBA"===C?(d=0,f=l,b=2*l,x=3*l):"RGB"===C?(d=0,f=l,b=2*l):"RBG"===C&&(d=0,b=l,f=2*l);for(let D=0;D<S;D++)for(let P=0;P<k;P++){const L=($.data[d++]-h[0])*g[0],B=($.data[f++]-h[1])*g[1],U=($.data[b++]-h[2])*g[2],W=-1===x?255:($.data[x++]-h[3])*g[3];R.fillStyle="rgba("+L+","+B+","+U+","+W+")",R.fillRect(P,D,1,1)}return N.toDataURL()}throw new Error("Can not access image data")},E.tensorToImageData=($,F)=>{const N=document.createElement("canvas").getContext("2d");let R;if(null==N)throw new Error("Can not access image data");{let k,S,C;void 0!==F?.tensorLayout&&"NHWC"===F.tensorLayout?(k=$.dims[2],S=$.dims[1],C=$.dims[3]):(k=$.dims[3],S=$.dims[2],C=$.dims[1]);const v=void 0!==F&&void 0!==F.format?F.format:"RGB",g=F?.norm;let h,l;void 0===g||void 0===g.mean?h=[255,255,255,255]:"number"==typeof g.mean?h=[g.mean,g.mean,g.mean,g.mean]:(h=[g.mean[0],g.mean[1],g.mean[2],255],void 0!==g.mean[3]&&(h[3]=g.mean[3])),void 0===g||void 0===g.bias?l=[0,0,0,0]:"number"==typeof g.bias?l=[g.bias,g.bias,g.bias,g.bias]:(l=[g.bias[0],g.bias[1],g.bias[2],0],void 0!==g.bias[3]&&(l[3]=g.bias[3]));const d=S*k;if(void 0!==F&&(void 0!==F.format&&4===C&&"RGBA"!==F.format||3===C&&"RGB"!==F.format&&"BGR"!==F.format))throw new Error("Tensor format doesn't match input tensor dims");const f=4;let b=0,x=1,D=2,P=3,L=0,B=d,U=2*d,W=-1;"RGBA"===v?(L=0,B=d,U=2*d,W=3*d):"RGB"===v?(L=0,B=d,U=2*d):"RBG"===v&&(L=0,U=d,B=2*d),R=N.createImageData(k,S);for(let H=0;H<S*k;b+=f,x+=f,D+=f,P+=f,H++)R.data[b]=($.data[L++]-l[0])*h[0],R.data[x]=($.data[B++]-l[1])*h[1],R.data[D]=($.data[U++]-l[2])*h[2],R.data[P]=-1===W?255:($.data[W++]-l[3])*h[3]}return R}},4866:(ge,E,$)=>{"use strict";Object.defineProperty(E,"__esModule",{value:!0}),E.tensorFromImage=E.bufferToTensor=void 0;const F=$(963);E.bufferToTensor=(N,R)=>{if(void 0===N)throw new Error("Image buffer must be defined");if(void 0===R.height||void 0===R.width)throw new Error("Image height and width must be defined");if("NHWC"===R.tensorLayout)throw new Error("NHWC Tensor layout is not supported yet");const{height:k,width:S}=R,C=R.norm??{mean:255,bias:0};let v,g;v="number"==typeof C.mean?[C.mean,C.mean,C.mean,C.mean]:[C.mean[0],C.mean[1],C.mean[2],C.mean[3]??255],g="number"==typeof C.bias?[C.bias,C.bias,C.bias,C.bias]:[C.bias[0],C.bias[1],C.bias[2],C.bias[3]??0];const h=void 0!==R.format?R.format:"RGBA",l=void 0!==R.tensorFormat&&void 0!==R.tensorFormat?R.tensorFormat:"RGB",d=k*S,f="RGBA"===l?new Float32Array(4*d):new Float32Array(3*d);let b=4,x=0,D=1,P=2,L=3,B=0,U=d,W=2*d,H=-1;"RGB"===h&&(b=3,x=0,D=1,P=2,L=-1),"RGBA"===l?H=3*d:"RBG"===l?(B=0,W=d,U=2*d):"BGR"===l&&(W=0,U=d,B=2*d);for(let re=0;re<d;re++,x+=b,P+=b,D+=b,L+=b)f[B++]=(N[x]+g[0])/v[0],f[U++]=(N[D]+g[1])/v[1],f[W++]=(N[P]+g[2])/v[2],-1!==H&&-1!==L&&(f[H++]=(N[L]+g[3])/v[3]);return new F.Tensor("float32",f,"RGBA"===l?[1,4,k,S]:[1,3,k,S])},E.tensorFromImage=function(){var N=_asyncToGenerator(function*(R,k){const S=typeof HTMLImageElement<"u"&&R instanceof HTMLImageElement,C=typeof ImageData<"u"&&R instanceof ImageData,v=typeof ImageBitmap<"u"&&R instanceof ImageBitmap,g="string"==typeof R;let h,l=k??{};if(S){const d=document.createElement("canvas");d.width=R.width,d.height=R.height;const f=d.getContext("2d");if(null==f)throw new Error("Can not access image data");{let b=R.height,x=R.width;if(void 0!==k&&void 0!==k.resizedHeight&&void 0!==k.resizedWidth&&(b=k.resizedHeight,x=k.resizedWidth),void 0!==k){if(l=k,void 0!==k.tensorFormat)throw new Error("Image input config format must be RGBA for HTMLImageElement");l.tensorFormat="RGBA",l.height=b,l.width=x}else l.tensorFormat="RGBA",l.height=b,l.width=x;f.drawImage(R,0,0),h=f.getImageData(0,0,x,b).data}}else{if(!C){if(v){if(void 0===k)throw new Error("Please provide image config with format for Imagebitmap");const d=document.createElement("canvas");d.width=R.width,d.height=R.height;const f=d.getContext("2d");if(null!=f){const b=R.height,x=R.width;return f.drawImage(R,0,0,x,b),h=f.getImageData(0,0,x,b).data,l.height=b,l.width=x,(0,E.bufferToTensor)(h,l)}throw new Error("Can not access image data")}if(g)return new Promise((d,f)=>{const b=document.createElement("canvas"),x=b.getContext("2d");if(!R||!x)return f();const D=new Image;D.crossOrigin="Anonymous",D.src=R,D.onload=()=>{b.width=D.width,b.height=D.height,x.drawImage(D,0,0,b.width,b.height);const P=x.getImageData(0,0,b.width,b.height);l.height=b.height,l.width=b.width,d((0,E.bufferToTensor)(P.data,l))}});throw new Error("Input data provided is not supported - aborted tensor creation")}{let d,f;if(void 0!==k&&void 0!==k.resizedWidth&&void 0!==k.resizedHeight?(d=k.resizedHeight,f=k.resizedWidth):(d=R.height,f=R.width),void 0!==k&&(l=k),l.format="RGBA",l.height=d,l.width=f,void 0!==k){const b=document.createElement("canvas");b.width=f,b.height=d;const x=b.getContext("2d");if(null==x)throw new Error("Can not access image data");x.putImageData(R,0,0),h=x.getImageData(0,0,f,d).data}else h=R.data}}if(void 0!==h)return(0,E.bufferToTensor)(h,l);throw new Error("Input data provided is not supported - aborted tensor creation")});return function(R,k){return N.apply(this,arguments)}}()},5957:(ge,E,$)=>{"use strict";Object.defineProperty(E,"__esModule",{value:!0}),E.Tensor=void 0;const F=$(2350),N=$(4866),R=$(106),k=new Map([["float32",Float32Array],["uint8",Uint8Array],["int8",Int8Array],["uint16",Uint16Array],["float16",Uint16Array],["int16",Int16Array],["int32",Int32Array],["bool",Uint8Array],["float64",Float64Array],["uint32",Uint32Array]]),S=new Map([[Float32Array,"float32"],[Uint8Array,"uint8"],[Int8Array,"int8"],[Uint16Array,"uint16"],[Int16Array,"int16"],[Int32Array,"int32"],[Float64Array,"float64"],[Uint32Array,"uint32"]]);let C=!1;E.Tensor=class{constructor(v,g,h){let l,d,f;if((()=>{if(!C){C=!0;const x=typeof BigInt64Array<"u"&&"function"==typeof BigInt64Array.from,D=typeof BigUint64Array<"u"&&"function"==typeof BigUint64Array.from;x&&(k.set("int64",BigInt64Array),S.set(BigInt64Array,"int64")),D&&(k.set("uint64",BigUint64Array),S.set(BigUint64Array,"uint64"))}})(),"string"==typeof v)if(l=v,f=h,"string"===v){if(!Array.isArray(g))throw new TypeError("A string tensor's data must be a string array.");d=g}else{const x=k.get(v);if(void 0===x)throw new TypeError(`Unsupported tensor type: ${v}.`);if(Array.isArray(g)){if("float16"===v)throw new TypeError("Creating a float16 tensor from number array is not supported. Please use Uint16Array as data.");d="uint64"===v||"int64"===v?x.from(g,BigInt):x.from(g)}else{if(!(g instanceof x))throw new TypeError(`A ${l} tensor's data must be type of ${x}`);d=g}}else if(f=g,Array.isArray(v)){if(0===v.length)throw new TypeError("Tensor type cannot be inferred from an empty array.");const x=typeof v[0];if("string"===x)l="string",d=v;else{if("boolean"!==x)throw new TypeError(`Invalid element type of data array: ${x}.`);l="bool",d=Uint8Array.from(v)}}else{const x=S.get(v.constructor);if(void 0===x)throw new TypeError(`Unsupported type for tensor data: ${v.constructor}.`);l=x,d=v}if(void 0===f)f=[d.length];else if(!Array.isArray(f))throw new TypeError("A tensor's dims must be a number array");const b=(0,R.calculateSize)(f);if(b!==d.length)throw new Error(`Tensor's size(${b}) does not match data length(${d.length}).`);this.dims=f,this.type=l,this.data=d,this.size=b}static fromImage(v,g){return _asyncToGenerator(function*(){return(0,N.tensorFromImage)(v,g)})()}toDataURL(v){return(0,F.tensorToDataURL)(this,v)}toImageData(v){return(0,F.tensorToImageData)(this,v)}reshape(v){return(0,R.tensorReshape)(this,v)}}},106:(ge,E,$)=>{"use strict";Object.defineProperty(E,"__esModule",{value:!0}),E.tensorReshape=E.calculateSize=void 0;const F=$(963);E.calculateSize=N=>{let R=1;for(let k=0;k<N.length;k++){const S=N[k];if("number"!=typeof S||!Number.isSafeInteger(S))throw new TypeError(`dims[${k}] must be an integer, got: ${S}`);if(S<0)throw new RangeError(`dims[${k}] must be a non-negative integer, got: ${S}`);R*=S}return R},E.tensorReshape=(N,R)=>new F.Tensor(N.type,N.data,R)},963:(ge,E,$)=>{"use strict";Object.defineProperty(E,"__esModule",{value:!0}),E.Tensor=void 0;const F=$(5957);E.Tensor=F.Tensor},9104:(ge,E)=>{"use strict";Object.defineProperty(E,"__esModule",{value:!0}),E.version=void 0,E.version="1.16.3"},1583:(ge,E)=>{var $,F=function(N){"use strict";Object.defineProperty(N,"__esModule",{value:!0}),N.default=void 0;var R=null;try{R=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch{}function k(K,ie,ce){this.low=0|K,this.high=0|ie,this.unsigned=!!ce}function S(K){return!0===(K&&K.__isLong__)}function C(K){var ie=Math.clz32(K&-K);return K?31-ie:ie}Object.defineProperty(k.prototype,"__isLong__",{value:!0}),k.isLong=S;var v={},g={};function h(K,ie){var ce,qe,Be;return ie?(Be=0<=(K>>>=0)&&K<256)&&(qe=g[K])?qe:(ce=d(K,0,!0),Be&&(g[K]=ce),ce):(Be=-128<=(K|=0)&&K<128)&&(qe=v[K])?qe:(ce=d(K,K<0?-1:0,!1),Be&&(v[K]=ce),ce)}function l(K,ie){if(isNaN(K))return ie?W:U;if(ie){if(K<0)return W;if(K>=P)return se}else{if(K<=-L)return Y;if(K+1>=L)return te}return K<0?l(-K,ie).neg():d(K%D|0,K/D|0,ie)}function d(K,ie,ce){return new k(K,ie,ce)}k.fromInt=h,k.fromNumber=l,k.fromBits=d;var f=Math.pow;function b(K,ie,ce){if(0===K.length)throw Error("empty string");if("number"==typeof ie?(ce=ie,ie=!1):ie=!!ie,"NaN"===K||"Infinity"===K||"+Infinity"===K||"-Infinity"===K)return ie?W:U;if((ce=ce||10)<2||36<ce)throw RangeError("radix");var qe;if((qe=K.indexOf("-"))>0)throw Error("interior hyphen");if(0===qe)return b(K.substring(1),ie,ce).neg();for(var Be=l(f(ce,8)),at=U,rt=0;rt<K.length;rt+=8){var ot=Math.min(8,K.length-rt),bt=parseInt(K.substring(rt,rt+ot),ce);if(ot<8){var wt=l(f(ce,ot));at=at.mul(wt).add(l(bt))}else at=(at=at.mul(Be)).add(l(bt))}return at.unsigned=ie,at}function x(K,ie){return"number"==typeof K?l(K,ie):"string"==typeof K?b(K,ie):d(K.low,K.high,"boolean"==typeof ie?ie:K.unsigned)}k.fromString=b,k.fromValue=x;var D=4294967296,P=D*D,L=P/2,B=h(1<<24),U=h(0);k.ZERO=U;var W=h(0,!0);k.UZERO=W;var H=h(1);k.ONE=H;var re=h(1,!0);k.UONE=re;var ue=h(-1);k.NEG_ONE=ue;var te=d(-1,2147483647,!1);k.MAX_VALUE=te;var se=d(-1,-1,!0);k.MAX_UNSIGNED_VALUE=se;var Y=d(0,-2147483648,!1);k.MIN_VALUE=Y;var X=k.prototype;return X.toInt=function(){return this.unsigned?this.low>>>0:this.low},X.toNumber=function(){return this.unsigned?(this.high>>>0)*D+(this.low>>>0):this.high*D+(this.low>>>0)},X.toString=function(K){if((K=K||10)<2||36<K)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative()){if(this.eq(Y)){var ie=l(K),ce=this.div(ie),qe=ce.mul(ie).sub(this);return ce.toString(K)+qe.toInt().toString(K)}return"-"+this.neg().toString(K)}for(var Be=l(f(K,6),this.unsigned),at=this,rt="";;){var ot=at.div(Be),bt=(at.sub(ot.mul(Be)).toInt()>>>0).toString(K);if((at=ot).isZero())return bt+rt;for(;bt.length<6;)bt="0"+bt;rt=""+bt+rt}},X.getHighBits=function(){return this.high},X.getHighBitsUnsigned=function(){return this.high>>>0},X.getLowBits=function(){return this.low},X.getLowBitsUnsigned=function(){return this.low>>>0},X.getNumBitsAbs=function(){if(this.isNegative())return this.eq(Y)?64:this.neg().getNumBitsAbs();for(var K=0!=this.high?this.high:this.low,ie=31;ie>0&&!(K&1<<ie);ie--);return 0!=this.high?ie+33:ie+1},X.isZero=function(){return 0===this.high&&0===this.low},X.eqz=X.isZero,X.isNegative=function(){return!this.unsigned&&this.high<0},X.isPositive=function(){return this.unsigned||this.high>=0},X.isOdd=function(){return 1==(1&this.low)},X.isEven=function(){return 0==(1&this.low)},X.equals=function(K){return S(K)||(K=x(K)),(this.unsigned===K.unsigned||this.high>>>31!=1||K.high>>>31!=1)&&this.high===K.high&&this.low===K.low},X.eq=X.equals,X.notEquals=function(K){return!this.eq(K)},X.neq=X.notEquals,X.ne=X.notEquals,X.lessThan=function(K){return this.comp(K)<0},X.lt=X.lessThan,X.lessThanOrEqual=function(K){return this.comp(K)<=0},X.lte=X.lessThanOrEqual,X.le=X.lessThanOrEqual,X.greaterThan=function(K){return this.comp(K)>0},X.gt=X.greaterThan,X.greaterThanOrEqual=function(K){return this.comp(K)>=0},X.gte=X.greaterThanOrEqual,X.ge=X.greaterThanOrEqual,X.compare=function(K){if(S(K)||(K=x(K)),this.eq(K))return 0;var ie=this.isNegative(),ce=K.isNegative();return ie&&!ce?-1:!ie&&ce?1:this.unsigned?K.high>>>0>this.high>>>0||K.high===this.high&&K.low>>>0>this.low>>>0?-1:1:this.sub(K).isNegative()?-1:1},X.comp=X.compare,X.negate=function(){return!this.unsigned&&this.eq(Y)?Y:this.not().add(H)},X.neg=X.negate,X.add=function(K){S(K)||(K=x(K));var bt=0,wt=0,Mt=0,un=0;return Mt+=(un+=(65535&this.low)+(65535&K.low))>>>16,wt+=(Mt+=(this.low>>>16)+(K.low>>>16))>>>16,bt+=(wt+=(65535&this.high)+(65535&K.high))>>>16,bt+=(this.high>>>16)+(K.high>>>16),d((Mt&=65535)<<16|(un&=65535),(bt&=65535)<<16|(wt&=65535),this.unsigned)},X.subtract=function(K){return S(K)||(K=x(K)),this.add(K.neg())},X.sub=X.subtract,X.multiply=function(K){if(this.isZero())return this;if(S(K)||(K=x(K)),R)return d(R.mul(this.low,this.high,K.low,K.high),R.get_high(),this.unsigned);if(K.isZero())return this.unsigned?W:U;if(this.eq(Y))return K.isOdd()?Y:U;if(K.eq(Y))return this.isOdd()?Y:U;if(this.isNegative())return K.isNegative()?this.neg().mul(K.neg()):this.neg().mul(K).neg();if(K.isNegative())return this.mul(K.neg()).neg();if(this.lt(B)&&K.lt(B))return l(this.toNumber()*K.toNumber(),this.unsigned);var ce=65535&this.high,qe=this.low>>>16,Be=65535&this.low,rt=65535&K.high,ot=K.low>>>16,bt=65535&K.low,wt=0,Mt=0,un=0,_n=0;return un+=(_n+=Be*bt)>>>16,Mt+=(un+=qe*bt)>>>16,un&=65535,Mt+=(un+=Be*ot)>>>16,wt+=(Mt+=ce*bt)>>>16,Mt&=65535,wt+=(Mt+=qe*ot)>>>16,Mt&=65535,wt+=(Mt+=Be*rt)>>>16,wt+=(this.high>>>16)*bt+ce*ot+qe*rt+Be*(K.high>>>16),d((un&=65535)<<16|(_n&=65535),(wt&=65535)<<16|(Mt&=65535),this.unsigned)},X.mul=X.multiply,X.divide=function(K){if(S(K)||(K=x(K)),K.isZero())throw Error("division by zero");var ie,ce,qe;if(R)return this.unsigned||-2147483648!==this.high||-1!==K.low||-1!==K.high?d((this.unsigned?R.div_u:R.div_s)(this.low,this.high,K.low,K.high),R.get_high(),this.unsigned):this;if(this.isZero())return this.unsigned?W:U;if(this.unsigned){if(K.unsigned||(K=K.toUnsigned()),K.gt(this))return W;if(K.gt(this.shru(1)))return re;qe=W}else{if(this.eq(Y))return K.eq(H)||K.eq(ue)?Y:K.eq(Y)?H:(ie=this.shr(1).div(K).shl(1)).eq(U)?K.isNegative()?H:ue:(ce=this.sub(K.mul(ie)),qe=ie.add(ce.div(K)));if(K.eq(Y))return this.unsigned?W:U;if(this.isNegative())return K.isNegative()?this.neg().div(K.neg()):this.neg().div(K).neg();if(K.isNegative())return this.div(K.neg()).neg();qe=U}for(ce=this;ce.gte(K);){ie=Math.max(1,Math.floor(ce.toNumber()/K.toNumber()));for(var Be=Math.ceil(Math.log(ie)/Math.LN2),at=Be<=48?1:f(2,Be-48),rt=l(ie),ot=rt.mul(K);ot.isNegative()||ot.gt(ce);)ot=(rt=l(ie-=at,this.unsigned)).mul(K);rt.isZero()&&(rt=H),qe=qe.add(rt),ce=ce.sub(ot)}return qe},X.div=X.divide,X.modulo=function(K){return S(K)||(K=x(K)),R?d((this.unsigned?R.rem_u:R.rem_s)(this.low,this.high,K.low,K.high),R.get_high(),this.unsigned):this.sub(this.div(K).mul(K))},X.mod=X.modulo,X.rem=X.modulo,X.not=function(){return d(~this.low,~this.high,this.unsigned)},X.countLeadingZeros=function(){return this.high?Math.clz32(this.high):Math.clz32(this.low)+32},X.clz=X.countLeadingZeros,X.countTrailingZeros=function(){return this.low?C(this.low):C(this.high)+32},X.ctz=X.countTrailingZeros,X.and=function(K){return S(K)||(K=x(K)),d(this.low&K.low,this.high&K.high,this.unsigned)},X.or=function(K){return S(K)||(K=x(K)),d(this.low|K.low,this.high|K.high,this.unsigned)},X.xor=function(K){return S(K)||(K=x(K)),d(this.low^K.low,this.high^K.high,this.unsigned)},X.shiftLeft=function(K){return S(K)&&(K=K.toInt()),0==(K&=63)?this:K<32?d(this.low<<K,this.high<<K|this.low>>>32-K,this.unsigned):d(0,this.low<<K-32,this.unsigned)},X.shl=X.shiftLeft,X.shiftRight=function(K){return S(K)&&(K=K.toInt()),0==(K&=63)?this:K<32?d(this.low>>>K|this.high<<32-K,this.high>>K,this.unsigned):d(this.high>>K-32,this.high>=0?0:-1,this.unsigned)},X.shr=X.shiftRight,X.shiftRightUnsigned=function(K){return S(K)&&(K=K.toInt()),0==(K&=63)?this:K<32?d(this.low>>>K|this.high<<32-K,this.high>>>K,this.unsigned):d(32===K?this.high:this.high>>>K-32,0,this.unsigned)},X.shru=X.shiftRightUnsigned,X.shr_u=X.shiftRightUnsigned,X.rotateLeft=function(K){var ie;return S(K)&&(K=K.toInt()),0==(K&=63)?this:32===K?d(this.high,this.low,this.unsigned):K<32?d(this.low<<K|this.high>>>(ie=32-K),this.high<<K|this.low>>>ie,this.unsigned):(ie=32-(K-=32),d(this.high<<K|this.low>>>ie,this.low<<K|this.high>>>ie,this.unsigned))},X.rotl=X.rotateLeft,X.rotateRight=function(K){var ie;return S(K)&&(K=K.toInt()),0==(K&=63)?this:32===K?d(this.high,this.low,this.unsigned):K<32?d(this.high<<(ie=32-K)|this.low>>>K,this.low<<ie|this.high>>>K,this.unsigned):(ie=32-(K-=32),d(this.low<<ie|this.high>>>K,this.high<<ie|this.low>>>K,this.unsigned))},X.rotr=X.rotateRight,X.toSigned=function(){return this.unsigned?d(this.low,this.high,!1):this},X.toUnsigned=function(){return this.unsigned?this:d(this.low,this.high,!0)},X.toBytes=function(K){return K?this.toBytesLE():this.toBytesBE()},X.toBytesLE=function(){var K=this.high,ie=this.low;return[255&ie,ie>>>8&255,ie>>>16&255,ie>>>24,255&K,K>>>8&255,K>>>16&255,K>>>24]},X.toBytesBE=function(){var K=this.high,ie=this.low;return[K>>>24,K>>>16&255,K>>>8&255,255&K,ie>>>24,ie>>>16&255,ie>>>8&255,255&ie]},k.fromBytes=function(K,ie,ce){return ce?k.fromBytesLE(K,ie):k.fromBytesBE(K,ie)},k.fromBytesLE=function(K,ie){return new k(K[0]|K[1]<<8|K[2]<<16|K[3]<<24,K[4]|K[5]<<8|K[6]<<16|K[7]<<24,ie)},k.fromBytesBE=function(K,ie){return new k(K[4]<<24|K[5]<<16|K[6]<<8|K[7],K[0]<<24|K[1]<<16|K[2]<<8|K[3],ie)},N.default=k,"default"in N?N.default:N}({});void 0===($=function(){return F}.apply(E,[]))||(ge.exports=$)},5686:(ge,E,$)=>{"use strict";$.r(E),$.d(E,{flatbuffers:()=>F});var F={SIZEOF_SHORT:2,SIZEOF_INT:4,FILE_IDENTIFIER_LENGTH:4,SIZE_PREFIX_LENGTH:4,Encoding:{UTF8_BYTES:1,UTF16_STRING:2}};F.int32=new Int32Array(2),F.float32=new Float32Array(F.int32.buffer),F.float64=new Float64Array(F.int32.buffer),F.isLittleEndian=1===new Uint16Array(new Uint8Array([1,0]).buffer)[0],F.Long=function(N,R){this.low=0|N,this.high=0|R},F.Long.create=function(N,R){return 0==N&&0==R?F.Long.ZERO:new F.Long(N,R)},F.Long.prototype.toFloat64=function(){return(this.low>>>0)+4294967296*this.high},F.Long.prototype.equals=function(N){return this.low==N.low&&this.high==N.high},F.Long.ZERO=new F.Long(0,0),F.Builder=function(N){if(N)R=N;else var R=1024;this.bb=F.ByteBuffer.allocate(R),this.space=R,this.minalign=1,this.vtable=null,this.vtable_in_use=0,this.isNested=!1,this.object_start=0,this.vtables=[],this.vector_num_elems=0,this.force_defaults=!1},F.Builder.prototype.clear=function(){this.bb.clear(),this.space=this.bb.capacity(),this.minalign=1,this.vtable=null,this.vtable_in_use=0,this.isNested=!1,this.object_start=0,this.vtables=[],this.vector_num_elems=0,this.force_defaults=!1},F.Builder.prototype.forceDefaults=function(N){this.force_defaults=N},F.Builder.prototype.dataBuffer=function(){return this.bb},F.Builder.prototype.asUint8Array=function(){return this.bb.bytes().subarray(this.bb.position(),this.bb.position()+this.offset())},F.Builder.prototype.prep=function(N,R){N>this.minalign&&(this.minalign=N);for(var k=1+~(this.bb.capacity()-this.space+R)&N-1;this.space<k+N+R;){var S=this.bb.capacity();this.bb=F.Builder.growByteBuffer(this.bb),this.space+=this.bb.capacity()-S}this.pad(k)},F.Builder.prototype.pad=function(N){for(var R=0;R<N;R++)this.bb.writeInt8(--this.space,0)},F.Builder.prototype.writeInt8=function(N){this.bb.writeInt8(this.space-=1,N)},F.Builder.prototype.writeInt16=function(N){this.bb.writeInt16(this.space-=2,N)},F.Builder.prototype.writeInt32=function(N){this.bb.writeInt32(this.space-=4,N)},F.Builder.prototype.writeInt64=function(N){this.bb.writeInt64(this.space-=8,N)},F.Builder.prototype.writeFloat32=function(N){this.bb.writeFloat32(this.space-=4,N)},F.Builder.prototype.writeFloat64=function(N){this.bb.writeFloat64(this.space-=8,N)},F.Builder.prototype.addInt8=function(N){this.prep(1,0),this.writeInt8(N)},F.Builder.prototype.addInt16=function(N){this.prep(2,0),this.writeInt16(N)},F.Builder.prototype.addInt32=function(N){this.prep(4,0),this.writeInt32(N)},F.Builder.prototype.addInt64=function(N){this.prep(8,0),this.writeInt64(N)},F.Builder.prototype.addFloat32=function(N){this.prep(4,0),this.writeFloat32(N)},F.Builder.prototype.addFloat64=function(N){this.prep(8,0),this.writeFloat64(N)},F.Builder.prototype.addFieldInt8=function(N,R,k){(this.force_defaults||R!=k)&&(this.addInt8(R),this.slot(N))},F.Builder.prototype.addFieldInt16=function(N,R,k){(this.force_defaults||R!=k)&&(this.addInt16(R),this.slot(N))},F.Builder.prototype.addFieldInt32=function(N,R,k){(this.force_defaults||R!=k)&&(this.addInt32(R),this.slot(N))},F.Builder.prototype.addFieldInt64=function(N,R,k){!this.force_defaults&&R.equals(k)||(this.addInt64(R),this.slot(N))},F.Builder.prototype.addFieldFloat32=function(N,R,k){(this.force_defaults||R!=k)&&(this.addFloat32(R),this.slot(N))},F.Builder.prototype.addFieldFloat64=function(N,R,k){(this.force_defaults||R!=k)&&(this.addFloat64(R),this.slot(N))},F.Builder.prototype.addFieldOffset=function(N,R,k){(this.force_defaults||R!=k)&&(this.addOffset(R),this.slot(N))},F.Builder.prototype.addFieldStruct=function(N,R,k){R!=k&&(this.nested(R),this.slot(N))},F.Builder.prototype.nested=function(N){if(N!=this.offset())throw new Error("FlatBuffers: struct must be serialized inline.")},F.Builder.prototype.notNested=function(){if(this.isNested)throw new Error("FlatBuffers: object serialization must not be nested.")},F.Builder.prototype.slot=function(N){this.vtable[N]=this.offset()},F.Builder.prototype.offset=function(){return this.bb.capacity()-this.space},F.Builder.growByteBuffer=function(N){var R=N.capacity();if(3221225472&R)throw new Error("FlatBuffers: cannot grow buffer beyond 2 gigabytes.");var k=R<<1,S=F.ByteBuffer.allocate(k);return S.setPosition(k-R),S.bytes().set(N.bytes(),k-R),S},F.Builder.prototype.addOffset=function(N){this.prep(F.SIZEOF_INT,0),this.writeInt32(this.offset()-N+F.SIZEOF_INT)},F.Builder.prototype.startObject=function(N){this.notNested(),null==this.vtable&&(this.vtable=[]),this.vtable_in_use=N;for(var R=0;R<N;R++)this.vtable[R]=0;this.isNested=!0,this.object_start=this.offset()},F.Builder.prototype.endObject=function(){if(null==this.vtable||!this.isNested)throw new Error("FlatBuffers: endObject called without startObject");this.addInt32(0);for(var N=this.offset(),R=this.vtable_in_use-1;R>=0&&0==this.vtable[R];R--);for(var k=R+1;R>=0;R--)this.addInt16(0!=this.vtable[R]?N-this.vtable[R]:0);this.addInt16(N-this.object_start);var S=(k+2)*F.SIZEOF_SHORT;this.addInt16(S);var C=0,v=this.space;e:for(R=0;R<this.vtables.length;R++){var g=this.bb.capacity()-this.vtables[R];if(S==this.bb.readInt16(g)){for(var h=F.SIZEOF_SHORT;h<S;h+=F.SIZEOF_SHORT)if(this.bb.readInt16(v+h)!=this.bb.readInt16(g+h))continue e;C=this.vtables[R];break}}return C?(this.space=this.bb.capacity()-N,this.bb.writeInt32(this.space,C-N)):(this.vtables.push(this.offset()),this.bb.writeInt32(this.bb.capacity()-N,this.offset()-N)),this.isNested=!1,N},F.Builder.prototype.finish=function(N,R,k){var S=k?F.SIZE_PREFIX_LENGTH:0;if(R){var C=R;if(this.prep(this.minalign,F.SIZEOF_INT+F.FILE_IDENTIFIER_LENGTH+S),C.length!=F.FILE_IDENTIFIER_LENGTH)throw new Error("FlatBuffers: file identifier must be length "+F.FILE_IDENTIFIER_LENGTH);for(var v=F.FILE_IDENTIFIER_LENGTH-1;v>=0;v--)this.writeInt8(C.charCodeAt(v))}this.prep(this.minalign,F.SIZEOF_INT+S),this.addOffset(N),S&&this.addInt32(this.bb.capacity()-this.space),this.bb.setPosition(this.space)},F.Builder.prototype.finishSizePrefixed=function(N,R){this.finish(N,R,!0)},F.Builder.prototype.requiredField=function(N,R){var k=this.bb.capacity()-N,S=k-this.bb.readInt32(k);if(0==this.bb.readInt16(S+R))throw new Error("FlatBuffers: field "+R+" must be set")},F.Builder.prototype.startVector=function(N,R,k){this.notNested(),this.vector_num_elems=R,this.prep(F.SIZEOF_INT,N*R),this.prep(k,N*R)},F.Builder.prototype.endVector=function(){return this.writeInt32(this.vector_num_elems),this.offset()},F.Builder.prototype.createString=function(N){if(N instanceof Uint8Array)var R=N;else{R=[];for(var k=0;k<N.length;){var S,C=N.charCodeAt(k++);(S=C<55296||C>=56320?C:(C<<10)+N.charCodeAt(k++)+-56613888)<128?R.push(S):(S<2048?R.push(S>>6&31|192):(S<65536?R.push(S>>12&15|224):R.push(S>>18&7|240,S>>12&63|128),R.push(S>>6&63|128)),R.push(63&S|128))}}this.addInt8(0),this.startVector(1,R.length,1),this.bb.setPosition(this.space-=R.length),k=0;for(var v=this.space,g=this.bb.bytes();k<R.length;k++)g[v++]=R[k];return this.endVector()},F.Builder.prototype.createLong=function(N,R){return F.Long.create(N,R)},F.ByteBuffer=function(N){this.bytes_=N,this.position_=0},F.ByteBuffer.allocate=function(N){return new F.ByteBuffer(new Uint8Array(N))},F.ByteBuffer.prototype.clear=function(){this.position_=0},F.ByteBuffer.prototype.bytes=function(){return this.bytes_},F.ByteBuffer.prototype.position=function(){return this.position_},F.ByteBuffer.prototype.setPosition=function(N){this.position_=N},F.ByteBuffer.prototype.capacity=function(){return this.bytes_.length},F.ByteBuffer.prototype.readInt8=function(N){return this.readUint8(N)<<24>>24},F.ByteBuffer.prototype.readUint8=function(N){return this.bytes_[N]},F.ByteBuffer.prototype.readInt16=function(N){return this.readUint16(N)<<16>>16},F.ByteBuffer.prototype.readUint16=function(N){return this.bytes_[N]|this.bytes_[N+1]<<8},F.ByteBuffer.prototype.readInt32=function(N){return this.bytes_[N]|this.bytes_[N+1]<<8|this.bytes_[N+2]<<16|this.bytes_[N+3]<<24},F.ByteBuffer.prototype.readUint32=function(N){return this.readInt32(N)>>>0},F.ByteBuffer.prototype.readInt64=function(N){return new F.Long(this.readInt32(N),this.readInt32(N+4))},F.ByteBuffer.prototype.readUint64=function(N){return new F.Long(this.readUint32(N),this.readUint32(N+4))},F.ByteBuffer.prototype.readFloat32=function(N){return F.int32[0]=this.readInt32(N),F.float32[0]},F.ByteBuffer.prototype.readFloat64=function(N){return F.int32[F.isLittleEndian?0:1]=this.readInt32(N),F.int32[F.isLittleEndian?1:0]=this.readInt32(N+4),F.float64[0]},F.ByteBuffer.prototype.writeInt8=function(N,R){this.bytes_[N]=R},F.ByteBuffer.prototype.writeUint8=function(N,R){this.bytes_[N]=R},F.ByteBuffer.prototype.writeInt16=function(N,R){this.bytes_[N]=R,this.bytes_[N+1]=R>>8},F.ByteBuffer.prototype.writeUint16=function(N,R){this.bytes_[N]=R,this.bytes_[N+1]=R>>8},F.ByteBuffer.prototype.writeInt32=function(N,R){this.bytes_[N]=R,this.bytes_[N+1]=R>>8,this.bytes_[N+2]=R>>16,this.bytes_[N+3]=R>>24},F.ByteBuffer.prototype.writeUint32=function(N,R){this.bytes_[N]=R,this.bytes_[N+1]=R>>8,this.bytes_[N+2]=R>>16,this.bytes_[N+3]=R>>24},F.ByteBuffer.prototype.writeInt64=function(N,R){this.writeInt32(N,R.low),this.writeInt32(N+4,R.high)},F.ByteBuffer.prototype.writeUint64=function(N,R){this.writeUint32(N,R.low),this.writeUint32(N+4,R.high)},F.ByteBuffer.prototype.writeFloat32=function(N,R){F.float32[0]=R,this.writeInt32(N,F.int32[0])},F.ByteBuffer.prototype.writeFloat64=function(N,R){F.float64[0]=R,this.writeInt32(N,F.int32[F.isLittleEndian?0:1]),this.writeInt32(N+4,F.int32[F.isLittleEndian?1:0])},F.ByteBuffer.prototype.getBufferIdentifier=function(){if(this.bytes_.length<this.position_+F.SIZEOF_INT+F.FILE_IDENTIFIER_LENGTH)throw new Error("FlatBuffers: ByteBuffer is too short to contain an identifier.");for(var N="",R=0;R<F.FILE_IDENTIFIER_LENGTH;R++)N+=String.fromCharCode(this.readInt8(this.position_+F.SIZEOF_INT+R));return N},F.ByteBuffer.prototype.__offset=function(N,R){var k=N-this.readInt32(N);return R<this.readInt16(k)?this.readInt16(k+R):0},F.ByteBuffer.prototype.__union=function(N,R){return N.bb_pos=R+this.readInt32(R),N.bb=this,N},F.ByteBuffer.prototype.__string=function(N,R){N+=this.readInt32(N);var k=this.readInt32(N),S="",C=0;if(N+=F.SIZEOF_INT,R===F.Encoding.UTF8_BYTES)return this.bytes_.subarray(N,N+k);for(;C<k;){var v,g=this.readUint8(N+C++);if(g<192)v=g;else{var h=this.readUint8(N+C++);if(g<224)v=(31&g)<<6|63&h;else{var l=this.readUint8(N+C++);v=g<240?(15&g)<<12|(63&h)<<6|63&l:(7&g)<<18|(63&h)<<12|(63&l)<<6|63&this.readUint8(N+C++)}}v<65536?S+=String.fromCharCode(v):(v-=65536,S+=String.fromCharCode(55296+(v>>10),56320+(1023&v)))}return S},F.ByteBuffer.prototype.__indirect=function(N){return N+this.readInt32(N)},F.ByteBuffer.prototype.__vector=function(N){return N+this.readInt32(N)+F.SIZEOF_INT},F.ByteBuffer.prototype.__vector_len=function(N){return this.readInt32(N+this.readInt32(N))},F.ByteBuffer.prototype.__has_identifier=function(N){if(N.length!=F.FILE_IDENTIFIER_LENGTH)throw new Error("FlatBuffers: file identifier must be length "+F.FILE_IDENTIFIER_LENGTH);for(var R=0;R<F.FILE_IDENTIFIER_LENGTH;R++)if(N.charCodeAt(R)!=this.readInt8(this.position_+F.SIZEOF_INT+R))return!1;return!0},F.ByteBuffer.prototype.createLong=function(N,R){return F.Long.create(N,R)}}},__webpack_module_cache__={};function __nested_webpack_require_836307__(ge){var E=__webpack_module_cache__[ge];if(void 0!==E)return E.exports;var $=__webpack_module_cache__[ge]={exports:{}};return __webpack_modules__[ge].call($.exports,$,$.exports,__nested_webpack_require_836307__),$.exports}__nested_webpack_require_836307__.n=ge=>{var E=ge&&ge.__esModule?()=>ge.default:()=>ge;return __nested_webpack_require_836307__.d(E,{a:E}),E},__nested_webpack_require_836307__.d=(ge,E)=>{for(var $ in E)__nested_webpack_require_836307__.o(E,$)&&!__nested_webpack_require_836307__.o(ge,$)&&Object.defineProperty(ge,$,{enumerable:!0,get:E[$]})},__nested_webpack_require_836307__.o=(ge,E)=>Object.prototype.hasOwnProperty.call(ge,E),__nested_webpack_require_836307__.r=ge=>{typeof Symbol<"u"&&Symbol.toStringTag&&Object.defineProperty(ge,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(ge,"__esModule",{value:!0})};var __nested_webpack_exports__=__nested_webpack_require_836307__(1057);return __nested_webpack_exports__})(),module.exports=E()},340:(ge,E,$)=>{var F=$(471),N=$(992),R=$(657),k=$(583),S=$(929),C=$(83),v=$(818);v.alea=F,v.xor128=N,v.xorwow=R,v.xorshift7=k,v.xor4096=S,v.tychei=C,ge.exports=v},471:function(ge,E,$){var F;!function(N,R,k){function S(h){var l=this,d=function g(){var h=4022871197;return function(d){d=String(d);for(var f=0;f<d.length;f++){var b=.02519603282416938*(h+=d.charCodeAt(f));b-=h=b>>>0,h=(b*=h)>>>0,h+=4294967296*(b-=h)}return 2.3283064365386963e-10*(h>>>0)}}();l.next=function(){var f=2091639*l.s0+2.3283064365386963e-10*l.c;return l.s0=l.s1,l.s1=l.s2,l.s2=f-(l.c=0|f)},l.c=1,l.s0=d(" "),l.s1=d(" "),l.s2=d(" "),l.s0-=d(h),l.s0<0&&(l.s0+=1),l.s1-=d(h),l.s1<0&&(l.s1+=1),l.s2-=d(h),l.s2<0&&(l.s2+=1),d=null}function C(h,l){return l.c=h.c,l.s0=h.s0,l.s1=h.s1,l.s2=h.s2,l}function v(h,l){var d=new S(h),f=l&&l.state,b=d.next;return b.int32=function(){return 4294967296*d.next()|0},b.double=function(){return b()+11102230246251565e-32*(2097152*b()|0)},b.quick=b,f&&("object"==typeof f&&C(f,d),b.state=function(){return C(d,{})}),b}R&&R.exports?R.exports=v:$.amdD&&$.amdO?void 0!==(F=function(){return v}.call(E,$,E,R))&&(R.exports=F):this.alea=v}(0,ge=$.nmd(ge))},83:function(ge,E,$){var F;!function(N,R,k){function S(g){var h=this,l="";h.next=function(){var f=h.b,b=h.c,x=h.d,D=h.a;return f=f<<25^f>>>7^b,b=b-x|0,x=x<<24^x>>>8^D,D=D-f|0,h.b=f=f<<20^f>>>12^b,h.c=b=b-x|0,h.d=x<<16^b>>>16^D,h.a=D-f|0},h.a=0,h.b=0,h.c=-1640531527,h.d=1367130551,g===Math.floor(g)?(h.a=g/4294967296|0,h.b=0|g):l+=g;for(var d=0;d<l.length+20;d++)h.b^=0|l.charCodeAt(d),h.next()}function C(g,h){return h.a=g.a,h.b=g.b,h.c=g.c,h.d=g.d,h}function v(g,h){var l=new S(g),d=h&&h.state,f=function(){return(l.next()>>>0)/4294967296};return f.double=function(){do{var D=((l.next()>>>11)+(l.next()>>>0)/4294967296)/(1<<21)}while(0===D);return D},f.int32=l.next,f.quick=f,d&&("object"==typeof d&&C(d,l),f.state=function(){return C(l,{})}),f}R&&R.exports?R.exports=v:$.amdD&&$.amdO?void 0!==(F=function(){return v}.call(E,$,E,R))&&(R.exports=F):this.tychei=v}(0,ge=$.nmd(ge))},992:function(ge,E,$){var F;!function(N,R,k){function S(g){var h=this,l="";h.x=0,h.y=0,h.z=0,h.w=0,h.next=function(){var f=h.x^h.x<<11;return h.x=h.y,h.y=h.z,h.z=h.w,h.w^=h.w>>>19^f^f>>>8},g===(0|g)?h.x=g:l+=g;for(var d=0;d<l.length+64;d++)h.x^=0|l.charCodeAt(d),h.next()}function C(g,h){return h.x=g.x,h.y=g.y,h.z=g.z,h.w=g.w,h}function v(g,h){var l=new S(g),d=h&&h.state,f=function(){return(l.next()>>>0)/4294967296};return f.double=function(){do{var D=((l.next()>>>11)+(l.next()>>>0)/4294967296)/(1<<21)}while(0===D);return D},f.int32=l.next,f.quick=f,d&&("object"==typeof d&&C(d,l),f.state=function(){return C(l,{})}),f}R&&R.exports?R.exports=v:$.amdD&&$.amdO?void 0!==(F=function(){return v}.call(E,$,E,R))&&(R.exports=F):this.xor128=v}(0,ge=$.nmd(ge))},929:function(ge,E,$){var F;!function(N,R,k){function S(g){var h=this;h.next=function(){var x,D,d=h.w,f=h.X,b=h.i;return h.w=d=d+1640531527|0,D=f[b+34&127],x=f[b=b+1&127],D^=D<<13,x^=x<<17,D=f[b]=(D^=D>>>15)^(x^=x>>>12),h.i=b,D+(d^d>>>16)|0},function l(d,f){var b,x,D,P,L,B=[],U=128;for(f===(0|f)?(x=f,f=null):(f+="\0",x=0,U=Math.max(U,f.length)),D=0,P=-32;P<U;++P)f&&(x^=f.charCodeAt((P+32)%f.length)),0===P&&(L=x),x^=x<<10,x^=x>>>15,x^=x<<4,x^=x>>>13,P>=0&&(D=0==(b=B[127&P]^=x+(L=L+1640531527|0))?D+1:0);for(D>=128&&(B[127&(f&&f.length||0)]=-1),D=127,P=512;P>0;--P)x=B[D+34&127],b=B[D=D+1&127],x^=x<<13,b^=b<<17,B[D]=(x^=x>>>15)^(b^=b>>>12);d.w=L,d.X=B,d.i=D}(h,g)}function C(g,h){return h.i=g.i,h.w=g.w,h.X=g.X.slice(),h}function v(g,h){null==g&&(g=+new Date);var l=new S(g),d=h&&h.state,f=function(){return(l.next()>>>0)/4294967296};return f.double=function(){do{var D=((l.next()>>>11)+(l.next()>>>0)/4294967296)/(1<<21)}while(0===D);return D},f.int32=l.next,f.quick=f,d&&(d.X&&C(d,l),f.state=function(){return C(l,{})}),f}R&&R.exports?R.exports=v:$.amdD&&$.amdO?void 0!==(F=function(){return v}.call(E,$,E,R))&&(R.exports=F):this.xor4096=v}(0,ge=$.nmd(ge))},583:function(ge,E,$){var F;!function(N,R,k){function S(g){var h=this;h.next=function(){var b,x,d=h.x,f=h.i;return b=d[f],x=(b^=b>>>7)^b<<24,x^=(b=d[f+1&7])^b>>>10,x^=(b=d[f+3&7])^b>>>3,x^=(b=d[f+4&7])^b<<7,b=d[f+7&7],d[f]=x^=(b^=b<<13)^b<<9,h.i=f+1&7,x},function l(d,f){var b,D=[];if(f===(0|f))D[0]=f;else for(f=""+f,b=0;b<f.length;++b)D[7&b]=D[7&b]<<15^f.charCodeAt(b)+D[b+1&7]<<13;for(;D.length<8;)D.push(0);for(b=0;b<8&&0===D[b];++b);for(8==b&&(D[7]=-1),d.x=D,d.i=0,b=256;b>0;--b)d.next()}(h,g)}function C(g,h){return h.x=g.x.slice(),h.i=g.i,h}function v(g,h){null==g&&(g=+new Date);var l=new S(g),d=h&&h.state,f=function(){return(l.next()>>>0)/4294967296};return f.double=function(){do{var D=((l.next()>>>11)+(l.next()>>>0)/4294967296)/(1<<21)}while(0===D);return D},f.int32=l.next,f.quick=f,d&&(d.x&&C(d,l),f.state=function(){return C(l,{})}),f}R&&R.exports?R.exports=v:$.amdD&&$.amdO?void 0!==(F=function(){return v}.call(E,$,E,R))&&(R.exports=F):this.xorshift7=v}(0,ge=$.nmd(ge))},657:function(ge,E,$){var F;!function(N,R,k){function S(g){var h=this,l="";h.next=function(){var f=h.x^h.x>>>2;return h.x=h.y,h.y=h.z,h.z=h.w,h.w=h.v,(h.d=h.d+362437|0)+(h.v=h.v^h.v<<4^f^f<<1)|0},h.x=0,h.y=0,h.z=0,h.w=0,h.v=0,g===(0|g)?h.x=g:l+=g;for(var d=0;d<l.length+64;d++)h.x^=0|l.charCodeAt(d),d==l.length&&(h.d=h.x<<10^h.x>>>4),h.next()}function C(g,h){return h.x=g.x,h.y=g.y,h.z=g.z,h.w=g.w,h.v=g.v,h.d=g.d,h}function v(g,h){var l=new S(g),d=h&&h.state,f=function(){return(l.next()>>>0)/4294967296};return f.double=function(){do{var D=((l.next()>>>11)+(l.next()>>>0)/4294967296)/(1<<21)}while(0===D);return D},f.int32=l.next,f.quick=f,d&&("object"==typeof d&&C(d,l),f.state=function(){return C(l,{})}),f}R&&R.exports?R.exports=v:$.amdD&&$.amdO?void 0!==(F=function(){return v}.call(E,$,E,R))&&(R.exports=F):this.xorwow=v}(0,ge=$.nmd(ge))},818:function(ge,E,$){var F;!function(N,R,k){var b,S=256,h=k.pow(S,6),l=k.pow(2,52),d=2*l,f=S-1;function x(H,re,ue){var te=[],se=B(L((re=1==re?{entropy:!0}:re||{}).entropy?[H,W(R)]:H??function U(){try{var H;return b&&(H=b.randomBytes)?H=H(S):(H=new Uint8Array(S),(N.crypto||N.msCrypto).getRandomValues(H)),W(H)}catch{var re=N.navigator,ue=re&&re.plugins;return[+new Date,N,ue,N.screen,W(R)]}}(),3),te),Y=new D(te),X=function(){for(var we=Y.g(6),K=h,ie=0;we<l;)we=(we+ie)*S,K*=S,ie=Y.g(1);for(;we>=d;)we/=2,K/=2,ie>>>=1;return(we+ie)/K};return X.int32=function(){return 0|Y.g(4)},X.quick=function(){return Y.g(4)/4294967296},X.double=X,B(W(Y.S),R),(re.pass||ue||function(we,K,ie,ce){return ce&&(ce.S&&P(ce,Y),we.state=function(){return P(Y,{})}),ie?(k.random=we,K):we})(X,se,"global"in re?re.global:this==k,re.state)}function D(H){var re,ue=H.length,te=this,se=0,Y=te.i=te.j=0,X=te.S=[];for(ue||(H=[ue++]);se<S;)X[se]=se++;for(se=0;se<S;se++)X[se]=X[Y=f&Y+H[se%ue]+(re=X[se])],X[Y]=re;(te.g=function(we){for(var K,ie=0,ce=te.i,qe=te.j,Be=te.S;we--;)K=Be[ce=f&ce+1],ie=ie*S+Be[f&(Be[ce]=Be[qe=f&qe+K])+(Be[qe]=K)];return te.i=ce,te.j=qe,ie})(S)}function P(H,re){return re.i=H.i,re.j=H.j,re.S=H.S.slice(),re}function L(H,re){var se,ue=[],te=typeof H;if(re&&"object"==te)for(se in H)try{ue.push(L(H[se],re-1))}catch{}return ue.length?ue:"string"==te?H:H+"\0"}function B(H,re){for(var te,ue=H+"",se=0;se<ue.length;)re[f&se]=f&(te^=19*re[f&se])+ue.charCodeAt(se++);return W(re)}function W(H){return String.fromCharCode.apply(0,H)}if(B(k.random(),R),ge.exports){ge.exports=x;try{b=$(42)}catch{}}else void 0!==(F=function(){return x}.call(E,$,E,ge))&&(ge.exports=F)}(typeof self<"u"?self:this,[],Math)},410:()=>{},628:()=>{},601:()=>{},792:()=>{},977:()=>{},42:()=>{},156:ge=>{function E(F,N,R,k,S,C,v){try{var g=F[C](v),h=g.value}catch(l){return void R(l)}g.done?N(h):Promise.resolve(h).then(k,S)}ge.exports=function $(F){return function(){var N=this,R=arguments;return new Promise(function(k,S){var C=F.apply(N,R);function v(h){E(C,k,S,v,g,"next",h)}function g(h){E(C,k,S,v,g,"throw",h)}v(void 0)})}},ge.exports.__esModule=!0,ge.exports.default=ge.exports}},ge=>{ge(ge.s=52)}]);