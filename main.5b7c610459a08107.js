(self.webpackChunkwams_ml_app=self.webpackChunkwams_ml_app||[]).push([[179],{189:(xt,vt,Q)=>{"use strict";var We={};Q.r(We),Q.d(We,{browserFiles:()=>mne,browserHTTPRequest:()=>xne,concatenateArrayBuffers:()=>Eb,copyModel:()=>Bte,decodeWeights:()=>rP,encodeWeights:()=>oI,fromMemory:()=>Sne,fromMemorySync:()=>MP,getLoadHandlers:()=>Dte,getModelArtifactsForJSON:()=>uI,getModelArtifactsForJSONSync:()=>lP,getModelArtifactsInfoForJSON:()=>np,getSaveHandlers:()=>cP,getWeightSpecs:()=>uP,http:()=>DI,isHTTPScheme:()=>EI,listModels:()=>Lte,loadWeights:()=>bne,moveModel:()=>zte,registerLoadRouter:()=>Ete,registerSaveRouter:()=>Ite,removeModel:()=>Vte,weightsLoaderFactory:()=>NP,withSaveHandler:()=>Ine,withSaveHandlerSync:()=>Ene});var qn={};Q.r(qn),Q.d(qn,{assertParamsValid:()=>kI,computeFlatOffset:()=>MI,computeOutShape:()=>AI,getNormalizedAxes:()=>Nne,isSliceContinous:()=>RI,maskToAxes:()=>Tne,parseSliceParams:()=>kb,sliceInfo:()=>FI,startForAxis:()=>BP,startIndicesWithElidedDims:()=>PP,stopForAxis:()=>zP,stopIndicesWithElidedDims:()=>LP,stridesForAxis:()=>VP,stridesWithElidedDims:()=>FP});var Xe={};Q.r(Xe),Q.d(Xe,{conv2d:()=>zL,depthwiseConv2d:()=>Zoe,matMul:()=>_E});var hn={};Q.r(hn),Q.d(hn,{collectGatherOpShapeInfo:()=>XE,computeOutShape:()=>xV,segOpComputeOptimalWindowSize:()=>wV});var ht={};Q.r(ht),Q.d(ht,{ERF_A1:()=>OE,ERF_A2:()=>$E,ERF_A3:()=>PE,ERF_A4:()=>LE,ERF_A5:()=>VE,ERF_P:()=>FE,PARALLELIZE_THRESHOLD:()=>NE,RowPartitionType:()=>wn,SELU_SCALE:()=>sv,SELU_SCALEALPHA:()=>nv,applyActivation:()=>Jb,assertAndGetBroadcastShape:()=>nt,assertAxesAreInnerMostDims:()=>Ns,assertParamsConsistent:()=>TE,assignToTypedArray:()=>iV,axesAreInnerMostDims:()=>GI,calculateShapes:()=>uu,checkEinsumDimSizes:()=>GE,checkPadOnDimRoundingMode:()=>Xs,combineLocations:()=>mL,combineRaggedTensorToTensorShapes:()=>QL,complexWithEvenIndex:()=>sV,complexWithOddIndex:()=>rV,computeConv2DInfo:()=>_s,computeConv3DInfo:()=>Xa,computeDefaultPad:()=>$I,computeDilation2DInfo:()=>sp,computeOptimalWindowSize:()=>tv,computeOutAndReduceShapes:()=>ws,computeOutShape:()=>So,computePool2DInfo:()=>pi,computePool3DInfo:()=>aa,convertConv2DDataFormat:()=>la,decodeEinsumEquation:()=>UE,eitherStridesOrDilationsAreOne:()=>Ts,expandShapeToKeepDim:()=>On,exponent:()=>aV,exponents:()=>oV,fromStringArrayToUint8:()=>CV,fromUint8ToStringArray:()=>da,getAxesPermutation:()=>vn,getBroadcastDims:()=>Zc,getComplexWithIndex:()=>BE,getEinsumComputePath:()=>HE,getEinsumPermutation:()=>WE,getFusedBiasGradient:()=>Qb,getFusedDyActivation:()=>Zb,getImageCenter:()=>kE,getInnerMostAxes:()=>$n,getPermuted:()=>bp,getRaggedRank:()=>eV,getReductionAxes:()=>ss,getReshaped:()=>yp,getReshapedPermuted:()=>vp,getRowPartitionTypesHelper:()=>JL,getSliceBeginCoords:()=>AE,getSliceSize:()=>RE,getSparseFillEmptyRowsIndicesDenseShapeMismatch:()=>cV,getSparseFillEmptyRowsNegativeIndexErrorMessage:()=>dV,getSparseFillEmptyRowsOutOfRangeIndexErrorMessage:()=>hV,getSparseReshapeEmptyTensorZeroOutputDimErrorMessage:()=>mV,getSparseReshapeInputOutputMismatchErrorMessage:()=>yV,getSparseReshapeInputOutputMultipleErrorMessage:()=>gV,getSparseReshapeMultipleNegativeOneOutputDimErrorMessage:()=>fV,getSparseReshapeNegativeOutputDimErrorMessage:()=>pV,getSparseSegmentReductionIndicesOutOfRangeErrorMessage:()=>_V,getSparseSegmentReductionNegativeSegmentIdsErrorMessage:()=>KE,getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage:()=>bV,getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage:()=>vV,getUndoAxesPermutation:()=>Qa,isIdentityPermutation:()=>jE,log:()=>Hee,mergeRealAndImagArrays:()=>ca,prepareAndValidate:()=>ME,prepareSplitSize:()=>qE,segment_util:()=>hn,shouldFuse:()=>ev,slice_util:()=>qn,splitRealAndImagArrays:()=>nV,stridesOrDilationsArePositive:()=>ru,tupleValuesAreOne:()=>Ya,upcastType:()=>Ir,validateDefaultValueShape:()=>tV,validateInput:()=>dE,validateUpdateShape:()=>FL,warn:()=>Gr});var Ue={};Q.r(Ue),Q.d(Ue,{json:()=>Ohe});var lt={};Q.r(lt),Q.d(lt,{json:()=>$he});var Te={};Q.r(Te),Q.d(Te,{json:()=>Phe});var U={};Q.r(U),Q.d(U,{json:()=>Lhe});var ge={};Q.r(ge),Q.d(ge,{json:()=>Vhe});var _e={};Q.r(_e),Q.d(_e,{json:()=>Bhe});var re={};Q.r(re),Q.d(re,{json:()=>zhe});var me={};Q.r(me),Q.d(me,{json:()=>Uhe});var Ae={};Q.r(Ae),Q.d(Ae,{json:()=>Whe});var $e={};Q.r($e),Q.d($e,{json:()=>Ghe});var Bt={};Q.r(Bt),Q.d(Bt,{json:()=>Hhe});var Kn={};Q.r(Kn),Q.d(Kn,{json:()=>jhe});var Bn={};Q.r(Bn),Q.d(Bn,{json:()=>qhe});var si={};Q.r(si),Q.d(si,{json:()=>Khe});var Rr={};Q.r(Rr),Q.d(Rr,{json:()=>Xhe});var Ct={};Q.r(Ct),Q.d(Ct,{json:()=>Yhe});var Ft={};Q.r(Ft),Q.d(Ft,{json:()=>Zhe});var Ot={};Q.r(Ot),Q.d(Ot,{json:()=>Qhe});var ce={};Q.r(ce),Q.d(ce,{json:()=>Jhe});var J={};Q.r(J),Q.d(J,{OP_SCOPE_SUFFIX:()=>sP,abs:()=>ns,acos:()=>WP,acosh:()=>GP,add:()=>le,addN:()=>One,all:()=>OI,any:()=>Ab,argMax:()=>Qc,argMin:()=>HP,asin:()=>jP,asinh:()=>qP,atan:()=>KP,atan2:()=>XP,atanh:()=>YP,avgPool:()=>Rb,avgPool3d:()=>ZP,basicLSTMCell:()=>rse,batchNorm:()=>op,batchNorm2d:()=>QP,batchNorm3d:()=>JP,batchNorm4d:()=>eL,batchToSpaceND:()=>Mb,bincount:()=>tL,bitwiseAnd:()=>fse,booleanMaskAsync:()=>Aoe,broadcastArgs:()=>mse,broadcastTo:()=>td,buffer:()=>dt,cast:()=>xe,ceil:()=>nL,clipByValue:()=>Er,clone:()=>ra,complex:()=>Ga,concat:()=>jn,concat1d:()=>sL,concat2d:()=>rL,concat3d:()=>iL,concat4d:()=>oL,conv1d:()=>LI,conv2d:()=>Za,conv2dTranspose:()=>BI,conv3d:()=>aL,conv3dTranspose:()=>uL,cos:()=>Fb,cosh:()=>zI,cosineWindow:()=>yE,cumprod:()=>Ob,cumsum:()=>UI,denseBincount:()=>WI,depthToSpace:()=>cL,depthwiseConv2d:()=>ap,diag:()=>Lse,dilation2d:()=>dL,div:()=>Pe,divNoNan:()=>hL,dot:()=>fL,dropout:()=>VL,einsum:()=>Hse,elu:()=>lp,enclosingPowerOfTwo:()=>BL,ensureShape:()=>Kse,equal:()=>Wi,erf:()=>pL,euclideanNorm:()=>yL,exp:()=>Hr,expandDims:()=>ar,expm1:()=>bL,eye:()=>HI,fft:()=>Xb,fill:()=>Yc,floor:()=>dp,floorDiv:()=>wI,fused:()=>Xe,gather:()=>hp,gatherND:()=>zoe,greater:()=>Dr,greaterEqual:()=>Ja,ifft:()=>gp,imag:()=>$b,image:()=>Co,inTopKAsync:()=>Hoe,irfft:()=>uE,isFinite:()=>vL,isInf:()=>_L,isNaN:()=>wL,leakyRelu:()=>Pb,less:()=>fp,lessEqual:()=>iu,linalg:()=>YL,linspace:()=>yre,localResponseNormalization:()=>xL,log:()=>jr,log1p:()=>Lb,logSigmoid:()=>CL,logSoftmax:()=>jI,logSumExp:()=>qI,logicalAnd:()=>wo,logicalNot:()=>Vb,logicalOr:()=>KI,logicalXor:()=>SL,losses:()=>Dle,lowerBound:()=>Are,matMul:()=>bt,max:()=>mi,maxPool:()=>zb,maxPool3d:()=>IL,maxPoolWithArgmax:()=>Ore,maximum:()=>oa,mean:()=>Nn,meshgrid:()=>Pre,min:()=>up,minimum:()=>ou,mirrorPad:()=>EL,mod:()=>DL,moments:()=>Ub,movingAverage:()=>Foe,mul:()=>F,multiRNNCell:()=>Wre,multinomial:()=>Hre,neg:()=>dn,norm:()=>cp,notEqual:()=>sd,oneHot:()=>YI,ones:()=>qr,onesLike:()=>Kr,op:()=>k,outerProduct:()=>Yre,pad:()=>el,pad1d:()=>Jre,pad2d:()=>tie,pad3d:()=>sie,pad4d:()=>iie,pool:()=>TL,pow:()=>Ka,prelu:()=>Gb,print:()=>bP,prod:()=>NL,raggedGather:()=>fie,raggedRange:()=>mie,raggedTensorToTensor:()=>yie,rand:()=>vie,randomGamma:()=>Eie,randomNormal:()=>JI,randomStandardNormal:()=>Nie,randomUniform:()=>au,randomUniformInt:()=>Rie,range:()=>rd,real:()=>pp,reciprocal:()=>kL,relu:()=>xo,relu6:()=>eE,reshape:()=>O,reverse:()=>yi,reverse1d:()=>Vie,reverse2d:()=>zie,reverse3d:()=>Wie,reverse4d:()=>Hie,rfft:()=>Yb,round:()=>tE,rsqrt:()=>nE,scalar:()=>ze,scatterND:()=>$oe,searchSorted:()=>XI,selu:()=>sE,separableConv2d:()=>rE,setdiff1dAsync:()=>Zie,sigmoid:()=>_o,sign:()=>AL,signal:()=>Ele,sin:()=>oE,sinh:()=>aE,slice:()=>Dt,slice1d:()=>jb,slice2d:()=>lE,slice3d:()=>qb,slice4d:()=>mp,softmax:()=>Kb,softplus:()=>nd,spaceToBatchND:()=>Wb,sparse:()=>Tle,sparseToDense:()=>Voe,spectral:()=>Ile,split:()=>Tr,sqrt:()=>Bs,square:()=>en,squaredDifference:()=>cE,squeeze:()=>lu,stack:()=>Xr,step:()=>id,stridedSlice:()=>RL,string:()=>Nle,sub:()=>Ne,sum:()=>Re,tan:()=>ML,tanh:()=>ed,tensor:()=>Ui,tensor1d:()=>lr,tensor2d:()=>od,tensor3d:()=>yoe,tensor4d:()=>boe,tensor5d:()=>voe,tensor6d:()=>_oe,tensorScatterUpdate:()=>xoe,tile:()=>gi,topk:()=>OL,transpose:()=>Tt,truncatedNormal:()=>hE,unique:()=>$L,unsortedSegmentSum:()=>fE,unstack:()=>bi,upperBound:()=>Toe,variable:()=>PL,where:()=>zs,whereAsync:()=>LL,zeros:()=>rs,zerosLike:()=>Et});var T={};function pe(n){return"function"==typeof n}function He(n){const e=n(s=>{Error.call(s),s.stack=(new Error).stack});return e.prototype=Object.create(Error.prototype),e.prototype.constructor=e,e}Q.r(T),Q.d(T,{addImpl:()=>Fz,bincountImpl:()=>uT,bincountReduceImpl:()=>Bz,castImpl:()=>Mz,ceilImpl:()=>zz,concatImpl:()=>Uz,equalImpl:()=>Hz,expImpl:()=>qz,expm1Impl:()=>Xz,floorImpl:()=>Qz,gatherNdImpl:()=>Jz,gatherV2Impl:()=>e3,greaterEqualImpl:()=>n3,greaterImpl:()=>t3,lessEqualImpl:()=>r3,lessImpl:()=>s3,linSpaceImpl:()=>o3,logImpl:()=>a3,maxImpl:()=>l3,maximumImpl:()=>c3,minimumImpl:()=>d3,multiplyImpl:()=>cT,negImpl:()=>f3,notEqualImpl:()=>p3,prodImpl:()=>b3,raggedGatherImpl:()=>_3,raggedRangeImpl:()=>x3,raggedTensorToTensorImpl:()=>I3,rangeImpl:()=>E3,rsqrtImpl:()=>D3,scatterImpl:()=>_u,sigmoidImpl:()=>Spe,simpleAbsImpl:()=>$z,sliceImpl:()=>Vz,sparseFillEmptyRowsImpl:()=>N3,sparseReshapeImpl:()=>k3,sparseSegmentReductionImpl:()=>gT,sqrtImpl:()=>Yve,staticRegexReplaceImpl:()=>A3,stridedSliceImpl:()=>R3,stringNGramsImpl:()=>M3,stringSplitImpl:()=>F3,stringToHashBucketFastImpl:()=>O3,subImpl:()=>Yz,tileImpl:()=>$3,topKImpl:()=>L3,transposeImpl:()=>aT,uniqueImpl:()=>B3});const St=He(n=>function(e){n(this),this.message=e?`${e.length} errors occurred during unsubscription:\n${e.map((s,r)=>`${r+1}) ${s.toString()}`).join("\n  ")}`:"",this.name="UnsubscriptionError",this.errors=e});function ft(n,t){if(n){const e=n.indexOf(t);0<=e&&n.splice(e,1)}}class ut{constructor(t){this.initialTeardown=t,this.closed=!1,this._parentage=null,this._finalizers=null}unsubscribe(){let t;if(!this.closed){this.closed=!0;const{_parentage:e}=this;if(e)if(this._parentage=null,Array.isArray(e))for(const i of e)i.remove(this);else e.remove(this);const{initialTeardown:s}=this;if(pe(s))try{s()}catch(i){t=i instanceof St?i.errors:[i]}const{_finalizers:r}=this;if(r){this._finalizers=null;for(const i of r)try{cs(i)}catch(o){t=t??[],o instanceof St?t=[...t,...o.errors]:t.push(o)}}if(t)throw new St(t)}}add(t){var e;if(t&&t!==this)if(this.closed)cs(t);else{if(t instanceof ut){if(t.closed||t._hasParent(this))return;t._addParent(this)}(this._finalizers=null!==(e=this._finalizers)&&void 0!==e?e:[]).push(t)}}_hasParent(t){const{_parentage:e}=this;return e===t||Array.isArray(e)&&e.includes(t)}_addParent(t){const{_parentage:e}=this;this._parentage=Array.isArray(e)?(e.push(t),e):e?[e,t]:t}_removeParent(t){const{_parentage:e}=this;e===t?this._parentage=null:Array.isArray(e)&&ft(e,t)}remove(t){const{_finalizers:e}=this;e&&ft(e,t),t instanceof ut&&t._removeParent(this)}}ut.EMPTY=(()=>{const n=new ut;return n.closed=!0,n})();const An=ut.EMPTY;function zn(n){return n instanceof ut||n&&"closed"in n&&pe(n.remove)&&pe(n.add)&&pe(n.unsubscribe)}function cs(n){pe(n)?n():n.unsubscribe()}const Zt={onUnhandledError:null,onStoppedNotification:null,Promise:void 0,useDeprecatedSynchronousErrorHandling:!1,useDeprecatedNextContext:!1},Ms={setTimeout(n,t,...e){const{delegate:s}=Ms;return s?.setTimeout?s.setTimeout(n,t,...e):setTimeout(n,t,...e)},clearTimeout(n){const{delegate:t}=Ms;return(t?.clearTimeout||clearTimeout)(n)},delegate:void 0};function Un(n){Ms.setTimeout(()=>{const{onUnhandledError:t}=Zt;if(!t)throw n;t(n)})}function Fs(){}const Fu=$_("C",void 0,void 0);function $_(n,t,e){return{kind:n,value:t,error:e}}let Il=null;function lm(n){if(Zt.useDeprecatedSynchronousErrorHandling){const t=!Il;if(t&&(Il={errorThrown:!1,error:null}),n(),t){const{errorThrown:e,error:s}=Il;if(Il=null,e)throw s}}else n()}class P_ extends ut{constructor(t){super(),this.isStopped=!1,t?(this.destination=t,zn(t)&&t.add(this)):this.destination=CG}static create(t,e,s){return new Md(t,e,s)}next(t){this.isStopped?V_(function bG(n){return $_("N",n,void 0)}(t),this):this._next(t)}error(t){this.isStopped?V_(function yG(n){return $_("E",void 0,n)}(t),this):(this.isStopped=!0,this._error(t))}complete(){this.isStopped?V_(Fu,this):(this.isStopped=!0,this._complete())}unsubscribe(){this.closed||(this.isStopped=!0,super.unsubscribe(),this.destination=null)}_next(t){this.destination.next(t)}_error(t){try{this.destination.error(t)}finally{this.unsubscribe()}}_complete(){try{this.destination.complete()}finally{this.unsubscribe()}}}const _G=Function.prototype.bind;function L_(n,t){return _G.call(n,t)}class wG{constructor(t){this.partialObserver=t}next(t){const{partialObserver:e}=this;if(e.next)try{e.next(t)}catch(s){um(s)}}error(t){const{partialObserver:e}=this;if(e.error)try{e.error(t)}catch(s){um(s)}else um(t)}complete(){const{partialObserver:t}=this;if(t.complete)try{t.complete()}catch(e){um(e)}}}class Md extends P_{constructor(t,e,s){let r;if(super(),pe(t)||!t)r={next:t??void 0,error:e??void 0,complete:s??void 0};else{let i;this&&Zt.useDeprecatedNextContext?(i=Object.create(t),i.unsubscribe=()=>this.unsubscribe(),r={next:t.next&&L_(t.next,i),error:t.error&&L_(t.error,i),complete:t.complete&&L_(t.complete,i)}):r=t}this.destination=new wG(r)}}function um(n){Zt.useDeprecatedSynchronousErrorHandling?function vG(n){Zt.useDeprecatedSynchronousErrorHandling&&Il&&(Il.errorThrown=!0,Il.error=n)}(n):Un(n)}function V_(n,t){const{onStoppedNotification:e}=Zt;e&&Ms.setTimeout(()=>e(n,t))}const CG={closed:!0,next:Fs,error:function xG(n){throw n},complete:Fs},B_="function"==typeof Symbol&&Symbol.observable||"@@observable";function El(n){return n}function RN(n){return 0===n.length?El:1===n.length?n[0]:function(e){return n.reduce((s,r)=>r(s),e)}}let Wn=(()=>{class n{constructor(e){e&&(this._subscribe=e)}lift(e){const s=new n;return s.source=this,s.operator=e,s}subscribe(e,s,r){const i=function EG(n){return n&&n instanceof P_||function IG(n){return n&&pe(n.next)&&pe(n.error)&&pe(n.complete)}(n)&&zn(n)}(e)?e:new Md(e,s,r);return lm(()=>{const{operator:o,source:a}=this;i.add(o?o.call(i,a):a?this._subscribe(i):this._trySubscribe(i))}),i}_trySubscribe(e){try{return this._subscribe(e)}catch(s){e.error(s)}}forEach(e,s){return new(s=MN(s))((r,i)=>{const o=new Md({next:a=>{try{e(a)}catch(l){i(l),o.unsubscribe()}},error:i,complete:r});this.subscribe(o)})}_subscribe(e){var s;return null===(s=this.source)||void 0===s?void 0:s.subscribe(e)}[B_](){return this}pipe(...e){return RN(e)(this)}toPromise(e){return new(e=MN(e))((s,r)=>{let i;this.subscribe(o=>i=o,o=>r(o),()=>s(i))})}}return n.create=t=>new n(t),n})();function MN(n){var t;return null!==(t=n??Zt.Promise)&&void 0!==t?t:Promise}const DG=He(n=>function(){n(this),this.name="ObjectUnsubscribedError",this.message="object unsubscribed"});let Ti=(()=>{class n extends Wn{constructor(){super(),this.closed=!1,this.currentObservers=null,this.observers=[],this.isStopped=!1,this.hasError=!1,this.thrownError=null}lift(e){const s=new FN(this,this);return s.operator=e,s}_throwIfClosed(){if(this.closed)throw new DG}next(e){lm(()=>{if(this._throwIfClosed(),!this.isStopped){this.currentObservers||(this.currentObservers=Array.from(this.observers));for(const s of this.currentObservers)s.next(e)}})}error(e){lm(()=>{if(this._throwIfClosed(),!this.isStopped){this.hasError=this.isStopped=!0,this.thrownError=e;const{observers:s}=this;for(;s.length;)s.shift().error(e)}})}complete(){lm(()=>{if(this._throwIfClosed(),!this.isStopped){this.isStopped=!0;const{observers:e}=this;for(;e.length;)e.shift().complete()}})}unsubscribe(){this.isStopped=this.closed=!0,this.observers=this.currentObservers=null}get observed(){var e;return(null===(e=this.observers)||void 0===e?void 0:e.length)>0}_trySubscribe(e){return this._throwIfClosed(),super._trySubscribe(e)}_subscribe(e){return this._throwIfClosed(),this._checkFinalizedStatuses(e),this._innerSubscribe(e)}_innerSubscribe(e){const{hasError:s,isStopped:r,observers:i}=this;return s||r?An:(this.currentObservers=null,i.push(e),new ut(()=>{this.currentObservers=null,ft(i,e)}))}_checkFinalizedStatuses(e){const{hasError:s,thrownError:r,isStopped:i}=this;s?e.error(r):i&&e.complete()}asObservable(){const e=new Wn;return e.source=this,e}}return n.create=(t,e)=>new FN(t,e),n})();class FN extends Ti{constructor(t,e){super(),this.destination=t,this.source=e}next(t){var e,s;null===(s=null===(e=this.destination)||void 0===e?void 0:e.next)||void 0===s||s.call(e,t)}error(t){var e,s;null===(s=null===(e=this.destination)||void 0===e?void 0:e.error)||void 0===s||s.call(e,t)}complete(){var t,e;null===(e=null===(t=this.destination)||void 0===t?void 0:t.complete)||void 0===e||e.call(t)}_subscribe(t){var e,s;return null!==(s=null===(e=this.source)||void 0===e?void 0:e.subscribe(t))&&void 0!==s?s:An}}function ON(n){return pe(n?.lift)}function ds(n){return t=>{if(ON(t))return t.lift(function(e){try{return n(e,this)}catch(s){this.error(s)}});throw new TypeError("Unable to lift unknown Observable type")}}function Xn(n,t,e,s,r){return new TG(n,t,e,s,r)}class TG extends P_{constructor(t,e,s,r,i,o){super(t),this.onFinalize=i,this.shouldUnsubscribe=o,this._next=e?function(a){try{e(a)}catch(l){t.error(l)}}:super._next,this._error=r?function(a){try{r(a)}catch(l){t.error(l)}finally{this.unsubscribe()}}:super._error,this._complete=s?function(){try{s()}catch(a){t.error(a)}finally{this.unsubscribe()}}:super._complete}unsubscribe(){var t;if(!this.shouldUnsubscribe||this.shouldUnsubscribe()){const{closed:e}=this;super.unsubscribe(),!e&&(null===(t=this.onFinalize)||void 0===t||t.call(this))}}}function Ht(n,t){return ds((e,s)=>{let r=0;e.subscribe(Xn(s,i=>{s.next(n.call(t,i,r++))}))})}function Dl(n){return this instanceof Dl?(this.v=n,this):new Dl(n)}function RG(n){if(!Symbol.asyncIterator)throw new TypeError("Symbol.asyncIterator is not defined.");var e,t=n[Symbol.asyncIterator];return t?t.call(n):(n=function LN(n){var t="function"==typeof Symbol&&Symbol.iterator,e=t&&n[t],s=0;if(e)return e.call(n);if(n&&"number"==typeof n.length)return{next:function(){return n&&s>=n.length&&(n=void 0),{value:n&&n[s++],done:!n}}};throw new TypeError(t?"Object is not iterable.":"Symbol.iterator is not defined.")}(n),e={},s("next"),s("throw"),s("return"),e[Symbol.asyncIterator]=function(){return this},e);function s(i){e[i]=n[i]&&function(o){return new Promise(function(a,l){!function r(i,o,a,l){Promise.resolve(l).then(function(u){i({value:u,done:a})},o)}(a,l,(o=n[i](o)).done,o.value)})}}}const VN=n=>n&&"number"==typeof n.length&&"function"!=typeof n;function BN(n){return pe(n?.then)}function zN(n){return pe(n[B_])}function UN(n){return Symbol.asyncIterator&&pe(n?.[Symbol.asyncIterator])}function WN(n){return new TypeError(`You provided ${null!==n&&"object"==typeof n?"an invalid object":`'${n}'`} where a stream was expected. You can provide an Observable, Promise, ReadableStream, Array, AsyncIterable, or Iterable.`)}const GN=function FG(){return"function"==typeof Symbol&&Symbol.iterator?Symbol.iterator:"@@iterator"}();function HN(n){return pe(n?.[GN])}function jN(n){return function AG(n,t,e){if(!Symbol.asyncIterator)throw new TypeError("Symbol.asyncIterator is not defined.");var r,s=e.apply(n,t||[]),i=[];return r={},o("next"),o("throw"),o("return"),r[Symbol.asyncIterator]=function(){return this},r;function o(h){s[h]&&(r[h]=function(f){return new Promise(function(p,g){i.push([h,f,p,g])>1||a(h,f)})})}function a(h,f){try{!function l(h){h.value instanceof Dl?Promise.resolve(h.value.v).then(u,c):d(i[0][2],h)}(s[h](f))}catch(p){d(i[0][3],p)}}function u(h){a("next",h)}function c(h){a("throw",h)}function d(h,f){h(f),i.shift(),i.length&&a(i[0][0],i[0][1])}}(this,arguments,function*(){const e=n.getReader();try{for(;;){const{value:s,done:r}=yield Dl(e.read());if(r)return yield Dl(void 0);yield yield Dl(s)}}finally{e.releaseLock()}})}function qN(n){return pe(n?.getReader)}function Mr(n){if(n instanceof Wn)return n;if(null!=n){if(zN(n))return function OG(n){return new Wn(t=>{const e=n[B_]();if(pe(e.subscribe))return e.subscribe(t);throw new TypeError("Provided object does not correctly implement Symbol.observable")})}(n);if(VN(n))return function $G(n){return new Wn(t=>{for(let e=0;e<n.length&&!t.closed;e++)t.next(n[e]);t.complete()})}(n);if(BN(n))return function PG(n){return new Wn(t=>{n.then(e=>{t.closed||(t.next(e),t.complete())},e=>t.error(e)).then(null,Un)})}(n);if(UN(n))return KN(n);if(HN(n))return function LG(n){return new Wn(t=>{for(const e of n)if(t.next(e),t.closed)return;t.complete()})}(n);if(qN(n))return function VG(n){return KN(jN(n))}(n)}throw WN(n)}function KN(n){return new Wn(t=>{(function BG(n,t){var e,s,r,i;return function NG(n,t,e,s){return new(e||(e=Promise))(function(i,o){function a(c){try{u(s.next(c))}catch(d){o(d)}}function l(c){try{u(s.throw(c))}catch(d){o(d)}}function u(c){c.done?i(c.value):function r(i){return i instanceof e?i:new e(function(o){o(i)})}(c.value).then(a,l)}u((s=s.apply(n,t||[])).next())})}(this,void 0,void 0,function*(){try{for(e=RG(n);!(s=yield e.next()).done;)if(t.next(s.value),t.closed)return}catch(o){r={error:o}}finally{try{s&&!s.done&&(i=e.return)&&(yield i.call(e))}finally{if(r)throw r.error}}t.complete()})})(n,t).catch(e=>t.error(e))})}function $o(n,t,e,s=0,r=!1){const i=t.schedule(function(){e(),r?n.add(this.schedule(null,s)):this.unsubscribe()},s);if(n.add(i),!r)return i}function Os(n,t,e=1/0){return pe(t)?Os((s,r)=>Ht((i,o)=>t(s,i,r,o))(Mr(n(s,r))),e):("number"==typeof t&&(e=t),ds((s,r)=>function zG(n,t,e,s,r,i,o,a){const l=[];let u=0,c=0,d=!1;const h=()=>{d&&!l.length&&!u&&t.complete()},f=g=>u<s?p(g):l.push(g),p=g=>{i&&t.next(g),u++;let m=!1;Mr(e(g,c++)).subscribe(Xn(t,y=>{r?.(y),i?f(y):t.next(y)},()=>{m=!0},void 0,()=>{if(m)try{for(u--;l.length&&u<s;){const y=l.shift();o?$o(t,o,()=>p(y)):p(y)}h()}catch(y){t.error(y)}}))};return n.subscribe(Xn(t,f,()=>{d=!0,h()})),()=>{a?.()}}(s,r,n,e)))}function Ou(n=1/0){return Os(El,n)}const Ji=new Wn(n=>n.complete());function U_(n){return n[n.length-1]}function Fd(n){return function WG(n){return n&&pe(n.schedule)}(U_(n))?n.pop():void 0}function YN(n,t=0){return ds((e,s)=>{e.subscribe(Xn(s,r=>$o(s,n,()=>s.next(r),t),()=>$o(s,n,()=>s.complete(),t),r=>$o(s,n,()=>s.error(r),t)))})}function ZN(n,t=0){return ds((e,s)=>{s.add(n.schedule(()=>e.subscribe(s),t))})}function QN(n,t){if(!n)throw new Error("Iterable cannot be null");return new Wn(e=>{$o(e,t,()=>{const s=n[Symbol.asyncIterator]();$o(e,t,()=>{s.next().then(r=>{r.done?e.complete():e.next(r.value)})},0,!0)})})}function Cs(n,t){return t?function YG(n,t){if(null!=n){if(zN(n))return function HG(n,t){return Mr(n).pipe(ZN(t),YN(t))}(n,t);if(VN(n))return function qG(n,t){return new Wn(e=>{let s=0;return t.schedule(function(){s===n.length?e.complete():(e.next(n[s++]),e.closed||this.schedule())})})}(n,t);if(BN(n))return function jG(n,t){return Mr(n).pipe(ZN(t),YN(t))}(n,t);if(UN(n))return QN(n,t);if(HN(n))return function KG(n,t){return new Wn(e=>{let s;return $o(e,t,()=>{s=n[GN](),$o(e,t,()=>{let r,i;try{({value:r,done:i}=s.next())}catch(o){return void e.error(o)}i?e.complete():e.next(r)},0,!0)}),()=>pe(s?.return)&&s.return()})}(n,t);if(qN(n))return function XG(n,t){return QN(jN(n),t)}(n,t)}throw WN(n)}(n,t):Mr(n)}function W_(n,t,...e){if(!0===t)return void n();if(!1===t)return;const s=new Md({next:()=>{s.unsubscribe(),n()}});return Mr(t(...e)).subscribe(s)}function jt(n){for(let t in n)if(n[t]===jt)return t;throw Error("Could not find renamed property on target object.")}function G_(n,t){for(const e in t)t.hasOwnProperty(e)&&!n.hasOwnProperty(e)&&(n[e]=t[e])}function hs(n){if("string"==typeof n)return n;if(Array.isArray(n))return"["+n.map(hs).join(", ")+"]";if(null==n)return""+n;if(n.overriddenName)return`${n.overriddenName}`;if(n.name)return`${n.name}`;const t=n.toString();if(null==t)return""+t;const e=t.indexOf("\n");return-1===e?t:t.substring(0,e)}function H_(n,t){return null==n||""===n?null===t?"":t:null==t||""===t?n:n+" "+t}const JG=jt({__forward_ref__:jt});function Qt(n){return n.__forward_ref__=Qt,n.toString=function(){return hs(this())},n}function Je(n){return j_(n)?n():n}function j_(n){return"function"==typeof n&&n.hasOwnProperty(JG)&&n.__forward_ref__===Qt}function q_(n){return n&&!!n.\u0275providers}class ee extends Error{constructor(t,e){super(function K_(n,t){return`NG0${Math.abs(n)}${t?": "+t:""}`}(t,e)),this.code=t}}function et(n){return"string"==typeof n?n:null==n?"":String(n)}function cm(n,t){throw new ee(-201,!1)}function ri(n,t){null==n&&function Ut(n,t,e,s){throw new Error(`ASSERTION ERROR: ${n}`+(null==s?"":` [Expected=> ${e} ${s} ${t} <=Actual]`))}(t,n,null,"!=")}function Ve(n){return{token:n.token,providedIn:n.providedIn||null,factory:n.factory,value:void 0}}function fr(n){return{providers:n.providers||[],imports:n.imports||[]}}function dm(n){return e1(n,hm)||e1(n,n1)}function e1(n,t){return n.hasOwnProperty(t)?n[t]:null}function t1(n){return n&&(n.hasOwnProperty(X_)||n.hasOwnProperty(aH))?n[X_]:null}const hm=jt({\u0275prov:jt}),X_=jt({\u0275inj:jt}),n1=jt({ngInjectableDef:jt}),aH=jt({ngInjectorDef:jt});var je=(()=>((je=je||{})[je.Default=0]="Default",je[je.Host=1]="Host",je[je.Self=2]="Self",je[je.SkipSelf=4]="SkipSelf",je[je.Optional=8]="Optional",je))();let Y_;function pr(n){const t=Y_;return Y_=n,t}function r1(n,t,e){const s=dm(n);return s&&"root"==s.providedIn?void 0===s.value?s.value=s.factory():s.value:e&je.Optional?null:void 0!==t?t:void cm(hs(n))}const ln=(()=>typeof globalThis<"u"&&globalThis||typeof global<"u"&&global||typeof window<"u"&&window||typeof self<"u"&&typeof WorkerGlobalScope<"u"&&self instanceof WorkerGlobalScope&&self)(),Od={},Z_="__NG_DI_FLAG__",fm="ngTempTokenPath",uH=/\n/gm,o1="__source";let $u;function xa(n){const t=$u;return $u=n,t}function hH(n,t=je.Default){if(void 0===$u)throw new ee(-203,!1);return null===$u?r1(n,void 0,t):$u.get(n,t&je.Optional?null:void 0,t)}function Se(n,t=je.Default){return(function s1(){return Y_}()||hH)(Je(n),t)}function Fe(n,t=je.Default){return Se(n,pm(t))}function pm(n){return typeof n>"u"||"number"==typeof n?n:0|(n.optional&&8)|(n.host&&1)|(n.self&&2)|(n.skipSelf&&4)}function Q_(n){const t=[];for(let e=0;e<n.length;e++){const s=Je(n[e]);if(Array.isArray(s)){if(0===s.length)throw new ee(900,!1);let r,i=je.Default;for(let o=0;o<s.length;o++){const a=s[o],l=fH(a);"number"==typeof l?-1===l?r=a.token:i|=l:r=a}t.push(Se(r,i))}else t.push(Se(s))}return t}function $d(n,t){return n[Z_]=t,n.prototype[Z_]=t,n}function fH(n){return n[Z_]}function Po(n){return{toString:n}.toString()}var eo=(()=>((eo=eo||{})[eo.OnPush=0]="OnPush",eo[eo.Default=1]="Default",eo))(),mr=(()=>{return(n=mr||(mr={}))[n.Emulated=0]="Emulated",n[n.None=2]="None",n[n.ShadowDom=3]="ShadowDom",mr;var n})();const Lo={},$t=[],mm=jt({\u0275cmp:jt}),J_=jt({\u0275dir:jt}),ew=jt({\u0275pipe:jt}),l1=jt({\u0275mod:jt}),Vo=jt({\u0275fac:jt}),Pd=jt({__NG_ELEMENT_ID__:jt}),u1=jt({__NG_ENV_ID__:jt});function c1(n,t,e){let s=n.length;for(;;){const r=n.indexOf(t,e);if(-1===r)return r;if(0===r||n.charCodeAt(r-1)<=32){const i=t.length;if(r+i===s||n.charCodeAt(r+i)<=32)return r}e=r+1}}function tw(n,t,e){let s=0;for(;s<e.length;){const r=e[s];if("number"==typeof r){if(0!==r)break;s++;const i=e[s++],o=e[s++],a=e[s++];n.setAttribute(t,o,a,i)}else{const i=r,o=e[++s];h1(i)?n.setProperty(t,i,o):n.setAttribute(t,i,o),s++}}return s}function d1(n){return 3===n||4===n||6===n}function h1(n){return 64===n.charCodeAt(0)}function Ld(n,t){if(null!==t&&0!==t.length)if(null===n||0===n.length)n=t.slice();else{let e=-1;for(let s=0;s<t.length;s++){const r=t[s];"number"==typeof r?e=r:0===e||f1(n,e,r,null,-1===e||2===e?t[++s]:null)}}return n}function f1(n,t,e,s,r){let i=0,o=n.length;if(-1===t)o=-1;else for(;i<n.length;){const a=n[i++];if("number"==typeof a){if(a===t){o=-1;break}if(a>t){o=i-1;break}}}for(;i<n.length;){const a=n[i];if("number"==typeof a)break;if(a===e){if(null===s)return void(null!==r&&(n[i+1]=r));if(s===n[i+1])return void(n[i+2]=r)}i++,null!==s&&i++,null!==r&&i++}-1!==o&&(n.splice(o,0,t),i=o+1),n.splice(i++,0,e),null!==s&&n.splice(i++,0,s),null!==r&&n.splice(i++,0,r)}const p1="ng-template";function gH(n,t,e){let s=0,r=!0;for(;s<n.length;){let i=n[s++];if("string"==typeof i&&r){const o=n[s++];if(e&&"class"===i&&-1!==c1(o.toLowerCase(),t,0))return!0}else{if(1===i){for(;s<n.length&&"string"==typeof(i=n[s++]);)if(i.toLowerCase()===t)return!0;return!1}"number"==typeof i&&(r=!1)}}return!1}function m1(n){return 4===n.type&&n.value!==p1}function yH(n,t,e){return t===(4!==n.type||e?n.value:p1)}function bH(n,t,e){let s=4;const r=n.attrs||[],i=function wH(n){for(let t=0;t<n.length;t++)if(d1(n[t]))return t;return n.length}(r);let o=!1;for(let a=0;a<t.length;a++){const l=t[a];if("number"!=typeof l){if(!o)if(4&s){if(s=2|1&s,""!==l&&!yH(n,l,e)||""===l&&1===t.length){if(Ni(s))return!1;o=!0}}else{const u=8&s?l:t[++a];if(8&s&&null!==n.attrs){if(!gH(n.attrs,u,e)){if(Ni(s))return!1;o=!0}continue}const d=vH(8&s?"class":l,r,m1(n),e);if(-1===d){if(Ni(s))return!1;o=!0;continue}if(""!==u){let h;h=d>i?"":r[d+1].toLowerCase();const f=8&s?h:null;if(f&&-1!==c1(f,u,0)||2&s&&u!==h){if(Ni(s))return!1;o=!0}}}}else{if(!o&&!Ni(s)&&!Ni(l))return!1;if(o&&Ni(l))continue;o=!1,s=l|1&s}}return Ni(s)||o}function Ni(n){return 0==(1&n)}function vH(n,t,e,s){if(null===t)return-1;let r=0;if(s||!e){let i=!1;for(;r<t.length;){const o=t[r];if(o===n)return r;if(3===o||6===o)i=!0;else{if(1===o||2===o){let a=t[++r];for(;"string"==typeof a;)a=t[++r];continue}if(4===o)break;if(0===o){r+=4;continue}}r+=i?1:2}return-1}return function xH(n,t){let e=n.indexOf(4);if(e>-1)for(e++;e<n.length;){const s=n[e];if("number"==typeof s)return-1;if(s===t)return e;e++}return-1}(t,n)}function g1(n,t,e=!1){for(let s=0;s<t.length;s++)if(bH(n,t[s],e))return!0;return!1}function CH(n,t){e:for(let e=0;e<t.length;e++){const s=t[e];if(n.length===s.length){for(let r=0;r<n.length;r++)if(n[r]!==s[r])continue e;return!0}}return!1}function y1(n,t){return n?":not("+t.trim()+")":t}function SH(n){let t=n[0],e=1,s=2,r="",i=!1;for(;e<n.length;){let o=n[e];if("string"==typeof o)if(2&s){const a=n[++e];r+="["+o+(a.length>0?'="'+a+'"':"")+"]"}else 8&s?r+="."+o:4&s&&(r+=" "+o);else""!==r&&!Ni(o)&&(t+=y1(i,r),r=""),s=o,i=i||!Ni(s);e++}return""!==r&&(t+=y1(i,r)),t}function Vd(n){return Po(()=>{const t=v1(n),e={...t,decls:n.decls,vars:n.vars,template:n.template,consts:n.consts||null,ngContentSelectors:n.ngContentSelectors,onPush:n.changeDetection===eo.OnPush,directiveDefs:null,pipeDefs:null,dependencies:t.standalone&&n.dependencies||null,getStandaloneInjector:null,data:n.data||{},encapsulation:n.encapsulation||mr.Emulated,styles:n.styles||$t,_:null,schemas:n.schemas||null,tView:null,id:""};_1(e);const s=n.dependencies;return e.directiveDefs=gm(s,!1),e.pipeDefs=gm(s,!0),e.id=function RH(n){let t=0;const e=[n.selectors,n.ngContentSelectors,n.hostVars,n.hostAttrs,n.consts,n.vars,n.decls,n.encapsulation,n.standalone,Object.getOwnPropertyNames(n.type.prototype),!!n.contentQueries,!!n.viewQuery].join("|");for(const r of e)t=Math.imul(31,t)+r.charCodeAt(0)<<0;return t+=2147483648,"c"+t}(e),e})}function TH(n){return Lt(n)||Ws(n)}function NH(n){return null!==n}function Or(n){return Po(()=>({type:n.type,bootstrap:n.bootstrap||$t,declarations:n.declarations||$t,imports:n.imports||$t,exports:n.exports||$t,transitiveCompileScopes:null,schemas:n.schemas||null,id:n.id||null}))}function b1(n,t){if(null==n)return Lo;const e={};for(const s in n)if(n.hasOwnProperty(s)){let r=n[s],i=r;Array.isArray(r)&&(i=r[1],r=r[0]),e[r]=s,t&&(t[r]=i)}return e}function qe(n){return Po(()=>{const t=v1(n);return _1(t),t})}function gr(n){return{type:n.type,name:n.name,factory:null,pure:!1!==n.pure,standalone:!0===n.standalone,onDestroy:n.type.prototype.ngOnDestroy||null}}function Lt(n){return n[mm]||null}function Ws(n){return n[J_]||null}function yr(n){return n[ew]||null}function $r(n,t){const e=n[l1]||null;if(!e&&!0===t)throw new Error(`Type ${hs(n)} does not have '\u0275mod' property.`);return e}function v1(n){const t={};return{type:n.type,providersResolver:null,factory:null,hostBindings:n.hostBindings||null,hostVars:n.hostVars||0,hostAttrs:n.hostAttrs||null,contentQueries:n.contentQueries||null,declaredInputs:t,exportAs:n.exportAs||null,standalone:!0===n.standalone,selectors:n.selectors||$t,viewQuery:n.viewQuery||null,features:n.features||null,setInput:null,findHostDirectiveDefs:null,hostDirectives:null,inputs:b1(n.inputs,t),outputs:b1(n.outputs)}}function _1(n){n.features?.forEach(t=>t(n))}function gm(n,t){if(!n)return null;const e=t?yr:TH;return()=>("function"==typeof n?n():n).map(s=>e(s)).filter(NH)}const Ss=0,Ie=1,at=2,Sn=3,ki=4,Tl=5,Gs=6,Lu=7,Rn=8,Vu=9,Nl=10,rt=11,Bd=12,w1=13,Bu=14,Yn=15,zd=16,zu=17,to=18,Ud=19,x1=20,Ca=21,Bo=22,ym=23,bm=24,It=25,nw=1,C1=2,no=7,vm=8,Uu=9,$s=11;function Pr(n){return Array.isArray(n)&&"object"==typeof n[nw]}function Lr(n){return Array.isArray(n)&&!0===n[nw]}function sw(n){return 0!=(4&n.flags)}function kl(n){return n.componentOffset>-1}function _m(n){return 1==(1&n.flags)}function Ai(n){return!!n.template}function rw(n){return 0!=(512&n[at])}function Al(n,t){return n.hasOwnProperty(Vo)?n[Vo]:null}let PH=ln.WeakRef??class $H{constructor(t){this.ref=t}deref(){return this.ref}},VH=0,so=null,wm=!1;function Is(n){const t=so;return so=n,t}class T1{constructor(){this.id=VH++,this.ref=function LH(n){return new PH(n)}(this),this.producers=new Map,this.consumers=new Map,this.trackingVersion=0,this.valueVersion=0}consumerPollProducersForChange(){for(const[t,e]of this.producers){const s=e.producerNode.deref();if(void 0!==s&&e.atTrackingVersion===this.trackingVersion){if(s.producerPollStatus(e.seenValueVersion))return!0}else this.producers.delete(t),s?.consumers.delete(this.id)}return!1}producerMayHaveChanged(){const t=wm;wm=!0;try{for(const[e,s]of this.consumers){const r=s.consumerNode.deref();void 0!==r&&r.trackingVersion===s.atTrackingVersion?r.onConsumerDependencyMayHaveChanged():(this.consumers.delete(e),r?.producers.delete(this.id))}}finally{wm=t}}producerAccessed(){if(wm)throw new Error("");if(null===so)return;let t=so.producers.get(this.id);void 0===t?(t={consumerNode:so.ref,producerNode:this.ref,seenValueVersion:this.valueVersion,atTrackingVersion:so.trackingVersion},so.producers.set(this.id,t),this.consumers.set(so.id,t)):(t.seenValueVersion=this.valueVersion,t.atTrackingVersion=so.trackingVersion)}get hasProducers(){return this.producers.size>0}get producerUpdatesAllowed(){return!1!==so?.consumerAllowSignalWrites}producerPollStatus(t){return this.valueVersion!==t||(this.onProducerUpdateValueVersion(),this.valueVersion!==t)}}let N1=null;const k1=()=>{};class WH extends T1{constructor(t,e,s){super(),this.watch=t,this.schedule=e,this.dirty=!1,this.cleanupFn=k1,this.registerOnCleanup=r=>{this.cleanupFn=r},this.consumerAllowSignalWrites=s}notify(){this.dirty||this.schedule(this),this.dirty=!0}onConsumerDependencyMayHaveChanged(){this.notify()}onProducerUpdateValueVersion(){}run(){if(this.dirty=!1,0!==this.trackingVersion&&!this.consumerPollProducersForChange())return;const t=Is(this);this.trackingVersion++;try{this.cleanupFn(),this.cleanupFn=k1,this.watch(this.registerOnCleanup)}finally{Is(t)}}cleanup(){this.cleanupFn()}}class GH{constructor(t,e,s){this.previousValue=t,this.currentValue=e,this.firstChange=s}isFirstChange(){return this.firstChange}}function ii(){return A1}function A1(n){return n.type.prototype.ngOnChanges&&(n.setInput=jH),HH}function HH(){const n=M1(this),t=n?.current;if(t){const e=n.previous;if(e===Lo)n.previous=t;else for(let s in t)e[s]=t[s];n.current=null,this.ngOnChanges(t)}}function jH(n,t,e,s){const r=this.declaredInputs[e],i=M1(n)||function qH(n,t){return n[R1]=t}(n,{previous:Lo,current:null}),o=i.current||(i.current={}),a=i.previous,l=a[r];o[r]=new GH(l&&l.currentValue,t,a===Lo),n[s]=t}ii.ngInherit=!0;const R1="__ngSimpleChanges__";function M1(n){return n[R1]||null}const ro=function(n,t,e){};function fn(n){for(;Array.isArray(n);)n=n[Ss];return n}function Sm(n,t){return fn(t[n])}function br(n,t){return fn(t[n.index])}function $1(n,t){return n.data[t]}function vr(n,t){const e=t[n];return Pr(e)?e:e[Ss]}function Im(n){return 128==(128&n[at])}function Sa(n,t){return null==t?null:n[t]}function P1(n){n[zu]=0}function JH(n){1024&n[at]||(n[at]|=1024,V1(n,1))}function L1(n){1024&n[at]&&(n[at]&=-1025,V1(n,-1))}function V1(n,t){let e=n[Sn];if(null===e)return;e[Tl]+=t;let s=e;for(e=e[Sn];null!==e&&(1===t&&1===s[Tl]||-1===t&&0===s[Tl]);)e[Tl]+=t,s=e,e=e[Sn]}const Ze={lFrame:Y1(null),bindingsEnabled:!0,skipHydrationRootTNode:null};function U1(){return Ze.bindingsEnabled}function oe(){return Ze.lFrame.lView}function kt(){return Ze.lFrame.tView}function Ps(){let n=W1();for(;null!==n&&64===n.type;)n=n.parent;return n}function W1(){return Ze.lFrame.currentTNode}function oo(n,t){const e=Ze.lFrame;e.currentTNode=n,e.isParent=t}function cw(){return Ze.lFrame.isParent}function dw(){Ze.lFrame.isParent=!1}function Gu(){return Ze.lFrame.bindingIndex++}function Uo(n){const t=Ze.lFrame,e=t.bindingIndex;return t.bindingIndex=t.bindingIndex+n,e}function fj(n,t){const e=Ze.lFrame;e.bindingIndex=e.bindingRootIndex=n,hw(t)}function hw(n){Ze.lFrame.currentDirectiveIndex=n}function q1(){return Ze.lFrame.currentQueryIndex}function pw(n){Ze.lFrame.currentQueryIndex=n}function mj(n){const t=n[Ie];return 2===t.type?t.declTNode:1===t.type?n[Gs]:null}function K1(n,t,e){if(e&je.SkipSelf){let r=t,i=n;for(;!(r=r.parent,null!==r||e&je.Host||(r=mj(i),null===r||(i=i[Bu],10&r.type))););if(null===r)return!1;t=r,n=i}const s=Ze.lFrame=X1();return s.currentTNode=t,s.lView=n,!0}function mw(n){const t=X1(),e=n[Ie];Ze.lFrame=t,t.currentTNode=e.firstChild,t.lView=n,t.tView=e,t.contextLView=n,t.bindingIndex=e.bindingStartIndex,t.inI18n=!1}function X1(){const n=Ze.lFrame,t=null===n?null:n.child;return null===t?Y1(n):t}function Y1(n){const t={currentTNode:null,isParent:!0,lView:null,tView:null,selectedIndex:-1,contextLView:null,elementDepthCount:0,currentNamespace:null,currentDirectiveIndex:-1,bindingRootIndex:-1,bindingIndex:-1,currentQueryIndex:0,parent:n,child:null,inI18n:!1};return null!==n&&(n.child=t),t}function Z1(){const n=Ze.lFrame;return Ze.lFrame=n.parent,n.currentTNode=null,n.lView=null,n}const Q1=Z1;function gw(){const n=Z1();n.isParent=!0,n.tView=null,n.selectedIndex=-1,n.contextLView=null,n.elementDepthCount=0,n.currentDirectiveIndex=-1,n.currentNamespace=null,n.bindingRootIndex=-1,n.bindingIndex=-1,n.currentQueryIndex=0}function tr(){return Ze.lFrame.selectedIndex}function Rl(n){Ze.lFrame.selectedIndex=n}function In(){const n=Ze.lFrame;return $1(n.tView,n.selectedIndex)}let ek=!0;function Em(){return ek}function Ia(n){ek=n}function Dm(n,t){for(let e=t.directiveStart,s=t.directiveEnd;e<s;e++){const i=n.data[e].type.prototype,{ngAfterContentInit:o,ngAfterContentChecked:a,ngAfterViewInit:l,ngAfterViewChecked:u,ngOnDestroy:c}=i;o&&(n.contentHooks??=[]).push(-e,o),a&&((n.contentHooks??=[]).push(e,a),(n.contentCheckHooks??=[]).push(e,a)),l&&(n.viewHooks??=[]).push(-e,l),u&&((n.viewHooks??=[]).push(e,u),(n.viewCheckHooks??=[]).push(e,u)),null!=c&&(n.destroyHooks??=[]).push(e,c)}}function Tm(n,t,e){tk(n,t,3,e)}function Nm(n,t,e,s){(3&n[at])===e&&tk(n,t,e,s)}function yw(n,t){let e=n[at];(3&e)===t&&(e&=4095,e+=1,n[at]=e)}function tk(n,t,e,s){const i=s??-1,o=t.length-1;let a=0;for(let l=void 0!==s?65535&n[zu]:0;l<o;l++)if("number"==typeof t[l+1]){if(a=t[l],null!=s&&a>=s)break}else t[l]<0&&(n[zu]+=65536),(a<i||-1==i)&&(Cj(n,e,t,l),n[zu]=(4294901760&n[zu])+l+2),l++}function nk(n,t){ro(4,n,t);const e=Is(null);try{t.call(n)}finally{Is(e),ro(5,n,t)}}function Cj(n,t,e,s){const r=e[s]<0,i=e[s+1],a=n[r?-e[s]:e[s]];r?n[at]>>12<n[zu]>>16&&(3&n[at])===t&&(n[at]+=4096,nk(a,i)):nk(a,i)}const Hu=-1;class jd{constructor(t,e,s){this.factory=t,this.resolving=!1,this.canSeeViewProviders=e,this.injectImpl=s}}function sk(n){return n!==Hu}function km(n){return 32767&n}function Am(n,t){let e=function Dj(n){return n>>16}(n),s=t;for(;e>0;)s=s[Bu],e--;return s}let vw=!0;function Rm(n){const t=vw;return vw=n,t}const rk=255,ik=5;let Tj=0;const ao={};function Mm(n,t){const e=ok(n,t);if(-1!==e)return e;const s=t[Ie];s.firstCreatePass&&(n.injectorIndex=t.length,_w(s.data,n),_w(t,null),_w(s.blueprint,null));const r=ww(n,t),i=n.injectorIndex;if(sk(r)){const o=km(r),a=Am(r,t),l=a[Ie].data;for(let u=0;u<8;u++)t[i+u]=a[o+u]|l[o+u]}return t[i+8]=r,i}function _w(n,t){n.push(0,0,0,0,0,0,0,0,t)}function ok(n,t){return-1===n.injectorIndex||n.parent&&n.parent.injectorIndex===n.injectorIndex||null===t[n.injectorIndex+8]?-1:n.injectorIndex}function ww(n,t){if(n.parent&&-1!==n.parent.injectorIndex)return n.parent.injectorIndex;let e=0,s=null,r=t;for(;null!==r;){if(s=fk(r),null===s)return Hu;if(e++,r=r[Bu],-1!==s.injectorIndex)return s.injectorIndex|e<<16}return Hu}function xw(n,t,e){!function Nj(n,t,e){let s;"string"==typeof e?s=e.charCodeAt(0)||0:e.hasOwnProperty(Pd)&&(s=e[Pd]),null==s&&(s=e[Pd]=Tj++);const r=s&rk;t.data[n+(r>>ik)]|=1<<r}(n,t,e)}function ak(n,t,e){if(e&je.Optional||void 0!==n)return n;cm()}function lk(n,t,e,s){if(e&je.Optional&&void 0===s&&(s=null),!(e&(je.Self|je.Host))){const r=n[Vu],i=pr(void 0);try{return r?r.get(t,s,e&je.Optional):r1(t,s,e&je.Optional)}finally{pr(i)}}return ak(s,0,e)}function uk(n,t,e,s=je.Default,r){if(null!==n){if(2048&t[at]){const o=function Fj(n,t,e,s,r){let i=n,o=t;for(;null!==i&&null!==o&&2048&o[at]&&!(512&o[at]);){const a=ck(i,o,e,s|je.Self,ao);if(a!==ao)return a;let l=i.parent;if(!l){const u=o[x1];if(u){const c=u.get(e,ao,s);if(c!==ao)return c}l=fk(o),o=o[Bu]}i=l}return r}(n,t,e,s,ao);if(o!==ao)return o}const i=ck(n,t,e,s,ao);if(i!==ao)return i}return lk(t,e,s,r)}function ck(n,t,e,s,r){const i=function Rj(n){if("string"==typeof n)return n.charCodeAt(0)||0;const t=n.hasOwnProperty(Pd)?n[Pd]:void 0;return"number"==typeof t?t>=0?t&rk:Mj:t}(e);if("function"==typeof i){if(!K1(t,n,s))return s&je.Host?ak(r,0,s):lk(t,e,s,r);try{const o=i(s);if(null!=o||s&je.Optional)return o;cm()}finally{Q1()}}else if("number"==typeof i){let o=null,a=ok(n,t),l=Hu,u=s&je.Host?t[Yn][Gs]:null;for((-1===a||s&je.SkipSelf)&&(l=-1===a?ww(n,t):t[a+8],l!==Hu&&hk(s,!1)?(o=t[Ie],a=km(l),t=Am(l,t)):a=-1);-1!==a;){const c=t[Ie];if(dk(i,a,c.data)){const d=Aj(a,t,e,o,s,u);if(d!==ao)return d}l=t[a+8],l!==Hu&&hk(s,t[Ie].data[a+8]===u)&&dk(i,a,t)?(o=c,a=km(l),t=Am(l,t)):a=-1}}return r}function Aj(n,t,e,s,r,i){const o=t[Ie],a=o.data[n+8],c=Fm(a,o,e,null==s?kl(a)&&vw:s!=o&&0!=(3&a.type),r&je.Host&&i===a);return null!==c?Ml(t,o,c,a):ao}function Fm(n,t,e,s,r){const i=n.providerIndexes,o=t.data,a=1048575&i,l=n.directiveStart,c=i>>20,h=r?a+c:n.directiveEnd;for(let f=s?a:a+c;f<h;f++){const p=o[f];if(f<l&&e===p||f>=l&&p.type===e)return f}if(r){const f=o[l];if(f&&Ai(f)&&f.type===e)return l}return null}function Ml(n,t,e,s){let r=n[e];const i=t.data;if(function Sj(n){return n instanceof jd}(r)){const o=r;o.resolving&&function eH(n,t){const e=t?`. Dependency path: ${t.join(" > ")} > ${n}`:"";throw new ee(-200,`Circular dependency in DI detected for ${n}${e}`)}(function zt(n){return"function"==typeof n?n.name||n.toString():"object"==typeof n&&null!=n&&"function"==typeof n.type?n.type.name||n.type.toString():et(n)}(i[e]));const a=Rm(o.canSeeViewProviders);o.resolving=!0;const l=o.injectImpl?pr(o.injectImpl):null;K1(n,s,je.Default);try{r=n[e]=o.factory(void 0,i,n,s),t.firstCreatePass&&e>=s.directiveStart&&function xj(n,t,e){const{ngOnChanges:s,ngOnInit:r,ngDoCheck:i}=t.type.prototype;if(s){const o=A1(t);(e.preOrderHooks??=[]).push(n,o),(e.preOrderCheckHooks??=[]).push(n,o)}r&&(e.preOrderHooks??=[]).push(0-n,r),i&&((e.preOrderHooks??=[]).push(n,i),(e.preOrderCheckHooks??=[]).push(n,i))}(e,i[e],t)}finally{null!==l&&pr(l),Rm(a),o.resolving=!1,Q1()}}return r}function dk(n,t,e){return!!(e[t+(n>>ik)]&1<<n)}function hk(n,t){return!(n&je.Self||n&je.Host&&t)}class ju{constructor(t,e){this._tNode=t,this._lView=e}get(t,e,s){return uk(this._tNode,this._lView,t,pm(s),e)}}function Mj(){return new ju(Ps(),oe())}function Cw(n){return j_(n)?()=>{const t=Cw(Je(n));return t&&t()}:Al(n)}function fk(n){const t=n[Ie],e=t.type;return 2===e?t.declTNode:1===e?n[Gs]:null}const Ku="__parameters__";function Yu(n,t,e){return Po(()=>{const s=function Sw(n){return function(...e){if(n){const s=n(...e);for(const r in s)this[r]=s[r]}}}(t);function r(...i){if(this instanceof r)return s.apply(this,i),this;const o=new r(...i);return a.annotation=o,a;function a(l,u,c){const d=l.hasOwnProperty(Ku)?l[Ku]:Object.defineProperty(l,Ku,{value:[]})[Ku];for(;d.length<=c;)d.push(null);return(d[c]=d[c]||[]).push(o),l}}return e&&(r.prototype=Object.create(e.prototype)),r.prototype.ngMetadataName=n,r.annotationCls=r,r})}function Xd(n,t){n.forEach(e=>Array.isArray(e)?Xd(e,t):t(e))}function mk(n,t,e){t>=n.length?n.push(e):n.splice(t,0,e)}function $m(n,t){return t>=n.length-1?n.pop():n.splice(t,1)[0]}function Yd(n,t){const e=[];for(let s=0;s<n;s++)e.push(t);return e}function Vr(n,t,e){let s=Zu(n,t);return s>=0?n[1|s]=e:(s=~s,function Vj(n,t,e,s){let r=n.length;if(r==t)n.push(e,s);else if(1===r)n.push(s,n[0]),n[0]=e;else{for(r--,n.push(n[r-1],n[r]);r>t;)n[r]=n[r-2],r--;n[t]=e,n[t+1]=s}}(n,s,t,e)),s}function Iw(n,t){const e=Zu(n,t);if(e>=0)return n[1|e]}function Zu(n,t){return function gk(n,t,e){let s=0,r=n.length>>e;for(;r!==s;){const i=s+(r-s>>1),o=n[i<<e];if(t===o)return i<<e;o>t?r=i:s=i+1}return~(r<<e)}(n,t,1)}const Lm=$d(Yu("Optional"),8),Vm=$d(Yu("SkipSelf"),4);var _r=(()=>((_r=_r||{})[_r.Important=1]="Important",_r[_r.DashCase=2]="DashCase",_r))();const oq=/^>|^->|<!--|-->|--!>|<!-$/g,aq=/(<|>)/,lq="\u200b$1\u200b";const Rw=new Map;let uq=0;const Fw="__ngContext__";function Hs(n,t){Pr(t)?(n[Fw]=t[Ud],function dq(n){Rw.set(n[Ud],n)}(t)):n[Fw]=t}let Ow;function $w(n,t){return Ow(n,t)}function Jd(n){const t=n[Sn];return Lr(t)?t[Sn]:t}function Pw(n){return Fk(n[Bd])}function Lw(n){return Fk(n[ki])}function Fk(n){for(;null!==n&&!Lr(n);)n=n[ki];return n}function Ju(n,t,e,s,r){if(null!=s){let i,o=!1;Lr(s)?i=s:Pr(s)&&(o=!0,s=s[Ss]);const a=fn(s);0===n&&null!==e?null==r?Vk(t,e,a):Fl(t,e,a,r||null,!0):1===n&&null!==e?Fl(t,e,a,r||null,!0):2===n?function jm(n,t,e){const s=Gm(n,t);s&&function kq(n,t,e,s){n.removeChild(t,e,s)}(n,s,t,e)}(t,a,o):3===n&&t.destroyNode(a),null!=i&&function Mq(n,t,e,s,r){const i=e[no];i!==fn(e)&&Ju(t,n,s,i,r);for(let a=$s;a<e.length;a++){const l=e[a];th(l[Ie],l,n,t,s,i)}}(t,n,i,e,r)}}function Vw(n,t){return n.createComment(function Ek(n){return n.replace(oq,t=>t.replace(aq,lq))}(t))}function Wm(n,t,e){return n.createElement(t,e)}function $k(n,t){const e=n[Uu],s=e.indexOf(t);L1(t),e.splice(s,1)}function Bw(n,t){if(n.length<=$s)return;const e=$s+t,s=n[e];if(s){const r=s[zd];null!==r&&r!==n&&$k(r,s),t>0&&(n[e-1][ki]=s[ki]);const i=$m(n,$s+t);!function xq(n,t){th(n,t,t[rt],2,null,null),t[Ss]=null,t[Gs]=null}(s[Ie],s);const o=i[to];null!==o&&o.detachView(i[Ie]),s[Sn]=null,s[ki]=null,s[at]&=-129}return s}function Pk(n,t){if(!(256&t[at])){const e=t[rt];t[ym]?.destroy(),t[bm]?.destroy(),e.destroyNode&&th(n,t,e,3,null,null),function Iq(n){let t=n[Bd];if(!t)return zw(n[Ie],n);for(;t;){let e=null;if(Pr(t))e=t[Bd];else{const s=t[$s];s&&(e=s)}if(!e){for(;t&&!t[ki]&&t!==n;)Pr(t)&&zw(t[Ie],t),t=t[Sn];null===t&&(t=n),Pr(t)&&zw(t[Ie],t),e=t&&t[ki]}t=e}}(t)}}function zw(n,t){if(!(256&t[at])){t[at]&=-129,t[at]|=256,function Nq(n,t){let e;if(null!=n&&null!=(e=n.destroyHooks))for(let s=0;s<e.length;s+=2){const r=t[e[s]];if(!(r instanceof jd)){const i=e[s+1];if(Array.isArray(i))for(let o=0;o<i.length;o+=2){const a=r[i[o]],l=i[o+1];ro(4,a,l);try{l.call(a)}finally{ro(5,a,l)}}else{ro(4,r,i);try{i.call(r)}finally{ro(5,r,i)}}}}}(n,t),function Tq(n,t){const e=n.cleanup,s=t[Lu];if(null!==e)for(let i=0;i<e.length-1;i+=2)if("string"==typeof e[i]){const o=e[i+3];o>=0?s[o]():s[-o].unsubscribe(),i+=2}else e[i].call(s[e[i+1]]);null!==s&&(t[Lu]=null);const r=t[Ca];if(null!==r){for(let i=0;i<r.length;i++)(0,r[i])();t[Ca]=null}}(n,t),1===t[Ie].type&&t[rt].destroy();const e=t[zd];if(null!==e&&Lr(t[Sn])){e!==t[Sn]&&$k(e,t);const s=t[to];null!==s&&s.detachView(n)}!function hq(n){Rw.delete(n[Ud])}(t)}}function Uw(n,t,e){return function Lk(n,t,e){let s=t;for(;null!==s&&40&s.type;)s=(t=s).parent;if(null===s)return e[Ss];{const{componentOffset:r}=s;if(r>-1){const{encapsulation:i}=n.data[s.directiveStart+r];if(i===mr.None||i===mr.Emulated)return null}return br(s,e)}}(n,t.parent,e)}function Fl(n,t,e,s,r){n.insertBefore(t,e,s,r)}function Vk(n,t,e){n.appendChild(t,e)}function Bk(n,t,e,s,r){null!==s?Fl(n,t,e,s,r):Vk(n,t,e)}function Gm(n,t){return n.parentNode(t)}function zk(n,t,e){return Wk(n,t,e)}let Ww,qw,Wk=function Uk(n,t,e){return 40&n.type?br(n,e):null};function Hm(n,t,e,s){const r=Uw(n,s,t),i=t[rt],a=zk(s.parent||t[Gs],s,t);if(null!=r)if(Array.isArray(e))for(let l=0;l<e.length;l++)Bk(i,r,e[l],a,!1);else Bk(i,r,e,a,!1);void 0!==Ww&&Ww(i,s,t,e,r)}function eh(n,t){if(null!==t){const e=t.type;if(3&e)return br(t,n);if(4&e)return Gw(-1,n[t.index]);if(8&e){const s=t.child;if(null!==s)return eh(n,s);{const r=n[t.index];return Lr(r)?Gw(-1,r):fn(r)}}if(32&e)return $w(t,n)()||fn(n[t.index]);{const s=Hk(n,t);return null!==s?Array.isArray(s)?s[0]:eh(Jd(n[Yn]),s):eh(n,t.next)}}return null}function Hk(n,t){return null!==t?n[Yn][Gs].projection[t.projection]:null}function Gw(n,t){const e=$s+n+1;if(e<t.length){const s=t[e],r=s[Ie].firstChild;if(null!==r)return eh(s,r)}return t[no]}function Hw(n,t,e,s,r,i,o){for(;null!=e;){const a=s[e.index],l=e.type;if(o&&0===t&&(a&&Hs(fn(a),s),e.flags|=2),32!=(32&e.flags))if(8&l)Hw(n,t,e.child,s,r,i,!1),Ju(t,n,r,a,i);else if(32&l){const u=$w(e,s);let c;for(;c=u();)Ju(t,n,r,c,i);Ju(t,n,r,a,i)}else 16&l?qk(n,t,s,e,r,i):Ju(t,n,r,a,i);e=o?e.projectionNext:e.next}}function th(n,t,e,s,r,i){Hw(e,s,n.firstChild,t,r,i,!1)}function qk(n,t,e,s,r,i){const o=e[Yn],l=o[Gs].projection[s.projection];if(Array.isArray(l))for(let u=0;u<l.length;u++)Ju(t,n,r,l[u],i);else Hw(n,t,l,o[Sn],r,i,!0)}function Kk(n,t,e){""===e?n.removeAttribute(t,"class"):n.setAttribute(t,"class",e)}function Xk(n,t,e){const{mergedAttrs:s,classes:r,styles:i}=e;null!==s&&tw(n,t,s),null!==r&&Kk(n,t,r),null!==i&&function Oq(n,t,e){n.setAttribute(t,"style",e)}(n,t,i)}class Jk{constructor(t){this.changingThisBreaksApplicationSecurity=t}toString(){return`SafeValue must use [property]=binding: ${this.changingThisBreaksApplicationSecurity} (see https://g.co/ng/security#xss)`}}function Ea(n){return n instanceof Jk?n.changingThisBreaksApplicationSecurity:n}class we{constructor(t,e){this._desc=t,this.ngMetadataName="InjectionToken",this.\u0275prov=void 0,"number"==typeof e?this.__NG_ELEMENT_ID__=e:void 0!==e&&(this.\u0275prov=Ve({token:this,providedIn:e.providedIn||"root",factory:e.factory}))}get multi(){return this}toString(){return`InjectionToken ${this._desc}`}}const oh=new we("ENVIRONMENT_INITIALIZER"),uA=new we("INJECTOR",-1),cA=new we("INJECTOR_DEF_TYPES");class dA{get(t,e=Od){if(e===Od){const s=new Error(`NullInjectorError: No provider for ${hs(t)}!`);throw s.name="NullInjectorError",s}return e}}function l6(...n){return{\u0275providers:fA(0,n),\u0275fromNgModule:!0}}function fA(n,...t){const e=[],s=new Set;let r;return Xd(t,i=>{const o=i;Jw(o,e,[],s)&&(r||=[],r.push(o))}),void 0!==r&&pA(r,e),e}function pA(n,t){for(let e=0;e<n.length;e++){const{providers:r}=n[e];ex(r,i=>{t.push(i)})}}function Jw(n,t,e,s){if(!(n=Je(n)))return!1;let r=null,i=t1(n);const o=!i&&Lt(n);if(i||o){if(o&&!o.standalone)return!1;r=n}else{const l=n.ngModule;if(i=t1(l),!i)return!1;r=l}const a=s.has(r);if(o){if(a)return!1;if(s.add(r),o.dependencies){const l="function"==typeof o.dependencies?o.dependencies():o.dependencies;for(const u of l)Jw(u,t,e,s)}}else{if(!i)return!1;{if(null!=i.imports&&!a){let u;s.add(r);try{Xd(i.imports,c=>{Jw(c,t,e,s)&&(u||=[],u.push(c))})}finally{}void 0!==u&&pA(u,t)}if(!a){const u=Al(r)||(()=>new r);t.push({provide:r,useFactory:u,deps:$t},{provide:cA,useValue:r,multi:!0},{provide:oh,useValue:()=>Se(r),multi:!0})}const l=i.providers;null==l||a||ex(l,c=>{t.push(c)})}}return r!==n&&void 0!==n.providers}function ex(n,t){for(let e of n)q_(e)&&(e=e.\u0275providers),Array.isArray(e)?ex(e,t):t(e)}const u6=jt({provide:String,useValue:jt});function tx(n){return null!==n&&"object"==typeof n&&u6 in n}function Ol(n){return"function"==typeof n}const nx=new we("Set Injector scope."),Ym={},d6={};let sx;function Zm(){return void 0===sx&&(sx=new dA),sx}class Go{}class rx extends Go{get destroyed(){return this._destroyed}constructor(t,e,s,r){super(),this.parent=e,this.source=s,this.scopes=r,this.records=new Map,this._ngOnDestroyHooks=new Set,this._onDestroyHooks=[],this._destroyed=!1,ox(t,o=>this.processProvider(o)),this.records.set(uA,tc(void 0,this)),r.has("environment")&&this.records.set(Go,tc(void 0,this));const i=this.records.get(nx);null!=i&&"string"==typeof i.value&&this.scopes.add(i.value),this.injectorDefTypes=new Set(this.get(cA.multi,$t,je.Self))}destroy(){this.assertNotDestroyed(),this._destroyed=!0;try{for(const t of this._ngOnDestroyHooks)t.ngOnDestroy();for(const t of this._onDestroyHooks)t()}finally{this.records.clear(),this._ngOnDestroyHooks.clear(),this.injectorDefTypes.clear(),this._onDestroyHooks.length=0}}onDestroy(t){return this.assertNotDestroyed(),this._onDestroyHooks.push(t),()=>this.removeOnDestroy(t)}runInContext(t){this.assertNotDestroyed();const e=xa(this),s=pr(void 0);try{return t()}finally{xa(e),pr(s)}}get(t,e=Od,s=je.Default){if(this.assertNotDestroyed(),t.hasOwnProperty(u1))return t[u1](this);s=pm(s);const r=xa(this),i=pr(void 0);try{if(!(s&je.SkipSelf)){let a=this.records.get(t);if(void 0===a){const l=function g6(n){return"function"==typeof n||"object"==typeof n&&n instanceof we}(t)&&dm(t);a=l&&this.injectableDefInScope(l)?tc(ix(t),Ym):null,this.records.set(t,a)}if(null!=a)return this.hydrate(t,a)}return(s&je.Self?Zm():this.parent).get(t,e=s&je.Optional&&e===Od?null:e)}catch(o){if("NullInjectorError"===o.name){if((o[fm]=o[fm]||[]).unshift(hs(t)),r)throw o;return function pH(n,t,e,s){const r=n[fm];throw t[o1]&&r.unshift(t[o1]),n.message=function mH(n,t,e,s=null){n=n&&"\n"===n.charAt(0)&&"\u0275"==n.charAt(1)?n.slice(2):n;let r=hs(t);if(Array.isArray(t))r=t.map(hs).join(" -> ");else if("object"==typeof t){let i=[];for(let o in t)if(t.hasOwnProperty(o)){let a=t[o];i.push(o+":"+("string"==typeof a?JSON.stringify(a):hs(a)))}r=`{${i.join(", ")}}`}return`${e}${s?"("+s+")":""}[${r}]: ${n.replace(uH,"\n  ")}`}("\n"+n.message,r,e,s),n.ngTokenPath=r,n[fm]=null,n}(o,t,"R3InjectorError",this.source)}throw o}finally{pr(i),xa(r)}}resolveInjectorInitializers(){const t=xa(this),e=pr(void 0);try{const s=this.get(oh.multi,$t,je.Self);for(const r of s)r()}finally{xa(t),pr(e)}}toString(){const t=[],e=this.records;for(const s of e.keys())t.push(hs(s));return`R3Injector[${t.join(", ")}]`}assertNotDestroyed(){if(this._destroyed)throw new ee(205,!1)}processProvider(t){let e=Ol(t=Je(t))?t:Je(t&&t.provide);const s=function f6(n){return tx(n)?tc(void 0,n.useValue):tc(yA(n),Ym)}(t);if(Ol(t)||!0!==t.multi)this.records.get(e);else{let r=this.records.get(e);r||(r=tc(void 0,Ym,!0),r.factory=()=>Q_(r.multi),this.records.set(e,r)),e=t,r.multi.push(t)}this.records.set(e,s)}hydrate(t,e){return e.value===Ym&&(e.value=d6,e.value=e.factory()),"object"==typeof e.value&&e.value&&function m6(n){return null!==n&&"object"==typeof n&&"function"==typeof n.ngOnDestroy}(e.value)&&this._ngOnDestroyHooks.add(e.value),e.value}injectableDefInScope(t){if(!t.providedIn)return!1;const e=Je(t.providedIn);return"string"==typeof e?"any"===e||this.scopes.has(e):this.injectorDefTypes.has(e)}removeOnDestroy(t){const e=this._onDestroyHooks.indexOf(t);-1!==e&&this._onDestroyHooks.splice(e,1)}}function ix(n){const t=dm(n),e=null!==t?t.factory:Al(n);if(null!==e)return e;if(n instanceof we)throw new ee(204,!1);if(n instanceof Function)return function h6(n){const t=n.length;if(t>0)throw Yd(t,"?"),new ee(204,!1);const e=function oH(n){return n&&(n[hm]||n[n1])||null}(n);return null!==e?()=>e.factory(n):()=>new n}(n);throw new ee(204,!1)}function yA(n,t,e){let s;if(Ol(n)){const r=Je(n);return Al(r)||ix(r)}if(tx(n))s=()=>Je(n.useValue);else if(function gA(n){return!(!n||!n.useFactory)}(n))s=()=>n.useFactory(...Q_(n.deps||[]));else if(function mA(n){return!(!n||!n.useExisting)}(n))s=()=>Se(Je(n.useExisting));else{const r=Je(n&&(n.useClass||n.provide));if(!function p6(n){return!!n.deps}(n))return Al(r)||ix(r);s=()=>new r(...Q_(n.deps))}return s}function tc(n,t,e=!1){return{factory:n,value:t,multi:e?[]:void 0}}function ox(n,t){for(const e of n)Array.isArray(e)?ox(e,t):e&&q_(e)?ox(e.\u0275providers,t):t(e)}const Qm=new we("AppId",{providedIn:"root",factory:()=>y6}),y6="ng",bA=new we("Platform Initializer"),nc=new we("Platform ID",{providedIn:"platform",factory:()=>"unknown"}),Jm=new we("AnimationModuleType"),ax=new we("CSP nonce",{providedIn:"root",factory:()=>function nh(){return void 0!==qw?qw:typeof document<"u"?document:void 0}().body?.querySelector("[ngCspNonce]")?.getAttribute("ngCspNonce")||null});let _A=(n,t)=>null;function wA(n,t){return _A(n,t)}class D6{}class SA{}class N6{resolveComponentFactory(t){throw function T6(n){const t=Error(`No component factory found for ${hs(n)}.`);return t.ngComponent=n,t}(t)}}let rg=(()=>{class n{}return n.NULL=new N6,n})();function k6(){return sc(Ps(),oe())}function sc(n,t){return new ps(br(n,t))}let ps=(()=>{class n{constructor(e){this.nativeElement=e}}return n.__NG_ELEMENT_ID__=k6,n})();function A6(n){return n instanceof ps?n.nativeElement:n}class ch{}let M6=(()=>{class n{}return n.\u0275prov=Ve({token:n,providedIn:"root",factory:()=>null}),n})();class $l{constructor(t){this.full=t,this.major=t.split(".")[0],this.minor=t.split(".")[1],this.patch=t.split(".").slice(2).join(".")}}const F6=new $l("16.0.0"),bx={};function dh(n){for(;n;){n[at]|=64;const t=Jd(n);if(rw(n)&&!t)return n;n=t}return null}function vx(n){return n.ngOriginalError}class Pl{constructor(){this._console=console}handleError(t){const e=this._findOriginalError(t);this._console.error("ERROR",t),e&&this._console.error("ORIGINAL ERROR",e)}_findOriginalError(t){let e=t&&vx(t);for(;e&&vx(e);)e=vx(e);return e||null}}const NA=new we("",{providedIn:"root",factory:()=>!1});function jo(n){return n instanceof Function?n():n}class RA extends T1{constructor(){super(...arguments),this.consumerAllowSignalWrites=!1,this._lView=null}set lView(t){this._lView=t}onConsumerDependencyMayHaveChanged(){dh(this._lView)}onProducerUpdateValueVersion(){}get hasReadASignal(){return this.hasProducers}runInContext(t,e,s){const r=Is(this);this.trackingVersion++;try{t(e,s)}finally{Is(r)}}destroy(){this.trackingVersion++}}let ag=null;function MA(){return ag??=new RA,ag}function FA(n,t){return n[t]??MA()}function OA(n,t){const e=MA();e.hasReadASignal&&(n[t]=ag,e.lView=n,ag=new RA)}const it={};function Qn(n){$A(kt(),oe(),tr()+n,!1)}function $A(n,t,e,s){if(!s)if(3==(3&t[at])){const i=n.preOrderCheckHooks;null!==i&&Tm(t,i,e)}else{const i=n.preOrderHooks;null!==i&&Nm(t,i,0,e)}Rl(e)}function BA(n,t=null,e=null,s){const r=zA(n,t,e,s);return r.resolveInjectorInitializers(),r}function zA(n,t=null,e=null,s,r=new Set){const i=[e||$t,l6(n)];return s=s||("object"==typeof n?void 0:hs(n)),new rx(i,t||Zm(),s||null,r)}let lo=(()=>{class n{static create(e,s){if(Array.isArray(e))return BA({name:""},s,e,"");{const r=e.name??"";return BA({name:r},e.parent,e.providers,r)}}}return n.THROW_IF_NOT_FOUND=Od,n.NULL=new dA,n.\u0275prov=Ve({token:n,providedIn:"any",factory:()=>Se(uA)}),n.__NG_ELEMENT_ID__=-1,n})();function ne(n,t=je.Default){const e=oe();return null===e?Se(n,t):uk(Ps(),e,Je(n),t)}function lg(n,t,e,s,r,i,o,a,l,u,c){const d=t.blueprint.slice();return d[Ss]=r,d[at]=140|s,(null!==u||n&&2048&n[at])&&(d[at]|=2048),P1(d),d[Sn]=d[Bu]=n,d[Rn]=e,d[Nl]=o||n&&n[Nl],d[rt]=a||n&&n[rt],d[Vu]=l||n&&n[Vu]||null,d[Gs]=i,d[Ud]=function cq(){return uq++}(),d[Bo]=c,d[x1]=u,d[Yn]=2==t.type?n[Yn]:d,d}function oc(n,t,e,s,r){let i=n.data[t];if(null===i)i=function _x(n,t,e,s,r){const i=W1(),o=cw(),l=n.data[t]=function t8(n,t,e,s,r,i){return{type:e,index:s,insertBeforeIndex:null,injectorIndex:t?t.injectorIndex:-1,directiveStart:-1,directiveEnd:-1,directiveStylingLast:-1,componentOffset:-1,propertyBindings:null,flags:0,providerIndexes:0,value:r,attrs:i,mergedAttrs:null,localNames:null,initialInputs:void 0,inputs:null,outputs:null,tView:null,next:null,prev:null,projectionNext:null,child:null,parent:t,projection:null,styles:null,stylesWithoutHost:null,residualStyles:void 0,classes:null,classesWithoutHost:null,residualClasses:void 0,classBindings:0,styleBindings:0}}(0,o?i:i&&i.parent,e,t,s,r);return null===n.firstChild&&(n.firstChild=l),null!==i&&(o?null==i.child&&null!==l.parent&&(i.child=l):null===i.next&&(i.next=l,l.prev=i)),l}(n,t,e,s,r),function hj(){return Ze.lFrame.inI18n}()&&(i.flags|=32);else if(64&i.type){i.type=e,i.value=s,i.attrs=r;const o=function Hd(){const n=Ze.lFrame,t=n.currentTNode;return n.isParent?t:t.parent}();i.injectorIndex=null===o?-1:o.injectorIndex}return oo(i,!0),i}function hh(n,t,e,s){if(0===e)return-1;const r=t.length;for(let i=0;i<e;i++)t.push(s),n.blueprint.push(s),n.data.push(null);return r}function WA(n,t,e,s,r){const i=FA(t,ym),o=tr(),a=2&s;try{if(Rl(-1),a&&t.length>It&&$A(n,t,It,!1),ro(a?2:0,r),a)i.runInContext(e,s,r);else{const u=Is(null);try{e(s,r)}finally{Is(u)}}}finally{a&&null===t[ym]&&OA(t,ym),Rl(o),ro(a?3:1,r)}}function wx(n,t,e){if(sw(t)){const s=Is(null);try{const i=t.directiveEnd;for(let o=t.directiveStart;o<i;o++){const a=n.data[o];a.contentQueries&&a.contentQueries(1,e[o],o)}}finally{Is(s)}}}function xx(n,t,e){U1()&&(function l8(n,t,e,s){const r=e.directiveStart,i=e.directiveEnd;kl(e)&&function m8(n,t,e){const s=br(t,n),o=ug(n,lg(n,GA(e),null,e.onPush?64:16,s,t,null,n[Nl].rendererFactory.createRenderer(s,e),null,null,null));n[t.index]=o}(t,e,n.data[r+e.componentOffset]),n.firstCreatePass||Mm(e,t),Hs(s,t);const o=e.initialInputs;for(let a=r;a<i;a++){const l=n.data[a],u=Ml(t,n,a,e);Hs(u,t),null!==o&&g8(0,a-r,u,l,0,o),Ai(l)&&(vr(e.index,t)[Rn]=Ml(t,n,a,e))}}(n,t,e,br(e,t)),64==(64&e.flags)&&XA(n,t,e))}function Cx(n,t,e=br){const s=t.localNames;if(null!==s){let r=t.index+1;for(let i=0;i<s.length;i+=2){const o=s[i+1],a=-1===o?e(t,n):n[o];n[r++]=a}}}function GA(n){const t=n.tView;return null===t||t.incompleteFirstPass?n.tView=Sx(1,null,n.template,n.decls,n.vars,n.directiveDefs,n.pipeDefs,n.viewQuery,n.schemas,n.consts,n.id):t}function Sx(n,t,e,s,r,i,o,a,l,u,c){const d=It+s,h=d+r,f=function X6(n,t){const e=[];for(let s=0;s<t;s++)e.push(s<n?null:it);return e}(d,h),p="function"==typeof u?u():u;return f[Ie]={type:n,blueprint:f,template:e,queries:null,viewQuery:a,declTNode:t,data:f.slice().fill(null,d),bindingStartIndex:d,expandoStartIndex:h,hostBindingOpCodes:null,firstCreatePass:!0,firstUpdatePass:!0,staticViewQueries:!1,staticContentQueries:!1,preOrderHooks:null,preOrderCheckHooks:null,contentHooks:null,contentCheckHooks:null,viewHooks:null,viewCheckHooks:null,destroyHooks:null,cleanup:null,contentQueries:null,components:null,directiveRegistry:"function"==typeof i?i():i,pipeRegistry:"function"==typeof o?o():o,firstChild:null,schemas:l,consts:p,incompleteFirstPass:!1,ssrId:c}}let HA=n=>null;function jA(n,t,e,s){for(let r in n)if(n.hasOwnProperty(r)){e=null===e?{}:e;const i=n[r];null===s?qA(e,t,r,i):s.hasOwnProperty(r)&&qA(e,t,s[r],i)}return e}function qA(n,t,e,s){n.hasOwnProperty(e)?n[e].push(t,s):n[e]=[t,s]}function Br(n,t,e,s,r,i,o,a){const l=br(t,e);let c,u=t.inputs;!a&&null!=u&&(c=u[s])?(Nx(n,e,c,s,r),kl(t)&&function r8(n,t){const e=vr(t,n);16&e[at]||(e[at]|=64)}(e,t.index)):3&t.type&&(s=function s8(n){return"class"===n?"className":"for"===n?"htmlFor":"formaction"===n?"formAction":"innerHtml"===n?"innerHTML":"readonly"===n?"readOnly":"tabindex"===n?"tabIndex":n}(s),r=null!=o?o(r,t.value||"",s):r,i.setProperty(l,s,r))}function Ix(n,t,e,s){if(U1()){const r=null===s?null:{"":-1},i=function c8(n,t){const e=n.directiveRegistry;let s=null,r=null;if(e)for(let i=0;i<e.length;i++){const o=e[i];if(g1(t,o.selectors,!1))if(s||(s=[]),Ai(o))if(null!==o.findHostDirectiveDefs){const a=[];r=r||new Map,o.findHostDirectiveDefs(o,a,r),s.unshift(...a,o),Ex(n,t,a.length)}else s.unshift(o),Ex(n,t,0);else r=r||new Map,o.findHostDirectiveDefs?.(o,s,r),s.push(o)}return null===s?null:[s,r]}(n,e);let o,a;null===i?o=a=null:[o,a]=i,null!==o&&KA(n,t,e,o,r,a),r&&function d8(n,t,e){if(t){const s=n.localNames=[];for(let r=0;r<t.length;r+=2){const i=e[t[r+1]];if(null==i)throw new ee(-301,!1);s.push(t[r],i)}}}(e,s,r)}e.mergedAttrs=Ld(e.mergedAttrs,e.attrs)}function KA(n,t,e,s,r,i){for(let u=0;u<s.length;u++)xw(Mm(e,t),n,s[u].type);!function f8(n,t,e){n.flags|=1,n.directiveStart=t,n.directiveEnd=t+e,n.providerIndexes=t}(e,n.data.length,s.length);for(let u=0;u<s.length;u++){const c=s[u];c.providersResolver&&c.providersResolver(c)}let o=!1,a=!1,l=hh(n,t,s.length,null);for(let u=0;u<s.length;u++){const c=s[u];e.mergedAttrs=Ld(e.mergedAttrs,c.hostAttrs),p8(n,e,t,l,c),h8(l,c,r),null!==c.contentQueries&&(e.flags|=4),(null!==c.hostBindings||null!==c.hostAttrs||0!==c.hostVars)&&(e.flags|=64);const d=c.type.prototype;!o&&(d.ngOnChanges||d.ngOnInit||d.ngDoCheck)&&((n.preOrderHooks??=[]).push(e.index),o=!0),!a&&(d.ngOnChanges||d.ngDoCheck)&&((n.preOrderCheckHooks??=[]).push(e.index),a=!0),l++}!function n8(n,t,e){const r=t.directiveEnd,i=n.data,o=t.attrs,a=[];let l=null,u=null;for(let c=t.directiveStart;c<r;c++){const d=i[c],h=e?e.get(d):null,p=h?h.outputs:null;l=jA(d.inputs,c,l,h?h.inputs:null),u=jA(d.outputs,c,u,p);const g=null===l||null===o||m1(t)?null:y8(l,c,o);a.push(g)}null!==l&&(l.hasOwnProperty("class")&&(t.flags|=8),l.hasOwnProperty("style")&&(t.flags|=16)),t.initialInputs=a,t.inputs=l,t.outputs=u}(n,e,i)}function XA(n,t,e){const s=e.directiveStart,r=e.directiveEnd,i=e.index,o=function pj(){return Ze.lFrame.currentDirectiveIndex}();try{Rl(i);for(let a=s;a<r;a++){const l=n.data[a],u=t[a];hw(a),(null!==l.hostBindings||0!==l.hostVars||null!==l.hostAttrs)&&u8(l,u)}}finally{Rl(-1),hw(o)}}function u8(n,t){null!==n.hostBindings&&n.hostBindings(1,t)}function Ex(n,t,e){t.componentOffset=e,(n.components??=[]).push(t.index)}function h8(n,t,e){if(e){if(t.exportAs)for(let s=0;s<t.exportAs.length;s++)e[t.exportAs[s]]=n;Ai(t)&&(e[""]=n)}}function p8(n,t,e,s,r){n.data[s]=r;const i=r.factory||(r.factory=Al(r.type)),o=new jd(i,Ai(r),ne);n.blueprint[s]=o,e[s]=o,function o8(n,t,e,s,r){const i=r.hostBindings;if(i){let o=n.hostBindingOpCodes;null===o&&(o=n.hostBindingOpCodes=[]);const a=~t.index;(function a8(n){let t=n.length;for(;t>0;){const e=n[--t];if("number"==typeof e&&e<0)return e}return 0})(o)!=a&&o.push(a),o.push(e,s,i)}}(n,t,s,hh(n,e,r.hostVars,it),r)}function uo(n,t,e,s,r,i){const o=br(n,t);!function Dx(n,t,e,s,r,i,o){if(null==i)n.removeAttribute(t,r,e);else{const a=null==o?et(i):o(i,s||"",r);n.setAttribute(t,r,a,e)}}(t[rt],o,i,n.value,e,s,r)}function g8(n,t,e,s,r,i){const o=i[t];if(null!==o)for(let a=0;a<o.length;)YA(s,e,o[a++],o[a++],o[a++])}function YA(n,t,e,s,r){const i=Is(null);try{null!==n.setInput?n.setInput(t,r,e,s):t[s]=r}finally{Is(i)}}function y8(n,t,e){let s=null,r=0;for(;r<e.length;){const i=e[r];if(0!==i)if(5!==i){if("number"==typeof i)break;if(n.hasOwnProperty(i)){null===s&&(s=[]);const o=n[i];for(let a=0;a<o.length;a+=2)if(o[a]===t){s.push(i,o[a+1],e[r+1]);break}}r+=2}else r+=2;else r+=4}return s}function ZA(n,t,e,s){return[n,!0,!1,t,null,0,s,e,null,null,null]}function QA(n,t){const e=n.contentQueries;if(null!==e)for(let s=0;s<e.length;s+=2){const i=e[s+1];if(-1!==i){const o=n.data[i];pw(e[s]),o.contentQueries(2,t[i],i)}}}function ug(n,t){return n[Bd]?n[w1][ki]=t:n[Bd]=t,n[w1]=t,t}function Tx(n,t,e){pw(0);const s=Is(null);try{t(n,e)}finally{Is(s)}}function JA(n){return n[Lu]||(n[Lu]=[])}function eR(n){return n.cleanup||(n.cleanup=[])}function nR(n,t){const e=n[Vu],s=e?e.get(Pl,null):null;s&&s.handleError(t)}function Nx(n,t,e,s,r){for(let i=0;i<e.length;){const o=e[i++],a=e[i++];YA(n.data[o],t[o],s,a,r)}}function qo(n,t,e){const s=Sm(t,n);!function Ok(n,t,e){n.setValue(t,e)}(n[rt],s,e)}function b8(n,t){const e=vr(t,n),s=e[Ie];!function v8(n,t){for(let e=t.length;e<n.blueprint.length;e++)t.push(n.blueprint[e])}(s,e);const r=e[Ss];null!==r&&null===e[Bo]&&(e[Bo]=wA(r,e[Vu])),kx(s,e,e[Rn])}function kx(n,t,e){mw(t);try{const s=n.viewQuery;null!==s&&Tx(1,s,e);const r=n.template;null!==r&&WA(n,t,r,1,e),n.firstCreatePass&&(n.firstCreatePass=!1),n.staticContentQueries&&QA(n,t),n.staticViewQueries&&Tx(2,n.viewQuery,e);const i=n.components;null!==i&&function _8(n,t){for(let e=0;e<t.length;e++)b8(n,t[e])}(t,i)}catch(s){throw n.firstCreatePass&&(n.incompleteFirstPass=!0,n.firstCreatePass=!1),s}finally{t[at]&=-5,gw()}}let sR=(()=>{class n{constructor(){this.all=new Set,this.queue=new Map}create(e,s,r){const i=typeof Zone>"u"?null:Zone.current,o=new WH(e,u=>{this.all.has(u)&&this.queue.set(u,i)},r);let a;this.all.add(o),o.notify();const l=()=>{o.cleanup(),a?.(),this.all.delete(o),this.queue.delete(o)};return a=s?.onDestroy(l),{destroy:l}}flush(){if(0!==this.queue.size)for(const[e,s]of this.queue)this.queue.delete(e),s?s.run(()=>e.run()):e.run()}get isQueueEmpty(){return 0===this.queue.size}}return n.\u0275prov=Ve({token:n,providedIn:"root",factory:()=>new n}),n})();function cg(n,t,e){let s=e?n.styles:null,r=e?n.classes:null,i=0;if(null!==t)for(let o=0;o<t.length;o++){const a=t[o];"number"==typeof a?i=a:1==i?r=H_(r,a):2==i&&(s=H_(s,a+": "+t[++o]+";"))}e?n.styles=s:n.stylesWithoutHost=s,e?n.classes=r:n.classesWithoutHost=r}function fh(n,t,e,s,r=!1){for(;null!==e;){const i=t[e.index];if(null!==i&&s.push(fn(i)),Lr(i)){for(let a=$s;a<i.length;a++){const l=i[a],u=l[Ie].firstChild;null!==u&&fh(l[Ie],l,u,s)}i[no]!==i[Ss]&&s.push(i[no])}const o=e.type;if(8&o)fh(n,t,e.child,s);else if(32&o){const a=$w(e,t);let l;for(;l=a();)s.push(l)}else if(16&o){const a=Hk(t,e);if(Array.isArray(a))s.push(...a);else{const l=Jd(t[Yn]);fh(l[Ie],l,a,s,!0)}}e=r?e.projectionNext:e.next}return s}function dg(n,t,e,s=!0){const r=t[Nl].rendererFactory;r.begin&&r.begin();try{hg(n,t,n.template,e)}catch(o){throw s&&nR(t,o),o}finally{r.end&&r.end(),t[Nl].effectManager?.flush()}}function hg(n,t,e,s){const r=t[at];if(256!=(256&r)){t[Nl].effectManager?.flush(),mw(t);try{P1(t),function H1(n){return Ze.lFrame.bindingIndex=n}(n.bindingStartIndex),null!==e&&WA(n,t,e,2,s);const o=3==(3&r);if(o){const u=n.preOrderCheckHooks;null!==u&&Tm(t,u,null)}else{const u=n.preOrderHooks;null!==u&&Nm(t,u,0,null),yw(t,0)}if(function E8(n){for(let t=Pw(n);null!==t;t=Lw(t)){if(!t[C1])continue;const e=t[Uu];for(let s=0;s<e.length;s++){JH(e[s])}}}(t),function I8(n){for(let t=Pw(n);null!==t;t=Lw(t))for(let e=$s;e<t.length;e++){const s=t[e],r=s[Ie];Im(s)&&hg(r,s,r.template,s[Rn])}}(t),null!==n.contentQueries&&QA(n,t),o){const u=n.contentCheckHooks;null!==u&&Tm(t,u)}else{const u=n.contentHooks;null!==u&&Nm(t,u,1),yw(t,1)}!function K6(n,t){const e=n.hostBindingOpCodes;if(null===e)return;const s=FA(t,bm);try{for(let r=0;r<e.length;r++){const i=e[r];if(i<0)Rl(~i);else{const o=i,a=e[++r],l=e[++r];fj(a,o),s.runInContext(l,2,t[o])}}}finally{null===t[bm]&&OA(t,bm),Rl(-1)}}(n,t);const a=n.components;null!==a&&function T8(n,t){for(let e=0;e<t.length;e++)D8(n,t[e])}(t,a);const l=n.viewQuery;if(null!==l&&Tx(2,l,s),o){const u=n.viewCheckHooks;null!==u&&Tm(t,u)}else{const u=n.viewHooks;null!==u&&Nm(t,u,2),yw(t,2)}!0===n.firstUpdatePass&&(n.firstUpdatePass=!1),t[at]&=-73,L1(t)}finally{gw()}}}function D8(n,t){const e=vr(t,n);if(Im(e)){const s=e[Ie];80&e[at]?hg(s,e,s.template,e[Rn]):e[Tl]>0&&Ax(e)}}function Ax(n){for(let s=Pw(n);null!==s;s=Lw(s))for(let r=$s;r<s.length;r++){const i=s[r];if(Im(i))if(1024&i[at]){const o=i[Ie];hg(o,i,o.template,i[Rn])}else i[Tl]>0&&Ax(i)}const e=n[Ie].components;if(null!==e)for(let s=0;s<e.length;s++){const r=vr(e[s],n);Im(r)&&r[Tl]>0&&Ax(r)}}class ph{get rootNodes(){const t=this._lView,e=t[Ie];return fh(e,t,e.firstChild,[])}constructor(t,e){this._lView=t,this._cdRefInjectingView=e,this._appRef=null,this._attachedToViewContainer=!1}get context(){return this._lView[Rn]}set context(t){this._lView[Rn]=t}get destroyed(){return 256==(256&this._lView[at])}destroy(){if(this._appRef)this._appRef.detachView(this);else if(this._attachedToViewContainer){const t=this._lView[Sn];if(Lr(t)){const e=t[vm],s=e?e.indexOf(this):-1;s>-1&&(Bw(t,s),$m(e,s))}this._attachedToViewContainer=!1}Pk(this._lView[Ie],this._lView)}onDestroy(t){!function B1(n,t){if(256==(256&n[at]))throw new ee(911,!1);null===n[Ca]&&(n[Ca]=[]),n[Ca].push(t)}(this._lView,t)}markForCheck(){dh(this._cdRefInjectingView||this._lView)}detach(){this._lView[at]&=-129}reattach(){this._lView[at]|=128}detectChanges(){dg(this._lView[Ie],this._lView,this.context)}checkNoChanges(){}attachToViewContainerRef(){if(this._appRef)throw new ee(902,!1);this._attachedToViewContainer=!0}detachFromAppRef(){this._appRef=null,function Sq(n,t){th(n,t,t[rt],2,null,null)}(this._lView[Ie],this._lView)}attachToAppRef(t){if(this._attachedToViewContainer)throw new ee(902,!1);this._appRef=t}}class N8 extends ph{constructor(t){super(t),this._view=t}detectChanges(){const t=this._view;dg(t[Ie],t,t[Rn],!1)}checkNoChanges(){}get context(){return null}}class rR extends rg{constructor(t){super(),this.ngModule=t}resolveComponentFactory(t){const e=Lt(t);return new mh(e,this.ngModule)}}function iR(n){const t=[];for(let e in n)n.hasOwnProperty(e)&&t.push({propName:n[e],templateName:e});return t}class A8{constructor(t,e){this.injector=t,this.parentInjector=e}get(t,e,s){s=pm(s);const r=this.injector.get(t,bx,s);return r!==bx||e===bx?r:this.parentInjector.get(t,e,s)}}class mh extends SA{get inputs(){return iR(this.componentDef.inputs)}get outputs(){return iR(this.componentDef.outputs)}constructor(t,e){super(),this.componentDef=t,this.ngModule=e,this.componentType=t.type,this.selector=function IH(n){return n.map(SH).join(",")}(t.selectors),this.ngContentSelectors=t.ngContentSelectors?t.ngContentSelectors:[],this.isBoundToModule=!!e}create(t,e,s,r){let i=(r=r||this.ngModule)instanceof Go?r:r?.injector;i&&null!==this.componentDef.getStandaloneInjector&&(i=this.componentDef.getStandaloneInjector(i)||i);const o=i?new A8(t,i):t,a=o.get(ch,null);if(null===a)throw new ee(407,!1);const c={rendererFactory:a,sanitizer:o.get(M6,null),effectManager:o.get(sR,null)},d=a.createRenderer(null,this.componentDef),h=this.componentDef.selectors[0][0]||"div",f=s?function Y6(n,t,e,s){const i=s.get(NA,!1)||e===mr.ShadowDom,o=n.selectRootElement(t,i);return function Z6(n){HA(n)}(o),o}(d,s,this.componentDef.encapsulation,o):Wm(d,h,function k8(n){const t=n.toLowerCase();return"svg"===t?"svg":"math"===t?"math":null}(h)),p=this.componentDef.onPush?576:528,g=Sx(0,null,null,1,0,null,null,null,null,null,null),m=lg(null,g,null,p,null,null,c,d,o,null,null);let y,b;mw(m);try{const v=this.componentDef;let _,x=null;v.findHostDirectiveDefs?(_=[],x=new Map,v.findHostDirectiveDefs(v,_,x),_.push(v)):_=[v];const C=function M8(n,t){const e=n[Ie],s=It;return n[s]=t,oc(e,s,2,"#host",null)}(m,f),E=function F8(n,t,e,s,r,i,o){const a=r[Ie];!function O8(n,t,e,s){for(const r of n)t.mergedAttrs=Ld(t.mergedAttrs,r.hostAttrs);null!==t.mergedAttrs&&(cg(t,t.mergedAttrs,!0),null!==e&&Xk(s,e,t))}(s,n,t,o);let l=null;null!==t&&(l=wA(t,r[Vu]));const u=i.rendererFactory.createRenderer(t,e),c=lg(r,GA(e),null,e.onPush?64:16,r[n.index],n,i,u,null,null,l);return a.firstCreatePass&&Ex(a,n,s.length-1),ug(r,c),r[n.index]=c}(C,f,v,_,m,c,d);b=$1(g,It),f&&function P8(n,t,e,s){if(s)tw(n,e,["ng-version",F6.full]);else{const{attrs:r,classes:i}=function EH(n){const t=[],e=[];let s=1,r=2;for(;s<n.length;){let i=n[s];if("string"==typeof i)2===r?""!==i&&t.push(i,n[++s]):8===r&&e.push(i);else{if(!Ni(r))break;r=i}s++}return{attrs:t,classes:e}}(t.selectors[0]);r&&tw(n,e,r),i&&i.length>0&&Kk(n,e,i.join(" "))}}(d,v,f,s),void 0!==e&&function L8(n,t,e){const s=n.projection=[];for(let r=0;r<t.length;r++){const i=e[r];s.push(null!=i?Array.from(i):null)}}(b,this.ngContentSelectors,e),y=function $8(n,t,e,s,r,i){const o=Ps(),a=r[Ie],l=br(o,r);KA(a,r,o,e,null,s);for(let c=0;c<e.length;c++)Hs(Ml(r,a,o.directiveStart+c,o),r);XA(a,r,o),l&&Hs(l,r);const u=Ml(r,a,o.directiveStart+o.componentOffset,o);if(n[Rn]=r[Rn]=u,null!==i)for(const c of i)c(u,t);return wx(a,o,n),u}(E,v,_,x,m,[V8]),kx(g,m,null)}finally{gw()}return new R8(this.componentType,y,sc(b,m),m,b)}}class R8 extends D6{constructor(t,e,s,r,i){super(),this.location=s,this._rootLView=r,this._tNode=i,this.previousInputValues=null,this.instance=e,this.hostView=this.changeDetectorRef=new N8(r),this.componentType=t}setInput(t,e){const s=this._tNode.inputs;let r;if(null!==s&&(r=s[t])){if(this.previousInputValues??=new Map,this.previousInputValues.has(t)&&Object.is(this.previousInputValues.get(t),e))return;const i=this._rootLView;Nx(i[Ie],i,r,t,e),this.previousInputValues.set(t,e),dh(vr(this._tNode.index,i))}}get injector(){return new ju(this._tNode,this._rootLView)}destroy(){this.hostView.destroy()}onDestroy(t){this.hostView.onDestroy(t)}}function V8(){const n=Ps();Dm(oe()[Ie],n)}function Vt(n){let t=function oR(n){return Object.getPrototypeOf(n.prototype).constructor}(n.type),e=!0;const s=[n];for(;t;){let r;if(Ai(n))r=t.\u0275cmp||t.\u0275dir;else{if(t.\u0275cmp)throw new ee(903,!1);r=t.\u0275dir}if(r){if(e){s.push(r);const o=n;o.inputs=Rx(n.inputs),o.declaredInputs=Rx(n.declaredInputs),o.outputs=Rx(n.outputs);const a=r.hostBindings;a&&W8(n,a);const l=r.viewQuery,u=r.contentQueries;if(l&&z8(n,l),u&&U8(n,u),G_(n.inputs,r.inputs),G_(n.declaredInputs,r.declaredInputs),G_(n.outputs,r.outputs),Ai(r)&&r.data.animation){const c=n.data;c.animation=(c.animation||[]).concat(r.data.animation)}}const i=r.features;if(i)for(let o=0;o<i.length;o++){const a=i[o];a&&a.ngInherit&&a(n),a===Vt&&(e=!1)}}t=Object.getPrototypeOf(t)}!function B8(n){let t=0,e=null;for(let s=n.length-1;s>=0;s--){const r=n[s];r.hostVars=t+=r.hostVars,r.hostAttrs=Ld(r.hostAttrs,e=Ld(e,r.hostAttrs))}}(s)}function Rx(n){return n===Lo?{}:n===$t?[]:n}function z8(n,t){const e=n.viewQuery;n.viewQuery=e?(s,r)=>{t(s,r),e(s,r)}:t}function U8(n,t){const e=n.contentQueries;n.contentQueries=e?(s,r,i)=>{t(s,r,i),e(s,r,i)}:t}function W8(n,t){const e=n.hostBindings;n.hostBindings=e?(s,r)=>{t(s,r),e(s,r)}:t}function fg(n){return!!function Mx(n){return null!==n&&("function"==typeof n||"object"==typeof n)}(n)&&(Array.isArray(n)||!(n instanceof Map)&&Symbol.iterator in n)}function js(n,t,e){return!Object.is(n[t],e)&&(n[t]=e,!0)}function Ll(n,t,e,s){const r=js(n,t,e);return js(n,t+1,s)||r}function Ri(n,t,e,s){const r=oe();return js(r,Gu(),t)&&(kt(),uo(In(),r,n,t,e,s)),Ri}function lc(n,t,e,s){return js(n,Gu(),e)?t+et(e)+s:it}function uc(n,t,e,s,r,i){const a=Ll(n,function zo(){return Ze.lFrame.bindingIndex}(),e,r);return Uo(2),a?t+et(e)+s+et(r)+i:it}function gc(n,t,e,s,r,i,o,a){const l=oe(),u=kt(),c=n+It,d=u.firstCreatePass?function p5(n,t,e,s,r,i,o,a,l){const u=t.consts,c=oc(t,n,4,o||null,Sa(u,a));Ix(t,e,c,Sa(u,l)),Dm(t,c);const d=c.tView=Sx(2,c,s,r,i,t.directiveRegistry,t.pipeRegistry,null,t.schemas,u,null);return null!==t.queries&&(t.queries.template(t,c),d.queries=t.queries.embeddedTView(c)),c}(c,u,l,t,e,s,r,i,o):u.data[c];oo(d,!1);const h=xR(u,l,d,n);Em()&&Hm(u,l,h,d),Hs(h,l),ug(l,l[c]=ZA(h,l,h,d)),_m(d)&&xx(u,l,d),null!=o&&Cx(l,d,a)}let xR=function CR(n,t,e,s){return Ia(!0),t[rt].createComment("")};function zr(n,t,e){const s=oe();return js(s,Gu(),t)&&Br(kt(),In(),s,n,t,s[rt],e,!1),zr}function Vx(n,t,e,s,r){const o=r?"class":"style";Nx(n,e,t.inputs[o],o,s)}function At(n,t,e,s){const r=oe(),i=kt(),o=It+n,a=r[rt],l=i.firstCreatePass?function v5(n,t,e,s,r,i){const o=t.consts,l=oc(t,n,2,s,Sa(o,r));return Ix(t,e,l,Sa(o,i)),null!==l.attrs&&cg(l,l.attrs,!1),null!==l.mergedAttrs&&cg(l,l.mergedAttrs,!0),null!==t.queries&&t.queries.elementStart(t,l),l}(o,i,r,t,e,s):i.data[o],u=SR(i,r,l,a,t,n);r[o]=u;const c=_m(l);return oo(l,!0),Xk(a,u,l),32!=(32&l.flags)&&Em()&&Hm(i,r,u,l),0===function tj(){return Ze.lFrame.elementDepthCount}()&&Hs(u,r),function nj(){Ze.lFrame.elementDepthCount++}(),c&&(xx(i,r,l),wx(i,l,r)),null!==s&&Cx(r,l),At}function Rt(){let n=Ps();cw()?dw():(n=n.parent,oo(n,!1));const t=n;(function rj(n){return Ze.skipHydrationRootTNode===n})(t)&&function lj(){Ze.skipHydrationRootTNode=null}(),function sj(){Ze.lFrame.elementDepthCount--}();const e=kt();return e.firstCreatePass&&(Dm(e,n),sw(n)&&e.queries.elementEnd(n)),null!=t.classesWithoutHost&&function Ij(n){return 0!=(8&n.flags)}(t)&&Vx(e,t,oe(),t.classesWithoutHost,!0),null!=t.stylesWithoutHost&&function Ej(n){return 0!=(16&n.flags)}(t)&&Vx(e,t,oe(),t.stylesWithoutHost,!1),Rt}function Ko(n,t,e,s){return At(n,t,e,s),Rt(),Ko}let SR=(n,t,e,s,r,i)=>(Ia(!0),Wm(s,r,function J1(){return Ze.lFrame.currentNamespace}()));function bg(n,t,e){const s=oe(),r=kt(),i=n+It,o=r.firstCreatePass?function x5(n,t,e,s,r){const i=t.consts,o=Sa(i,s),a=oc(t,n,8,"ng-container",o);return null!==o&&cg(a,o,!0),Ix(t,e,a,Sa(i,r)),null!==t.queries&&t.queries.elementStart(t,a),a}(i,r,s,t,e):r.data[i];oo(o,!0);const a=ER(r,s,o,n);return s[i]=a,Em()&&Hm(r,s,a,o),Hs(a,s),_m(o)&&(xx(r,s,o),wx(r,o,s)),null!=e&&Cx(s,o),bg}function vg(){let n=Ps();const t=kt();return cw()?dw():(n=n.parent,oo(n,!1)),t.firstCreatePass&&(Dm(t,n),sw(n)&&t.queries.elementEnd(n)),vg}let ER=(n,t,e,s)=>(Ia(!0),Vw(t[rt],""));function _h(n){return!!n&&"function"==typeof n.then}function DR(n){return!!n&&"function"==typeof n.subscribe}function ms(n,t,e,s){const r=oe(),i=kt(),o=Ps();return function NR(n,t,e,s,r,i,o){const a=_m(s),u=n.firstCreatePass&&eR(n),c=t[Rn],d=JA(t);let h=!0;if(3&s.type||o){const g=br(s,t),m=o?o(g):g,y=d.length,b=o?_=>o(fn(_[s.index])):s.index;let v=null;if(!o&&a&&(v=function E5(n,t,e,s){const r=n.cleanup;if(null!=r)for(let i=0;i<r.length-1;i+=2){const o=r[i];if(o===e&&r[i+1]===s){const a=t[Lu],l=r[i+2];return a.length>l?a[l]:null}"string"==typeof o&&(i+=2)}return null}(n,t,r,s.index)),null!==v)(v.__ngLastListenerFn__||v).__ngNextListenerFn__=i,v.__ngLastListenerFn__=i,h=!1;else{i=AR(s,t,c,i,!1);const _=e.listen(m,r,i);d.push(i,_),u&&u.push(r,b,y,y+1)}}else i=AR(s,t,c,i,!1);const f=s.outputs;let p;if(h&&null!==f&&(p=f[r])){const g=p.length;if(g)for(let m=0;m<g;m+=2){const x=t[p[m]][p[m+1]].subscribe(i),C=d.length;d.push(i,x),u&&u.push(r,s.index,C,-(C+1))}}}(i,r,r[rt],o,n,t,s),ms}function kR(n,t,e,s){try{return ro(6,t,e),!1!==e(s)}catch(r){return nR(n,r),!1}finally{ro(7,t,e)}}function AR(n,t,e,s,r){return function i(o){if(o===Function)return s;dh(n.componentOffset>-1?vr(n.index,t):t);let l=kR(t,e,s,o),u=i.__ngNextListenerFn__;for(;u;)l=kR(t,e,u,o)&&l,u=u.__ngNextListenerFn__;return r&&!1===l&&(o.preventDefault(),o.returnValue=!1),l}}function yc(n=1){return function gj(n){return(Ze.lFrame.contextLView=function yj(n,t){for(;n>0;)t=t[Bu],n--;return t}(n,Ze.lFrame.contextLView))[Rn]}(n)}function D5(n,t){let e=null;const s=function _H(n){const t=n.attrs;if(null!=t){const e=t.indexOf(5);if(!(1&e))return t[e+1]}return null}(n);for(let r=0;r<t.length;r++){const i=t[r];if("*"!==i){if(null===s?g1(n,i,!0):CH(s,i))return r}else e=r}return e}function MR(n,t=0,e){const s=oe(),r=kt(),i=oc(r,It+n,16,null,e||null);null===i.projection&&(i.projection=t),dw(),(!s[Bo]||function Gd(){return null!==Ze.skipHydrationRootTNode}())&&32!=(32&i.flags)&&function Rq(n,t,e){qk(t[rt],0,t,e,Uw(n,e,t),zk(e.parent||t[Gs],e,t))}(r,s,i)}function wh(n,t,e){return Bx(n,"",t,"",e),wh}function Bx(n,t,e,s,r){const i=oe(),o=lc(i,t,e,s);return o!==it&&Br(kt(),In(),i,n,o,i[rt],r,!1),Bx}function _g(n,t){return n<<17|t<<2}function Da(n){return n>>17&32767}function zx(n){return 2|n}function Vl(n){return(131068&n)>>2}function Ux(n,t){return-131069&n|t<<2}function Wx(n){return 1|n}function UR(n,t,e,s,r){const i=n[e+1],o=null===t;let a=s?Da(i):Vl(i),l=!1;for(;0!==a&&(!1===l||o);){const c=n[a+1];M5(n[a],t)&&(l=!0,n[a+1]=s?Wx(c):zx(c)),a=s?Da(c):Vl(c)}l&&(n[e+1]=s?zx(i):Wx(i))}function M5(n,t){return null===n||null==t||(Array.isArray(n)?n[1]:n)===t||!(!Array.isArray(n)||"string"!=typeof t)&&Zu(n,t)>=0}const gs={textEnd:0,key:0,keyEnd:0,value:0,valueEnd:0};function WR(n){return n.substring(gs.key,gs.keyEnd)}function GR(n,t){const e=gs.textEnd;return e===t?-1:(t=gs.keyEnd=function P5(n,t,e){for(;t<e&&n.charCodeAt(t)>32;)t++;return t}(n,gs.key=t,e),bc(n,t,e))}function bc(n,t,e){for(;t<e&&n.charCodeAt(t)<=32;)t++;return t}function Gx(n,t,e){return Mi(n,t,e,!1),Gx}function vc(n,t){return Mi(n,t,null,!0),vc}function XR(n){!function Fi(n,t,e,s){const r=kt(),i=Uo(2);r.firstUpdatePass&&ZR(r,null,i,s);const o=oe();if(e!==it&&js(o,i,e)){const a=r.data[tr()];if(tM(a,s)&&!YR(r,i)){let l=s?a.classesWithoutHost:a.stylesWithoutHost;null!==l&&(e=H_(l,e||"")),Vx(r,a,o,e,s)}else!function q5(n,t,e,s,r,i,o,a){r===it&&(r=$t);let l=0,u=0,c=0<r.length?r[0]:null,d=0<i.length?i[0]:null;for(;null!==c||null!==d;){const h=l<r.length?r[l+1]:void 0,f=u<i.length?i[u+1]:void 0;let g,p=null;c===d?(l+=2,u+=2,h!==f&&(p=d,g=f)):null===d||null!==c&&c<d?(l+=2,p=c):(u+=2,p=d,g=f),null!==p&&JR(n,t,e,s,p,g,o,a),c=l<r.length?r[l]:null,d=u<i.length?i[u]:null}}(r,a,o,o[rt],o[i+1],o[i+1]=function H5(n,t,e){if(null==e||""===e)return $t;const s=[],r=Ea(e);if(Array.isArray(r))for(let i=0;i<r.length;i++)n(s,r[i],!0);else if("object"==typeof r)for(const i in r)r.hasOwnProperty(i)&&n(s,i,r[i]);else"string"==typeof r&&t(s,r);return s}(n,t,e),s,i)}}(j5,fo,n,!0)}function fo(n,t){for(let e=function O5(n){return function jR(n){gs.key=0,gs.keyEnd=0,gs.value=0,gs.valueEnd=0,gs.textEnd=n.length}(n),GR(n,bc(n,0,gs.textEnd))}(t);e>=0;e=GR(t,e))Vr(n,WR(t),!0)}function Mi(n,t,e,s){const r=oe(),i=kt(),o=Uo(2);i.firstUpdatePass&&ZR(i,n,o,s),t!==it&&js(r,o,t)&&JR(i,i.data[tr()],r,r[rt],n,r[o+1]=function K5(n,t){return null==n||""===n||("string"==typeof t?n+=t:"object"==typeof n&&(n=hs(Ea(n)))),n}(t,e),s,o)}function YR(n,t){return t>=n.expandoStartIndex}function ZR(n,t,e,s){const r=n.data;if(null===r[e+1]){const i=r[tr()],o=YR(n,e);tM(i,s)&&null===t&&!o&&(t=!1),t=function z5(n,t,e,s){const r=function fw(n){const t=Ze.lFrame.currentDirectiveIndex;return-1===t?null:n[t]}(n);let i=s?t.residualClasses:t.residualStyles;if(null===r)0===(s?t.classBindings:t.styleBindings)&&(e=xh(e=Hx(null,n,t,e,s),t.attrs,s),i=null);else{const o=t.directiveStylingLast;if(-1===o||n[o]!==r)if(e=Hx(r,n,t,e,s),null===i){let l=function U5(n,t,e){const s=e?t.classBindings:t.styleBindings;if(0!==Vl(s))return n[Da(s)]}(n,t,s);void 0!==l&&Array.isArray(l)&&(l=Hx(null,n,t,l[1],s),l=xh(l,t.attrs,s),function W5(n,t,e,s){n[Da(e?t.classBindings:t.styleBindings)]=s}(n,t,s,l))}else i=function G5(n,t,e){let s;const r=t.directiveEnd;for(let i=1+t.directiveStylingLast;i<r;i++)s=xh(s,n[i].hostAttrs,e);return xh(s,t.attrs,e)}(n,t,s)}return void 0!==i&&(s?t.residualClasses=i:t.residualStyles=i),e}(r,i,t,s),function A5(n,t,e,s,r,i){let o=i?t.classBindings:t.styleBindings,a=Da(o),l=Vl(o);n[s]=e;let c,u=!1;if(Array.isArray(e)?(c=e[1],(null===c||Zu(e,c)>0)&&(u=!0)):c=e,r)if(0!==l){const h=Da(n[a+1]);n[s+1]=_g(h,a),0!==h&&(n[h+1]=Ux(n[h+1],s)),n[a+1]=function N5(n,t){return 131071&n|t<<17}(n[a+1],s)}else n[s+1]=_g(a,0),0!==a&&(n[a+1]=Ux(n[a+1],s)),a=s;else n[s+1]=_g(l,0),0===a?a=s:n[l+1]=Ux(n[l+1],s),l=s;u&&(n[s+1]=zx(n[s+1])),UR(n,c,s,!0),UR(n,c,s,!1),function R5(n,t,e,s,r){const i=r?n.residualClasses:n.residualStyles;null!=i&&"string"==typeof t&&Zu(i,t)>=0&&(e[s+1]=Wx(e[s+1]))}(t,c,n,s,i),o=_g(a,l),i?t.classBindings=o:t.styleBindings=o}(r,i,t,e,o,s)}}function Hx(n,t,e,s,r){let i=null;const o=e.directiveEnd;let a=e.directiveStylingLast;for(-1===a?a=e.directiveStart:a++;a<o&&(i=t[a],s=xh(s,i.hostAttrs,r),i!==n);)a++;return null!==n&&(e.directiveStylingLast=a),s}function xh(n,t,e){const s=e?1:2;let r=-1;if(null!==t)for(let i=0;i<t.length;i++){const o=t[i];"number"==typeof o?r=o:r===s&&(Array.isArray(n)||(n=void 0===n?[]:["",n]),Vr(n,o,!!e||t[++i]))}return void 0===n?null:n}function j5(n,t,e){const s=String(t);""!==s&&!s.includes(" ")&&Vr(n,s,e)}function JR(n,t,e,s,r,i,o,a){if(!(3&t.type))return;const l=n.data,u=l[a+1],c=function k5(n){return 1==(1&n)}(u)?eM(l,t,e,r,Vl(u),o):void 0;wg(c)||(wg(i)||function T5(n){return 2==(2&n)}(u)&&(i=eM(l,null,e,r,a,o)),function Fq(n,t,e,s,r){if(t)r?n.addClass(e,s):n.removeClass(e,s);else{let i=-1===s.indexOf("-")?void 0:_r.DashCase;null==r?n.removeStyle(e,s,i):("string"==typeof r&&r.endsWith("!important")&&(r=r.slice(0,-10),i|=_r.Important),n.setStyle(e,s,r,i))}}(s,o,Sm(tr(),e),r,i))}function eM(n,t,e,s,r,i){const o=null===t;let a;for(;r>0;){const l=n[r],u=Array.isArray(l),c=u?l[1]:l,d=null===c;let h=e[r+1];h===it&&(h=d?$t:void 0);let f=d?Iw(h,s):c===s?h:void 0;if(u&&!wg(f)&&(f=Iw(l,s)),wg(f)&&(a=f,o))return a;const p=n[r+1];r=o?Da(p):Vl(p)}if(null!==t){let l=i?t.residualClasses:t.residualStyles;null!=l&&(a=Iw(l,s))}return a}function wg(n){return void 0!==n}function tM(n,t){return 0!=(n.flags&(t?8:16))}function En(n,t=""){const e=oe(),s=kt(),r=n+It,i=s.firstCreatePass?oc(s,r,1,t,null):s.data[r],o=nM(s,e,i,t,n);e[r]=o,Em()&&Hm(s,e,o,i),oo(i,!1)}let nM=(n,t,e,s,r)=>(Ia(!0),function Um(n,t){return n.createText(t)}(t[rt],s));function _c(n){return Ch("",n,""),_c}function Ch(n,t,e){const s=oe(),r=lc(s,n,t,e);return r!==it&&qo(s,tr(),r),Ch}function jx(n,t,e,s,r){const i=oe(),o=uc(i,n,t,e,s,r);return o!==it&&qo(i,tr(),o),jx}const Bl=void 0;var gK=["en",[["a","p"],["AM","PM"],Bl],[["AM","PM"],Bl,Bl],[["S","M","T","W","T","F","S"],["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],["Su","Mo","Tu","We","Th","Fr","Sa"]],Bl,[["J","F","M","A","M","J","J","A","S","O","N","D"],["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],["January","February","March","April","May","June","July","August","September","October","November","December"]],Bl,[["B","A"],["BC","AD"],["Before Christ","Anno Domini"]],0,[6,0],["M/d/yy","MMM d, y","MMMM d, y","EEEE, MMMM d, y"],["h:mm a","h:mm:ss a","h:mm:ss a z","h:mm:ss a zzzz"],["{1}, {0}",Bl,"{1} 'at' {0}",Bl],[".",",",";","%","+","-","E","\xd7","\u2030","\u221e","NaN",":"],["#,##0.###","#,##0%","\xa4#,##0.00","#E0"],"USD","$","US Dollar",{},"ltr",function mK(n){const e=Math.floor(Math.abs(n)),s=n.toString().replace(/^[^.]*\.?/,"").length;return 1===e&&0===s?1:5}];let wc={};function nr(n){const t=function yK(n){return n.toLowerCase().replace(/_/g,"-")}(n);let e=xM(t);if(e)return e;const s=t.split("-")[0];if(e=xM(s),e)return e;if("en"===s)return gK;throw new ee(701,!1)}function xM(n){return n in wc||(wc[n]=ln.ng&&ln.ng.common&&ln.ng.common.locales&&ln.ng.common.locales[n]),wc[n]}var Ee=(()=>((Ee=Ee||{})[Ee.LocaleId=0]="LocaleId",Ee[Ee.DayPeriodsFormat=1]="DayPeriodsFormat",Ee[Ee.DayPeriodsStandalone=2]="DayPeriodsStandalone",Ee[Ee.DaysFormat=3]="DaysFormat",Ee[Ee.DaysStandalone=4]="DaysStandalone",Ee[Ee.MonthsFormat=5]="MonthsFormat",Ee[Ee.MonthsStandalone=6]="MonthsStandalone",Ee[Ee.Eras=7]="Eras",Ee[Ee.FirstDayOfWeek=8]="FirstDayOfWeek",Ee[Ee.WeekendRange=9]="WeekendRange",Ee[Ee.DateFormat=10]="DateFormat",Ee[Ee.TimeFormat=11]="TimeFormat",Ee[Ee.DateTimeFormat=12]="DateTimeFormat",Ee[Ee.NumberSymbols=13]="NumberSymbols",Ee[Ee.NumberFormats=14]="NumberFormats",Ee[Ee.CurrencyCode=15]="CurrencyCode",Ee[Ee.CurrencySymbol=16]="CurrencySymbol",Ee[Ee.CurrencyName=17]="CurrencyName",Ee[Ee.Currencies=18]="Currencies",Ee[Ee.Directionality=19]="Directionality",Ee[Ee.PluralCase=20]="PluralCase",Ee[Ee.ExtraData=21]="ExtraData",Ee))();const xc="en-US";let CM=xc;function Xx(n,t,e,s,r){if(n=Je(n),Array.isArray(n))for(let i=0;i<n.length;i++)Xx(n[i],t,e,s,r);else{const i=kt(),o=oe();let a=Ol(n)?n:Je(n.provide),l=yA(n);const u=Ps(),c=1048575&u.providerIndexes,d=u.directiveStart,h=u.providerIndexes>>20;if(Ol(n)||!n.multi){const f=new jd(l,r,ne),p=Zx(a,t,r?c:c+h,d);-1===p?(xw(Mm(u,o),i,a),Yx(i,n,t.length),t.push(a),u.directiveStart++,u.directiveEnd++,r&&(u.providerIndexes+=1048576),e.push(f),o.push(f)):(e[p]=f,o[p]=f)}else{const f=Zx(a,t,c+h,d),p=Zx(a,t,c,c+h),m=p>=0&&e[p];if(r&&!m||!r&&!(f>=0&&e[f])){xw(Mm(u,o),i,a);const y=function pX(n,t,e,s,r){const i=new jd(n,e,ne);return i.multi=[],i.index=t,i.componentProviders=0,KM(i,r,s&&!e),i}(r?fX:hX,e.length,r,s,l);!r&&m&&(e[p].providerFactory=y),Yx(i,n,t.length,0),t.push(a),u.directiveStart++,u.directiveEnd++,r&&(u.providerIndexes+=1048576),e.push(y),o.push(y)}else Yx(i,n,f>-1?f:p,KM(e[r?p:f],l,!r&&s));!r&&s&&m&&e[p].componentProviders++}}}function Yx(n,t,e,s){const r=Ol(t),i=function c6(n){return!!n.useClass}(t);if(r||i){const l=(i?Je(t.useClass):t).prototype.ngOnDestroy;if(l){const u=n.destroyHooks||(n.destroyHooks=[]);if(!r&&t.multi){const c=u.indexOf(e);-1===c?u.push(e,[s,l]):u[c+1].push(s,l)}else u.push(e,l)}}}function KM(n,t,e){return e&&n.componentProviders++,n.multi.push(t)-1}function Zx(n,t,e,s){for(let r=e;r<s;r++)if(t[r]===n)return r;return-1}function hX(n,t,e,s){return Qx(this.multi,[])}function fX(n,t,e,s){const r=this.multi;let i;if(this.providerFactory){const o=this.providerFactory.componentProviders,a=Ml(e,e[Ie],this.providerFactory.index,s);i=a.slice(0,o),Qx(r,i);for(let l=o;l<a.length;l++)i.push(a[l])}else i=[],Qx(r,i);return i}function Qx(n,t){for(let e=0;e<n.length;e++)t.push((0,n[e])());return t}function Jt(n,t=[]){return e=>{e.providersResolver=(s,r)=>function dX(n,t,e){const s=kt();if(s.firstCreatePass){const r=Ai(n);Xx(e,s.data,s.blueprint,r,!0),Xx(t,s.data,s.blueprint,r,!1)}}(s,r?r(n):n,t)}}class Cc{}class XM{}class Jx extends Cc{constructor(t,e,s){super(),this._parent=e,this._bootstrapComponents=[],this.destroyCbs=[],this.componentFactoryResolver=new rR(this);const r=$r(t);this._bootstrapComponents=jo(r.bootstrap),this._r3Injector=zA(t,e,[{provide:Cc,useValue:this},{provide:rg,useValue:this.componentFactoryResolver},...s],hs(t),new Set(["environment"])),this._r3Injector.resolveInjectorInitializers(),this.instance=this._r3Injector.get(t)}get injector(){return this._r3Injector}destroy(){const t=this._r3Injector;!t.destroyed&&t.destroy(),this.destroyCbs.forEach(e=>e()),this.destroyCbs=null}onDestroy(t){this.destroyCbs.push(t)}}class e0 extends XM{constructor(t){super(),this.moduleType=t}create(t){return new Jx(this.moduleType,t,[])}}class YM extends Cc{constructor(t){super(),this.componentFactoryResolver=new rR(this),this.instance=null;const e=new rx([...t.providers,{provide:Cc,useValue:this},{provide:rg,useValue:this.componentFactoryResolver}],t.parent||Zm(),t.debugName,new Set(["environment"]));this.injector=e,t.runEnvironmentInitializers&&e.resolveInjectorInitializers()}destroy(){this.injector.destroy()}onDestroy(t){this.injector.onDestroy(t)}}function t0(n,t,e=null){return new YM({providers:n,parent:t,debugName:e,runEnvironmentInitializers:!0}).injector}let yX=(()=>{class n{constructor(e){this._injector=e,this.cachedInjectors=new Map}getOrCreateStandaloneInjector(e){if(!e.standalone)return null;if(!this.cachedInjectors.has(e.id)){const s=fA(0,e.type),r=s.length>0?t0([s],this._injector,`Standalone[${e.type.name}]`):null;this.cachedInjectors.set(e.id,r)}return this.cachedInjectors.get(e.id)}ngOnDestroy(){try{for(const e of this.cachedInjectors.values())null!==e&&e.destroy()}finally{this.cachedInjectors.clear()}}}return n.\u0275prov=Ve({token:n,providedIn:"environment",factory:()=>new n(Se(Go))}),n})();function ZM(n){n.getStandaloneInjector=t=>t.get(yX).getOrCreateStandaloneInjector(n)}function iF(n,t,e,s,r,i,o){const a=t+e;return Ll(n,a,r,i)?function co(n,t,e){return n[t]=e}(n,a+2,o?s.call(o,r,i):s(r,i)):function Nh(n,t){const e=n[t];return e===it?void 0:e}(n,a+2)}function Eg(n,t){const e=kt();let s;const r=n+It;e.firstCreatePass?(s=function $X(n,t){if(t)for(let e=t.length-1;e>=0;e--){const s=t[e];if(n===s.name)return s}}(t,e.pipeRegistry),e.data[r]=s,s.onDestroy&&(e.destroyHooks??=[]).push(r,s.onDestroy)):s=e.data[r];const i=s.factory||(s.factory=Al(s.type)),o=pr(ne);try{const a=Rm(!1),l=i();return Rm(a),function y5(n,t,e,s){e>=n.data.length&&(n.data[e]=null,n.blueprint[e]=null),t[e]=s}(e,oe(),r,l),l}finally{pr(o)}}function Dg(n,t,e,s){const r=n+It,i=oe(),o=function Wu(n,t){return n[t]}(i,r);return function kh(n,t){return n[Ie].data[t].pure}(i,r)?iF(i,function er(){const n=Ze.lFrame;let t=n.bindingRootIndex;return-1===t&&(t=n.bindingRootIndex=n.tView.bindingStartIndex),t}(),t,o.transform,e,s,o):o.transform(e,s)}function s0(n){return t=>{setTimeout(n,void 0,t)}}const un=class zX extends Ti{constructor(t=!1){super(),this.__isAsync=t}emit(t){super.next(t)}subscribe(t,e,s){let r=t,i=e||(()=>null),o=s;if(t&&"object"==typeof t){const l=t;r=l.next?.bind(l),i=l.error?.bind(l),o=l.complete?.bind(l)}this.__isAsync&&(i=s0(i),r&&(r=s0(r)),o&&(o=s0(o)));const a=super.subscribe({next:r,error:i,complete:o});return t instanceof ut&&t.add(a),a}};function UX(){return this._results[Symbol.iterator]()}class r0{get changes(){return this._changes||(this._changes=new un)}constructor(t=!1){this._emitDistinctChangesOnly=t,this.dirty=!0,this._results=[],this._changesDetected=!1,this._changes=null,this.length=0,this.first=void 0,this.last=void 0;const e=r0.prototype;e[Symbol.iterator]||(e[Symbol.iterator]=UX)}get(t){return this._results[t]}map(t){return this._results.map(t)}filter(t){return this._results.filter(t)}find(t){return this._results.find(t)}reduce(t,e){return this._results.reduce(t,e)}forEach(t){this._results.forEach(t)}some(t){return this._results.some(t)}toArray(){return this._results.slice()}toString(){return this._results.toString()}reset(t,e){const s=this;s.dirty=!1;const r=function oi(n){return n.flat(Number.POSITIVE_INFINITY)}(t);(this._changesDetected=!function Pj(n,t,e){if(n.length!==t.length)return!1;for(let s=0;s<n.length;s++){let r=n[s],i=t[s];if(e&&(r=e(r),i=e(i)),i!==r)return!1}return!0}(s._results,r,e))&&(s._results=r,s.length=r.length,s.last=r[this.length-1],s.first=r[0])}notifyOnChanges(){this._changes&&(this._changesDetected||!this._emitDistinctChangesOnly)&&this._changes.emit(this)}setDirty(){this.dirty=!0}destroy(){this.changes.complete(),this.changes.unsubscribe()}}let Xo=(()=>{class n{}return n.__NG_ELEMENT_ID__=HX,n})();const WX=Xo,GX=class extends WX{constructor(t,e,s){super(),this._declarationLView=t,this._declarationTContainer=e,this.elementRef=s}get ssrId(){return this._declarationTContainer.tView?.ssrId||null}createEmbeddedView(t,e){return this.createEmbeddedViewImpl(t,e,null)}createEmbeddedViewImpl(t,e,s){const r=this._declarationTContainer.tView,i=lg(this._declarationLView,r,t,16,null,r.declTNode,null,null,null,e||null,s||null);i[zd]=this._declarationLView[this._declarationTContainer.index];const a=this._declarationLView[to];return null!==a&&(i[to]=a.createEmbeddedView(r)),kx(r,i,t),new ph(i)}};function HX(){return Tg(Ps(),oe())}function Tg(n,t){return 4&n.type?new GX(t,n,sc(n,t)):null}let Oi=(()=>{class n{}return n.__NG_ELEMENT_ID__=QX,n})();function QX(){return pF(Ps(),oe())}const JX=Oi,hF=class extends JX{constructor(t,e,s){super(),this._lContainer=t,this._hostTNode=e,this._hostLView=s}get element(){return sc(this._hostTNode,this._hostLView)}get injector(){return new ju(this._hostTNode,this._hostLView)}get parentInjector(){const t=ww(this._hostTNode,this._hostLView);if(sk(t)){const e=Am(t,this._hostLView),s=km(t);return new ju(e[Ie].data[s+8],e)}return new ju(null,this._hostLView)}clear(){for(;this.length>0;)this.remove(this.length-1)}get(t){const e=fF(this._lContainer);return null!==e&&e[t]||null}get length(){return this._lContainer.length-$s}createEmbeddedView(t,e,s){let r,i;"number"==typeof s?r=s:null!=s&&(r=s.index,i=s.injector);const a=t.createEmbeddedViewImpl(e||{},i,null);return this.insertImpl(a,r,!1),a}createComponent(t,e,s,r,i){const o=t&&!function Kd(n){return"function"==typeof n}(t);let a;if(o)a=e;else{const p=e||{};a=p.index,s=p.injector,r=p.projectableNodes,i=p.environmentInjector||p.ngModuleRef}const l=o?t:new mh(Lt(t)),u=s||this.parentInjector;if(!i&&null==l.ngModule){const g=(o?u:this.parentInjector).get(Go,null);g&&(i=g)}Lt(l.componentType??{});const f=l.create(u,r,null,i);return this.insertImpl(f.hostView,a,!1),f}insert(t,e){return this.insertImpl(t,e,!1)}insertImpl(t,e,s){const r=t._lView,i=r[Ie];if(function QH(n){return Lr(n[Sn])}(r)){const l=this.indexOf(t);if(-1!==l)this.detach(l);else{const u=r[Sn],c=new hF(u,u[Gs],u[Sn]);c.detach(c.indexOf(t))}}const o=this._adjustIndex(e),a=this._lContainer;if(function Eq(n,t,e,s){const r=$s+s,i=e.length;s>0&&(e[r-1][ki]=t),s<i-$s?(t[ki]=e[r],mk(e,$s+s,t)):(e.push(t),t[ki]=null),t[Sn]=e;const o=t[zd];null!==o&&e!==o&&function Dq(n,t){const e=n[Uu];t[Yn]!==t[Sn][Sn][Yn]&&(n[C1]=!0),null===e?n[Uu]=[t]:e.push(t)}(o,t);const a=t[to];null!==a&&a.insertView(n),t[at]|=128}(i,r,a,o),!s){const l=Gw(o,a),u=r[rt],c=Gm(u,a[no]);null!==c&&function Cq(n,t,e,s,r,i){s[Ss]=r,s[Gs]=t,th(n,s,e,1,r,i)}(i,a[Gs],u,r,c,l)}return t.attachToViewContainerRef(),mk(a0(a),o,t),t}move(t,e){return this.insert(t,e)}indexOf(t){const e=fF(this._lContainer);return null!==e?e.indexOf(t):-1}remove(t){const e=this._adjustIndex(t,-1),s=Bw(this._lContainer,e);s&&($m(a0(this._lContainer),e),Pk(s[Ie],s))}detach(t){const e=this._adjustIndex(t,-1),s=Bw(this._lContainer,e);return s&&null!=$m(a0(this._lContainer),e)?new ph(s):null}_adjustIndex(t,e=0){return t??this.length+e}};function fF(n){return n[vm]}function a0(n){return n[vm]||(n[vm]=[])}function pF(n,t){let e;const s=t[n.index];return Lr(s)?e=s:(e=ZA(s,t,null,n),t[n.index]=e,ug(t,e)),mF(e,t,n,s),new hF(e,n,t)}let mF=function gF(n,t,e,s){if(n[no])return;let r;r=8&e.type?fn(s):function e9(n,t){const e=n[rt],s=e.createComment(""),r=br(t,n);return Fl(e,Gm(e,r),s,function Aq(n,t){return n.nextSibling(t)}(e,r),!1),s}(t,e),n[no]=r};class l0{constructor(t){this.queryList=t,this.matches=null}clone(){return new l0(this.queryList)}setDirty(){this.queryList.setDirty()}}class u0{constructor(t=[]){this.queries=t}createEmbeddedView(t){const e=t.queries;if(null!==e){const s=null!==t.contentQueries?t.contentQueries[0]:e.length,r=[];for(let i=0;i<s;i++){const o=e.getByIndex(i);r.push(this.queries[o.indexInDeclarationView].clone())}return new u0(r)}return null}insertView(t){this.dirtyQueriesWithMatches(t)}detachView(t){this.dirtyQueriesWithMatches(t)}dirtyQueriesWithMatches(t){for(let e=0;e<this.queries.length;e++)null!==wF(t,e).matches&&this.queries[e].setDirty()}}class yF{constructor(t,e,s=null){this.predicate=t,this.flags=e,this.read=s}}class c0{constructor(t=[]){this.queries=t}elementStart(t,e){for(let s=0;s<this.queries.length;s++)this.queries[s].elementStart(t,e)}elementEnd(t){for(let e=0;e<this.queries.length;e++)this.queries[e].elementEnd(t)}embeddedTView(t){let e=null;for(let s=0;s<this.length;s++){const r=null!==e?e.length:0,i=this.getByIndex(s).embeddedTView(t,r);i&&(i.indexInDeclarationView=s,null!==e?e.push(i):e=[i])}return null!==e?new c0(e):null}template(t,e){for(let s=0;s<this.queries.length;s++)this.queries[s].template(t,e)}getByIndex(t){return this.queries[t]}get length(){return this.queries.length}track(t){this.queries.push(t)}}class d0{constructor(t,e=-1){this.metadata=t,this.matches=null,this.indexInDeclarationView=-1,this.crossesNgTemplate=!1,this._appliesToNextNode=!0,this._declarationNodeIndex=e}elementStart(t,e){this.isApplyingToNode(e)&&this.matchTNode(t,e)}elementEnd(t){this._declarationNodeIndex===t.index&&(this._appliesToNextNode=!1)}template(t,e){this.elementStart(t,e)}embeddedTView(t,e){return this.isApplyingToNode(t)?(this.crossesNgTemplate=!0,this.addMatch(-t.index,e),new d0(this.metadata)):null}isApplyingToNode(t){if(this._appliesToNextNode&&1!=(1&this.metadata.flags)){const e=this._declarationNodeIndex;let s=t.parent;for(;null!==s&&8&s.type&&s.index!==e;)s=s.parent;return e===(null!==s?s.index:-1)}return this._appliesToNextNode}matchTNode(t,e){const s=this.metadata.predicate;if(Array.isArray(s))for(let r=0;r<s.length;r++){const i=s[r];this.matchTNodeWithReadOption(t,e,s9(e,i)),this.matchTNodeWithReadOption(t,e,Fm(e,t,i,!1,!1))}else s===Xo?4&e.type&&this.matchTNodeWithReadOption(t,e,-1):this.matchTNodeWithReadOption(t,e,Fm(e,t,s,!1,!1))}matchTNodeWithReadOption(t,e,s){if(null!==s){const r=this.metadata.read;if(null!==r)if(r===ps||r===Oi||r===Xo&&4&e.type)this.addMatch(e.index,-2);else{const i=Fm(e,t,r,!1,!1);null!==i&&this.addMatch(e.index,i)}else this.addMatch(e.index,s)}}addMatch(t,e){null===this.matches?this.matches=[t,e]:this.matches.push(t,e)}}function s9(n,t){const e=n.localNames;if(null!==e)for(let s=0;s<e.length;s+=2)if(e[s]===t)return e[s+1];return null}function i9(n,t,e,s){return-1===e?function r9(n,t){return 11&n.type?sc(n,t):4&n.type?Tg(n,t):null}(t,n):-2===e?function o9(n,t,e){return e===ps?sc(t,n):e===Xo?Tg(t,n):e===Oi?pF(t,n):void 0}(n,t,s):Ml(n,n[Ie],e,t)}function bF(n,t,e,s){const r=t[to].queries[s];if(null===r.matches){const i=n.data,o=e.matches,a=[];for(let l=0;l<o.length;l+=2){const u=o[l];a.push(u<0?null:i9(t,i[u],o[l+1],e.metadata.read))}r.matches=a}return r.matches}function h0(n,t,e,s){const r=n.queries.getByIndex(e),i=r.matches;if(null!==i){const o=bF(n,t,r,e);for(let a=0;a<i.length;a+=2){const l=i[a];if(l>0)s.push(o[a/2]);else{const u=i[a+1],c=t[-l];for(let d=$s;d<c.length;d++){const h=c[d];h[zd]===h[Sn]&&h0(h[Ie],h,u,s)}if(null!==c[Uu]){const d=c[Uu];for(let h=0;h<d.length;h++){const f=d[h];h0(f[Ie],f,u,s)}}}}}return s}function Yo(n){const t=oe(),e=kt(),s=q1();pw(s+1);const r=wF(e,s);if(n.dirty&&function ZH(n){return 4==(4&n[at])}(t)===(2==(2&r.metadata.flags))){if(null===r.matches)n.reset([]);else{const i=r.crossesNgTemplate?h0(e,t,s,[]):bF(e,t,r,s);n.reset(i,A6),n.notifyOnChanges()}return!0}return!1}function Sc(n,t,e){const s=kt();s.firstCreatePass&&(_F(s,new yF(n,t,e),-1),2==(2&t)&&(s.staticViewQueries=!0)),vF(s,oe(),t)}function Ng(n,t,e,s){const r=kt();if(r.firstCreatePass){const i=Ps();_F(r,new yF(t,e,s),i.index),function l9(n,t){const e=n.contentQueries||(n.contentQueries=[]);t!==(e.length?e[e.length-1]:-1)&&e.push(n.queries.length-1,t)}(r,n),2==(2&e)&&(r.staticContentQueries=!0)}vF(r,oe(),e)}function Zo(){return function a9(n,t){return n[to].queries[t].queryList}(oe(),q1())}function vF(n,t,e){const s=new r0(4==(4&e));(function e8(n,t,e,s){const r=JA(t);r.push(e),n.firstCreatePass&&eR(n).push(s,r.length-1)})(n,t,s,s.destroy),null===t[to]&&(t[to]=new u0),t[to].queries.push(new l0(s))}function _F(n,t,e){null===n.queries&&(n.queries=new c0),n.queries.track(new d0(t,e))}function wF(n,t){return n.queries.getByIndex(t)}const b0=new we("Application Initializer");let v0=(()=>{class n{constructor(){this.initialized=!1,this.done=!1,this.donePromise=new Promise((e,s)=>{this.resolve=e,this.reject=s}),this.appInits=Fe(b0,{optional:!0})??[]}runInitializers(){if(this.initialized)return;const e=[];for(const r of this.appInits){const i=r();if(_h(i))e.push(i);else if(DR(i)){const o=new Promise((a,l)=>{i.subscribe({complete:a,error:l})});e.push(o)}}const s=()=>{this.done=!0,this.resolve()};Promise.all(e).then(()=>{s()}).catch(r=>{this.reject(r)}),0===e.length&&s(),this.initialized=!0}}return n.\u0275fac=function(e){return new(e||n)},n.\u0275prov=Ve({token:n,factory:n.\u0275fac,providedIn:"root"}),n})(),LF=(()=>{class n{log(e){console.log(e)}warn(e){console.warn(e)}}return n.\u0275fac=function(e){return new(e||n)},n.\u0275prov=Ve({token:n,factory:n.\u0275fac,providedIn:"platform"}),n})();const po=new we("LocaleId",{providedIn:"root",factory:()=>Fe(po,je.Optional|je.SkipSelf)||function k9(){return typeof $localize<"u"&&$localize.locale||xc}()});class R9{constructor(t,e){this.ngModuleFactory=t,this.componentFactories=e}}let VF=(()=>{class n{compileModuleSync(e){return new e0(e)}compileModuleAsync(e){return Promise.resolve(this.compileModuleSync(e))}compileModuleAndAllComponentsSync(e){const s=this.compileModuleSync(e),i=jo($r(e).declarations).reduce((o,a)=>{const l=Lt(a);return l&&o.push(new mh(l)),o},[]);return new R9(s,i)}compileModuleAndAllComponentsAsync(e){return Promise.resolve(this.compileModuleAndAllComponentsSync(e))}clearCache(){}clearCacheFor(e){}getModuleId(e){}}return n.\u0275fac=function(e){return new(e||n)},n.\u0275prov=Ve({token:n,factory:n.\u0275fac,providedIn:"root"}),n})();const O9=(()=>Promise.resolve(0))();function _0(n){typeof Zone>"u"?O9.then(()=>{n&&n.apply(null,null)}):Zone.current.scheduleMicroTask("scheduleMicrotask",n)}function UF(...n){}class Pt{constructor({enableLongStackTrace:t=!1,shouldCoalesceEventChangeDetection:e=!1,shouldCoalesceRunChangeDetection:s=!1}){if(this.hasPendingMacrotasks=!1,this.hasPendingMicrotasks=!1,this.isStable=!0,this.onUnstable=new un(!1),this.onMicrotaskEmpty=new un(!1),this.onStable=new un(!1),this.onError=new un(!1),typeof Zone>"u")throw new ee(908,!1);Zone.assertZonePatched();const r=this;r._nesting=0,r._outer=r._inner=Zone.current,Zone.TaskTrackingZoneSpec&&(r._inner=r._inner.fork(new Zone.TaskTrackingZoneSpec)),t&&Zone.longStackTraceZoneSpec&&(r._inner=r._inner.fork(Zone.longStackTraceZoneSpec)),r.shouldCoalesceEventChangeDetection=!s&&e,r.shouldCoalesceRunChangeDetection=s,r.lastRequestAnimationFrameId=-1,r.nativeRequestAnimationFrame=function $9(){let n=ln.requestAnimationFrame,t=ln.cancelAnimationFrame;if(typeof Zone<"u"&&n&&t){const e=n[Zone.__symbol__("OriginalDelegate")];e&&(n=e);const s=t[Zone.__symbol__("OriginalDelegate")];s&&(t=s)}return{nativeRequestAnimationFrame:n,nativeCancelAnimationFrame:t}}().nativeRequestAnimationFrame,function V9(n){const t=()=>{!function L9(n){n.isCheckStableRunning||-1!==n.lastRequestAnimationFrameId||(n.lastRequestAnimationFrameId=n.nativeRequestAnimationFrame.call(ln,()=>{n.fakeTopEventTask||(n.fakeTopEventTask=Zone.root.scheduleEventTask("fakeTopEventTask",()=>{n.lastRequestAnimationFrameId=-1,x0(n),n.isCheckStableRunning=!0,w0(n),n.isCheckStableRunning=!1},void 0,()=>{},()=>{})),n.fakeTopEventTask.invoke()}),x0(n))}(n)};n._inner=n._inner.fork({name:"angular",properties:{isAngularZone:!0},onInvokeTask:(e,s,r,i,o,a)=>{try{return WF(n),e.invokeTask(r,i,o,a)}finally{(n.shouldCoalesceEventChangeDetection&&"eventTask"===i.type||n.shouldCoalesceRunChangeDetection)&&t(),GF(n)}},onInvoke:(e,s,r,i,o,a,l)=>{try{return WF(n),e.invoke(r,i,o,a,l)}finally{n.shouldCoalesceRunChangeDetection&&t(),GF(n)}},onHasTask:(e,s,r,i)=>{e.hasTask(r,i),s===r&&("microTask"==i.change?(n._hasPendingMicrotasks=i.microTask,x0(n),w0(n)):"macroTask"==i.change&&(n.hasPendingMacrotasks=i.macroTask))},onHandleError:(e,s,r,i)=>(e.handleError(r,i),n.runOutsideAngular(()=>n.onError.emit(i)),!1)})}(r)}static isInAngularZone(){return typeof Zone<"u"&&!0===Zone.current.get("isAngularZone")}static assertInAngularZone(){if(!Pt.isInAngularZone())throw new ee(909,!1)}static assertNotInAngularZone(){if(Pt.isInAngularZone())throw new ee(909,!1)}run(t,e,s){return this._inner.run(t,e,s)}runTask(t,e,s,r){const i=this._inner,o=i.scheduleEventTask("NgZoneEvent: "+r,t,P9,UF,UF);try{return i.runTask(o,e,s)}finally{i.cancelTask(o)}}runGuarded(t,e,s){return this._inner.runGuarded(t,e,s)}runOutsideAngular(t){return this._outer.run(t)}}const P9={};function w0(n){if(0==n._nesting&&!n.hasPendingMicrotasks&&!n.isStable)try{n._nesting++,n.onMicrotaskEmpty.emit(null)}finally{if(n._nesting--,!n.hasPendingMicrotasks)try{n.runOutsideAngular(()=>n.onStable.emit(null))}finally{n.isStable=!0}}}function x0(n){n.hasPendingMicrotasks=!!(n._hasPendingMicrotasks||(n.shouldCoalesceEventChangeDetection||n.shouldCoalesceRunChangeDetection)&&-1!==n.lastRequestAnimationFrameId)}function WF(n){n._nesting++,n.isStable&&(n.isStable=!1,n.onUnstable.emit(null))}function GF(n){n._nesting--,w0(n)}class B9{constructor(){this.hasPendingMicrotasks=!1,this.hasPendingMacrotasks=!1,this.isStable=!0,this.onUnstable=new un,this.onMicrotaskEmpty=new un,this.onStable=new un,this.onError=new un}run(t,e,s){return t.apply(e,s)}runGuarded(t,e,s){return t.apply(e,s)}runOutsideAngular(t){return t()}runTask(t,e,s,r){return t.apply(e,s)}}const HF=new we("",{providedIn:"root",factory:jF});function jF(){const n=Fe(Pt);let t=!0;return function ZG(...n){const t=Fd(n),e=function GG(n,t){return"number"==typeof U_(n)?n.pop():t}(n,1/0),s=n;return s.length?1===s.length?Mr(s[0]):Ou(e)(Cs(s,t)):Ji}(new Wn(r=>{t=n.isStable&&!n.hasPendingMacrotasks&&!n.hasPendingMicrotasks,n.runOutsideAngular(()=>{r.next(t),r.complete()})}),new Wn(r=>{let i;n.runOutsideAngular(()=>{i=n.onStable.subscribe(()=>{Pt.assertNotInAngularZone(),_0(()=>{!t&&!n.hasPendingMacrotasks&&!n.hasPendingMicrotasks&&(t=!0,r.next(!0))})})});const o=n.onUnstable.subscribe(()=>{Pt.assertInAngularZone(),t&&(t=!1,n.runOutsideAngular(()=>{r.next(!1)}))});return()=>{i.unsubscribe(),o.unsubscribe()}}).pipe(function QG(n={}){const{connector:t=(()=>new Ti),resetOnError:e=!0,resetOnComplete:s=!0,resetOnRefCountZero:r=!0}=n;return i=>{let o,a,l,u=0,c=!1,d=!1;const h=()=>{a?.unsubscribe(),a=void 0},f=()=>{h(),o=l=void 0,c=d=!1},p=()=>{const g=o;f(),g?.unsubscribe()};return ds((g,m)=>{u++,!d&&!c&&h();const y=l=l??t();m.add(()=>{u--,0===u&&!d&&!c&&(a=W_(p,r))}),y.subscribe(m),!o&&u>0&&(o=new Md({next:b=>y.next(b),error:b=>{d=!0,h(),a=W_(f,e,b),y.error(b)},complete:()=>{c=!0,h(),a=W_(f,s),y.complete()}}),Mr(g).subscribe(o))})(i)}}()))}const qF=new we(""),Ag=new we("");let I0,C0=(()=>{class n{constructor(e,s,r){this._ngZone=e,this.registry=s,this._pendingCount=0,this._isZoneStable=!0,this._didWork=!1,this._callbacks=[],this.taskTrackingZone=null,I0||(function z9(n){I0=n}(r),r.addToWindow(s)),this._watchAngularEvents(),e.run(()=>{this.taskTrackingZone=typeof Zone>"u"?null:Zone.current.get("TaskTrackingZone")})}_watchAngularEvents(){this._ngZone.onUnstable.subscribe({next:()=>{this._didWork=!0,this._isZoneStable=!1}}),this._ngZone.runOutsideAngular(()=>{this._ngZone.onStable.subscribe({next:()=>{Pt.assertNotInAngularZone(),_0(()=>{this._isZoneStable=!0,this._runCallbacksIfReady()})}})})}increasePendingRequestCount(){return this._pendingCount+=1,this._didWork=!0,this._pendingCount}decreasePendingRequestCount(){if(this._pendingCount-=1,this._pendingCount<0)throw new Error("pending async requests below zero");return this._runCallbacksIfReady(),this._pendingCount}isStable(){return this._isZoneStable&&0===this._pendingCount&&!this._ngZone.hasPendingMacrotasks}_runCallbacksIfReady(){if(this.isStable())_0(()=>{for(;0!==this._callbacks.length;){let e=this._callbacks.pop();clearTimeout(e.timeoutId),e.doneCb(this._didWork)}this._didWork=!1});else{let e=this.getPendingTasks();this._callbacks=this._callbacks.filter(s=>!s.updateCb||!s.updateCb(e)||(clearTimeout(s.timeoutId),!1)),this._didWork=!0}}getPendingTasks(){return this.taskTrackingZone?this.taskTrackingZone.macroTasks.map(e=>({source:e.source,creationLocation:e.creationLocation,data:e.data})):[]}addCallback(e,s,r){let i=-1;s&&s>0&&(i=setTimeout(()=>{this._callbacks=this._callbacks.filter(o=>o.timeoutId!==i),e(this._didWork,this.getPendingTasks())},s)),this._callbacks.push({doneCb:e,timeoutId:i,updateCb:r})}whenStable(e,s,r){if(r&&!this.taskTrackingZone)throw new Error('Task tracking zone is required when passing an update callback to whenStable(). Is "zone.js/plugins/task-tracking" loaded?');this.addCallback(e,s,r),this._runCallbacksIfReady()}getPendingRequestCount(){return this._pendingCount}registerApplication(e){this.registry.registerApplication(e,this)}unregisterApplication(e){this.registry.unregisterApplication(e)}findProviders(e,s,r){return[]}}return n.\u0275fac=function(e){return new(e||n)(Se(Pt),Se(S0),Se(Ag))},n.\u0275prov=Ve({token:n,factory:n.\u0275fac}),n})(),S0=(()=>{class n{constructor(){this._applications=new Map}registerApplication(e,s){this._applications.set(e,s)}unregisterApplication(e){this._applications.delete(e)}unregisterAllApplications(){this._applications.clear()}getTestability(e){return this._applications.get(e)||null}getAllTestabilities(){return Array.from(this._applications.values())}getAllRootElements(){return Array.from(this._applications.keys())}findTestabilityInTree(e,s=!0){return I0?.findTestabilityInTree(this,e,s)??null}}return n.\u0275fac=function(e){return new(e||n)},n.\u0275prov=Ve({token:n,factory:n.\u0275fac,providedIn:"platform"}),n})(),Ta=null;const KF=new we("AllowMultipleToken"),E0=new we("PlatformDestroyListeners"),D0=new we("appBootstrapListener");class YF{constructor(t,e){this.name=t,this.token=e}}function QF(n,t,e=[]){const s=`Platform: ${t}`,r=new we(s);return(i=[])=>{let o=T0();if(!o||o.injector.get(KF,!1)){const a=[...e,...i,{provide:r,useValue:!0}];n?n(a):function G9(n){if(Ta&&!Ta.get(KF,!1))throw new ee(400,!1);(function XF(){!function zH(n){N1=n}(()=>{throw new ee(600,!1)})})(),Ta=n;const t=n.get(eO);(function ZF(n){n.get(bA,null)?.forEach(e=>e())})(n)}(function JF(n=[],t){return lo.create({name:t,providers:[{provide:nx,useValue:"platform"},{provide:E0,useValue:new Set([()=>Ta=null])},...n]})}(a,s))}return function j9(n){const t=T0();if(!t)throw new ee(401,!1);return t}()}}function T0(){return Ta?.get(eO)??null}let eO=(()=>{class n{constructor(e){this._injector=e,this._modules=[],this._destroyListeners=[],this._destroyed=!1}bootstrapModuleFactory(e,s){const r=function q9(n="zone.js",t){return"noop"===n?new B9:"zone.js"===n?new Pt(t):n}(s?.ngZone,function tO(n){return{enableLongStackTrace:!1,shouldCoalesceEventChangeDetection:n?.eventCoalescing??!1,shouldCoalesceRunChangeDetection:n?.runCoalescing??!1}}({eventCoalescing:s?.ngZoneEventCoalescing,runCoalescing:s?.ngZoneRunCoalescing}));return r.run(()=>{const i=function gX(n,t,e){return new Jx(n,t,e)}(e.moduleType,this.injector,function oO(n){return[{provide:Pt,useFactory:n},{provide:oh,multi:!0,useFactory:()=>{const t=Fe(X9,{optional:!0});return()=>t.initialize()}},{provide:iO,useFactory:K9},{provide:HF,useFactory:jF}]}(()=>r)),o=i.injector.get(Pl,null);return r.runOutsideAngular(()=>{const a=r.onError.subscribe({next:l=>{o.handleError(l)}});i.onDestroy(()=>{Rg(this._modules,i),a.unsubscribe()})}),function nO(n,t,e){try{const s=e();return _h(s)?s.catch(r=>{throw t.runOutsideAngular(()=>n.handleError(r)),r}):s}catch(s){throw t.runOutsideAngular(()=>n.handleError(s)),s}}(o,r,()=>{const a=i.injector.get(v0);return a.runInitializers(),a.donePromise.then(()=>(function SM(n){ri(n,"Expected localeId to be defined"),"string"==typeof n&&(CM=n.toLowerCase().replace(/_/g,"-"))}(i.injector.get(po,xc)||xc),this._moduleDoBootstrap(i),i))})})}bootstrapModule(e,s=[]){const r=sO({},s);return function U9(n,t,e){const s=new e0(e);return Promise.resolve(s)}(0,0,e).then(i=>this.bootstrapModuleFactory(i,r))}_moduleDoBootstrap(e){const s=e.injector.get(zl);if(e._bootstrapComponents.length>0)e._bootstrapComponents.forEach(r=>s.bootstrap(r));else{if(!e.instance.ngDoBootstrap)throw new ee(-403,!1);e.instance.ngDoBootstrap(s)}this._modules.push(e)}onDestroy(e){this._destroyListeners.push(e)}get injector(){return this._injector}destroy(){if(this._destroyed)throw new ee(404,!1);this._modules.slice().forEach(s=>s.destroy()),this._destroyListeners.forEach(s=>s());const e=this._injector.get(E0,null);e&&(e.forEach(s=>s()),e.clear()),this._destroyed=!0}get destroyed(){return this._destroyed}}return n.\u0275fac=function(e){return new(e||n)(Se(lo))},n.\u0275prov=Ve({token:n,factory:n.\u0275fac,providedIn:"platform"}),n})();function sO(n,t){return Array.isArray(t)?t.reduce(sO,n):{...n,...t}}let zl=(()=>{class n{constructor(){this._bootstrapListeners=[],this._runningTick=!1,this._destroyed=!1,this._destroyListeners=[],this._views=[],this.internalErrorHandler=Fe(iO),this.componentTypes=[],this.components=[],this.isStable=Fe(HF),this._injector=Fe(Go)}get destroyed(){return this._destroyed}get injector(){return this._injector}bootstrap(e,s){const r=e instanceof SA;if(!this._injector.get(v0).done)throw!r&&function Pu(n){const t=Lt(n)||Ws(n)||yr(n);return null!==t&&t.standalone}(e),new ee(405,!1);let o;o=r?e:this._injector.get(rg).resolveComponentFactory(e),this.componentTypes.push(o.componentType);const a=function W9(n){return n.isBoundToModule}(o)?void 0:this._injector.get(Cc),u=o.create(lo.NULL,[],s||o.selector,a),c=u.location.nativeElement,d=u.injector.get(qF,null);return d?.registerApplication(c),u.onDestroy(()=>{this.detachView(u.hostView),Rg(this.components,u),d?.unregisterApplication(c)}),this._loadComponent(u),u}tick(){if(this._runningTick)throw new ee(101,!1);try{this._runningTick=!0;for(let e of this._views)e.detectChanges()}catch(e){this.internalErrorHandler(e)}finally{this._runningTick=!1}}attachView(e){const s=e;this._views.push(s),s.attachToAppRef(this)}detachView(e){const s=e;Rg(this._views,s),s.detachFromAppRef()}_loadComponent(e){this.attachView(e.hostView),this.tick(),this.components.push(e);const s=this._injector.get(D0,[]);s.push(...this._bootstrapListeners),s.forEach(r=>r(e))}ngOnDestroy(){if(!this._destroyed)try{this._destroyListeners.forEach(e=>e()),this._views.slice().forEach(e=>e.destroy())}finally{this._destroyed=!0,this._views=[],this._bootstrapListeners=[],this._destroyListeners=[]}}onDestroy(e){return this._destroyListeners.push(e),()=>Rg(this._destroyListeners,e)}destroy(){if(this._destroyed)throw new ee(406,!1);const e=this._injector;e.destroy&&!e.destroyed&&e.destroy()}get viewCount(){return this._views.length}warnIfDestroyed(){}}return n.\u0275fac=function(e){return new(e||n)},n.\u0275prov=Ve({token:n,factory:n.\u0275fac,providedIn:"root"}),n})();function Rg(n,t){const e=n.indexOf(t);e>-1&&n.splice(e,1)}const iO=new we("",{providedIn:"root",factory:()=>Fe(Pl).handleError.bind(void 0)});function K9(){const n=Fe(Pt),t=Fe(Pl);return e=>n.runOutsideAngular(()=>t.handleError(e))}let X9=(()=>{class n{constructor(){this.zone=Fe(Pt),this.applicationRef=Fe(zl)}initialize(){this._onMicrotaskEmptySubscription||(this._onMicrotaskEmptySubscription=this.zone.onMicrotaskEmpty.subscribe({next:()=>{this.zone.run(()=>{this.applicationRef.tick()})}}))}ngOnDestroy(){this._onMicrotaskEmptySubscription?.unsubscribe()}}return n.\u0275fac=function(e){return new(e||n)},n.\u0275prov=Ve({token:n,factory:n.\u0275fac,providedIn:"root"}),n})();let Na=(()=>{class n{}return n.__NG_ELEMENT_ID__=Z9,n})();function Z9(n){return function Q9(n,t,e){if(kl(n)&&!e){const s=vr(n.index,t);return new ph(s,s)}return 47&n.type?new ph(t[Yn],t):null}(Ps(),oe(),16==(16&n))}class cO{constructor(){}supports(t){return fg(t)}create(t){return new r7(t)}}const s7=(n,t)=>t;class r7{constructor(t){this.length=0,this._linkedRecords=null,this._unlinkedRecords=null,this._previousItHead=null,this._itHead=null,this._itTail=null,this._additionsHead=null,this._additionsTail=null,this._movesHead=null,this._movesTail=null,this._removalsHead=null,this._removalsTail=null,this._identityChangesHead=null,this._identityChangesTail=null,this._trackByFn=t||s7}forEachItem(t){let e;for(e=this._itHead;null!==e;e=e._next)t(e)}forEachOperation(t){let e=this._itHead,s=this._removalsHead,r=0,i=null;for(;e||s;){const o=!s||e&&e.currentIndex<hO(s,r,i)?e:s,a=hO(o,r,i),l=o.currentIndex;if(o===s)r--,s=s._nextRemoved;else if(e=e._next,null==o.previousIndex)r++;else{i||(i=[]);const u=a-r,c=l-r;if(u!=c){for(let h=0;h<u;h++){const f=h<i.length?i[h]:i[h]=0,p=f+h;c<=p&&p<u&&(i[h]=f+1)}i[o.previousIndex]=c-u}}a!==l&&t(o,a,l)}}forEachPreviousItem(t){let e;for(e=this._previousItHead;null!==e;e=e._nextPrevious)t(e)}forEachAddedItem(t){let e;for(e=this._additionsHead;null!==e;e=e._nextAdded)t(e)}forEachMovedItem(t){let e;for(e=this._movesHead;null!==e;e=e._nextMoved)t(e)}forEachRemovedItem(t){let e;for(e=this._removalsHead;null!==e;e=e._nextRemoved)t(e)}forEachIdentityChange(t){let e;for(e=this._identityChangesHead;null!==e;e=e._nextIdentityChange)t(e)}diff(t){if(null==t&&(t=[]),!fg(t))throw new ee(900,!1);return this.check(t)?this:null}onDestroy(){}check(t){this._reset();let r,i,o,e=this._itHead,s=!1;if(Array.isArray(t)){this.length=t.length;for(let a=0;a<this.length;a++)i=t[a],o=this._trackByFn(a,i),null!==e&&Object.is(e.trackById,o)?(s&&(e=this._verifyReinsertion(e,i,o,a)),Object.is(e.item,i)||this._addIdentityChange(e,i)):(e=this._mismatch(e,i,o,a),s=!0),e=e._next}else r=0,function Y8(n,t){if(Array.isArray(n))for(let e=0;e<n.length;e++)t(n[e]);else{const e=n[Symbol.iterator]();let s;for(;!(s=e.next()).done;)t(s.value)}}(t,a=>{o=this._trackByFn(r,a),null!==e&&Object.is(e.trackById,o)?(s&&(e=this._verifyReinsertion(e,a,o,r)),Object.is(e.item,a)||this._addIdentityChange(e,a)):(e=this._mismatch(e,a,o,r),s=!0),e=e._next,r++}),this.length=r;return this._truncate(e),this.collection=t,this.isDirty}get isDirty(){return null!==this._additionsHead||null!==this._movesHead||null!==this._removalsHead||null!==this._identityChangesHead}_reset(){if(this.isDirty){let t;for(t=this._previousItHead=this._itHead;null!==t;t=t._next)t._nextPrevious=t._next;for(t=this._additionsHead;null!==t;t=t._nextAdded)t.previousIndex=t.currentIndex;for(this._additionsHead=this._additionsTail=null,t=this._movesHead;null!==t;t=t._nextMoved)t.previousIndex=t.currentIndex;this._movesHead=this._movesTail=null,this._removalsHead=this._removalsTail=null,this._identityChangesHead=this._identityChangesTail=null}}_mismatch(t,e,s,r){let i;return null===t?i=this._itTail:(i=t._prev,this._remove(t)),null!==(t=null===this._unlinkedRecords?null:this._unlinkedRecords.get(s,null))?(Object.is(t.item,e)||this._addIdentityChange(t,e),this._reinsertAfter(t,i,r)):null!==(t=null===this._linkedRecords?null:this._linkedRecords.get(s,r))?(Object.is(t.item,e)||this._addIdentityChange(t,e),this._moveAfter(t,i,r)):t=this._addAfter(new i7(e,s),i,r),t}_verifyReinsertion(t,e,s,r){let i=null===this._unlinkedRecords?null:this._unlinkedRecords.get(s,null);return null!==i?t=this._reinsertAfter(i,t._prev,r):t.currentIndex!=r&&(t.currentIndex=r,this._addToMoves(t,r)),t}_truncate(t){for(;null!==t;){const e=t._next;this._addToRemovals(this._unlink(t)),t=e}null!==this._unlinkedRecords&&this._unlinkedRecords.clear(),null!==this._additionsTail&&(this._additionsTail._nextAdded=null),null!==this._movesTail&&(this._movesTail._nextMoved=null),null!==this._itTail&&(this._itTail._next=null),null!==this._removalsTail&&(this._removalsTail._nextRemoved=null),null!==this._identityChangesTail&&(this._identityChangesTail._nextIdentityChange=null)}_reinsertAfter(t,e,s){null!==this._unlinkedRecords&&this._unlinkedRecords.remove(t);const r=t._prevRemoved,i=t._nextRemoved;return null===r?this._removalsHead=i:r._nextRemoved=i,null===i?this._removalsTail=r:i._prevRemoved=r,this._insertAfter(t,e,s),this._addToMoves(t,s),t}_moveAfter(t,e,s){return this._unlink(t),this._insertAfter(t,e,s),this._addToMoves(t,s),t}_addAfter(t,e,s){return this._insertAfter(t,e,s),this._additionsTail=null===this._additionsTail?this._additionsHead=t:this._additionsTail._nextAdded=t,t}_insertAfter(t,e,s){const r=null===e?this._itHead:e._next;return t._next=r,t._prev=e,null===r?this._itTail=t:r._prev=t,null===e?this._itHead=t:e._next=t,null===this._linkedRecords&&(this._linkedRecords=new dO),this._linkedRecords.put(t),t.currentIndex=s,t}_remove(t){return this._addToRemovals(this._unlink(t))}_unlink(t){null!==this._linkedRecords&&this._linkedRecords.remove(t);const e=t._prev,s=t._next;return null===e?this._itHead=s:e._next=s,null===s?this._itTail=e:s._prev=e,t}_addToMoves(t,e){return t.previousIndex===e||(this._movesTail=null===this._movesTail?this._movesHead=t:this._movesTail._nextMoved=t),t}_addToRemovals(t){return null===this._unlinkedRecords&&(this._unlinkedRecords=new dO),this._unlinkedRecords.put(t),t.currentIndex=null,t._nextRemoved=null,null===this._removalsTail?(this._removalsTail=this._removalsHead=t,t._prevRemoved=null):(t._prevRemoved=this._removalsTail,this._removalsTail=this._removalsTail._nextRemoved=t),t}_addIdentityChange(t,e){return t.item=e,this._identityChangesTail=null===this._identityChangesTail?this._identityChangesHead=t:this._identityChangesTail._nextIdentityChange=t,t}}class i7{constructor(t,e){this.item=t,this.trackById=e,this.currentIndex=null,this.previousIndex=null,this._nextPrevious=null,this._prev=null,this._next=null,this._prevDup=null,this._nextDup=null,this._prevRemoved=null,this._nextRemoved=null,this._nextAdded=null,this._nextMoved=null,this._nextIdentityChange=null}}class o7{constructor(){this._head=null,this._tail=null}add(t){null===this._head?(this._head=this._tail=t,t._nextDup=null,t._prevDup=null):(this._tail._nextDup=t,t._prevDup=this._tail,t._nextDup=null,this._tail=t)}get(t,e){let s;for(s=this._head;null!==s;s=s._nextDup)if((null===e||e<=s.currentIndex)&&Object.is(s.trackById,t))return s;return null}remove(t){const e=t._prevDup,s=t._nextDup;return null===e?this._head=s:e._nextDup=s,null===s?this._tail=e:s._prevDup=e,null===this._head}}class dO{constructor(){this.map=new Map}put(t){const e=t.trackById;let s=this.map.get(e);s||(s=new o7,this.map.set(e,s)),s.add(t)}get(t,e){const r=this.map.get(t);return r?r.get(t,e):null}remove(t){const e=t.trackById;return this.map.get(e).remove(t)&&this.map.delete(e),t}get isEmpty(){return 0===this.map.size}clear(){this.map.clear()}}function hO(n,t,e){const s=n.previousIndex;if(null===s)return s;let r=0;return e&&s<e.length&&(r=e[s]),s+t+r}function pO(){return new Og([new cO])}let Og=(()=>{class n{constructor(e){this.factories=e}static create(e,s){if(null!=s){const r=s.factories.slice();e=e.concat(r)}return new n(e)}static extend(e){return{provide:n,useFactory:s=>n.create(e,s||pO()),deps:[[n,new Vm,new Lm]]}}find(e){const s=this.factories.find(r=>r.supports(e));if(null!=s)return s;throw new ee(901,!1)}}return n.\u0275prov=Ve({token:n,providedIn:"root",factory:pO}),n})();const d7=QF(null,"core",[]);let h7=(()=>{class n{constructor(e){}}return n.\u0275fac=function(e){return new(e||n)(Se(zl))},n.\u0275mod=Or({type:n}),n.\u0275inj=fr({}),n})(),wO=(()=>{class n{get whenAllTasksComplete(){return 0===this.collection.size&&this.complete(),this.promise}constructor(){this.taskId=0,this.collection=new Set,this.ngZone=Fe(Pt),this.completed=!1,this.ngZone.runOutsideAngular(()=>{this.promise=new Promise(e=>{this.resolve=e})})}add(){if(this.completed)return-1;const e=this.taskId++;return this.collection.add(e),e}remove(e){this.completed||(this.collection.delete(e),0===this.collection.size&&this.complete())}ngOnDestroy(){this.complete(),this.collection.clear()}complete(){this.completed=!0,this.resolve()}}return n.\u0275fac=function(e){return new(e||n)},n.\u0275prov=Ve({token:n,factory:n.\u0275fac,providedIn:"root"}),n})(),O0=null;function ka(){return O0}class S7{}const Es=new we("DocumentToken");let $0=(()=>{class n{historyGo(e){throw new Error("Not implemented")}}return n.\u0275fac=function(e){return new(e||n)},n.\u0275prov=Ve({token:n,factory:function(){return function I7(){return Se(CO)}()},providedIn:"platform"}),n})();const E7=new we("Location Initialized");let CO=(()=>{class n extends $0{constructor(e){super(),this._doc=e,this._location=window.location,this._history=window.history}getBaseHrefFromDOM(){return ka().getBaseHref(this._doc)}onPopState(e){const s=ka().getGlobalEventTarget(this._doc,"window");return s.addEventListener("popstate",e,!1),()=>s.removeEventListener("popstate",e)}onHashChange(e){const s=ka().getGlobalEventTarget(this._doc,"window");return s.addEventListener("hashchange",e,!1),()=>s.removeEventListener("hashchange",e)}get href(){return this._location.href}get protocol(){return this._location.protocol}get hostname(){return this._location.hostname}get port(){return this._location.port}get pathname(){return this._location.pathname}get search(){return this._location.search}get hash(){return this._location.hash}set pathname(e){this._location.pathname=e}pushState(e,s,r){SO()?this._history.pushState(e,s,r):this._location.hash=r}replaceState(e,s,r){SO()?this._history.replaceState(e,s,r):this._location.hash=r}forward(){this._history.forward()}back(){this._history.back()}historyGo(e=0){this._history.go(e)}getState(){return this._history.state}}return n.\u0275fac=function(e){return new(e||n)(Se(Es))},n.\u0275prov=Ve({token:n,factory:function(){return function D7(){return new CO(Se(Es))}()},providedIn:"platform"}),n})();function SO(){return!!window.history.pushState}function P0(n,t){if(0==n.length)return t;if(0==t.length)return n;let e=0;return n.endsWith("/")&&e++,t.startsWith("/")&&e++,2==e?n+t.substring(1):1==e?n+t:n+"/"+t}function IO(n){const t=n.match(/#|\?|$/),e=t&&t.index||n.length;return n.slice(0,e-("/"===n[e-1]?1:0))+n.slice(e)}function Qo(n){return n&&"?"!==n[0]?"?"+n:n}let Wl=(()=>{class n{historyGo(e){throw new Error("Not implemented")}}return n.\u0275fac=function(e){return new(e||n)},n.\u0275prov=Ve({token:n,factory:function(){return Fe(DO)},providedIn:"root"}),n})();const EO=new we("appBaseHref");let DO=(()=>{class n extends Wl{constructor(e,s){super(),this._platformLocation=e,this._removeListenerFns=[],this._baseHref=s??this._platformLocation.getBaseHrefFromDOM()??Fe(Es).location?.origin??""}ngOnDestroy(){for(;this._removeListenerFns.length;)this._removeListenerFns.pop()()}onPopState(e){this._removeListenerFns.push(this._platformLocation.onPopState(e),this._platformLocation.onHashChange(e))}getBaseHref(){return this._baseHref}prepareExternalUrl(e){return P0(this._baseHref,e)}path(e=!1){const s=this._platformLocation.pathname+Qo(this._platformLocation.search),r=this._platformLocation.hash;return r&&e?`${s}${r}`:s}pushState(e,s,r,i){const o=this.prepareExternalUrl(r+Qo(i));this._platformLocation.pushState(e,s,o)}replaceState(e,s,r,i){const o=this.prepareExternalUrl(r+Qo(i));this._platformLocation.replaceState(e,s,o)}forward(){this._platformLocation.forward()}back(){this._platformLocation.back()}getState(){return this._platformLocation.getState()}historyGo(e=0){this._platformLocation.historyGo?.(e)}}return n.\u0275fac=function(e){return new(e||n)(Se($0),Se(EO,8))},n.\u0275prov=Ve({token:n,factory:n.\u0275fac,providedIn:"root"}),n})(),T7=(()=>{class n extends Wl{constructor(e,s){super(),this._platformLocation=e,this._baseHref="",this._removeListenerFns=[],null!=s&&(this._baseHref=s)}ngOnDestroy(){for(;this._removeListenerFns.length;)this._removeListenerFns.pop()()}onPopState(e){this._removeListenerFns.push(this._platformLocation.onPopState(e),this._platformLocation.onHashChange(e))}getBaseHref(){return this._baseHref}path(e=!1){let s=this._platformLocation.hash;return null==s&&(s="#"),s.length>0?s.substring(1):s}prepareExternalUrl(e){const s=P0(this._baseHref,e);return s.length>0?"#"+s:s}pushState(e,s,r,i){let o=this.prepareExternalUrl(r+Qo(i));0==o.length&&(o=this._platformLocation.pathname),this._platformLocation.pushState(e,s,o)}replaceState(e,s,r,i){let o=this.prepareExternalUrl(r+Qo(i));0==o.length&&(o=this._platformLocation.pathname),this._platformLocation.replaceState(e,s,o)}forward(){this._platformLocation.forward()}back(){this._platformLocation.back()}getState(){return this._platformLocation.getState()}historyGo(e=0){this._platformLocation.historyGo?.(e)}}return n.\u0275fac=function(e){return new(e||n)(Se($0),Se(EO,8))},n.\u0275prov=Ve({token:n,factory:n.\u0275fac}),n})(),L0=(()=>{class n{constructor(e){this._subject=new un,this._urlChangeListeners=[],this._urlChangeSubscription=null,this._locationStrategy=e;const s=this._locationStrategy.getBaseHref();this._basePath=function A7(n){if(new RegExp("^(https?:)?//").test(n)){const[,e]=n.split(/\/\/[^\/]+/);return e}return n}(IO(TO(s))),this._locationStrategy.onPopState(r=>{this._subject.emit({url:this.path(!0),pop:!0,state:r.state,type:r.type})})}ngOnDestroy(){this._urlChangeSubscription?.unsubscribe(),this._urlChangeListeners=[]}path(e=!1){return this.normalize(this._locationStrategy.path(e))}getState(){return this._locationStrategy.getState()}isCurrentPathEqualTo(e,s=""){return this.path()==this.normalize(e+Qo(s))}normalize(e){return n.stripTrailingSlash(function k7(n,t){if(!n||!t.startsWith(n))return t;const e=t.substring(n.length);return""===e||["/",";","?","#"].includes(e[0])?e:t}(this._basePath,TO(e)))}prepareExternalUrl(e){return e&&"/"!==e[0]&&(e="/"+e),this._locationStrategy.prepareExternalUrl(e)}go(e,s="",r=null){this._locationStrategy.pushState(r,"",e,s),this._notifyUrlChangeListeners(this.prepareExternalUrl(e+Qo(s)),r)}replaceState(e,s="",r=null){this._locationStrategy.replaceState(r,"",e,s),this._notifyUrlChangeListeners(this.prepareExternalUrl(e+Qo(s)),r)}forward(){this._locationStrategy.forward()}back(){this._locationStrategy.back()}historyGo(e=0){this._locationStrategy.historyGo?.(e)}onUrlChange(e){return this._urlChangeListeners.push(e),this._urlChangeSubscription||(this._urlChangeSubscription=this.subscribe(s=>{this._notifyUrlChangeListeners(s.url,s.state)})),()=>{const s=this._urlChangeListeners.indexOf(e);this._urlChangeListeners.splice(s,1),0===this._urlChangeListeners.length&&(this._urlChangeSubscription?.unsubscribe(),this._urlChangeSubscription=null)}}_notifyUrlChangeListeners(e="",s){this._urlChangeListeners.forEach(r=>r(e,s))}subscribe(e,s,r){return this._subject.subscribe({next:e,error:s,complete:r})}}return n.normalizeQueryParams=Qo,n.joinWithSlash=P0,n.stripTrailingSlash=IO,n.\u0275fac=function(e){return new(e||n)(Se(Wl))},n.\u0275prov=Ve({token:n,factory:function(){return function N7(){return new L0(Se(Wl))}()},providedIn:"root"}),n})();function TO(n){return n.replace(/\/index.html$/,"")}var xr=(()=>((xr=xr||{})[xr.Decimal=0]="Decimal",xr[xr.Percent=1]="Percent",xr[xr.Currency=2]="Currency",xr[xr.Scientific=3]="Scientific",xr))(),Ge=(()=>((Ge=Ge||{})[Ge.Decimal=0]="Decimal",Ge[Ge.Group=1]="Group",Ge[Ge.List=2]="List",Ge[Ge.PercentSign=3]="PercentSign",Ge[Ge.PlusSign=4]="PlusSign",Ge[Ge.MinusSign=5]="MinusSign",Ge[Ge.Exponential=6]="Exponential",Ge[Ge.SuperscriptingExponent=7]="SuperscriptingExponent",Ge[Ge.PerMille=8]="PerMille",Ge[Ge.Infinity=9]="Infinity",Ge[Ge.NaN=10]="NaN",Ge[Ge.TimeSeparator=11]="TimeSeparator",Ge[Ge.CurrencyDecimal=12]="CurrencyDecimal",Ge[Ge.CurrencyGroup=13]="CurrencyGroup",Ge))();function li(n,t){const e=nr(n),s=e[Ee.NumberSymbols][t];if(typeof s>"u"){if(t===Ge.CurrencyDecimal)return e[Ee.NumberSymbols][Ge.Decimal];if(t===Ge.CurrencyGroup)return e[Ee.NumberSymbols][Ge.Group]}return s}const sY=/^(\d+)?\.((\d+)(-(\d+))?)?$/;function j0(n){const t=parseInt(n);if(isNaN(t))throw new Error("Invalid integer literal when parsing "+n);return t}class yY{constructor(t,e,s,r){this.$implicit=t,this.ngForOf=e,this.index=s,this.count=r}get first(){return 0===this.index}get last(){return this.index===this.count-1}get even(){return this.index%2==0}get odd(){return!this.even}}let VO=(()=>{class n{set ngForOf(e){this._ngForOf=e,this._ngForOfDirty=!0}set ngForTrackBy(e){this._trackByFn=e}get ngForTrackBy(){return this._trackByFn}constructor(e,s,r){this._viewContainer=e,this._template=s,this._differs=r,this._ngForOf=null,this._ngForOfDirty=!0,this._differ=null}set ngForTemplate(e){e&&(this._template=e)}ngDoCheck(){if(this._ngForOfDirty){this._ngForOfDirty=!1;const e=this._ngForOf;!this._differ&&e&&(this._differ=this._differs.find(e).create(this.ngForTrackBy))}if(this._differ){const e=this._differ.diff(this._ngForOf);e&&this._applyChanges(e)}}_applyChanges(e){const s=this._viewContainer;e.forEachOperation((r,i,o)=>{if(null==r.previousIndex)s.createEmbeddedView(this._template,new yY(r.item,this._ngForOf,-1,-1),null===o?void 0:o);else if(null==o)s.remove(null===i?void 0:i);else if(null!==i){const a=s.get(i);s.move(a,o),BO(a,r)}});for(let r=0,i=s.length;r<i;r++){const a=s.get(r).context;a.index=r,a.count=i,a.ngForOf=this._ngForOf}e.forEachIdentityChange(r=>{BO(s.get(r.currentIndex),r)})}static ngTemplateContextGuard(e,s){return!0}}return n.\u0275fac=function(e){return new(e||n)(ne(Oi),ne(Xo),ne(Og))},n.\u0275dir=qe({type:n,selectors:[["","ngFor","","ngForOf",""]],inputs:{ngForOf:"ngForOf",ngForTrackBy:"ngForTrackBy",ngForTemplate:"ngForTemplate"},standalone:!0}),n})();function BO(n,t){n.context.$implicit=t.item}let X0=(()=>{class n{constructor(e,s){this._viewContainer=e,this._context=new bY,this._thenTemplateRef=null,this._elseTemplateRef=null,this._thenViewRef=null,this._elseViewRef=null,this._thenTemplateRef=s}set ngIf(e){this._context.$implicit=this._context.ngIf=e,this._updateView()}set ngIfThen(e){zO("ngIfThen",e),this._thenTemplateRef=e,this._thenViewRef=null,this._updateView()}set ngIfElse(e){zO("ngIfElse",e),this._elseTemplateRef=e,this._elseViewRef=null,this._updateView()}_updateView(){this._context.$implicit?this._thenViewRef||(this._viewContainer.clear(),this._elseViewRef=null,this._thenTemplateRef&&(this._thenViewRef=this._viewContainer.createEmbeddedView(this._thenTemplateRef,this._context))):this._elseViewRef||(this._viewContainer.clear(),this._thenViewRef=null,this._elseTemplateRef&&(this._elseViewRef=this._viewContainer.createEmbeddedView(this._elseTemplateRef,this._context)))}static ngTemplateContextGuard(e,s){return!0}}return n.\u0275fac=function(e){return new(e||n)(ne(Oi),ne(Xo))},n.\u0275dir=qe({type:n,selectors:[["","ngIf",""]],inputs:{ngIf:"ngIf",ngIfThen:"ngIfThen",ngIfElse:"ngIfElse"},standalone:!0}),n})();class bY{constructor(){this.$implicit=null,this.ngIf=null}}function zO(n,t){if(t&&!t.createEmbeddedView)throw new Error(`${n} must be a TemplateRef, but received '${hs(t)}'.`)}let GO=(()=>{class n{constructor(e){this._locale=e}transform(e,s,r){if(!function Q0(n){return!(null==n||""===n||n!=n)}(e))return null;r=r||this._locale;try{return function uY(n,t,e){return function G0(n,t,e,s,r,i,o=!1){let a="",l=!1;if(isFinite(n)){let u=function dY(n){let s,r,i,o,a,t=Math.abs(n)+"",e=0;for((r=t.indexOf("."))>-1&&(t=t.replace(".","")),(i=t.search(/e/i))>0?(r<0&&(r=i),r+=+t.slice(i+1),t=t.substring(0,i)):r<0&&(r=t.length),i=0;"0"===t.charAt(i);i++);if(i===(a=t.length))s=[0],r=1;else{for(a--;"0"===t.charAt(a);)a--;for(r-=i,s=[],o=0;i<=a;i++,o++)s[o]=Number(t.charAt(i))}return r>22&&(s=s.splice(0,21),e=r-1,r=1),{digits:s,exponent:e,integerLen:r}}(n);o&&(u=function cY(n){if(0===n.digits[0])return n;const t=n.digits.length-n.integerLen;return n.exponent?n.exponent+=2:(0===t?n.digits.push(0,0):1===t&&n.digits.push(0),n.integerLen+=2),n}(u));let c=t.minInt,d=t.minFrac,h=t.maxFrac;if(i){const b=i.match(sY);if(null===b)throw new Error(`${i} is not a valid digit info`);const v=b[1],_=b[3],x=b[5];null!=v&&(c=j0(v)),null!=_&&(d=j0(_)),null!=x?h=j0(x):null!=_&&d>h&&(h=d)}!function hY(n,t,e){if(t>e)throw new Error(`The minimum number of digits after fraction (${t}) is higher than the maximum (${e}).`);let s=n.digits,r=s.length-n.integerLen;const i=Math.min(Math.max(t,r),e);let o=i+n.integerLen,a=s[o];if(o>0){s.splice(Math.max(n.integerLen,o));for(let d=o;d<s.length;d++)s[d]=0}else{r=Math.max(0,r),n.integerLen=1,s.length=Math.max(1,o=i+1),s[0]=0;for(let d=1;d<o;d++)s[d]=0}if(a>=5)if(o-1<0){for(let d=0;d>o;d--)s.unshift(0),n.integerLen++;s.unshift(1),n.integerLen++}else s[o-1]++;for(;r<Math.max(0,i);r++)s.push(0);let l=0!==i;const u=t+n.integerLen,c=s.reduceRight(function(d,h,f,p){return p[f]=(h+=d)<10?h:h-10,l&&(0===p[f]&&f>=u?p.pop():l=!1),h>=10?1:0},0);c&&(s.unshift(c),n.integerLen++)}(u,d,h);let f=u.digits,p=u.integerLen;const g=u.exponent;let m=[];for(l=f.every(b=>!b);p<c;p++)f.unshift(0);for(;p<0;p++)f.unshift(0);p>0?m=f.splice(p,f.length):(m=f,f=[0]);const y=[];for(f.length>=t.lgSize&&y.unshift(f.splice(-t.lgSize,f.length).join(""));f.length>t.gSize;)y.unshift(f.splice(-t.gSize,f.length).join(""));f.length&&y.unshift(f.join("")),a=y.join(li(e,s)),m.length&&(a+=li(e,r)+m.join("")),g&&(a+=li(e,Ge.Exponential)+"+"+g)}else a=li(e,Ge.Infinity);return a=n<0&&!l?t.negPre+a+t.negSuf:t.posPre+a+t.posSuf,a}(n,function H0(n,t="-"){const e={minInt:1,minFrac:0,maxFrac:0,posPre:"",posSuf:"",negPre:"",negSuf:"",gSize:0,lgSize:0},s=n.split(";"),r=s[0],i=s[1],o=-1!==r.indexOf(".")?r.split("."):[r.substring(0,r.lastIndexOf("0")+1),r.substring(r.lastIndexOf("0")+1)],a=o[0],l=o[1]||"";e.posPre=a.substring(0,a.indexOf("#"));for(let c=0;c<l.length;c++){const d=l.charAt(c);"0"===d?e.minFrac=e.maxFrac=c+1:"#"===d?e.maxFrac=c+1:e.posSuf+=d}const u=a.split(",");if(e.gSize=u[1]?u[1].length:0,e.lgSize=u[2]||u[1]?(u[2]||u[1]).length:0,i){const c=r.length-e.posPre.length-e.posSuf.length,d=i.indexOf("#");e.negPre=i.substring(0,d).replace(/'/g,""),e.negSuf=i.slice(d+c).replace(/'/g,"")}else e.negPre=t+e.posPre,e.negSuf=e.posSuf;return e}(function V0(n,t){return nr(n)[Ee.NumberFormats][t]}(t,xr.Decimal),li(t,Ge.MinusSign)),t,Ge.Group,Ge.Decimal,e)}(function J0(n){if("string"==typeof n&&!isNaN(Number(n)-parseFloat(n)))return Number(n);if("number"!=typeof n)throw new Error(`${n} is not a number`);return n}(e),r,s)}catch(i){throw function Li(n,t){return new ee(2100,!1)}()}}}return n.\u0275fac=function(e){return new(e||n)(ne(po,16))},n.\u0275pipe=gr({name:"number",type:n,pure:!0,standalone:!0}),n})();let HO=(()=>{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275mod=Or({type:n}),n.\u0275inj=fr({}),n})();const jO="browser";function qO(n){return"server"===n}let jY=(()=>{class n{}return n.\u0275prov=Ve({token:n,providedIn:"root",factory:()=>new qY(Se(Es),window)}),n})();class qY{constructor(t,e){this.document=t,this.window=e,this.offset=()=>[0,0]}setOffset(t){this.offset=Array.isArray(t)?()=>t:t}getScrollPosition(){return this.supportsScrolling()?[this.window.pageXOffset,this.window.pageYOffset]:[0,0]}scrollToPosition(t){this.supportsScrolling()&&this.window.scrollTo(t[0],t[1])}scrollToAnchor(t){if(!this.supportsScrolling())return;const e=function KY(n,t){const e=n.getElementById(t)||n.getElementsByName(t)[0];if(e)return e;if("function"==typeof n.createTreeWalker&&n.body&&"function"==typeof n.body.attachShadow){const s=n.createTreeWalker(n.body,NodeFilter.SHOW_ELEMENT);let r=s.currentNode;for(;r;){const i=r.shadowRoot;if(i){const o=i.getElementById(t)||i.querySelector(`[name="${t}"]`);if(o)return o}r=s.nextNode()}}return null}(this.document,t);e&&(this.scrollToElement(e),e.focus())}setHistoryScrollRestoration(t){if(this.supportScrollRestoration()){const e=this.window.history;e&&e.scrollRestoration&&(e.scrollRestoration=t)}}scrollToElement(t){const e=t.getBoundingClientRect(),s=e.left+this.window.pageXOffset,r=e.top+this.window.pageYOffset,i=this.offset();this.window.scrollTo(s-i[0],r-i[1])}supportScrollRestoration(){try{if(!this.supportsScrolling())return!1;const t=KO(this.window.history)||KO(Object.getPrototypeOf(this.window.history));return!(!t||!t.writable&&!t.set)}catch{return!1}}supportsScrolling(){try{return!!this.window&&!!this.window.scrollTo&&"pageXOffset"in this.window}catch{return!1}}}function KO(n){return Object.getOwnPropertyDescriptor(n,"scrollRestoration")}class xZ extends S7{constructor(){super(...arguments),this.supportsDOMEvents=!0}}class nC extends xZ{static makeCurrent(){!function C7(n){O0||(O0=n)}(new nC)}onAndCancel(t,e,s){return t.addEventListener(e,s),()=>{t.removeEventListener(e,s)}}dispatchEvent(t,e){t.dispatchEvent(e)}remove(t){t.parentNode&&t.parentNode.removeChild(t)}createElement(t,e){return(e=e||this.getDefaultDocument()).createElement(t)}createHtmlDocument(){return document.implementation.createHTMLDocument("fakeTitle")}getDefaultDocument(){return document}isElementNode(t){return t.nodeType===Node.ELEMENT_NODE}isShadowRoot(t){return t instanceof DocumentFragment}getGlobalEventTarget(t,e){return"window"===e?window:"document"===e?t:"body"===e?t.body:null}getBaseHref(t){const e=function CZ(){return $h=$h||document.querySelector("base"),$h?$h.getAttribute("href"):null}();return null==e?null:function SZ(n){Kg=Kg||document.createElement("a"),Kg.setAttribute("href",n);const t=Kg.pathname;return"/"===t.charAt(0)?t:`/${t}`}(e)}resetBaseElement(){$h=null}getUserAgent(){return window.navigator.userAgent}getCookie(t){return function pY(n,t){t=encodeURIComponent(t);for(const e of n.split(";")){const s=e.indexOf("="),[r,i]=-1==s?[e,""]:[e.slice(0,s),e.slice(s+1)];if(r.trim()===t)return decodeURIComponent(i)}return null}(document.cookie,t)}}let Kg,$h=null,EZ=(()=>{class n{build(){return new XMLHttpRequest}}return n.\u0275fac=function(e){return new(e||n)},n.\u0275prov=Ve({token:n,factory:n.\u0275fac}),n})();const sC=new we("EventManagerPlugins");let JO=(()=>{class n{constructor(e,s){this._zone=s,this._eventNameToPlugin=new Map,e.forEach(r=>{r.manager=this}),this._plugins=e.slice().reverse()}addEventListener(e,s,r){return this._findPluginFor(s).addEventListener(e,s,r)}getZone(){return this._zone}_findPluginFor(e){const s=this._eventNameToPlugin.get(e);if(s)return s;const r=this._plugins;for(let i=0;i<r.length;i++){const o=r[i];if(o.supports(e))return this._eventNameToPlugin.set(e,o),o}throw new Error(`No event manager plugin found for event ${e}`)}}return n.\u0275fac=function(e){return new(e||n)(Se(sC),Se(Pt))},n.\u0275prov=Ve({token:n,factory:n.\u0275fac}),n})();class e${constructor(t){this._doc=t}}const rC="ng-app-id";let t$=(()=>{class n{constructor(e,s,r,i={}){this.doc=e,this.appId=s,this.nonce=r,this.platformId=i,this.styleRef=new Map,this.hostNodes=new Set,this.styleNodesInDOM=this.collectServerRenderedStyles(),this.platformIsServer=qO(i),this.resetHostNodes()}addStyles(e){for(const s of e)1===this.changeUsageCount(s,1)&&this.onStyleAdded(s)}removeStyles(e){for(const s of e)this.changeUsageCount(s,-1)<=0&&this.onStyleRemoved(s)}ngOnDestroy(){const e=this.styleNodesInDOM;e&&(e.forEach(s=>s.remove()),e.clear());for(const s of this.getAllStyles())this.onStyleRemoved(s);this.resetHostNodes()}addHost(e){this.hostNodes.add(e);for(const s of this.getAllStyles())this.addStyleToHost(e,s)}removeHost(e){this.hostNodes.delete(e)}getAllStyles(){return this.styleRef.keys()}onStyleAdded(e){for(const s of this.hostNodes)this.addStyleToHost(s,e)}onStyleRemoved(e){const s=this.styleRef;s.get(e)?.elements?.forEach(r=>r.remove()),s.delete(e)}collectServerRenderedStyles(){const e=this.doc.head?.querySelectorAll(`style[${rC}="${this.appId}"]`);if(e?.length){const s=new Map;return e.forEach(r=>{null!=r.textContent&&s.set(r.textContent,r)}),s}return null}changeUsageCount(e,s){const r=this.styleRef;if(r.has(e)){const i=r.get(e);return i.usage+=s,i.usage}return r.set(e,{usage:s,elements:[]}),s}getStyleElement(e,s){const r=this.styleNodesInDOM,i=r?.get(s);if(i?.parentNode===e)return r.delete(s),i.removeAttribute(rC),i;{const o=this.doc.createElement("style");return this.nonce&&o.setAttribute("nonce",this.nonce),o.textContent=s,this.platformIsServer&&o.setAttribute(rC,this.appId),o}}addStyleToHost(e,s){const r=this.getStyleElement(e,s);e.appendChild(r);const i=this.styleRef,o=i.get(s)?.elements;o?o.push(r):i.set(s,{elements:[r],usage:1})}resetHostNodes(){const e=this.hostNodes;e.clear(),e.add(this.doc.head)}}return n.\u0275fac=function(e){return new(e||n)(Se(Es),Se(Qm),Se(ax,8),Se(nc))},n.\u0275prov=Ve({token:n,factory:n.\u0275fac}),n})();const iC={svg:"http://www.w3.org/2000/svg",xhtml:"http://www.w3.org/1999/xhtml",xlink:"http://www.w3.org/1999/xlink",xml:"http://www.w3.org/XML/1998/namespace",xmlns:"http://www.w3.org/2000/xmlns/",math:"http://www.w3.org/1998/MathML/"},oC=/%COMP%/g,kZ=new we("RemoveStylesOnCompDestory",{providedIn:"root",factory:()=>!1});function s$(n,t){return t.map(e=>e.replace(oC,n))}let aC=(()=>{class n{constructor(e,s,r,i,o,a,l,u=null){this.eventManager=e,this.sharedStylesHost=s,this.appId=r,this.removeStylesOnCompDestory=i,this.doc=o,this.platformId=a,this.ngZone=l,this.nonce=u,this.rendererByCompId=new Map,this.platformIsServer=qO(a),this.defaultRenderer=new lC(e,o,l,this.platformIsServer)}createRenderer(e,s){if(!e||!s)return this.defaultRenderer;this.platformIsServer&&s.encapsulation===mr.ShadowDom&&(s={...s,encapsulation:mr.Emulated});const r=this.getOrCreateRenderer(e,s);return r instanceof i$?r.applyToHost(e):r instanceof uC&&r.applyStyles(),r}getOrCreateRenderer(e,s){const r=this.rendererByCompId;let i=r.get(s.id);if(!i){const o=this.doc,a=this.ngZone,l=this.eventManager,u=this.sharedStylesHost,c=this.removeStylesOnCompDestory,d=this.platformIsServer;switch(s.encapsulation){case mr.Emulated:i=new i$(l,u,s,this.appId,c,o,a,d);break;case mr.ShadowDom:return new FZ(l,u,e,s,o,a,this.nonce,d);default:i=new uC(l,u,s,c,o,a,d)}i.onDestroy=()=>r.delete(s.id),r.set(s.id,i)}return i}ngOnDestroy(){this.rendererByCompId.clear()}}return n.\u0275fac=function(e){return new(e||n)(Se(JO),Se(t$),Se(Qm),Se(kZ),Se(Es),Se(nc),Se(Pt),Se(ax))},n.\u0275prov=Ve({token:n,factory:n.\u0275fac}),n})();class lC{constructor(t,e,s,r){this.eventManager=t,this.doc=e,this.ngZone=s,this.platformIsServer=r,this.data=Object.create(null),this.destroyNode=null}destroy(){}createElement(t,e){return e?this.doc.createElementNS(iC[e]||e,t):this.doc.createElement(t)}createComment(t){return this.doc.createComment(t)}createText(t){return this.doc.createTextNode(t)}appendChild(t,e){(r$(t)?t.content:t).appendChild(e)}insertBefore(t,e,s){t&&(r$(t)?t.content:t).insertBefore(e,s)}removeChild(t,e){t&&t.removeChild(e)}selectRootElement(t,e){let s="string"==typeof t?this.doc.querySelector(t):t;if(!s)throw new Error(`The selector "${t}" did not match any elements`);return e||(s.textContent=""),s}parentNode(t){return t.parentNode}nextSibling(t){return t.nextSibling}setAttribute(t,e,s,r){if(r){e=r+":"+e;const i=iC[r];i?t.setAttributeNS(i,e,s):t.setAttribute(e,s)}else t.setAttribute(e,s)}removeAttribute(t,e,s){if(s){const r=iC[s];r?t.removeAttributeNS(r,e):t.removeAttribute(`${s}:${e}`)}else t.removeAttribute(e)}addClass(t,e){t.classList.add(e)}removeClass(t,e){t.classList.remove(e)}setStyle(t,e,s,r){r&(_r.DashCase|_r.Important)?t.style.setProperty(e,s,r&_r.Important?"important":""):t.style[e]=s}removeStyle(t,e,s){s&_r.DashCase?t.style.removeProperty(e):t.style[e]=""}setProperty(t,e,s){t[e]=s}setValue(t,e){t.nodeValue=e}listen(t,e,s){if("string"==typeof t&&!(t=ka().getGlobalEventTarget(this.doc,t)))throw new Error(`Unsupported event target ${t} for event ${e}`);return this.eventManager.addEventListener(t,e,this.decoratePreventDefault(s))}decoratePreventDefault(t){return e=>{if("__ngUnwrap__"===e)return t;!1===(this.platformIsServer?this.ngZone.runGuarded(()=>t(e)):t(e))&&(e.preventDefault(),e.returnValue=!1)}}}function r$(n){return"TEMPLATE"===n.tagName&&void 0!==n.content}class FZ extends lC{constructor(t,e,s,r,i,o,a,l){super(t,i,o,l),this.sharedStylesHost=e,this.hostEl=s,this.shadowRoot=s.attachShadow({mode:"open"}),this.sharedStylesHost.addHost(this.shadowRoot);const u=s$(r.id,r.styles);for(const c of u){const d=document.createElement("style");a&&d.setAttribute("nonce",a),d.textContent=c,this.shadowRoot.appendChild(d)}}nodeOrShadowRoot(t){return t===this.hostEl?this.shadowRoot:t}appendChild(t,e){return super.appendChild(this.nodeOrShadowRoot(t),e)}insertBefore(t,e,s){return super.insertBefore(this.nodeOrShadowRoot(t),e,s)}removeChild(t,e){return super.removeChild(this.nodeOrShadowRoot(t),e)}parentNode(t){return this.nodeOrShadowRoot(super.parentNode(this.nodeOrShadowRoot(t)))}destroy(){this.sharedStylesHost.removeHost(this.shadowRoot)}}class uC extends lC{constructor(t,e,s,r,i,o,a,l){super(t,i,o,a),this.sharedStylesHost=e,this.removeStylesOnCompDestory=r,this.rendererUsageCount=0,this.styles=l?s$(l,s.styles):s.styles}applyStyles(){this.sharedStylesHost.addStyles(this.styles),this.rendererUsageCount++}destroy(){this.removeStylesOnCompDestory&&(this.sharedStylesHost.removeStyles(this.styles),this.rendererUsageCount--,0===this.rendererUsageCount&&this.onDestroy?.())}}class i$ extends uC{constructor(t,e,s,r,i,o,a,l){const u=r+"-"+s.id;super(t,e,s,i,o,a,l,u),this.contentAttr=function AZ(n){return"_ngcontent-%COMP%".replace(oC,n)}(u),this.hostAttr=function RZ(n){return"_nghost-%COMP%".replace(oC,n)}(u)}applyToHost(t){this.applyStyles(),this.setAttribute(t,this.hostAttr,"")}createElement(t,e){const s=super.createElement(t,e);return super.setAttribute(s,this.contentAttr,""),s}}let OZ=(()=>{class n extends e${constructor(e){super(e)}supports(e){return!0}addEventListener(e,s,r){return e.addEventListener(s,r,!1),()=>this.removeEventListener(e,s,r)}removeEventListener(e,s,r){return e.removeEventListener(s,r)}}return n.\u0275fac=function(e){return new(e||n)(Se(Es))},n.\u0275prov=Ve({token:n,factory:n.\u0275fac}),n})();const o$=["alt","control","meta","shift"],$Z={"\b":"Backspace","\t":"Tab","\x7f":"Delete","\x1b":"Escape",Del:"Delete",Esc:"Escape",Left:"ArrowLeft",Right:"ArrowRight",Up:"ArrowUp",Down:"ArrowDown",Menu:"ContextMenu",Scroll:"ScrollLock",Win:"OS"},PZ={alt:n=>n.altKey,control:n=>n.ctrlKey,meta:n=>n.metaKey,shift:n=>n.shiftKey};let LZ=(()=>{class n extends e${constructor(e){super(e)}supports(e){return null!=n.parseEventName(e)}addEventListener(e,s,r){const i=n.parseEventName(s),o=n.eventCallback(i.fullKey,r,this.manager.getZone());return this.manager.getZone().runOutsideAngular(()=>ka().onAndCancel(e,i.domEventName,o))}static parseEventName(e){const s=e.toLowerCase().split("."),r=s.shift();if(0===s.length||"keydown"!==r&&"keyup"!==r)return null;const i=n._normalizeKey(s.pop());let o="",a=s.indexOf("code");if(a>-1&&(s.splice(a,1),o="code."),o$.forEach(u=>{const c=s.indexOf(u);c>-1&&(s.splice(c,1),o+=u+".")}),o+=i,0!=s.length||0===i.length)return null;const l={};return l.domEventName=r,l.fullKey=o,l}static matchEventFullKeyCode(e,s){let r=$Z[e.key]||e.key,i="";return s.indexOf("code.")>-1&&(r=e.code,i="code."),!(null==r||!r)&&(r=r.toLowerCase()," "===r?r="space":"."===r&&(r="dot"),o$.forEach(o=>{o!==r&&(0,PZ[o])(e)&&(i+=o+".")}),i+=r,i===s)}static eventCallback(e,s,r){return i=>{n.matchEventFullKeyCode(i,e)&&r.runGuarded(()=>s(i))}}static _normalizeKey(e){return"esc"===e?"escape":e}}return n.\u0275fac=function(e){return new(e||n)(Se(Es))},n.\u0275prov=Ve({token:n,factory:n.\u0275fac}),n})();const UZ=QF(d7,"browser",[{provide:nc,useValue:jO},{provide:bA,useValue:function VZ(){nC.makeCurrent()},multi:!0},{provide:Es,useFactory:function zZ(){return function Vq(n){qw=n}(document),document},deps:[]}]),WZ=new we(""),u$=[{provide:Ag,useClass:class IZ{addToWindow(t){ln.getAngularTestability=(s,r=!0)=>{const i=t.findTestabilityInTree(s,r);if(null==i)throw new Error("Could not find testability for element.");return i},ln.getAllAngularTestabilities=()=>t.getAllTestabilities(),ln.getAllAngularRootElements=()=>t.getAllRootElements(),ln.frameworkStabilizers||(ln.frameworkStabilizers=[]),ln.frameworkStabilizers.push(s=>{const r=ln.getAllAngularTestabilities();let i=r.length,o=!1;const a=function(l){o=o||l,i--,0==i&&s(o)};r.forEach(function(l){l.whenStable(a)})})}findTestabilityInTree(t,e,s){return null==e?null:t.getTestability(e)??(s?ka().isShadowRoot(e)?this.findTestabilityInTree(t,e.host,!0):this.findTestabilityInTree(t,e.parentElement,!0):null)}},deps:[]},{provide:qF,useClass:C0,deps:[Pt,S0,Ag]},{provide:C0,useClass:C0,deps:[Pt,S0,Ag]}],c$=[{provide:nx,useValue:"root"},{provide:Pl,useFactory:function BZ(){return new Pl},deps:[]},{provide:sC,useClass:OZ,multi:!0,deps:[Es,Pt,nc]},{provide:sC,useClass:LZ,multi:!0,deps:[Es]},aC,t$,JO,{provide:ch,useExisting:aC},{provide:class XY{},useClass:EZ,deps:[]},[]];let d$=(()=>{class n{constructor(e){}static withServerTransition(e){return{ngModule:n,providers:[{provide:Qm,useValue:e.appId}]}}}return n.\u0275fac=function(e){return new(e||n)(Se(WZ,12))},n.\u0275mod=Or({type:n}),n.\u0275inj=fr({providers:[...c$,...u$],imports:[HO,h7]}),n})(),h$=(()=>{class n{constructor(e){this._doc=e}getTitle(){return this._doc.title}setTitle(e){this._doc.title=e||""}}return n.\u0275fac=function(e){return new(e||n)(Se(Es))},n.\u0275prov=Ve({token:n,factory:function(e){let s=null;return s=e?new e:function HZ(){return new h$(Se(Es))}(),s},providedIn:"root"}),n})();function tt(...n){return Cs(n,Fd(n))}typeof window<"u"&&window;class Vi extends Ti{constructor(t){super(),this._value=t}get value(){return this.getValue()}_subscribe(t){const e=super._subscribe(t);return!e.closed&&t.next(this._value),e}getValue(){const{hasError:t,thrownError:e,_value:s}=this;if(t)throw e;return this._throwIfClosed(),s}next(t){super.next(this._value=t)}}const{isArray:ZZ}=Array,{getPrototypeOf:QZ,prototype:JZ,keys:eQ}=Object;const{isArray:nQ}=Array;function Xg(...n){const t=Fd(n),e=function XN(n){return pe(U_(n))?n.pop():void 0}(n),{args:s,keys:r}=function g$(n){if(1===n.length){const t=n[0];if(ZZ(t))return{args:t,keys:null};if(function tQ(n){return n&&"object"==typeof n&&QZ(n)===JZ}(t)){const e=eQ(t);return{args:e.map(s=>t[s]),keys:e}}}return{args:n,keys:null}}(n);if(0===s.length)return Cs([],t);const i=new Wn(function rQ(n,t,e=El){return s=>{v$(t,()=>{const{length:r}=n,i=new Array(r);let o=r,a=r;for(let l=0;l<r;l++)v$(t,()=>{const u=Cs(n[l],t);let c=!1;u.subscribe(Xn(s,d=>{i[l]=d,c||(c=!0,a--),a||s.next(e(i.slice()))},()=>{--o||s.complete()}))},s)},s)}}(s,t,r?o=>function b$(n,t){return n.reduce((e,s,r)=>(e[s]=t[r],e),{})}(r,o):El));return e?i.pipe(function y$(n){return Ht(t=>function sQ(n,t){return nQ(t)?n(...t):n(t)}(n,t))}(e)):i}function v$(n,t,e){n?$o(e,n,t):t()}const Yg=He(n=>function(){n(this),this.name="EmptyError",this.message="no elements in sequence"});function Zg(...n){return function iQ(){return Ou(1)}()(Cs(n,Fd(n)))}function _$(n){return new Wn(t=>{Mr(n()).subscribe(t)})}function Ph(n,t){const e=pe(n)?n:()=>n,s=r=>r.error(e());return new Wn(t?r=>t.schedule(s,0,r):s)}function dC(){return ds((n,t)=>{let e=null;n._refCount++;const s=Xn(t,void 0,void 0,void 0,()=>{if(!n||n._refCount<=0||0<--n._refCount)return void(e=null);const r=n._connection,i=e;e=null,r&&(!i||r===i)&&r.unsubscribe(),t.unsubscribe()});n.subscribe(s),s.closed||(e=n.connect())})}class w$ extends Wn{constructor(t,e){super(),this.source=t,this.subjectFactory=e,this._subject=null,this._refCount=0,this._connection=null,ON(t)&&(this.lift=t.lift)}_subscribe(t){return this.getSubject().subscribe(t)}getSubject(){const t=this._subject;return(!t||t.isStopped)&&(this._subject=this.subjectFactory()),this._subject}_teardown(){this._refCount=0;const{_connection:t}=this;this._subject=this._connection=null,t?.unsubscribe()}connect(){let t=this._connection;if(!t){t=this._connection=new ut;const e=this.getSubject();t.add(this.source.subscribe(Xn(e,void 0,()=>{this._teardown(),e.complete()},s=>{this._teardown(),e.error(s)},()=>this._teardown()))),t.closed&&(this._connection=null,t=ut.EMPTY)}return t}refCount(){return dC()(this)}}function ea(n,t){return ds((e,s)=>{let r=null,i=0,o=!1;const a=()=>o&&!r&&s.complete();e.subscribe(Xn(s,l=>{r?.unsubscribe();let u=0;const c=i++;Mr(n(l,c)).subscribe(r=Xn(s,d=>s.next(t?t(l,d,c,u++):d),()=>{r=null,a()}))},()=>{o=!0,a()}))})}function Gl(n){return n<=0?()=>Ji:ds((t,e)=>{let s=0;t.subscribe(Xn(e,r=>{++s<=n&&(e.next(r),n<=s&&e.complete())}))})}function x$(...n){const t=Fd(n);return ds((e,s)=>{(t?Zg(n,e,t):Zg(n,e)).subscribe(s)})}function ta(n,t){return ds((e,s)=>{let r=0;e.subscribe(Xn(s,i=>n.call(t,i,r++)&&s.next(i)))})}function Qg(n){return ds((t,e)=>{let s=!1;t.subscribe(Xn(e,r=>{s=!0,e.next(r)},()=>{s||e.next(n),e.complete()}))})}function C$(n=oQ){return ds((t,e)=>{let s=!1;t.subscribe(Xn(e,r=>{s=!0,e.next(r)},()=>s?e.complete():e.error(n())))})}function oQ(){return new Yg}function Hl(n,t){const e=arguments.length>=2;return s=>s.pipe(n?ta((r,i)=>n(r,i,s)):El,Gl(1),e?Qg(t):C$(()=>new Yg))}function Lh(n,t){return pe(t)?Os(n,t,1):Os(n,1)}function rr(n,t,e){const s=pe(n)||t||e?{next:n,error:t,complete:e}:n;return s?ds((r,i)=>{var o;null===(o=s.subscribe)||void 0===o||o.call(s);let a=!0;r.subscribe(Xn(i,l=>{var u;null===(u=s.next)||void 0===u||u.call(s,l),i.next(l)},()=>{var l;a=!1,null===(l=s.complete)||void 0===l||l.call(s),i.complete()},l=>{var u;a=!1,null===(u=s.error)||void 0===u||u.call(s,l),i.error(l)},()=>{var l,u;a&&(null===(l=s.unsubscribe)||void 0===l||l.call(s)),null===(u=s.finalize)||void 0===u||u.call(s)}))}):El}function jl(n){return ds((t,e)=>{let i,s=null,r=!1;s=t.subscribe(Xn(e,void 0,void 0,o=>{i=Mr(n(o,jl(n)(t))),s?(s.unsubscribe(),s=null,i.subscribe(e)):r=!0})),r&&(s.unsubscribe(),s=null,i.subscribe(e))})}function hC(n){return n<=0?()=>Ji:ds((t,e)=>{let s=[];t.subscribe(Xn(e,r=>{s.push(r),n<s.length&&s.shift()},()=>{for(const r of s)e.next(r);e.complete()},void 0,()=>{s=null}))})}function fC(n){return ds((t,e)=>{try{t.subscribe(e)}finally{e.add(n)}})}const ct="primary",Vh=Symbol("RouteTitle");class dQ{constructor(t){this.params=t||{}}has(t){return Object.prototype.hasOwnProperty.call(this.params,t)}get(t){if(this.has(t)){const e=this.params[t];return Array.isArray(e)?e[0]:e}return null}getAll(t){if(this.has(t)){const e=this.params[t];return Array.isArray(e)?e:[e]}return[]}get keys(){return Object.keys(this.params)}}function Tc(n){return new dQ(n)}function hQ(n,t,e){const s=e.path.split("/");if(s.length>n.length||"full"===e.pathMatch&&(t.hasChildren()||s.length<n.length))return null;const r={};for(let i=0;i<s.length;i++){const o=s[i],a=n[i];if(o.startsWith(":"))r[o.substring(1)]=a;else if(o!==a.path)return null}return{consumed:n.slice(0,s.length),posParams:r}}function mo(n,t){const e=n?Object.keys(n):void 0,s=t?Object.keys(t):void 0;if(!e||!s||e.length!=s.length)return!1;let r;for(let i=0;i<e.length;i++)if(r=e[i],!S$(n[r],t[r]))return!1;return!0}function S$(n,t){if(Array.isArray(n)&&Array.isArray(t)){if(n.length!==t.length)return!1;const e=[...n].sort(),s=[...t].sort();return e.every((r,i)=>s[i]===r)}return n===t}function I$(n){return n.length>0?n[n.length-1]:null}function Ra(n){return function YZ(n){return!!n&&(n instanceof Wn||pe(n.lift)&&pe(n.subscribe))}(n)?n:_h(n)?Cs(Promise.resolve(n)):tt(n)}const pQ={exact:function T$(n,t,e){if(!ql(n.segments,t.segments)||!Jg(n.segments,t.segments,e)||n.numberOfChildren!==t.numberOfChildren)return!1;for(const s in t.children)if(!n.children[s]||!T$(n.children[s],t.children[s],e))return!1;return!0},subset:N$},E$={exact:function mQ(n,t){return mo(n,t)},subset:function gQ(n,t){return Object.keys(t).length<=Object.keys(n).length&&Object.keys(t).every(e=>S$(n[e],t[e]))},ignored:()=>!0};function D$(n,t,e){return pQ[e.paths](n.root,t.root,e.matrixParams)&&E$[e.queryParams](n.queryParams,t.queryParams)&&!("exact"===e.fragment&&n.fragment!==t.fragment)}function N$(n,t,e){return k$(n,t,t.segments,e)}function k$(n,t,e,s){if(n.segments.length>e.length){const r=n.segments.slice(0,e.length);return!(!ql(r,e)||t.hasChildren()||!Jg(r,e,s))}if(n.segments.length===e.length){if(!ql(n.segments,e)||!Jg(n.segments,e,s))return!1;for(const r in t.children)if(!n.children[r]||!N$(n.children[r],t.children[r],s))return!1;return!0}{const r=e.slice(0,n.segments.length),i=e.slice(n.segments.length);return!!(ql(n.segments,r)&&Jg(n.segments,r,s)&&n.children[ct])&&k$(n.children[ct],t,i,s)}}function Jg(n,t,e){return t.every((s,r)=>E$[e](n[r].parameters,s.parameters))}class Nc{constructor(t=new qt([],{}),e={},s=null){this.root=t,this.queryParams=e,this.fragment=s}get queryParamMap(){return this._queryParamMap||(this._queryParamMap=Tc(this.queryParams)),this._queryParamMap}toString(){return vQ.serialize(this)}}class qt{constructor(t,e){this.segments=t,this.children=e,this.parent=null,Object.values(e).forEach(s=>s.parent=this)}hasChildren(){return this.numberOfChildren>0}get numberOfChildren(){return Object.keys(this.children).length}toString(){return ey(this)}}class Bh{constructor(t,e){this.path=t,this.parameters=e}get parameterMap(){return this._parameterMap||(this._parameterMap=Tc(this.parameters)),this._parameterMap}toString(){return M$(this)}}function ql(n,t){return n.length===t.length&&n.every((e,s)=>e.path===t[s].path)}let zh=(()=>{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275prov=Ve({token:n,factory:function(){return new pC},providedIn:"root"}),n})();class pC{parse(t){const e=new kQ(t);return new Nc(e.parseRootSegment(),e.parseQueryParams(),e.parseFragment())}serialize(t){const e=`/${Uh(t.root,!0)}`,s=function xQ(n){const t=Object.keys(n).map(e=>{const s=n[e];return Array.isArray(s)?s.map(r=>`${ty(e)}=${ty(r)}`).join("&"):`${ty(e)}=${ty(s)}`}).filter(e=>!!e);return t.length?`?${t.join("&")}`:""}(t.queryParams);return`${e}${s}${"string"==typeof t.fragment?`#${function _Q(n){return encodeURI(n)}(t.fragment)}`:""}`}}const vQ=new pC;function ey(n){return n.segments.map(t=>M$(t)).join("/")}function Uh(n,t){if(!n.hasChildren())return ey(n);if(t){const e=n.children[ct]?Uh(n.children[ct],!1):"",s=[];return Object.entries(n.children).forEach(([r,i])=>{r!==ct&&s.push(`${r}:${Uh(i,!1)}`)}),s.length>0?`${e}(${s.join("//")})`:e}{const e=function bQ(n,t){let e=[];return Object.entries(n.children).forEach(([s,r])=>{s===ct&&(e=e.concat(t(r,s)))}),Object.entries(n.children).forEach(([s,r])=>{s!==ct&&(e=e.concat(t(r,s)))}),e}(n,(s,r)=>r===ct?[Uh(n.children[ct],!1)]:[`${r}:${Uh(s,!1)}`]);return 1===Object.keys(n.children).length&&null!=n.children[ct]?`${ey(n)}/${e[0]}`:`${ey(n)}/(${e.join("//")})`}}function A$(n){return encodeURIComponent(n).replace(/%40/g,"@").replace(/%3A/gi,":").replace(/%24/g,"$").replace(/%2C/gi,",")}function ty(n){return A$(n).replace(/%3B/gi,";")}function mC(n){return A$(n).replace(/\(/g,"%28").replace(/\)/g,"%29").replace(/%26/gi,"&")}function ny(n){return decodeURIComponent(n)}function R$(n){return ny(n.replace(/\+/g,"%20"))}function M$(n){return`${mC(n.path)}${function wQ(n){return Object.keys(n).map(t=>`;${mC(t)}=${mC(n[t])}`).join("")}(n.parameters)}`}const CQ=/^[^\/()?;#]+/;function gC(n){const t=n.match(CQ);return t?t[0]:""}const SQ=/^[^\/()?;=#]+/,EQ=/^[^=?&#]+/,TQ=/^[^&#]+/;class kQ{constructor(t){this.url=t,this.remaining=t}parseRootSegment(){return this.consumeOptional("/"),""===this.remaining||this.peekStartsWith("?")||this.peekStartsWith("#")?new qt([],{}):new qt([],this.parseChildren())}parseQueryParams(){const t={};if(this.consumeOptional("?"))do{this.parseQueryParam(t)}while(this.consumeOptional("&"));return t}parseFragment(){return this.consumeOptional("#")?decodeURIComponent(this.remaining):null}parseChildren(){if(""===this.remaining)return{};this.consumeOptional("/");const t=[];for(this.peekStartsWith("(")||t.push(this.parseSegment());this.peekStartsWith("/")&&!this.peekStartsWith("//")&&!this.peekStartsWith("/(");)this.capture("/"),t.push(this.parseSegment());let e={};this.peekStartsWith("/(")&&(this.capture("/"),e=this.parseParens(!0));let s={};return this.peekStartsWith("(")&&(s=this.parseParens(!1)),(t.length>0||Object.keys(e).length>0)&&(s[ct]=new qt(t,e)),s}parseSegment(){const t=gC(this.remaining);if(""===t&&this.peekStartsWith(";"))throw new ee(4009,!1);return this.capture(t),new Bh(ny(t),this.parseMatrixParams())}parseMatrixParams(){const t={};for(;this.consumeOptional(";");)this.parseParam(t);return t}parseParam(t){const e=function IQ(n){const t=n.match(SQ);return t?t[0]:""}(this.remaining);if(!e)return;this.capture(e);let s="";if(this.consumeOptional("=")){const r=gC(this.remaining);r&&(s=r,this.capture(s))}t[ny(e)]=ny(s)}parseQueryParam(t){const e=function DQ(n){const t=n.match(EQ);return t?t[0]:""}(this.remaining);if(!e)return;this.capture(e);let s="";if(this.consumeOptional("=")){const o=function NQ(n){const t=n.match(TQ);return t?t[0]:""}(this.remaining);o&&(s=o,this.capture(s))}const r=R$(e),i=R$(s);if(t.hasOwnProperty(r)){let o=t[r];Array.isArray(o)||(o=[o],t[r]=o),o.push(i)}else t[r]=i}parseParens(t){const e={};for(this.capture("(");!this.consumeOptional(")")&&this.remaining.length>0;){const s=gC(this.remaining),r=this.remaining[s.length];if("/"!==r&&")"!==r&&";"!==r)throw new ee(4010,!1);let i;s.indexOf(":")>-1?(i=s.slice(0,s.indexOf(":")),this.capture(i),this.capture(":")):t&&(i=ct);const o=this.parseChildren();e[i]=1===Object.keys(o).length?o[ct]:new qt([],o),this.consumeOptional("//")}return e}peekStartsWith(t){return this.remaining.startsWith(t)}consumeOptional(t){return!!this.peekStartsWith(t)&&(this.remaining=this.remaining.substring(t.length),!0)}capture(t){if(!this.consumeOptional(t))throw new ee(4011,!1)}}function F$(n){return n.segments.length>0?new qt([],{[ct]:n}):n}function O$(n){const t={};for(const s of Object.keys(n.children)){const i=O$(n.children[s]);if(s===ct&&0===i.segments.length&&i.hasChildren())for(const[o,a]of Object.entries(i.children))t[o]=a;else(i.segments.length>0||i.hasChildren())&&(t[s]=i)}return function AQ(n){if(1===n.numberOfChildren&&n.children[ct]){const t=n.children[ct];return new qt(n.segments.concat(t.segments),t.children)}return n}(new qt(n.segments,t))}function Kl(n){return n instanceof Nc}function $$(n){let t;const r=F$(function e(i){const o={};for(const l of i.children){const u=e(l);o[l.outlet]=u}const a=new qt(i.url,o);return i===n&&(t=a),a}(n.root));return t??r}function P$(n,t,e,s){let r=n;for(;r.parent;)r=r.parent;if(0===t.length)return yC(r,r,r,e,s);const i=function MQ(n){if("string"==typeof n[0]&&1===n.length&&"/"===n[0])return new V$(!0,0,n);let t=0,e=!1;const s=n.reduce((r,i,o)=>{if("object"==typeof i&&null!=i){if(i.outlets){const a={};return Object.entries(i.outlets).forEach(([l,u])=>{a[l]="string"==typeof u?u.split("/"):u}),[...r,{outlets:a}]}if(i.segmentPath)return[...r,i.segmentPath]}return"string"!=typeof i?[...r,i]:0===o?(i.split("/").forEach((a,l)=>{0==l&&"."===a||(0==l&&""===a?e=!0:".."===a?t++:""!=a&&r.push(a))}),r):[...r,i]},[]);return new V$(e,t,s)}(t);if(i.toRoot())return yC(r,r,new qt([],{}),e,s);const o=function FQ(n,t,e){if(n.isAbsolute)return new ry(t,!0,0);if(!e)return new ry(t,!1,NaN);if(null===e.parent)return new ry(e,!0,0);const s=sy(n.commands[0])?0:1;return function OQ(n,t,e){let s=n,r=t,i=e;for(;i>r;){if(i-=r,s=s.parent,!s)throw new ee(4005,!1);r=s.segments.length}return new ry(s,!1,r-i)}(e,e.segments.length-1+s,n.numberOfDoubleDots)}(i,r,n),a=o.processChildren?Gh(o.segmentGroup,o.index,i.commands):B$(o.segmentGroup,o.index,i.commands);return yC(r,o.segmentGroup,a,e,s)}function sy(n){return"object"==typeof n&&null!=n&&!n.outlets&&!n.segmentPath}function Wh(n){return"object"==typeof n&&null!=n&&n.outlets}function yC(n,t,e,s,r){let o,i={};s&&Object.entries(s).forEach(([l,u])=>{i[l]=Array.isArray(u)?u.map(c=>`${c}`):`${u}`}),o=n===t?e:L$(n,t,e);const a=F$(O$(o));return new Nc(a,i,r)}function L$(n,t,e){const s={};return Object.entries(n.children).forEach(([r,i])=>{s[r]=i===t?e:L$(i,t,e)}),new qt(n.segments,s)}class V${constructor(t,e,s){if(this.isAbsolute=t,this.numberOfDoubleDots=e,this.commands=s,t&&s.length>0&&sy(s[0]))throw new ee(4003,!1);const r=s.find(Wh);if(r&&r!==I$(s))throw new ee(4004,!1)}toRoot(){return this.isAbsolute&&1===this.commands.length&&"/"==this.commands[0]}}class ry{constructor(t,e,s){this.segmentGroup=t,this.processChildren=e,this.index=s}}function B$(n,t,e){if(n||(n=new qt([],{})),0===n.segments.length&&n.hasChildren())return Gh(n,t,e);const s=function PQ(n,t,e){let s=0,r=t;const i={match:!1,pathIndex:0,commandIndex:0};for(;r<n.segments.length;){if(s>=e.length)return i;const o=n.segments[r],a=e[s];if(Wh(a))break;const l=`${a}`,u=s<e.length-1?e[s+1]:null;if(r>0&&void 0===l)break;if(l&&u&&"object"==typeof u&&void 0===u.outlets){if(!U$(l,u,o))return i;s+=2}else{if(!U$(l,{},o))return i;s++}r++}return{match:!0,pathIndex:r,commandIndex:s}}(n,t,e),r=e.slice(s.commandIndex);if(s.match&&s.pathIndex<n.segments.length){const i=new qt(n.segments.slice(0,s.pathIndex),{});return i.children[ct]=new qt(n.segments.slice(s.pathIndex),n.children),Gh(i,0,r)}return s.match&&0===r.length?new qt(n.segments,{}):s.match&&!n.hasChildren()?bC(n,t,e):s.match?Gh(n,0,r):bC(n,t,e)}function Gh(n,t,e){if(0===e.length)return new qt(n.segments,{});{const s=function $Q(n){return Wh(n[0])?n[0].outlets:{[ct]:n}}(e),r={};if(!s[ct]&&n.children[ct]&&1===n.numberOfChildren&&0===n.children[ct].segments.length){const i=Gh(n.children[ct],t,e);return new qt(n.segments,i.children)}return Object.entries(s).forEach(([i,o])=>{"string"==typeof o&&(o=[o]),null!==o&&(r[i]=B$(n.children[i],t,o))}),Object.entries(n.children).forEach(([i,o])=>{void 0===s[i]&&(r[i]=o)}),new qt(n.segments,r)}}function bC(n,t,e){const s=n.segments.slice(0,t);let r=0;for(;r<e.length;){const i=e[r];if(Wh(i)){const l=LQ(i.outlets);return new qt(s,l)}if(0===r&&sy(e[0])){s.push(new Bh(n.segments[t].path,z$(e[0]))),r++;continue}const o=Wh(i)?i.outlets[ct]:`${i}`,a=r<e.length-1?e[r+1]:null;o&&a&&sy(a)?(s.push(new Bh(o,z$(a))),r+=2):(s.push(new Bh(o,{})),r++)}return new qt(s,{})}function LQ(n){const t={};return Object.entries(n).forEach(([e,s])=>{"string"==typeof s&&(s=[s]),null!==s&&(t[e]=bC(new qt([],{}),0,s))}),t}function z$(n){const t={};return Object.entries(n).forEach(([e,s])=>t[e]=`${s}`),t}function U$(n,t,e){return n==e.path&&mo(t,e.parameters)}const Hh="imperative";class go{constructor(t,e){this.id=t,this.url=e}}class vC extends go{constructor(t,e,s="imperative",r=null){super(t,e),this.type=0,this.navigationTrigger=s,this.restoredState=r}toString(){return`NavigationStart(id: ${this.id}, url: '${this.url}')`}}class Xl extends go{constructor(t,e,s){super(t,e),this.urlAfterRedirects=s,this.type=1}toString(){return`NavigationEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}')`}}class iy extends go{constructor(t,e,s,r){super(t,e),this.reason=s,this.code=r,this.type=2}toString(){return`NavigationCancel(id: ${this.id}, url: '${this.url}')`}}class jh extends go{constructor(t,e,s,r){super(t,e),this.reason=s,this.code=r,this.type=16}}class _C extends go{constructor(t,e,s,r){super(t,e),this.error=s,this.target=r,this.type=3}toString(){return`NavigationError(id: ${this.id}, url: '${this.url}', error: ${this.error})`}}class VQ extends go{constructor(t,e,s,r){super(t,e),this.urlAfterRedirects=s,this.state=r,this.type=4}toString(){return`RoutesRecognized(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`}}class BQ extends go{constructor(t,e,s,r){super(t,e),this.urlAfterRedirects=s,this.state=r,this.type=7}toString(){return`GuardsCheckStart(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`}}class zQ extends go{constructor(t,e,s,r,i){super(t,e),this.urlAfterRedirects=s,this.state=r,this.shouldActivate=i,this.type=8}toString(){return`GuardsCheckEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state}, shouldActivate: ${this.shouldActivate})`}}class UQ extends go{constructor(t,e,s,r){super(t,e),this.urlAfterRedirects=s,this.state=r,this.type=5}toString(){return`ResolveStart(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`}}class WQ extends go{constructor(t,e,s,r){super(t,e),this.urlAfterRedirects=s,this.state=r,this.type=6}toString(){return`ResolveEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`}}class GQ{constructor(t){this.route=t,this.type=9}toString(){return`RouteConfigLoadStart(path: ${this.route.path})`}}class HQ{constructor(t){this.route=t,this.type=10}toString(){return`RouteConfigLoadEnd(path: ${this.route.path})`}}class jQ{constructor(t){this.snapshot=t,this.type=11}toString(){return`ChildActivationStart(path: '${this.snapshot.routeConfig&&this.snapshot.routeConfig.path||""}')`}}class qQ{constructor(t){this.snapshot=t,this.type=12}toString(){return`ChildActivationEnd(path: '${this.snapshot.routeConfig&&this.snapshot.routeConfig.path||""}')`}}class KQ{constructor(t){this.snapshot=t,this.type=13}toString(){return`ActivationStart(path: '${this.snapshot.routeConfig&&this.snapshot.routeConfig.path||""}')`}}class XQ{constructor(t){this.snapshot=t,this.type=14}toString(){return`ActivationEnd(path: '${this.snapshot.routeConfig&&this.snapshot.routeConfig.path||""}')`}}class W${constructor(t,e,s){this.routerEvent=t,this.position=e,this.anchor=s,this.type=15}toString(){return`Scroll(anchor: '${this.anchor}', position: '${this.position?`${this.position[0]}, ${this.position[1]}`:null}')`}}class YQ{constructor(){this.outlet=null,this.route=null,this.injector=null,this.children=new qh,this.attachRef=null}}let qh=(()=>{class n{constructor(){this.contexts=new Map}onChildOutletCreated(e,s){const r=this.getOrCreateContext(e);r.outlet=s,this.contexts.set(e,r)}onChildOutletDestroyed(e){const s=this.getContext(e);s&&(s.outlet=null,s.attachRef=null)}onOutletDeactivated(){const e=this.contexts;return this.contexts=new Map,e}onOutletReAttached(e){this.contexts=e}getOrCreateContext(e){let s=this.getContext(e);return s||(s=new YQ,this.contexts.set(e,s)),s}getContext(e){return this.contexts.get(e)||null}}return n.\u0275fac=function(e){return new(e||n)},n.\u0275prov=Ve({token:n,factory:n.\u0275fac,providedIn:"root"}),n})();class G${constructor(t){this._root=t}get root(){return this._root.value}parent(t){const e=this.pathFromRoot(t);return e.length>1?e[e.length-2]:null}children(t){const e=wC(t,this._root);return e?e.children.map(s=>s.value):[]}firstChild(t){const e=wC(t,this._root);return e&&e.children.length>0?e.children[0].value:null}siblings(t){const e=xC(t,this._root);return e.length<2?[]:e[e.length-2].children.map(r=>r.value).filter(r=>r!==t)}pathFromRoot(t){return xC(t,this._root).map(e=>e.value)}}function wC(n,t){if(n===t.value)return t;for(const e of t.children){const s=wC(n,e);if(s)return s}return null}function xC(n,t){if(n===t.value)return[t];for(const e of t.children){const s=xC(n,e);if(s.length)return s.unshift(t),s}return[]}class na{constructor(t,e){this.value=t,this.children=e}toString(){return`TreeNode(${this.value})`}}function kc(n){const t={};return n&&n.children.forEach(e=>t[e.value.outlet]=e),t}class H$ extends G${constructor(t,e){super(t),this.snapshot=e,CC(this,t)}toString(){return this.snapshot.toString()}}function j$(n,t){const e=function ZQ(n,t){const o=new oy([],{},{},"",{},ct,t,null,{});return new K$("",new na(o,[]))}(0,t),s=new Vi([new Bh("",{})]),r=new Vi({}),i=new Vi({}),o=new Vi({}),a=new Vi(""),l=new Ac(s,r,o,a,i,ct,t,e.root);return l.snapshot=e.root,new H$(new na(l,[]),e)}class Ac{constructor(t,e,s,r,i,o,a,l){this.urlSubject=t,this.paramsSubject=e,this.queryParamsSubject=s,this.fragmentSubject=r,this.dataSubject=i,this.outlet=o,this.component=a,this._futureSnapshot=l,this.title=this.dataSubject?.pipe(Ht(u=>u[Vh]))??tt(void 0),this.url=t,this.params=e,this.queryParams=s,this.fragment=r,this.data=i}get routeConfig(){return this._futureSnapshot.routeConfig}get root(){return this._routerState.root}get parent(){return this._routerState.parent(this)}get firstChild(){return this._routerState.firstChild(this)}get children(){return this._routerState.children(this)}get pathFromRoot(){return this._routerState.pathFromRoot(this)}get paramMap(){return this._paramMap||(this._paramMap=this.params.pipe(Ht(t=>Tc(t)))),this._paramMap}get queryParamMap(){return this._queryParamMap||(this._queryParamMap=this.queryParams.pipe(Ht(t=>Tc(t)))),this._queryParamMap}toString(){return this.snapshot?this.snapshot.toString():`Future(${this._futureSnapshot})`}}function q$(n,t="emptyOnly"){const e=n.pathFromRoot;let s=0;if("always"!==t)for(s=e.length-1;s>=1;){const r=e[s],i=e[s-1];if(r.routeConfig&&""===r.routeConfig.path)s--;else{if(i.component)break;s--}}return function QQ(n){return n.reduce((t,e)=>({params:{...t.params,...e.params},data:{...t.data,...e.data},resolve:{...e.data,...t.resolve,...e.routeConfig?.data,...e._resolvedData}}),{params:{},data:{},resolve:{}})}(e.slice(s))}class oy{get title(){return this.data?.[Vh]}constructor(t,e,s,r,i,o,a,l,u){this.url=t,this.params=e,this.queryParams=s,this.fragment=r,this.data=i,this.outlet=o,this.component=a,this.routeConfig=l,this._resolve=u}get root(){return this._routerState.root}get parent(){return this._routerState.parent(this)}get firstChild(){return this._routerState.firstChild(this)}get children(){return this._routerState.children(this)}get pathFromRoot(){return this._routerState.pathFromRoot(this)}get paramMap(){return this._paramMap||(this._paramMap=Tc(this.params)),this._paramMap}get queryParamMap(){return this._queryParamMap||(this._queryParamMap=Tc(this.queryParams)),this._queryParamMap}toString(){return`Route(url:'${this.url.map(s=>s.toString()).join("/")}', path:'${this.routeConfig?this.routeConfig.path:""}')`}}class K$ extends G${constructor(t,e){super(e),this.url=t,CC(this,e)}toString(){return X$(this._root)}}function CC(n,t){t.value._routerState=n,t.children.forEach(e=>CC(n,e))}function X$(n){const t=n.children.length>0?` { ${n.children.map(X$).join(", ")} } `:"";return`${n.value}${t}`}function SC(n){if(n.snapshot){const t=n.snapshot,e=n._futureSnapshot;n.snapshot=e,mo(t.queryParams,e.queryParams)||n.queryParamsSubject.next(e.queryParams),t.fragment!==e.fragment&&n.fragmentSubject.next(e.fragment),mo(t.params,e.params)||n.paramsSubject.next(e.params),function fQ(n,t){if(n.length!==t.length)return!1;for(let e=0;e<n.length;++e)if(!mo(n[e],t[e]))return!1;return!0}(t.url,e.url)||n.urlSubject.next(e.url),mo(t.data,e.data)||n.dataSubject.next(e.data)}else n.snapshot=n._futureSnapshot,n.dataSubject.next(n._futureSnapshot.data)}function IC(n,t){const e=mo(n.params,t.params)&&function yQ(n,t){return ql(n,t)&&n.every((e,s)=>mo(e.parameters,t[s].parameters))}(n.url,t.url);return e&&!(!n.parent!=!t.parent)&&(!n.parent||IC(n.parent,t.parent))}let Y$=(()=>{class n{constructor(){this.activated=null,this._activatedRoute=null,this.name=ct,this.activateEvents=new un,this.deactivateEvents=new un,this.attachEvents=new un,this.detachEvents=new un,this.parentContexts=Fe(qh),this.location=Fe(Oi),this.changeDetector=Fe(Na),this.environmentInjector=Fe(Go),this.inputBinder=Fe(ay,{optional:!0}),this.supportsBindingToComponentInputs=!0}get activatedComponentRef(){return this.activated}ngOnChanges(e){if(e.name){const{firstChange:s,previousValue:r}=e.name;if(s)return;this.isTrackedInParentContexts(r)&&(this.deactivate(),this.parentContexts.onChildOutletDestroyed(r)),this.initializeOutletWithName()}}ngOnDestroy(){this.isTrackedInParentContexts(this.name)&&this.parentContexts.onChildOutletDestroyed(this.name),this.inputBinder?.unsubscribeFromRouteData(this)}isTrackedInParentContexts(e){return this.parentContexts.getContext(e)?.outlet===this}ngOnInit(){this.initializeOutletWithName()}initializeOutletWithName(){if(this.parentContexts.onChildOutletCreated(this.name,this),this.activated)return;const e=this.parentContexts.getContext(this.name);e?.route&&(e.attachRef?this.attach(e.attachRef,e.route):this.activateWith(e.route,e.injector))}get isActivated(){return!!this.activated}get component(){if(!this.activated)throw new ee(4012,!1);return this.activated.instance}get activatedRoute(){if(!this.activated)throw new ee(4012,!1);return this._activatedRoute}get activatedRouteData(){return this._activatedRoute?this._activatedRoute.snapshot.data:{}}detach(){if(!this.activated)throw new ee(4012,!1);this.location.detach();const e=this.activated;return this.activated=null,this._activatedRoute=null,this.detachEvents.emit(e.instance),e}attach(e,s){this.activated=e,this._activatedRoute=s,this.location.insert(e.hostView),this.inputBinder?.bindActivatedRouteToOutletComponent(this),this.attachEvents.emit(e.instance)}deactivate(){if(this.activated){const e=this.component;this.activated.destroy(),this.activated=null,this._activatedRoute=null,this.deactivateEvents.emit(e)}}activateWith(e,s){if(this.isActivated)throw new ee(4013,!1);this._activatedRoute=e;const r=this.location,o=e.snapshot.component,a=this.parentContexts.getOrCreateContext(this.name).children,l=new JQ(e,a,r.injector);this.activated=r.createComponent(o,{index:r.length,injector:l,environmentInjector:s??this.environmentInjector}),this.changeDetector.markForCheck(),this.inputBinder?.bindActivatedRouteToOutletComponent(this),this.activateEvents.emit(this.activated.instance)}}return n.\u0275fac=function(e){return new(e||n)},n.\u0275dir=qe({type:n,selectors:[["router-outlet"]],inputs:{name:"name"},outputs:{activateEvents:"activate",deactivateEvents:"deactivate",attachEvents:"attach",detachEvents:"detach"},exportAs:["outlet"],standalone:!0,features:[ii]}),n})();class JQ{constructor(t,e,s){this.route=t,this.childContexts=e,this.parent=s}get(t,e){return t===Ac?this.route:t===qh?this.childContexts:this.parent.get(t,e)}}const ay=new we("");let Z$=(()=>{class n{constructor(){this.outletDataSubscriptions=new Map}bindActivatedRouteToOutletComponent(e){this.unsubscribeFromRouteData(e),this.subscribeToRouteData(e)}unsubscribeFromRouteData(e){this.outletDataSubscriptions.get(e)?.unsubscribe(),this.outletDataSubscriptions.delete(e)}subscribeToRouteData(e){const{activatedRoute:s}=e,r=Xg([s.queryParams,s.params,s.data]).pipe(ea(([i,o,a],l)=>(a={...i,...o,...a},0===l?tt(a):Promise.resolve(a)))).subscribe(i=>{if(!e.isActivated||!e.activatedComponentRef||e.activatedRoute!==s||null===s.component)return void this.unsubscribeFromRouteData(e);const o=function x7(n){const t=Lt(n);if(!t)return null;const e=new mh(t);return{get selector(){return e.selector},get type(){return e.componentType},get inputs(){return e.inputs},get outputs(){return e.outputs},get ngContentSelectors(){return e.ngContentSelectors},get isStandalone(){return t.standalone}}}(s.component);if(o)for(const{templateName:a}of o.inputs)e.activatedComponentRef.setInput(a,i[a]);else this.unsubscribeFromRouteData(e)});this.outletDataSubscriptions.set(e,r)}}return n.\u0275fac=function(e){return new(e||n)},n.\u0275prov=Ve({token:n,factory:n.\u0275fac}),n})();function Kh(n,t,e){if(e&&n.shouldReuseRoute(t.value,e.value.snapshot)){const s=e.value;s._futureSnapshot=t.value;const r=function tJ(n,t,e){return t.children.map(s=>{for(const r of e.children)if(n.shouldReuseRoute(s.value,r.value.snapshot))return Kh(n,s,r);return Kh(n,s)})}(n,t,e);return new na(s,r)}{if(n.shouldAttach(t.value)){const i=n.retrieve(t.value);if(null!==i){const o=i.route;return o.value._futureSnapshot=t.value,o.children=t.children.map(a=>Kh(n,a)),o}}const s=function nJ(n){return new Ac(new Vi(n.url),new Vi(n.params),new Vi(n.queryParams),new Vi(n.fragment),new Vi(n.data),n.outlet,n.component,n)}(t.value),r=t.children.map(i=>Kh(n,i));return new na(s,r)}}const EC="ngNavigationCancelingError";function Q$(n,t){const{redirectTo:e,navigationBehaviorOptions:s}=Kl(t)?{redirectTo:t,navigationBehaviorOptions:void 0}:t,r=J$(!1,0,t);return r.url=e,r.navigationBehaviorOptions=s,r}function J$(n,t,e){const s=new Error("NavigationCancelingError: "+(n||""));return s[EC]=!0,s.cancellationCode=t,e&&(s.url=e),s}function e2(n){return t2(n)&&Kl(n.url)}function t2(n){return n&&n[EC]}let n2=(()=>{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275cmp=Vd({type:n,selectors:[["ng-component"]],standalone:!0,features:[ZM],decls:1,vars:0,template:function(e,s){1&e&&Ko(0,"router-outlet")},dependencies:[Y$],encapsulation:2}),n})();function DC(n){const t=n.children&&n.children.map(DC),e=t?{...n,children:t}:{...n};return!e.component&&!e.loadComponent&&(t||e.loadChildren)&&e.outlet&&e.outlet!==ct&&(e.component=n2),e}function Bi(n){return n.outlet||ct}function Xh(n){if(!n)return null;if(n.routeConfig?._injector)return n.routeConfig._injector;for(let t=n.parent;t;t=t.parent){const e=t.routeConfig;if(e?._loadedInjector)return e._loadedInjector;if(e?._injector)return e._injector}return null}class uJ{constructor(t,e,s,r,i){this.routeReuseStrategy=t,this.futureState=e,this.currState=s,this.forwardEvent=r,this.inputBindingEnabled=i}activate(t){const e=this.futureState._root,s=this.currState?this.currState._root:null;this.deactivateChildRoutes(e,s,t),SC(this.futureState.root),this.activateChildRoutes(e,s,t)}deactivateChildRoutes(t,e,s){const r=kc(e);t.children.forEach(i=>{const o=i.value.outlet;this.deactivateRoutes(i,r[o],s),delete r[o]}),Object.values(r).forEach(i=>{this.deactivateRouteAndItsChildren(i,s)})}deactivateRoutes(t,e,s){const r=t.value,i=e?e.value:null;if(r===i)if(r.component){const o=s.getContext(r.outlet);o&&this.deactivateChildRoutes(t,e,o.children)}else this.deactivateChildRoutes(t,e,s);else i&&this.deactivateRouteAndItsChildren(e,s)}deactivateRouteAndItsChildren(t,e){t.value.component&&this.routeReuseStrategy.shouldDetach(t.value.snapshot)?this.detachAndStoreRouteSubtree(t,e):this.deactivateRouteAndOutlet(t,e)}detachAndStoreRouteSubtree(t,e){const s=e.getContext(t.value.outlet),r=s&&t.value.component?s.children:e,i=kc(t);for(const o of Object.keys(i))this.deactivateRouteAndItsChildren(i[o],r);if(s&&s.outlet){const o=s.outlet.detach(),a=s.children.onOutletDeactivated();this.routeReuseStrategy.store(t.value.snapshot,{componentRef:o,route:t,contexts:a})}}deactivateRouteAndOutlet(t,e){const s=e.getContext(t.value.outlet),r=s&&t.value.component?s.children:e,i=kc(t);for(const o of Object.keys(i))this.deactivateRouteAndItsChildren(i[o],r);s&&(s.outlet&&(s.outlet.deactivate(),s.children.onOutletDeactivated()),s.attachRef=null,s.route=null)}activateChildRoutes(t,e,s){const r=kc(e);t.children.forEach(i=>{this.activateRoutes(i,r[i.value.outlet],s),this.forwardEvent(new XQ(i.value.snapshot))}),t.children.length&&this.forwardEvent(new qQ(t.value.snapshot))}activateRoutes(t,e,s){const r=t.value,i=e?e.value:null;if(SC(r),r===i)if(r.component){const o=s.getOrCreateContext(r.outlet);this.activateChildRoutes(t,e,o.children)}else this.activateChildRoutes(t,e,s);else if(r.component){const o=s.getOrCreateContext(r.outlet);if(this.routeReuseStrategy.shouldAttach(r.snapshot)){const a=this.routeReuseStrategy.retrieve(r.snapshot);this.routeReuseStrategy.store(r.snapshot,null),o.children.onOutletReAttached(a.contexts),o.attachRef=a.componentRef,o.route=a.route.value,o.outlet&&o.outlet.attach(a.componentRef,a.route.value),SC(a.route.value),this.activateChildRoutes(t,null,o.children)}else{const a=Xh(r.snapshot);o.attachRef=null,o.route=r,o.injector=a,o.outlet&&o.outlet.activateWith(r,o.injector),this.activateChildRoutes(t,null,o.children)}}else this.activateChildRoutes(t,null,s)}}class s2{constructor(t){this.path=t,this.route=this.path[this.path.length-1]}}class ly{constructor(t,e){this.component=t,this.route=e}}function cJ(n,t,e){const s=n._root;return Yh(s,t?t._root:null,e,[s.value])}function Rc(n,t){const e=Symbol(),s=t.get(n,e);return s===e?"function"!=typeof n||function iH(n){return null!==dm(n)}(n)?t.get(n):n:s}function Yh(n,t,e,s,r={canDeactivateChecks:[],canActivateChecks:[]}){const i=kc(t);return n.children.forEach(o=>{(function hJ(n,t,e,s,r={canDeactivateChecks:[],canActivateChecks:[]}){const i=n.value,o=t?t.value:null,a=e?e.getContext(n.value.outlet):null;if(o&&i.routeConfig===o.routeConfig){const l=function fJ(n,t,e){if("function"==typeof e)return e(n,t);switch(e){case"pathParamsChange":return!ql(n.url,t.url);case"pathParamsOrQueryParamsChange":return!ql(n.url,t.url)||!mo(n.queryParams,t.queryParams);case"always":return!0;case"paramsOrQueryParamsChange":return!IC(n,t)||!mo(n.queryParams,t.queryParams);default:return!IC(n,t)}}(o,i,i.routeConfig.runGuardsAndResolvers);l?r.canActivateChecks.push(new s2(s)):(i.data=o.data,i._resolvedData=o._resolvedData),Yh(n,t,i.component?a?a.children:null:e,s,r),l&&a&&a.outlet&&a.outlet.isActivated&&r.canDeactivateChecks.push(new ly(a.outlet.component,o))}else o&&Zh(t,a,r),r.canActivateChecks.push(new s2(s)),Yh(n,null,i.component?a?a.children:null:e,s,r)})(o,i[o.value.outlet],e,s.concat([o.value]),r),delete i[o.value.outlet]}),Object.entries(i).forEach(([o,a])=>Zh(a,e.getContext(o),r)),r}function Zh(n,t,e){const s=kc(n),r=n.value;Object.entries(s).forEach(([i,o])=>{Zh(o,r.component?t?t.children.getContext(i):null:t,e)}),e.canDeactivateChecks.push(new ly(r.component&&t&&t.outlet&&t.outlet.isActivated?t.outlet.component:null,r))}function Qh(n){return"function"==typeof n}function r2(n){return n instanceof Yg||"EmptyError"===n?.name}const uy=Symbol("INITIAL_VALUE");function Mc(){return ea(n=>Xg(n.map(t=>t.pipe(Gl(1),x$(uy)))).pipe(Ht(t=>{for(const e of t)if(!0!==e){if(e===uy)return uy;if(!1===e||e instanceof Nc)return e}return!0}),ta(t=>t!==uy),Gl(1)))}function i2(n){return function SG(...n){return RN(n)}(rr(t=>{if(Kl(t))throw Q$(0,t)}),Ht(t=>!0===t))}class cy{constructor(t){this.segmentGroup=t||null}}class o2{constructor(t){this.urlTree=t}}function Fc(n){return Ph(new cy(n))}function a2(n){return Ph(new o2(n))}class MJ{constructor(t,e){this.urlSerializer=t,this.urlTree=e}noMatchError(t){return new ee(4002,!1)}lineralizeSegments(t,e){let s=[],r=e.root;for(;;){if(s=s.concat(r.segments),0===r.numberOfChildren)return tt(s);if(r.numberOfChildren>1||!r.children[ct])return Ph(new ee(4e3,!1));r=r.children[ct]}}applyRedirectCommands(t,e,s){return this.applyRedirectCreateUrlTree(e,this.urlSerializer.parse(e),t,s)}applyRedirectCreateUrlTree(t,e,s,r){const i=this.createSegmentGroup(t,e.root,s,r);return new Nc(i,this.createQueryParams(e.queryParams,this.urlTree.queryParams),e.fragment)}createQueryParams(t,e){const s={};return Object.entries(t).forEach(([r,i])=>{if("string"==typeof i&&i.startsWith(":")){const a=i.substring(1);s[r]=e[a]}else s[r]=i}),s}createSegmentGroup(t,e,s,r){const i=this.createSegments(t,e.segments,s,r);let o={};return Object.entries(e.children).forEach(([a,l])=>{o[a]=this.createSegmentGroup(t,l,s,r)}),new qt(i,o)}createSegments(t,e,s,r){return e.map(i=>i.path.startsWith(":")?this.findPosParam(t,i,r):this.findOrReturn(i,s))}findPosParam(t,e,s){const r=s[e.path.substring(1)];if(!r)throw new ee(4001,!1);return r}findOrReturn(t,e){let s=0;for(const r of e){if(r.path===t.path)return e.splice(s),r;s++}return t}}const TC={matched:!1,consumedSegments:[],remainingSegments:[],parameters:{},positionalParamSegments:{}};function FJ(n,t,e,s,r){const i=NC(n,t,e);return i.matched?(s=function sJ(n,t){return n.providers&&!n._injector&&(n._injector=t0(n.providers,t,`Route: ${n.path}`)),n._injector??t}(t,s),function kJ(n,t,e,s){const r=t.canMatch;return r&&0!==r.length?tt(r.map(o=>{const a=Rc(o,n);return Ra(function vJ(n){return n&&Qh(n.canMatch)}(a)?a.canMatch(t,e):n.runInContext(()=>a(t,e)))})).pipe(Mc(),i2()):tt(!0)}(s,t,e).pipe(Ht(o=>!0===o?i:{...TC}))):tt(i)}function NC(n,t,e){if(""===t.path)return"full"===t.pathMatch&&(n.hasChildren()||e.length>0)?{...TC}:{matched:!0,consumedSegments:[],remainingSegments:e,parameters:{},positionalParamSegments:{}};const r=(t.matcher||hQ)(e,n,t);if(!r)return{...TC};const i={};Object.entries(r.posParams??{}).forEach(([a,l])=>{i[a]=l.path});const o=r.consumed.length>0?{...i,...r.consumed[r.consumed.length-1].parameters}:i;return{matched:!0,consumedSegments:r.consumed,remainingSegments:e.slice(r.consumed.length),parameters:o,positionalParamSegments:r.posParams??{}}}function l2(n,t,e,s){return e.length>0&&function PJ(n,t,e){return e.some(s=>dy(n,t,s)&&Bi(s)!==ct)}(n,e,s)?{segmentGroup:new qt(t,$J(s,new qt(e,n.children))),slicedSegments:[]}:0===e.length&&function LJ(n,t,e){return e.some(s=>dy(n,t,s))}(n,e,s)?{segmentGroup:new qt(n.segments,OJ(n,0,e,s,n.children)),slicedSegments:e}:{segmentGroup:new qt(n.segments,n.children),slicedSegments:e}}function OJ(n,t,e,s,r){const i={};for(const o of s)if(dy(n,e,o)&&!r[Bi(o)]){const a=new qt([],{});i[Bi(o)]=a}return{...r,...i}}function $J(n,t){const e={};e[ct]=t;for(const s of n)if(""===s.path&&Bi(s)!==ct){const r=new qt([],{});e[Bi(s)]=r}return e}function dy(n,t,e){return(!(n.hasChildren()||t.length>0)||"full"!==e.pathMatch)&&""===e.path}class UJ{constructor(t,e,s,r,i,o,a){this.injector=t,this.configLoader=e,this.rootComponentType=s,this.config=r,this.urlTree=i,this.paramsInheritanceStrategy=o,this.urlSerializer=a,this.allowRedirects=!0,this.applyRedirects=new MJ(this.urlSerializer,this.urlTree)}noMatchError(t){return new ee(4002,!1)}recognize(){const t=l2(this.urlTree.root,[],[],this.config).segmentGroup;return this.processSegmentGroup(this.injector,this.config,t,ct).pipe(jl(e=>{if(e instanceof o2)return this.allowRedirects=!1,this.urlTree=e.urlTree,this.match(e.urlTree);throw e instanceof cy?this.noMatchError(e):e}),Ht(e=>{const s=new oy([],Object.freeze({}),Object.freeze({...this.urlTree.queryParams}),this.urlTree.fragment,{},ct,this.rootComponentType,null,{}),r=new na(s,e),i=new K$("",r),o=function RQ(n,t,e=null,s=null){return P$($$(n),t,e,s)}(s,[],this.urlTree.queryParams,this.urlTree.fragment);return o.queryParams=this.urlTree.queryParams,i.url=this.urlSerializer.serialize(o),this.inheritParamsAndData(i._root),{state:i,tree:o}}))}match(t){return this.processSegmentGroup(this.injector,this.config,t.root,ct).pipe(jl(s=>{throw s instanceof cy?this.noMatchError(s):s}))}inheritParamsAndData(t){const e=t.value,s=q$(e,this.paramsInheritanceStrategy);e.params=Object.freeze(s.params),e.data=Object.freeze(s.data),t.children.forEach(r=>this.inheritParamsAndData(r))}processSegmentGroup(t,e,s,r){return 0===s.segments.length&&s.hasChildren()?this.processChildren(t,e,s):this.processSegment(t,e,s,s.segments,r,!0)}processChildren(t,e,s){const r=[];for(const i of Object.keys(s.children))"primary"===i?r.unshift(i):r.push(i);return Cs(r).pipe(Lh(i=>{const o=s.children[i],a=function aJ(n,t){const e=n.filter(s=>Bi(s)===t);return e.push(...n.filter(s=>Bi(s)!==t)),e}(e,i);return this.processSegmentGroup(t,a,o,i)}),function lQ(n,t){return ds(function aQ(n,t,e,s,r){return(i,o)=>{let a=e,l=t,u=0;i.subscribe(Xn(o,c=>{const d=u++;l=a?n(l,c,d):(a=!0,c),s&&o.next(l)},r&&(()=>{a&&o.next(l),o.complete()})))}}(n,t,arguments.length>=2,!0))}((i,o)=>(i.push(...o),i)),Qg(null),function uQ(n,t){const e=arguments.length>=2;return s=>s.pipe(n?ta((r,i)=>n(r,i,s)):El,hC(1),e?Qg(t):C$(()=>new Yg))}(),Os(i=>{if(null===i)return Fc(s);const o=u2(i);return function WJ(n){n.sort((t,e)=>t.value.outlet===ct?-1:e.value.outlet===ct?1:t.value.outlet.localeCompare(e.value.outlet))}(o),tt(o)}))}processSegment(t,e,s,r,i,o){return Cs(e).pipe(Lh(a=>this.processSegmentAgainstRoute(a._injector??t,e,a,s,r,i,o).pipe(jl(l=>{if(l instanceof cy)return tt(null);throw l}))),Hl(a=>!!a),jl(a=>{if(r2(a))return function BJ(n,t,e){return 0===t.length&&!n.children[e]}(s,r,i)?tt([]):Fc(s);throw a}))}processSegmentAgainstRoute(t,e,s,r,i,o,a){return function VJ(n,t,e,s){return!!(Bi(n)===s||s!==ct&&dy(t,e,n))&&("**"===n.path||NC(t,n,e).matched)}(s,r,i,o)?void 0===s.redirectTo?this.matchSegmentAgainstRoute(t,r,s,i,o,a):a&&this.allowRedirects?this.expandSegmentAgainstRouteUsingRedirect(t,r,e,s,i,o):Fc(r):Fc(r)}expandSegmentAgainstRouteUsingRedirect(t,e,s,r,i,o){return"**"===r.path?this.expandWildCardWithParamsAgainstRouteUsingRedirect(t,s,r,o):this.expandRegularSegmentAgainstRouteUsingRedirect(t,e,s,r,i,o)}expandWildCardWithParamsAgainstRouteUsingRedirect(t,e,s,r){const i=this.applyRedirects.applyRedirectCommands([],s.redirectTo,{});return s.redirectTo.startsWith("/")?a2(i):this.applyRedirects.lineralizeSegments(s,i).pipe(Os(o=>{const a=new qt(o,{});return this.processSegment(t,e,a,o,r,!1)}))}expandRegularSegmentAgainstRouteUsingRedirect(t,e,s,r,i,o){const{matched:a,consumedSegments:l,remainingSegments:u,positionalParamSegments:c}=NC(e,r,i);if(!a)return Fc(e);const d=this.applyRedirects.applyRedirectCommands(l,r.redirectTo,c);return r.redirectTo.startsWith("/")?a2(d):this.applyRedirects.lineralizeSegments(r,d).pipe(Os(h=>this.processSegment(t,s,e,h.concat(u),o,!1)))}matchSegmentAgainstRoute(t,e,s,r,i,o){let a;if("**"===s.path){const l=r.length>0?I$(r).parameters:{};a=tt({snapshot:new oy(r,l,Object.freeze({...this.urlTree.queryParams}),this.urlTree.fragment,c2(s),Bi(s),s.component??s._loadedComponent??null,s,d2(s)),consumedSegments:[],remainingSegments:[]}),e.children={}}else a=FJ(e,s,r,t).pipe(Ht(({matched:l,consumedSegments:u,remainingSegments:c,parameters:d})=>l?{snapshot:new oy(u,d,Object.freeze({...this.urlTree.queryParams}),this.urlTree.fragment,c2(s),Bi(s),s.component??s._loadedComponent??null,s,d2(s)),consumedSegments:u,remainingSegments:c}:null));return a.pipe(ea(l=>null===l?Fc(e):this.getChildConfig(t=s._injector??t,s,r).pipe(ea(({routes:u})=>{const c=s._loadedInjector??t,{snapshot:d,consumedSegments:h,remainingSegments:f}=l,{segmentGroup:p,slicedSegments:g}=l2(e,h,f,u);if(0===g.length&&p.hasChildren())return this.processChildren(c,u,p).pipe(Ht(y=>null===y?null:[new na(d,y)]));if(0===u.length&&0===g.length)return tt([new na(d,[])]);const m=Bi(s)===i;return this.processSegment(c,u,p,g,m?ct:i,!0).pipe(Ht(y=>[new na(d,y)]))}))))}getChildConfig(t,e,s){return e.children?tt({routes:e.children,injector:t}):e.loadChildren?void 0!==e._loadedRoutes?tt({routes:e._loadedRoutes,injector:e._loadedInjector}):function NJ(n,t,e,s){const r=t.canLoad;return void 0===r||0===r.length?tt(!0):tt(r.map(o=>{const a=Rc(o,n);return Ra(function mJ(n){return n&&Qh(n.canLoad)}(a)?a.canLoad(t,e):n.runInContext(()=>a(t,e)))})).pipe(Mc(),i2())}(t,e,s).pipe(Os(r=>r?this.configLoader.loadChildren(t,e).pipe(rr(i=>{e._loadedRoutes=i.routes,e._loadedInjector=i.injector})):function RJ(n){return Ph(J$(!1,3))}())):tt({routes:[],injector:t})}}function GJ(n){const t=n.value.routeConfig;return t&&""===t.path}function u2(n){const t=[],e=new Set;for(const s of n){if(!GJ(s)){t.push(s);continue}const r=t.find(i=>s.value.routeConfig===i.value.routeConfig);void 0!==r?(r.children.push(...s.children),e.add(r)):t.push(s)}for(const s of e){const r=u2(s.children);t.push(new na(s.value,r))}return t.filter(s=>!e.has(s))}function c2(n){return n.data||{}}function d2(n){return n.resolve||{}}function h2(n){return"string"==typeof n.title||null===n.title}function kC(n){return ea(t=>{const e=n(t);return e?Cs(e).pipe(Ht(()=>t)):tt(t)})}const Oc=new we("ROUTES");let AC=(()=>{class n{constructor(){this.componentLoaders=new WeakMap,this.childrenLoaders=new WeakMap,this.compiler=Fe(VF)}loadComponent(e){if(this.componentLoaders.get(e))return this.componentLoaders.get(e);if(e._loadedComponent)return tt(e._loadedComponent);this.onLoadStartListener&&this.onLoadStartListener(e);const s=Ra(e.loadComponent()).pipe(Ht(f2),rr(i=>{this.onLoadEndListener&&this.onLoadEndListener(e),e._loadedComponent=i}),fC(()=>{this.componentLoaders.delete(e)})),r=new w$(s,()=>new Ti).pipe(dC());return this.componentLoaders.set(e,r),r}loadChildren(e,s){if(this.childrenLoaders.get(s))return this.childrenLoaders.get(s);if(s._loadedRoutes)return tt({routes:s._loadedRoutes,injector:s._loadedInjector});this.onLoadStartListener&&this.onLoadStartListener(s);const i=this.loadModuleFactoryOrRoutes(s.loadChildren).pipe(Ht(a=>{this.onLoadEndListener&&this.onLoadEndListener(s);let l,u;return Array.isArray(a)?u=a:(l=a.create(e).injector,u=l.get(Oc,[],je.Self|je.Optional).flat()),{routes:u.map(DC),injector:l}}),fC(()=>{this.childrenLoaders.delete(s)})),o=new w$(i,()=>new Ti).pipe(dC());return this.childrenLoaders.set(s,o),o}loadModuleFactoryOrRoutes(e){return Ra(e()).pipe(Ht(f2),Os(s=>s instanceof XM||Array.isArray(s)?tt(s):Cs(this.compiler.compileModuleAsync(s))))}}return n.\u0275fac=function(e){return new(e||n)},n.\u0275prov=Ve({token:n,factory:n.\u0275fac,providedIn:"root"}),n})();function f2(n){return function ZJ(n){return n&&"object"==typeof n&&"default"in n}(n)?n.default:n}let hy=(()=>{class n{get hasRequestedNavigation(){return 0!==this.navigationId}constructor(){this.currentNavigation=null,this.lastSuccessfulNavigation=null,this.events=new Ti,this.configLoader=Fe(AC),this.environmentInjector=Fe(Go),this.urlSerializer=Fe(zh),this.rootContexts=Fe(qh),this.inputBindingEnabled=null!==Fe(ay,{optional:!0}),this.navigationId=0,this.afterPreactivation=()=>tt(void 0),this.rootComponentType=null,this.configLoader.onLoadEndListener=r=>this.events.next(new HQ(r)),this.configLoader.onLoadStartListener=r=>this.events.next(new GQ(r))}complete(){this.transitions?.complete()}handleNavigationRequest(e){const s=++this.navigationId;this.transitions?.next({...this.transitions.value,...e,id:s})}setupNavigations(e){return this.transitions=new Vi({id:0,currentUrlTree:e.currentUrlTree,currentRawUrl:e.currentUrlTree,extractedUrl:e.urlHandlingStrategy.extract(e.currentUrlTree),urlAfterRedirects:e.urlHandlingStrategy.extract(e.currentUrlTree),rawUrl:e.currentUrlTree,extras:{},resolve:null,reject:null,promise:Promise.resolve(!0),source:Hh,restoredState:null,currentSnapshot:e.routerState.snapshot,targetSnapshot:null,currentRouterState:e.routerState,targetRouterState:null,guards:{canActivateChecks:[],canDeactivateChecks:[]},guardsResult:null}),this.transitions.pipe(ta(s=>0!==s.id),Ht(s=>({...s,extractedUrl:e.urlHandlingStrategy.extract(s.rawUrl)})),ea(s=>{let r=!1,i=!1;return tt(s).pipe(rr(o=>{this.currentNavigation={id:o.id,initialUrl:o.rawUrl,extractedUrl:o.extractedUrl,trigger:o.source,extras:o.extras,previousNavigation:this.lastSuccessfulNavigation?{...this.lastSuccessfulNavigation,previousNavigation:null}:null}}),ea(o=>{const a=e.browserUrlTree.toString(),l=!e.navigated||o.extractedUrl.toString()!==a||a!==e.currentUrlTree.toString();if(!l&&"reload"!==(o.extras.onSameUrlNavigation??e.onSameUrlNavigation)){const c="";return this.events.next(new jh(o.id,e.serializeUrl(s.rawUrl),c,0)),e.rawUrlTree=o.rawUrl,o.resolve(null),Ji}if(e.urlHandlingStrategy.shouldProcessUrl(o.rawUrl))return p2(o.source)&&(e.browserUrlTree=o.extractedUrl),tt(o).pipe(ea(c=>{const d=this.transitions?.getValue();return this.events.next(new vC(c.id,this.urlSerializer.serialize(c.extractedUrl),c.source,c.restoredState)),d!==this.transitions?.getValue()?Ji:Promise.resolve(c)}),function HJ(n,t,e,s,r,i){return Os(o=>function zJ(n,t,e,s,r,i,o="emptyOnly"){return new UJ(n,t,e,s,r,o,i).recognize()}(n,t,e,s,o.extractedUrl,r,i).pipe(Ht(({state:a,tree:l})=>({...o,targetSnapshot:a,urlAfterRedirects:l}))))}(this.environmentInjector,this.configLoader,this.rootComponentType,e.config,this.urlSerializer,e.paramsInheritanceStrategy),rr(c=>{if(s.targetSnapshot=c.targetSnapshot,s.urlAfterRedirects=c.urlAfterRedirects,this.currentNavigation={...this.currentNavigation,finalUrl:c.urlAfterRedirects},"eager"===e.urlUpdateStrategy){if(!c.extras.skipLocationChange){const h=e.urlHandlingStrategy.merge(c.urlAfterRedirects,c.rawUrl);e.setBrowserUrl(h,c)}e.browserUrlTree=c.urlAfterRedirects}const d=new VQ(c.id,this.urlSerializer.serialize(c.extractedUrl),this.urlSerializer.serialize(c.urlAfterRedirects),c.targetSnapshot);this.events.next(d)}));if(l&&e.urlHandlingStrategy.shouldProcessUrl(e.rawUrlTree)){const{id:c,extractedUrl:d,source:h,restoredState:f,extras:p}=o,g=new vC(c,this.urlSerializer.serialize(d),h,f);this.events.next(g);const m=j$(0,this.rootComponentType).snapshot;return tt(s={...o,targetSnapshot:m,urlAfterRedirects:d,extras:{...p,skipLocationChange:!1,replaceUrl:!1}})}{const c="";return this.events.next(new jh(o.id,e.serializeUrl(s.extractedUrl),c,1)),e.rawUrlTree=o.rawUrl,o.resolve(null),Ji}}),rr(o=>{const a=new BQ(o.id,this.urlSerializer.serialize(o.extractedUrl),this.urlSerializer.serialize(o.urlAfterRedirects),o.targetSnapshot);this.events.next(a)}),Ht(o=>s={...o,guards:cJ(o.targetSnapshot,o.currentSnapshot,this.rootContexts)}),function wJ(n,t){return Os(e=>{const{targetSnapshot:s,currentSnapshot:r,guards:{canActivateChecks:i,canDeactivateChecks:o}}=e;return 0===o.length&&0===i.length?tt({...e,guardsResult:!0}):function xJ(n,t,e,s){return Cs(n).pipe(Os(r=>function TJ(n,t,e,s,r){const i=t&&t.routeConfig?t.routeConfig.canDeactivate:null;return i&&0!==i.length?tt(i.map(a=>{const l=Xh(t)??r,u=Rc(a,l);return Ra(function bJ(n){return n&&Qh(n.canDeactivate)}(u)?u.canDeactivate(n,t,e,s):l.runInContext(()=>u(n,t,e,s))).pipe(Hl())})).pipe(Mc()):tt(!0)}(r.component,r.route,e,t,s)),Hl(r=>!0!==r,!0))}(o,s,r,n).pipe(Os(a=>a&&function pJ(n){return"boolean"==typeof n}(a)?function CJ(n,t,e,s){return Cs(t).pipe(Lh(r=>Zg(function IJ(n,t){return null!==n&&t&&t(new jQ(n)),tt(!0)}(r.route.parent,s),function SJ(n,t){return null!==n&&t&&t(new KQ(n)),tt(!0)}(r.route,s),function DJ(n,t,e){const s=t[t.length-1],i=t.slice(0,t.length-1).reverse().map(o=>function dJ(n){const t=n.routeConfig?n.routeConfig.canActivateChild:null;return t&&0!==t.length?{node:n,guards:t}:null}(o)).filter(o=>null!==o).map(o=>_$(()=>tt(o.guards.map(l=>{const u=Xh(o.node)??e,c=Rc(l,u);return Ra(function yJ(n){return n&&Qh(n.canActivateChild)}(c)?c.canActivateChild(s,n):u.runInContext(()=>c(s,n))).pipe(Hl())})).pipe(Mc())));return tt(i).pipe(Mc())}(n,r.path,e),function EJ(n,t,e){const s=t.routeConfig?t.routeConfig.canActivate:null;if(!s||0===s.length)return tt(!0);const r=s.map(i=>_$(()=>{const o=Xh(t)??e,a=Rc(i,o);return Ra(function gJ(n){return n&&Qh(n.canActivate)}(a)?a.canActivate(t,n):o.runInContext(()=>a(t,n))).pipe(Hl())}));return tt(r).pipe(Mc())}(n,r.route,e))),Hl(r=>!0!==r,!0))}(s,i,n,t):tt(a)),Ht(a=>({...e,guardsResult:a})))})}(this.environmentInjector,o=>this.events.next(o)),rr(o=>{if(s.guardsResult=o.guardsResult,Kl(o.guardsResult))throw Q$(0,o.guardsResult);const a=new zQ(o.id,this.urlSerializer.serialize(o.extractedUrl),this.urlSerializer.serialize(o.urlAfterRedirects),o.targetSnapshot,!!o.guardsResult);this.events.next(a)}),ta(o=>!!o.guardsResult||(e.restoreHistory(o),this.cancelNavigationTransition(o,"",3),!1)),kC(o=>{if(o.guards.canActivateChecks.length)return tt(o).pipe(rr(a=>{const l=new UQ(a.id,this.urlSerializer.serialize(a.extractedUrl),this.urlSerializer.serialize(a.urlAfterRedirects),a.targetSnapshot);this.events.next(l)}),ea(a=>{let l=!1;return tt(a).pipe(function jJ(n,t){return Os(e=>{const{targetSnapshot:s,guards:{canActivateChecks:r}}=e;if(!r.length)return tt(e);let i=0;return Cs(r).pipe(Lh(o=>function qJ(n,t,e,s){const r=n.routeConfig,i=n._resolve;return void 0!==r?.title&&!h2(r)&&(i[Vh]=r.title),function KJ(n,t,e,s){const r=function XJ(n){return[...Object.keys(n),...Object.getOwnPropertySymbols(n)]}(n);if(0===r.length)return tt({});const i={};return Cs(r).pipe(Os(o=>function YJ(n,t,e,s){const r=Xh(t)??s,i=Rc(n,r);return Ra(i.resolve?i.resolve(t,e):r.runInContext(()=>i(t,e)))}(n[o],t,e,s).pipe(Hl(),rr(a=>{i[o]=a}))),hC(1),function cQ(n){return Ht(()=>n)}(i),jl(o=>r2(o)?Ji:Ph(o)))}(i,n,t,s).pipe(Ht(o=>(n._resolvedData=o,n.data=q$(n,e).resolve,r&&h2(r)&&(n.data[Vh]=r.title),null)))}(o.route,s,n,t)),rr(()=>i++),hC(1),Os(o=>i===r.length?tt(e):Ji))})}(e.paramsInheritanceStrategy,this.environmentInjector),rr({next:()=>l=!0,complete:()=>{l||(e.restoreHistory(a),this.cancelNavigationTransition(a,"",2))}}))}),rr(a=>{const l=new WQ(a.id,this.urlSerializer.serialize(a.extractedUrl),this.urlSerializer.serialize(a.urlAfterRedirects),a.targetSnapshot);this.events.next(l)}))}),kC(o=>{const a=l=>{const u=[];l.routeConfig?.loadComponent&&!l.routeConfig._loadedComponent&&u.push(this.configLoader.loadComponent(l.routeConfig).pipe(rr(c=>{l.component=c}),Ht(()=>{})));for(const c of l.children)u.push(...a(c));return u};return Xg(a(o.targetSnapshot.root)).pipe(Qg(),Gl(1))}),kC(()=>this.afterPreactivation()),Ht(o=>{const a=function eJ(n,t,e){const s=Kh(n,t._root,e?e._root:void 0);return new H$(s,t)}(e.routeReuseStrategy,o.targetSnapshot,o.currentRouterState);return s={...o,targetRouterState:a}}),rr(o=>{e.currentUrlTree=o.urlAfterRedirects,e.rawUrlTree=e.urlHandlingStrategy.merge(o.urlAfterRedirects,o.rawUrl),e.routerState=o.targetRouterState,"deferred"===e.urlUpdateStrategy&&(o.extras.skipLocationChange||e.setBrowserUrl(e.rawUrlTree,o),e.browserUrlTree=o.urlAfterRedirects)}),((n,t,e,s)=>Ht(r=>(new uJ(t,r.targetRouterState,r.currentRouterState,e,s).activate(n),r)))(this.rootContexts,e.routeReuseStrategy,o=>this.events.next(o),this.inputBindingEnabled),Gl(1),rr({next:o=>{r=!0,this.lastSuccessfulNavigation=this.currentNavigation,e.navigated=!0,this.events.next(new Xl(o.id,this.urlSerializer.serialize(o.extractedUrl),this.urlSerializer.serialize(e.currentUrlTree))),e.titleStrategy?.updateTitle(o.targetRouterState.snapshot),o.resolve(!0)},complete:()=>{r=!0}}),fC(()=>{r||i||this.cancelNavigationTransition(s,"",1),this.currentNavigation?.id===s.id&&(this.currentNavigation=null)}),jl(o=>{if(i=!0,t2(o)){e2(o)||(e.navigated=!0,e.restoreHistory(s,!0));const a=new iy(s.id,this.urlSerializer.serialize(s.extractedUrl),o.message,o.cancellationCode);if(this.events.next(a),e2(o)){const l=e.urlHandlingStrategy.merge(o.url,e.rawUrlTree),u={skipLocationChange:s.extras.skipLocationChange,replaceUrl:"eager"===e.urlUpdateStrategy||p2(s.source)};e.scheduleNavigation(l,Hh,null,u,{resolve:s.resolve,reject:s.reject,promise:s.promise})}else s.resolve(!1)}else{e.restoreHistory(s,!0);const a=new _C(s.id,this.urlSerializer.serialize(s.extractedUrl),o,s.targetSnapshot??void 0);this.events.next(a);try{s.resolve(e.errorHandler(o))}catch(l){s.reject(l)}}return Ji}))}))}cancelNavigationTransition(e,s,r){const i=new iy(e.id,this.urlSerializer.serialize(e.extractedUrl),s,r);this.events.next(i),e.resolve(!1)}}return n.\u0275fac=function(e){return new(e||n)},n.\u0275prov=Ve({token:n,factory:n.\u0275fac,providedIn:"root"}),n})();function p2(n){return n!==Hh}let m2=(()=>{class n{buildTitle(e){let s,r=e.root;for(;void 0!==r;)s=this.getResolvedTitleForRoute(r)??s,r=r.children.find(i=>i.outlet===ct);return s}getResolvedTitleForRoute(e){return e.data[Vh]}}return n.\u0275fac=function(e){return new(e||n)},n.\u0275prov=Ve({token:n,factory:function(){return Fe(QJ)},providedIn:"root"}),n})(),QJ=(()=>{class n extends m2{constructor(e){super(),this.title=e}updateTitle(e){const s=this.buildTitle(e);void 0!==s&&this.title.setTitle(s)}}return n.\u0275fac=function(e){return new(e||n)(Se(h$))},n.\u0275prov=Ve({token:n,factory:n.\u0275fac,providedIn:"root"}),n})(),JJ=(()=>{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275prov=Ve({token:n,factory:function(){return Fe(tee)},providedIn:"root"}),n})();class eee{shouldDetach(t){return!1}store(t,e){}shouldAttach(t){return!1}retrieve(t){return null}shouldReuseRoute(t,e){return t.routeConfig===e.routeConfig}}let tee=(()=>{class n extends eee{}return n.\u0275fac=function(){let t;return function(s){return(t||(t=function Ls(n){return Po(()=>{const t=n.prototype.constructor,e=t[Vo]||Cw(t),s=Object.prototype;let r=Object.getPrototypeOf(n.prototype).constructor;for(;r&&r!==s;){const i=r[Vo]||Cw(r);if(i&&i!==e)return i;r=Object.getPrototypeOf(r)}return i=>new i})}(n)))(s||n)}}(),n.\u0275prov=Ve({token:n,factory:n.\u0275fac,providedIn:"root"}),n})();const fy=new we("",{providedIn:"root",factory:()=>({})});let nee=(()=>{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275prov=Ve({token:n,factory:function(){return Fe(see)},providedIn:"root"}),n})(),see=(()=>{class n{shouldProcessUrl(e){return!0}extract(e){return e}merge(e,s){return e}}return n.\u0275fac=function(e){return new(e||n)},n.\u0275prov=Ve({token:n,factory:n.\u0275fac,providedIn:"root"}),n})();var Ur=(()=>((Ur=Ur||{})[Ur.COMPLETE=0]="COMPLETE",Ur[Ur.FAILED=1]="FAILED",Ur[Ur.REDIRECTING=2]="REDIRECTING",Ur))();function g2(n,t){n.events.pipe(ta(e=>e instanceof Xl||e instanceof iy||e instanceof _C||e instanceof jh),Ht(e=>e instanceof Xl||e instanceof jh?Ur.COMPLETE:e instanceof iy&&(0===e.code||1===e.code)?Ur.REDIRECTING:Ur.FAILED),ta(e=>e!==Ur.REDIRECTING),Gl(1)).subscribe(()=>{t()})}function ree(n){throw n}function iee(n,t,e){return t.parse("/")}const oee={paths:"exact",fragment:"ignored",matrixParams:"ignored",queryParams:"exact"},aee={paths:"subset",fragment:"ignored",matrixParams:"ignored",queryParams:"subset"};let ci=(()=>{class n{get navigationId(){return this.navigationTransitions.navigationId}get browserPageId(){if("computed"===this.canceledNavigationResolution)return this.location.getState()?.\u0275routerPageId}get events(){return this.navigationTransitions.events}constructor(){this.disposed=!1,this.currentPageId=0,this.console=Fe(LF),this.isNgZoneEnabled=!1,this.options=Fe(fy,{optional:!0})||{},this.pendingTasks=Fe(wO),this.errorHandler=this.options.errorHandler||ree,this.malformedUriErrorHandler=this.options.malformedUriErrorHandler||iee,this.navigated=!1,this.lastSuccessfulId=-1,this.urlHandlingStrategy=Fe(nee),this.routeReuseStrategy=Fe(JJ),this.titleStrategy=Fe(m2),this.onSameUrlNavigation=this.options.onSameUrlNavigation||"ignore",this.paramsInheritanceStrategy=this.options.paramsInheritanceStrategy||"emptyOnly",this.urlUpdateStrategy=this.options.urlUpdateStrategy||"deferred",this.canceledNavigationResolution=this.options.canceledNavigationResolution||"replace",this.config=Fe(Oc,{optional:!0})?.flat()??[],this.navigationTransitions=Fe(hy),this.urlSerializer=Fe(zh),this.location=Fe(L0),this.componentInputBindingEnabled=!!Fe(ay,{optional:!0}),this.isNgZoneEnabled=Fe(Pt)instanceof Pt&&Pt.isInAngularZone(),this.resetConfig(this.config),this.currentUrlTree=new Nc,this.rawUrlTree=this.currentUrlTree,this.browserUrlTree=this.currentUrlTree,this.routerState=j$(0,null),this.navigationTransitions.setupNavigations(this).subscribe(e=>{this.lastSuccessfulId=e.id,this.currentPageId=this.browserPageId??0},e=>{this.console.warn(`Unhandled Navigation Error: ${e}`)})}resetRootComponentType(e){this.routerState.root.component=e,this.navigationTransitions.rootComponentType=e}initialNavigation(){if(this.setUpLocationChangeListener(),!this.navigationTransitions.hasRequestedNavigation){const e=this.location.getState();this.navigateToSyncWithBrowser(this.location.path(!0),Hh,e)}}setUpLocationChangeListener(){this.locationSubscription||(this.locationSubscription=this.location.subscribe(e=>{const s="popstate"===e.type?"popstate":"hashchange";"popstate"===s&&setTimeout(()=>{this.navigateToSyncWithBrowser(e.url,s,e.state)},0)}))}navigateToSyncWithBrowser(e,s,r){const i={replaceUrl:!0},o=r?.navigationId?r:null;if(r){const l={...r};delete l.navigationId,delete l.\u0275routerPageId,0!==Object.keys(l).length&&(i.state=l)}const a=this.parseUrl(e);this.scheduleNavigation(a,s,o,i)}get url(){return this.serializeUrl(this.currentUrlTree)}getCurrentNavigation(){return this.navigationTransitions.currentNavigation}get lastSuccessfulNavigation(){return this.navigationTransitions.lastSuccessfulNavigation}resetConfig(e){this.config=e.map(DC),this.navigated=!1,this.lastSuccessfulId=-1}ngOnDestroy(){this.dispose()}dispose(){this.navigationTransitions.complete(),this.locationSubscription&&(this.locationSubscription.unsubscribe(),this.locationSubscription=void 0),this.disposed=!0}createUrlTree(e,s={}){const{relativeTo:r,queryParams:i,fragment:o,queryParamsHandling:a,preserveFragment:l}=s,u=l?this.currentUrlTree.fragment:o;let d,c=null;switch(a){case"merge":c={...this.currentUrlTree.queryParams,...i};break;case"preserve":c=this.currentUrlTree.queryParams;break;default:c=i||null}null!==c&&(c=this.removeEmptyProps(c));try{d=$$(r?r.snapshot:this.routerState.snapshot.root)}catch{("string"!=typeof e[0]||!e[0].startsWith("/"))&&(e=[]),d=this.currentUrlTree.root}return P$(d,e,c,u??null)}navigateByUrl(e,s={skipLocationChange:!1}){const r=Kl(e)?e:this.parseUrl(e),i=this.urlHandlingStrategy.merge(r,this.rawUrlTree);return this.scheduleNavigation(i,Hh,null,s)}navigate(e,s={skipLocationChange:!1}){return function lee(n){for(let t=0;t<n.length;t++)if(null==n[t])throw new ee(4008,!1)}(e),this.navigateByUrl(this.createUrlTree(e,s),s)}serializeUrl(e){return this.urlSerializer.serialize(e)}parseUrl(e){let s;try{s=this.urlSerializer.parse(e)}catch(r){s=this.malformedUriErrorHandler(r,this.urlSerializer,e)}return s}isActive(e,s){let r;if(r=!0===s?{...oee}:!1===s?{...aee}:s,Kl(e))return D$(this.currentUrlTree,e,r);const i=this.parseUrl(e);return D$(this.currentUrlTree,i,r)}removeEmptyProps(e){return Object.keys(e).reduce((s,r)=>{const i=e[r];return null!=i&&(s[r]=i),s},{})}scheduleNavigation(e,s,r,i,o){if(this.disposed)return Promise.resolve(!1);let a,l,u;o?(a=o.resolve,l=o.reject,u=o.promise):u=new Promise((d,h)=>{a=d,l=h});const c=this.pendingTasks.add();return g2(this,()=>{Promise.resolve().then(()=>this.pendingTasks.remove(c))}),this.navigationTransitions.handleNavigationRequest({source:s,restoredState:r,currentUrlTree:this.currentUrlTree,currentRawUrl:this.currentUrlTree,rawUrl:e,extras:i,resolve:a,reject:l,promise:u,currentSnapshot:this.routerState.snapshot,currentRouterState:this.routerState}),u.catch(d=>Promise.reject(d))}setBrowserUrl(e,s){const r=this.urlSerializer.serialize(e);if(this.location.isCurrentPathEqualTo(r)||s.extras.replaceUrl){const o={...s.extras.state,...this.generateNgRouterState(s.id,this.browserPageId)};this.location.replaceState(r,"",o)}else{const i={...s.extras.state,...this.generateNgRouterState(s.id,(this.browserPageId??0)+1)};this.location.go(r,"",i)}}restoreHistory(e,s=!1){if("computed"===this.canceledNavigationResolution){const i=this.currentPageId-(this.browserPageId??this.currentPageId);0!==i?this.location.historyGo(i):this.currentUrlTree===this.getCurrentNavigation()?.finalUrl&&0===i&&(this.resetState(e),this.browserUrlTree=e.currentUrlTree,this.resetUrlToCurrentUrlTree())}else"replace"===this.canceledNavigationResolution&&(s&&this.resetState(e),this.resetUrlToCurrentUrlTree())}resetState(e){this.routerState=e.currentRouterState,this.currentUrlTree=e.currentUrlTree,this.rawUrlTree=this.urlHandlingStrategy.merge(this.currentUrlTree,e.rawUrl)}resetUrlToCurrentUrlTree(){this.location.replaceState(this.urlSerializer.serialize(this.rawUrlTree),"",this.generateNgRouterState(this.lastSuccessfulId,this.currentPageId))}generateNgRouterState(e,s){return"computed"===this.canceledNavigationResolution?{navigationId:e,\u0275routerPageId:s}:{navigationId:e}}}return n.\u0275fac=function(e){return new(e||n)},n.\u0275prov=Ve({token:n,factory:n.\u0275fac,providedIn:"root"}),n})();class y2{}let dee=(()=>{class n{constructor(e,s,r,i,o){this.router=e,this.injector=r,this.preloadingStrategy=i,this.loader=o}setUpPreloading(){this.subscription=this.router.events.pipe(ta(e=>e instanceof Xl),Lh(()=>this.preload())).subscribe(()=>{})}preload(){return this.processRoutes(this.injector,this.router.config)}ngOnDestroy(){this.subscription&&this.subscription.unsubscribe()}processRoutes(e,s){const r=[];for(const i of s){i.providers&&!i._injector&&(i._injector=t0(i.providers,e,`Route: ${i.path}`));const o=i._injector??e,a=i._loadedInjector??o;(i.loadChildren&&!i._loadedRoutes&&void 0===i.canLoad||i.loadComponent&&!i._loadedComponent)&&r.push(this.preloadConfig(o,i)),(i.children||i._loadedRoutes)&&r.push(this.processRoutes(a,i.children??i._loadedRoutes))}return Cs(r).pipe(Ou())}preloadConfig(e,s){return this.preloadingStrategy.preload(s,()=>{let r;r=s.loadChildren&&void 0===s.canLoad?this.loader.loadChildren(e,s):tt(null);const i=r.pipe(Os(o=>null===o?tt(void 0):(s._loadedRoutes=o.routes,s._loadedInjector=o.injector,this.processRoutes(o.injector??e,o.routes))));return s.loadComponent&&!s._loadedComponent?Cs([i,this.loader.loadComponent(s)]).pipe(Ou()):i})}}return n.\u0275fac=function(e){return new(e||n)(Se(ci),Se(VF),Se(Go),Se(y2),Se(AC))},n.\u0275prov=Ve({token:n,factory:n.\u0275fac,providedIn:"root"}),n})();const MC=new we("");let b2=(()=>{class n{constructor(e,s,r,i,o={}){this.urlSerializer=e,this.transitions=s,this.viewportScroller=r,this.zone=i,this.options=o,this.lastId=0,this.lastSource="imperative",this.restoredId=0,this.store={},o.scrollPositionRestoration=o.scrollPositionRestoration||"disabled",o.anchorScrolling=o.anchorScrolling||"disabled"}init(){"disabled"!==this.options.scrollPositionRestoration&&this.viewportScroller.setHistoryScrollRestoration("manual"),this.routerEventsSubscription=this.createScrollEvents(),this.scrollEventsSubscription=this.consumeScrollEvents()}createScrollEvents(){return this.transitions.events.subscribe(e=>{e instanceof vC?(this.store[this.lastId]=this.viewportScroller.getScrollPosition(),this.lastSource=e.navigationTrigger,this.restoredId=e.restoredState?e.restoredState.navigationId:0):e instanceof Xl?(this.lastId=e.id,this.scheduleScrollEvent(e,this.urlSerializer.parse(e.urlAfterRedirects).fragment)):e instanceof jh&&0===e.code&&(this.lastSource=void 0,this.restoredId=0,this.scheduleScrollEvent(e,this.urlSerializer.parse(e.url).fragment))})}consumeScrollEvents(){return this.transitions.events.subscribe(e=>{e instanceof W$&&(e.position?"top"===this.options.scrollPositionRestoration?this.viewportScroller.scrollToPosition([0,0]):"enabled"===this.options.scrollPositionRestoration&&this.viewportScroller.scrollToPosition(e.position):e.anchor&&"enabled"===this.options.anchorScrolling?this.viewportScroller.scrollToAnchor(e.anchor):"disabled"!==this.options.scrollPositionRestoration&&this.viewportScroller.scrollToPosition([0,0]))})}scheduleScrollEvent(e,s){this.zone.runOutsideAngular(()=>{setTimeout(()=>{this.zone.run(()=>{this.transitions.events.next(new W$(e,"popstate"===this.lastSource?this.store[this.restoredId]:null,s))})},0)})}ngOnDestroy(){this.routerEventsSubscription?.unsubscribe(),this.scrollEventsSubscription?.unsubscribe()}}return n.\u0275fac=function(e){!function UA(){throw new Error("invalid")}()},n.\u0275prov=Ve({token:n,factory:n.\u0275fac}),n})();function sa(n,t){return{\u0275kind:n,\u0275providers:t}}function _2(){const n=Fe(lo);return t=>{const e=n.get(zl);if(t!==e.components[0])return;const s=n.get(ci),r=n.get(w2);1===n.get(FC)&&s.initialNavigation(),n.get(x2,null,je.Optional)?.setUpPreloading(),n.get(MC,null,je.Optional)?.init(),s.resetRootComponentType(e.componentTypes[0]),r.closed||(r.next(),r.complete(),r.unsubscribe())}}const w2=new we("",{factory:()=>new Ti}),FC=new we("",{providedIn:"root",factory:()=>1}),x2=new we("");function mee(n){return sa(0,[{provide:x2,useExisting:dee},{provide:y2,useExisting:n}])}const C2=new we("ROUTER_FORROOT_GUARD"),yee=[L0,{provide:zh,useClass:pC},ci,qh,{provide:Ac,useFactory:function v2(n){return n.routerState.root},deps:[ci]},AC,[]];function bee(){return new YF("Router",ci)}let S2=(()=>{class n{constructor(e){}static forRoot(e,s){return{ngModule:n,providers:[yee,[],{provide:Oc,multi:!0,useValue:e},{provide:C2,useFactory:xee,deps:[[ci,new Lm,new Vm]]},{provide:fy,useValue:s||{}},s?.useHash?{provide:Wl,useClass:T7}:{provide:Wl,useClass:DO},{provide:MC,useFactory:()=>{const n=Fe(jY),t=Fe(Pt),e=Fe(fy),s=Fe(hy),r=Fe(zh);return e.scrollOffset&&n.setOffset(e.scrollOffset),new b2(r,s,n,t,e)}},s?.preloadingStrategy?mee(s.preloadingStrategy).\u0275providers:[],{provide:YF,multi:!0,useFactory:bee},s?.initialNavigation?Cee(s):[],s?.bindToComponentInputs?sa(8,[Z$,{provide:ay,useExisting:Z$}]).\u0275providers:[],[{provide:I2,useFactory:_2},{provide:D0,multi:!0,useExisting:I2}]]}}static forChild(e){return{ngModule:n,providers:[{provide:Oc,multi:!0,useValue:e}]}}}return n.\u0275fac=function(e){return new(e||n)(Se(C2,8))},n.\u0275mod=Or({type:n}),n.\u0275inj=fr({}),n})();function xee(n){return"guarded"}function Cee(n){return["disabled"===n.initialNavigation?sa(3,[{provide:b0,multi:!0,useFactory:()=>{const t=Fe(ci);return()=>{t.setUpLocationChangeListener()}}},{provide:FC,useValue:2}]).\u0275providers:[],"enabledBlocking"===n.initialNavigation?sa(2,[{provide:FC,useValue:0},{provide:b0,multi:!0,deps:[lo],useFactory:t=>{const e=t.get(E7,Promise.resolve());return()=>e.then(()=>new Promise(s=>{const r=t.get(ci),i=t.get(w2);g2(r,()=>{s(!0)}),t.get(hy).afterPreactivation=()=>(s(!0),i.closed?tt(void 0):i),r.initialNavigation()}))}}]).\u0275providers:[]]}const I2=new we(""),Iee=[];let Eee=(()=>{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275mod=Or({type:n}),n.\u0275inj=fr({imports:[S2.forRoot(Iee),S2]}),n})();function E2(n,t,e,s,r,i,o){try{var a=n[i](o),l=a.value}catch(u){return void e(u)}a.done?t(l):Promise.resolve(l).then(s,r)}function te(n){return function(){var t=this,e=arguments;return new Promise(function(s,r){var i=n.apply(t,e);function o(l){E2(i,s,r,o,a,"next",l)}function a(l){E2(i,s,r,o,a,"throw",l)}o(void 0)})}}class D2{constructor(t,e){this.backend=t,this.dataMover=e,this.data=new WeakMap,this.dataIdsCount=0}get(t){return this.data.has(t)||this.dataMover.moveData(this.backend,t),this.data.get(t)}set(t,e){this.dataIdsCount++,this.data.set(t,e)}has(t){return this.data.has(t)}delete(t){return this.dataIdsCount--,this.data.delete(t)}numDataIds(){return this.dataIdsCount}}class OC{refCount(t){return Cr("refCount")}incRef(t){return Cr("incRef")}timerAvailable(){return!0}time(t){return Cr("time")}read(t){return Cr("read")}readSync(t){return Cr("readSync")}readToGPU(t,e){return Cr("readToGPU")}numDataIds(){return Cr("numDataIds")}disposeData(t,e){return Cr("disposeData")}write(t,e,s){return Cr("write")}move(t,e,s,r,i){return Cr("move")}createTensorFromGPUData(t,e,s){return Cr("createTensorFromGPUData")}memory(){return Cr("memory")}floatPrecision(){return Cr("floatPrecision")}epsilon(){return 32===this.floatPrecision()?1e-7:1e-4}dispose(){return Cr("dispose")}}function Cr(n){throw new Error(`'${n}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`)}function T2(n){let t=n.length,e=0;for(;t>0;)e=Math.random()*t|0,t--,Ma(n,t,e)}function Yl(n,t,e){return Math.max(n,Math.min(t,e))}function $C(n){return n%2==0?n:n+1}function Ma(n,t,e){const s=n[t];n[t]=n[e],n[e]=s}function S(n,t){if(!n)throw new Error("string"==typeof t?t:t())}function Sr(n,t,e=""){S(wt(n,t),()=>e+` Shapes ${n} and ${t} must match`)}function $c(n){S(null!=n,()=>"The input to the tensor constructor must be a non-null value.")}function X(n){if(0===n.length)return 1;let t=n[0];for(let e=1;e<n.length;e++)t*=n[e];return t}function wt(n,t){if(n===t)return!0;if(null==n||null==t||n.length!==t.length)return!1;for(let e=0;e<n.length;e++)if(n[e]!==t[e])return!1;return!0}function Pc(n){return n%1==0}function PC(n){const t=Math.ceil(Math.sqrt(n));return[t,Math.ceil(n/t)]}function Lc(n,t){return t<=n.length?n:n+" ".repeat(t-n.length)}function N2(n,t=(r=>0),e,s){return new Promise((r,i)=>{let o=0;const a=()=>{if(n())return void r();o++;const l=t(o);null!=e&&o>=e?i():null!=s?s(a,l):setTimeout(a,l)};a()})}function k2(n,t){let e=1,s=-1;for(let i=0;i<n.length;++i)if(n[i]>=0)e*=n[i];else if(-1===n[i]){if(-1!==s)throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${s} and dim ${i}`);s=i}else if(n[i]<0)throw Error(`Shapes can not be < 0. Found ${n[i]} at dim ${i}`);if(-1===s){if(t>0&&t!==e)throw Error(`Size(${t}) must match the product of shape ${n}`);return n}if(0===e)throw Error(`Cannot infer the missing size in [${n}] when there are 0 elements`);if(t%e!=0)throw Error(`The implicit shape can't be a fractional number. Got ${t} / ${e}`);const r=n.slice();return r[s]=t/e,r}function mt(n,t){const e=t.length;return S((n=null==n?t.map((s,r)=>r):[].concat(n)).every(s=>s>=-e&&s<e),()=>`All values in axis param must be in range [-${e}, ${e}) but got axis ${n}`),S(n.every(s=>Pc(s)),()=>`All values in axis param must be integers but got axis ${n}`),n.map(s=>s<0?e+s:s)}function Fa(n,t){const e=[],s=[],r=null!=t&&Array.isArray(t)&&0===t.length,i=null==t||r?null:mt(t,n).sort();let o=0;for(let a=0;a<n.length;++a){if(null!=i){if(i[o]===a&&1!==n[a])throw new Error(`Can't squeeze axis ${a} since its dim '${n[a]}' is not 1`);(null==i[o]||i[o]>a)&&1===n[a]&&(e.push(n[a]),s.push(a)),i[o]<=a&&o++}1!==n[a]&&(e.push(n[a]),s.push(a))}return{newShape:e,keptDims:s}}function Ds(n,t){return Fn(n,t)}function Fn(n,t){let e=null;if(null==n||"float32"===n)e=new Float32Array(t);else if("int32"===n)e=new Int32Array(t);else if("bool"===n)e=new Uint8Array(t);else{if("string"!==n)throw new Error(`Unknown data type ${n}`);e=new Array(t)}return e}function A2(n,t){return!("complex64"===t||"float32"===t&&"complex64"!==n||"int32"===t&&"float32"!==n&&"complex64"!==n||"bool"===t&&"bool"===n)}function py(n){if("float32"===n||"int32"===n)return 4;if("complex64"===n)return 8;if("bool"===n)return 1;throw new Error(`Unknown dtype ${n}`)}function Jh(n){return"string"==typeof n||n instanceof String}function LC(n){return"number"==typeof n}function Vc(n){return Array.isArray(n)?Vc(n[0]):n instanceof Float32Array?"float32":n instanceof Int32Array||n instanceof Uint8Array||n instanceof Uint8ClampedArray?"int32":LC(n)?"float32":Jh(n)?"string":function Fee(n){return"boolean"==typeof n}(n)?"bool":"float32"}function VC(n){return!!(n&&n.constructor&&n.call&&n.apply)}function BC(n,t){for(let e=t;e<n;++e)if(n%e==0)return e;return n}function Be(n){const t=n.length;if(t<2)return[];const e=new Array(t-1);e[t-2]=n[t-1];for(let s=t-3;s>=0;--s)e[s]=e[s+1]*n[s+1];return e}function R2(n,t,e,s=!1){const r=new Array;if(1===t.length){const i=t[0]*(s?2:1);for(let o=0;o<i;o++)r[o]=e[n+o]}else{const i=t[0],o=t.slice(1),a=o.reduce((l,u)=>l*u)*(s?2:1);for(let l=0;l<i;l++)r[l]=R2(n+l*a,o,e,s)}return r}function di(n,t,e=!1){if(0===n.length)return t[0];const s=n.reduce((r,i)=>r*i)*(e?2:1);if(0===s)return[];if(s!==t.length)throw new Error(`[${n}] does not match the input size ${t.length}${e?" for a complex tensor":""}.`);return R2(0,n,t,e)}function zC(n,t){const e=Vs(n,t);for(let s=0;s<e.length;s++)e[s]=1;return e}function Vs(n,t){if(null==t||"float32"===t||"complex64"===t)return new Float32Array(n);if("int32"===t)return new Int32Array(n);if("bool"===t)return new Uint8Array(n);throw new Error(`Unknown data type ${t}`)}function M2(n,t){const e=n.reduce((s,r)=>s*r,1);if(null==t||"float32"===t)return di(n,new Float32Array(e));if("int32"===t)return di(n,new Int32Array(e));if("bool"===t)return di(n,new Uint8Array(e));throw new Error(`Unknown data type ${t}`)}function Wr(n){n.forEach(t=>{S(Number.isInteger(t)&&t>=0,()=>`Tensor must have a shape comprised of positive integers but got shape [${n}].`)})}function yo(n,t,e){if(0===t)return 0;if(1===t)return n[0];let s=n[n.length-1];for(let r=0;r<n.length-1;++r)s+=e[r]*n[r];return s}function Bc(n,t,e){if(0===t)return[];if(1===t)return[n];const s=new Array(t);for(let r=0;r<s.length-1;++r)s[r]=Math.floor(n/e[r]),n-=s[r]*e[r];return s[s.length-1]=n,s}function Zl(n){return n&&n.then&&"function"==typeof n.then}const F2="tfjsflags";class $ee{constructor(t){this.global=t,this.flags={},this.flagRegistry={},this.urlFlags={},this.getQueryParams=Pee,this.populateURLFlags()}setPlatform(t,e){null!=this.platform&&(W().getBool("IS_TEST")||W().getBool("PROD")||console.warn(`Platform ${this.platformName} has already been set. Overwriting the platform with ${t}.`)),this.platformName=t,this.platform=e}registerFlag(t,e,s){if(this.flagRegistry[t]={evaluationFn:e,setHook:s},null!=this.urlFlags[t]){const r=this.urlFlags[t];W().getBool("IS_TEST")||W().getBool("PROD")||console.warn(`Setting feature override from URL ${t}: ${r}.`),this.set(t,r)}}getAsync(t){var e=this;return te(function*(){return t in e.flags||(e.flags[t]=yield e.evaluateFlag(t)),e.flags[t]})()}get(t){if(t in this.flags)return this.flags[t];const e=this.evaluateFlag(t);if(Zl(e))throw new Error(`Flag ${t} cannot be synchronously evaluated. Please use getAsync() instead.`);return this.flags[t]=e,this.flags[t]}getNumber(t){return this.get(t)}getBool(t){return this.get(t)}getString(t){return this.get(t)}getFlags(){return this.flags}get features(){return this.flags}set(t,e){if(null==this.flagRegistry[t])throw new Error(`Cannot set flag ${t} as it has not been registered.`);this.flags[t]=e,null!=this.flagRegistry[t].setHook&&this.flagRegistry[t].setHook(e)}evaluateFlag(t){if(null==this.flagRegistry[t])throw new Error(`Cannot evaluate flag '${t}': no evaluation function found.`);return this.flagRegistry[t].evaluationFn()}setFlags(t){this.flags=Object.assign({},t)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if(typeof this.global>"u"||typeof this.global.location>"u"||typeof this.global.location.search>"u")return;const t=this.getQueryParams(this.global.location.search);F2 in t&&t[F2].split(",").forEach(s=>{const[r,i]=s.split(":");this.urlFlags[r]=function Vee(n,t){const e=t.toLowerCase();return"true"===e||"false"===e?"true"===e:""+ +e===e?+e:t}(0,i)})}}function Pee(n){const t={};return n.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,(e,...s)=>(function Lee(n,t,e){n[decodeURIComponent(t)]=decodeURIComponent(e||"")}(t,s[0],s[1]),s.join("="))),t}function W(){return O2}let UC,O2=null;function $2(){if(null==UC){let n;if(typeof window<"u")n=window;else if(typeof global<"u")n=global;else if(typeof process<"u")n=process;else{if(!(typeof self<"u"))throw new Error("Could not find a global object");n=self}UC=n}return UC}function WC(n,t){const e=function zee(){const n=$2();return null==n._tfGlobals&&(n._tfGlobals=new Map),n._tfGlobals}();if(e.has(n))return e.get(n);{const s=t();return e.set(n,s),e.get(n)}}const my="Abs",ef="Acos",nf="Acosh",zc="Add",gy="AddN",yy="ArgMax",by="ArgMin",sf="Asin",rf="Asinh",af="Atan",lf="Atanh",uf="Atan2",vy="AvgPool",jC="AvgPoolGrad",_y="AvgPool3D",qC="AvgPool3DGrad",wy="BatchMatMul",xy="BatchToSpaceND",KC="Bincount",XC="BitwiseAnd",YC="BroadcastArgs",cf="Cast",df="Ceil",hf="ClipByValue",ZC="Complex",Cy="ComplexAbs",Sy="Concat",Iy="Conv2D",QC="Conv2DBackpropFilter",Ey="Conv2DBackpropInput",Dy="Conv3D",JC="Conv3DBackpropFilterV2",eS="Conv3DBackpropInputV2",ff="Cos",pf="Cosh",tS="Cumprod",Ty="Cumsum",nS="CropAndResize",sS="DenseBincount",rS="DepthToSpace",Ny="DepthwiseConv2dNative",iS="DepthwiseConv2dNativeBackpropFilter",oS="DepthwiseConv2dNativeBackpropInput",aS="Diag",ky="Dilation2D",lS="Dilation2DBackpropInput",uS="Dilation2DBackpropFilter",mf="RealDiv",cS="Einsum",gf="Elu",dS="EluGrad",yf="Erf",Ay="Equal",bf="Exp",Ry="ExpandDims",vf="Expm1",fS="Fill",pS="FlipLeftRight",_f="Floor",wf="FloorDiv",My="FusedBatchNorm",Fy="GatherV2",mS="GatherNd",Oy="Greater",xf="GreaterEqual",Cf="Identity",gS="IFFT",yS="Imag",Sf="IsFinite",If="IsInf",Ef="IsNan",$y="LeakyRelu",Py="Less",Ly="LessEqual",bS="LinSpace",Df="Log",Tf="Log1p",Vy="LogicalAnd",By="LogicalNot",zy="LogicalOr",Uy="LRN",vS="LRNGrad",Wy="Max",Nf="Maximum",Gy="MaxPool",_S="MaxPoolGrad",Hy="MaxPool3D",wS="MaxPool3DGrad",xS="MaxPoolWithArgmax",jy="Mean",qy="Min",kf="Minimum",Ky="MirrorPad",Af="Mod",CS="Multinomial",Rf="Multiply",Xy="Neg",Yy="NotEqual",SS="NonMaxSuppressionV3",IS="NonMaxSuppressionV4",ES="NonMaxSuppressionV5",Zy="OnesLike",Qy="OneHot",Jy="Pack",eb="PadV2",Mf="Pow",tb="Prelu",nb="Prod",DS="RaggedGather",TS="RaggedRange",NS="RaggedTensorToTensor",kS="Range",AS="Real",Ff="Reciprocal",Of="Relu",sb="Reshape",rb="ResizeNearestNeighbor",RS="ResizeNearestNeighborGrad",ib="ResizeBilinear",MS="ResizeBilinearGrad",$f="Relu6",ob="Reverse",Pf="Round",Lf="Rsqrt",FS="ScatterNd",OS="TensorScatterUpdate",$S="SearchSorted",ab="Select",Vf="Selu",lb="Slice",Bf="Sin",zf="Sinh",Uf="Sign",Wf="Sigmoid",Gf="Softplus",Hf="Sqrt",ub="Sum",cb="SpaceToBatchND",db="SplitV",hb="Softmax",PS="SparseFillEmptyRows",LS="SparseReshape",VS="SparseSegmentMean",BS="SparseSegmentSum",zS="SparseToDense",jf="SquaredDifference",US="Square",fb="StaticRegexReplace",WS="StridedSlice",GS="StringNGrams",HS="StringSplit",jS="StringToHashBucketFast",qf="Sub",Kf="Tan",Xf="Tanh",Yf="Tile",qS="TopK",KS="Transform",Uc="Transpose",XS="Unique",pb="Unpack",mb="UnsortedSegmentSum",gb="ZerosLike",Zf="Step",YS="RotateWithOffset",yb="_FusedMatMul",bb="FusedConv2D",vb="FusedDepthwiseConv2D";function Gr(...n){W().getBool("IS_TEST")||W().getBool("PROD")||console.warn(...n)}function Hee(...n){W().getBool("IS_TEST")||W().getBool("PROD")||console.log(...n)}const Wc=WC("kernelRegistry",()=>new Map),Qf=WC("gradRegistry",()=>new Map);function P2(n,t){const e=JS(n,t);return Wc.get(e)}function L2(n){return Qf.get(n)}function ZS(n){const t=Wc.entries(),e=[];for(;;){const{done:s,value:r}=t.next();if(s)break;const[i,o]=r,[a]=i.split("_");a===n&&e.push(o)}return e}function QS(n){const{kernelName:t,backendName:e}=n,s=JS(t,e);Wc.has(s)&&Gr(`The kernel '${t}' for backend '${e}' is already registered`),Wc.set(s,n)}function jee(n){const{kernelName:t}=n;Qf.has(t)&&W().getBool("DEBUG")&&Gr(`Overriding the gradient for '${t}'`),Qf.set(t,n)}function JS(n,t){return`${t}_${n}`}function V2(n){return n instanceof Float32Array||n instanceof Int32Array||n instanceof Uint8Array||n instanceof Uint8ClampedArray}var B2=Q(658);const Ql=Q.n(B2)()||B2;function _b(n){return Ql.fromString(n,!0,16)}const z2=_b("c3a5c85c97cb3127"),Jl=_b("b492b66fbe98f273"),qs=_b("9ae16a3b2f90404f");function eI(n){return n.xor(n.shru(47))}function U2(n,t,e){const s=n.slice(t,t+e);return Ql.fromBytes(Array.from(s),!0,!0)}function nn(n,t){return U2(n,t,8)}function W2(n,t){return U2(n,t,4)}function bs(n,t){return 0===t?n:n.shru(t).or(n.shl(64-t))}function Oa(n,t,e=_b("9ddfea08eb382d69")){let s=n.xor(t).mul(e);s=s.xor(s.shru(47));let r=t.xor(s).mul(e);return r=r.xor(r.shru(47)),r=r.mul(e),r}function wb(n,t,e,s){return function Kee(n,t,e,s,r,i){r=r.add(n),i=bs(i.add(r).add(s),21);const o=r;return r=(r=r.add(t)).add(e),i=i.add(bs(r,44)),[r.add(s),i.add(o)]}(nn(n,t),nn(n,t+8),nn(n,t+16),nn(n,t+24),e,s)}function Qee(n,t=n.length){const e=Ql.fromNumber(81,!0);if(t<=32)return t<=16?function Xee(n,t=n.length){if(t>=8){const e=qs.add(2*t),s=nn(n,0).add(qs),r=nn(n,t-8);return Oa(bs(r,37).mul(e).add(s),bs(s,25).add(r).mul(e),e)}if(t>=4){const e=qs.add(2*t);return Oa(W2(n,0).shl(3).add(t),W2(n,t-4),e)}if(t>0){const o=t+(n[t-1]<<2);return eI(qs.mul(n[0]+(n[t>>1]<<8)).xor(z2.mul(o))).mul(qs)}return qs}(n,t):function Yee(n,t=n.length){const e=qs.add(2*t),s=nn(n,0).mul(Jl),r=nn(n,8),i=nn(n,t-8).mul(e),o=nn(n,t-16).mul(qs);return Oa(bs(s.add(r),43).add(bs(i,30)).add(o),s.add(bs(r.add(qs),18)).add(i),e)}(n,t);if(t<=64)return function Zee(n,t=n.length){const e=qs.add(2*t),s=nn(n,0).mul(qs),r=nn(n,8),i=nn(n,t-8).mul(e),o=nn(n,t-16).mul(qs),a=bs(s.add(r),43).add(bs(i,30)).add(o),l=Oa(a,s.add(bs(r.add(qs),18)).add(i),e),u=nn(n,16).mul(e),c=nn(n,24),d=a.add(nn(n,t-32)).mul(e),h=l.add(nn(n,t-24)).mul(e);return Oa(bs(u.add(c),43).add(bs(d,30)).add(h),u.add(bs(c.add(s),18)).add(d),e)}(n,t);let s=e,r=e.mul(Jl).add(113),i=eI(r.mul(qs).add(113)).mul(qs),o=[Ql.UZERO,Ql.UZERO],a=[Ql.UZERO,Ql.UZERO];s=s.mul(qs).add(nn(n,0));let l=0;const u=64*(t-1>>6),c=u+(t-1&63)-63;do{s=bs(s.add(r).add(o[0]).add(nn(n,l+8)),37).mul(Jl),r=bs(r.add(o[1]).add(nn(n,l+48)),42).mul(Jl),s=s.xor(a[1]),r=r.add(o[0]).add(nn(n,l+40)),i=bs(i.add(a[0]),33).mul(Jl),o=wb(n,l,o[1].mul(Jl),s.add(a[0])),a=wb(n,l+32,i.add(a[1]),r.add(nn(n,l+16))),[i,s]=[s,i],l+=64}while(l!==u);const d=Jl.add(i.and(255).shl(1));return l=c,a[0]=a[0].add(t-1&63),o[0]=o[0].add(a[0]),a[0]=a[0].add(o[0]),s=bs(s.add(r).add(o[0]).add(nn(n,l+8)),37).mul(d),r=bs(r.add(o[1]).add(nn(n,l+48)),42).mul(d),s=s.xor(a[1].mul(9)),r=r.add(o[0].mul(9).add(nn(n,l+40))),i=bs(i.add(a[0]),33).mul(d),o=wb(n,l,o[1].mul(d),s.add(a[0])),a=wb(n,l+32,i.add(a[1]),r.add(nn(n,l+16))),[i,s]=[s,i],Oa(Oa(o[0],a[0],d).add(eI(r).mul(z2)).add(i),Oa(o[1],a[1],d).add(s),d)}function $a(n,t){return"string"===t?Pa(n):eu([n],t)}function eu(n,t){if("string"===t)throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(n)&&(n=tu(n)),W().getBool("DEBUG")&&function Aee(n,t){for(let e=0;e<n.length;e++){const s=n[e];if(isNaN(s)||!isFinite(s))throw Error(`A tensor of type ${t} being uploaded contains ${s}.`)}}(n,t),function Jee(n,t){return n instanceof Float32Array&&"float32"===t||n instanceof Int32Array&&"int32"===t||n instanceof Uint8Array&&"bool"===t}(n,t))return n;if(null==t||"float32"===t||"complex64"===t)return new Float32Array(n);if("int32"===t)return new Int32Array(n);if("bool"===t){const e=new Uint8Array(n.length);for(let s=0;s<e.length;++s)0!==Math.round(n[s])&&(e[s]=1);return e}throw new Error(`Unknown data type ${t}`)}function ir(){return W().platform.now()}function Pa(n,t="utf-8"){return t=t||"utf-8",W().platform.encode(n,t)}function La(n,t="utf-8"){return t=t||"utf-8",W().platform.decode(n,t)}function hi(n){return null!=W().platform.isTypedArray?W().platform.isTypedArray(n):V2(n)}function tu(n,t=[],e=!1){if(null==t&&(t=[]),"boolean"==typeof n||"number"==typeof n||"string"==typeof n||Zl(n)||null==n||hi(n)&&e)t.push(n);else if(Array.isArray(n)||hi(n))for(let s=0;s<n.length;++s)tu(n[s],t,e);else{let s=-1;for(const r of Object.keys(n))/^([1-9]+[0-9]*|0)$/.test(r)&&(s=Math.max(s,Number(r)));for(let r=0;r<=s;r++)tu(n[r],t,e)}return t}class ete{constructor(t,e){this.backendTimer=t,this.logger=e,null==e&&(this.logger=new nte)}profileKernel(t,e,s){let r;const i=()=>{r=s()};let o;const a=ir();if(this.backendTimer.timerAvailable())o=this.backendTimer.time(i);else{i();for(const u of r)u.dataSync();o=Promise.resolve({kernelMs:ir()-a})}if(W().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let u=0;u<r.length;u++){const c=r[u];c.data().then(d=>{tte(d,c.dtype,t)})}return{kernelName:t,outputs:r,inputs:e,timeMs:o.then(u=>u.kernelMs),extraInfo:o.then(u=>null!=u.getExtraProfileInfo?u.getExtraProfileInfo():"")}}logKernelProfile(t){const{kernelName:e,outputs:s,timeMs:r,inputs:i,extraInfo:o}=t;s.forEach(a=>{Promise.all([a.data(),r,o]).then(l=>{this.logger.logKernelProfile(e,a,l[0],l[1],i,l[2])})})}}function tte(n,t,e){if("float32"!==t)return!1;for(let s=0;s<n.length;s++){const r=n[s];if(isNaN(r)||!isFinite(r))return console.warn(`Found ${r} in the result of '${e}'`),!0}return!1}class nte{logKernelProfile(t,e,s,r,i,o){const a="number"==typeof r?Lc(`${r}ms`,9):r.error,l=Lc(t,25),u=e.rank,c=e.size,d=Lc(e.shape.toString(),14);let h="";for(const f in i){const p=i[f];if(null!=p){const g=p.shape||e.shape,m=g.length;h+=`${f}: ${m}D ${m>0?g:""} `}}console.log(`%c${l}\t%c${a}\t%c${u}D ${d}\t%c${c}\t%c${h}\t%c${o}`,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}}const G2=20,Jf=3,tI=7;function ite(n,t,e,s){const r=Be(t),i=function ote(n,t,e,s){const r=X(t),i=s[s.length-1],o=new Array(i).fill(0),a=t.length,l="complex64"===e?tp(n):n;if(a>1)for(let u=0;u<r/i;u++){const c=u*i;for(let d=0;d<i;d++)o[d]=Math.max(o[d],ep(l[c+d],0,e).length)}return o}(n,t,e,r),o=t.length,a=xb(n,t,e,r,i),l=["Tensor"];return s&&(l.push(`  dtype: ${e}`),l.push(`  rank: ${o}`),l.push(`  shape: [${t}]`),l.push("  values:")),l.push(a.map(u=>"    "+u).join("\n")),l.join("\n")}function ep(n,t,e){let s;return s=Array.isArray(n)?`${parseFloat(n[0].toFixed(tI))} + ${parseFloat(n[1].toFixed(tI))}j`:Jh(n)?`'${n}'`:"bool"===e?H2(n):parseFloat(n.toFixed(tI)).toString(),Lc(s,t)}function H2(n){return 0===n?"false":"true"}function xb(n,t,e,s,r,i=!0){const o="complex64"===e?2:1,a=t[0],l=t.length;if(0===l)return"complex64"===e?[ep(tp(n)[0],0,e)]:"bool"===e?[H2(n[0])]:[n[0].toString()];if(1===l){if(a>G2){let y=Array.from(n.slice(0,Jf*o)),b=Array.from(n.slice((a-Jf)*o,a*o));return"complex64"===e&&(y=tp(y),b=tp(b)),["["+y.map((v,_)=>ep(v,r[_],e)).join(", ")+", ..., "+b.map((v,_)=>ep(v,r[a-Jf+_],e)).join(", ")+"]"]}return["["+("complex64"===e?tp(n):Array.from(n)).map((m,y)=>ep(m,r[y],e)).join(", ")+"]"]}const u=t.slice(1),c=s.slice(1),d=s[0]*o,h=[];if(a>G2){for(let g=0;g<Jf;g++){const m=g*d;h.push(...xb(n.slice(m,m+d),u,e,c,r,!1))}h.push("...");for(let g=a-Jf;g<a;g++){const m=g*d;h.push(...xb(n.slice(m,m+d),u,e,c,r,g===a-1))}}else for(let g=0;g<a;g++){const m=g*d;h.push(...xb(n.slice(m,m+d),u,e,c,r,g===a-1))}const f=2===l?",":"";h[0]="["+(a>0?h[0]+f:"");for(let g=1;g<h.length-1;g++)h[g]=" "+h[g]+f;let p=",\n";for(let g=2;g<l;g++)p+="\n";return h[h.length-1]=" "+h[h.length-1]+"]"+(i?"":p),h}function tp(n){const t=[];for(let e=0;e<n.length;e+=2)t.push([n[e],n[e+1]]);return t}class ts{constructor(t,e,s){if(this.dtype=e,this.shape=t.slice(),this.size=X(t),null!=s){const r=s.length;S(r===this.size,()=>`Length of values '${r}' does not match the size inferred by the shape '${this.size}'.`)}if("complex64"===e)throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=s||Fn(e,this.size),this.strides=Be(t)}set(t,...e){0===e.length&&(e=[0]),S(e.length===this.rank,()=>`The number of provided coordinates (${e.length}) must match the rank (${this.rank})`);const s=this.locToIndex(e);this.values[s]=t}get(...t){0===t.length&&(t=[0]);let e=0;for(const r of t){if(r<0||r>=this.shape[e])throw new Error(`Requested out of range element at ${t}.   Buffer shape=${this.shape}`);e++}let s=t[t.length-1];for(let r=0;r<t.length-1;++r)s+=this.strides[r]*t[r];return this.values[s]}locToIndex(t){if(0===this.rank)return 0;if(1===this.rank)return t[0];let e=t[t.length-1];for(let s=0;s<t.length-1;++s)e+=this.strides[s]*t[s];return e}indexToLoc(t){if(0===this.rank)return[];if(1===this.rank)return[t];const e=new Array(this.shape.length);for(let s=0;s<e.length-1;++s)e[s]=Math.floor(t/this.strides[s]),t-=e[s]*this.strides[s];return e[e.length-1]=t,e}get rank(){return this.shape.length}toTensor(){return zi().makeTensor(this.values,this.shape,this.dtype)}}let zi=null,Gc=null,j2=null;class pn{constructor(t,e,s,r){this.kept=!1,this.isDisposedInternal=!1,this.shape=t.slice(),this.dtype=e||"float32",this.size=X(t),this.strides=Be(t),this.dataId=s,this.id=r,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}buffer(){var t=this;return te(function*(){const e=yield t.data();return Gc.buffer(t.shape,t.dtype,e)})()}bufferSync(){return Gc.buffer(this.shape,this.dtype,this.dataSync())}array(){var t=this;return te(function*(){const e=yield t.data();return di(t.shape,e,"complex64"===t.dtype)})()}arraySync(){return di(this.shape,this.dataSync(),"complex64"===this.dtype)}data(){var t=this;return te(function*(){t.throwIfDisposed();const e=zi().read(t.dataId);if("string"===t.dtype){const s=yield e;try{return s.map(r=>La(r))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return e})()}dataToGPU(t){return this.throwIfDisposed(),zi().readToGPU(this.dataId,t)}dataSync(){this.throwIfDisposed();const t=zi().readSync(this.dataId);if("string"===this.dtype)try{return t.map(e=>La(e))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return t}bytes(){var t=this;return te(function*(){t.throwIfDisposed();const e=yield zi().read(t.dataId);return"string"===t.dtype?e:new Uint8Array(e.buffer)})()}dispose(){this.isDisposed||(zi().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(t=!1){return Gc.print(this,t)}clone(){return this.throwIfDisposed(),Gc.clone(this)}toString(t=!1){return ite(this.dataSync(),this.shape,this.dtype,t)}cast(t){return this.throwIfDisposed(),Gc.cast(this,t)}variable(t=!0,e,s){return this.throwIfDisposed(),zi().makeVariable(this,t,e,s)}}function Y(){return WC("Tensor",()=>pn)}Object.defineProperty(pn,Symbol.hasInstance,{value:n=>!!n&&null!=n.data&&null!=n.dataSync&&null!=n.throwIfDisposed}),Y();class Cb extends pn{constructor(t,e,s,r){super(t.shape,t.dtype,t.dataId,r),this.trainable=e,this.name=s}assign(t){if(t.dtype!==this.dtype)throw new Error(`dtype of the new value (${t.dtype}) and previous value (${this.dtype}) must match`);if(!wt(t.shape,this.shape))throw new Error(`shape of the new value (${t.shape}) and previous value (${this.shape}) must match`);zi().disposeTensor(this),this.dataId=t.dataId,zi().incRef(this,null)}dispose(){zi().disposeVariable(this),this.isDisposedInternal=!0}}Object.defineProperty(Cb,Symbol.hasInstance,{value:n=>n instanceof pn&&null!=n.assign&&n.assign instanceof Function});var Va=(()=>((Va=Va||{}).float32="float32",Va.int32="int32",Va.bool="int32",Va.complex64="complex64",Va))(),Ba=(()=>((Ba=Ba||{}).float32="float32",Ba.int32="int32",Ba.bool="bool",Ba.complex64="complex64",Ba))(),za=(()=>((za=za||{}).float32="float32",za.int32="float32",za.bool="float32",za.complex64="complex64",za))(),Ua=(()=>((Ua=Ua||{}).float32="complex64",Ua.int32="complex64",Ua.bool="complex64",Ua.complex64="complex64",Ua))();const cte={float32:za,int32:Va,bool:Ba,complex64:Ua};function Ir(n,t){if("string"===n||"string"===t){if("string"===n&&"string"===t)return"string";throw new Error(`Can not upcast ${n} with ${t}`)}return cte[n][t]}function nI(n){return Ir(n,"int32")}function q2(n){return null!=n&&"object"==typeof n&&"texture"in n&&n.texture instanceof WebGLTexture}function K2(n){return typeof GPUBuffer<"u"&&null!=n&&"object"==typeof n&&"buffer"in n&&n.buffer instanceof GPUBuffer}function Tn(n,t){if(n.dtype===t.dtype)return[n,t];const e=Ir(n.dtype,t.dtype);return[n.cast(e),t.cast(e)]}function X2(n){const t=[];return Y2(n,t,new Set),t}function Y2(n,t,e){if(null==n)return;if(n instanceof pn)return void t.push(n);if(!function hte(n){return Array.isArray(n)||"object"==typeof n}(n))return;const s=n;for(const r in s){const i=s[r];e.has(i)||(e.add(i),Y2(i,t,e))}}function sI(n){return null!=n.kernelName}class Z2{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map(t=>t.name)))}}}dispose(){for(const t in this.registeredVariables)this.registeredVariables[t].dispose()}}let fte=(()=>{class n{constructor(e){this.ENV=e,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new Z2}ready(){var e=this;return te(function*(){if(null!=e.pendingBackendInit)return e.pendingBackendInit.then(()=>{});if(null!=e.backendInstance)return;const s=e.getSortedBackends();for(let r=0;r<s.length;r++){const i=s[r];if(yield e.initializeBackend(i).success)return void(yield e.setBackend(i))}throw new Error("Could not initialize any backends, all backend initializations failed.")})()}get backend(){if(null!=this.pendingBackendInit)throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);if(null==this.backendInstance){const{name:e,asyncInit:s}=this.initializeBackendsAndReturnBest();if(s)throw new Error(`The highest priority backend '${e}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);this.setBackend(e)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(e){if(!(e in this.registry)){if(!(e in this.registryFactory))return null;{const{asyncInit:s}=this.initializeBackend(e);if(s)return null}}return this.registry[e]}findBackendFactory(e){return e in this.registryFactory?this.registryFactory[e].factory:null}registerBackend(e,s,r=1){return e in this.registryFactory?(Gr(`${e} backend was already registered. Reusing existing backend factory.`),!1):(this.registryFactory[e]={factory:s,priority:r},!0)}setBackend(e){var s=this;return te(function*(){if(null==s.registryFactory[e])throw new Error(`Backend name '${e}' not found in registry`);if(s.backendName=e,null==s.registry[e]){s.backendInstance=null;const{success:r,asyncInit:i}=s.initializeBackend(e);if(!(i?yield r:r))return!1}return s.backendInstance=s.registry[e],s.setupRegisteredKernels(),s.profiler=new ete(s.backendInstance),!0})()}setupRegisteredKernels(){ZS(this.backendName).forEach(s=>{null!=s.setupFunc&&s.setupFunc(this.backendInstance)})}disposeRegisteredKernels(e){ZS(e).forEach(r=>{null!=r.disposeFunc&&r.disposeFunc(this.registry[e])})}initializeBackend(e){const s=this.registryFactory[e];if(null==s)throw new Error(`Cannot initialize backend ${e}, no registration found.`);try{const r=s.factory();if(!r||r instanceof OC||"function"!=typeof r.then)return this.registry[e]=r,{success:!0,asyncInit:!1};{const i=++this.pendingBackendInitId,o=r.then(a=>!(i<this.pendingBackendInitId||(this.registry[e]=a,this.pendingBackendInit=null,0))).catch(a=>(i<this.pendingBackendInitId||(this.pendingBackendInit=null,Gr(`Initialization of backend ${e} failed`),Gr(a.stack||a.message)),!1));return this.pendingBackendInit=o,{success:o,asyncInit:!0}}}catch(r){return Gr(`Initialization of backend ${e} failed`),Gr(r.stack||r.message),{success:!1,asyncInit:!1}}}removeBackend(e){if(!(e in this.registryFactory))throw new Error(`${e} backend not found in registry`);this.backendName===e&&null!=this.pendingBackendInit&&this.pendingBackendInitId++,e in this.registry&&(this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e]),delete this.registryFactory[e],this.backendName===e&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(0===Object.keys(this.registryFactory).length)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort((e,s)=>this.registryFactory[s].priority-this.registryFactory[e].priority)}initializeBackendsAndReturnBest(){const e=this.getSortedBackends();for(let s=0;s<e.length;s++){const r=e[s],{success:i,asyncInit:o}=this.initializeBackend(r);if(o||i)return{name:r,asyncInit:o}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(e,s){const r=this.state.tensorInfo.get(s),i=r.backend,o=this.readSync(s),a=i.refCount(s);i.disposeData(s,!0),r.backend=e,e.move(s,o,r.shape,r.dtype,a),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(e,s){let i,r=null;if(null==s){if("function"!=typeof e)throw new Error("Please provide a function to tidy()");s=e}else{if("string"!=typeof e&&!(e instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if("function"!=typeof s)throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");r=e}return this.scopedRun(()=>this.startScope(r),()=>this.endScope(i),()=>(i=s(),i instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),i))}scopedRun(e,s,r){e();try{const i=r();return s(),i}catch(i){throw s(),i}}nextTensorId(){return n.nextTensorId++}nextVariableId(){return n.nextVariableId++}clone(e){const s=M.runKernel(Cf,{x:e});return this.addTapeNode(this.state.activeScope.name,{x:e},[s],a=>({x:()=>M.runKernel(cf,{x:a},{dtype:"float32"})}),[],{}),s}runKernel(e,s,r){if(null==P2(e,this.backendName))throw new Error(`Kernel '${e}' not registered for backend '${this.backendName}'`);return this.runKernelFunc({kernelName:e,inputs:s,attrs:r})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(e,s,r){const i=this.backend.numDataIds();let o=0;r.forEach(u=>{o+="complex64"===u.dtype?3:1});const l=i-s-o-this.state.numDataMovesStack[this.state.numDataMovesStack.length-1];if(l>0)throw new Error(`Backend '${this.backendName}' has an internal memory leak (${l} data ids) after running '${e}'`)}runKernelFunc(e){let s,r=[];const i=this.isTapeOn(),o=this.state.numBytes,a=this.state.numTensors;let l,u;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0);const c=sI(e)?e.kernelName:null!=this.state.activeScope?this.state.activeScope.name:"";if(sI(e)){const{kernelName:g,inputs:m,attrs:y}=e,b=P2(g,this.backendName);S(null!=b,()=>`Cannot find registered kernel '${g}' for backend '${this.backendName}'`),l=()=>{const v=this.backend.numDataIds();u=b.kernelFunc({inputs:m,attrs:y,backend:this.backend});const _=Array.isArray(u)?u:[u];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(g,v,_);const x=_.map(C=>null!=C.rank?C:this.makeTensorFromTensorInfo(C));if(i){const C=this.getTensorsForGradient(g,m,x);r=this.saveTensorsForBackwardMode(C)}return x}}else{const{forwardFunc:g}=e,m=y=>{i&&(r=y.map(b=>this.keep(this.clone(b))))};l=()=>{const y=this.backend.numDataIds();u=this.tidy(()=>g(this.backend,m));const b=Array.isArray(u)?u:[u];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(c,y,b),b}}const{inputs:d,attrs:h}=e,f=sI(e)?null:e.backwardsFunc;let p;return this.scopedRun(()=>this.state.kernelDepth++,()=>this.state.kernelDepth--,()=>{this.ENV.getBool("DEBUG")||this.state.profiling?(p=this.profiler.profileKernel(c,d,()=>l()),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(p),s=p.outputs):s=l()}),i&&this.addTapeNode(c,d,s,f,r,h),this.state.profiling&&this.state.activeProfile.kernels.push({name:c,bytesAdded:this.state.numBytes-o,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-a,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(d).map(g=>null!=d[g]?d[g].shape:null),outputShapes:s.map(g=>g.shape),kernelTimeMs:p.timeMs,extraInfo:p.extraInfo}),Array.isArray(u)?s:s[0]}saveTensorsForBackwardMode(e){return e.map(r=>this.keep(this.clone(r)))}getTensorsForGradient(e,s,r){const i=L2(e);if(null!=i){const o=i.inputsToSave||[],a=i.outputsToSave||[];let l;i.saveAllInputs?(S(Array.isArray(s),()=>"saveAllInputs is true, expected inputs to be an array."),l=Object.keys(s).map(c=>s[c])):l=o.map(c=>s[c]);const u=r.filter((c,d)=>a[d]);return l.concat(u)}return[]}makeTensor(e,s,r,i){if(null==e)throw new Error("Values passed to engine.makeTensor() are null");i=i||this.backend;let o=e;"string"===(r=r||"float32")&&Jh(e[0])&&(o=e.map(u=>Pa(u)));const a=i.write(o,s,r),l=new pn(s,r,a,this.nextTensorId());if(this.trackTensor(l,i),"string"===r){const u=this.state.tensorInfo.get(a),c=function Mee(n){if(null==n)return 0;let t=0;return n.forEach(e=>t+=e.length),t}(o);this.state.numBytes+=c-u.bytes,u.bytes=c}return l}makeTensorFromDataId(e,s,r,i){return this.makeTensorFromTensorInfo({dataId:e,shape:s,dtype:r=r||"float32"},i)}makeTensorFromTensorInfo(e,s){const{dataId:r,shape:i,dtype:o}=e,a=new pn(i,o,r,this.nextTensorId());return this.trackTensor(a,s),a}makeVariable(e,s=!0,r,i){r=r||this.nextVariableId().toString(),null!=i&&i!==e.dtype&&(e=e.cast(i));const o=new Cb(e,s,r,this.nextTensorId());if(null!=this.state.registeredVariables[o.name])throw new Error(`Variable with name ${o.name} was already registered`);return this.state.registeredVariables[o.name]=o,this.incRef(o,this.backend),o}trackTensor(e,s){this.state.numTensors++,"string"===e.dtype&&this.state.numStringTensors++;let r=0;"complex64"!==e.dtype&&"string"!==e.dtype&&(r=e.size*py(e.dtype)),this.state.numBytes+=r,this.state.tensorInfo.has(e.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(e.dataId,{backend:s||this.backend,dtype:e.dtype,shape:e.shape,bytes:r})),e instanceof Cb||this.track(e)}incRef(e,s){this.trackTensor(e,s),this.backend.incRef(e.dataId)}removeDataId(e,s){this.state.tensorInfo.has(e)&&this.state.tensorInfo.get(e).backend===s&&(this.state.tensorInfo.delete(e),this.state.numDataBuffers--)}disposeTensor(e){if(!this.state.tensorInfo.has(e.dataId))return;const s=this.state.tensorInfo.get(e.dataId);if(this.state.numTensors--,"string"===e.dtype&&(this.state.numStringTensors--,this.state.numBytes-=s.bytes),"complex64"!==e.dtype&&"string"!==e.dtype){const r=e.size*py(e.dtype);this.state.numBytes-=r}s.backend.disposeData(e.dataId)&&this.removeDataId(e.dataId,s.backend)}disposeVariables(){for(const e in this.state.registeredVariables)this.disposeVariable(this.state.registeredVariables[e])}disposeVariable(e){this.disposeTensor(e),null!=this.state.registeredVariables[e.name]&&delete this.state.registeredVariables[e.name]}memory(){const e=this.backend.memory();return e.numTensors=this.state.numTensors,e.numDataBuffers=this.state.numDataBuffers,e.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(e.unreliable=!0,null==e.reasons&&(e.reasons=[]),e.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),e}profile(e){var s=this;return te(function*(){s.state.profiling=!0;const r=s.state.numBytes,i=s.state.numTensors;s.state.activeProfile.kernels=[],s.state.activeProfile.result=yield e(),s.state.profiling=!1,s.state.activeProfile.peakBytes=Math.max(...s.state.activeProfile.kernels.map(o=>o.totalBytesSnapshot)),s.state.activeProfile.newBytes=s.state.numBytes-r,s.state.activeProfile.newTensors=s.state.numTensors-i;for(const o of s.state.activeProfile.kernels)o.kernelTimeMs=yield o.kernelTimeMs,o.extraInfo=yield o.extraInfo;return s.state.activeProfile})()}isTapeOn(){return this.state.gradientDepth>0&&0===this.state.kernelDepth}addTapeNode(e,s,r,i,o,a){const l={id:this.state.nextTapeNodeId++,kernelName:e,inputs:s,outputs:r,saved:o},u=L2(e);null!=u&&(i=u.gradFunc),null!=i&&(l.gradient=c=>(c=c.map((d,h)=>{if(null==d){const f=r[h],p=Vs(f.size,f.dtype);return this.makeTensor(p,f.shape,f.dtype)}return d}),i(c.length>1?c:c[0],o,a))),this.state.activeTape.push(l)}keep(e){return e.kept=!0,e}startTape(){0===this.state.gradientDepth&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(e){const s={track:[],name:"unnamed scope",id:this.state.nextScopeId++};e&&(s.name=e),this.state.scopeStack.push(s),this.state.activeScope=s}endScope(e){const s=X2(e),r=new Set(s.map(o=>o.id));for(let o=0;o<this.state.activeScope.track.length;o++){const a=this.state.activeScope.track[o];!a.kept&&!r.has(a.id)&&a.dispose()}const i=this.state.scopeStack.pop();this.state.activeScope=0===this.state.scopeStack.length?null:this.state.scopeStack[this.state.scopeStack.length-1],s.forEach(o=>{!o.kept&&o.scopeId===i.id&&this.track(o)})}gradients(e,s,r,i=!1){if(S(s.length>0,()=>"gradients() received an empty list of xs."),null!=r&&"float32"!==r.dtype)throw new Error(`dy must have 'float32' dtype, but has '${r.dtype}'`);const o=this.scopedRun(()=>this.startTape(),()=>this.endTape(),()=>this.tidy("forward",e));S(o instanceof pn,()=>"The result y returned by f() must be a tensor.");const a=function ste(n,t,e){const s={},r={};for(let l=0;l<t.length;l++)s[t[l].id]=!0;for(let l=0;l<n.length;l++){const u=n[l],c=u.inputs;for(const d in c){const h=c[d];let f=!1;for(let p=0;p<t.length;p++)if(s[h.id]){u.outputs.forEach(g=>s[g.id]=!0),f=!0,r[u.id]=!0;break}if(f)break}}const i={};i[e.id]=!0;const o={};for(let l=n.length-1;l>=0;l--){const u=n[l],c=u.inputs;for(let d=0;d<u.outputs.length;d++)if(i[u.outputs[d].id]){for(const h in c)i[c[h].id]=!0,o[u.id]=!0;break}}const a=[];for(let l=0;l<n.length;l++){const u=n[l];if(r[u.id]&&o[u.id]){const c={};for(const h in u.inputs){const f=u.inputs[h];s[f.id]&&(c[h]=f)}const d=Object.assign({},u);d.inputs=c,d.outputs=u.outputs,a.push(d)}}return a}(this.state.activeTape,s,o);if(!i&&0===a.length&&s.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",()=>{const l={};l[o.id]=r??function pte(n){const t=zC(X(n),"float32");return M.makeTensor(t,n,"float32")}(o.shape),function rte(n,t,e,s){for(let r=t.length-1;r>=0;r--){const i=t[r],o=[];if(i.outputs.forEach(l=>{const u=n[l.id];o.push(null!=u?u:null)}),null==i.gradient)throw new Error(`Cannot compute gradient: gradient function not found for ${i.kernelName}.`);const a=i.gradient(o);for(const l in i.inputs){if(!(l in a))throw new Error(`Cannot backprop through input ${l}. Available gradients found: ${Object.keys(a)}.`);const u=e(()=>a[l]());if("float32"!==u.dtype)throw new Error(`Error in gradient for op ${i.kernelName}. The gradient of input ${l} must have 'float32' dtype, but has '${u.dtype}'`);const c=i.inputs[l];if(!wt(u.shape,c.shape))throw new Error(`Error in gradient for op ${i.kernelName}. The gradient of input '${l}' has shape '${u.shape}', which does not match the shape of the input '${c.shape}'`);if(null==n[c.id])n[c.id]=u;else{const d=n[c.id];n[c.id]=s(d,u),d.dispose()}}}}(l,a,c=>this.tidy(c),mte);const u=s.map(c=>l[c.id]);return 0===this.state.gradientDepth&&(this.state.activeTape.forEach(c=>{for(const d of c.saved)d.dispose()}),this.state.activeTape=null),{value:o,grads:u}})}customGrad(e){return S(VC(e),()=>"The f passed in customGrad(f) must be a function."),(...s)=>{let r;S(s.every(l=>l instanceof pn),()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors");const i={};return s.forEach((l,u)=>{i[u]=l}),this.runKernelFunc({forwardFunc:(l,u)=>(r=e(...s,u),S(r.value instanceof pn,()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor"),S(VC(r.gradFunc),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function."),r.value),backwardsFunc:(l,u)=>{const c=r.gradFunc(l,u),d=Array.isArray(c)?c:[c];S(d.length===s.length,()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...)."),S(d.every(f=>f instanceof pn),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.");const h={};return d.forEach((f,p)=>{h[p]=()=>f}),h},inputs:i})}}readSync(e){return this.state.tensorInfo.get(e).backend.readSync(e)}read(e){return this.state.tensorInfo.get(e).backend.read(e)}readToGPU(e,s){return this.state.tensorInfo.get(e).backend.readToGPU(e,s)}time(e){var s=this;return te(function*(){const r=ir(),i=yield s.backend.time(e);return i.wallMs=ir()-r,i})()}track(e){return null!=this.state.activeScope&&(e.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(e)),e}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new Z2;for(const e in this.registry)this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}}return n.nextTensorId=0,n.nextVariableId=0,n})();function Q2(){const n=$2();if(null==n._tfengine){const t=new $ee(n);n._tfengine=new fte(t)}return function Bee(n){O2=n}(n._tfengine.ENV),function ate(n){zi=n}(()=>n._tfengine),n._tfengine}const M=Q2();function mte(n,t){return M.runKernel(zc,{a:n,b:t})}function J2(n){if(n||function gte(){return typeof navigator<"u"&&null!=navigator}()){if(n||(n=navigator),"ReactNative"===n.product)return!0;const t=n.userAgent||n.vendor||(typeof window<"u"?window.opera:"");return t?/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(t)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(t.substr(0,4)):n.userAgentData&&n.userAgentData.mobile}return!1}function eP(){return typeof window<"u"&&null!=window.document||typeof WorkerGlobalScope<"u"}const or=W();function Wa(n,t){let e=n;if(hi(n))return"string"===t?[]:[n.length];if(q2(n))return[n.height,n.width*(n.channels||"RGBA").length];if(K2(n))return[n.buffer.size/(null==t?4:py(t))];if(!Array.isArray(n))return[];const s=[];for(;Array.isArray(e)||hi(e)&&"string"!==t;)s.push(e.length),e=e[0];return Array.isArray(n)&&W().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&tP(n,s,[]),s}function tP(n,t,e){if(e=e||[],!Array.isArray(n)&&!hi(n))return void S(0===t.length,()=>`Element arr[${e.join("][")}] is a primitive, but should be an array/TypedArray of ${t[0]} elements`);S(t.length>0,()=>`Element arr[${e.join("][")}] should be a primitive, but is an array of ${n.length} elements`),S(n.length===t[0],()=>`Element arr[${e.join("][")}] should have ${t[0]} elements, but has ${n.length} elements`);const s=t.slice(1);for(let r=0;r<n.length;++r)tP(n[r],s,e.concat(r))}function nP(n,t,e,s){if("string_or_numeric"!==n){if(null==n)throw new Error("Expected dtype cannot be null.");if("numeric"!==n&&n!==t||"numeric"===n&&"string"===t)throw new Error(`Argument '${e}' passed to '${s}' must be ${n} tensor, but got ${t} tensor`)}}function I(n,t,e,s="numeric"){if(n instanceof pn)return nP(s,n.dtype,t,e),n;let r=Vc(n);if("string"!==r&&["bool","int32","float32"].indexOf(s)>=0&&(r=s),nP(s,r,t,e),null==n||!hi(n)&&!Array.isArray(n)&&"number"!=typeof n&&"boolean"!=typeof n&&"string"!=typeof n)throw new Error(`Argument '${t}' passed to '${e}' must be a Tensor or TensorLike, but got '${null==n?"null":n.constructor.name}'`);const i=Wa(n,r);!hi(n)&&!Array.isArray(n)&&(n=[n]);const a="string"!==r?eu(n,r):tu(n,[],!0);return M.makeTensor(a,i,r)}function Sb(n,t,e,s="numeric"){if(!Array.isArray(n))throw new Error(`Argument ${t} passed to ${e} must be a \`Tensor[]\` or \`TensorLike[]\``);return n.map((i,o)=>I(i,`${t}[${o}]`,e,s))}or.registerFlag("DEBUG",()=>!1,n=>{n&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")}),or.registerFlag("IS_BROWSER",()=>eP()),or.registerFlag("IS_NODE",()=>typeof process<"u"&&typeof process.versions<"u"&&typeof process.versions.node<"u"),or.registerFlag("IS_CHROME",()=>typeof navigator<"u"&&null!=navigator&&null!=navigator.userAgent&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor)),or.registerFlag("IS_SAFARI",()=>typeof navigator<"u"&&null!=navigator&&null!=navigator.userAgent&&/Safari/.test(navigator.userAgent)&&/Apple/.test(navigator.vendor)),or.registerFlag("PROD",()=>!1),or.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",()=>or.getBool("DEBUG")),or.registerFlag("DEPRECATION_WARNINGS_ENABLED",()=>!0),or.registerFlag("IS_TEST",()=>!1),or.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",()=>or.getBool("DEBUG")),or.registerFlag("WRAP_TO_IMAGEBITMAP",()=>!1),or.registerFlag("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU",()=>!1),or.registerFlag("USE_SETTIMEOUTCUSTOM",()=>!1);const sP="__op";function k(n){const t=Object.keys(n);if(1!==t.length)throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${t.length} keys.`);let e=t[0];const s=n[e];e.endsWith("_")&&(e=e.substring(0,e.length-1)),e+=sP;const r=(...i)=>{M.startScope(e);try{const o=s(...i);return Zl(o)&&console.error("Cannot return a Promise inside of tidy."),M.endScope(o),o}catch(o){throw M.endScope(null),o}};return Object.defineProperty(r,"name",{value:e,configurable:!0}),r}const Ga=k({complex_:function yte(n,t){const e=I(n,"real","complex"),s=I(t,"imag","complex");return Sr(e.shape,s.shape,`real and imag shapes, ${e.shape} and ${s.shape}, must match in call to tf.complex().`),M.runKernel(ZC,{real:e,imag:s})}});function Ha(n,t,e,s){if(null==s)s=Vc(n);else if("complex64"===s)throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(K2(n)||q2(n)){if("float32"!==s&&"int32"!==s)throw new Error(`Creating tensor from GPU data only supports 'float32'|'int32' dtype, while the dtype is ${s}.`);return M.backend.createTensorFromGPUData(n,t||e,s)}if(!hi(n)&&!Array.isArray(n)&&"number"!=typeof n&&"boolean"!=typeof n&&"string"!=typeof n)throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(null!=t){Wr(t);const r=X(t),i=X(e);S(r===i,()=>`Based on the provided shape, [${t}], the tensor should have ${r} values but has ${i}`);for(let o=0;o<e.length;++o){const l=o!==e.length-1||e[o]!==X(t.slice(o));S(e[o]===t[o]||!l,()=>`Error creating a new Tensor. Inferred shape (${e}) does not match the provided shape (${t}). `)}}return!hi(n)&&!Array.isArray(n)&&(n=[n]),t=t||e,n="string"!==s?eu(n,s):tu(n,[],!0),M.makeTensor(n,t,s)}function Ui(n,t,e){return Ha(n,t,Wa(n,e),e)}const iI={float32:4,float16:2,int32:4,uint16:2,uint8:1,bool:1,complex64:8},Ib=4;function oI(n,t){return aI.apply(this,arguments)}function aI(){return aI=te(function*(n,t){const e=[],s=[],r=Array.isArray(n)?n.map(o=>o.name):Object.keys(n);for(let o=0;o<r.length;++o){const a=r[o],l=Array.isArray(n)?n[o].tensor:n[a];if("float32"!==l.dtype&&"int32"!==l.dtype&&"bool"!==l.dtype&&"string"!==l.dtype&&"complex64"!==l.dtype)throw new Error(`Unsupported dtype in weight '${a}': ${l.dtype}`);const u={name:a,shape:l.shape,dtype:l.dtype};if("string"===l.dtype){const c=new Promise(function(){var d=te(function*(h){const f=yield l.bytes(),p=f.reduce((y,b)=>y+b.length,0)+Ib*f.length,g=new Uint8Array(p);let m=0;for(let y=0;y<f.length;y++){const b=f[y],v=new Uint8Array(new Uint32Array([b.length]).buffer);g.set(v,m),m+=Ib,g.set(b,m),m+=b.length}h(g)});return function(h){return d.apply(this,arguments)}}());s.push(c)}else s.push(l.data());null!=t&&(u.group=t),e.push(u)}return{data:bte(yield Promise.all(s)),specs:e}}),aI.apply(this,arguments)}function rP(n,t){const e={};let s,r=0;for(const i of t){const o=i.name,a=i.dtype,l=i.shape,u=X(l);let c;if("quantization"in i){const d=i.quantization;if("uint8"===d.dtype||"uint16"===d.dtype){if(!("min"in d)||!("scale"in d))throw new Error(`Weight ${i.name} with quantization ${d.dtype} doesn't have corresponding metadata min and scale.`)}else{if("float16"!==d.dtype)throw new Error(`Weight ${i.name} has unknown quantization dtype ${d.dtype}. Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'.`);if("float32"!==a)throw new Error(`Weight ${i.name} is quantized with ${d.dtype} which only supports weights of type float32 not ${a}.`)}const h=iI[d.dtype],f=n.slice(r,r+u*h),p="uint8"===d.dtype?new Uint8Array(f):new Uint16Array(f);if("float32"===a)if("uint8"===d.dtype||"uint16"===d.dtype){c=new Float32Array(p.length);for(let g=0;g<p.length;g++)c[g]=p[g]*d.scale+d.min}else{if("float16"!==d.dtype)throw new Error(`Unsupported quantization type ${d.dtype} for weight type float32.`);void 0===s&&(s=Ste()),c=s(p)}else{if("int32"!==a)throw new Error(`Unsupported dtype in weight '${o}': ${a}`);if("uint8"!==d.dtype&&"uint16"!==d.dtype)throw new Error(`Unsupported quantization type ${d.dtype} for weight type int32.`);c=new Int32Array(p.length);for(let g=0;g<p.length;g++)c[g]=Math.round(p[g]*d.scale+d.min)}r+=u*h}else if("string"===a){const d=X(i.shape);c=[];for(let h=0;h<d;h++){const f=new Uint32Array(n.slice(r,r+Ib))[0];r+=Ib;const p=new Uint8Array(n.slice(r,r+f));c.push(p),r+=f}}else{const d=iI[a],h=n.slice(r,r+u*d);if("float32"===a)c=new Float32Array(h);else if("int32"===a)c=new Int32Array(h);else if("bool"===a)c=new Uint8Array(h);else{if("complex64"!==a)throw new Error(`Unsupported dtype in weight '${o}': ${a}`);{c=new Float32Array(h);const f=new Float32Array(c.length/2),p=new Float32Array(c.length/2);for(let y=0;y<f.length;y++)f[y]=c[2*y],p[y]=c[2*y+1];const g=Ui(f,l,"float32"),m=Ui(p,l,"float32");e[o]=Ga(g,m),g.dispose(),m.dispose()}}r+=u*d}"complex64"!==a&&(e[o]=Ui(c,l,a))}return e}function bte(n){if(null===n)throw new Error(`Invalid input value: ${JSON.stringify(n)}`);let t=0;const e=[];n.forEach(i=>{if(t+=i.byteLength,e.push(i.byteLength===i.buffer.byteLength?i:new i.constructor(i)),!(i instanceof Float32Array||i instanceof Int32Array||i instanceof Uint8Array))throw new Error(`Unsupported TypedArray subtype: ${i.constructor.name}`)});const s=new Uint8Array(t);let r=0;return e.forEach(i=>{s.set(new Uint8Array(i.buffer),r),r+=i.byteLength}),s.buffer}const lI=typeof Buffer<"u"&&(typeof Blob>"u"||typeof atob>"u"||typeof btoa>"u");function iP(n){return lI?Buffer.byteLength(n):new Blob([n]).size}function Eb(n){if(1===n.length)return n[0];let t=0;n.forEach(r=>{t+=r.byteLength});const e=new Uint8Array(t);let s=0;return n.forEach(r=>{e.set(new Uint8Array(r),s),s+=r.byteLength}),e.buffer}function oP(n){for(n=n.trim();n.endsWith("/");)n=n.slice(0,n.length-1);const e=n.split("/");return e[e.length-1]}function aP(n,t){const e={modelTopology:n.modelTopology,format:n.format,generatedBy:n.generatedBy,convertedBy:n.convertedBy,weightsManifest:t};return null!=n.signature&&(e.signature=n.signature),null!=n.userDefinedMetadata&&(e.userDefinedMetadata=n.userDefinedMetadata),null!=n.modelInitializer&&(e.modelInitializer=n.modelInitializer),null!=n.initializerSignature&&(e.initializerSignature=n.initializerSignature),null!=n.trainingConfig&&(e.trainingConfig=n.trainingConfig),e}function lP(n,t,e){const s={modelTopology:n.modelTopology,format:n.format,generatedBy:n.generatedBy,convertedBy:n.convertedBy};if(null!=n.trainingConfig&&(s.trainingConfig=n.trainingConfig),null!=n.weightsManifest){if(!t)throw new Error("modelJSON has weightsManifest but weightSpecs is null");if(!e)throw new Error("modelJSON has weightsManifest but weightData is null");s.weightSpecs=t,s.weightData=e}return null!=n.signature&&(s.signature=n.signature),null!=n.userDefinedMetadata&&(s.userDefinedMetadata=n.userDefinedMetadata),null!=n.modelInitializer&&(s.modelInitializer=n.modelInitializer),null!=n.initializerSignature&&(s.initializerSignature=n.initializerSignature),s}function uI(n,t){return cI.apply(this,arguments)}function cI(){return(cI=te(function*(n,t){let e,s;return null!=n.weightsManifest&&([e,s]=yield t(n.weightsManifest)),lP(n,e,s)})).apply(this,arguments)}function np(n){if(n.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:null==n.modelTopology?0:iP(JSON.stringify(n.modelTopology)),weightSpecsBytes:null==n.weightSpecs?0:iP(JSON.stringify(n.weightSpecs)),weightDataBytes:null==n.weightData?0:n.weightData.byteLength}}function uP(n){const t=[];for(const e of n)t.push(...e.weights);return t}function Ste(){const n=function wte(){const n=e=>{let s=e<<13,r=0;for(;!(8388608&s);)r-=8388608,s<<=1;return s&=-8388609,r+=947912704,s|r},t=new Uint32Array(2048);t[0]=0;for(let e=1;e<1024;e++)t[e]=n(e);for(let e=1024;e<2048;e++)t[e]=939524096+(e-1024<<13);return t}(),t=function xte(){const n=new Uint32Array(64);n[0]=0,n[31]=1199570944,n[32]=2147483648,n[63]=3347054592;for(let t=1;t<31;t++)n[t]=t<<23;for(let t=33;t<63;t++)n[t]=2147483648+(t-32<<23);return n}(),e=function Cte(){const n=new Uint32Array(64);for(let t=0;t<64;t++)n[t]=1024;return n[0]=n[32]=0,n}();return s=>{const r=new ArrayBuffer(4*s.length),i=new Uint32Array(r);for(let o=0;o<s.length;o++){const a=s[o];i[o]=n[e[a>>10]+(1023&a)]+t[a>>10]}return new Float32Array(r)}}class bn{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return null==bn.instance&&(bn.instance=new bn),bn.instance}static registerSaveRouter(t){bn.getInstance().saveRouters.push(t)}static registerLoadRouter(t){bn.getInstance().loadRouters.push(t)}static getSaveHandlers(t){return bn.getHandlers(t,"save")}static getLoadHandlers(t,e){return bn.getHandlers(t,"load",e)}static getHandlers(t,e,s){const r=[];return("load"===e?bn.getInstance().loadRouters:bn.getInstance().saveRouters).forEach(o=>{const a=o(t,s);null!==a&&r.push(a)}),r}}const Ite=n=>bn.registerSaveRouter(n),Ete=n=>bn.registerLoadRouter(n),cP=n=>bn.getSaveHandlers(n),Dte=(n,t)=>bn.getLoadHandlers(n,t),Db="tensorflowjs",nu="models_store",ja="model_info_store";function fI(){if(!W().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");const n=typeof window>"u"?self:window,t=n.indexedDB||n.mozIndexedDB||n.webkitIndexedDB||n.msIndexedDB||n.shimIndexedDB;if(null==t)throw new Error("The current browser does not appear to support IndexedDB.");return t}function pI(n){const t=n.result;t.createObjectStore(nu,{keyPath:"modelPath"}),t.createObjectStore(ja,{keyPath:"modelPath"})}let Hc=(()=>{class n{constructor(e){if(this.indexedDB=fI(),null==e||!e)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=e}save(e){var s=this;return te(function*(){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return s.databaseAction(s.modelPath,e)})()}load(){var e=this;return te(function*(){return e.databaseAction(e.modelPath)})()}databaseAction(e,s){return new Promise((r,i)=>{const o=this.indexedDB.open(Db,1);o.onupgradeneeded=()=>pI(o),o.onsuccess=()=>{const a=o.result;if(null==s){const l=a.transaction(nu,"readonly"),c=l.objectStore(nu).get(this.modelPath);c.onsuccess=()=>{if(null==c.result)return a.close(),i(new Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));r(c.result.modelArtifacts)},c.onerror=d=>(a.close(),i(c.error)),l.oncomplete=()=>a.close()}else{const l=np(s),u=a.transaction(ja,"readwrite");let d,h,c=u.objectStore(ja);try{d=c.put({modelPath:this.modelPath,modelArtifactsInfo:l})}catch(f){return i(f)}d.onsuccess=()=>{h=a.transaction(nu,"readwrite");const f=h.objectStore(nu);let p;try{p=f.put({modelPath:this.modelPath,modelArtifacts:s,modelArtifactsInfo:l})}catch(g){return i(g)}p.onsuccess=()=>r({modelArtifactsInfo:l}),p.onerror=g=>{c=u.objectStore(ja);const m=c.delete(this.modelPath);m.onsuccess=()=>(a.close(),i(p.error)),m.onerror=y=>(a.close(),i(p.error))}},d.onerror=f=>(a.close(),i(d.error)),u.oncomplete=()=>{null==h?a.close():h.oncomplete=()=>a.close()}}},o.onerror=a=>i(o.error)})}}return n.URL_SCHEME="indexeddb://",n})();const dP=n=>W().getBool("IS_BROWSER")&&!Array.isArray(n)&&n.startsWith(Hc.URL_SCHEME)?function Tte(n){return new Hc(n)}(n.slice(Hc.URL_SCHEME.length)):null;bn.registerSaveRouter(dP),bn.registerLoadRouter(dP);class kte{constructor(){this.indexedDB=fI()}listModels(){var t=this;return te(function*(){return new Promise((e,s)=>{const r=t.indexedDB.open(Db,1);r.onupgradeneeded=()=>pI(r),r.onsuccess=()=>{const i=r.result,o=i.transaction(ja,"readonly"),l=o.objectStore(ja).getAll();l.onsuccess=()=>{const u={};for(const c of l.result)u[c.modelPath]=c.modelArtifactsInfo;e(u)},l.onerror=u=>(i.close(),s(l.error)),o.oncomplete=()=>i.close()},r.onerror=i=>s(r.error)})})()}removeModel(t){var e=this;return te(function*(){return t=function Nte(n){return n.startsWith(Hc.URL_SCHEME)?n.slice(Hc.URL_SCHEME.length):n}(t),new Promise((s,r)=>{const i=e.indexedDB.open(Db,1);i.onupgradeneeded=()=>pI(i),i.onsuccess=()=>{const o=i.result,a=o.transaction(ja,"readwrite"),l=a.objectStore(ja),u=l.get(t);let c;u.onsuccess=()=>{if(null==u.result)return o.close(),r(new Error(`Cannot find model with path '${t}' in IndexedDB.`));{const d=l.delete(t),h=()=>{c=o.transaction(nu,"readwrite");const p=c.objectStore(nu).delete(t);p.onsuccess=()=>s(u.result.modelArtifactsInfo),p.onerror=g=>r(u.error)};d.onsuccess=h,d.onerror=f=>(h(),o.close(),r(u.error))}},u.onerror=d=>(o.close(),r(u.error)),a.oncomplete=()=>{null==c?o.close():c.oncomplete=()=>o.close()}},i.onerror=o=>r(i.error)})})()}}const bo="/",su="tensorflowjs_models",hP="info",Ate="model_topology",Rte="weight_specs",Mte="weight_data",Fte="model_metadata";function fP(n){return{info:[su,n,hP].join(bo),topology:[su,n,Ate].join(bo),weightSpecs:[su,n,Rte].join(bo),weightData:[su,n,Mte].join(bo),modelMetadata:[su,n,Fte].join(bo)}}function pP(n){for(const t of Object.values(n))window.localStorage.removeItem(t)}function mP(n){const t=n.split(bo);if(t.length<3)throw new Error(`Invalid key format: ${n}`);return t.slice(1,t.length-1).join(bo)}let jc=(()=>{class n{constructor(e){if(!W().getBool("IS_BROWSER")||typeof window>"u"||typeof window.localStorage>"u")throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,null==e||!e)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=e,this.keys=fP(this.modelPath)}save(e){var s=this;return te(function*(){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{const r=JSON.stringify(e.modelTopology),i=JSON.stringify(e.weightSpecs),o=np(e);try{return s.LS.setItem(s.keys.info,JSON.stringify(o)),s.LS.setItem(s.keys.topology,r),s.LS.setItem(s.keys.weightSpecs,i),s.LS.setItem(s.keys.weightData,function vte(n){if(lI)return Buffer.from(n).toString("base64");const t=new Uint8Array(n);let e="";for(let s=0,r=t.length;s<r;s++)e+=String.fromCharCode(t[s]);return btoa(e)}(e.weightData)),s.LS.setItem(s.keys.modelMetadata,JSON.stringify({format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,signature:null!=e.signature?e.signature:void 0,userDefinedMetadata:null!=e.userDefinedMetadata?e.userDefinedMetadata:void 0,modelInitializer:null!=e.modelInitializer?e.modelInitializer:void 0,initializerSignature:null!=e.initializerSignature?e.initializerSignature:void 0,trainingConfig:null!=e.trainingConfig?e.trainingConfig:void 0})),{modelArtifactsInfo:o}}catch{throw pP(s.keys),new Error(`Failed to save model '${s.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${o.modelTopologyBytes}, weightSpecsBytes=${o.weightSpecsBytes}, weightDataBytes=${o.weightDataBytes}.`)}}})()}load(){var e=this;return te(function*(){const s=JSON.parse(e.LS.getItem(e.keys.info));if(null==s)throw new Error(`In local storage, there is no model with name '${e.modelPath}'`);if("JSON"!==s.modelTopologyType)throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");const r={},i=JSON.parse(e.LS.getItem(e.keys.topology));if(null==i)throw new Error(`In local storage, the topology of model '${e.modelPath}' is missing.`);r.modelTopology=i;const o=JSON.parse(e.LS.getItem(e.keys.weightSpecs));if(null==o)throw new Error(`In local storage, the weight specs of model '${e.modelPath}' are missing.`);r.weightSpecs=o;const a=e.LS.getItem(e.keys.modelMetadata);if(null!=a){const u=JSON.parse(a);r.format=u.format,r.generatedBy=u.generatedBy,r.convertedBy=u.convertedBy,null!=u.signature&&(r.signature=u.signature),null!=u.userDefinedMetadata&&(r.userDefinedMetadata=u.userDefinedMetadata),null!=u.modelInitializer&&(r.modelInitializer=u.modelInitializer),null!=u.initializerSignature&&(r.initializerSignature=u.initializerSignature),null!=u.trainingConfig&&(r.trainingConfig=u.trainingConfig)}const l=e.LS.getItem(e.keys.weightData);if(null==l)throw new Error(`In local storage, the binary weight values of model '${e.modelPath}' are missing.`);return r.weightData=function _te(n){if(lI){const s=Buffer.from(n,"base64");return s.buffer.slice(s.byteOffset,s.byteOffset+s.byteLength)}const t=atob(n),e=new Uint8Array(t.length);for(let s=0;s<t.length;++s)e.set([t.charCodeAt(s)],s);return e.buffer}(l),r})()}}return n.URL_SCHEME="localstorage://",n})();const gP=n=>W().getBool("IS_BROWSER")&&!Array.isArray(n)&&n.startsWith(jc.URL_SCHEME)?function $te(n){return new jc(n)}(n.slice(jc.URL_SCHEME.length)):null;bn.registerSaveRouter(gP),bn.registerLoadRouter(gP);class Pte{constructor(){S(W().getBool("IS_BROWSER"),()=>"Current environment is not a web browser"),S(typeof window>"u"||typeof window.localStorage<"u",()=>"Current browser does not appear to support localStorage"),this.LS=window.localStorage}listModels(){var t=this;return te(function*(){const e={},s=su+bo,r=bo+hP;for(let i=0;i<t.LS.length;++i){const o=t.LS.key(i);o.startsWith(s)&&o.endsWith(r)&&(e[mP(o)]=JSON.parse(t.LS.getItem(o)))}return e})()}removeModel(t){var e=this;return te(function*(){const s=fP(t=function Ote(n){return n.startsWith(jc.URL_SCHEME)?n.slice(jc.URL_SCHEME.length):n}(t));if(null==e.LS.getItem(s.info))throw new Error(`Cannot find model at path '${t}'`);const r=JSON.parse(e.LS.getItem(s.info));return pP(s),r})()}}const qc="://";class Ks{constructor(){this.managers={}}static getInstance(){return null==Ks.instance&&(Ks.instance=new Ks),Ks.instance}static registerManager(t,e){S(null!=t,()=>"scheme must not be undefined or null."),t.endsWith(qc)&&(t=t.slice(0,t.indexOf(qc))),S(t.length>0,()=>"scheme must not be an empty string.");const s=Ks.getInstance();S(null==s.managers[t],()=>`A model store manager is already registered for scheme '${t}'.`),s.managers[t]=e}static getManager(t){const e=Ks.getInstance().managers[t];if(null==e)throw new Error(`Cannot find model manager for scheme '${t}'`);return e}static getSchemes(){return Object.keys(Ks.getInstance().managers)}}function Tb(n){if(-1===n.indexOf(qc))throw new Error(`The url string provided does not contain a scheme. Supported schemes are: ${Ks.getSchemes().join(",")}`);return{scheme:n.split(qc)[0],path:n.split(qc)[1]}}function yP(n,t){return mI.apply(this,arguments)}function mI(){return(mI=te(function*(n,t,e=!1){S(n!==t,()=>`Old path and new path are the same: '${n}'`);const s=bn.getLoadHandlers(n);S(s.length>0,()=>`Copying failed because no load handler is found for source URL ${n}.`),S(s.length<2,()=>`Copying failed because more than one (${s.length}) load handlers for source URL ${n}.`);const r=s[0],i=bn.getSaveHandlers(t);S(i.length>0,()=>`Copying failed because no save handler is found for destination URL ${t}.`),S(i.length<2,()=>`Copying failed because more than one (${s.length}) save handlers for destination URL ${t}.`);const o=i[0],a=Tb(n).scheme,l=Tb(n).path,u=a===Tb(n).scheme,c=yield r.load();e&&u&&(yield Ks.getManager(a).removeModel(l));const d=yield o.save(c);return e&&!u&&(yield Ks.getManager(a).removeModel(l)),d.modelArtifactsInfo})).apply(this,arguments)}function Lte(){return gI.apply(this,arguments)}function gI(){return(gI=te(function*(){const n=Ks.getSchemes(),t={};for(const e of n){const s=yield Ks.getManager(e).listModels();for(const r in s)t[e+qc+r]=s[r]}return t})).apply(this,arguments)}function Vte(n){return yI.apply(this,arguments)}function yI(){return(yI=te(function*(n){const t=Tb(n);return Ks.getManager(t.scheme).removeModel(t.path)})).apply(this,arguments)}function Bte(n,t){return bI.apply(this,arguments)}function bI(){return(bI=te(function*(n,t){return yP(n,t,!1)})).apply(this,arguments)}function zte(n,t){return vI.apply(this,arguments)}function vI(){return(vI=te(function*(n,t){return yP(n,t,!0)})).apply(this,arguments)}class Ute{constructor(){this.messageName="setTimeoutCustom",this.functionRefs=[],this.handledMessageCount=0,this.hasEventListener=!1}fetch(t,e){return fetch(t,e)}now(){return performance.now()}encode(t,e){if("utf-8"!==e&&"utf8"!==e)throw new Error(`Browser's encoder only supports utf-8, but got ${e}`);return null==this.textEncoder&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(t)}decode(t,e){return new TextDecoder(e).decode(t)}setTimeoutCustom(t,e){typeof window>"u"||!W().getBool("USE_SETTIMEOUTCUSTOM")?setTimeout(t,e):(this.functionRefs.push(t),setTimeout(()=>{window.postMessage({name:this.messageName,index:this.functionRefs.length-1},"*")},e),this.hasEventListener||(this.hasEventListener=!0,window.addEventListener("message",s=>{s.source===window&&s.data.name===this.messageName&&(s.stopPropagation(),(0,this.functionRefs[s.data.index])(),this.handledMessageCount++,this.handledMessageCount===this.functionRefs.length&&(this.functionRefs=[],this.handledMessageCount=0))},!0)))}isTypedArray(t){return V2(t)}}if(W().get("IS_BROWSER")){W().setPlatform("browser",new Ute);try{Ks.registerManager(jc.URL_SCHEME,new Pte)}catch{}try{Ks.registerManager(Hc.URL_SCHEME,new kte)}catch{}}let Kc;function dt(n,t="float32",e){return t=t||"float32",Wr(n),new ts(n,t,e)}W().get("IS_NODE")&&!W().get("IS_BROWSER")&&W().setPlatform("node",new class Gte{constructor(){this.util=Q(628),this.textEncoder=new this.util.TextEncoder}fetch(t,e){return null!=W().global.fetch?W().global.fetch(t,e):(null==Kc&&(Kc=Q(410)),Kc(t,e))}now(){const t=process.hrtime();return 1e3*t[0]+t[1]/1e6}encode(t,e){if("utf-8"!==e&&"utf8"!==e)throw new Error(`Node built-in encoder only supports utf-8, but got ${e}`);return this.textEncoder.encode(t)}decode(t,e){return 0===t.length?"":new this.util.TextDecoder(e).decode(t)}isTypedArray(t){return this.util.types.isFloat32Array(t)||this.util.types.isInt32Array(t)||this.util.types.isUint8Array(t)||this.util.types.isUint8ClampedArray(t)}});const xe=k({cast_:function Hte(n,t){const e=I(n,"x","cast");if(!function Ree(n){return"bool"===n||"complex64"===n||"float32"===n||"int32"===n||"string"===n}(t))throw new Error(`Failed to cast to unknown dtype ${t}`);if("string"===t&&"string"!==e.dtype||"string"!==t&&"string"===e.dtype)throw new Error("Only strings can be casted to strings");return M.runKernel(cf,{x:e},{dtype:t})}}),ra=k({clone_:function jte(n){const e={x:I(n,"x","clone","string_or_numeric")};return M.runKernel(Cf,e)}});function bP(n,t=!1){console.log(n.toString(t))}function vo(){return M}function _I(){return M.memory()}function z(n,t){return M.tidy(n,t)}function gt(n){X2(n).forEach(e=>e.dispose())}function vs(n){return M.keep(n)}function vP(n,t,e=1){return M.registerBackend(n,t,e)}Q2(),function lte(n){Gc=n}({buffer:dt,cast:xe,clone:ra,print:bP}),function ute(n){j2=n}(function qte(n){W().getBool("DEPRECATION_WARNINGS_ENABLED")&&console.warn(n+" You can disable deprecation warnings with tf.disableDeprecationWarnings().")});const le=k({add_:function Xte(n,t){let e=I(n,"a","add"),s=I(t,"b","add");return[e,s]=Tn(e,s),M.runKernel(zc,{a:e,b:s})}}),wI=k({floorDiv_:function Yte(n,t){let e=I(n,"a","floorDiv"),s=I(t,"b","floorDiv");return[e,s]=Tn(e,s),M.runKernel(wf,{a:e,b:s})}}),Pe=k({div_:function Zte(n,t){let e=I(n,"a","div"),s=I(t,"b","div");return[e,s]=Tn(e,s),"int32"===e.dtype&&"int32"===s.dtype?wI(e,s):M.runKernel(mf,{a:e,b:s},{})}}),F=k({mul_:function Qte(n,t){let e=I(n,"a","mul"),s=I(t,"b","mul");return[e,s]=Tn(e,s),M.runKernel(Rf,{a:e,b:s})}}),Bs=k({sqrt_:function Jte(n){const e={x:I(n,"x","sqrt","float32")};return M.runKernel(Hf,e)}}),en=k({square_:function ene(n){const t=I(n,"x","square");return M.runKernel("Square",{x:t},{})}}),Et=k({zerosLike_:function tne(n){const e={x:I(n,"x","zerosLike")};return M.runKernel(gb,e)}});function ia(n){return M.customGrad(n)}function ze(n,t){if((hi(n)&&"string"!==t||Array.isArray(n))&&"complex64"!==t)throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if("string"===t&&hi(n)&&!(n instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return Ha(n,[],[],t)}class Xc{getClassName(){return this.constructor.className}static fromConfig(t,e){return new t(e)}}class fi{constructor(){this.classNameMap={}}static getMap(){return null==fi.instance&&(fi.instance=new fi),fi.instance}static register(t){fi.getMap().classNameMap[t.className]=[t,t.fromConfig]}}function ue(n){S(null!=n.className,()=>"Class being registered does not have the static className property defined."),S("string"==typeof n.className,()=>"className is required to be a string, but got type "+typeof n.className),S(n.className.length>0,()=>"Class being registered has an empty-string as its className, which is disallowed."),fi.register(n)}class qa extends Xc{minimize(t,e=!1,s){const{value:r,grads:i}=this.computeGradients(t,s);if(null!=s){const o=s.map(a=>({name:a.name,tensor:i[a.name]}));this.applyGradients(o)}else this.applyGradients(i);return gt(i),e?r:(r.dispose(),null)}get iterations(){return null==this.iterations_&&(this.iterations_=0),this.iterations_}incrementIterations(){this.iterations_=this.iterations+1}computeGradients(t,e){return function nne(n,t){S(VC(n),()=>"The f passed in variableGrads(f) must be a function"),S(null==t||Array.isArray(t)&&t.every(u=>u instanceof Cb),()=>"The varList passed in variableGrads(f, varList) must be an array of variables");const e=null!=t;if(!e){t=[];for(const u in M.registeredVariables)t.push(M.registeredVariables[u])}const s=e?t.filter(u=>!u.trainable):null,r=t.length;S((t=t.filter(u=>u.trainable)).length>0,()=>`variableGrads() expects at least one of the input variables to be trainable, but none of the ${r} variables is trainable.`);const{value:o,grads:a}=M.gradients(n,t,null,!0);S(a.some(u=>null!=u),()=>"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize()."),S(0===o.rank,()=>`The f passed in variableGrads(f) must return a scalar, but it returned a rank-${o.rank} tensor`);const l={};return t.forEach((u,c)=>{null!=a[c]&&(l[u.name]=a[c])}),s?.forEach(u=>l[u.name]=null),{value:o,grads:l}}(t,e)}dispose(){null!=this.iterations_&&gt(this.iterations_)}saveIterations(){var t=this;return te(function*(){return null==t.iterations_&&(t.iterations_=0),{name:"iter",tensor:ze(t.iterations_,"int32")}})()}getWeights(){return te(function*(){throw new Error("getWeights() is not implemented for this optimizer yet.")})()}setWeights(t){var e=this;return te(function*(){throw new Error(`setWeights() is not implemented for this optimizer class ${e.getClassName()}`)})()}extractIterations(t){var e=this;return te(function*(){return e.iterations_=(yield t[0].tensor.data())[0],t.slice(1)})()}}Object.defineProperty(qa,Symbol.hasInstance,{value:n=>null!=n.minimize&&null!=n.computeGradients&&null!=n.applyGradients});class _P extends qa{static get className(){return"Adadelta"}constructor(t,e,s=null){super(),this.learningRate=t,this.rho=e,this.epsilon=s,this.accumulatedGrads=[],this.accumulatedUpdates=[],null==s&&(this.epsilon=M.backend.epsilon())}applyGradients(t){(Array.isArray(t)?t.map(s=>s.name):Object.keys(t)).forEach((s,r)=>{const i=M.registeredVariables[s];null==this.accumulatedGrads[r]&&(this.accumulatedGrads[r]={originalName:`${s}/accum_grad`,variable:z(()=>Et(i).variable(!1))}),null==this.accumulatedUpdates[r]&&(this.accumulatedUpdates[r]={originalName:`${s}/accum_var`,variable:z(()=>Et(i).variable(!1))});const a=Array.isArray(t)?t[r].tensor:t[s];if(null==a)return;const l=this.accumulatedGrads[r].variable,u=this.accumulatedUpdates[r].variable;z(()=>{const c=le(F(l,this.rho),F(en(a),1-this.rho)),d=F(Pe(Bs(le(u,this.epsilon)),Bs(le(l,this.epsilon))),a),h=le(F(u,this.rho),F(en(d),1-this.rho));l.assign(c),u.assign(h);const f=le(F(d,-this.learningRate),i);i.assign(f)})}),this.incrementIterations()}dispose(){null!=this.accumulatedUpdates&&(gt(this.accumulatedGrads.map(t=>t.variable)),gt(this.accumulatedUpdates.map(t=>t.variable)))}getWeights(){var t=this;return te(function*(){const e=[...t.accumulatedGrads,...t.accumulatedUpdates];return[yield t.saveIterations()].concat(e.map(s=>({name:s.originalName,tensor:s.variable})))})()}setWeights(t){var e=this;return te(function*(){const s=(t=yield e.extractIterations(t)).length/2;e.accumulatedGrads=t.slice(0,s).map(i=>({originalName:i.name,variable:i.tensor.variable(!1)})),e.accumulatedUpdates=t.slice(s,2*s).map(i=>({originalName:i.name,variable:i.tensor.variable(!1)}))})()}getConfig(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}}static fromConfig(t,e){return new t(e.learningRate,e.rho,e.epsilon)}}function Yc(n,t,e){return Wr(n),e=e||Vc(t),M.runKernel(fS,{},{shape:n,value:t,dtype:e})}class wP extends qa{static get className(){return"Adagrad"}constructor(t,e=.1){super(),this.learningRate=t,this.initialAccumulatorValue=e,this.accumulatedGrads=[]}applyGradients(t){(Array.isArray(t)?t.map(s=>s.name):Object.keys(t)).forEach((s,r)=>{const i=M.registeredVariables[s];null==this.accumulatedGrads[r]&&(this.accumulatedGrads[r]={originalName:`${s}/accumulator`,variable:z(()=>Yc(i.shape,this.initialAccumulatorValue).variable(!1))});const o=Array.isArray(t)?t[r].tensor:t[s];if(null==o)return;const a=this.accumulatedGrads[r].variable;z(()=>{const l=le(a,en(o));a.assign(l);const u=le(F(Pe(o,Bs(le(l,M.backend.epsilon()))),-this.learningRate),i);i.assign(u)})}),this.incrementIterations()}dispose(){null!=this.accumulatedGrads&&gt(this.accumulatedGrads.map(t=>t.variable))}getWeights(){var t=this;return te(function*(){return[yield t.saveIterations()].concat(t.accumulatedGrads.map(e=>({name:e.originalName,tensor:e.variable})))})()}setWeights(t){var e=this;return te(function*(){t=yield e.extractIterations(t),e.accumulatedGrads=t.map(r=>({originalName:r.name,variable:r.tensor.variable(!1)}))})()}getConfig(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}}static fromConfig(t,e){return new t(e.learningRate,e.initialAccumulatorValue)}}const Ka=k({pow_:function sne(n,t){let e=I(n,"base","pow"),s=I(t,"exp","pow");return[e,s]=Tn(e,s),M.runKernel(Mf,{a:e,b:s})}}),Ne=k({sub_:function rne(n,t){let e=I(n,"a","sub"),s=I(t,"b","sub");return[e,s]=Tn(e,s),M.runKernel(qf,{a:e,b:s})}});class xP extends qa{static get className(){return"Adam"}constructor(t,e,s,r=null){super(),this.learningRate=t,this.beta1=e,this.beta2=s,this.epsilon=r,this.accumulatedFirstMoment=[],this.accumulatedSecondMoment=[],z(()=>{this.accBeta1=ze(e).variable(),this.accBeta2=ze(s).variable()}),null==r&&(this.epsilon=M.backend.epsilon())}applyGradients(t){const e=Array.isArray(t)?t.map(s=>s.name):Object.keys(t);z(()=>{const s=Ne(1,this.accBeta1),r=Ne(1,this.accBeta2);e.forEach((i,o)=>{const a=M.registeredVariables[i];null==this.accumulatedFirstMoment[o]&&(this.accumulatedFirstMoment[o]={originalName:`${i}/m`,variable:z(()=>Et(a).variable(!1))}),null==this.accumulatedSecondMoment[o]&&(this.accumulatedSecondMoment[o]={originalName:`${i}/v`,variable:z(()=>Et(a).variable(!1))});const u=Array.isArray(t)?t[o].tensor:t[i];if(null==u)return;const c=this.accumulatedFirstMoment[o].variable,d=this.accumulatedSecondMoment[o].variable,h=le(F(c,this.beta1),F(u,1-this.beta1)),f=le(F(d,this.beta2),F(en(u),1-this.beta2)),p=Pe(h,s),g=Pe(f,r);c.assign(h),d.assign(f);const m=le(F(Pe(p,le(Bs(g),this.epsilon)),-this.learningRate),a);a.assign(m)}),this.accBeta1.assign(F(this.accBeta1,this.beta1)),this.accBeta2.assign(F(this.accBeta2,this.beta2))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.accBeta2.dispose(),null!=this.accumulatedFirstMoment&&gt(this.accumulatedFirstMoment.map(t=>t.variable)),null!=this.accumulatedSecondMoment&&gt(this.accumulatedSecondMoment.map(t=>t.variable))}getWeights(){var t=this;return te(function*(){const e=[...t.accumulatedFirstMoment,...t.accumulatedSecondMoment];return[yield t.saveIterations()].concat(e.map(s=>({name:s.originalName,tensor:s.variable})))})()}setWeights(t){var e=this;return te(function*(){t=yield e.extractIterations(t),z(()=>{e.accBeta1.assign(Ka(e.beta1,e.iterations_+1)),e.accBeta2.assign(Ka(e.beta2,e.iterations_+1))});const s=t.length/2;e.accumulatedFirstMoment=t.slice(0,s).map(i=>({originalName:i.name,variable:i.tensor.variable(!1)})),e.accumulatedSecondMoment=t.slice(s,2*s).map(i=>({originalName:i.name,variable:i.tensor.variable(!1)}))})()}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}}static fromConfig(t,e){return new t(e.learningRate,e.beta1,e.beta2,e.epsilon)}}const ns=k({abs_:function ine(n){const t=I(n,"x","abs");return M.runKernel("complex64"===t.dtype?Cy:my,{x:t})}});function Zc(n,t){const e=n.length,s=[];for(let r=0;r<e;r++){const i=e-1-r;(t[t.length-1-r]||1)>1&&1===(n[i]||1)&&s.unshift(i)}return s}function ss(n,t){const e=[];for(let s=0;s<t.length;s++){const r=n[n.length-s-1],i=t.length-s-1;(null==r||1===r&&t[i]>1)&&e.unshift(i)}return e}function nt(n,t){const e=Math.max(n.length,t.length),s=new Array(e);for(let r=0;r<e;r++){let i=n[n.length-r-1];null==i&&(i=1);let o=t[t.length-r-1];if(null==o&&(o=1),1===i)s[e-r-1]=o;else if(1===o)s[e-r-1]=i;else{if(i!==o)throw Error(`Operands could not be broadcast together with shapes ${n} and ${t}.`);s[e-r-1]=i}}return s}const oa=k({maximum_:function one(n,t){let e=I(n,"a","maximum"),s=I(t,"b","maximum");return[e,s]=Tn(e,s),"bool"===e.dtype&&(e=xe(e,"int32"),s=xe(s,"int32")),nt(e.shape,s.shape),M.runKernel(Nf,{a:e,b:s})}});class CP extends qa{static get className(){return"Adamax"}constructor(t,e,s,r=null,i=0){super(),this.learningRate=t,this.beta1=e,this.beta2=s,this.epsilon=r,this.decay=i,this.accumulatedFirstMoment=[],this.accumulatedWeightedInfNorm=[],z(()=>{this.iteration=ze(0).variable(),this.accBeta1=ze(e).variable()}),null==r&&(this.epsilon=M.backend.epsilon())}applyGradients(t){const e=Array.isArray(t)?t.map(s=>s.name):Object.keys(t);z(()=>{const s=Ne(1,this.accBeta1),r=Pe(-this.learningRate,le(F(this.iteration,this.decay),1));e.forEach((i,o)=>{const a=M.registeredVariables[i];null==this.accumulatedFirstMoment[o]&&(this.accumulatedFirstMoment[o]={originalName:`${i}/m`,variable:Et(a).variable(!1)}),null==this.accumulatedWeightedInfNorm[o]&&(this.accumulatedWeightedInfNorm[o]={originalName:`${i}/v`,variable:Et(a).variable(!1)});const u=Array.isArray(t)?t[o].tensor:t[i];if(null==u)return;const c=this.accumulatedFirstMoment[o].variable,d=this.accumulatedWeightedInfNorm[o].variable,h=le(F(c,this.beta1),F(u,1-this.beta1)),f=F(d,this.beta2),p=ns(u),g=oa(f,p);c.assign(h),d.assign(g);const m=le(F(Pe(r,s),Pe(h,le(g,this.epsilon))),a);a.assign(m)}),this.iteration.assign(le(this.iteration,1)),this.accBeta1.assign(F(this.accBeta1,this.beta1))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.iteration.dispose(),null!=this.accumulatedFirstMoment&&gt(this.accumulatedFirstMoment.map(t=>t.variable)),null!=this.accumulatedWeightedInfNorm&&gt(this.accumulatedWeightedInfNorm.map(t=>t.variable))}getWeights(){return te(function*(){throw new Error("getWeights() is not implemented for Adamax yet.")})()}setWeights(t){return te(function*(){throw new Error("setWeights() is not implemented for Adamax yet.")})()}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}}static fromConfig(t,e){return new t(e.learningRate,e.beta1,e.beta2,e.epsilon,e.decay)}}class xI extends qa{static get className(){return"SGD"}constructor(t){super(),this.learningRate=t,this.setLearningRate(t)}applyGradients(t){(Array.isArray(t)?t.map(s=>s.name):Object.keys(t)).forEach((s,r)=>{const i=Array.isArray(t)?t[r].tensor:t[s];if(null==i)return;const o=M.registeredVariables[s];z(()=>{const a=le(F(this.c,i),o);o.assign(a)})}),this.incrementIterations()}setLearningRate(t){this.learningRate=t,null!=this.c&&this.c.dispose(),this.c=vs(ze(-t))}dispose(){this.c.dispose()}getWeights(){var t=this;return te(function*(){return[yield t.saveIterations()]})()}setWeights(t){var e=this;return te(function*(){if(0!==(t=yield e.extractIterations(t)).length)throw new Error("SGD optimizer does not have settable weights.")})()}getConfig(){return{learningRate:this.learningRate}}static fromConfig(t,e){return new t(e.learningRate)}}class SP extends xI{static get className(){return"Momentum"}constructor(t,e,s=!1){super(t),this.learningRate=t,this.momentum=e,this.useNesterov=s,this.accumulations=[],this.m=ze(this.momentum)}applyGradients(t){(Array.isArray(t)?t.map(s=>s.name):Object.keys(t)).forEach((s,r)=>{const i=M.registeredVariables[s];null==this.accumulations[r]&&(this.accumulations[r]={originalName:`${s}/momentum`,variable:z(()=>Et(i).variable(!1))});const o=this.accumulations[r].variable,a=Array.isArray(t)?t[r].tensor:t[s];null!=a&&z(()=>{let l;const u=le(F(this.m,o),a);l=le(F(this.c,this.useNesterov?le(a,F(u,this.m)):u),i),o.assign(u),i.assign(l)})}),this.incrementIterations()}dispose(){this.m.dispose(),null!=this.accumulations&&gt(this.accumulations.map(t=>t.variable))}setMomentum(t){this.momentum=t}getWeights(){var t=this;return te(function*(){return[yield t.saveIterations()].concat(t.accumulations.map(e=>({name:e.originalName,tensor:e.variable})))})()}setWeights(t){var e=this;return te(function*(){t=yield e.extractIterations(t),e.accumulations=t.map(r=>({originalName:r.name,variable:r.tensor.variable(!1)}))})()}getConfig(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}}static fromConfig(t,e){return new t(e.learningRate,e.momentum,e.useNesterov)}}class IP extends qa{static get className(){return"RMSProp"}constructor(t,e=.9,s=0,r=null,i=!1){if(super(),this.learningRate=t,this.decay=e,this.momentum=s,this.epsilon=r,this.accumulatedMeanSquares=[],this.accumulatedMoments=[],this.accumulatedMeanGrads=[],this.centered=i,null==r&&(this.epsilon=M.backend.epsilon()),null==t)throw new Error("learningRate for RMSPropOptimizer must be defined.")}applyGradients(t){(Array.isArray(t)?t.map(s=>s.name):Object.keys(t)).forEach((s,r)=>{const i=M.registeredVariables[s],o=!1;null==this.accumulatedMeanSquares[r]&&(this.accumulatedMeanSquares[r]={originalName:`${s}/rms`,variable:z(()=>Et(i).variable(o))}),null==this.accumulatedMoments[r]&&(this.accumulatedMoments[r]={originalName:`${s}/momentum`,variable:z(()=>Et(i).variable(o))}),null==this.accumulatedMeanGrads[r]&&this.centered&&(this.accumulatedMeanGrads[r]={originalName:`${s}/mg`,variable:z(()=>Et(i).variable(o))});const a=Array.isArray(t)?t[r].tensor:t[s];if(null==a)return;const l=this.accumulatedMeanSquares[r].variable,u=this.accumulatedMoments[r].variable;z(()=>{const c=le(F(l,this.decay),F(en(a),1-this.decay));if(this.centered){const d=this.accumulatedMeanGrads[r].variable,h=le(F(d,this.decay),F(a,1-this.decay)),f=Pe(F(a,this.learningRate),Bs(Ne(c,le(en(h),this.epsilon)))),p=le(F(u,this.momentum),f);l.assign(c),d.assign(h),u.assign(p);const g=Ne(i,p);i.assign(g)}else{const d=le(F(l,this.decay),F(en(a),1-this.decay)),h=le(F(u,this.momentum),Pe(F(a,this.learningRate),Bs(le(d,this.epsilon))));l.assign(d),u.assign(h);const f=Ne(i,h);i.assign(f)}})}),this.incrementIterations()}dispose(){null!=this.accumulatedMeanSquares&&gt(this.accumulatedMeanSquares.map(t=>t.variable)),null!=this.accumulatedMeanGrads&&this.centered&&gt(this.accumulatedMeanGrads.map(t=>t.variable)),null!=this.accumulatedMoments&&gt(this.accumulatedMoments.map(t=>t.variable))}getWeights(){var t=this;return te(function*(){const e=[...t.accumulatedMeanSquares,...t.accumulatedMoments];return t.centered&&e.push(...t.accumulatedMeanGrads),[yield t.saveIterations()].concat(e.map(s=>({name:s.originalName,tensor:s.variable})))})()}setWeights(t){var e=this;return te(function*(){t=yield e.extractIterations(t);const s=e.centered?t.length/3:t.length/2,r=!1;e.accumulatedMeanSquares=t.slice(0,s).map(i=>({originalName:i.name,variable:i.tensor.variable(r)})),e.accumulatedMoments=t.slice(s,2*s).map(i=>({originalName:i.name,variable:i.tensor.variable(r)})),e.centered&&(e.accumulatedMeanGrads=t.slice(2*s,3*s).map(i=>({originalName:i.name,variable:i.tensor.variable(r)})))})()}getConfig(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}}static fromConfig(t,e){return new t(e.learningRate,e.decay,e.momentum,e.epsilon,e.centered)}}const ane=[_P,wP,xP,CP,SP,IP,xI];function EP(n){return new Promise(t=>setTimeout(t)).then(n)}let CI=(()=>{class n{constructor(e){if(!W().getBool("IS_BROWSER"))throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");e.startsWith(n.URL_SCHEME)&&(e=e.slice(n.URL_SCHEME.length)),(null==e||0===e.length)&&(e="model"),this.modelJsonFileName=e+".json",this.weightDataFileName=e+".weights.bin"}save(e){var s=this;return te(function*(){if(typeof document>"u")throw new Error("Browser downloads are not supported in this environment since `document` is not present");const r=window.URL.createObjectURL(new Blob([e.weightData],{type:"application/octet-stream"}));if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");{const o=aP(e,[{paths:["./"+s.weightDataFileName],weights:e.weightSpecs}]),a=window.URL.createObjectURL(new Blob([JSON.stringify(o)],{type:"application/json"})),l=null==s.modelJsonAnchor?document.createElement("a"):s.modelJsonAnchor;if(l.download=s.modelJsonFileName,l.href=a,yield EP(()=>l.dispatchEvent(new MouseEvent("click"))),null!=e.weightData){const u=null==s.weightDataAnchor?document.createElement("a"):s.weightDataAnchor;u.download=s.weightDataFileName,u.href=r,yield EP(()=>u.dispatchEvent(new MouseEvent("click")))}return{modelArtifactsInfo:np(e)}}})()}}return n.URL_SCHEME="downloads://",n})();class hne{constructor(t){if(null==t||t.length<1)throw new Error(`When calling browserFiles, at least 1 file is required, but received ${t}`);this.jsonFile=t[0],this.weightsFiles=t.slice(1)}load(){var t=this;return te(function*(){return new Promise((e,s)=>{const r=new FileReader;r.onload=i=>{const o=JSON.parse(i.target.result),a=o.modelTopology;if(null==a)return void s(new Error(`modelTopology field is missing from file ${t.jsonFile.name}`));if(null==o.weightsManifest)return void s(new Error(`weightManifest field is missing from file ${t.jsonFile.name}`));if(0===t.weightsFiles.length)return void e({modelTopology:a});const u=uI(o,c=>t.loadWeights(c));e(u)},r.onerror=i=>s(`Failed to read model topology and weights manifest JSON from file '${t.jsonFile.name}'. BrowserFiles supports loading Keras-style tf.Model artifacts only.`),r.readAsText(t.jsonFile)})})()}loadWeights(t){const e=[],s=[];for(const o of t)e.push(...o.weights),s.push(...o.paths);const r=this.checkManifestAndWeightFiles(t),i=s.map(o=>this.loadWeightsFile(o,r[o]));return Promise.all(i).then(o=>[e,Eb(o)])}loadWeightsFile(t,e){return new Promise((s,r)=>{const i=new FileReader;i.onload=o=>{s(o.target.result)},i.onerror=o=>r(`Failed to weights data from file of path '${t}'.`),i.readAsArrayBuffer(e)})}checkManifestAndWeightFiles(t){const e=[],s=this.weightsFiles.map(i=>oP(i.name)),r={};for(const i of t)i.paths.forEach(o=>{const a=oP(o);if(-1!==e.indexOf(a))throw new Error(`Duplicate file basename found in weights manifest: '${a}'`);if(e.push(a),-1===s.indexOf(a))throw new Error(`Weight file with basename '${a}' is not provided.`);r[o]=this.weightsFiles[s.indexOf(a)]});if(e.length!==this.weightsFiles.length)throw new Error(`Mismatch in the number of files in weights manifest (${e.length}) and the number of weight files provided (${this.weightsFiles.length}).`);return r}}function mne(n){return new hne(n)}bn.registerSaveRouter(n=>W().getBool("IS_BROWSER")&&!Array.isArray(n)&&n.startsWith(CI.URL_SCHEME)?function pne(n="model"){return new CI(n)}(n.slice(CI.URL_SCHEME.length)):null);class gne{constructor(t){if(this.shards=[],this.previousShardIndex=0,t instanceof Array||(t=[t]),0===(t=t.map(s=>hi(s)?s.buffer:s)).length)return;this.bufferUniformSize=t[0].byteLength;let e=0;for(let s=0;s<t.length;s++){const r=t[s];s!==t.length-1&&r.byteLength!==this.bufferUniformSize&&(this.bufferUniformSize=void 0);const i=e+r.byteLength;this.shards.push({buffer:r,start:e,end:i}),e=i}0===this.shards.length&&(this.byteLength=0),this.byteLength=this.shards[this.shards.length-1].end}slice(t=0,e=this.byteLength){if(t=isNaN(Number(t))?0:t,e=isNaN(Number(e))?0:e,t=Math.max(0,t),(e=Math.min(this.byteLength,e))<=t)return new ArrayBuffer(0);const s=this.findShardForByte(t);if(-1===s)throw new Error(`Could not find start shard for byte ${t}`);const i=new ArrayBuffer(e-t),o=new Uint8Array(i);let a=0;for(let l=s;l<this.shards.length;l++){const u=this.shards[l],d=t+a-u.start,h=a,p=Math.min(e,u.end)-u.start,g=new Uint8Array(u.buffer.slice(d,p));if(o.set(g,h),a+=g.length,e<u.end)break}return i}findShardForByte(t){if(0===this.shards.length||t<0||t>=this.byteLength)return-1;if(null!=this.bufferUniformSize)return this.previousShardIndex=Math.floor(t/this.bufferUniformSize),this.previousShardIndex;function e(r){return t<r.start?-1:t>=r.end?1:0}if(0===e(this.shards[this.previousShardIndex]))return this.previousShardIndex;const s=function yne(n,t){let e=0,s=n.length;for(;e<=s;){const r=Math.floor((s-e)/2)+e,i=t(n[r]);if(0===i)return r;i<0?s=r:e=r+1}return-1}(this.shards,e);return-1===s?-1:(this.previousShardIndex=s,this.previousShardIndex)}}function DP(n,t,e,s){(function o(l){S(null!=l&&Array.isArray(l)&&l.length>0,()=>"promises must be a none empty array")})(n),function a(l,u){S(l>=0&&l<=1,()=>`Progress fraction must be in range [0, 1], but got startFraction ${l}`),S(u>=0&&u<=1,()=>`Progress fraction must be in range [0, 1], but got endFraction ${u}`),S(u>=l,()=>`startFraction must be no more than endFraction, but got startFraction ${l} and endFraction ${u}`)}(e=e??0,s=s??1);let r=0;return Promise.all(n.map(l=>(l.then(u=>{const c=e+ ++r/n.length*(s-e);return t(c),u}),l)))}function TP(n,t){return SI.apply(this,arguments)}function SI(){return(SI=te(function*(n,t){null==t&&(t={});const e=null==t.fetchFunc?W().platform.fetch:t.fetchFunc,s=n.map(d=>e(d,t.requestInit,{isBinary:!0})),a=(null==t.onProgress?yield Promise.all(s):yield DP(s,t.onProgress,0,.5)).map(d=>d.arrayBuffer());return null==t.onProgress?yield Promise.all(a):yield DP(a,t.onProgress,.5,1)})).apply(this,arguments)}function bne(n){return II.apply(this,arguments)}function II(){return(II=te(function*(n,t="",e,s){return NP(o=>TP(o,{requestInit:s}))(n,t,e)})).apply(this,arguments)}function NP(n){return function(){var t=te(function*(e,s="",r){const i=e.map(()=>!1),o={},a=null!=r?r.map(()=>!1):[],l=[];if(e.forEach((p,g)=>{let m=0;p.weights.forEach(y=>{const v=iI["quantization"in y?y.quantization.dtype:y.dtype]*X(y.shape),_=()=>{i[g]=!0,null==o[g]&&(o[g]=[]),o[g].push({manifestEntry:y,groupOffset:m,sizeBytes:v})};null!=r?r.forEach((x,C)=>{x===y.name&&(_(),a[C]=!0)}):_(),l.push(y.name),m+=v})}),!a.every(p=>p)){const p=r.filter((g,m)=>!a[m]);throw new Error(`Could not find weights in manifest with names: ${p.join(", ")}. \nManifest JSON has weights with names: ${l.join(", ")}.`)}const u=i.reduce((p,g,m)=>(g&&p.push(m),p),[]),c=[];u.forEach(p=>{e[p].paths.forEach(g=>{const m=s+(s.endsWith("/")?"":"/")+g;c.push(m)})});const d=yield n(c),h={};let f=0;return u.forEach(p=>{const g=e[p].paths.length,m=new gne(d.slice(f,f+g));o[p].forEach(b=>{const _=rP(m.slice(b.groupOffset,b.groupOffset+b.sizeBytes),[b.manifestEntry]);for(const x in _)h[x]=_[x]}),f+=g}),h});return function(e){return t.apply(this,arguments)}}()}let kP=(()=>{class n{constructor(e,s){if(this.DEFAULT_METHOD="POST",null==s&&(s={}),this.weightPathPrefix=s.weightPathPrefix,this.onProgress=s.onProgress,this.weightUrlConverter=s.weightUrlConverter,null!=s.fetchFunc?(S("function"==typeof s.fetchFunc,()=>"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)"),this.fetch=s.fetchFunc):this.fetch=W().platform.fetch,S(null!=e&&e.length>0,()=>"URL path for http must not be null, undefined or empty."),Array.isArray(e)&&S(2===e.length,()=>`URL paths for http must have a length of 2, (actual length is ${e.length}).`),this.path=e,null!=s.requestInit&&null!=s.requestInit.body)throw new Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=s.requestInit||{}}save(e){var s=this;return te(function*(){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");const r=Object.assign({method:s.DEFAULT_METHOD},s.requestInit);r.body=new FormData;const o=aP(e,[{paths:["./model.weights.bin"],weights:e.weightSpecs}]);r.body.append("model.json",new Blob([JSON.stringify(o)],{type:"application/json"}),"model.json"),null!=e.weightData&&r.body.append("model.weights.bin",new Blob([e.weightData],{type:"application/octet-stream"}),"model.weights.bin");const a=yield s.fetch(s.path,r);if(a.ok)return{modelArtifactsInfo:np(e),responses:[a]};throw new Error(`BrowserHTTPRequest.save() failed due to HTTP response status ${a.status}.`)})()}load(){var e=this;return te(function*(){const s=yield e.fetch(e.path,e.requestInit);if(!s.ok)throw new Error(`Request to ${e.path} failed with status code ${s.status}. Please verify this URL points to the model JSON of the model to load.`);let r;try{r=yield s.json()}catch{let l=`Failed to parse model JSON of response from ${e.path}.`;throw e.path.endsWith(".pb")?l+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":l+=" Please make sure the server is serving valid JSON for this request.",new Error(l)}if(null==r.modelTopology&&null==r.weightsManifest)throw new Error(`The JSON from HTTP path ${e.path} contains neither model topology or manifest for weights.`);return uI(r,a=>e.loadWeights(a))})()}loadWeights(e){var s=this;return te(function*(){const r=Array.isArray(s.path)?s.path[1]:s.path,[i,o]=function wne(n){const t=n.lastIndexOf("/"),e=n.lastIndexOf("?");return[n.substring(0,t)+"/",e>t?n.substring(e):""]}(r),a=s.weightPathPrefix||i,l=uP(e),u=[],c=[];for(const h of e)for(const f of h.paths)null!=s.weightUrlConverter?c.push(s.weightUrlConverter(f)):u.push(a+f+o);return s.weightUrlConverter&&u.push(...yield Promise.all(c)),[l,Eb(yield TP(u,{requestInit:s.requestInit,fetchFunc:s.fetch,onProgress:s.onProgress}))]})()}}return n.URL_SCHEME_REGEX=/^https?:\/\//,n})();function EI(n){return null!=n.match(kP.URL_SCHEME_REGEX)}const AP=(n,t)=>{if(typeof fetch>"u"&&(null==t||null==t.fetchFunc))return null;{let e=!0;if(e=Array.isArray(n)?n.every(s=>EI(s)):EI(n),e)return DI(n,t)}return null};function DI(n,t){return new kP(n,t)}function xne(n,t){return DI(n,t)}bn.registerSaveRouter(AP),bn.registerLoadRouter(AP);class TI{constructor(t){this.modelArtifacts=t}load(){return this.modelArtifacts}}class RP{constructor(t){this.saveHandler=t}save(t){return this.saveHandler(t)}}class Cne{constructor(t){t.load&&(this.load=()=>Promise.resolve(t.load())),t.save&&(this.save=e=>Promise.resolve(t.save(e)))}}function Sne(n,t,e,s){return new Cne(MP(...arguments))}function MP(n,t,e,s){return 1===arguments.length?null!=n.modelTopology||null!=n.weightSpecs?new TI(n):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new TI({modelTopology:n})):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new TI({modelTopology:n,weightSpecs:t,weightData:e,trainingConfig:s}))}function Ine(n){return new RP(n)}function Ene(n){return new RP(n)}const NI=-2,Dne=-1;function kI(n,t,e){const s=n.shape.length;S(s===t.length,()=>`Error in slice${s}D: Length of begin ${t} must match the rank of the array (${s}).`),S(s===e.length,()=>`Error in slice${s}D: Length of size ${e} must match the rank of the array (${s}).`);for(let r=0;r<s;++r)S(t[r]+e[r]<=n.shape[r],()=>`Error in slice${s}D: begin[${r}] + size[${r}] (${t[r]+e[r]}) would overflow input.shape[${r}] (${n.shape[r]})`)}function Tne(n){const t=[];let e=0;for(;n>0;)1&n&&t.push(e),n/=2,e++;return t}function AI(n,t,e){const s=[];for(let r=0;r<n.length;r++)s[r]=Math.ceil((t[r]-n[r])/e[r]);return s}function FP(n,t,e,s){const r=[...n];for(let i=r.length;i<s.length;i++)r.push(1);for(let i=0;i<e;i++)0===i?r[t]=1:(r.splice(t,0,1),r.pop());return r}function OP(n,t,e){return e<=n?e:e-(t-1)}function $P(n,t){const e=[];for(let s=0;s<n;s++)e.push(t+s);return e}function Nne(n,t,e,s,r,i,o,a,l){const u=n.length;let c=new Array(u),d=new Array(u),h=new Array(u);if(t.length&&e>0){const f=t[0],p=e+1;c=PP(o,f,p,s,n),d=LP(a,f,p,r,n),h=FP(i,f,p,n)}else for(let f=0;f<u;f++)c[f]=BP(o,s,i,n,f,l),d[f]=zP(a,r,i,n,f,l),h[f]=VP(i,f,l);return{begin:c,end:d,strides:h}}function PP(n,t,e,s,r){const i=[...r],o=$P(e,t);for(let a=0;a<i.length;a++)if(o.indexOf(a)>-1)i[a]=0;else{const l=OP(t,e,a);let u=s[l];n&1<<l&&(u=0),i[a]=u}return i}function LP(n,t,e,s,r){const i=[...r],o=$P(e,t);for(let a=0;a<i.length;a++)if(o.indexOf(a)>-1)i[a]=Number.MAX_SAFE_INTEGER;else{const l=OP(t,e,a);let u=s[l];n&1<<l&&(u=Number.MAX_SAFE_INTEGER),i[a]=u}for(let a=0;a<i.length;a++)i[a]<0&&(i[a]+=r[a]),i[a]=Yl(0,i[a],r[a]);return i}function VP(n,t,e){let s=n[t];return(e&1<<t||null==s)&&(s=1),s}function BP(n,t,e,s,r,i){let o=t[r];(n&1<<r||i&1<<r||null==o)&&(o=(e[r]||1)>0?Number.MIN_SAFE_INTEGER:Number.MAX_SAFE_INTEGER);const l=s[r];return o<0&&(o+=l),o=Yl(0,o,l-1),o}function zP(n,t,e,s,r,i){let o=t[r];const a=e[r]||1;(n&1<<r||i&1<<r||null==o)&&(o=a>0?Number.MAX_SAFE_INTEGER:Number.MIN_SAFE_INTEGER);const l=s[r];return o<0&&(o+=l),o=a>0?Yl(0,o,l):Yl(-1,o,l-1),o}function RI(n,t,e){let s=e.length;for(let r=0;r<e.length;r++)if(e[r]>1){s=r;break}for(let r=s+1;r<e.length;r++)if(t[r]>0||e[r]!==n[r])return!1;return!0}function MI(n,t){let e=n.length>0?n[n.length-1]:1;for(let s=0;s<n.length-1;s++)e+=n[s]*t[s];return e}function kb(n,t,e){let s;const r=n.shape.length;let i;return s="number"==typeof t?[t,...new Array(r-1).fill(0)]:t.length<r?t.concat(new Array(r-t.length).fill(0)):t.slice(),s.forEach(o=>{S(-1!==o,()=>"slice() does not support negative begin indexing.")}),i=null==e?new Array(r).fill(-1):"number"==typeof e?[e,...new Array(r-1).fill(-1)]:e.length<r?e.concat(new Array(r-e.length).fill(-1)):e,i=i.map((o,a)=>o>=0?o:(S(-1===o,()=>`Negative size values should be exactly -1 but got ${o} for the slice() size at index ${a}.`),n.shape[a]-s[a])),[s,i]}function FI(n,t,e,s,r,i,o,a,l){let u;if(null==s?(u=new Array(t.length),u.fill(1)):u=s,null!=o&&o&o-1)throw new Error("Multiple ellipses in slice is not allowed.");let c=!1;const d={dims:u.length,numAddAxisAfterEllipsis:0,begin:t.slice(),end:e.slice(),strides:u.slice(),beginMask:r,endMask:i,ellipsisMask:o,newAxisMask:a,shrinkAxisMask:l};for(let v=0;v<d.dims;v++)c&&1<<v&a&&d.numAddAxisAfterEllipsis++,1<<v&o&&(c=!0);c||(d.ellipsisMask|=1<<d.dims,d.dims++);const h={dims:n.length,beginMask:0,endMask:0,beginValid:!1,endValid:!1};!function kne(n,t){t.beginMask=0,t.endMask=0,t.shrinkAxisMask=0;let e=0;t.beginValid=null!=n.begin,t.endValid=null!=n.end,t.begin=new Array(t.dims),t.end=new Array(t.dims),t.strides=new Array(t.dims),t.finalShapeGatherIndices=[],t.finalShapeGatherIndicesSparse=[],t.inputShapeGatherIndicesSparse=new Array(t.dims);for(let s=0;s<n.dims;s++)if(1<<s&n.ellipsisMask){const r=Math.min(t.dims-(n.dims-s)+1+n.numAddAxisAfterEllipsis,t.dims);for(;e<r;e++)t.begin[e]=0,t.end[e]=0,t.strides[e]=1,t.beginMask|=1<<e,t.endMask|=1<<e,t.finalShapeGatherIndices.push(e),t.finalShapeGatherIndicesSparse.push(-1),t.inputShapeGatherIndicesSparse[e]=s}else if(1<<s&n.newAxisMask)t.finalShapeGatherIndices.push(NI),t.finalShapeGatherIndicesSparse.push(-1);else{if(e===t.begin.length)throw Error(`Index out of range using input dim ${e}; input has only ${t.dims} dims, ${t.begin.length}.`);null!=n.begin&&(t.begin[e]=n.begin[s]),null!=n.end&&(t.end[e]=n.end[s]),t.strides[e]=n.strides[s],n.beginMask&1<<s&&(t.beginMask|=1<<e),n.endMask&1<<s&&(t.endMask|=1<<e),n.shrinkAxisMask&1<<s?(t.finalShapeGatherIndices.push(Dne),t.finalShapeGatherIndicesSparse.push(-1),t.shrinkAxisMask|=1<<e):(t.finalShapeGatherIndices.push(e),t.finalShapeGatherIndicesSparse.push(s)),t.inputShapeGatherIndicesSparse[e]=s,e++}}(d,h);let f=!0,p=!0,g=!0;const m=[],y=[];for(let v=0;v<n.length;++v){if(0===h.strides[v])throw Error(`strides[${v}] must be non-zero`);const _=!!(h.shrinkAxisMask&1<<v),x=n[v];if(-1===x){m.push(_?1:-1);continue}const C=[h.beginMask&1<<v,h.endMask&1<<v],E=[h.strides[v]>0?0:-1,h.strides[v]>0?x:x-1];if(_&&h.strides[v]<=0)throw Error("only stride 1 allowed on non-range indexing.");g=g&&1===h.strides[v];const D=!!(h.beginMask&1<<v&&h.endMask&1<<v);if(h.beginValid&&h.endValid){if(_){const G=h.begin[v]<0?x+h.begin[v]:h.begin[v];if(h.begin[v]=G,h.end[v]=h.begin[v]+1,G<0||G>=x)throw Error(`slice index ${h.begin[v]} of dimension ${v} out of bounds.`)}else h.begin[v]=UP(h.begin[v],0,h.strides[v],x,C,E),h.end[v]=UP(h.end[v],1,h.strides[v],x,C,E);const V=1===h.strides[v]&&0===h.begin[v]&&h.end[v]===x;f=f&&V,p=p&&(0===v&&1===h.strides[v]||V)}else f=f&&1===h.strides[v]&&D,p=p&&(0===v&&1===h.strides[v]||D);let N,R=!1;if(h.beginValid&&h.endValid?(N=h.end[v]-h.begin[v],R=!0):_?(N=1,R=!0):D&&x>=0&&(N=h.strides[v]<0?-x:x,R=!0),R){let V;V=0===N||N<0!=h.strides[v]<0?0:Math.trunc(N/h.strides[v])+(N%h.strides[v]!=0?1:0),m.push(V)}else m.push(-1)}for(let v=0;v<h.finalShapeGatherIndices.length;++v){const _=h.finalShapeGatherIndices[v];_>=0?y.push(m[_]):_===NI&&y.push(1)}return{finalShapeSparse:y.filter((v,_)=>h.finalShapeGatherIndices[_]!==NI),finalShape:y,isIdentity:f,sliceDim0:p,isSimpleSlice:g,begin:h.begin,end:h.end,strides:h.strides}}function UP(n,t,e,s,r,i){if(r[t])return e>0?i[t]:i[t+1&1];{const o=n<0?s+n:n;return o<i[0]?i[0]:o>i[1]?i[1]:o}}const WP=k({acos_:function Rne(n){const e={x:I(n,"x","acos")};return M.runKernel(ef,e)}}),GP=k({acosh_:function Mne(n){const e={x:I(n,"x","acosh")};return M.runKernel(nf,e)}}),One=k({addN_:function Fne(n){S(Array.isArray(n),()=>"The argument passed to tf.addN() must be a list of tensors"),S(n.length>=1,()=>`Must pass at least one tensor to tf.addN(), but got ${n.length}`);const t=n.map((r,i)=>I(r,`tensors${i}`,"addN")),e=t[0];return t.forEach(r=>{if(r.dtype!==e.dtype)throw new Error("All tensors passed to tf.addN() must have the same dtype")}),t.forEach(r=>{if(!wt(r.shape,e.shape))throw new Error("All tensors passed to tf.addN() must have the same shape")}),M.runKernel(gy,t)}}),OI=k({all_:function $ne(n,t=null,e=!1){const r={x:I(n,"x","all","bool")};return M.runKernel("All",r,{axis:t,keepDims:e})}}),Ab=k({any_:function Pne(n,t=null,e=!1){const r={x:I(n,"x","any","bool")};return M.runKernel("Any",r,{axis:t,keepDims:e})}}),Qc=k({argMax_:function Lne(n,t=0){const s={x:I(n,"x","argMax")};return M.runKernel(yy,s,{axis:t})}}),HP=k({argMin_:function Vne(n,t=0){const s={x:I(n,"x","argMin")};return M.runKernel(by,s,{axis:t})}}),jP=k({asin_:function Bne(n){const e={x:I(n,"x","asin")};return M.runKernel(sf,e)}}),qP=k({asinh_:function zne(n){const e={x:I(n,"x","asinh")};return M.runKernel(rf,e)}}),KP=k({atan_:function Une(n){const e={x:I(n,"x","atan")};return M.runKernel(af,e)}}),XP=k({atan2_:function Wne(n,t){let e=I(n,"a","atan2"),s=I(t,"b","atan2");return[e,s]=Tn(e,s),M.runKernel(uf,{a:e,b:s})}}),YP=k({atanh_:function Gne(n){const e={x:I(n,"x","atanh")};return M.runKernel(lf,e)}});function sp(n,t,e,s,r="NHWC",i){return _s(n,[...t,n[3]],e,i,s,null,null,la(r))}function pi(n,t,e,s,r,i,o="channelsLast"){const[a,l]=rp(t);let u;if("channelsLast"===o)u=[a,l,n[3],n[3]];else{if("channelsFirst"!==o)throw new Error(`Unknown dataFormat ${o}`);u=[a,l,n[1],n[1]]}return _s(n,u,e,s,r,i,!1,o)}function aa(n,t,e,s,r,i,o="NDHWC"){const[a,l,u]=PI(t);let c,d;if("NDHWC"===o)d="channelsLast",c=[a,l,u,n[4],n[4]];else{if("NCDHW"!==o)throw new Error(`Unknown dataFormat ${o}`);d="channelsFirst",c=[a,l,u,n[1],n[1]]}return Xa(n,c,e,s,r,!1,d,i)}function _s(n,t,e,s,r,i,o=!1,a="channelsLast"){let[l,u,c,d]=[-1,-1,-1,-1];if("channelsLast"===a)[l,u,c,d]=n;else{if("channelsFirst"!==a)throw new Error(`Unknown dataFormat ${a}`);[l,d,u,c]=n}const[h,f,,p]=t,[g,m]=rp(e),[y,b]=rp(s),v=Jc(h,y),_=Jc(f,b),{padInfo:x,outHeight:C,outWidth:E}=function qne(n,t,e,s,r,i,o,a,l){let u,c,d;if("number"==typeof n){u={top:n,bottom:n,left:n,right:n,type:0===n?"VALID":"NUMBER"};const f=function Hne(n,t,e,s,r){null==s&&(s=$I(n,t,e));const o=n[1];return[ip((n[0]-t+2*s)/e+1,r),ip((o-t+2*s)/e+1,r)]}([t,e],i,s,n,a);c=f[0],d=f[1]}else if("same"===n){c=Math.ceil(t/s),d=Math.ceil(e/r);const h=Math.max(0,(c-1)*s+i-t),f=Math.max(0,(d-1)*r+o-e),p=Math.floor(h/2),g=h-p,m=Math.floor(f/2);u={top:p,bottom:g,left:m,right:f-m,type:"SAME"}}else if("valid"===n)u={top:0,bottom:0,left:0,right:0,type:"VALID"},c=Math.ceil((t-i+1)/s),d=Math.ceil((e-o+1)/r);else{if("object"!=typeof n)throw Error(`Unknown padding parameter: ${n}`);{const h="channelsLast"===l?n[1][0]:n[2][0],f="channelsLast"===l?n[1][1]:n[2][1],p="channelsLast"===l?n[2][0]:n[3][0],g="channelsLast"===l?n[2][1]:n[3][1];u={top:h,bottom:f,left:p,right:g,type:0===h&&0===f&&0===p&&0===g?"VALID":"EXPLICIT"},c=ip((t-i+h+f)/s+1,a),d=ip((e-o+p+g)/r+1,a)}}return{padInfo:u,outHeight:c,outWidth:d}}(r,u,c,g,m,v,_,i,a),D=o?p*d:p;let N;return"channelsFirst"===a?N=[l,D,C,E]:"channelsLast"===a&&(N=[l,C,E,D]),{batchSize:l,dataFormat:a,inHeight:u,inWidth:c,inChannels:d,outHeight:C,outWidth:E,outChannels:D,padInfo:x,strideHeight:g,strideWidth:m,filterHeight:h,filterWidth:f,effectiveFilterHeight:v,effectiveFilterWidth:_,dilationHeight:y,dilationWidth:b,inShape:n,outShape:N,filterShape:t}}function Xa(n,t,e,s,r,i=!1,o="channelsLast",a){let[l,u,c,d,h]=[-1,-1,-1,-1,-1];if("channelsLast"===o)[l,u,c,d,h]=n;else{if("channelsFirst"!==o)throw new Error(`Unknown dataFormat ${o}`);[l,h,u,c,d]=n}const[f,p,g,,m]=t,[y,b,v]=PI(e),[_,x,C]=PI(s),E=Jc(f,_),D=Jc(p,x),N=Jc(g,C),{padInfo:R,outDepth:V,outHeight:G,outWidth:j}=function Kne(n,t,e,s,r,i,o,a,l,u,c){let d,h,f,p;if("valid"===n&&(n=0),"number"==typeof n){d={top:n,bottom:n,left:n,right:n,front:n,back:n,type:0===n?"VALID":"NUMBER"};const m=function jne(n,t,e,s,r,i){null==r&&(r=$I(n,t[0],s[0]));const o=[0,0,0,e];for(let a=0;a<3;a++)n[a]+2*r>=t[a]&&(o[a]=ip((n[a]-t[a]+2*r)/s[a]+1,i));return o}([t,e,s,1],[a,l,u],1,[r,i,o],n,c);h=m[0],f=m[1],p=m[2]}else{if("same"!==n)throw Error(`Unknown padding parameter: ${n}`);{h=Math.ceil(t/r),f=Math.ceil(e/i),p=Math.ceil(s/o);const g=(h-1)*r+a-t,m=(f-1)*i+l-e,y=(p-1)*o+u-s,b=Math.floor(g/2),v=g-b,_=Math.floor(m/2),x=m-_,C=Math.floor(y/2);d={top:_,bottom:x,left:C,right:y-C,front:b,back:v,type:"SAME"}}}return{padInfo:d,outDepth:h,outHeight:f,outWidth:p}}(r,u,c,d,y,b,v,E,D,N,a),q=i?m*h:m;let K;return"channelsFirst"===o?K=[l,q,V,G,j]:"channelsLast"===o&&(K=[l,V,G,j,q]),{batchSize:l,dataFormat:o,inDepth:u,inHeight:c,inWidth:d,inChannels:h,outDepth:V,outHeight:G,outWidth:j,outChannels:q,padInfo:R,strideDepth:y,strideHeight:b,strideWidth:v,filterDepth:f,filterHeight:p,filterWidth:g,effectiveFilterDepth:E,effectiveFilterHeight:D,effectiveFilterWidth:N,dilationDepth:_,dilationHeight:x,dilationWidth:C,inShape:n,outShape:K,filterShape:t}}function $I(n,t,e,s=1){const r=Jc(t,s);return Math.floor((n[0]*(e-1)-e+r)/2)}function rp(n){return"number"==typeof n?[n,n,n]:2===n.length?[n[0],n[1],1]:n}function PI(n){return"number"==typeof n?[n,n,n]:n}function Jc(n,t){return t<=1?n:n+(n-1)*(t-1)}function ip(n,t){if(!t)return Math.trunc(n);switch(t){case"round":return Math.round(n);case"ceil":return Math.ceil(n);case"floor":return Math.floor(n);default:throw new Error(`Unknown roundingMode ${t}`)}}function Ya(n){const[t,e,s]=rp(n);return 1===t&&1===e&&1===s}function Ts(n,t){return Ya(n)||Ya(t)}function ru(n){return rp(n).every(t=>t>0)}function la(n){if("NHWC"===n)return"channelsLast";if("NCHW"===n)return"channelsFirst";throw new Error(`Unknown dataFormat ${n}`)}function Xs(n,t,e){if(null!=e){if("string"==typeof t)throw Error(`Error in ${n}: pad must be an integer when using dimRoundingMode ${e} but got pad ${t}.`);if("number"==typeof t)S(Pc(t),()=>`Error in ${n}: pad must be an integer when using dimRoundingMode ${e} but got pad ${t}.`);else{if("object"!=typeof t)throw Error(`Error in ${n}: Unknown padding parameter: ${t}`);t.forEach(s=>{s.forEach(r=>{S(Pc(r),()=>`Error in ${n}: pad must be an integer when using dimRoundingMode ${e} but got pad ${r}.`)})})}}}const O=k({reshape_:function Xne(n,t){const s={x:I(n,"x","reshape","string_or_numeric")};return M.runKernel(sb,s,{shape:t})}}),Rb=k({avgPool_:function Yne(n,t,e,s,r){const i=I(n,"x","avgPool","float32");S(Ts(e,1),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${e} and dilations '1'`);let a=i,l=!1;3===i.rank&&(l=!0,a=O(i,[1,i.shape[0],i.shape[1],i.shape[2]])),S(4===a.rank,()=>`Error in avgPool: x must be rank 4 but got rank ${a.rank}.`),Xs("avgPool",s,r);let d=M.runKernel(vy,{x:a},{filterSize:t,strides:e,pad:s,dimRoundingMode:r});return d=xe(d,i.dtype),l?O(d,[d.shape[1],d.shape[2],d.shape[3]]):d}}),ZP=k({avgPool3d_:function Zne(n,t,e,s,r,i="NDHWC"){const o=I(n,"x","avgPool3d","float32");let a=o,l=!1;4===o.rank&&(l=!0,a=O(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),S(5===a.rank,()=>`Error in avgPool3d: x must be rank 5 but got rank ${a.rank}.`),S("NDHWC"===i,()=>`Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of ${i}`),S("number"==typeof e&&e>0||Array.isArray(e)&&e[0]>0&&e[1]>0&&e[2]>0,()=>`Error in avgPool3d: Stride must be > 0, but got '${e}'`),Xs("avgPool3d",s,r);let d=M.runKernel(_y,{x:a},{filterSize:t,strides:e,pad:s,dimRoundingMode:r,dataFormat:i});return d=xe(d,a.dtype),l?O(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}}),jn=k({concat_:function Qne(n,t=0){S(n.length>=1,()=>"Pass at least one tensor to concat");const e=Sb(n,"tensors","concat","string_or_numeric");return"complex64"===e[0].dtype&&e.forEach(i=>{if("complex64"!==i.dtype)throw new Error(`Cannot concatenate complex64 tensors with a tensor\n          with dtype ${i.dtype}. `)}),1===e.length?ra(e[0]):M.runKernel(Sy,e,{axis:t})}}),bt=k({matMul_:function Jne(n,t,e=!1,s=!1){let r=I(n,"a","matMul"),i=I(t,"b","matMul");return[r,i]=Tn(r,i),M.runKernel(wy,{a:r,b:i},{transposeA:e,transposeB:s})}}),_o=k({sigmoid_:function ese(n){const e={x:I(n,"x","sigmoid","float32")};return M.runKernel(Wf,e)}}),Dt=k({slice_:function tse(n,t,e){const s=I(n,"x","slice","string_or_numeric");if(0===s.rank)throw new Error("Slicing scalar is not possible");return M.runKernel(lb,{x:s},{begin:t,size:e})}}),ed=k({tanh_:function nse(n){const e={x:I(n,"x","tanh","float32")};return M.runKernel(Xf,e)}}),rse=k({basicLSTMCell_:function sse(n,t,e,s,r,i){const o=I(n,"forgetBias","basicLSTMCell"),a=I(t,"lstmKernel","basicLSTMCell"),l=I(e,"lstmBias","basicLSTMCell"),u=I(s,"data","basicLSTMCell"),c=I(r,"c","basicLSTMCell"),d=I(i,"h","basicLSTMCell"),h=jn([u,d],1),f=bt(h,a),p=le(f,l),m=p.shape[1]/4,y=[p.shape[0],m],b=Dt(p,[0,0],y),v=Dt(p,[0,m],y),_=Dt(p,[0,2*m],y),x=Dt(p,[0,3*m],y),C=le(F(_o(b),ed(v)),F(c,_o(le(o,_))));return[C,F(ed(C),_o(x))]}}),Mb=k({batchToSpaceND_:function ise(n,t,e){const s=I(n,"x","batchToSpaceND"),r=t.reduce((a,l)=>a*l);return S(s.rank>=1+t.length,()=>`input rank is ${s.rank} but should be > than blockShape.length ${t.length}`),S(e.length===t.length,()=>`crops.length is ${e.length} but should be equal to blockShape.length  ${t.length}`),S(s.shape[0]%r==0,()=>`input tensor batch is ${s.shape[0]} but is not divisible by the product of the elements of blockShape ${t.join(" * ")} === ${r}`),M.runKernel(xy,{x:s},{blockShape:t,crops:e})}});function ose(n){let t;return t=0===n.rank||1===n.rank?O(n,[1,1,1,n.size]):2===n.rank?O(n,[1,1,n.shape[0],n.shape[1]]):3===n.rank?O(n,[1,n.shape[0],n.shape[1],n.shape[2]]):n,t}const op=k({batchNorm_:function ase(n,t,e,s,r,i){null==i&&(i=.001);const o=I(n,"x","batchNorm"),a=I(t,"mean","batchNorm"),l=I(e,"variance","batchNorm");let u,c;null!=r&&(u=I(r,"scale","batchNorm")),null!=s&&(c=I(s,"offset","batchNorm")),S(a.rank===l.rank,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),S(null==c||a.rank===c.rank,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),S(null==u||a.rank===u.rank,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");const h={x:ose(o),scale:u,offset:c,mean:a,variance:l},p=M.runKernel(My,h,{varianceEpsilon:i});return O(p,o.shape)}}),QP=k({batchNorm2d_:function lse(n,t,e,s,r,i){const o=I(n,"x","batchNorm"),a=I(t,"mean","batchNorm"),l=I(e,"variance","batchNorm");let u,c;return null!=r&&(u=I(r,"scale","batchNorm")),null!=s&&(c=I(s,"offset","batchNorm")),S(2===o.rank,()=>`Error in batchNorm2D: x must be rank 2 but got rank ${o.rank}.`),S(2===a.rank||1===a.rank,()=>`Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank ${a.rank}.`),S(2===l.rank||1===l.rank,()=>`Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank ${l.rank}.`),null!=u&&S(2===u.rank||1===u.rank,()=>`Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank ${u.rank}.`),null!=c&&S(2===c.rank||1===c.rank,()=>`Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank ${c.rank}.`),op(o,a,l,c,u,i)}}),JP=k({batchNorm3d_:function use(n,t,e,s,r,i){const o=I(n,"x","batchNorm"),a=I(t,"mean","batchNorm"),l=I(e,"variance","batchNorm");let u,c;return null!=r&&(u=I(r,"scale","batchNorm")),null!=s&&(c=I(s,"offset","batchNorm")),S(3===o.rank,()=>`Error in batchNorm3D: x must be rank 3 but got rank ${o.rank}.`),S(3===a.rank||1===a.rank,()=>`Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank ${a.rank}.`),S(3===l.rank||1===l.rank,()=>`Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank ${l.rank}.`),null!=u&&S(3===u.rank||1===u.rank,()=>`Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank ${u.rank}.`),null!=c&&S(3===c.rank||1===c.rank,()=>`Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank ${c.rank}.`),op(o,a,l,c,u,i)}}),eL=k({batchNorm4d_:function cse(n,t,e,s,r,i){const o=I(n,"x","batchNorm"),a=I(t,"mean","batchNorm"),l=I(e,"variance","batchNorm");let u,c;return null!=r&&(u=I(r,"scale","batchNorm")),null!=s&&(c=I(s,"offset","batchNorm")),S(4===o.rank,()=>`Error in batchNorm4D: x must be rank 4 but got rank ${o.rank}.`),S(4===a.rank||1===a.rank,()=>`Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank ${a.rank}.`),S(4===l.rank||1===l.rank,()=>`Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank ${l.rank}.`),null!=u&&S(4===u.rank||1===u.rank,()=>`Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank ${u.rank}.`),null!=c&&S(4===c.rank||1===c.rank,()=>`Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank ${c.rank}.`),op(o,a,l,c,u,i)}}),tL=k({bincount_:function dse(n,t,e){const s=I(n,"x","bincount"),r=I(t,"weights","bincount");return S("int32"===s.dtype,()=>`Error in bincount: input dtype must be int32, but got ${s.dtype}`),S(e>=0,()=>`size must be non-negative, but got ${e}.`),S(r.size===s.size||0===r.size,()=>`Error in bincount: weights must have the same size as input or0-length, but got input shape: ${s.shape}, weights shape: ${r.shape}.`),M.runKernel(KC,{x:s,weights:r},{size:e})}}),fse=k({bitwiseAnd_:function hse(n,t){const e=I(n,"x","bitwiseAnd"),s=I(t,"y","bitwiseAnd");if(!wt(e.shape,s.shape))throw new Error(`BitwiseAnd: Tensors must have the same shape. x: ${e.shape}, y: ${s.shape}`);if("int32"!==e.dtype||"int32"!==s.dtype)throw new Error(`BitwiseAnd: Only supports 'int32' values in tensor, found type of x: ${e.dtype} and type of y: ${s.dtype}`);return M.runKernel(XC,{a:e,b:s})}}),mse=k({broadcastArgs_:function pse(n,t){const e=I(n,"s0","broadcastArgs","int32"),s=I(t,"s1","broadcastArgs","int32");if(1!==e.rank)throw new Error(`broadcastArgs(): first input must be a vector (rank=1). Has rank ${e.rank}`);if(1!==s.rank)throw new Error(`broadcastArgs(): second input must be a vector (rank=1). Has rank ${s.rank}`);return M.runKernel(YC,{s0:e,s1:s})}}),td=k({broadcastTo_:function gse(n,t){let e=I(n,"broadcastTo","x");const s=e.shape;if(Wr(t),t.length<e.rank)throw new Error(`broadcastTo(): shape.length=${t.length} < input.rank=${e.rank}.`);if(t.length>e.rank){const u=e.shape.slice();for(;u.length<t.length;)u.unshift(1);e=O(e,u)}const r=e.shape,i=Array.from(t);for(let u=t.length-1;u>=0;u--)if(r[u]===t[u])i[u]=1;else if(1!==e.shape[u])throw new Error(`broadcastTo(): [${s}] cannot be broadcast to [${t}].`);return 0===i.map((u,c)=>u>1?c:-1).filter(u=>u>=0).length?ra(e):M.runKernel(Yf,{x:e},{reps:i})}}),nL=k({ceil_:function yse(n){const e={x:I(n,"x","ceil","float32")};return M.runKernel(df,e)}}),Er=k({clipByValue_:function bse(n,t,e){const s=I(n,"x","clipByValue");return S(t<=e,()=>`Error in clip: min (${t}) must be less than or equal to max (${e}).`),t===e?Yc(s.shape,t,s.dtype):M.runKernel(hf,{x:s},{clipValueMin:t,clipValueMax:e})}}),sL=k({concat1d_:function vse(n){return jn(n,0)}}),rL=k({concat2d_:function _se(n,t){return jn(n,t)}}),iL=k({concat3d_:function wse(n,t){return jn(n,t)}}),oL=k({concat4d_:function xse(n,t){return jn(n,t)}}),Za=k({conv2d_:function Cse(n,t,e,s,r="NHWC",i=[1,1],o){const a=I(n,"x","conv2d","float32"),l=I(t,"filter","conv2d","float32");let u=a,c=!1;3===a.rank&&(c=!0,u=O(a,[1,a.shape[0],a.shape[1],a.shape[2]])),S(4===u.rank,()=>`Error in conv2d: input must be rank 4, but got rank ${u.rank}.`),S(4===l.rank,()=>`Error in conv2d: filter must be rank 4, but got rank ${l.rank}.`),Xs("conv2d",s,o);const d="NHWC"===r?u.shape[3]:u.shape[1];S(d===l.shape[2],()=>`Error in conv2d: depth of input (${d}) must match input depth for filter ${l.shape[2]}.`),S(Ts(e,i),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${e} and dilations '${i}'`),S(ru(i),()=>"Error in conv2D: Dilated rates should be larger than 0."),S(ru(e),()=>"Error in conv2D: Strides should be larger than 0.");const p=M.runKernel(Iy,{x:u,filter:l},{strides:e,pad:s,dataFormat:r,dilations:i,dimRoundingMode:o});return c?O(p,[p.shape[1],p.shape[2],p.shape[3]]):p}}),LI=k({conv1d_:function Sse(n,t,e,s,r="NWC",i=1,o){const a=I(n,"x","conv1d"),l=I(t,"filter","conv1d");let u=a,c=!1;2===a.rank&&(c=!0,u=O(a,[1,a.shape[0],a.shape[1]])),S(3===u.rank,()=>`Error in conv1d: input must be rank 3, but got rank ${u.rank}.`),S(3===l.rank,()=>`Error in conv1d: filter must be rank 3, but got rank ${l.rank}.`),Xs("conv1d",s,o),S(u.shape[2]===l.shape[1],()=>`Error in conv1d: depth of input (${u.shape[2]}) must match input depth for filter ${l.shape[1]}.`),S(Ts(e,i),()=>`Error in conv1D: Either stride or dilation must be 1. Got stride ${e} and dilation '${i}'`),S(ru(i),()=>"Error in conv1D: Dilated rates should be larger than 0."),S(ru(e),()=>"Error in conv1D: Stride should be larger than 0."),S("NWC"===r,()=>`Error in conv1d: got dataFormat of ${r} but only NWC is currently supported.`);const d=O(l,[1,l.shape[0],l.shape[1],l.shape[2]]),h=O(u,[u.shape[0],1,u.shape[1],u.shape[2]]),m=Za(h,d,[1,e],s,"NHWC",[1,i],o);return O(m,c?[m.shape[2],m.shape[3]]:[m.shape[0],m.shape[2],m.shape[3]])}}),VI=k({conv2DBackpropInput_:function Ise(n,t,e,s,r,i="NHWC",o){S(n.length===t.rank,()=>`Length of inShape (${n.length}) and rank of dy (${t.rank}) must match`);let a=n,l=t,u=!1;3===t.rank&&(u=!0,l=O(t,[1,t.shape[0],t.shape[1],t.shape[2]]),a=[1,n[0],n[1],n[2]]),S(4===a.length,()=>`Error in conv2dDerInput: inShape must be length 4, but got length ${a.length}.`),S(4===l.rank,()=>`Error in conv2dDerInput: dy must be rank 4, but got rank ${l.rank}`),S(4===e.rank,()=>`Error in conv2dDerInput: filter must be rank 4, but got rank ${e.rank}`);const c="NHWC"===i?a[3]:a[1],d="NHWC"===i?l.shape[3]:l.shape[1];S(c===e.shape[2],()=>`Error in conv2dDerInput: depth of input (${c}) must match input depth for filter ${e.shape[2]}.`),S(d===e.shape[3],()=>`Error in conv2dDerInput: depth of output (${d}) must match output depth for filter ${e.shape[3]}.`),Xs("conv2dDerInput",r,o);const p=M.runKernel(Ey,{dy:l,filter:e},{strides:s,pad:r,dataFormat:i,dimRoundingMode:o,inputShape:a});return u?O(p,[p.shape[1],p.shape[2],p.shape[3]]):p}}),BI=k({conv2dTranspose_:function Ese(n,t,e,s,r,i){const o=I(n,"x","conv2dTranspose"),a=I(t,"filter","conv2dTranspose");return VI(e,o,a,s,r,"NHWC",i)}}),aL=k({conv3d_:function Dse(n,t,e,s,r="NDHWC",i=[1,1,1]){const o=I(n,"x","conv3d"),a=I(t,"filter","conv3d");let l=o,u=!1;4===o.rank&&(u=!0,l=O(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),S(5===l.rank,()=>`Error in conv3d: input must be rank 5, but got rank ${l.rank}.`),S(5===a.rank,()=>`Error in conv3d: filter must be rank 5, but got rank ${a.rank}.`),S(l.shape[4]===a.shape[3],()=>`Error in conv3d: depth of input (${l.shape[4]}) must match input depth for filter ${a.shape[3]}.`),S(Ts(e,i),()=>`Error in conv3D: Either strides or dilations must be 1. Got strides ${e} and dilations '${i}'`),S("NDHWC"===r,()=>`Error in conv3d: got dataFormat of ${r} but only NDHWC is currently supported.`),S(ru(i),()=>"Error in conv3D: Dilated rates should be larger than 0."),S(ru(e),()=>"Error in conv3D: Strides should be larger than 0.");const h=M.runKernel(Dy,{x:l,filter:a},{strides:e,pad:s,dataFormat:r,dilations:i});return u?O(h,[h.shape[1],h.shape[2],h.shape[3],h.shape[4]]):h}}),lL=k({conv3DBackpropInput_:function Tse(n,t,e,s,r){S(n.length===t.rank,()=>`Length of inShape (${n.length}) and rank of dy (${t.rank}) must match`);let i=n,o=t,a=!1;4===t.rank&&(a=!0,o=O(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]]),i=[1,n[0],n[1],n[2],n[3]]);const l=i[4],u=o.shape[4];S(5===i.length,()=>`Error in conv3dDerInput: inShape must be length 5, but got length ${i.length}.`),S(5===o.rank,()=>`Error in conv3dDerInput: dy must be rank 5, but got rank ${o.rank}`),S(5===e.rank,()=>`Error in conv3dDerInput: filter must be rank 5, but got rank ${e.rank}`),S(l===e.shape[3],()=>`Error in conv3dDerInput: depth of input (${l}) must match input depth for filter ${e.shape[3]}.`),S(u===e.shape[4],()=>`Error in conv3dDerInput: depth of output (${u}) must match output depth for filter ${e.shape[4]}.`);const h=M.runKernel(eS,{dy:o,filter:e},{pad:r,strides:s,inputShape:i});return a?O(h,[h.shape[1],h.shape[2],h.shape[3],h.shape[4]]):h}}),uL=k({conv3dTranspose_:function Nse(n,t,e,s,r){const i=I(n,"x","conv3dTranspose"),o=I(t,"filter","conv3dTranspose");return lL(e,i,o,s,r)}}),Fb=k({cos_:function kse(n){const e={x:I(n,"x","cos","float32")};return M.runKernel(ff,e)}}),zI=k({cosh_:function Ase(n){const e={x:I(n,"x","cosh","float32")};return M.runKernel(pf,e)}}),Ob=k({cumprod_:function Rse(n,t=0,e=!1,s=!1){const i={x:I(n,"x","cumprod")};return M.runKernel(tS,i,{axis:t,exclusive:e,reverse:s})}}),UI=k({cumsum_:function Mse(n,t=0,e=!1,s=!1){const i={x:I(n,"x","cumsum")};return M.runKernel(Ty,i,{axis:t,exclusive:e,reverse:s})}}),WI=k({denseBincount_:function Fse(n,t,e,s=!1){const r=I(n,"x","denseBincount"),i=I(t,"weights","denseBincount");return S("int32"===r.dtype,()=>`Error in denseBincount: input dtype must be int32, but got ${r.dtype}`),S(r.rank<=2,()=>`Error in denseBincount: input must be at most rank 2, but got rank ${r.rank}.`),S(e>=0,()=>`size must be non-negative, but got ${e}.`),S(i.size===r.size||0===i.size,()=>`Error in denseBincount: weights must have the same shape as x or 0-length, but got x shape: ${r.shape}, weights shape: ${i.shape}.`),M.runKernel(sS,{x:r,weights:i},{size:e,binaryOutput:s})}}),cL=k({depthToSpace_:function Ose(n,t,e="NHWC"){const s=I(n,"x","depthToSpace","float32"),r="NHWC"===e?s.shape[1]:s.shape[2],i="NHWC"===e?s.shape[2]:s.shape[3],o="NHWC"===e?s.shape[3]:s.shape[1];return S(t>1,()=>`blockSize should be > 1 for depthToSpace, but was: ${t}`),S(r*t>=0,()=>`Negative dimension size caused by overflow when multiplying\n    ${r} and ${t}  for depthToSpace with input shape\n    ${s.shape}`),S(i*t>=0,()=>`Negative dimension size caused by overflow when multiplying\n    ${i} and ${t} for depthToSpace with input shape\n        ${s.shape}`),S(o%(t*t)==0,()=>`Dimension size must be evenly divisible by ${t*t} but is ${o} for depthToSpace with input shape ${s.shape}`),M.runKernel(rS,{x:s},{blockSize:t,dataFormat:e})}}),ap=k({depthwiseConv2d_:function $se(n,t,e,s,r="NHWC",i=[1,1],o){const a=I(n,"x","depthwiseConv2d","float32"),l=I(t,"filter","depthwiseConv2d","float32");let u=a,c=!1;3===a.rank&&(c=!0,u=O(a,[1,a.shape[0],a.shape[1],a.shape[2]])),S(4===u.rank,()=>`Error in depthwiseConv2d: input must be rank 4, but got rank ${u.rank}.`),S(4===l.rank,()=>`Error in depthwiseConv2d: filter must be rank 4, but got rank ${l.rank}.`);const d="NHWC"===r?u.shape[3]:u.shape[1];S(d===l.shape[2],()=>`Error in depthwiseConv2d: number of input channels (${d}) must match the inChannels dimension in filter ${l.shape[2]}.`),Xs("depthwiseConv2d",s,o);const p=M.runKernel(Ny,{x:u,filter:l},{strides:e,pad:s,dataFormat:r,dilations:i,dimRoundingMode:o});return c?O(p,[p.shape[1],p.shape[2],p.shape[3]]):p}}),Lse=k({diag_:function Pse(n){const e={x:I(n,"x","diag")};return M.runKernel(aS,e)}}),dL=k({dilation2d_:function Vse(n,t,e,s,r=[1,1],i="NHWC"){const o=I(n,"x","dilation2d"),a=I(t,"filter","dilation2d");S(3===o.rank||4===o.rank,()=>`Error in dilation2d: input must be rank 3 or 4, but got rank ${o.rank}.`),S(3===a.rank,()=>`Error in dilation2d: filter must be rank 3, but got rank ${a.rank}.`),S("NHWC"===i,()=>`Error in dilation2d: Only NHWC is currently supported, but got dataFormat of ${i}`);let l=o,u=!1;3===o.rank&&(l=O(o,[1,o.shape[0],o.shape[1],o.shape[2]]),u=!0),S(l.shape[3]===a.shape[2],()=>`Error in dilation2d:  input and filter must have the same depth: ${l.shape[3]} vs ${a.shape[2]}`);const h=M.runKernel(ky,{x:l,filter:a},{strides:e,pad:s,dilations:r});return u?O(h,[h.shape[1],h.shape[2],h.shape[3]]):h}}),Wi=k({equal_:function Bse(n,t){let e=I(n,"a","equal","string_or_numeric"),s=I(t,"b","equal","string_or_numeric");return[e,s]=Tn(e,s),nt(e.shape,s.shape),M.runKernel(Ay,{a:e,b:s})}}),zs=k({where_:function zse(n,t,e){const s=I(t,"a","where"),r=I(e,"b","where"),i=I(n,"condition","where","bool"),o=nt(nt(i.shape,s.shape),r.shape),a=td(i,o),l=td(s,o),u=td(r,o);return M.runKernel(ab,{condition:a,t:l,e:u})}}),hL=k({divNoNan_:function Use(n,t){let e=I(n,"a","div"),s=I(t,"b","div");[e,s]=Tn(e,s);const r=Pe(e,s),i=Et(r),o=Wi(s,i);return zs(o,i,r)}}),fL=k({dot_:function Wse(n,t){const e=I(n,"t1","dot"),s=I(t,"t2","dot");S(!(1!==e.rank&&2!==e.rank||1!==s.rank&&2!==s.rank),()=>`Error in dot: inputs must all be rank 1 or 2, but got ranks ${e.rank} and ${s.rank}.`);const r=1===e.rank?e.size:e.shape[1],i=1===s.rank?s.size:s.shape[0];if(S(r===i,()=>`Error in dot: inner dimensions of inputs must match, but got ${r} and ${i}.`),1===e.rank&&1===s.rank){const o=O(e,[1,-1]),a=O(s,[-1,1]),l=bt(o,a);return O(l,[])}if(1===e.rank&&2===s.rank){const o=O(e,[1,-1]),a=O(s,[s.shape[0],s.shape[1]]),l=bt(o,a);return O(l,[l.size])}if(2===e.rank&&1===s.rank){const o=O(s,[-1,1]),a=bt(e,o);return O(a,[a.size])}{const o=O(s,[s.shape[0],s.shape[1]]);return bt(e,o)}}}),Hse=k({einsum_:function Gse(n,...t){const e=t.map((r,i)=>I(r,`tensors${i}`,"einsum"));return M.runKernel(cS,e,{equation:n})}}),lp=k({elu_:function jse(n){const e={x:I(n,"x","elu","float32")};return M.runKernel(gf,e)}}),Kse=k({ensureShape_:function qse(n,t){const e=I(n,"x","ensureShape","string_or_numeric");if(!function kee(n,t){if(n===t)return!0;if(null==n||null==t||n.length!==t.length)return!1;for(let e=0;e<n.length;e++)if(null!==n[e]&&null!==t[e]&&n[e]!==t[e])return!1;return!0}(e.shape,t))throw new Error(`EnsureShape: Shape of tensor ${e.shape} is not compatible with expected shape ${t}`);return n}}),pL=k({erf_:function Xse(n){let t=I(n,"x","erf");return S("int32"===t.dtype||"float32"===t.dtype,()=>"Input dtype must be `int32` or `float32`."),"int32"===t.dtype&&(t=xe(t,"float32")),M.runKernel(yf,{x:t})}});function GI(n,t){for(let e=0;e<n.length;++e)if(n[n.length-e-1]!==t-1-e)return!1;return!0}function mL(n,t,e){const s=n.length+t.length,r=[];let i=0,o=0;for(let a=0;a<s;a++)-1===e.indexOf(a)?r.push(n[i++]):r.push(t[o++]);return r}function ws(n,t){const e=[],s=n.length;for(let i=0;i<s;i++)-1===t.indexOf(i)&&e.push(n[i]);return[e,t.map(i=>n[i])]}function On(n,t){return mL(n,t.map(s=>1),t)}function Ns(n,t,e){S(GI(t,e),()=>`${n} supports only inner-most axes for now. Got axes ${t} and rank-${e} input.`)}function vn(n,t){if(GI(n,t))return null;const e=[];for(let s=0;s<t;++s)-1===n.indexOf(s)&&e.push(s);return n.forEach(s=>e.push(s)),e}function Qa(n){return n.map((t,e)=>[e,t]).sort((t,e)=>t[1]-e[1]).map(t=>t[0])}function $n(n,t){const e=[];for(let s=t-n;s<t;++s)e.push(s);return e}const mi=k({max_:function Yse(n,t=null,e=!1){const r={x:I(n,"x","max")};return M.runKernel(Wy,r,{reductionIndices:t,keepDims:e})}}),up=k({min_:function Zse(n,t=null,e=!1){const r={x:I(n,"x","min")};return M.runKernel(qy,r,{axis:t,keepDims:e})}}),Re=k({sum_:function Qse(n,t=null,e=!1){let s=I(n,"x","sum");return"bool"===s.dtype&&(s=xe(s,"int32")),M.runKernel(ub,{x:s},{axis:t,keepDims:e})}});function gL(n,t,e=null){if(0===n.rank)return ns(n);if(1!==n.rank&&null===e)return gL(O(n,[-1]),t,e);if(1===n.rank||"number"==typeof e||Array.isArray(e)&&1===e.length){if(1===t)return Re(ns(n),e);if(t===1/0)return mi(ns(n),e);if(t===-1/0)return up(ns(n),e);if("euclidean"===t||2===t)return Bs(Re(Ka(ns(n),ze(2,"int32")),e));throw new Error(`Error in norm: invalid ord value: ${t}`)}if(Array.isArray(e)&&2===e.length){if(1===t)return mi(Re(ns(n),e[0]),e[1]-1);if(t===1/0)return mi(Re(ns(n),e[1]),e[0]);if(t===-1/0)return up(Re(ns(n),e[1]),e[0]);if("fro"===t||"euclidean"===t)return Bs(Re(en(n),e));throw new Error(`Error in norm: invalid ord value: ${t}`)}throw new Error(`Error in norm: invalid axis: ${e}`)}const cp=k({norm_:function Jse(n,t="euclidean",e=null,s=!1){const r=gL(n=I(n,"x","norm"),t,e);let i=r.shape;if(s){const o=mt(e,n.shape);i=On(r.shape,o)}return O(r,i)}}),yL=k({euclideanNorm_:function ere(n,t=null,e=!1){return cp(n,"euclidean",t,e)}}),Hr=k({exp_:function tre(n){const e={x:I(n,"x","exp")};return M.runKernel(bf,e)}}),ar=k({expandDims_:function nre(n,t=0){const e=I(n,"x","expandDims","string_or_numeric");return S(t<=e.rank,()=>"Axis must be <= rank of the tensor"),M.runKernel(Ry,{input:e},{dim:t})}}),bL=k({expm1_:function sre(n){const e={x:I(n,"x","expm1")};return M.runKernel(vf,e)}}),gi=k({tile_:function rre(n,t){const e=I(n,"x","tile","string_or_numeric");return S(e.rank===t.length,()=>`Error in transpose: rank of input ${e.rank} must match length of reps ${t}.`),M.runKernel(Yf,{x:e},{reps:t})}}),HI=k({eye_:function ire(n,t,e,s="float32"){null==t&&(t=n);const r=dt([n,t],s),i=n<=t?n:t;for(let a=0;a<i;++a)r.set(1,a,a);const o=O(r.toTensor(),[n,t]);if(null==e)return o;if(1===e.length)return gi(ar(o,0),[e[0],1,1]);if(2===e.length)return gi(ar(ar(o,0),0),[e[0],e[1],1,1]);if(3===e.length)return gi(ar(ar(ar(o,0),0),0),[e[0],e[1],e[2],1,1]);throw new Error(`eye() currently supports only 1D and 2D batchShapes, but received ${e.length}D.`)}}),dp=k({floor_:function ore(n){const e={x:I(n,"x","floor","float32")};return M.runKernel(_f,e)}}),hp=k({gather_:function are(n,t,e=0,s=0){const r=I(n,"x","gather"),i=I(t,"indices","gather","int32");return M.runKernel(Fy,{x:r,indices:i},{axis:e,batchDims:s})}}),Dr=k({greater_:function lre(n,t){let e=I(n,"a","greater","string_or_numeric"),s=I(t,"b","greater","string_or_numeric");return[e,s]=Tn(e,s),nt(e.shape,s.shape),M.runKernel(Oy,{a:e,b:s})}}),Ja=k({greaterEqual_:function ure(n,t){let e=I(n,"a","greaterEqual","string_or_numeric"),s=I(t,"b","greaterEqual","string_or_numeric");return[e,s]=Tn(e,s),nt(e.shape,s.shape),M.runKernel(xf,{a:e,b:s})}}),$b=k({imag_:function cre(n){const e={input:I(n,"input","imag")};return M.runKernel(yS,e)}}),vL=k({isFinite_:function dre(n){const e={x:I(n,"x","isFinite")};return M.runKernel(Sf,e)}}),_L=k({isInf_:function hre(n){const e={x:I(n,"x","isInf")};return M.runKernel(If,e)}}),wL=k({isNaN_:function fre(n){const e={x:I(n,"x","isNaN")};return M.runKernel(Ef,e)}}),Pb=k({leakyRelu_:function pre(n,t=.2){const s={x:I(n,"x","leakyRelu")};return M.runKernel($y,s,{alpha:t})}}),fp=k({less_:function mre(n,t){let e=I(n,"a","less","string_or_numeric"),s=I(t,"b","less","string_or_numeric");return[e,s]=Tn(e,s),nt(e.shape,s.shape),M.runKernel(Py,{a:e,b:s})}}),iu=k({lessEqual_:function gre(n,t){let e=I(n,"a","lessEqual","string_or_numeric"),s=I(t,"b","lessEqual","string_or_numeric");return[e,s]=Tn(e,s),nt(e.shape,s.shape),M.runKernel(Ly,{a:e,b:s})}});function yre(n,t,e){if(e<=0)throw new Error("The number of values should be positive.");return M.runKernel(bS,{},{start:n,stop:t,num:e})}const xL=k({localResponseNormalization_:function bre(n,t=5,e=1,s=1,r=.5){const i=I(n,"x","localResponseNormalization");S(4===i.rank||3===i.rank,()=>`Error in localResponseNormalization: x must be rank 3 or 4 but got\n               rank ${i.rank}.`),S(Pc(t),()=>`Error in localResponseNormalization: depthRadius must be an integer but got depthRadius ${t}.`);let o=i,a=!1;3===i.rank&&(a=!0,o=O(i,[1,i.shape[0],i.shape[1],i.shape[2]]));const c=M.runKernel(Uy,{x:o},{depthRadius:t,bias:e,alpha:s,beta:r});return a?O(c,[c.shape[1],c.shape[2],c.shape[3]]):c}}),jr=k({log_:function vre(n){const e={x:I(n,"x","log","float32")};return M.runKernel(Df,e)}}),Lb=k({log1p_:function _re(n){const e={x:I(n,"x","log1p")};return M.runKernel(Tf,e)}}),dn=k({neg_:function wre(n){const e={x:I(n,"x","neg")};return M.runKernel(Xy,e)}}),nd=k({softplus_:function xre(n){const e={x:I(n,"x","softplus")};return M.runKernel(Gf,e)}}),CL=k({logSigmoid_:function Cre(n){const t=I(n,"x","logSigmoid");return ia(s=>({value:dn(nd(dn(s))),gradFunc:o=>F(o,_o(dn(s)))}))(t)}}),jI=k({logSoftmax_:function Sre(n,t=-1){const e=I(n,"logits","logSoftmax");if(-1===t&&(t=e.rank-1),t!==e.rank-1)throw Error(`Log Softmax along a non-last dimension is not yet supported. Logits was rank ${e.rank} and axis was ${t}`);return ia((r,i)=>{const a=mi(r,t,!0),l=Ne(r,a),u=Ne(xe(l,"float32"),jr(Re(Hr(l),t,!0)));return i([u]),{value:u,gradFunc:(d,h)=>{const[f]=h,g=Hr(f);return Ne(d,F(Re(d,t,!0),g))}}})(e)}}),qI=k({logSumExp_:function Ire(n,t=null,e=!1){const s=I(n,"x","logSumExp"),r=mt(t,s.shape),i=mi(s,r,!0),o=Ne(s,i),a=Hr(o),l=Re(a,r),u=jr(l),c=le(O(i,u.shape),u);if(e){const d=On(c.shape,r);return O(c,d)}return c}}),wo=k({logicalAnd_:function Ere(n,t){const e=I(n,"a","logicalAnd","bool"),s=I(t,"b","logicalAnd","bool");return nt(e.shape,s.shape),M.runKernel(Vy,{a:e,b:s})}}),Vb=k({logicalNot_:function Dre(n){const e={x:I(n,"x","logicalNot","bool")};return M.runKernel(By,e)}}),KI=k({logicalOr_:function Tre(n,t){const e=I(n,"a","logicalOr","bool"),s=I(t,"b","logicalOr","bool");return nt(e.shape,s.shape),M.runKernel(zy,{a:e,b:s})}}),SL=k({logicalXor_:function Nre(n,t){const e=I(n,"a","logicalXor","bool"),s=I(t,"b","logicalXor","bool");return nt(e.shape,s.shape),wo(KI(n,t),Vb(wo(n,t)))}}),Bb=2147483648,XI=k({searchSorted_:function kre(n,t,e="left"){const s=I(n,"sortedSequence","searchSorted"),r=I(t,"values","searchSorted"),o=r.shape[r.shape.length-1],a=O(s,[-1,s.shape[s.shape.length-1]]),l=O(r,[-1,o]);if(a.rank<2)throw new Error("Sorted input argument must be at least 2-dimensional");if(a.shape[0]!==l.shape[0])throw new Error("Leading dimension of 'sortedSequence' and 'values' must match.");if(X(l.shape)>=Bb)throw new Error(`values tensor size must less than ${Bb}`);if(a.shape[1]>=Bb)throw new Error(`trailing dim_size must less than ${Bb} for int32 output type, was ${a.shape[1]}`);return M.runKernel($S,{sortedSequence:a,values:l},{side:e})}});function Are(n,t){return XI(n,t,"left")}const zb=k({maxPool_:function Rre(n,t,e,s,r){const i=I(n,"x","maxPool");let a=i,l=!1;3===i.rank&&(l=!0,a=O(i,[1,i.shape[0],i.shape[1],i.shape[2]])),S(4===a.rank,()=>`Error in maxPool: input must be rank 4 but got rank ${a.rank}.`),S(Ts(e,1),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${e} and dilations '1'`),Xs("maxPool",s,r);const d=M.runKernel(Gy,{x:a},{filterSize:t,strides:e,pad:s,dimRoundingMode:r});return l?O(d,[d.shape[1],d.shape[2],d.shape[3]]):d}}),IL=k({maxPool3d_:function Mre(n,t=[1,1,1],e,s,r,i="NDHWC"){const o=I(n,"x","maxPool3d");let a=o,l=!1;4===o.rank&&(l=!0,a=O(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),S(5===a.rank,()=>`Error in maxPool3d: x must be rank 5 but got rank ${a.rank}.`),S("NDHWC"===i,()=>`Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of ${i}`),Xs("maxPool3d",s,r);const d=M.runKernel(Hy,{x:a},{filterSize:t,strides:e,pad:s,dimRoundingMode:r,dataFormat:i});return l?O(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}}),Ore=k({maxPoolWithArgmax_:function Fre(n,t,e,s,r=!1){const o={x:I(n,"x","maxPoolWithArgmax")},l=M.runKernel(xS,o,{filterSize:t,strides:e,pad:s,includeBatchInIndex:r});return{result:l[0],indexes:l[1]}}}),Nn=k({mean_:function $re(n,t=null,e=!1){const r={x:I(n,"x","mean")};return M.runKernel(jy,r,{axis:t,keepDims:e})}});function rs(n,t="float32"){if(Wr(n),"complex64"===t){const s=rs(n,"float32"),r=rs(n,"float32");return Ga(s,r)}const e=Vs(X(n),t);return M.makeTensor(e,n,t)}function qr(n,t="float32"){if(Wr(n),"complex64"===t){const s=qr(n,"float32"),r=rs(n,"float32");return Ga(s,r)}const e=zC(X(n),t);return M.makeTensor(e,n,t)}function Pre(n,t,{indexing:e="xy"}={}){if("xy"!==e&&"ij"!==e)throw new TypeError(`${e} is not a valid third argument to meshgrid`);if(void 0===n)return[];let s=I(n,"x","meshgrid",n instanceof pn?n.dtype:"float32");if(void 0===t)return[s];let r=I(t,"y","meshgrid",t instanceof pn?t.dtype:"float32");const i=X(s.shape),o=X(r.shape);return"xy"===e?(s=O(s,[1,-1]),r=O(r,[-1,1]),[bt(qr([o,1],s.dtype),s),bt(r,qr([1,i],r.dtype))]):(s=O(s,[-1,1]),r=O(r,[1,-1]),[bt(s,qr([1,o],s.dtype)),bt(qr([i,1],r.dtype),r)])}const ou=k({minimum_:function Lre(n,t){let e=I(n,"a","minimum"),s=I(t,"b","minimum");return[e,s]=Tn(e,s),"bool"===e.dtype&&(e=xe(e,"int32"),s=xe(s,"int32")),nt(e.shape,s.shape),M.runKernel(kf,{a:e,b:s})}}),EL=k({mirrorPad_:function Vre(n,t,e){S("reflect"===e||"symmetric"===e,()=>`Invalid mode. Mode must be either reflect or symmetric. Got ${e}.`);const s=I(n,"x","mirrorPad");if(0===s.rank)throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");S(t.length===s.rank,()=>`Padding doesn't match input. Must be ${s.rank}. Got ${t.length}.`);const r="reflect"===e?1:0;for(let a=0;a<s.rank;a++)S(2===t[a].length,()=>"Invalid number of paddings. Must be length of 2 each."),S(t[a][0]>=0&&t[a][0]<=s.shape[a]-r&&t[a][1]>=0&&t[a][1]<=s.shape[a]-r,()=>`Padding in dimension ${a} cannot be greater than or equal to ${s.shape[a]-r} or less than 0 for input of shape ${s.shape}`);return M.runKernel(Ky,{x:s},{paddings:t,mode:e})}}),DL=k({mod_:function Bre(n,t){let e=I(n,"a","mod"),s=I(t,"b","mod");return[e,s]=Tn(e,s),M.runKernel(Af,{a:e,b:s})}}),Ub=k({moments_:function zre(n,t=null,e=!1){const s=mt(t,(n=I(n,"x","moments")).shape),r=Nn(n,s,e);let i=r.shape;e||(i=On(r.shape,s));const o=en(Ne(xe(n,"float32"),O(r,i)));return{mean:r,variance:Nn(o,s,e)}}}),Wre=k({multiRNNCell_:function Ure(n,t,e,s){const r=I(t,"data","multiRNNCell"),i=Sb(e,"c","multiRNNCell"),o=Sb(s,"h","multiRNNCell");let a=r;const l=[];for(let d=0;d<n.length;d++){const h=n[d](a,i[d],o[d]);l.push(h[0]),l.push(h[1]),a=h[1]}const u=[],c=[];for(let d=0;d<l.length;d+=2)u.push(l[d]),c.push(l[d+1]);return[u,c]}}),Hre=k({multinomial_:function Gre(n,t,e,s=!1){const r=I(n,"logits","multinomial"),i=r.size,o=r.rank;if(i<2)throw new Error(`Error in multinomial: you need at least 2 outcomes, but got ${i}.`);if(o>2)throw new Error(`Rank of probabilities must be 1 or 2, but is ${o}`);e=e||Math.random();const l={logits:1===o?O(r,[1,-1]):r},c=M.runKernel(CS,l,{numSamples:t,seed:e,normalized:s});return 1===o?O(c,[c.size]):c}}),sd=k({notEqual_:function jre(n,t){let e=I(n,"a","notEqual","string_or_numeric"),s=I(t,"b","notEqual","string_or_numeric");return[e,s]=Tn(e,s),nt(e.shape,s.shape),M.runKernel(Yy,{a:e,b:s})}}),YI=k({oneHot_:function qre(n,t,e=1,s=0,r="int32"){if(t<2)throw new Error(`Error in oneHot: depth must be >=2, but it is ${t}`);const o={indices:I(n,"indices","oneHot","int32")};return M.runKernel(Qy,o,{dtype:r,depth:t,onValue:e,offValue:s})}}),Kr=k({onesLike_:function Kre(n){const e={x:I(n,"x","onesLike")};return M.runKernel(Zy,e)}}),Yre=k({outerProduct_:function Xre(n,t){const e=I(n,"v1","outerProduct"),s=I(t,"v2","outerProduct");S(1===e.rank&&1===s.rank,()=>`Error in outerProduct: inputs must be rank 1, but got ranks ${e.rank} and ${s.rank}.`);const r=O(e,[-1,1]),i=O(s,[1,-1]);return bt(r,i)}}),el=k({pad_:function Zre(n,t,e=0){const s=I(n,"x","pad");if(0===s.rank)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");return M.runKernel(eb,{x:s},{paddings:t,constantValue:e})}}),Jre=k({pad1d_:function Qre(n,t,e=0){return S(2===t.length,()=>"Invalid number of paddings. Must be length of 2."),el(n,[t],e)}}),tie=k({pad2d_:function eie(n,t,e=0){return S(2===t.length&&2===t[0].length&&2===t[1].length,()=>"Invalid number of paddings. Must be length of 2 each."),el(n,t,e)}}),sie=k({pad3d_:function nie(n,t,e=0){return S(3===t.length&&2===t[0].length&&2===t[1].length&&2===t[2].length,()=>"Invalid number of paddings. Must be length of 2 each."),el(n,t,e)}}),iie=k({pad4d_:function rie(n,t,e=0){return S(4===t.length&&2===t[0].length&&2===t[1].length&&2===t[2].length&&2===t[3].length,()=>"Invalid number of paddings. Must be length of 2 each."),el(n,t,e)}}),Wb=k({spaceToBatchND_:function oie(n,t,e){const s=I(n,"x","spaceToBatchND");return S(s.rank>=1+t.length,()=>`input rank ${s.rank} should be > than [blockShape] ${t.length}`),S(e.length===t.length,()=>`paddings.shape[0] ${e.length} must be equal to [blockShape] ${t.length}`),S(s.shape.reduce((o,a,l)=>l>0&&l<=t.length?o&&(a+e[l-1][0]+e[l-1][1])%t[l-1]==0:o,!0),()=>`input spatial dimensions ${s.shape.slice(1)} with paddings ${e.toString()} must be divisible by blockShapes ${t.toString()}`),M.runKernel(cb,{x:s},{blockShape:t,paddings:e})}}),TL=k({pool_:function aie(n,t,e,s,r,i,o){null==r&&(r=[1,1]),null==i&&(i=1),0===s&&(s="valid");const a=I(n,"x","maxPool");let l=a,u=!1;3===a.rank&&(u=!0,l=O(a,[1,a.shape[0],a.shape[1],a.shape[2]])),S(Ts(i,r),()=>`Error in pool: Either strides or dilations must be 1. Got strides ${i} and dilations '${r}'`);const c=pi(l.shape,t,i,r,s),d=[c.dilationHeight,c.dilationWidth];let h;h="same"===s?function uie(n,t){const s=n.map((o,a)=>o+(o-1)*(t[a]-1)).map(o=>o-1),r=s.map(o=>Math.floor(o/2)),i=s.map((o,a)=>o-r[a]);return s.map((o,a)=>[r[a],i[a]])}([c.filterHeight,c.filterWidth],d):[[0,0],[0,0]];const f=1===d[0]&&1===d[1],[p,g]=function lie(n,t,e){const s=e.map(c=>c[0]),r=e.map(c=>c[1]),i=n.concat(s,r),o=t.map((c,d)=>(c-i[d]%c)%c),a=r.map((c,d)=>c+o[d]),l=t.map((c,d)=>[s[d],a[d]]),u=t.map((c,d)=>[0,o[d]]);return[l,u]}([c.inHeight,c.inWidth],d,h),m=f?s:"valid",y=f?l:Wb(l,d,p),v=("avg"===e?()=>Rb(y,t,i,m,o):()=>zb(y,t,i,m,o))(),_=f?v:Mb(v,d,g);return u?O(_,[_.shape[1],_.shape[2],_.shape[3]]):_}}),Gb=k({prelu_:function cie(n,t){const e=I(n,"x","prelu"),s=I(t,"alpha","prelu");return M.runKernel(tb,{x:e,alpha:s})}}),NL=k({prod_:function die(n,t=null,e=!1){let s=I(n,"x","prod");return"bool"===s.dtype&&(s=xe(s,"int32")),M.runKernel(nb,{x:s},{axis:t,keepDims:e})}}),fie=k({raggedGather_:function hie(n,t,e,s){const r=n.map((c,d)=>I(c,`tensors${d}`,"raggedGather","int32")),i=I(t,"paramsDenseValues","raggedGather"),o=I(e,"indices","raggedGather","int32"),u=M.runKernel(DS,{paramsNestedSplits:r,paramsDenseValues:i,indices:o},{outputRaggedRank:s});return{outputNestedSplits:u.slice(0,u.length-1),outputDenseValues:u[u.length-1]}}}),mie=k({raggedRange_:function pie(n,t,e){const s=I(n,"starts","raggedRange"),r=I(t,"limits","raggedRange",s.dtype),i=I(e,"deltas","raggedRange",s.dtype),a=M.runKernel(TS,{starts:s,limits:r,deltas:i});return{rtNestedSplits:a[0],rtDenseValues:a[1]}}}),yie=k({raggedTensorToTensor_:function gie(n,t,e,s,r){const i=I(n,"shape","raggedTensorToTensor","int32"),o=I(t,"values","raggedTensorToTensor"),a=I(e,"defaultValue","raggedTensorToTensor",o.dtype),l=s.map((d,h)=>I(d,`tensors${h}`,"raggedTensorToTensor","int32"));return M.runKernel(NS,{shape:i,values:o,defaultValue:a,rowPartitionTensors:l},{rowPartitionTypes:r})}}),vie=k({rand_:function bie(n,t,e){Wr(n);const s=X(n);let r=null;if(null==e||"float32"===e)r=new Float32Array(s);else if("int32"===e)r=new Int32Array(s);else{if("bool"!==e)throw new Error(`Unknown data type ${e}`);r=new Uint8Array(s)}for(let i=0;i<s;i++)r[i]=t();return M.makeTensor(r,n,e)}});var Hb=Q(340);class ZI{constructor(t,e,s,r,i){this.mean=t,this.stdDev=e,this.dtype=s,this.nextVal=NaN,this.truncated=r,this.truncated&&(this.upper=this.mean+2*this.stdDev,this.lower=this.mean-2*this.stdDev);const o=i||Math.random();this.random=Hb.alea(o.toString())}nextValue(){if(!isNaN(this.nextVal)){const r=this.nextVal;return this.nextVal=NaN,r}let t,e,s=!1;for(;!s;){let r,i,o;do{r=2*this.random()-1,i=2*this.random()-1,o=r*r+i*i}while(o>=1||0===o);const a=Math.sqrt(-2*Math.log(o)/o);t=this.mean+this.stdDev*r*a,e=this.mean+this.stdDev*i*a,(!this.truncated||this.isValidTruncated(t))&&(s=!0)}return(!this.truncated||this.isValidTruncated(e))&&(this.nextVal=this.convertValue(e)),this.convertValue(t)}convertValue(t){return null==this.dtype||"float32"===this.dtype?t:Math.round(t)}isValidTruncated(t){return t<=this.upper&&t>=this.lower}}class _ie{constructor(t,e,s,r){this.alpha=t,this.beta=1/e,this.dtype=s;const i=r||Math.random();this.randu=Hb.alea(i.toString()),this.randn=new ZI(0,1,s,!1,this.randu()),this.d=t<1?t+2/3:t-1/3,this.c=1/Math.sqrt(9*this.d)}nextValue(){let t,e,s,r,i,o;for(;;){do{r=this.randn.nextValue(),o=1+this.c*r}while(o<=0);if(o*=o*o,t=r*r,e=1-.331*t*t,s=.5*t+this.d*(1-o+Math.log(o)),i=this.randu(),i<e||Math.log(i)<s)break}return o*=1/this.beta*this.d,this.alpha<1&&(o*=Math.pow(this.randu(),1/this.alpha)),this.convertValue(o)}convertValue(t){return"float32"===this.dtype?t:Math.round(t)}}class wie{constructor(t=0,e=1,s,r){if(this.canReturnFloat=()=>null==this.dtype||"float32"===this.dtype,this.min=t,this.range=e-t,this.dtype=s,null==r&&(r=Math.random()),"number"==typeof r&&(r=r.toString()),!this.canReturnFloat()&&this.range<=1)throw new Error(`The difference between ${t} - ${e} <= 1 and dtype is not float`);this.random=Hb.alea(r)}convertValue(t){return this.canReturnFloat()?t:Math.round(t)}nextValue(){return this.convertValue(this.min+this.range*this.random())}}const Eie=k({randomGamma_:function Iie(n,t,e=1,s="float32",r){if(Wr(n),null==e&&(e=1),null==s&&(s="float32"),"float32"!==s&&"int32"!==s)throw new Error(`Unsupported data type ${s}`);const i=new _ie(t,e,s,r),o=dt(n,s);for(let a=0;a<o.values.length;a++)o.values[a]=i.nextValue();return o.toTensor()}}),JI=k({randomNormal_:function Die(n,t=0,e=1,s,r){if(Wr(n),null!=s&&"bool"===s)throw new Error(`Unsupported data type ${s}`);const i=new ZI(t,e,s,!1,r),o=dt(n,s);for(let a=0;a<o.values.length;a++)o.values[a]=i.nextValue();return o.toTensor()}}),Nie=k({randomStandardNormal_:function Tie(n,t,e){if(null!=t&&"bool"===t)throw new Error(`Unsupported data type ${t}`);return JI(n,0,1,t,e)}}),au=k({randomUniform_:function kie(n,t=0,e=1,s="float32",r){Wr(n);const i=dt(n,s),o=new wie(t,e,null,r);for(let a=0;a<i.values.length;a++)i.values[a]=o.nextValue();return i.toTensor()}}),Rie=k({randomUniformInt_:function Aie(n,t,e,s){return au(n,t,e,"int32",s)}});function rd(n,t,e=1,s="float32"){if(0===e)throw new Error("Cannot have a step of zero");return M.runKernel(kS,{},{start:n,stop:t,step:e,dtype:s})}const pp=k({real_:function Mie(n){const e={input:I(n,"input","real")};return M.runKernel(AS,e)}}),kL=k({reciprocal_:function Fie(n){const e={x:I(n,"x","reciprocal")};return M.runKernel(Ff,e)}}),xo=k({relu_:function Oie(n){const e={x:I(n,"x","relu")};return M.runKernel(Of,e)}}),eE=k({relu6_:function $ie(n){const e={x:I(n,"x","relu6")};return M.runKernel($f,e)}}),yi=k({reverse_:function Pie(n,t){const s={x:I(n,"x","reverse")};return M.runKernel(ob,s,{dims:t})}}),Vie=k({reverse1d_:function Lie(n){const t=I(n,"x","reverse");return S(1===t.rank,()=>`Error in reverse1D: x must be rank 1 but got rank ${t.rank}.`),yi(t,0)}}),zie=k({reverse2d_:function Bie(n,t){const e=I(n,"x","reverse");return S(2===e.rank,()=>`Error in reverse2D: x must be rank 2 but got rank ${e.rank}.`),yi(e,t)}}),Wie=k({reverse3d_:function Uie(n,t){const e=I(n,"x","reverse");return S(3===e.rank,()=>`Error in reverse3D: x must be rank 3 but got rank ${e.rank}.`),yi(e,t)}}),Hie=k({reverse4d_:function Gie(n,t){const e=I(n,"x","reverse");return S(4===e.rank,()=>`Error in reverse4D: x must be rank 4 but got rank ${e.rank}.`),yi(e,t)}}),tE=k({round_:function jie(n){const e={x:I(n,"x","round")};return M.runKernel(Pf,e)}}),nE=k({rsqrt_:function qie(n){const e={x:I(n,"x","rsqrt","float32")};return M.runKernel(Lf,e)}}),sE=k({selu_:function Kie(n){const e={x:I(n,"x","selu")};return M.runKernel(Vf,e)}}),rE=k({separableConv2d_:function Xie(n,t,e,s,r,i=[1,1],o="NHWC"){const a=I(n,"x","separableConv2d"),l=I(t,"depthwiseFilter","separableConv2d"),u=I(e,"pointwiseFilter","separableConv2d");let c=a,d=!1;if(3===a.rank&&(d=!0,c=O(a,[1,a.shape[0],a.shape[1],a.shape[2]])),"NCHW"===o)throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");S(4===c.rank,()=>`Error in separableConv2d: input must be rank 4, but got rank ${c.rank}.`),S(4===l.rank,()=>`Error in separableConv2d: depthwise filter must be rank 4, but got rank ${l.rank}.`),S(4===u.rank,()=>`Error in separableConv2d: pointwise filter must be rank 4, but got rank ${l.rank}.`),S(1===u.shape[0],()=>`Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got ${u.shape[0]}.`),S(1===u.shape[1],()=>`Error in separableConv2d: the second dimension of pointwise filter must be 1, but got ${u.shape[1]}.`);const h=l.shape[2],f=l.shape[3];S(u.shape[2]===h*f,()=>`Error in separableConv2d: the third dimension of pointwise filter must be ${h*f}, but got ${u.shape[2]}.`);const p=ap(c,l,s,r,o,i),m=Za(p,u,1,"valid",o);return d?O(m,[m.shape[1],m.shape[2],m.shape[3]]):m}});function iE(){return(iE=te(function*(n,t){const e=I(n,"x","setdiff1d"),s=I(t,"y","setdiff1d");S(e.dtype===s.dtype,()=>`x and y should have the same dtype, but got x (${e.dtype}) and y (${s.dtype}).`),S(1===e.rank,()=>`x should be 1D tensor, but got x (${e.shape}).`),S(1===s.rank,()=>`y should be 1D tensor, but got y (${s.shape}).`);const r=yield e.data(),i=yield s.data(),o=new Set(i);let a=0;for(let c=0;c<r.length;c++)o.has(r[c])||a++;const l=new ts([a],e.dtype),u=new ts([a],"int32");for(let c=0,d=0;c<r.length;c++)o.has(r[c])||(l.values[d]=r[c],u.values[d]=c,d++);return[l.toTensor(),u.toTensor()]})).apply(this,arguments)}const Zie=function Yie(n,t){return iE.apply(this,arguments)},AL=k({sign_:function Qie(n){const e={x:I(n,"x","sign")};return M.runKernel(Uf,e)}}),oE=k({sin_:function Jie(n){const e={x:I(n,"x","sin","float32")};return M.runKernel(Bf,e)}}),aE=k({sinh_:function eoe(n){const e={x:I(n,"x","sinh")};return M.runKernel(zf,e)}}),jb=k({slice1d_:function toe(n,t,e){const s=I(n,"x","slice1d");return S(1===s.rank,()=>`slice1d expects a rank-1 tensor, but got a rank-${s.rank} tensor`),Dt(s,[t],[e])}}),lE=k({slice2d_:function noe(n,t,e){const s=I(n,"x","slice2d");return S(2===s.rank,()=>`slice2d expects a rank-2 tensor, but got a rank-${s.rank} tensor`),Dt(s,t,e)}}),qb=k({slice3d_:function soe(n,t,e){const s=I(n,"x","slice3d");return S(3===s.rank,()=>`slice3d expects a rank-3 tensor, but got a rank-${s.rank} tensor`),Dt(s,t,e)}}),mp=k({slice4d_:function roe(n,t,e){const s=I(n,"x","slice4d");return S(4===s.rank,()=>`slice4d expects a rank-4 tensor, but got a rank-${s.rank} tensor`),Dt(s,t,e)}}),Kb=k({softmax_:function ioe(n,t=-1){const e=I(n,"logits","softmax","float32");if(-1===t&&(t=e.rank-1),t!==e.rank-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${e.rank} and dim was ${t}`);return M.runKernel(hb,{logits:e},{dim:t})}}),Xb=k({fft_:function ooe(n){return S("complex64"===n.dtype,()=>`The dtype for tf.spectral.fft() must be complex64 but got ${n.dtype}.`),M.runKernel("FFT",{input:n})}}),gp=k({ifft_:function aoe(n){return S("complex64"===n.dtype,()=>`The dtype for tf.spectral.ifft() must be complex64 but got ${n.dtype}.`),M.runKernel(gS,{input:n})}}),uE=k({irfft_:function loe(n){const t=n.shape[n.shape.length-1],e=n.size/t;let s;if(t<=2){const r=O(n,[e,t]);s=gp(r)}else{const r=[e,2*(t-1)],i=O(pp(n),[e,t]),o=O($b(n),[e,t]),a=yi(Dt(i,[0,1],[e,t-2]),1),l=F(yi(Dt(o,[0,1],[e,t-2]),1),ze(-1)),u=jn([i,a],1),c=jn([o,l],1),d=O(Ga(u,c),[r[0],r[1]]);s=gp(d)}if(s=pp(s),3===n.rank&&0!==n.shape[0]){const r=s,i=n.shape[0];s=O(s,[i,s.shape[0]/i,s.shape[1]]),r.dispose()}return s}}),Tr=k({split_:function uoe(n,t,e=0){const r={x:I(n,"x","split")};return M.runKernel(db,r,{numOrSizeSplits:t,axis:e})}}),Yb=k({rfft_:function coe(n,t){S("float32"===n.dtype,()=>`The dtype for rfft() must be real value but got ${n.dtype}`);let e=n.shape[n.shape.length-1];const s=n.size/e;let r;if(null!=t&&t<e){const p=n.shape.map(m=>0),g=n.shape.map(m=>m);g[n.shape.length-1]=t,r=Dt(n,p,g),e=t}else if(null!=t&&t>e){const p=n.shape.map(g=>g);p[n.shape.length-1]=t-e,r=jn([n,rs(p)],n.shape.length-1),e=t}else r=n;const i=Et(r),o=O(Ga(r,i),[s,e]),a=Xb(o),l=Math.floor(e/2)+1,u=pp(a),c=$b(a),d=Tr(u,[l,e-l],u.shape.length-1),h=Tr(c,[l,e-l],c.shape.length-1),f=r.shape.slice();return f[r.shape.length-1]=l,O(Ga(d[0],h[0]),f)}}),cE=k({squaredDifference_:function doe(n,t){let e=I(n,"a","squaredDifference"),s=I(t,"b","squaredDifference");return[e,s]=Tn(e,s),nt(e.shape,s.shape),M.runKernel(jf,{a:e,b:s},{})}}),lu=k({squeeze_:function hoe(n,t){const e=I(n,"x","squeeze","string_or_numeric");return O(e,Fa(e.shape,t).newShape)}}),Xr=k({stack_:function foe(n,t=0){const e=Sb(n,"tensors","stack","string_or_numeric");return S(e.length>=1,()=>"Pass at least one tensor to tf.stack"),e.length>0&&S(t<=e[0].rank,()=>"Axis must be <= rank of the tensor"),M.runKernel(Jy,e,{axis:t})}}),id=k({step_:function poe(n,t=0){const s={x:I(n,"x","step")};return M.runKernel(Zf,s,{alpha:t})}}),RL=k({stridedSlice_:function moe(n,t,e,s,r=0,i=0,o=0,a=0,l=0){const c={x:I(n,"x","stridedSlice","string_or_numeric")};return M.runKernel(WS,c,{begin:t,end:e,strides:s,beginMask:r,endMask:i,ellipsisMask:o,newAxisMask:a,shrinkAxisMask:l})}}),ML=k({tan_:function goe(n){const e={x:I(n,"x","tan","float32")};return M.runKernel(Kf,e)}});function lr(n,t){$c(n);const e=Wa(n,t);if(1!==e.length)throw new Error("tensor1d() requires values to be a flat/TypedArray");return Ha(n,null,e,t)}function od(n,t,e){if($c(n),null!=t&&2!==t.length)throw new Error("tensor2d() requires shape to have two numbers");const s=Wa(n,e);if(2!==s.length&&1!==s.length)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(1===s.length&&null==t)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return Ha(n,t,s,e)}function yoe(n,t,e){if($c(n),null!=t&&3!==t.length)throw new Error("tensor3d() requires shape to have three numbers");const s=Wa(n,e);if(3!==s.length&&1!==s.length)throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");if(1===s.length&&null==t)throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");return Ha(n,t,s,e)}function boe(n,t,e){if($c(n),null!=t&&4!==t.length)throw new Error("tensor4d() requires shape to have four numbers");const s=Wa(n,e);if(4!==s.length&&1!==s.length)throw new Error("tensor4d() requires values to be number[][][][] or flat/TypedArray");if(1===s.length&&null==t)throw new Error("tensor4d() requires shape to be provided when `values` are a flat array");return Ha(n,t,s,e)}function voe(n,t,e){if($c(n),null!=t&&5!==t.length)throw new Error("tensor5d() requires shape to have five numbers");const s=Wa(n,e);if(5!==s.length&&1!==s.length)throw new Error("tensor5d() requires values to be number[][][][][] or flat/TypedArray");if(1===s.length&&null==t)throw new Error("tensor5d() requires shape to be provided when `values` are a flat array");return Ha(n,t,s,e)}function _oe(n,t,e){if($c(n),null!=t&&6!==t.length)throw new Error("tensor6d() requires shape to have six numbers");const s=Wa(n,e);if(6!==s.length&&1!==s.length)throw new Error("tensor6d() requires values to be number[][][][][][] or flat/TypedArray");if(1===s.length&&null==t)throw new Error("tensor6d() requires shape to be provided when `values` are a flat array");return Ha(n,t=t||s,s,e)}function FL(n,t,e){const s=t.rank>1?t.shape[t.rank-1]:1,r=t.rank>1?t.rank-1:1,i=`Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${e.shape}, indices.shape: ${t.shape}, shape: ${n}, sliceDim: ${s}, and batchDim: ${r}.`;if(e.rank<r)throw new Error(i+` update.rank < ${r}. `);if(n.length<s+(e.rank-r))throw new Error(i+` Output shape length < ${s+(e.rank-r)}`);if(e.rank!==r+n.length-s)throw new Error(i+" update.rank != "+(r+n.length-s));for(let o=0;o<r;++o)if(e.shape[o]!==t.shape[o])throw new Error(i+` updates.shape[${o}] (${e.shape[o]}) != indices.shape[${o}] (${t.shape[o]}).`);for(let o=0;o<e.rank-r;++o)if(e.shape[o+r]!==n[o+s])throw new Error(i+` updates.shape[${o+r}] (${e.shape[o+r]}) != shape[${o+r}] (${n[o+r]})`)}function dE(n,t,e){if(t.rank<1)throw new Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${t.rank}.`);if(n.rank<1)throw new Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${n.rank}.`);if("int32"!==t.dtype)throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${t.dtype}`);if(e.length<1)throw new Error(`Output rank must be greater or equal to 1, but got shape: ${e}`);if(0===e.length){if(0===t.size)throw new Error(`Indices specified for empty output. indices shape: ${t.shape}`);if(0===n.size)throw new Error(`Updates specified for empty output. updates shape: ${n.shape}`)}FL(e,t,n)}function uu(n,t,e){const s=t.shape.length,r=s>1?t.shape[s-1]:1,i=e.length;let o=1;for(let d=r;d<i;++d)o*=e[d];const a=r<1?1:r;return{sliceRank:r,numUpdates:X(t.shape)/a,sliceSize:o,strides:[...Be(e.slice(0,r)),1],outputSize:X(e)}}const xoe=k({tensorScatterUpdate_:function woe(n,t,e){const s=I(n,"tensor","tensorScatterupdate"),r=I(t,"indices","tensorScatterupdate","int32"),i=I(e,"updates","tensorScatterupdate");if(dE(i,r,s.shape),s.dtype!==i.dtype)throw new Error(`tensor and updates must have the same dtype, instead they are ${s.dtype} and ${i.dtype}.`);return M.runKernel(OS,{tensor:s,indices:r,updates:i},{})}}),OL=k({topk_:function Coe(n,t=1,e=!0){const s=I(n,"x","topk");if(0===s.rank)throw new Error("topk() expects the input to be of rank 1 or higher");const r=s.shape[s.shape.length-1];if(t<0)throw new Error(`'k' passed to topk() must be >= 0 but got ${t}`);if(t>r)throw new Error(`'k' passed to topk() must be <= the last dimension (${r}) but got ${t}`);const i={x:s},o={k:t,sorted:e},[a,l]=M.runKernel(qS,i,o);return{values:a,indices:l}}}),hE=k({truncatedNormal_:function Soe(n,t=0,e=1,s,r){if(Wr(n),null!=s&&"bool"===s)throw new Error("Unsupported data type $ { dtype }");const i=new ZI(t,e,s,!0,r),o=dt(n,s);for(let a=0;a<o.values.length;a++)o.values[a]=i.nextValue();return o.toTensor()}}),$L=k({unique_:function Ioe(n,t=0){const e=I(n,"x","unique","string_or_numeric");S(e.rank>0,()=>"The input tensor must be at least 1D");const s={x:e},r={axis:t},[i,o]=M.runKernel(XS,s,r);return{values:i,indices:o}}}),fE=k({unsortedSegmentSum_:function Eoe(n,t,e){const s=I(n,"x","unsortedSegmentSum"),r=I(t,"segmentIds","unsortedSegmentSum","int32");return S(Pc(e),()=>"numSegments must be of dtype int"),M.runKernel(mb,{x:s,segmentIds:r},{numSegments:e})}}),bi=k({unstack_:function Doe(n,t=0){const e=I(n,"x","unstack","string_or_numeric");return S(t>=-e.shape.length&&t<e.shape.length,()=>`Axis = ${t} is not in [-${e.shape.length}, ${e.shape.length})`),M.runKernel(pb,{value:e},{axis:t})}});function Toe(n,t){return XI(n,t,"right")}function PL(n,t=!0,e,s){return M.makeVariable(n,t,e,s)}function pE(n,t){const e=[];for(let i=0;i<t.length;i++)t[i]&&e.push(i);const s=dt(n,"int32"),r=dt([e.length,n.length],"int32");for(let i=0;i<e.length;i++){const o=s.indexToLoc(e[i]);r.values.set(o,i*n.length)}return r.toTensor()}function mE(){return(mE=te(function*(n){const t=I(n,"condition","whereAsync","bool"),e=yield t.data(),s=pE(t.shape,e);return n!==t&&t.dispose(),s})).apply(this,arguments)}const LL=function Noe(n){return mE.apply(this,arguments)};function gE(){return(gE=te(function*(n,t,e){const s=I(n,"tensor","boolMask"),r=I(t,"mask","boolMask","bool"),i=e??0,o=r.rank,a=s.shape;S(o>0,()=>"mask cannot be scalar"),Sr(a.slice(i,i+o),r.shape,"mask's shape must match the first K dimensions of tensor's shape,");let l=1;for(let g=i;g<i+o;g++)l*=a[g];const u=a.slice(0,i).concat([l],a.slice(i+o)),c=O(s,u),d=O(r,[-1]),h=yield LL(d),f=lu(h,[1]),p=hp(c,f,i);return n!==s&&s.dispose(),t!==r&&r.dispose(),f.dispose(),c.dispose(),d.dispose(),h.dispose(),p})).apply(this,arguments)}const Aoe=function koe(n,t,e){return gE.apply(this,arguments)},Tt=k({transpose_:function Roe(n,t,e){const s=I(n,"x","transpose");if(null==t&&(t=s.shape.map((o,a)=>a).reverse()),S(s.rank===t.length,()=>`Error in transpose: rank of input ${s.rank} must match length of perm ${t}.`),t.forEach(o=>{S(o>=0&&o<s.rank,()=>`All entries in 'perm' must be between 0 and ${s.rank-1} but got ${t}`)}),s.rank<=1)return s.clone();const r={x:s},i={perm:t};return"complex64"===s.dtype?z(()=>{let o=pp(s),a=$b(s);return o=M.runKernel(Uc,{x:o},i),a=M.runKernel(Uc,{x:a},i),e&&(a=dn(a)),Ga(o,a)}):M.runKernel(Uc,r,i)}}),Foe=k({movingAverage_:function Moe(n,t,e,s,r=!0){const i=I(n,"v","movingAverage"),o=I(t,"x","movingAverage"),a=I(e,"decay","movingAverage");(function dte(n,t){S(n.dtype===t.dtype,()=>`The dtypes of the first(${n.dtype}) and second(${t.dtype}) input must match`)})(i,o),S(wt(i.shape,o.shape),()=>"Shape mismatch in v and x");const l=ze(1),u=Ne(l,a);let c=F(Ne(o,i),u);if(r){S(null!=s,()=>"When using zeroDebias: true, step is required.");const d=I(s,"step","movingAverage");c=Pe(c,Ne(l,Ka(a,d)))}return le(i,c)}}),$oe=k({scatterND_:function Ooe(n,t,e){Wr(e);const s=I(n,"indices","scatterND","int32"),r=I(t,"updates","scatterND");return dE(r,s,e),M.runKernel(FS,{indices:s,updates:r},{shape:e})}}),Voe=k({sparseToDense_:function Loe(n,t,e,s=0){Wr(e);const r=I(n,"sparseIndices","sparseToDense","int32"),i=I(t,"sparseValues","sparseToDense","string_or_numeric"),o=I(s,"defaultValue","sparseToDense",i.dtype);return function Poe(n,t,e,s){if("int32"!==n.dtype)throw new Error(`tf.sparseToDense() expects the indices to be int32 type, but the dtype was ${n.dtype}.`);if(n.rank>2)throw new Error(`sparseIndices should be a scalar, vector, or matrix, but got shape ${n.shape}.`);const r=n.rank>0?n.shape[0]:1,i=n.rank>1?n.shape[1]:1;if(e.length!==i)throw new Error(`outputShape has incorrect number of elements:, ${e.length}, should be: ${i}.`);if(0!==t.rank&&(1!==t.rank||t.size!==r))throw new Error(`sparseValues has incorrect shape ${t.shape}, should be [] or [${r}]`);if(t.dtype!==s.dtype)throw new Error("sparseValues.dtype must match defaultValues.dtype")}(r,i,e,o),M.runKernel(zS,{sparseIndices:r,sparseValues:i,defaultValue:o},{outputShape:e})}}),zoe=k({gatherND_:function Boe(n,t){const e=I(t,"indices","gatherND","int32"),r={params:I(n,"x","gatherND","string_or_numeric"),indices:e};return M.runKernel(mS,r)}}),VL=k({dropout_:function Woe(n,t,e,s){const r=I(n,"x","dropout");if(S("float32"===r.dtype,()=>`x has to be a floating point tensor since it's going to be scaled, but got a ${r.dtype} tensor instead.`),S(t>=0&&t<1,()=>`rate must be a float in the range [0, 1), but got ${t}.`),0===t)return n instanceof pn?r.clone():r;const i=function Uoe(n,t){if(null==t)return n.shape.slice();if(wt(n.shape,t))return t;if(n.shape.length===t.length){const e=[];for(let s=0;s<n.shape.length;s++)e.push(null==t[s]&&null!=n.shape[s]?n.shape[s]:t[s]);return e}return t}(r,e),o=1-t,a=Pe(dp(le(au(i,0,1,"float32",s),o)),o);return F(r,a)}});function BL(n){return Math.floor(Math.pow(2,Math.ceil(Math.log(n)/Math.log(2))))}function yE(n,t,e){const s=1-n%2,r=new Float32Array(n);for(let i=0;i<n;++i){const o=2*Math.PI*i/(n+s-1);r[i]=t-e*Math.cos(o)}return lr(r,"float32")}function bE(){return(bE=te(function*(n,t,e=1){const s=I(n,"predictions","inTopK"),r=I(t,"targets","inTopK");S(s.rank>1,()=>`inTopK() expects the predictions to be of rank 2 or higher, but got ${s.rank}`),S(s.rank-1===r.rank,()=>`predictions rank should be 1 larger than targets rank, but got predictions rank ${s.rank} and targets rank ${r.rank}`),Sr(s.shape.slice(0,s.shape.length-1),r.shape,"predictions's shape should be align with the targets' shape, except the last dimension.");const i=s.shape[s.shape.length-1];S(e>0&&e<=i,()=>`'k' passed to inTopK() must be > 0 && <= the predictions last dimension (${i}), but got ${e}`);const o=yield s.data(),a=yield r.data(),[l,u]=[o.length/i,i],c=Ds("bool",l);for(let d=0;d<l;d++){const h=d*u,f=o.subarray(h,h+u),p=[];for(let g=0;g<f.length;g++)p.push({value:f[g],index:g});p.sort((g,m)=>m.value-g.value),c[d]=0;for(let g=0;g<e;g++)if(p[g].index===a[d]){c[d]=1;break}}return n!==s&&s.dispose(),t!==r&&r.dispose(),Ui(c,r.shape,"bool")})).apply(this,arguments)}const Hoe=function Goe(n,t){return bE.apply(this,arguments)},vE=k({conv2DBackpropFilter_:function joe(n,t,e,s,r,i="NHWC",o){let a=n;3===n.rank&&(a=O(n,[1,n.shape[0],n.shape[1],n.shape[2]]));let l=t;3===l.rank&&(l=O(t,[1,t.shape[0],t.shape[1],t.shape[2]])),S(4===a.rank,()=>`Error in conv2dDerFilter: input must be rank 4, but got shape ${a.shape}.`),S(4===l.rank,()=>`Error in conv2dDerFilter: dy must be rank 4, but got shape ${l.shape}.`),S(4===e.length,()=>`Error in conv2dDerFilter: filterShape must be length 4, but got ${e}.`);const u="NHWC"===i?a.shape[3]:a.shape[1],c="NHWC"===i?l.shape[3]:l.shape[1];return S(u===e[2],()=>`Error in conv2dDerFilter: depth of input ${u}) must match input depth in filter (${e[2]}.`),S(c===e[3],()=>`Error in conv2dDerFilter: depth of dy (${c}) must match output depth for filter (${e[3]}).`),Xs("conv2dDerFilter",r,o),M.runKernel(QC,{x:a,dy:l},{strides:s,pad:r,dataFormat:i,dimRoundingMode:o,filterShape:e})}});function Zb(n,t,e){if(null==e||"linear"===e)return n;if("relu"===e)return F(n,id(t));throw new Error(`Cannot compute gradient for fused activation ${e}.`)}function Qb(n,t){let e=t;const s=ss(n.shape,t.shape);return s.length>0&&(e=Re(e,s)),O(e,n.shape)}function Jb(n,t,e,s){if("linear"===t)return n;if("relu"===t)return xo(n);if("elu"===t)return lp(n);if("relu6"===t)return eE(n);if("prelu"===t)return Gb(n,e);if("leakyrelu"===t)return Pb(n,s);if("sigmoid"===t)return _o(n);throw new Error(`Unknown fused activation ${t}.`)}const ev=(n,t)=>!(n>0)||"linear"===t,zL=k({fusedConv2d_:function qoe({x:n,filter:t,strides:e,pad:s,dataFormat:r="NHWC",dilations:i=[1,1],dimRoundingMode:o,bias:a,activation:l="linear",preluActivationWeights:u,leakyreluAlpha:c}){if(!1===ev(M.state.gradientDepth,l=l||"linear")){S("NHWC"===r,()=>`Error in fused conv2d: got dataFormat of ${r} but only NHWC is currently supported for the case of gradient depth is 0 and the activation is not linear.`);let C=Za(n,t,e,s,r,i,o);return null!=a&&(C=le(C,a)),Jb(C,l,u,c)}const d=I(n,"x","conv2d","float32"),h=I(t,"filter","conv2d","float32");let f=d,p=!1;3===d.rank&&(p=!0,f=O(d,[1,d.shape[0],d.shape[1],d.shape[2]])),S(4===f.rank,()=>`Error in fused conv2d: input must be rank 4, but got rank ${f.rank}.`),S(4===h.rank,()=>`Error in fused conv2d: filter must be rank 4, but got rank ${h.rank}.`),Xs("fused conv2d",s,o);const g="NHWC"===r?f.shape[3]:f.shape[1];S(h.shape[2]===g,()=>`Error in conv2d: depth of input (${g}) must match input depth for filter ${h.shape[2]}.`),S(Ts(e,i),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${e} and dilations '${i}'`);const m=_s(f.shape,h.shape,e,i,s,o);let y,b;if(null!=a&&(y=I(a,"bias","fused conv2d"),[y]=Tn(y,d),"NHWC"===r?nt(m.outShape,y.shape):(S(y.shape.length<=1,()=>`Error in fused conv2d: only supports scalar or 1-D Tensor bias for NCHW format but got the bias of rank-${y.shape.length}.`),S(0===y.shape.length||y.shape[0]===m.outChannels||1===y.shape[0],()=>`Error in fused conv2d: bias shape (${y.shape}) is not compatible with the number of output channels (${m.outChannels})`))),null!=u){const C=u.shape;if(S(C.length<=1||3===C.length,()=>`Error in fused conv2d: only supports scalar, 1-D Tensor or 3-D Tensor PReLU activation weights but got a tensor of rank-${C.length}.`),1===C.length)S(1===C[0]||C[0]===m.outChannels,()=>`Error in fused conv2d: PReLU activation weights (${C}) is not compatible with the number of output channels (${m.outChannels}).`);else if(3===C.length)try{nt(C,m.outShape)}catch{throw Error(`Error in fused conv2d: PReLU activation weights (${C}) is not compatible with the output shape of the conv2d (${m.outShape}).`)}b=I(u,"prelu weights","fused conv2d")}const v=(C,E)=>{S("NHWC"===r,()=>`Error in gradient of fused conv2D: got dataFormat of ${r} but only NHWC is currently supported.`);const[D,N,R,V]=E,G=Zb(C,R,l);S(Ya(i),()=>`Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${i}'`);const K=[VI(N.shape,G,D,e,s),vE(N,G,D.shape,e,s)];if(null!=V){const P=Qb(V,G);K.push(P)}return K},_={x:f,filter:h,bias:y,preluActivationWeights:b},x={strides:e,pad:s,dataFormat:r,dilations:i,dimRoundingMode:o,activation:l,leakyreluAlpha:c};return null==a?ia((E,D,N)=>{let R=M.runKernel(bb,_,x);return N([D,E,R]),p&&(R=O(R,[R.shape[1],R.shape[2],R.shape[3]])),{value:R,gradFunc:v}})(f,h):ia((E,D,N,R)=>{let V=M.runKernel(bb,_,x);return R([D,E,V,N]),p&&(V=O(V,[V.shape[1],V.shape[2],V.shape[3]])),{value:V,gradFunc:v}})(f,h,y)}}),UL=k({depthwiseConv2dNativeBackpropFilter_:function Koe(n,t,e,s,r,i=[1,1],o){let a=n;3===n.rank&&(a=O(n,[1,n.shape[0],n.shape[1],n.shape[2]]));let l=t;return 3===l.rank&&(l=O(t,[1,t.shape[0],t.shape[1],t.shape[2]])),M.runKernel(iS,{x:a,dy:l},{strides:s,pad:r,dimRoundingMode:o,dilations:i,filterShape:e})}}),WL=k({depthwiseConv2dNativeBackpropInput_:function Xoe(n,t,e,s,r,i=[1,1],o){let a=t,l=!1;3===t.rank&&(l=!0,a=O(t,[1,t.shape[0],t.shape[1],t.shape[2]]));const d=M.runKernel(oS,{dy:a,filter:e},{strides:s,pad:r,dimRoundingMode:o,dilations:i,inputShape:n});return l?O(d,[d.shape[1],d.shape[2],d.shape[3]]):d}}),Zoe=k({fusedDepthwiseConv2d_:function Yoe({x:n,filter:t,strides:e,pad:s,dataFormat:r="NHWC",dilations:i=[1,1],dimRoundingMode:o,bias:a,activation:l="linear",preluActivationWeights:u,leakyreluAlpha:c}){if(!1===ev(M.state.gradientDepth,l)){let x=ap(n,t,e,s,r,i,o);return null!=a&&(x=le(x,a)),Jb(x,l,u,c)}const d=I(n,"x","depthwiseConv2d","float32"),h=I(t,"filter","depthwiseConv2d","float32");let f=d,p=!1;3===d.rank&&(p=!0,f=O(d,[1,d.shape[0],d.shape[1],d.shape[2]])),S(4===f.rank,()=>`Error in fused depthwiseConv2d: input must be rank 4, but got rank ${f.rank}.`),S(4===h.rank,()=>`Error in fused depthwiseConv2d: filter must be rank 4, but got rank ${h.rank}.`),S(f.shape[3]===h.shape[2],()=>`Error in fused depthwiseConv2d: number of input channels (${f.shape[3]}) must match the inChannels dimension in filter ${h.shape[2]}.`),null==i&&(i=[1,1]),S(Ts(e,i),()=>`Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides ${e} and dilations '${i}'`),Xs("fused depthwiseConv2d",s,o);const g=_s(f.shape,h.shape,e,i,s,o,!0);let m,y;null!=a&&(m=I(a,"bias","fused conv2d"),[m]=Tn(m,d),nt(g.outShape,m.shape)),null!=u&&(y=I(u,"prelu weights","fused depthwiseConv2d"));const b=(x,C)=>{S(Ya(i),()=>`Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '${i}'`);const[E,D,N,R]=C,V=Zb(x,N,l),G=WL(D.shape,V,E,e,s,i,o),j=UL(D,V,E.shape,e,s,i,o);return null!=R?[G,j,Qb(m,V)]:[G,j]},v={x:f,filter:h,bias:m,preluActivationWeights:y},_={strides:e,pad:s,dataFormat:r,dilations:i,dimRoundingMode:o,activation:l,leakyreluAlpha:c};return null==a?ia((C,E,D)=>{let N=M.runKernel(vb,v,_);return D([E,C,N]),p&&(N=O(N,[N.shape[1],N.shape[2],N.shape[3]])),{value:N,gradFunc:b}})(f,h):ia((C,E,D,N)=>{let R=M.runKernel(vb,v,_);return N([E,C,R,D]),p&&(R=O(R,[R.shape[1],R.shape[2],R.shape[3]])),{value:R,gradFunc:b}})(f,h,m)}}),_E=k({fusedMatMul_:function Qoe({a:n,b:t,transposeA:e=!1,transposeB:s=!1,bias:r,activation:i="linear",preluActivationWeights:o,leakyreluAlpha:a=.2}){if(!1===ev(M.state.gradientDepth,i)){let V=bt(n,t,e,s);return null!=r&&(V=le(V,r)),Jb(V,i,o,a)}let l=I(n,"a","fused matMul"),u=I(t,"b","fused matMul");[l,u]=Tn(l,u);const c=e?l.shape[l.rank-2]:l.shape[l.rank-1],d=s?u.shape[u.rank-1]:u.shape[u.rank-2],h=e?l.shape[l.rank-1]:l.shape[l.rank-2],f=s?u.shape[u.rank-2]:u.shape[u.rank-1],p=l.shape.slice(0,-2),g=u.shape.slice(0,-2),m=X(p),y=X(g);S(c===d,()=>`Error in fused matMul: inner shapes (${c}) and (${d}) of Tensors with shapes ${l.shape} and ${u.shape} and transposeA=${e} and transposeB=${s} must match.`);const v=nt(l.shape.slice(0,-2),u.shape.slice(0,-2)).concat([h,f]),_=O(l,e?[m,c,h]:[m,h,c]),x=O(u,s?[y,f,d]:[y,d,f]);let C,E;null!=r&&(C=I(r,"bias","fused matMul"),[C]=Tn(C,l),nt(v,C.shape)),null!=o&&(E=I(o,"prelu weights","fused matMul"));const D=(V,G)=>{const[j,q,K,P]=G,B=Zb(O(V,K.shape),K,i);let L,H;return e||s?!e&&s?(L=bt(B,q,!1,!1),H=bt(B,j,!0,!1)):e&&!s?(L=bt(q,B,!1,!0),H=bt(j,B,!1,!1)):(L=bt(q,B,!0,!0),H=bt(B,j,!0,!0)):(L=bt(B,q,!1,!0),H=bt(j,B,!0,!1)),null!=r?[L,H,Qb(P,B)]:[L,H]},N={a:_,b:x,bias:C,preluActivationWeights:E},R={transposeA:e,transposeB:s,activation:i,leakyreluAlpha:a};return null==r?ia((G,j,q)=>{const K=M.runKernel(yb,N,R);return q([G,j,K]),{value:O(K,v),gradFunc:D}})(_,x):ia((G,j,q,K)=>{const P=M.runKernel(yb,N,R);return K([G,j,P,q]),{value:O(P,v),gradFunc:D}})(_,x,C)}}),eae=k({hammingWindow_:function Joe(n){return yE(n,.54,.46)}}),GL=k({hannWindow_:function tae(n){return yE(n,.5,.5)}}),HL=k({frame_:function nae(n,t,e,s=!1,r=0){let i=0;const o=[];for(;i+t<=n.size;)o.push(Dt(n,i,t)),i+=e;if(s)for(;i<n.size;){const a=i+t-n.size,l=jn([Dt(n,i,t-a),Yc([a],r)]);o.push(l),i+=e}return 0===o.length?od([],[0,t]):O(jn(o),[o.length,t])}}),rae=k({stft_:function sae(n,t,e,s,r=GL){null==s&&(s=BL(t));const i=HL(n,t,e),o=F(i,r(t));return Yb(o,s)}}),oae=k({cropAndResize_:function iae(n,t,e,s,r="bilinear",i=0){const o=I(n,"image","cropAndResize"),a=I(t,"boxes","cropAndResize","float32"),l=I(e,"boxInd","cropAndResize","int32"),u=a.shape[0];return S(4===o.rank,()=>`Error in cropAndResize: image must be rank 4,but got rank ${o.rank}.`),S(2===a.rank&&4===a.shape[1],()=>`Error in cropAndResize: boxes must be have size [${u},4] but had shape ${a.shape}.`),S(1===l.rank&&l.shape[0]===u,()=>`Error in cropAndResize: boxInd must be have size [${u}] but had shape ${a.shape}.`),S(2===s.length,()=>`Error in cropAndResize: cropSize must be of length 2, but got length ${s.length}.`),S(s[0]>=1&&s[1]>=1,()=>`cropSize must be atleast [1,1], but was ${s}`),S("bilinear"===r||"nearest"===r,()=>`method must be bilinear or nearest, but was ${r}`),M.runKernel(nS,{image:o,boxes:a,boxInd:l},{method:r,extrapolationValue:i,cropSize:s})}}),lae=k({flipLeftRight_:function aae(n){const t=I(n,"image","flipLeftRight","float32");return S(4===t.rank,()=>`Error in flipLeftRight: image must be rank 4,but got rank ${t.rank}.`),M.runKernel(pS,{image:t},{})}}),cae=k({grayscaleToRGB_:function uae(n){const t=I(n,"image","grayscaleToRGB"),e=t.rank-1,s=t.shape[e];S(t.rank>=2,()=>`Error in grayscaleToRGB: images must be at least rank 2, but got rank ${t.rank}.`),S(1===s,()=>`Error in grayscaleToRGB: last dimension of a grayscale image should be size 1, but got size ${s}.`);const r=new Array(t.rank);return r.fill(1,0,e),r[e]=3,gi(t,r)}}),hae=k({rotateWithOffset_:function dae(n,t,e=0,s=.5){const r=I(n,"image","rotateWithOffset","float32");return S(4===r.rank,()=>`Error in rotateWithOffset: image must be rank 4,but got rank ${r.rank}.`),M.runKernel(YS,{image:r},{radians:t,fillValue:e,center:s})}});function ad(n,t,e,s,r,i){null==s&&(s=.5),null==r&&(r=Number.NEGATIVE_INFINITY),null==i&&(i=0);const o=n.shape[0];return e=Math.min(e,o),S(0<=s&&s<=1,()=>`iouThreshold must be in [0, 1], but was '${s}'`),S(2===n.rank,()=>`boxes must be a 2D tensor, but was of rank '${n.rank}'`),S(4===n.shape[1],()=>`boxes must have 4 columns, but 2nd dimension was ${n.shape[1]}`),S(1===t.rank,()=>"scores must be a 1D tensor"),S(t.shape[0]===o,()=>`scores has incompatible shape with boxes. Expected ${o}, but was ${t.shape[0]}`),S(0<=i&&i<=1,()=>`softNmsSigma must be in [0, 1], but was '${i}'`),{maxOutputSize:e,iouThreshold:s,scoreThreshold:r,softNmsSigma:i}}const pae=k({nonMaxSuppression_:function fae(n,t,e,s=.5,r=Number.NEGATIVE_INFINITY){const i=I(n,"boxes","nonMaxSuppression","float32"),o=I(t,"scores","nonMaxSuppression","float32"),a=ad(i,o,e,s,r);return M.runKernel(SS,{boxes:i,scores:o},{maxOutputSize:e=a.maxOutputSize,iouThreshold:s=a.iouThreshold,scoreThreshold:r=a.scoreThreshold})}});function mae(n,t,e){const s=function gae(n,t,e){return function bae(n,t,e){let s=0,r=n.length,i=0,o=!1;for(;s<r;){i=s+(r-s>>>1);const a=e(t,n[i]);a>0?s=i+1:(r=i,o=!a)}return o?s:-s-1}(n,t,e||yae)}(n,t,e);n.splice(s<0?-(s+1):s,0,t)}function yae(n,t){return n>t?1:n<t?-1:0}function wE(n,t,e,s,r){return SE(n,t,e,s,r,0)}function xE(n,t,e,s,r,i){return SE(n,t,e,s,r,0,!1,i,!0)}function CE(n,t,e,s,r,i){return SE(n,t,e,s,r,i,!0)}function SE(n,t,e,s,r,i,o=!1,a=!1,l=!1){const u=[];for(let m=0;m<t.length;m++)t[m]>r&&u.push({score:t[m],boxIndex:m,suppressBeginIndex:0});u.sort(jL);const c=i>0?-.5/i:0,d=[],h=[];for(;d.length<e&&u.length>0;){const m=u.pop(),{score:y,boxIndex:b,suppressBeginIndex:v}=m;if(y<r)break;let _=!1;for(let x=d.length-1;x>=v;--x){const C=vae(n,b,d[x]);if(C>=s){_=!0;break}if(m.score=m.score*_ae(s,c,C),m.score<=r)break}m.suppressBeginIndex=d.length,_||(m.score===y?(d.push(b),h.push(m.score)):m.score>r&&mae(u,m,jL))}const f=d.length,p=e-f;a&&p>0&&(d.push(...new Array(p).fill(0)),h.push(...new Array(p).fill(0)));const g={selectedIndices:d};return o&&(g.selectedScores=h),l&&(g.validOutputs=f),g}function vae(n,t,e){const s=n.subarray(4*t,4*t+4),r=n.subarray(4*e,4*e+4),i=Math.min(s[0],s[2]),o=Math.min(s[1],s[3]),a=Math.max(s[0],s[2]),l=Math.max(s[1],s[3]),u=Math.min(r[0],r[2]),c=Math.min(r[1],r[3]),d=Math.max(r[0],r[2]),h=Math.max(r[1],r[3]),f=(a-i)*(l-o),p=(d-u)*(h-c);if(f<=0||p<=0)return 0;const g=Math.max(i,u),m=Math.max(o,c),y=Math.min(a,d),b=Math.min(l,h),v=Math.max(y-g,0)*Math.max(b-m,0);return v/(f+p-v)}function _ae(n,t,e){const s=Math.exp(t*e*e);return e<=n?s:0}function jL(n,t){return n.score-t.score||n.score===t.score&&t.boxIndex-n.boxIndex}function IE(){return(IE=te(function*(n,t,e,s=.5,r=Number.NEGATIVE_INFINITY){const i=I(n,"boxes","nonMaxSuppressionAsync"),o=I(t,"scores","nonMaxSuppressionAsync"),a=ad(i,o,e,s,r);e=a.maxOutputSize,s=a.iouThreshold,r=a.scoreThreshold;const l=yield Promise.all([i.data(),o.data()]),u=l[0],c=l[1],{selectedIndices:d}=wE(u,c,e,s,r);return i!==n&&i.dispose(),o!==t&&o.dispose(),lr(d,"int32")})).apply(this,arguments)}const Sae=k({nonMaxSuppressionWithScore_:function Cae(n,t,e,s=.5,r=Number.NEGATIVE_INFINITY,i=0){const o=I(n,"boxes","nonMaxSuppression"),a=I(t,"scores","nonMaxSuppression"),l=ad(o,a,e,s,r,i),d=M.runKernel(ES,{boxes:o,scores:a},{maxOutputSize:e=l.maxOutputSize,iouThreshold:s=l.iouThreshold,scoreThreshold:r=l.scoreThreshold,softNmsSigma:i=l.softNmsSigma});return{selectedIndices:d[0],selectedScores:d[1]}}});function EE(){return(EE=te(function*(n,t,e,s=.5,r=Number.NEGATIVE_INFINITY,i=0){const o=I(n,"boxes","nonMaxSuppressionAsync"),a=I(t,"scores","nonMaxSuppressionAsync"),l=ad(o,a,e,s,r,i);e=l.maxOutputSize,s=l.iouThreshold,r=l.scoreThreshold,i=l.softNmsSigma;const u=yield Promise.all([o.data(),a.data()]),c=u[0],d=u[1],{selectedIndices:h,selectedScores:f}=CE(c,d,e,s,r,i);return o!==n&&o.dispose(),a!==t&&a.dispose(),{selectedIndices:lr(h,"int32"),selectedScores:lr(f)}})).apply(this,arguments)}const Tae=k({nonMaxSuppressionPadded_:function Dae(n,t,e,s=.5,r=Number.NEGATIVE_INFINITY,i=!1){const o=I(n,"boxes","nonMaxSuppression"),a=I(t,"scores","nonMaxSuppression"),l=ad(o,a,e,s,r,null),p=M.runKernel(IS,{boxes:o,scores:a},{maxOutputSize:l.maxOutputSize,iouThreshold:l.iouThreshold,scoreThreshold:l.scoreThreshold,padToMaxOutputSize:i});return{selectedIndices:p[0],validOutputs:p[1]}}});function DE(){return(DE=te(function*(n,t,e,s=.5,r=Number.NEGATIVE_INFINITY,i=!1){const o=I(n,"boxes","nonMaxSuppressionAsync"),a=I(t,"scores","nonMaxSuppressionAsync"),l=ad(o,a,e,s,r,null),u=l.maxOutputSize,c=l.iouThreshold,d=l.scoreThreshold,[h,f]=yield Promise.all([o.data(),a.data()]),{selectedIndices:p,validOutputs:g}=xE(h,f,u,c,d,i);return o!==n&&o.dispose(),a!==t&&a.dispose(),{selectedIndices:lr(p,"int32"),validOutputs:ze(g,"int32")}})).apply(this,arguments)}const qL=k({resizeBilinear_:function Aae(n,t,e=!1,s=!1){const r=I(n,"images","resizeBilinear");S(3===r.rank||4===r.rank,()=>`Error in resizeBilinear: x must be rank 3 or 4, but got rank ${r.rank}.`),S(2===t.length,()=>`Error in resizeBilinear: new shape must 2D, but got shape ${t}.`),S(!1===s||!1===e,()=>"Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false.");let i=r,o=!1;3===r.rank&&(o=!0,i=O(r,[1,r.shape[0],r.shape[1],r.shape[2]]));const[]=t,u=M.runKernel(ib,{images:i},{alignCorners:e,halfPixelCenters:s,size:t});return o?O(u,[u.shape[1],u.shape[2],u.shape[3]]):u}}),KL=k({resizeNearestNeighbor_:function Rae(n,t,e=!1,s=!1){const r=I(n,"images","resizeNearestNeighbor");S(3===r.rank||4===r.rank,()=>`Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ${r.rank}.`),S(2===t.length,()=>`Error in resizeNearestNeighbor: new shape must 2D, but got shape ${t}.`),S("float32"===r.dtype||"int32"===r.dtype,()=>"`images` must have `int32` or `float32` as dtype"),S(!1===s||!1===e,()=>"Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false.");let i=r,o=!1;3===r.rank&&(o=!0,i=O(r,[1,r.shape[0],r.shape[1],r.shape[2]]));const[]=t,u=M.runKernel(rb,{images:i},{alignCorners:e,halfPixelCenters:s,size:t});return o?O(u,[u.shape[1],u.shape[2],u.shape[3]]):u}}),Oae=k({threshold_:function Mae(n,t="binary",e=!1,s=.5){const r=I(n,"image","threshold"),l=r.shape[0]*r.shape[1];let c,d,h,f,u=F(lr([s]),255);if(S(3===r.rank,()=>`Error in threshold: image must be rank 3,but got rank ${r.rank}.`),S(3===r.shape[2]||1===r.shape[2],()=>`Error in threshold: image color channel must be equal to 3 or 1but got ${r.shape[2]}.`),S("int32"===r.dtype||"float32"===r.dtype,()=>`Error in dtype: image dtype must be int32 or float32,but got dtype ${r.dtype}.`),S("otsu"===t||"binary"===t,()=>`Method must be binary or otsu, but was ${t}`),3===r.shape[2]){[c,d,h]=Tr(r,[1,1,1],-1);const m=F(c,.2989),y=F(d,.587),b=F(h,.114);f=le(le(m,y),b)}else f=n;"otsu"===t&&(u=function Fae(n,t){let i,o,a,l,u,c,e=lr([-1]),s=lr([0]),r=lr([0]);for(let d=0;d<n.size-1;d++){i=Dt(n,0,d+1),o=Dt(n,d+1),u=Pe(Re(i),t),c=Pe(Re(o),t);const h=Re(F(i,rd(0,i.size)));a=Pe(h,Re(i));const f=Yc(o.shape,i.size),p=le(rd(0,o.size),f),g=F(o,p);l=Pe(Re(g),Re(o));const m=Ne(a,l),y=Ne(a,l),b=F(u,c);r=F(F(b,m),y);const v=Dr(r,s);s=zs(v,r,s),e=zs(v,lr([d]),e)}return e}(tL(xe(tE(f),"int32"),Ui([]),256),l));const p=e?iu(f,u):Dr(f,u);return xe(F(p,255),"int32")}}),Pae=k({transform_:function $ae(n,t,e="nearest",s="constant",r=0,i){const o=I(n,"image","transform","float32"),a=I(t,"transforms","transform","float32");return S(4===o.rank,()=>`Error in transform: image must be rank 4,but got rank ${o.rank}.`),S(2===a.rank&&(a.shape[0]===o.shape[0]||1===a.shape[0])&&8===a.shape[1],()=>"Error in transform: Input transform should be batch x 8 or 1 x 8"),S(null==i||2===i.length,()=>`Error in transform: outputShape must be [height, width] or null, but got ${i}.`),M.runKernel(KS,{image:o,transforms:a},{interpolation:e,fillMode:s,fillValue:r,outputShape:i})}}),Vae=k({bandPart_:function Lae(n,t,e){const s=I(n,"a","bandPart");S(s.rank>=2,()=>`bandPart(): Rank must be at least 2, got ${s.rank}.`);const r=s.shape,[i,o]=s.shape.slice(-2);let a,l;"number"==typeof t?(S(t%1==0,()=>`bandPart(): numLower must be an integer, got ${t}.`),S(t<=i,()=>`bandPart(): numLower (${t}) must not be greater than the number of rows (${i}).`),a=I(t<0?i:t,"numLower","bandPart")):(S("int32"===t.dtype,()=>"bandPart(): numLower's dtype must be an int32."),a=zs(fp(t,0),i,ou(t,i))),"number"==typeof e?(S(e%1==0,()=>`bandPart(): numUpper must be an integer, got ${e}.`),S(e<=o,()=>`bandPart(): numUpper (${e}) must not be greater than the number of columns (${o}).`),l=I(e<0?o:e,"numUpper","bandPart")):(S("int32"===e.dtype,()=>"bandPart(): numUpper's dtype must be an int32."),l=zs(fp(e,0),o,ou(e,o)));const u=O(rd(0,i,1,"int32"),[-1,1]),c=rd(0,o,1,"int32"),d=Ne(u,c),h=wo(iu(d,a),Ja(d,dn(l))),f=rs([i,o],s.dtype);return O(Xr(bi(O(s,[-1,i,o])).map(p=>zs(h,p,f))),r)}}),zae=k({gramSchmidt_:function Bae(n){let t;if(Array.isArray(n)){t=!1,S(null!=n&&n.length>0,()=>"Gram-Schmidt process: input must not be null, undefined, or empty");const r=n[0].shape[0];for(let i=1;i<n.length;++i)S(n[i].shape[0]===r,()=>`Gram-Schmidt: Non-unique lengths found in the input vectors: (${n[i].shape[0]} vs. ${r})`)}else t=!0,n=Tr(n,n.shape[0],0).map(r=>lu(r,[0]));S(n.length<=n[0].shape[0],()=>`Gram-Schmidt: Number of vectors (${n.length}) exceeds number of dimensions (${n[0].shape[0]}).`);const e=[],s=n;for(let r=0;r<n.length;++r)e.push(M.tidy(()=>{let i=s[r];if(r>0)for(let o=0;o<r;++o){const a=F(Re(F(e[o],i)),e[o]);i=Ne(i,a)}return Pe(i,cp(i,"euclidean"))}));return t?Xr(e,0):e}});function XL(n,t=!1){return M.tidy(()=>{S(2===n.shape.length,()=>`qr2d() requires a 2D Tensor, but got a ${n.shape.length}D Tensor.`);const e=n.shape[0],s=n.shape[1];let r=HI(e),i=ra(n);const o=od([[1]],[1,1]);let a=ra(o);const l=e>=s?s:e;for(let u=0;u<l;++u){const c=i,d=a,h=r;[a,i,r]=M.tidy(()=>{const f=Dt(i,[u,u],[e-u,1]),p=cp(f),g=Dt(i,[u,u],[1,1]),m=zs(Dr(g,0),od([[-1]]),od([[1]])),y=Ne(g,F(m,p)),b=Pe(f,y);a=1===b.shape[0]?ra(o):jn([o,Dt(b,[1,0],[b.shape[0]-1,b.shape[1]])],0);const v=dn(Pe(bt(m,y),p)),_=Dt(i,[u,0],[e-u,s]),x=F(v,a),C=Tt(a);if(0===u)i=Ne(_,bt(x,bt(C,_)));else{const N=Ne(_,bt(x,bt(C,_)));i=jn([Dt(i,[0,0],[u,s]),N],0)}const E=Tt(x),D=Dt(r,[0,u],[e,r.shape[1]-u]);if(0===u)r=Ne(D,bt(bt(D,a),E));else{const N=Ne(D,bt(bt(D,a),E));r=jn([Dt(r,[0,0],[e,u]),N],1)}return[a,i,r]}),gt([c,d,h])}return!t&&e>s&&(r=Dt(r,[0,0],[e,s]),i=Dt(i,[0,0],[s,s])),[r,i]})}const Wae=k({qr_:function Uae(n,t=!1){if(S(n.rank>=2,()=>`qr() requires input tensor to have a rank >= 2, but got rank ${n.rank}`),2===n.rank)return XL(n,t);{const e=n.shape.slice(0,n.shape.length-2).reduce((l,u)=>l*u),s=bi(O(n,[e,n.shape[n.shape.length-2],n.shape[n.shape.length-1]]),0),r=[],i=[];return s.forEach(l=>{const[u,c]=XL(l,t);r.push(u),i.push(c)}),[O(Xr(r,0),n.shape),O(Xr(i,0),n.shape)]}}});var _n=(()=>((_n=_n||{})[_n.NONE=0]="NONE",_n[_n.MEAN=1]="MEAN",_n[_n.SUM=2]="SUM",_n[_n.SUM_BY_NONZERO_WEIGHTS=3]="SUM_BY_NONZERO_WEIGHTS",_n))();const ua=k({computeWeightedLoss_:function Gae(n,t,e=_n.SUM_BY_NONZERO_WEIGHTS){const s=I(n,"losses","computeWeightedLoss");let r=null;null!=t&&(r=I(t,"weights","computeWeightedLoss"));const i=null==r?s:F(s,r);if(e===_n.NONE)return i;if(e===_n.SUM)return Re(i);if(e===_n.MEAN){if(null==r)return Nn(i);{const o=s.size/r.size,a=Pe(Re(i),Re(r));return o>1?Pe(a,ze(o)):a}}if(e===_n.SUM_BY_NONZERO_WEIGHTS){if(null==r)return Pe(Re(i),ze(s.size));{const o=F(r,qr(s.shape)),a=xe(Re(sd(o,ze(0))),"float32");return Pe(Re(i),a)}}throw Error(`Unknown reduction: ${e}`)}}),jae=k({absoluteDifference_:function Hae(n,t,e,s=_n.SUM_BY_NONZERO_WEIGHTS){const r=I(n,"labels","absoluteDifference"),i=I(t,"predictions","absoluteDifference");let o=null;null!=e&&(o=I(e,"weights","absoluteDifference")),Sr(r.shape,i.shape,"Error in absoluteDifference: ");const a=ns(Ne(r,i));return ua(a,o,s)}}),Kae=k({cosineDistance_:function qae(n,t,e,s,r=_n.SUM_BY_NONZERO_WEIGHTS){const i=I(n,"labels","cosineDistance"),o=I(t,"predictions","cosineDistance");let a=null;null!=s&&(a=I(s,"weights","cosineDistance")),Sr(i.shape,o.shape,"Error in cosineDistance: ");const l=ze(1),u=Ne(l,Re(F(i,o),e,!0));return ua(u,a,r)}}),Yae=k({hingeLoss_:function Xae(n,t,e,s=_n.SUM_BY_NONZERO_WEIGHTS){let r=I(n,"labels","hingeLoss");const i=I(t,"predictions","hingeLoss");let o=null;null!=e&&(o=I(e,"weights","hingeLoss")),Sr(r.shape,i.shape,"Error in hingeLoss: ");const a=ze(1);r=Ne(F(ze(2),r),a);const l=xo(Ne(a,F(r,i)));return ua(l,o,s)}}),Qae=k({huberLoss_:function Zae(n,t,e,s=1,r=_n.SUM_BY_NONZERO_WEIGHTS){const i=I(n,"labels","huberLoss"),o=I(t,"predictions","huberLoss");let a=null;null!=e&&(a=I(e,"weights","huberLoss")),Sr(i.shape,o.shape,"Error in huberLoss: ");const l=ze(s),u=ns(Ne(o,i)),c=ou(u,l),d=Ne(u,c),h=le(F(ze(.5),en(c)),F(l,d));return ua(h,a,r)}}),ele=k({logLoss_:function Jae(n,t,e,s=1e-7,r=_n.SUM_BY_NONZERO_WEIGHTS){const i=I(n,"labels","logLoss"),o=I(t,"predictions","logLoss");let a=null;null!=e&&(a=I(e,"weights","logLoss")),Sr(i.shape,o.shape,"Error in logLoss: ");const l=ze(1),u=ze(s),c=dn(F(i,jr(le(o,u)))),d=F(Ne(l,i),jr(le(Ne(l,o),u))),h=Ne(c,d);return ua(h,a,r)}}),nle=k({meanSquaredError_:function tle(n,t,e,s=_n.SUM_BY_NONZERO_WEIGHTS){const r=I(n,"labels","meanSquaredError"),i=I(t,"predictions","meanSquaredError");let o=null;null!=e&&(o=I(e,"weights","meanSquaredError")),Sr(r.shape,i.shape,"Error in meanSquaredError: ");const a=cE(r,i);return ua(a,o,s)}}),ile=k({sigmoidCrossEntropy_:function rle(n,t,e,s=0,r=_n.SUM_BY_NONZERO_WEIGHTS){let i=I(n,"multiClassLabels","sigmoidCrossEntropy");const o=I(t,"logits","sigmoidCrossEntropy");let a=null;if(null!=e&&(a=I(e,"weights","sigmoidCrossEntropy")),Sr(i.shape,o.shape,"Error in sigmoidCrossEntropy: "),s>0){const u=ze(s),c=ze(1),d=ze(.5);i=le(F(i,Ne(c,u)),F(d,u))}const l=function sle(n,t){const e=I(n,"labels","sigmoidCrossEntropyWithLogits"),s=I(t,"logits","sigmoidCrossEntropyWithLogits");Sr(e.shape,s.shape,"Error in sigmoidCrossEntropyWithLogits: ");const r=xo(s),i=F(s,e),o=Lb(Hr(dn(ns(s))));return le(Ne(r,i),o)}(i,o);return ua(l,a,r)}}),lle=k({softmaxCrossEntropy_:function ale(n,t,e,s=0,r=_n.SUM_BY_NONZERO_WEIGHTS){let i=I(n,"onehotLabels","softmaxCrossEntropy");const o=I(t,"logits","softmaxCrossEntropy");let a=null;if(null!=e&&(a=I(e,"weights","softmaxCrossEntropy")),Sr(i.shape,o.shape,"Error in softmaxCrossEntropy: "),s>0){const u=ze(s),c=ze(1),d=ze(i.shape[1]);i=le(F(i,Ne(c,u)),Pe(u,d))}const l=function ole(n,t,e=-1){if(-1===e&&(e=t.rank-1),e!==t.rank-1)throw Error(`Softmax cross entropy along a non-last dimension is not yet supported. Labels / logits was rank ${t.rank} and dim was ${e}`);return ia((r,i,o)=>{const l=qI(i,[e],!0),u=Ne(xe(i,"float32"),l);o([r,u]);const c=dn(F(u,r));return{value:Re(c,[e]),gradFunc:(f,p)=>{const[g,m]=p,y=On(f.shape,[e]);return[F(O(f,y),Ne(xe(g,"float32"),Hr(m))),F(O(f,y),Ne(Hr(m),xe(g,"float32")))]}}})(n,t)}(i,o);return ua(l,a,r)}}),Ile={fft:Xb,ifft:gp,rfft:Yb,irfft:uE},Ele={hammingWindow:eae,hannWindow:GL,frame:HL,stft:rae},Co={flipLeftRight:lae,grayscaleToRGB:cae,resizeNearestNeighbor:KL,resizeBilinear:qL,rotateWithOffset:hae,cropAndResize:oae,nonMaxSuppression:pae,nonMaxSuppressionAsync:function wae(n,t,e){return IE.apply(this,arguments)},nonMaxSuppressionWithScore:Sae,nonMaxSuppressionWithScoreAsync:function Iae(n,t,e){return EE.apply(this,arguments)},nonMaxSuppressionPadded:Tae,nonMaxSuppressionPaddedAsync:function Nae(n,t,e){return DE.apply(this,arguments)},threshold:Oae,transform:Pae},YL={bandPart:Vae,gramSchmidt:zae,qr:Wae},Dle={absoluteDifference:jae,computeWeightedLoss:ua,cosineDistance:Kae,hingeLoss:Yae,huberLoss:Qae,logLoss:ele,meanSquaredError:nle,sigmoidCrossEntropy:ile,softmaxCrossEntropy:lle},Tle={sparseFillEmptyRows:k({sparseFillEmptyRows_:function ule(n,t,e,s){const r=I(n,"indices","sparseFillEmptyRows","int32"),i=I(t,"values","sparseFillEmptyRows"),o=I(e,"denseShape","sparseFillEmptyRows","int32"),a=I(s,"defaultValue","sparseFillEmptyRows",i.dtype);if(2!==r.rank)throw new Error(`Indices should be Tensor2D but received shape\n        ${r.shape}`);if(1!==i.rank)throw new Error(`Values should be Tensor1D but received shape ${i.shape}`);if(1!==o.rank)throw new Error(`Dense shape should be Tensor1D but received shape ${o.shape}`);if(0!==a.rank)throw new Error(`Default value should be a scalar but received shape ${a.shape}`);const u=M.runKernel(PS,{indices:r,values:i,denseShape:o,defaultValue:a});return{outputIndices:u[0],outputValues:u[1],emptyRowIndicator:u[2],reverseIndexMap:u[3]}}}),sparseReshape:k({sparseReshape_:function dle(n,t,e){const s=I(n,"inputIndices","sparseReshape","int32"),r=I(t,"inputShape","sparseReshape","int32"),i=I(e,"newShape","sparseReshape","int32");if(2!==s.rank)throw new Error(`Input indices should be Tensor2D but received shape\n        ${s.shape}`);if(1!==r.rank)throw new Error(`Input shape should be Tensor1D but received shape ${r.shape}`);if(1!==i.rank)throw new Error(`New shape should be Tensor1D but received shape ${i.shape}`);const a=M.runKernel(LS,{inputIndices:s,inputShape:r,newShape:i});return{outputIndices:a[0],outputShape:a[1]}}}),sparseSegmentMean:k({sparseSegmentMean_:function fle(n,t,e){const s=I(n,"data","sparseSegmentMean"),r=I(t,"indices","sparseSegmentMean","int32"),i=I(e,"segmentIds","sparseSegmentMean","int32");if(s.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==r.rank)throw new Error(`Indices should be Tensor1D but received shape\n          ${r.shape}`);if(1!==i.rank)throw new Error(`Segment ids should be Tensor1D but received shape\n          ${i.shape}`);return M.runKernel(VS,{data:s,indices:r,segmentIds:i})}}),sparseSegmentSum:k({sparseSegmentSum_:function mle(n,t,e){const s=I(n,"data","sparseSegmentSum"),r=I(t,"indices","sparseSegmentSum","int32"),i=I(e,"segmentIds","sparseSegmentSum","int32");if(s.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==r.rank)throw new Error(`Indices should be Tensor1D but received shape\n         ${r.shape}`);if(1!==i.rank)throw new Error(`Segment ids should be Tensor1D but received shape\n         ${i.shape}`);return M.runKernel(BS,{data:s,indices:r,segmentIds:i})}})},Nle={stringNGrams:k({stringNGrams_:function yle(n,t,e,s,r,i,o,a){const l=I(n,"data","stringNGrams","string");if("string"!==l.dtype)throw new Error("Data must be of datatype string");if(1!==l.shape.length)throw new Error(`Data must be a vector, saw: ${l.shape}`);const u=I(t,"dataSplits","stringNGrams");if("int32"!==u.dtype)throw new Error("Data splits must be of datatype int32");const h=M.runKernel(GS,{data:l,dataSplits:u},{separator:e,nGramWidths:s,leftPad:r,rightPad:i,padWidth:o,preserveShortSequences:a});return{nGrams:h[0],nGramsSplits:h[1]}}}),stringSplit:k({stringSplit_:function vle(n,t,e=!0){const s=I(n,"input","stringSplit","string"),r=I(t,"delimiter","stringSplit","string");if(1!==s.rank)throw new Error(`Input should be Tensor1D but received shape ${s.shape}`);if(0!==r.rank)throw new Error(`Delimiter should be a scalar but received shape ${r.shape}`);const a=M.runKernel(HS,{input:s,delimiter:r},{skipEmpty:e});return{indices:a[0],values:a[1],shape:a[2]}}}),stringToHashBucketFast:k({stringToHashBucketFast_:function wle(n,t){const e=I(n,"input","stringToHashBucketFast","string"),s={numBuckets:t};if(t<=0)throw new Error("Number of buckets must be at least 1");return M.runKernel(jS,{input:e},s)}}),staticRegexReplace:k({staticRegexReplace_:function Cle(n,t,e,s=!0){const r=I(n,"input","staticRegexReplace","string");return M.runKernel(fb,{x:r},{pattern:t,rewrite:e,replaceGlobal:s})}})},ld=class kle{static sgd(t){return new xI(t)}static momentum(t,e,s=!1){return new SP(t,e,s)}static rmsprop(t,e=.9,s=0,r=null,i=!1){return new IP(t,e,s,r,i)}static adam(t=.001,e=.9,s=.999,r=null){return new xP(t,e,s,r)}static adadelta(t=.001,e=.95,s=null){return new _P(t,e,s)}static adamax(t=.002,e=.9,s=.999,r=null,i=0){return new CP(t,e,s,r,i)}static adagrad(t,e=.1){return new wP(t,e)}},Ale=typeof requestAnimationFrame<"u"?requestAnimationFrame:typeof setImmediate<"u"?setImmediate:n=>n();function ZL(){return new Promise(n=>Ale(()=>n()))}function TE(n,t){const e=n[0].length;n.forEach((r,i)=>{S(r.length===e,()=>`Error in concat${e}D: rank of tensors[${i}] must be the same as the rank of the rest (${e})`)}),S(t>=0&&t<e,()=>`Error in concat${e}D: axis must be between 0 and ${e-1}.`);const s=n[0];n.forEach((r,i)=>{for(let o=0;o<e;o++)S(o===t||r[o]===s[o],()=>`Error in concat${e}D: Shape of tensors[${i}] (${r}) does not match the shape of the rest (${s}) along the non-concatenated axis ${i}.`)})}function So(n,t){const e=n[0].slice();for(let s=1;s<n.length;s++)e[t]+=n[s][t];return e}var wn=(()=>((wn=wn||{})[wn.FIRST_DIM_SIZE=0]="FIRST_DIM_SIZE",wn[wn.VALUE_ROWIDS=1]="VALUE_ROWIDS",wn[wn.ROW_LENGTHS=2]="ROW_LENGTHS",wn[wn.ROW_SPLITS=3]="ROW_SPLITS",wn[wn.ROW_LIMITS=4]="ROW_LIMITS",wn[wn.ROW_STARTS=5]="ROW_STARTS",wn))();function QL(n,t,e){let s=new Array;if(null==e&&null==t)return s;if(null==t)for(;s.length<n+e.length;)s.push(-1);else s=t.slice();if(null==e)return s;if(n+e.length!==s.length)throw new Error(`rt input.shape and shape=${t} are incompatible: rt input.rank = ${n+e.length}, but shape.rank = ${s.length}`);for(let r=1;r<e.length;++r){const i=e[r],o=s[s.length-e.length+r],a=s[o];if(i>=0)if(a>=0){if(a!==i)throw new Error(`rt input.shape and shape=${t} are incompatible: rt input.shape[${r+n}] = ${i} but shape[${r+n}] = ${a}`)}else s[o]=i}return s}function JL(n){const t={FIRST_DIM_SIZE:wn.FIRST_DIM_SIZE,VALUE_ROWIDS:wn.VALUE_ROWIDS,ROW_LENGTHS:wn.ROW_LENGTHS,ROW_SPLITS:wn.ROW_SPLITS,ROW_LIMITS:wn.ROW_LIMITS,ROW_STARTS:wn.ROW_STARTS},e=[];for(const s of n){if(!(s in t))break;e.push(t[s])}return e}function eV(n){return 0===n.length?0:n[0]===wn.FIRST_DIM_SIZE?n.length-1:n.length}function tV(n,t){if(null==n||null==t)return;const e=n.length,s=t.length;if(e>=s)throw new Error(`defaultValue.shape=${n} and ragged tensor flatValues.shape=${t}, are incompatible: defaultValue.rank = ${e} must be less than ragged tensor input flatValues.rank = ${s})`);for(let r=0;r<Math.min(e,s-1);++r){const i=n[r],o=t[r+1];if(i>=0&&o>=0&&1!==i&&i!==o)throw new Error(`defaultValue.shape=${n}, and ragged tensor input flatValues.shape=${t} are incompatible: defaultValue.shape[${r-n.length}] = ${i} but ragged tensor input.flatValues.shape[${r-n.length}] = ${o}`)}}const NE=30;function tv(n){return n<=NE?n:BC(n,Math.floor(Math.sqrt(n)))}function kE(n,t,e){return[e*("number"==typeof n?n:n[0]),t*("number"==typeof n?n:n[1])]}function yp(n,t,e,s=!0){let r=[];if(s)r=r.concat(t.slice(0)),r.push(n[0]/e),r=r.concat(n.slice(1));else{r=r.concat(n[0]);const i=t.length;for(let o=0;o<i;++o)r=r.concat([n[o+1]/t[o],t[o]]);r=r.concat(n.slice(i+1))}return r}function bp(n,t,e=!0){const s=[];if(e){s.push(t);for(let r=t+1;r<n;++r)r<=2*t?(s.push(r),s.push(r-(t+1))):s.push(r)}else{const r=[],i=[];for(let o=1;o<n;++o)o>=2*t+1||o%2==1?i.push(o):r.push(o);s.push(...r),s.push(0),s.push(...i)}return s}function vp(n,t,e,s=!0){const r=[];r.push(s?n[0]/e:n[0]*e);for(let i=1;i<n.length;++i)r.push(i<=t.length?s?t[i-1]*n[i]:n[i]/t[i-1]:n[i]);return r}function AE(n,t){const e=[0];for(let s=0;s<t;++s)e.push(n[s][0]);return e}function RE(n,t,e){const s=n.slice(0,1);for(let r=0;r<e;++r)s.push(n[r+1]-t[r][0]-t[r][1]);return s}function ME(n,t){const e=n.shape.length,s=t.shape.length;if(e<1)throw new Error(`tf.gatherND() expects the input to be rank 1 or higher, but the rank was ${e}.`);if(s<1)throw new Error(`tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ${s}.`);if("int32"!==t.dtype)throw new Error(`tf.gatherND() expects the indices to be int32 type, but the dtype was ${t.dtype}.`);if(t.shape[s-1]>e)throw new Error(`index innermost dimension length must be <= tensor rank; saw: ${t.shape[s-1]} vs. ${e}`);if(0===X(n.shape))throw new Error(`Requested more than 0 entries, but input is empty. Input shape: ${n.shape}.`);const r=t.shape,i=r[r.length-1];let o=1;for(let d=0;d<r.length-1;++d)o*=r[d];const a=n.shape,l=r.slice();l.pop();let u=1;for(let d=i;d<e;++d)u*=a[d],l.push(a[d]);const c=[...Be(n.shape).map(d=>d/u),1].slice(0,i);return[l,o,u,c]}const nv=1.7580993408473768,sv=1.0507009873554805,FE=.3275911,OE=.254829592,$E=-.284496736,PE=1.421413741,LE=-1.453152027,VE=1.061405429;function ca(n,t){if(n.length!==t.length)throw new Error(`Cannot merge real and imag arrays of different lengths. real:${n.length}, imag: ${t.length}.`);const e=new Float32Array(2*n.length);for(let s=0;s<e.length;s+=2)e[s]=n[s/2],e[s+1]=t[s/2];return e}function nV(n){const t=new Float32Array(n.length/2),e=new Float32Array(n.length/2);for(let s=0;s<n.length;s+=2)t[s/2]=n[s],e[s/2]=n[s+1];return{real:t,imag:e}}function sV(n){const t=Math.ceil(n.length/4),e=new Float32Array(t),s=new Float32Array(t);for(let r=0;r<n.length;r+=4)e[Math.floor(r/4)]=n[r],s[Math.floor(r/4)]=n[r+1];return{real:e,imag:s}}function rV(n){const t=Math.floor(n.length/4),e=new Float32Array(t),s=new Float32Array(t);for(let r=2;r<n.length;r+=4)e[Math.floor(r/4)]=n[r],s[Math.floor(r/4)]=n[r+1];return{real:e,imag:s}}function BE(n,t){return{real:n[2*t],imag:n[2*t+1]}}function iV(n,t,e,s){n[2*s]=t,n[2*s+1]=e}function oV(n,t){const e=new Float32Array(n/2),s=new Float32Array(n/2);for(let r=0;r<Math.ceil(n/2);r++){const i=(t?2:-2)*Math.PI*(r/n);e[r]=Math.cos(i),s[r]=Math.sin(i)}return{real:e,imag:s}}function aV(n,t,e){const s=(e?2:-2)*Math.PI*(n/t);return{real:Math.cos(s),imag:Math.sin(s)}}const zE="->",Rle=/->/g,lV=",",uV="...";function UE(n,t){const e=((n=n.replace(/\s/g,"")).length-n.replace(Rle,"").length)/zE.length;if(e<1)throw new Error("Equations without an arrow are not supported.");if(e>1)throw new Error(`Equation must contain exactly one arrow ("${zE}").`);const[s,r]=n.split(zE);S(-1===s.indexOf(uV),()=>`The ellipsis notation ("${uV}") is not supported yet.`);const i=s.split(lV),o=i.length;if(t!==o)throw new Error(`Expected ${o} input tensors, received ${t}`);if(o>2)throw new Error("Support for more than 2 input tensors is not implemented yet.");const a=[];for(let h=0;h<r.length;++h){const f=r[h];if(!i.some(p=>-1!==p.indexOf(f)))throw new Error(`Output subscripts contain the label ${f} not present in the input subscripts.`);-1===a.indexOf(f)&&a.push(f)}for(let h=0;h<s.length;++h){const f=s[h];-1===a.indexOf(f)&&f!==lV&&a.push(f)}const l=new Array(i.length);for(let h=0;h<o;++h){if(new Set(i[h].split("")).size!==i[h].length)throw new Error(`Found duplicate axes in input component ${i[h]}. Support for duplicate axes in input is not implemented yet.`);l[h]=[];for(let f=0;f<i[h].length;++f)l[h].push(a.indexOf(i[h][f]))}const u=a.length,d=[];for(let h=r.length;h<u;++h)d.push(h);return{allDims:a,summedDims:d,idDims:l}}function WE(n,t){let e=new Array(n);e.fill(-1);for(let r=0;r<t.length;++r)e[t[r]]=r;const s=[];for(let r=0;r<n;++r)-1===e[r]&&s.push(r);return e=e.filter(r=>-1!==r),{permutationIndices:e,expandDims:s}}function GE(n,t,e){const s=new Array(n);for(let r=0;r<e.length;++r){const i=e[r].shape;for(let o=0;o<t[r].length;++o)void 0===s[t[r][o]]?s[t[r][o]]=i[o]:S(s[t[r][o]]===i[o],()=>`Expected dimension ${s[t[r][o]]} at axis ${o} of input shaped ${JSON.stringify(i)}, but got dimension ${i[o]}`)}}function HE(n,t){const e=n,s=[];let r=0;0===n.length&&e.push(-1),r=n.length+1;for(let o=0;o<r;++o)s.push([]);const i=[];for(let o=0;o<e.length;++o){const l=Mle(t,e[o]);for(const u of l)-1===i.indexOf(u)&&(s[o].push(u),i.push(u))}return{path:e,steps:s}}function jE(n){return n.every((t,e)=>t===e)}function Mle(n,t){const e=[];for(let s=0;s<n.length;++s)(0===n[s].length||-1!==n[s].indexOf(t)||-1===t)&&e.push(s);return e}function qE(n,t,e=0){let s=[];if("number"==typeof t)S(n.shape[e]%t==0,()=>"Number of splits must evenly divide the axis."),s=new Array(t).fill(n.shape[e]/t);else{S(t.reduce((o,a)=>(-1===a&&(o+=1),o),0)<=1,()=>"There should be only one negative value in split array.");const i=t.indexOf(-1);if(-1!==i){const o=t.reduce((a,l)=>l>0?a+l:a);t[i]=n.shape[e]-o}S(n.shape[e]===t.reduce((o,a)=>o+a),()=>"The sum of sizes must match the size of the axis dimension."),s=t}return s}function cV(n){return`Received SparseTensor with denseShape[0] = 0 but\n  indices.shape[0] = ${n}`}function dV(n,t){return`indices(${n}, 0) is invalid: ${t} < 0`}function hV(n,t,e){return`indices(${n}, 0) is invalid: ${t} >= ${e}`}function fV(n,t){return`only one output dimension may be -1, not both ${n} and ${t}`}function pV(n,t){return`size ${n} must be non-negative, not ${t}`}function mV(){return"reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero"}function gV(n,t){return`Input to reshape is a SparseTensor with ${X(n)}\n  dense values, but the requested shape requires a multiple of ${X(t)}. inputShape=${n} outputShape= ${t}`}function yV(n,t){return`Input to reshape is a tensor with ${X(n)} dense values, but the requested shape has ${X(t)}. inputShape=${n} outputShape=${t}`}function KE(){return"segment ids must be >= 0"}function bV(){return"segment ids are not increasing"}function vV(n,t){return`Segment id ${n} out of range [0, ${t}), possibly because segmentIds input is not sorted.`}function _V(n,t,e){return`Bad: indices[${n}] == ${t} out of range [0, ${e})`}function wV(n,t){let s,e=!1;for(n<=NE?(s=n,e=!0):s=BC(n,Math.floor(Math.sqrt(n)));!e;)s>t||s===n?e=!0:s=BC(n,s+1);return s}function xV(n,t,e){const s=[],r=n.length;for(let i=0;i<r;i++)s.push(i!==t?n[i]:e);return s}function XE(n,t,e,s){const r=t.shape.length,i=n.shape.length;if(0!==s&&(s<-r||s>r))throw new Error(`Expect batchDims in the range of [-${r}, ${r}], but got ${s}`);if(s<0&&(s+=r),s>i)throw new Error(`batchDims (${s}) must be less than rank(x) (\n    ${i}).`);if(e<s)throw new Error(`batchDims (${s}) must be less than or equal to axis (${e}).`);for(let d=0;d<s;++d)if(n.shape[d]!==t.shape[d])throw new Error(`x.shape[${d}]: ${n.shape[d]} should be equal to indices.shape[${d}]: ${t.shape[d]}.`);const o=n.shape[e],a=[];let l=1,u=1,c=1;for(let d=0;d<s;++d)a.push(n.shape[d]),l*=n.shape[d];for(let d=s;d<e;d++)a.push(n.shape[d]),u*=n.shape[d];for(let d=s;d<r;d++)a.push(t.shape[d]);for(let d=e+1;d<i;d++)a.push(n.shape[d]),c*=n.shape[d];return{batchSize:l,sliceSize:c,outerSize:u,dimSize:o,outputShape:a}}function da(n){try{return n.map(t=>La(t))}catch(t){throw new Error(`Failed to decode encoded string bytes into utf-8, error: ${t}`)}}function CV(n){return n.map(t=>Pa(t))}!function lne(){for(const n of ane)ue(n)}();const SV={kernelName:my,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>F(n,id(xe(e,"float32"),-1))}}},Fle={kernelName:ef,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>{const s=en(xe(e,"float32")),r=Bs(Ne(ze(1),s));return dn(Pe(n,r))}}}},Ole={kernelName:nf,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>{const s=Bs(Ne(en(xe(e,"float32")),1));return Pe(n,s)}}}},$le={kernelName:zc,inputsToSave:["a","b"],gradFunc:(n,t)=>{const[e,s]=t,r=nt(e.shape,s.shape);return{a:()=>{let a=n;const l=ss(e.shape,r);return l.length>0&&(a=Re(a,l)),O(a,e.shape)},b:()=>{let a=n;const l=ss(s.shape,r);return l.length>0&&(a=Re(a,l)),O(a,s.shape)}}}},Ple={kernelName:gy,saveAllInputs:!0,gradFunc:(n,t)=>{const e={};return t.forEach((s,r)=>{e[r]=()=>n.clone()}),e}},Lle={kernelName:yy,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>Et(e)}}},Vle={kernelName:by,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>Et(e)}}},Ble={kernelName:sf,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>Pe(n,Bs(Ne(ze(1),en(xe(e,"float32")))))}}},zle={kernelName:rf,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>{const s=Bs(le(ze(1),en(xe(e,"float32"))));return Pe(n,s)}}}},Ule={kernelName:uf,inputsToSave:["a","b"],gradFunc:(n,t)=>{const[e,s]=t,r=nt(e.shape,s.shape);return{a:()=>{const a=le(en(e),en(s));let l=F(n,Pe(s,a));const u=ss(e.shape,r);return u.length>0&&(l=Re(l,u)),O(l,e.shape)},b:()=>{const a=le(en(e),en(s));let l=dn(F(n,Pe(e,a)));const u=ss(s.shape,r);return u.length>0&&(l=Re(l,u)),O(l,s.shape)}}}},Wle={kernelName:af,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>Pe(n,le(en(xe(e,"float32")),1))}}},Gle={kernelName:lf,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>Pe(n,Ne(ze(1),en(xe(e,"float32"))))}}},jle=k({avgPool3dGrad_:function Hle(n,t,e,s,r,i){const o=I(n,"dy","avgPool3dGrad"),a=I(t,"input","avgPool3dGrad");let l=o,u=a,c=!1;4===a.rank&&(c=!0,l=O(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]]),u=O(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]])),S(5===l.rank,()=>`Error in avgPool3dGrad: dy must be rank 5 but got rank ${l.rank}.`),S(5===u.rank,()=>`Error in avgPool3dGrad: input must be rank 5 but got rank ${u.rank}.`),Xs("avgPool3dGrad",r,i);const f=M.runKernel(qC,{dy:l,input:u},{filterSize:e,strides:s,pad:r,dimRoundingMode:i});return c?O(f,[f.shape[1],f.shape[2],f.shape[3],f.shape[4]]):f}}),qle={kernelName:_y,inputsToSave:["x"],gradFunc:(n,t,e)=>{const[s]=t,{filterSize:r,strides:i,pad:o,dimRoundingMode:a}=e;return{x:()=>jle(n,s,r,i,o,a)}}},Xle=k({avgPoolGrad_:function Kle(n,t,e,s,r){const i=I(n,"dy","avgPoolGrad"),o=I(t,"input","avgPoolGrad");S(o.rank===i.rank,()=>`Rank of input (${o.rank}) does not match rank of dy (${i.rank})`);let a=o,l=i,u=!1;3===o.rank&&(u=!0,a=O(o,[1,o.shape[0],o.shape[1],o.shape[2]]),l=O(i,[1,i.shape[0],i.shape[1],i.shape[2]])),S(4===l.rank,()=>`Error in avgPoolGrad: dy must be rank 4 but got rank ${l.rank}.`),S(4===a.rank,()=>`Error in avgPoolGrad: input must be rank 4 but got rank ${a.rank}.`);const h=M.runKernel(jC,{dy:l,input:a},{filterSize:e,strides:s,pad:r});return u?O(h,[h.shape[1],h.shape[2],h.shape[3]]):h}}),Yle={kernelName:vy,inputsToSave:["x"],gradFunc:(n,t,e)=>{const[s]=t,{filterSize:r,strides:i,pad:o}=e;return{x:()=>Xle(n,s,r,i,o)}}},Zle={kernelName:wy,inputsToSave:["a","b"],gradFunc:(n,t,e)=>{const[s,r]=t,{transposeA:i,transposeB:o}=e;return i||o?!i&&o?{a:()=>bt(n,r,!1,!1),b:()=>bt(n,s,!0,!1)}:i&&!o?{a:()=>bt(r,n,!1,!0),b:()=>bt(s,n,!1,!1)}:{a:()=>bt(r,n,!0,!0),b:()=>bt(n,s,!0,!0)}:{a:()=>bt(n,r,!1,!0),b:()=>bt(s,n,!0,!1)}}},Qle={kernelName:xy,gradFunc:(n,t,e)=>{const{blockShape:s,crops:r}=e;return{x:()=>Wb(n,s,r)}}},Jle={kernelName:"BroadcastTo",gradFunc:(n,t,e)=>{const r=e.inputShape,i=e.shape,o=Array.from(i);for(let l=r.length-1;l>=0;l--)if(r[l]===i[l])o[l]=1;else if(1!==r[l])throw new Error(`broadcastTo(): [${r}] cannot be broadcast to [${i}].`);const a=[];for(let l=0;l<o.length;l++)o[l]>1&&a.push(l);return{x:()=>Re(n,a,!0)}}},eue={kernelName:cf,gradFunc:n=>({x:()=>n.clone()})},tue={kernelName:df,gradFunc:n=>({x:()=>Et(n)})},nue={kernelName:hf,inputsToSave:["x"],gradFunc:(n,t,e)=>{const[s]=t,{clipValueMin:r,clipValueMax:i}=e;return{x:()=>zs(wo(Ja(s,r),iu(s,i)),n,Et(n))}}},sue={kernelName:Cy,inputsToSave:["x"],gradFunc:SV.gradFunc},rue={kernelName:Sy,saveAllInputs:!0,gradFunc:(n,t,e)=>{const s=t.map(l=>l.shape),{axis:r}=e,i=mt(r,t[0].shape)[0],o=s.map(l=>l[i]);return Tr(n,o,i).map(l=>()=>l)}},iue={kernelName:Iy,inputsToSave:["x","filter"],gradFunc:(n,t,e)=>{const[s,r]=t,{dilations:i,strides:o,pad:a,dataFormat:l}=e;return S(Ya(i),()=>`Error in gradient of conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${i}'`),{x:()=>VI(s.shape,n,r,o,a,l),filter:()=>vE(s,n,r.shape,o,a,l)}}},oue={kernelName:Ey,inputsToSave:["dy","filter"],gradFunc:(n,t,e)=>{const[s,r]=t,{strides:i,pad:o,dataFormat:a,dimRoundingMode:l}=e;return{dy:()=>Za(n,r,i,o,a,1,l),filter:()=>vE(n,s,r.shape,i,o,a,l)}}},lue=k({conv3DBackpropFilter_:function aue(n,t,e,s,r){let i=n;4===n.rank&&(i=O(n,[1,n.shape[0],n.shape[1],n.shape[2],n.shape[3]]));let o=t;return 4===o.rank&&(o=O(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]])),S(5===i.rank,()=>`Error in conv3dDerFilter: input must be rank 5, but got shape ${i.shape}.`),S(5===o.rank,()=>`Error in conv3dDerFilter: dy must be rank 5, but got shape ${o.shape}.`),S(5===e.length,()=>`Error in conv3dDerFilter: filterShape must be length 5, but got ${e}.`),S(i.shape[4]===e[3],()=>`Error in conv3dDerFilter: depth of input ${i.shape[4]}) must match input depth in filter (${e[3]}.`),S(o.shape[4]===e[4],()=>`Error in conv3dDerFilter: depth of dy (${o.shape[4]}) must match output depth for filter (${e[4]}).`),M.runKernel(JC,{x:i,dy:o},{strides:s,pad:r,filterShape:e})}}),uue={kernelName:Dy,inputsToSave:["x","filter"],gradFunc:(n,t,e)=>{const{dilations:s,strides:r,pad:i}=e;S(Ya(s),()=>`Error in gradient of conv3D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${s}'`);const[o,a]=t;return{x:()=>lL(o.shape,n,a,r,i),filter:()=>lue(o,n,a.shape,r,i)}}},cue={kernelName:ff,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>F(dn(oE(xe(e,"float32"))),n)}}},due={kernelName:pf,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>F(aE(xe(e,"float32")),n)}}},hue={kernelName:Ty,inputsToSave:["x"],gradFunc:(n,t,e)=>{const[s]=t,{axis:r,exclusive:i,reverse:o}=e;return{x:()=>{const a=vn([r],s.rank);let l=UI(n,r,i,!o);return null!=a&&(l=Tt(l,a)),l}}}},fue={kernelName:Ny,inputsToSave:["x","filter"],gradFunc:(n,t,e)=>{const{dilations:s,strides:r,pad:i,dimRoundingMode:o}=e,a=s??[1,1];S(Ya(a),()=>`Error in gradient of depthwiseConv2dNative: dilation rates greater than 1 are not yet supported. Got dilations '${a}'`);const[l,u]=t;return S(4===l.rank,()=>`Error in gradient of depthwiseConv2dNative: input must be rank 4, but got rank ${l.rank}.`),S(4===u.rank,()=>`Error in gradient of depthwiseConv2dNative: filter must be rank 4, but got rank ${u.rank}.`),S(l.shape[3]===u.shape[2],()=>`Error in gradient of depthwiseConv2d: number of input channels (${l.shape[3]}) must match the inChannels dimension in filter ${u.shape[2]}.`),S(Ts(r,a),()=>`Error in gradient of depthwiseConv2d: Either strides or dilations must be  1. Got strides ${r} and dilations '${a}'.`),Xs("depthwiseConv2d",i,o),{x:()=>WL(l.shape,n,u,r,i,a,o),filter:()=>UL(l,n,u.shape,r,i,a,o)}}},pue={kernelName:ky,inputsToSave:["x","filter"],gradFunc:(n,t,e)=>{const[s,r]=t,i={x:s,filter:r,dy:n},o={x:s,filter:r,dy:n};return{x:()=>M.runKernel(lS,i,e),filter:()=>M.runKernel(uS,o,e)}}},mue={kernelName:gf,outputsToSave:[!0],gradFunc:(n,t)=>{const[e]=t,s={dy:n,y:e};return{x:()=>M.runKernel(dS,s)}}},gue={kernelName:yf,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t,s=F(Hr(dn(en(e))),2/Math.sqrt(Math.PI));return{x:()=>F(n,s)}}},yue={kernelName:bf,outputsToSave:[!0],gradFunc:(n,t)=>{const[e]=t;return{x:()=>F(n,e)}}},bue={kernelName:Ry,inputsToSave:["input"],gradFunc:(n,t)=>{const[e]=t;return{input:()=>O(n,e.shape)}}},vue={kernelName:vf,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>F(n,Hr(e))}}},_ue={kernelName:_f,gradFunc:n=>({x:()=>Et(n)})},wue={kernelName:wf,inputsToSave:["a","b"],gradFunc:(n,t)=>{const[e,s]=t,r=nt(e.shape,s.shape);return{a:()=>{const a=Pe(n,xe(s,"float32")),l=ss(e.shape,r);return l.length>0?O(Re(a,l),e.shape):a},b:()=>{let a=F(n,xe(e,"float32"));const l=ss(s.shape,r);l.length>0&&(a=O(Re(a,l),s.shape));const u=en(s);return dn(Pe(a,xe(u,"float32")))}}}},xue={kernelName:My,inputsToSave:["x","mean","variance","scale"],gradFunc:(n,t,e)=>{const{varianceEpsilon:s}=e,[r,i,o,a]=t,l=a??ze(1),u=ss(i.shape,r.shape),c=[];if(1===i.rank){for(let _=0;_<r.shape.length-1;++_)c.push(r.shape[_]);c.push(1)}const d=Ne(r,i),h=F(n,l),f=nE(le(o,ze(s))),p=F(F(F(f,f),f),ze(-.5));return{x:()=>O(F(F(n,1===i.rank?gi(O(f,[1,1,1,i.shape[0]]),c):f),l),r.shape),mean:()=>{let _=F(F(f,ze(-1)),h);return 1===i.rank&&(_=Re(_,u)),O(_,i.shape)},variance:()=>{let _=F(F(p,d),h);return 1===i.rank&&(_=Re(_,u)),O(_,i.shape)},scale:()=>{const _=F(d,f);let x=F(n,_);return 1===i.rank&&(x=Re(x,u)),O(x,i.shape)},offset:()=>{let _=n;return 1===i.rank&&(_=Re(_,u)),O(_,i.shape)}}}},Cue={kernelName:Fy,inputsToSave:["x","indices"],gradFunc:(n,t,e)=>{const[s,r]=t,{axis:i}=e,o=mt(i,s.shape)[0];return{x:()=>{const l=s.shape,u=r.size,c=l.slice(0,o),d=c.length,h=l.slice(i,l.length).slice(1),f=h.length,p=IV(0,d),g=IV(d+1,d+1+f),m=EV([c,[u],h]),y=O(n,m),b=O(r,[u]),v=EV([[d],p,g]),_=Tt(y,v);let x=fE(_,b,s.shape[o]);const C=Qa(v);return x=Tt(x,C),x},indices:()=>r}}};function IV(n,t){const e=[];for(let s=n;s<t;++s)e.push(s);return e}function EV(n){const t=[];for(let e=0;e<n.length;++e)for(let s=0;s<n[e].length;++s)t.push(n[e][s]);return t}const Sue={kernelName:xf,inputsToSave:["a","b"],gradFunc:(n,t)=>{const[e,s]=t;return{a:()=>Et(e),b:()=>Et(s)}}},Iue={kernelName:Cf,gradFunc:n=>({x:()=>xe(n,"float32")})},Eue={kernelName:Sf,gradFunc:n=>({x:()=>Et(n)})},Due={kernelName:If,gradFunc:n=>({x:()=>Et(n)})},Tue={kernelName:Ef,gradFunc:n=>({x:()=>Et(n)})},Nue={kernelName:$y,inputsToSave:["x"],gradFunc:(n,t,e)=>{const[s]=t,{alpha:r}=e,i=Dr(s,0);return{x:()=>zs(i,n,F(n,r))}}},kue={kernelName:Tf,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>Pe(n,le(e,1))}}},Aue={kernelName:Df,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>Pe(n,xe(e,"float32"))}}},Rue={kernelName:"LogSoftmax",inputsToSave:[],outputsToSave:[!0],gradFunc:(n,t,e)=>{const[s]=t,{axis:r}=e;return{logits:()=>{const o=Hr(s);return Ne(n,F(Re(n,r,!0),o))}}}},Fue=k({localResponseNormalizationBackprop_:function Mue(n,t,e,s=5,r=1,i=1,o=.5){return M.runKernel(vS,{x:n,y:t,dy:e},{depthRadius:s,bias:r,alpha:i,beta:o})}}),Oue={kernelName:Uy,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,t,e)=>{const[s,r]=t,{depthRadius:i,bias:o,alpha:a,beta:l}=e;return{x:()=>Fue(s,r,n,i,o,a,l)}}};function DV(n,t,e,s){return t.rank<e.rank&&(t=O(t,On(t.shape,s))),n.rank<e.rank&&(n=O(n,On(n.shape,s))),{x:()=>F(n,xe(Wi(e,t),n.dtype))}}const TV={kernelName:Wy,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,t,e)=>{const s=e,{reductionIndices:r}=s,i=t[0],l=DV(n,t[1],i,mt(r,i.shape));return{x:()=>l.x()}}},$ue={kernelName:Nf,inputsToSave:["a","b"],gradFunc:(n,t)=>{const[e,s]=t;return{a:()=>F(n,xe(Ja(e,s),"float32")),b:()=>F(n,xe(fp(e,s),"float32"))}}},Lue=k({maxPool3dGrad_:function Pue(n,t,e,s,r,i,o){const a=I(n,"dy","maxPool3dGrad"),l=I(t,"input","maxPool3dGrad"),u=I(e,"output","maxPool3dGrad");let c=a,d=l,h=u,f=!1;4===l.rank&&(f=!0,c=O(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]]),d=O(l,[1,l.shape[0],l.shape[1],l.shape[2],l.shape[3]]),h=O(u,[1,u.shape[0],u.shape[1],u.shape[2],u.shape[3]])),S(5===c.rank,()=>`Error in maxPool3dGrad: dy must be rank 5 but got rank ${c.rank}.`),S(5===d.rank,()=>`Error in maxPool3dGrad: input must be rank 5 but got rank ${d.rank}.`),S(5===h.rank,()=>`Error in maxPool3dGrad: output must be rank 5 but got rank ${h.rank}.`),Xs("maxPool3dGrad",i,o);const m=M.runKernel(wS,{dy:c,input:d,output:h},{filterSize:s,strides:r,pad:i,dimRoundingMode:o});return f?O(m,[m.shape[1],m.shape[2],m.shape[3],m.shape[4]]):m}}),Vue={kernelName:Hy,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,t,e)=>{const[s,r]=t,{filterSize:i,strides:o,pad:a,dimRoundingMode:l}=e;return{x:()=>Lue(n,s,r,i,o,a,l)}}},zue=k({maxPoolGrad_:function Bue(n,t,e,s,r,i,o){const a=I(n,"dy","maxPoolGrad"),l=I(t,"input","maxPoolGrad"),u=I(e,"output","maxPoolGrad");return S(l.rank===a.rank,()=>`Rank of input (${l.rank}) does not match rank of dy (${a.rank})`),S(4===a.rank,()=>`Error in maxPoolGrad: dy must be rank 4 but got rank ${a.rank}.`),S(4===l.rank,()=>`Error in maxPoolGrad: input must be rank 4 but got rank ${l.rank}.`),Xs("maxPoolGrad",i,o),M.runKernel(_S,{dy:a,input:l,output:u},{filterSize:s,strides:r,pad:i,dimRoundingMode:o})}}),NV={kernelName:eb,inputsToSave:["x"],gradFunc:(n,t,e)=>{const s=t[0],{paddings:r}=e,i=r.map(o=>o[0]);return{x:()=>Dt(n,i,s.shape)}}};const kV={kernelName:cb,gradFunc:(n,t,e)=>{const{blockShape:s,paddings:r}=e;return{x:()=>Mb(n,s,r)}}},AV={kernelName:db,gradFunc:(n,t,e)=>{const{axis:s}=e;return{x:()=>jn(n,s)}}},Pce=[SV,Fle,Ole,$le,Ple,Lle,Vle,Ble,zle,Ule,Wle,Gle,qle,Yle,Zle,Qle,Jle,eue,tue,nue,sue,rue,oue,iue,uue,cue,due,hue,fue,pue,{kernelName:mf,inputsToSave:["a","b"],gradFunc:(n,t)=>{const[e,s]=t,r=nt(e.shape,s.shape);return{a:()=>{const a=Pe(n,xe(s,"float32")),l=ss(e.shape,r);return l.length>0?O(Re(a,l),e.shape):a},b:()=>{let a=F(n,xe(e,"float32"));const l=ss(s.shape,r);l.length>0&&(a=O(Re(a,l),s.shape));const u=en(s);return dn(Pe(a,xe(u,"float32")))}}}},mue,gue,yue,bue,vue,wue,_ue,xue,Cue,Sue,Iue,Eue,Due,Tue,Nue,kue,Aue,Rue,Oue,TV,TV,$ue,Vue,{kernelName:Gy,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,t,e)=>{const[s,r]=t,{filterSize:i,strides:o,pad:a}=e;return{x:()=>zue(n,s,r,i,o,a)}}},{kernelName:jy,inputsToSave:["x"],gradFunc:(n,t,e)=>{const[s]=t,{axis:r}=e,i=mt(r,s.shape),l=X(ws(s.shape,i)[1]);return{x:()=>{const c=s.shape.slice();i.forEach(f=>{c[f]=1});const d=O(n,c);return Pe(F(d,qr(s.shape,"float32")),l)}}}},{kernelName:qy,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,t,e)=>{const s=e,{axis:r}=s,[i,o]=t,l=DV(n,o,i,mt(r,i.shape));return{x:()=>l.x()}}},{kernelName:kf,inputsToSave:["a","b"],gradFunc:(n,t)=>{const[e,s]=t;return{a:()=>F(n,xe(iu(e,s),"float32")),b:()=>F(n,xe(Dr(e,s),"float32"))}}},{kernelName:Ky,inputsToSave:["x"],gradFunc:(n,t,e)=>{const s=t[0],{paddings:r}=e,i=r.map(o=>o[0]);return{x:()=>Dt(n,i,s.shape)}}},{kernelName:Af,inputsToSave:["a","b"],gradFunc:(n,t)=>{const[e,s]=t,r=nt(e.shape,s.shape);return{a:()=>{const a=ss(e.shape,r);return a.length>0?O(Re(n,a),e.shape):n},b:()=>{const a=F(n,dn(dp(Pe(e,s)))),l=ss(s.shape,r);return l.length>0?O(Re(a,l),s.shape):a}}}},{kernelName:Rf,inputsToSave:["a","b"],gradFunc:(n,t)=>{const[e,s]=t,r=nt(e.shape,s.shape);return{a:()=>{const a=F(n,xe(s,"float32")),l=ss(e.shape,r);return l.length>0?O(Re(a,l),e.shape):a},b:()=>{const a=F(n,xe(e,"float32")),l=ss(s.shape,r);return l.length>0?O(Re(a,l),s.shape):a}}}},{kernelName:Xy,gradFunc:n=>({x:()=>dn(n)})},{kernelName:Qy,inputsToSave:["indices"],gradFunc:(n,t)=>{const e=t[0];return{indices:()=>rs(e.shape,"float32")}}},{kernelName:Zy,gradFunc:n=>({x:()=>Et(n)})},{kernelName:Jy,saveAllInputs:!0,gradFunc:(n,t,e)=>{const{axis:s}=e;return bi(n,s).map(i=>()=>i)}},NV,NV,{kernelName:Mf,inputsToSave:["a","b"],outputsToSave:[!0],gradFunc:(n,t)=>{const[e,s,r]=t,i=e,o=s,a=nt(i.shape,o.shape);return{a:()=>{const c=xe(o,"float32");let d=F(n,F(c,Ka(i,Ne(c,ze(1)))));const h=ss(i.shape,a);return h.length>0&&(d=Re(d,h)),O(d,i.shape)},b:()=>{const c=Dr(i,0),d=zs(c,jr(i),Et(i));let h=F(n,F(r,d));const f=ss(o.shape,a);return f.length>0&&(h=Re(h,f)),O(h,o.shape)}}}},{kernelName:tb,inputsToSave:["x","alpha"],gradFunc:(n,t)=>{const[e,s]=t,r=Dr(e,0);return{x:()=>zs(r,n,F(n,s)),alpha:()=>{let i=zs(r,Et(n),F(n,e));const o=ss(s.shape,n.shape);return o.length>0&&(i=Re(i,o)),O(i,s.shape)}}}},{kernelName:nb,inputsToSave:["x"],gradFunc:(n,t,e)=>{const[s]=t,{axis:r}=e;let i=[];return i=null==r?s.shape.map((o,a)=>a):"number"==typeof r?[r]:r,{x:()=>function nce(n,t,e){const s=n.shape.length,r=s-e.length,i=vn(e,s);let o=n;null!=i&&(o=Tt(n,i));const a=o.shape.slice(),u=a.splice(s-e.length,e.length).reduce((h,f)=>h*f,1);a.push(u);let d=function tce(n,t,e){const s=n.shape.slice();s[e]=1;const r=O(t,s),i=Ob(n,e,!0,!1),o=Ob(n,e,!0,!0),a=F(i,o);return F(r,a)}(o.reshape(a),t,r);if(d=d.reshape(o.shape),null!=i){const h=Qa(i);d=Tt(d,h)}return d}(s,n,i)}}},{kernelName:Ff,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>Pe(n,dn(en(e)))}}},{kernelName:$f,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t,s=F(iu(e,6),id(e));return{x:()=>F(n,xe(s,"float32"))}}},{kernelName:Of,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>F(n,xe(id(e),"float32"))}}},{kernelName:sb,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>O(n,e.shape)}}},{kernelName:ib,inputsToSave:["images"],gradFunc:(n,t,e)=>{const[s]=t,r={dy:n,images:s};return{images:()=>M.runKernel(MS,r,e)}}},{kernelName:rb,inputsToSave:["images"],gradFunc:(n,t,e)=>{const[s]=t,r={dy:n,images:s};return{images:()=>M.runKernel(RS,r,e)}}},{kernelName:ob,gradFunc:(n,t,e)=>{const{dims:s}=e,r=mt(s,n.shape);return{x:()=>yi(n,r)}}},{kernelName:Pf,gradFunc:n=>({x:()=>Et(n)})},{kernelName:Lf,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>dn(Pe(n,F(Ka(e,1.5),2)))}}},{kernelName:ab,inputsToSave:["condition"],gradFunc:(n,t)=>{const[e]=t;return{condition:()=>xe(Et(e),"float32"),t:()=>F(n,xe(e,n.dtype)),e:()=>F(n,xe(Vb(e),n.dtype))}}},{kernelName:Vf,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>{const s=Dr(e,ze(0)),r=ze(nv),i=ze(sv),o=F(n,i),a=F(F(n,r),Hr(xe(e,"float32")));return zs(s,o,a)}}}},{kernelName:Wf,outputsToSave:[!0],gradFunc:(n,t)=>{const[e]=t;return{x:()=>F(n,F(e,Ne(ze(1),e)))}}},{kernelName:Uf,gradFunc:n=>({x:()=>Et(n)})},{kernelName:Bf,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>F(Fb(xe(e,"float32")),n)}}},{kernelName:zf,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>F(zI(xe(e,"float32")),n)}}},{kernelName:lb,inputsToSave:["x"],gradFunc:(n,t,e)=>{const[s]=t,{begin:r,size:i}=e,o=s.shape,[a,l]=kb(s,r,i),u=[];for(let c=0;c<n.rank;c++)u.push([a[c],o[c]-a[c]-l[c]]);return{x:()=>el(n,u)}}},{kernelName:hb,outputsToSave:[!0],gradFunc:(n,t,e)=>{const[s]=t,{dim:r}=e,o=F(n,s);return{logits:()=>Ne(o,F(Re(o,[r],!0),s))}}},{kernelName:Gf,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>F(n,_o(e))}}},kV,kV,AV,AV,{kernelName:Hf,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>Pe(n,F(Bs(xe(e,"float32")),2))}}},{kernelName:jf,inputsToSave:["a","b"],gradFunc:(n,t)=>{const[e,s]=t,r=ze(2);return{a:()=>F(n,F(r,Ne(e,s))),b:()=>F(n,F(r,Ne(s,e)))}}},{kernelName:US,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>F(n,F(xe(e,"float32"),2))}}},{kernelName:Zf,gradFunc:n=>({x:()=>Et(n)})},{kernelName:qf,inputsToSave:["a","b"],gradFunc:(n,t)=>{const[e,s]=t,r=nt(e.shape,s.shape);return{a:()=>{let a=n;const l=ss(e.shape,r);return l.length>0&&(a=Re(a,l)),O(a,e.shape)},b:()=>{let a=n;const l=ss(s.shape,r);return l.length>0&&(a=Re(a,l)),O(dn(a),s.shape)}}}},{kernelName:ub,inputsToSave:["x"],gradFunc:(n,t,e)=>{const[s]=t,r=s.shape.slice(),{axis:i}=e;mt(i,s.shape).forEach(u=>{r[u]=1});const a=O(n,r),l=F(a,qr(s.shape,"float32"));return{x:()=>l}}},{kernelName:Kf,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>Pe(n,en(Fb(e)))}}},{kernelName:Xf,outputsToSave:[!0],gradFunc:(n,t)=>{const[e]=t;return{x:()=>F(Ne(ze(1),en(e)),n)}}},{kernelName:Yf,inputsToSave:["x"],gradFunc:(n,t,e)=>{const[s]=t,{reps:r}=e;return{x:()=>{let o=Et(s);if(1===s.rank)for(let a=0;a<r[0];++a)o=le(o,Dt(n,[a*s.shape[0]],[s.shape[0]]));else if(2===s.rank)for(let a=0;a<r[0];++a)for(let l=0;l<r[1];++l)o=le(o,Dt(n,[a*s.shape[0],l*s.shape[1]],[s.shape[0],s.shape[1]]));else if(3===s.rank)for(let a=0;a<r[0];++a)for(let l=0;l<r[1];++l)for(let u=0;u<r[2];++u)o=le(o,Dt(n,[a*s.shape[0],l*s.shape[1],u*s.shape[2]],[s.shape[0],s.shape[1],s.shape[2]]));else{if(4!==s.rank)throw new Error(`Gradient for tile operation is not implemented for rank-${s.rank} tensors yet.`);for(let a=0;a<r[0];++a)for(let l=0;l<r[1];++l)for(let u=0;u<r[2];++u)for(let c=0;c<r[3];++c)o=le(o,Dt(n,[a*s.shape[0],l*s.shape[1],u*s.shape[2],c*s.shape[3]],[s.shape[0],s.shape[1],s.shape[2],s.shape[3]]))}return o}}}},{kernelName:Uc,gradFunc:(n,t,e)=>{const s=e,{perm:r}=s,i=Qa(r);return{x:()=>Tt(n,i)}}},{kernelName:pb,gradFunc:(n,t,e)=>{const s=e,{axis:r}=s;return{value:()=>Xr(n,r)}}},{kernelName:mb,inputsToSave:["segmentIds"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>function Oce(n,t){const e=oa(t,Et(t)),s=hp(n,e);let r=Ja(t,ze(0,"int32"));const i=s.rank-r.rank;for(let a=0;a<i;++a)r=ar(r,a+1);r=wo(r,qr(s.shape,"bool"));const o=Et(s);return zs(r,s,o)}(n,e)}}},{kernelName:gb,gradFunc:n=>({x:()=>Et(n)})}];for(const n of Pce)jee(n);Y().prototype.abs=function(){return this.throwIfDisposed(),ns(this)},Y().prototype.acos=function(){return this.throwIfDisposed(),WP(this)},Y().prototype.acosh=function(){return this.throwIfDisposed(),GP(this)},Y().prototype.add=function(n){return this.throwIfDisposed(),le(this,n)},Y().prototype.all=function(n,t){return this.throwIfDisposed(),OI(this,n,t)},Y().prototype.any=function(n,t){return this.throwIfDisposed(),Ab(this,n,t)},Y().prototype.argMax=function(n){return this.throwIfDisposed(),Qc(this,n)},Y().prototype.argMin=function(n){return this.throwIfDisposed(),HP(this,n)},Y().prototype.asScalar=function(){return this.throwIfDisposed(),S(1===this.size,()=>"The array must have only 1 element."),O(this,[])},Y().prototype.asType=function(n){return this.throwIfDisposed(),xe(this,n)},Y().prototype.as1D=function(){return this.throwIfDisposed(),O(this,[this.size])},Y().prototype.as2D=function(n,t){return this.throwIfDisposed(),O(this,[n,t])},Y().prototype.as3D=function(n,t,e){return this.throwIfDisposed(),O(this,[n,t,e])},Y().prototype.as4D=function(n,t,e,s){return this.throwIfDisposed(),O(this,[n,t,e,s])},Y().prototype.as5D=function(n,t,e,s,r){return this.throwIfDisposed(),O(this,[n,t,e,s,r])},Y().prototype.asin=function(){return this.throwIfDisposed(),jP(this)},Y().prototype.asinh=function(){return this.throwIfDisposed(),qP(this)},Y().prototype.atan=function(){return this.throwIfDisposed(),KP(this)},Y().prototype.atan2=function(n){return this.throwIfDisposed(),XP(this,n)},Y().prototype.atanh=function(){return this.throwIfDisposed(),YP(this)},Y().prototype.avgPool=function(n,t,e,s){return this.throwIfDisposed(),Rb(this,n,t,e,s)},Y().prototype.batchToSpaceND=function(n,t){return this.throwIfDisposed(),Mb(this,n,t)},Y().prototype.batchNorm=function(n,t,e,s,r){return this.throwIfDisposed(),op(this,n,t,e,s,r)},Y().prototype.broadcastTo=function(n){return this.throwIfDisposed(),td(this,n)},Y().prototype.cast=function(n){return this.throwIfDisposed(),xe(this,n)},Y().prototype.ceil=function(){return this.throwIfDisposed(),nL(this)},Y().prototype.clipByValue=function(n,t){return this.throwIfDisposed(),Er(this,n,t)},Y().prototype.concat=function(n,t){return this.throwIfDisposed(),n instanceof pn&&(n=[n]),jn([this,...n],t)},Y().prototype.conv1d=function(n,t,e,s,r,i){return this.throwIfDisposed(),LI(this,n,t,e,s,r,i)},Y().prototype.conv2dTranspose=function(n,t,e,s,r){return this.throwIfDisposed(),BI(this,n,t,e,s,r)},Y().prototype.conv2d=function(n,t,e,s,r,i){return this.throwIfDisposed(),Za(this,n,t,e,s,r,i)},Y().prototype.cos=function(){return this.throwIfDisposed(),Fb(this)},Y().prototype.cosh=function(){return this.throwIfDisposed(),zI(this)},Y().prototype.cumprod=function(n,t,e){return this.throwIfDisposed(),Ob(this,n,t,e)},Y().prototype.cumsum=function(n,t,e){return this.throwIfDisposed(),UI(this,n,t,e)},Y().prototype.depthToSpace=function(n,t){return this.throwIfDisposed(),cL(this,n,t)},Y().prototype.depthwiseConv2d=function(n,t,e,s,r,i){return this.throwIfDisposed(),ap(this,n,t,e,s,r,i)},Y().prototype.dilation2d=function(n,t,e,s,r){return this.throwIfDisposed(),dL(this,n,t,e,s,r)},Y().prototype.divNoNan=function(n){return this.throwIfDisposed(),hL(this,n)},Y().prototype.div=function(n){return this.throwIfDisposed(),Pe(this,n)},Y().prototype.dot=function(n){return this.throwIfDisposed(),fL(this,n)},Y().prototype.elu=function(){return this.throwIfDisposed(),lp(this)},Y().prototype.equal=function(n){return this.throwIfDisposed(),Wi(this,n)},Y().prototype.erf=function(){return this.throwIfDisposed(),pL(this)},Y().prototype.euclideanNorm=function(n,t){return this.throwIfDisposed(),yL(this,n,t)},Y().prototype.exp=function(){return this.throwIfDisposed(),Hr(this)},Y().prototype.expandDims=function(n){return this.throwIfDisposed(),ar(this,n)},Y().prototype.expm1=function(){return this.throwIfDisposed(),bL(this)},Y().prototype.fft=function(){return this.throwIfDisposed(),Xb(this)},Y().prototype.flatten=function(){return this.throwIfDisposed(),O(this,[this.size])},Y().prototype.floor=function(){return this.throwIfDisposed(),dp(this)},Y().prototype.floorDiv=function(n){return this.throwIfDisposed(),wI(this,n)},Y().prototype.gather=function(n,t,e){return this.throwIfDisposed(),hp(this,n,t,e)},Y().prototype.greaterEqual=function(n){return this.throwIfDisposed(),Ja(this,n)},Y().prototype.greater=function(n){return this.throwIfDisposed(),Dr(this,n)},Y().prototype.ifft=function(){return this.throwIfDisposed(),gp(this)},Y().prototype.irfft=function(){return this.throwIfDisposed(),uE(this)},Y().prototype.isFinite=function(){return this.throwIfDisposed(),vL(this)},Y().prototype.isInf=function(){return this.throwIfDisposed(),_L(this)},Y().prototype.isNaN=function(){return this.throwIfDisposed(),wL(this)},Y().prototype.leakyRelu=function(n){return this.throwIfDisposed(),Pb(this,n)},Y().prototype.lessEqual=function(n){return this.throwIfDisposed(),iu(this,n)},Y().prototype.less=function(n){return this.throwIfDisposed(),fp(this,n)},Y().prototype.localResponseNormalization=function(n,t,e,s){return this.throwIfDisposed(),xL(this,n,t,e,s)},Y().prototype.logSigmoid=function(){return this.throwIfDisposed(),CL(this)},Y().prototype.logSoftmax=function(n){return this.throwIfDisposed(),jI(this,n)},Y().prototype.logSumExp=function(n,t){return this.throwIfDisposed(),qI(this,n,t)},Y().prototype.log=function(){return this.throwIfDisposed(),jr(this)},Y().prototype.log1p=function(){return this.throwIfDisposed(),Lb(this)},Y().prototype.logicalAnd=function(n){return this.throwIfDisposed(),wo(this,n)},Y().prototype.logicalNot=function(){return this.throwIfDisposed(),Vb(this)},Y().prototype.logicalOr=function(n){return this.throwIfDisposed(),KI(this,n)},Y().prototype.logicalXor=function(n){return this.throwIfDisposed(),SL(this,n)},Y().prototype.matMul=function(n,t,e){return this.throwIfDisposed(),bt(this,n,t,e)},Y().prototype.maxPool=function(n,t,e,s){return this.throwIfDisposed(),zb(this,n,t,e,s)},Y().prototype.max=function(n,t){return this.throwIfDisposed(),mi(this,n,t)},Y().prototype.maximum=function(n){return this.throwIfDisposed(),oa(this,n)},Y().prototype.mean=function(n,t){return this.throwIfDisposed(),Nn(this,n,t)},Y().prototype.min=function(n,t){return this.throwIfDisposed(),up(this,n,t)},Y().prototype.minimum=function(n){return this.throwIfDisposed(),ou(this,n)},Y().prototype.mirrorPad=function(n,t){return this.throwIfDisposed(),EL(this,n,t)},Y().prototype.mod=function(n){return this.throwIfDisposed(),DL(this,n)},Y().prototype.mul=function(n){return this.throwIfDisposed(),F(this,n)},Y().prototype.neg=function(){return this.throwIfDisposed(),dn(this)},Y().prototype.norm=function(n,t,e){return this.throwIfDisposed(),cp(this,n,t,e)},Y().prototype.notEqual=function(n){return this.throwIfDisposed(),sd(this,n)},Y().prototype.oneHot=function(n,t=1,e=0){return this.throwIfDisposed(),YI(this,n,t,e)},Y().prototype.onesLike=function(){return this.throwIfDisposed(),Kr(this)},Y().prototype.pad=function(n,t){return this.throwIfDisposed(),el(this,n,t)},Y().prototype.pool=function(n,t,e,s,r,i){return this.throwIfDisposed(),TL(this,n,t,e,s,r,i)},Y().prototype.pow=function(n){return this.throwIfDisposed(),Ka(this,n)},Y().prototype.prelu=function(n){return this.throwIfDisposed(),Gb(this,n)},Y().prototype.prod=function(n,t){return this.throwIfDisposed(),NL(this,n,t)},Y().prototype.reciprocal=function(){return this.throwIfDisposed(),kL(this)},Y().prototype.relu=function(){return this.throwIfDisposed(),xo(this)},Y().prototype.relu6=function(){return this.throwIfDisposed(),eE(this)},Y().prototype.reshapeAs=function(n){return this.throwIfDisposed(),O(this,n.shape)},Y().prototype.reshape=function(n){return this.throwIfDisposed(),O(this,n)},Y().prototype.resizeBilinear=function(n,t,e){return this.throwIfDisposed(),qL(this,n,t,e)},Y().prototype.resizeNearestNeighbor=function(n,t,e){return this.throwIfDisposed(),KL(this,n,t,e)},Y().prototype.reverse=function(n){return this.throwIfDisposed(),yi(this,n)},Y().prototype.rfft=function(){return this.throwIfDisposed(),Yb(this)},Y().prototype.round=function(){return this.throwIfDisposed(),tE(this)},Y().prototype.rsqrt=function(){return this.throwIfDisposed(),nE(this)},Y().prototype.selu=function(){return this.throwIfDisposed(),sE(this)},Y().prototype.separableConv2d=function(n,t,e,s,r,i){return this.throwIfDisposed(),rE(this,n,t,e,s,r,i)},Y().prototype.sigmoid=function(){return this.throwIfDisposed(),_o(this)},Y().prototype.sign=function(){return this.throwIfDisposed(),AL(this)},Y().prototype.sin=function(){return this.throwIfDisposed(),oE(this)},Y().prototype.sinh=function(){return this.throwIfDisposed(),aE(this)},Y().prototype.slice=function(n,t){return this.throwIfDisposed(),Dt(this,n,t)},Y().prototype.softmax=function(n){return this.throwIfDisposed(),Kb(this,n)},Y().prototype.softplus=function(){return this.throwIfDisposed(),nd(this)},Y().prototype.spaceToBatchND=function(n,t){return this.throwIfDisposed(),Wb(this,n,t)},Y().prototype.split=function(n,t){return this.throwIfDisposed(),Tr(this,n,t)},Y().prototype.sqrt=function(){return this.throwIfDisposed(),Bs(this)},Y().prototype.square=function(){return this.throwIfDisposed(),en(this)},Y().prototype.squaredDifference=function(n){return this.throwIfDisposed(),cE(this,n)},Y().prototype.squeeze=function(n){return this.throwIfDisposed(),lu(this,n)},Y().prototype.stack=function(n,t){this.throwIfDisposed();const e=n instanceof pn?[this,n]:[this,...n];return Xr(e,t)},Y().prototype.step=function(n){return this.throwIfDisposed(),id(this,n)},Y().prototype.stridedSlice=function(n,t,e,s,r,i,o,a){return this.throwIfDisposed(),RL(this,n,t,e,s,r,i,o,a)},Y().prototype.sub=function(n){return this.throwIfDisposed(),Ne(this,n)},Y().prototype.sum=function(n,t){return this.throwIfDisposed(),Re(this,n,t)},Y().prototype.tan=function(){return this.throwIfDisposed(),ML(this)},Y().prototype.tanh=function(){return this.throwIfDisposed(),ed(this)},Y().prototype.tile=function(n){return this.throwIfDisposed(),gi(this,n)},Y().prototype.toBool=function(){return this.throwIfDisposed(),xe(this,"bool")},Y().prototype.toFloat=function(){return this.throwIfDisposed(),xe(this,"float32")},Y().prototype.toInt=function(){return this.throwIfDisposed(),xe(this,"int32")},Y().prototype.topk=function(n,t){return this.throwIfDisposed(),OL(this,n,t)},Y().prototype.transpose=function(n){return this.throwIfDisposed(),Tt(this,n)},Y().prototype.unique=function(n){return this.throwIfDisposed(),$L(this,n)},Y().prototype.unsortedSegmentSum=function(n,t){return this.throwIfDisposed(),fE(this,n,t)},Y().prototype.unstack=function(n){return this.throwIfDisposed(),bi(this,n)},Y().prototype.where=function(n,t){return this.throwIfDisposed(),zs(n,this,t)},Y().prototype.zerosLike=function(){return this.throwIfDisposed(),Et(this)};class Io extends Error{constructor(t){super(t),Object.setPrototypeOf(this,Io.prototype)}}class vi extends Error{constructor(t){super(t),Object.setPrototypeOf(this,vi.prototype)}}class $ extends Error{constructor(t){super(t),Object.setPrototypeOf(this,$.prototype)}}class ot extends Error{constructor(t){super(t),Object.setPrototypeOf(this,ot.prototype)}}class YE extends Error{constructor(t){super(t),Object.setPrototypeOf(this,YE.prototype)}}class RV extends Error{constructor(t){super(t),Object.setPrototypeOf(this,RV.prototype)}}class MV{constructor(t){this.maxEntries=t||100,this.cache=new Map}get(t){let e;return this.cache.has(t)&&(e=this.cache.get(t),this.cache.delete(t),this.cache.set(t,e)),e}put(t,e){if(this.cache.has(t))this.cache.delete(t);else if(this.cache.size>=this.maxEntries){const s=this.cache.keys().next().value;this.cache.delete(s)}this.cache.set(t,e)}getMaxEntries(){return this.maxEntries}setMaxEntries(t){if(t<0)throw new Error(`The maxEntries of LRU caches must be at least 0, but got ${t}.`);if(this.maxEntries>t)for(let e=0;e<this.maxEntries-t;e++){const s=this.cache.keys().next().value;this.cache.delete(s)}this.maxEntries=t}}function cu(n,t){if(Array.isArray(n)){let e=[];for(let s=0;s<t;s++)e=e.concat(n);return e}{const e=new Array(t);return e.fill(n),e}}function Yr(n,t){if(!n)throw new YE(t)}function FV(n,t){let e=0;for(const s of n)s===t&&e++;return e}function ur(n){return 1===n.length?n[0]:n}function sn(n){return Array.isArray(n)?n:[n]}function ha(n){const e=n.replace(/(.)([A-Z][a-z0-9]+)/g,"$1_$2").replace(/([a-z])([A-Z])/g,"$1_$2").toLowerCase();return"_"!==e[0]?e:"private"+e}function du(n){return n.length<=1||-1===n.indexOf("_")?n:n.replace(/[_]+(\w|$)/g,(t,e)=>e.toUpperCase())}let _i={};function ZE(n){if(null==n)return null;const t={};return t.className=n.getClassName(),t.config=n.getConfig(),t}function QE(n){if(null!=n&&"object"==typeof n)if(Array.isArray(n))n.forEach(t=>QE(t));else{const t=Object.keys(n);for(const e of t){const s=n[e];null!=s&&"object"==typeof s&&(Array.isArray(s)||"ndarray"!==s.type||"number"!=typeof s.value?QE(s):n[e]=s.value)}}}function _p(n,t={},e={},s="object",r=!1){if("string"==typeof n){let o;if(n in e)o=e[n];else if(n in _i)o=_i[n];else if(o=t[n],null==o)throw new $(`Unknown ${s}: ${n}. This may be due to one of the following reasons:\n1. The ${s} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.\n2. The custom ${s} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);return o}{const i=n;if(null==i.className||null==i.config)throw new $(`${s}: Improper config format: ${JSON.stringify(i)}.\n'className' and 'config' must set.`);const o=i.className;let a,l;if(o in e?[a,l]=e[o]:o in _i?[a,l]=_i.className:o in t&&([a,l]=t[o]),null==a)throw new $(`Unknown ${s}: ${o}. This may be due to one of the following reasons:\n1. The ${s} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.\n2. The custom ${s} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);if(null!=l){const u={};for(const f of Object.keys(_i))u[f]=_i[f];for(const f of Object.keys(e))u[f]=e[f];i.config.customObjects=u;const d=Object.assign({},_i);for(const f of Object.keys(e))_i[f]=e[f];QE(i.config);const h=l(a,i.config,e,r);return _i=Object.assign({},d),h}{const u=Object.assign({},_i);for(const d of Object.keys(e))_i[d]=e[d];const c=new a(i.config);return _i=Object.assign({},u),c}}}function rv(n,t){return-1*function Lce(n,t){return n<t?-1:n>t?1:0}(n,t)}function tl(n){if(null==n)return n;const t=[];for(const e of n)-1===t.indexOf(e)&&t.push(e);return t}function Vce(n){if(null==n)throw new $(`Invalid value in obj: ${JSON.stringify(n)}`);for(const t in n)if(n.hasOwnProperty(t))return!1;return!0}function hu(n,t,e){if(null!=e&&n.indexOf(e)<0)throw new $(`${e} is not a valid ${t}.  Valid values are ${n} or null/undefined.`)}function JE(n,t,e=0,s=1/0){return Yr(e>=0),Yr(s>=e),Array.isArray(n)&&n.length>=e&&n.length<=s&&n.every(r=>typeof r===t)}function xs(n,t){Array.isArray(n)?(S(n.length>0,()=>`${t} is unexpectedly an empty array.`),n.forEach((e,s)=>xs(e,`element ${s+1} of ${t}`))):S(Number.isInteger(n)&&n>0,()=>`Expected ${t} to be a positive integer, but got ${OV(n)}.`)}function OV(n){return null===n?"null":Array.isArray(n)?"["+n.map(t=>OV(t)).join(",")+"]":"string"==typeof n?`"${n}"`:`${n}`}function $V(n){return"relu"===n?"relu":"linear"===n?"linear":"elu"===n?"elu":null}let zce=0;function PV(){return zce++}const iv={};function ov(n=""){return n in iv||(iv[n]=0),iv[n]+=1,n+iv[n].toString()}const Uce=["channelsFirst","channelsLast"],Wce=["nearest","bilinear"],Gce=["valid","same","causal"],Hce=["max","avg"],jce=["sum","mul","concat","ave"],ud=new Map;function Pn(n){hu(Uce,"DataFormat",n)}function Zr(n){hu(Gce,"PaddingMode",n)}function LV(n){hu(Hce,"PoolMode",n)}const wp=[];function fu(n,t){wp.push(n);try{const e=t();return wp.pop(),e}catch(e){throw wp.pop(),e}}function BV(n){if(!UV(n))throw new Error("Not a valid tensor name: '"+n+"'");return function Kce(){return 0===wp.length?"":wp.join("/")+"/"}()+n}function zV(n){if(!UV(n))throw new Error("Not a valid tensor name: '"+n+"'");ud.has(n)||ud.set(n,0);const t=ud.get(n);if(ud.set(n,ud.get(n)+1),t>0){const e=`${n}_${t}`;return ud.set(e,1),e}return n}const Xce=new RegExp(/^[A-Za-z0-9][-A-Za-z0-9\._\/]*$/);function UV(n){return!!n.match(Xce)}function Yce(n){return n===parseInt(n.toString(),10)}function nl(n,t,e){null==t&&(t=0),null==e&&(e=n.length);let s=1;for(let r=t;r<e;++r)s*=n[r];return s}function cd(n){if(0===n.length)return Number.NaN;let t=Number.POSITIVE_INFINITY;for(let e=0;e<n.length;e++){const s=n[e];s<t&&(t=s)}return t}function sl(n){if(0===n.length)return Number.NaN;let t=Number.NEGATIVE_INFINITY;for(let e=0;e<n.length;e++){const s=n[e];s>t&&(t=s)}return t}function Gi(n,t){if(t<n)throw new $(`end (${t}) < begin (${n}) is forbidden.`);const e=[];for(let s=n;s<t;++s)e.push(s);return e}let av;function is(){return null==av&&(av=function Kte(){return M.backend}().epsilon()),av}function Eo(n,t){return xe(n,t)}function xp(n,t=-1){const e=n.shape.slice();return t<0&&(t=e.length+t+1),e.splice(t,0,1),O(n,e)}function pu(n,t,e){return z(()=>{switch(n.rank){case 1:return jb(n,t,e);case 2:return lE(n,[t,0],[e,n.shape[1]]);case 3:return qb(n,[t,0,0],[e,n.shape[1],n.shape[2]]);case 4:return mp(n,[t,0,0,0],[e,n.shape[1],n.shape[2],n.shape[3]]);case 5:return Dt(n,[t,0,0,0,0],[e,n.shape[1],n.shape[2],n.shape[3],n.shape[4]]);case 6:return Dt(n,[t,0,0,0,0,0],[e,n.shape[1],n.shape[2],n.shape[3],n.shape[4],n.shape[5]]);default:throw new $(`sliceAlongFirstAxis() received an unsupported tensor rank: ${n.rank}`)}})}function eD(n,t,e){return z(()=>{switch(n.rank){case 1:return jb(n,t,e);case 2:return lE(n,[0,t],[n.shape[0],e]);case 3:return qb(n,[0,0,t],[n.shape[0],n.shape[1],e]);case 4:return mp(n,[0,0,0,t],[n.shape[0],n.shape[1],n.shape[2],e]);default:throw new $(`sliceAlongLastAxis() received an unsupported tensor rank: ${n.rank}`)}})}function lv(n,t,e,s){return z(()=>{switch(n.rank){case 1:return jb(n,t,e);case 2:switch(s){case 1:return pu(n,t,e);case 2:return eD(n,t,e);default:throw new $(`The axis is not within the rank of the tensor ${s}`)}case 3:switch(s){case 1:return pu(n,t,e);case 2:return qb(n,[0,t,0],[n.shape[0],e,n.shape[2]]);case 3:return eD(n,t,e);default:throw new $(`The axis is not within the rank of the tensor ${s}`)}case 4:switch(s){case 1:return pu(n,t,e);case 2:return mp(n,[0,t,0,0],[n.shape[0],e,n.shape[2],n.shape[3]]);case 3:return mp(n,[0,0,t,0],[n.shape[0],n.shape[1],e,n.shape[3]]);case 4:return eD(n,t,e);default:throw new $(`The axis is not within the rank of the tensor ${s}`)}default:throw new $(`sliceAlongLastAxis() received an unsupported tensor rank: ${n.rank}`)}})}function tD(n,t=-1){let e;return t<0&&(e=n[0].rank,t=0!==e?e:0),t===n[0].rank&&(t=-1),jn(n,t)}function GV(n,t){switch(n.rank){case 1:return sL([n,t]);case 2:return rL([n,t],0);case 3:return iL([n,t],0);case 4:return oL([n,t],0);default:throw new $(`concatAlongFirstAxis() received an unsupported tensor rank: ${n.rank}`)}}function nD(n,t){if(Array.isArray(t)||(t=[t]),n.rank!==t.length)throw new $(`The length of input n (${t.length}) does not match the number of dimensions in input x (${n.rank})`);return gi(n,t)}function uv(n,t=0,e=1,s,r){return JI(n,t,e,s,r)}function Do(n,t,e,s){if(n.rank<2||t.rank<2)throw new ot(`dot requires both inputs to be rank >= 2 but got x shape = ${n.shape} and y shape = ${t.shape}`);if(t.rank>=3&&n.shape.slice(-1)[0]!==t.shape.slice(-2)[0])throw new ot(`If rank y >= 3, then the second last dim of y must equal the last dim of x but got x shape = ${n.shape} and  y shape = ${t.shape}`);if(2===n.rank&&2===t.rank)return _E({a:n,b:t,transposeA:!1,transposeB:!1,bias:s?sD(n.rank,s,"channelsLast"):null,activation:e});{const r=n.shape.slice(),i=r.pop();n=O(n,[-1,i]);const o=t.shape.slice(),a=o.pop(),l=o.pop(),u=[...o,a],c=Array.from({length:t.rank},(p,g)=>0===g?t.rank-2:g<=t.rank-2?g-1:g);t=O(Tt(t,c),[l,-1]);const d=[...r,...u];return O(_E({a:n,b:t,transposeA:!1,transposeB:!1,bias:s?sD(n.rank,s,"channelsLast"):null,activation:e}),d)}}function HV(n,t,e){return z(()=>(t=Array.isArray(t)?lr(t,"int32"):xe(t,"int32"),hp(n,t,e)))}function Cp(n){return F(n,n)}function sD(n,t,e){const s=t.shape;if(1!==t.rank&&t.rank!==n)throw new $(`Unexpected bias dimensions: ${t.rank}; expected it to be 1 or ${n}`);if(5===n){if("channelsFirst"===e)return O(t,1===s.length?[1,s[0],1,1,1]:[1,s[3],s[0],s[1],s[2]]);if("channelsLast"===e)return O(t,1===s.length?[1,1,1,1,s[0]]:[1].concat(s))}else if(4===n){if("channelsFirst"===e)return O(t,1===s.length?[1,s[0],1,1]:[1,s[2],s[0],s[1]]);if("channelsLast"===e)return O(t,1===s.length?[1,1,1,s[0]]:[1].concat(s))}else if(3===n){if("channelsFirst"===e)return O(t,1===s.length?[1,s[0],1]:[1,s[1],s[0]]);if("channelsLast"===e)return O(t,1===s.length?[1,1,s[0]]:[1].concat(s))}else if(n<3)return t;throw new $(`Unsupported input rank by biasAdd: ${t.rank}`)}function ji(n,t,e){return z(()=>(null==e&&(e="channelsLast"),Pn(e),le(n,sD(n.rank,t,e))))}function jV(n,t,e,s){return z(()=>VL(n,t,e,s))}function Sp(n,t,e=!1){return e?n():t()}const ide=["fanIn","fanOut","fanAvg"],ode=["normal","uniform","truncatedNormal"];class wi extends Xc{fromConfigUsesCustomObjects(){return!1}getConfig(){return{}}}ue((()=>{class n extends wi{apply(e,s){return rs(e,s)}}return n.className="Zeros",n})());let qV=(()=>{class n extends wi{apply(e,s){return qr(e,s)}}return n.className="Ones",n})();ue(qV),ue((()=>{class n extends wi{constructor(e){if(super(),"object"!=typeof e)throw new $(`Expected argument of type ConstantConfig but got ${e}`);if(void 0===e.value)throw new $(`config must have value set but got ${e}`);this.value=e.value}apply(e,s){return z(()=>F(ze(this.value),qr(e,s)))}getConfig(){return{value:this.value}}}return n.className="Constant",n})()),ue((()=>{class n extends wi{constructor(e){super(),this.DEFAULT_MINVAL=-.05,this.DEFAULT_MAXVAL=.05,this.minval=e.minval||this.DEFAULT_MINVAL,this.maxval=e.maxval||this.DEFAULT_MAXVAL,this.seed=e.seed}apply(e,s){return au(e,this.minval,this.maxval,s,this.seed)}getConfig(){return{minval:this.minval,maxval:this.maxval,seed:this.seed}}}return n.className="RandomUniform",n})()),ue((()=>{class n extends wi{constructor(e){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,s){if("float32"!==(s=s||"float32")&&"int32"!==s)throw new ot(`randomNormal does not support dType ${s}.`);return uv(e,this.mean,this.stddev,s,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}return n.className="RandomNormal",n})()),ue((()=>{class n extends wi{constructor(e){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,s){if("float32"!==(s=s||"float32")&&"int32"!==s)throw new ot(`truncatedNormal does not support dType ${s}.`);return hE(e,this.mean,this.stddev,s,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}return n.className="TruncatedNormal",n})()),ue((()=>{class n extends wi{constructor(e){super(),this.gain=null!=e.gain?e.gain:1}apply(e,s){return z(()=>{if(2!==e.length||e[0]!==e[1])throw new $("Identity matrix initializer can only be used for 2D square matrices.");return F(this.gain,HI(e[0]))})}getConfig(){return{gain:this.gain}}}return n.className="Identity",n})());let Qr=(()=>{class n extends wi{constructor(e){if(super(),e.scale<0)throw new $(`scale must be a positive float. Got: ${e.scale}`);this.scale=null==e.scale?1:e.scale,this.mode=null==e.mode?"fanIn":e.mode,function ade(n){hu(ide,"FanMode",n)}(this.mode),this.distribution=null==e.distribution?"normal":e.distribution,function lde(n){hu(ode,"Distribution",n)}(this.distribution),this.seed=e.seed}apply(e,s){const r=function ude(n,t="channelsLast"){let e,s;if(Pn(t),2===n.length)e=n[0],s=n[1];else if(-1!==[3,4,5].indexOf(n.length)){if("channelsFirst"===t){const r=nl(n,2);e=n[1]*r,s=n[0]*r}else if("channelsLast"===t){const r=nl(n,0,n.length-2);e=n[n.length-2]*r,s=n[n.length-1]*r}}else{const r=nl(n);e=Math.sqrt(r),s=Math.sqrt(r)}return[e,s]}(e),i=r[0],o=r[1];let a=this.scale;if(a/="fanIn"===this.mode?Math.max(1,i):"fanOut"===this.mode?Math.max(1,o):Math.max(1,(i+o)/2),"normal"===this.distribution){const l=Math.sqrt(a);if("float32"!==(s=s||"float32")&&"int32"!==s)throw new ot(`${this.getClassName()} does not support dType ${s}.`);return hE(e,0,l,s,this.seed)}{const l=Math.sqrt(3*a);return au(e,-l,l,s,this.seed)}}getConfig(){return{scale:this.scale,mode:this.mode,distribution:this.distribution,seed:this.seed}}}return n.className="VarianceScaling",n})();ue(Qr);let KV=(()=>{class n extends Qr{constructor(e){super({scale:1,mode:"fanAvg",distribution:"uniform",seed:null==e?null:e.seed})}getClassName(){return Qr.className}}return n.className="GlorotUniform",n})();ue(KV);let XV=(()=>{class n extends Qr{constructor(e){super({scale:1,mode:"fanAvg",distribution:"normal",seed:null==e?null:e.seed})}getClassName(){return Qr.className}}return n.className="GlorotNormal",n})();ue(XV);let YV=(()=>{class n extends Qr{constructor(e){super({scale:2,mode:"fanIn",distribution:"normal",seed:null==e?null:e.seed})}getClassName(){return Qr.className}}return n.className="HeNormal",n})();ue(YV);let ZV=(()=>{class n extends Qr{constructor(e){super({scale:2,mode:"fanIn",distribution:"uniform",seed:null==e?null:e.seed})}getClassName(){return Qr.className}}return n.className="HeUniform",n})();ue(ZV);let QV=(()=>{class n extends Qr{constructor(e){super({scale:1,mode:"fanIn",distribution:"normal",seed:null==e?null:e.seed})}getClassName(){return Qr.className}}return n.className="LeCunNormal",n})();ue(QV);let JV=(()=>{class n extends Qr{constructor(e){super({scale:1,mode:"fanIn",distribution:"uniform",seed:null==e?null:e.seed})}getClassName(){return Qr.className}}return n.className="LeCunUniform",n})();ue(JV),ue((()=>{class n extends wi{constructor(e){super(),this.DEFAULT_GAIN=1,this.ELEMENTS_WARN_SLOW=2e3,this.gain=null==e.gain?this.DEFAULT_GAIN:e.gain,this.seed=e.seed}apply(e,s){return z(()=>{if(e.length<2)throw new ot("Shape must be at least 2D.");if("int32"!==s&&"float32"!==s&&void 0!==s)throw new TypeError(`Unsupported data type ${s}.`);const r=X(e.slice(0,-1)),i=e[e.length-1],o=r*i;o>this.ELEMENTS_WARN_SLOW&&console.warn(`Orthogonal initializer is being called on a matrix with more than ${this.ELEMENTS_WARN_SLOW} (${o}) elements: Slowness may result.`);const l=uv([Math.max(i,r),Math.min(i,r)],0,1,s,this.seed),u=YL.qr(l,!1);let c=u[0];const h=u[1].flatten().stridedSlice([0],[Math.min(i,r)*Math.min(i,r)],[Math.min(i,r)+1]);return c=F(c,h.sign()),r<i&&(c=c.transpose()),F(ze(this.gain),c.reshape(e))})}getConfig(){return{gain:this.gain,seed:this.seed}}}return n.className="Orthogonal",n})());const eB={constant:"Constant",glorotNormal:"GlorotNormal",glorotUniform:"GlorotUniform",heNormal:"HeNormal",heUniform:"HeUniform",identity:"Identity",leCunNormal:"LeCunNormal",leCunUniform:"LeCunUniform",ones:"Ones",orthogonal:"Orthogonal",randomNormal:"RandomNormal",randomUniform:"RandomUniform",truncatedNormal:"TruncatedNormal",varianceScaling:"VarianceScaling",zeros:"Zeros"};function tB(n,t={}){return _p(n,fi.getMap().classNameMap,t,"initializer")}function xn(n){return ZE(n)}function mn(n){if("string"==typeof n){const t=n in eB?eB[n]:n;if("GlorotNormal"===t)return new XV;if("GlorotUniform"===t)return new KV;if("HeNormal"===t)return new YV;if("HeUniform"===t)return new ZV;if("LeCunNormal"===t)return new QV;if("LeCunUniform"===t)return new JV;{const e={};return e.className=t,e.config={},tB(e)}}return n instanceof wi?n:tB(n)}function rD(n){return Array.isArray(n)&&Array.isArray(n[0])}function cv(n){return 0===n.length?[]:Array.isArray(n[0])?n:[n]}function Ke(n){let t;if(Array.isArray(n)){if(1!==n.length)throw new $(`Expected Tensor length to be 1; got ${n.length}`);t=n[0]}else t=n;return t}function Mt(n){if(Array.isArray(n)&&Array.isArray(n[0])){if(1===n.length)return n[0];throw new $(`Expected exactly 1 Shape; got ${n.length}`)}return n}function dv(n){let t=0;for(const e of n)t+=0===e.shape.length?1:e.shape.reduce((s,r)=>s*r);return t}const nB="Variable";class To{constructor(t,e="float32",s=nB,r=!0,i=null){this.dtype=e??"float32",this.shape=t.shape,this.id=PV(),this.originalName=BV(s=s??nB),this.name=zV(this.originalName),this.trainable_=r,this.constraint=i,this.val=PL(t,this.trainable_,this.name,this.dtype)}read(){return this.assertNotDisposed(),this.val}write(t){return this.assertNotDisposed(),function cde(n,t){if(n.shape.toString()!==t.shape.toString())throw new Error("Shape mismatch: "+JSON.stringify(n.shape)+" vs. "+JSON.stringify(t.shape))}(this.val,t),this.val.id!==t.id&&(this.val.assign(t),null!=this.constraint&&this.val.assign(this.constraint.apply(this.val))),this}dispose(){this.assertNotDisposed(),this.val.dispose()}assertNotDisposed(){if(this.val.isDisposed)throw new Error(`LayersVariable ${this.name} is already disposed.`)}get trainable(){return this.trainable_}set trainable(t){this.trainable_=t,this.val.trainable=t}}function iD(n){return n.map(t=>t.read())}function oD(n){n.forEach(t=>{t[0].write(t[1])})}class os{constructor(t){this.dtype=t.dtype,this.shape=t.shape,this.ndim=null!=t.shape?t.shape.length:t.ndim,this.maxNDim=t.maxNDim,this.minNDim=t.minNDim,this.axes=t.axes||{}}}class No{constructor(t,e,s,r,i,o,a){this.dtype=t,this.shape=e,this.sourceLayer=s,this.inputs=r,this.callArgs=i,this.outputTensorIndex=a,this.id=PV(),null!=o&&(this.originalName=BV(o),this.name=zV(this.originalName)),this.rank=e.length}}let dde=0;class hv{constructor(t,e){this.callArgs=e,this.id=dde++,this.outboundLayer=t.outboundLayer,this.inboundLayers=t.inboundLayers,this.nodeIndices=t.nodeIndices,this.tensorIndices=t.tensorIndices,this.inputTensors=t.inputTensors,this.outputTensors=t.outputTensors,this.inputMasks=t.inputMasks,this.outputMasks=t.outputMasks,this.inputShapes=t.inputShapes,this.outputShapes=t.outputShapes;for(const s of t.inboundLayers)s?.outboundNodes.push(this);t.outboundLayer.inboundNodes.push(this)}getConfig(){const t=[];for(const e of this.inboundLayers)t.push(null!=e?e.name:null);return{outboundLayer:this.outboundLayer?this.outboundLayer.name:null,inboundLayers:t,nodeIndices:this.nodeIndices,tensorIndices:this.tensorIndices}}}let hde=0;class yt extends Xc{constructor(t={}){super(),this._callHook=null,this._addedWeightNames=[],this._stateful=!1,this.id=hde++,this.activityRegularizer=null,this.inputSpec=null,this.supportsMasking=!1,this._trainableWeights=[],this._nonTrainableWeights=[],this._losses=[],this._updates=[],this._built=!1,this.inboundNodes=[],this.outboundNodes=[];let e=t.name;if(!e){const s=this.getClassName();e=ha(s)+"_"+ov(s)}if(this.name=e,this.trainable_=null==t.trainable||t.trainable,null!=t.inputShape||null!=t.batchInputShape){let s;if(null!=t.batchInputShape)s=t.batchInputShape;else if(null!=t.inputShape){let i=null;null!=t.batchSize&&(i=t.batchSize),s=[i].concat(t.inputShape)}this.batchInputShape=s;let r=t.dtype;null==r&&(r=t.inputDType),null==r&&(r="float32"),this.dtype=r}this.initialWeights=null!=t.weights?t.weights:null,this._refCount=null,this.fastWeightInitDuringBuild=!1}static nodeKey(t,e){return t.name+"_ib-"+e.toString()}getNodeAtIndex(t,e){if(0===this.inboundNodes.length)throw new vi(`The layer has never been called and thus has no defined ${e}.`);if(this.inboundNodes.length<=t)throw new $(`Asked to get ${e} at node ${t}, but the layer has only ${this.inboundNodes.length} inbound nodes.`);return this.inboundNodes[t]}getInputAt(t){return ur(this.getNodeAtIndex(t,"input").inputTensors)}getOutputAt(t){return ur(this.getNodeAtIndex(t,"output").outputTensors)}get input(){if(this.inboundNodes.length>1)throw new Io(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer input" is ill-defined. Use \`getInputAt(nodeIndex)\` instead.`);if(0===this.inboundNodes.length)throw new Io(`Layer ${this.name} is not connected, no input to return.`);return ur(this.getNodeAtIndex(0,"input").inputTensors)}get output(){if(0===this.inboundNodes.length)throw new Io(`Layer ${this.name} has no inbound nodes.`);if(this.inboundNodes.length>1)throw new Io(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer output" is ill-defined. Use \`getOutputAt(nodeIndex)\` instead.`);return ur(this.getNodeAtIndex(0,"output").outputTensors)}get losses(){return this._losses}calculateLosses(){return this.losses.map(t=>t())}get updates(){return this._updates}get built(){return this._built}set built(t){this._built=t}get trainable(){return this.trainable_}set trainable(t){this._trainableWeights.forEach(e=>e.trainable=t),this.trainable_=t}get trainableWeights(){return this.trainable_?this._trainableWeights.filter(t=>t.trainable):[]}set trainableWeights(t){this._trainableWeights=t}get nonTrainableWeights(){return this.trainable?this._trainableWeights.filter(t=>!t.trainable).concat(this._nonTrainableWeights):this._trainableWeights.concat(this._nonTrainableWeights)}set nonTrainableWeights(t){this._nonTrainableWeights=t}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}get stateful(){return this._stateful}resetStates(){if(!this.stateful)throw new Error("Cannot call the resetStates() method of a non-stateful Layer object.")}assertInputCompatibility(t){if(t=sn(t),null==this.inputSpec||0===this.inputSpec.length)return;const e=sn(this.inputSpec);if(t.length!==e.length)throw new $(`Layer ${this.name} expects ${e.length} inputs, but it received ${t.length} input tensors. Input received: ${t}`);for(let s=0;s<t.length;s++){const r=t[s],i=e[s];if(null==i)continue;const o=r.rank;if(null!=i.ndim&&o!==i.ndim)throw new $(`Input ${s} is incompatible with layer ${this.name}: expected ndim=${i.ndim}, found ndim=${o}`);if(null!=i.maxNDim&&o>i.maxNDim)throw new $(`Input ${s} is incompatible with layer ${this.name}: expected max_ndim=${i.maxNDim}, found ndim=${o}`);if(null!=i.minNDim&&o<i.minNDim)throw new $(`Input ${s} is incompatible with layer ${this.name}: expected min_ndim=${i.minNDim}, found ndim=${o}.`);if(null!=i.dtype&&r.dtype!==i.dtype)throw new $(`Input ${s} is incompatible with layer ${this.name} : expected dtype=${i.dtype}, found dtype=${r.dtype}.`);if(i.axes){const a=r.shape;for(const l in i.axes){const u=Number(l),c=i.axes[l];if(null!=c&&-1===[c,null].indexOf(u>=0?a[u]:a[a.length+u]))throw new $(`Input ${s} is incompatible with layer ${this.name}: expected axis ${u} of input shape to have value ${c} but got shape ${a}.`)}}if(null!=i.shape)for(let a=0;a<i.shape.length;++a){const l=i.shape[a],u=r.shape[a];if(null!=l&&null!=u&&l!==u)throw new $(`Input ${s} is incompatible with layer ${this.name}: expected shape=${i.shape}, found shape=${r.shape}.`)}}}call(t,e){return t}invokeCallHook(t,e){null!=this._callHook&&this._callHook(t,e)}setCallHook(t){this._callHook=t}clearCallHook(){this._callHook=null}apply(t,e){e=e||{},this.assertNotDisposed();const s=sn(t);let r=!0;for(const o of s)if(!(o instanceof No)){r=!1;break}let i=!0;for(const o of s)if(o instanceof No){i=!1;break}if(r===i)throw new $("Arguments to apply() must be all SymbolicTensors or all Tensors");return fu(this.name,()=>{if(!this.built){this.assertInputCompatibility(t);const o=[];for(const a of sn(t))o.push(a.shape);this.build(ur(o)),this.built=!0,this.initialWeights&&this.setWeights(this.initialWeights),null===this._refCount&&i&&(this._refCount=1)}if(this.assertInputCompatibility(t),i){let o=this.call(t,e);const a=sn(o),l=[];for(let u of a)-1!==s.indexOf(u)&&(u=u.clone()),l.push(u);if(o=ur(l),null!=this.activityRegularizer)throw new ot("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return o}{const o=function fde(n){n=sn(n);const t=[];for(const e of n)t.push(e.shape);return ur(t)}(t),a=this.computeOutputShape(o);let l;const u="float32";if(this.warnOnIncompatibleInputShape(Array.isArray(t)?o[0]:o),l=null!=a&&a.length>0&&Array.isArray(a[0])?a.map((c,d)=>new No(u,c,this,sn(t),e,this.name,d)):new No(u,a,this,sn(t),e,this.name),this.addInboundNode(t,l,null,null,o,a,e),this._refCount++,null!=this.activityRegularizer)throw new ot("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return l}})}warnOnIncompatibleInputShape(t){if(null!=this.batchInputShape)if(t.length!==this.batchInputShape.length)console.warn(`The rank of the input tensor provided (shape: ${JSON.stringify(t)}) does not match that of the batchInputShape (${JSON.stringify(this.batchInputShape)}) of the layer ${this.name}`);else{let e=!1;this.batchInputShape.forEach((s,r)=>{null!=s&&null!=t[r]&&t[r]!==s&&(e=!0)}),e&&console.warn(`The shape of the input tensor (${JSON.stringify(t)}) does not match the expectation of layer ${this.name}: ${JSON.stringify(this.batchInputShape)}`)}}get outputShape(){if(null==this.inboundNodes||0===this.inboundNodes.length)throw new Io(`The layer ${this.name} has never been called and thus has no defined output shape.`);const t=[];for(const e of this.inboundNodes){const s=JSON.stringify(e.outputShapes);-1===t.indexOf(s)&&t.push(s)}if(1===t.length){const e=this.inboundNodes[0].outputShapes;return Array.isArray(e)&&Array.isArray(e[0])&&1===e.length?e[0]:e}throw new Io(`The layer ${this.name} has multiple inbound nodes with different output shapes. Hence the notion of "output shape" is ill-defined for the layer.`)}countParams(){if(!this.built)throw new vi(`You tried to call countParams() on ${this.name}, but the layer is not built yet. Build it first by calling build(batchInputShape).`);return dv(this.weights)}build(t){this.built=!0}getWeights(t=!1){return iD(t?this.trainableWeights:this.weights)}setWeights(t){z(()=>{const e=this.weights;if(e.length!==t.length)throw new $(`You called setWeights(weights) on layer "${this.name}" with a weight list of length ${t.length}, but the layer was expecting ${e.length} weights. Provided weights: ${t}...`);if(0===e.length)return;const s=[],r=iD(e);for(let i=0;i<r.length;++i){const o=r[i],a=e[i],l=t[i];if(!wt(o.shape,l.shape))throw new $(`Layer weight shape ${o.shape} not compatible with provided weight shape ${l.shape}`);s.push([a,l])}oD(s)})}addWeight(t,e,s,r,i,o,a,l){if(-1!==this._addedWeightNames.indexOf(t))throw new $(`Duplicate weight name ${t} for layer ${this.name}`);this._addedWeightNames.push(t),null==s&&(s="float32"),this.fastWeightInitDuringBuild&&(r=null!=l?l():mn("zeros"));const u=r.apply(e,s),c=new To(u,s,t,o,a);return u.dispose(),null!=i&&this.addLoss(()=>i.apply(c.read())),null==o&&(o=!0),o?this._trainableWeights.push(c):this._nonTrainableWeights.push(c),c}setFastWeightInitDuringBuild(t){this.fastWeightInitDuringBuild=t}addLoss(t){null==t||Array.isArray(t)&&0===t.length||(t=sn(t),null!=this._losses&&this.losses.push(...t))}computeOutputShape(t){return t}computeMask(t,e){if(!this.supportsMasking){if(null!=e){if(!Array.isArray(e))throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`);e.forEach(s=>{if(null!=s)throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`)})}return null}return e}addInboundNode(t,e,s,r,i,o,a=null){const l=sn(t);e=sn(e),s=sn(s),r=sn(r),i=cv(i),o=cv(o);const u=[],c=[],d=[];for(const h of l)u.push(h.sourceLayer),c.push(h.nodeIndex),d.push(h.tensorIndex);new hv({outboundLayer:this,inboundLayers:u,nodeIndices:c,tensorIndices:d,inputTensors:l,outputTensors:e,inputMasks:s,outputMasks:r,inputShapes:i,outputShapes:o},a);for(let h=0;h<e.length;h++)e[h].sourceLayer=this,e[h].nodeIndex=this.inboundNodes.length-1,e[h].tensorIndex=h}getConfig(){const t={name:this.name,trainable:this.trainable};return null!=this.batchInputShape&&(t.batchInputShape=this.batchInputShape),null!=this.dtype&&(t.dtype=this.dtype),t}disposeWeights(){return this.weights.forEach(t=>t.dispose()),this.weights.length}assertNotDisposed(){if(0===this._refCount)throw new Error(`Layer '${this.name}' is already disposed.`)}dispose(){if(!this.built)throw new Error(`Cannot dispose Layer ${this.name} because it has not been built yet.`);if(null===this._refCount)throw new Error(`Cannot dispose Layer ${this.name} because it has not been used yet.`);this.assertNotDisposed();let t=0;return 0==--this._refCount&&(t=this.disposeWeights()),{refCountAfterDispose:this._refCount,numDisposedVariables:t}}}function sB(n,t,e){if((null==t||null!=e&&e>0)&&(t=n.sourceLayer,e=n.nodeIndex),0===t.inboundNodes.length)return[n];{const s=t.inboundNodes[e];if(0===s.inboundLayers.length)return s.inputTensors;{const r=[];for(let i=0;i<s.inboundLayers.length;i++){const u=sB(s.inputTensors[i],s.inboundLayers[i],s.nodeIndices[i]);for(const c of u)-1===r.indexOf(c)&&r.push(c)}return r}}}let fv=(()=>{class n extends yt{constructor(e){if(super({dtype:e.dtype,name:null!=e.name?e.name:ov("input").toString()}),null==e.batchSize&&(e.batchSize=null),null==e.sparse&&(e.sparse=!1),this.trainable=!1,this.built=!0,this.sparse=e.sparse,null!=e.inputShape&&null!=e.batchInputShape)throw new $("Only provide the inputShape OR batchInputShape argument to inputLayer, not both at the same time.");let s=e.batchInputShape;if(null==s){if(null==e.inputShape)throw new $("An InputLayer should be passed either a `batchInputShape` or an `inputShape`.");s=[e.batchSize].concat(e.inputShape)}else if(null!=e.batchSize)throw new $("Cannot specify batchSize if batchInputShape is specified when creating an InputLayer.");const r=e.dtype||"float32";this.batchInputShape=s,this.dtype=r,this.inputSpec=[{shape:s}];const i=new No(this.dtype,this.batchInputShape,this,[],{},this.name);i.nodeIndex=0,i.tensorIndex=0,new hv({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:[i],outputTensors:[i],inputMasks:[null],outputMasks:[null],inputShapes:[s],outputShapes:[s]})}apply(e,s){throw new $(`Cannot pass any input to an InputLayer's apply() method. InputLayer name: ${this.name}`)}dispose(){return{refCountAfterDispose:this._refCount,numDisposedVariables:0}}getConfig(){return{batchInputShape:this.batchInputShape,dtype:this.dtype,sparse:this.sparse,name:this.name}}}return n.className="InputLayer",n})();ue(fv);class rl{constructor(t){if(this.id2Value={},this.id2Mask={},this.name2Id={},t instanceof rl)for(const e in t.id2Value)this.id2Value[e]=t.id2Value[e],e in t.id2Mask&&(this.id2Mask[e]=t.id2Mask[e]);else{if(null==t)return;for(const e of t)this.add(e.key,e.value)}}add(t,e,s){if(null!=this.id2Value[t.id])throw new $(`Duplicate key: name=${t.name}, id=${t.id}`);return this.id2Value[t.id]=function gde(n,t){if(null==n.dtype||n.dtype===t.dtype)return t;try{return xe(t,n.dtype)}catch{throw new $(`The dtype of the feed (${t.dtype}) can not be cast to the dtype of the key '${n.name}' (${n.dtype}).`)}}(t,e),this.name2Id[t.name]=t.id,null!=s&&(this.id2Mask[t.id]=s),this}addFeed(t){this.add(t.key,t.value)}hasKey(t){return null!=this.id2Value[t.id]}names(){return Object.keys(this.name2Id)}getValue(t){if(t instanceof No){if(null==this.id2Value[t.id])throw new $(`Nonexistent key: ${t.name}`);return this.id2Value[t.id]}{const e=this.name2Id[t];if(null==e)throw new $(`Feed dict has no SymbolicTensor name: ${t}`);return this.id2Value[e]}}getMask(t){if(t instanceof No){if(null==this.id2Value[t.id])throw new $(`Nonexistent key: ${t.name}`);return this.id2Mask[t.id]}{const e=this.name2Id[t];if(null==e)throw new $(`Feed dict has no SymbolicTensor name: ${t}`);return this.id2Mask[e]}}disposeMasks(){null!=this.id2Mask&&gt(this.id2Mask)}}const pv=new MV,mv=new MV;function Ip(n,t,e,s){const r=null!=e&&e.training,i=Array.isArray(n),o=i?n:[n],a=o.map(p=>p.name),l=[],u=t.names();for(const p of a)-1!==u.indexOf(p)?l.push(t.getValue(p)):l.push(null);null!=s&&(s.maxNumTensors=-1/0,s.minNumTensors=1/0);const c=a.join(",")+"|"+t.names().sort().join(",");let h,d=pv.get(c);if(null==d){const p=function bde(n,t){S(null!=n&&n.length>0,()=>"Expected at least one fetch, got none");let e=[],s={};if(1===n.length){const r=rB(n[0],t);e=r.sorted,s=r.recipientMap}else{const r=new Set;for(const i of n){const{sorted:o,recipientMap:a}=rB(i,t);for(const l of o)r.has(l.name)||(e.push(l),r.add(l.name));for(const l in a)null==s[l]&&(s[l]=new Set),a[l].forEach(u=>s[l].add(u))}}return{sorted:e,recipientCounts:vde(s)}}(o,t);d=p.sorted,h=p.recipientCounts,pv.put(c,d),mv.put(c,h)}h={},r||Object.assign(h,mv.get(c));const f=new rl(t);for(let p=0;p<d.length;++p){if(null!=s){const N=_I().numTensors;N>s.maxNumTensors&&(s.maxNumTensors=N),N<s.minNumTensors&&(s.minNumTensors=N)}const g=d[p],m=g.sourceLayer;if(m instanceof fv)continue;const y=[],b=[],v=[];let _=!1;for(const N of g.inputs){const R=f.getValue(N),V=f.getMask(N);y.push(R),b.push(V),null!=V&&(_=!0),r||(h[N.name]--,0===h[N.name]&&!t.hasKey(N)&&-1===a.indexOf(N.name)&&!R.isDisposed&&!0!==N.sourceLayer.stateful&&v.push(R))}_&&((e=e||{}).mask=b[0]);const x=sn(m.apply(y,e));let C=null;m.supportsMasking&&(C=m.computeMask(y,b));const E=_de(g),D=Array.isArray(E)?E:[E];for(let N=0;N<D.length;++N){f.hasKey(D[N])||f.add(D[N],x[N],Array.isArray(C)?C[0]:C);const R=a.indexOf(D[N].name);-1!==R&&(l[R]=x[N])}r||gt(v)}return f.disposeMasks(),i?l:l[0]}function vde(n){const t={};for(const e in n)t[e]=n[e].size;return t}function rB(n,t){const e=new Set,s=[],r={};for(const a of t.names())e.add(a);const i=[],o=[];for(i.push(n);i.length>0;){const a=i[i.length-1];if(e.has(a.name)){i.pop();continue}const l=o[o.length-1]===i.length-1;if(0===a.inputs.length||l)i.pop(),s.push(a),e.add(a.name),l&&o.pop();else{o.push(i.length-1);for(const u of a.inputs)null==r[u.name]&&(r[u.name]=new Set),r[u.name].add(a.name),!e.has(u.name)&&i.push(u)}}return{sorted:s,recipientMap:r}}function _de(n){let t;if(1===n.sourceLayer.inboundNodes.length)t=n.sourceLayer.output;else{let e=null;for(let s=0;s<n.sourceLayer.inboundNodes.length;++s)for(const r of n.sourceLayer.inboundNodes[s].outputTensors)if(r.id===n.id){e=s;break}t=n.sourceLayer.getOutputAt(e)}return t}function aD(n,t){return z(()=>Bs(Re(F(n,n),t,!0)))}W().registerFlag("TOPOLOGICAL_SORT_CACHE_MAX_ENTRIES",()=>100,function yde(n){pv?.setMaxEntries(n),mv?.setMaxEntries(n)});class Ep extends Xc{getConfig(){return{}}}ue((()=>{class n extends Ep{constructor(e){super(),this.defaultMaxValue=2,this.defaultAxis=0,this.maxValue=null!=e.maxValue?e.maxValue:this.defaultMaxValue,this.axis=null!=e.axis?e.axis:this.defaultAxis}apply(e){return z(()=>{const s=aD(e,this.axis),r=Er(s,0,this.maxValue);return F(e,Pe(r,le(is(),s)))})}getConfig(){return{maxValue:this.maxValue,axis:this.axis}}}return n.className="MaxNorm",n})()),ue((()=>{class n extends Ep{constructor(e){super(),this.defaultAxis=0,this.axis=null!=e.axis?e.axis:this.defaultAxis}apply(e){return z(()=>Pe(e,le(is(),aD(e,this.axis))))}getConfig(){return{axis:this.axis}}}return n.className="UnitNorm",n})()),ue((()=>{class n extends Ep{apply(e){return xo(e)}}return n.className="NonNeg",n})()),ue((()=>{class n extends Ep{constructor(e){super(),this.defaultMinValue=0,this.defaultMaxValue=1,this.defaultRate=1,this.defaultAxis=0,this.minValue=null!=e.minValue?e.minValue:this.defaultMinValue,this.maxValue=null!=e.maxValue?e.maxValue:this.defaultMaxValue,this.rate=null!=e.rate?e.rate:this.defaultRate,this.axis=null!=e.axis?e.axis:this.defaultAxis}apply(e){return z(()=>{const s=aD(e,this.axis),r=le(F(this.rate,Er(s,this.minValue,this.maxValue)),F(1-this.rate,s));return F(e,Pe(r,le(is(),s)))})}getConfig(){return{minValue:this.minValue,maxValue:this.maxValue,rate:this.rate,axis:this.axis}}}return n.className="MinMaxNorm",n})());const iB={maxNorm:"MaxNorm",minMaxNorm:"MinMaxNorm",nonNeg:"NonNeg",unitNorm:"UnitNorm"};function as(n){return ZE(n)}function oB(n,t={}){return _p(n,fi.getMap().classNameMap,t,"constraint")}function ls(n){return null==n?null:"string"==typeof n?oB({className:n in iB?iB[n]:n,config:{}}):n instanceof Ep?n:oB(n)}function il(n){return lD.apply(this,arguments)}function lD(){return(lD=te(function*(n){if(null==n)return;const t=[],e=[],s=[];for(const r in n){const i=n[r];if("number"!=typeof i){const o=i;t.push(o.data()),e.push(r),s.push(o)}}if(t.length>0){const r=yield Promise.all(t);for(let i=0;i<r.length;++i)n[e[i]]=r[i][0];gt(s)}})).apply(this,arguments)}function aB(n){if(null!=n)for(const t in n){const e=n[t];"number"!=typeof e&&e.dispose()}}class dd{constructor(){this.validationData=null}setParams(t){this.params=t}onEpochBegin(t,e){return te(function*(){})()}onEpochEnd(t,e){return te(function*(){})()}onBatchBegin(t,e){return te(function*(){})()}onBatchEnd(t,e){return te(function*(){})()}onTrainBegin(t){return te(function*(){})()}onTrainEnd(t){return te(function*(){})()}setModel(t){}}class xde{constructor(t,e=10){null==t&&(t=[]),this.callbacks=t,this.queueLength=e}append(t){this.callbacks.push(t)}setParams(t){for(const e of this.callbacks)e.setParams(t)}setModel(t){for(const e of this.callbacks)e.setModel(t)}onEpochBegin(t,e){var s=this;return te(function*(){null==e&&(e={});for(const r of s.callbacks)yield r.onEpochBegin(t,e)})()}onEpochEnd(t,e){var s=this;return te(function*(){null==e&&(e={});for(const r of s.callbacks)yield r.onEpochEnd(t,e)})()}onBatchBegin(t,e){var s=this;return te(function*(){null==e&&(e={});for(const r of s.callbacks)yield r.onBatchBegin(t,e)})()}onBatchEnd(t,e){var s=this;return te(function*(){null==e&&(e={});for(const r of s.callbacks)yield r.onBatchEnd(t,e)})()}onTrainBegin(t){var e=this;return te(function*(){null==t&&(t={});for(const s of e.callbacks)yield s.onTrainBegin(t)})()}onTrainEnd(t){var e=this;return te(function*(){null==t&&(t={});for(const s of e.callbacks)yield s.onTrainEnd(t)})()}}class Cde extends dd{constructor(){super()}onEpochBegin(t){var e=this;return te(function*(){e.seen=0,e.totals={}})()}onBatchEnd(t,e){var s=this;return te(function*(){null==e&&(e={});const r=null==e.size?0:e.size;s.seen+=r;for(const i in e){const o=e[i];if("number"==typeof o)s.totals.hasOwnProperty(i)||(s.totals[i]=0),s.totals[i]=s.totals[i]+o*r;else{let a;i in s.totals?a=s.totals[i]:s.totals[i]=0;const l=z(()=>le(s.totals[i],F(o,r)));s.totals[i]=l,a?.dispose()}}})()}onEpochEnd(t,e){var s=this;return te(function*(){if(null!=e)for(const r of s.params.metrics)null!=s.totals[r]&&("number"==typeof s.totals[r]?e[r]=s.totals[r]/s.seen:z(()=>{const i=F(Pe(1,s.seen),s.totals[r]);e[r]=i,s.totals[r].dispose(),vs(e[r])}))})()}}class Sde extends dd{onTrainBegin(t){var e=this;return te(function*(){e.epoch=[],e.history={}})()}onEpochEnd(t,e){var s=this;return te(function*(){null==e&&(e={}),s.epoch.push(t);for(const r in e)null==s.history[r]&&(s.history[r]=[]),s.history[r].push(e[r])})()}syncData(){var t=this;return te(function*(){const e=[],s=[],r=[];for(const o in t.history){const a=t.history[o];for(let l=0;l<a.length;++l)"number"!=typeof a[l]&&(e.push(a[l].data()),s.push(o),r.push(l))}const i=yield Promise.all(e);for(let o=0;o<i.length;++o)t.history[s[o]][r[o]].dispose(),t.history[s[o]][r[o]]=i[o][0]})()}}class Ide extends dd{constructor(t,e){if(super(),this.currentEpoch=0,this.nowFunc=t.nowFunc,this.nextFrameFunc=t.nextFrameFunc||ZL,this.yieldEvery=e||"auto","auto"===this.yieldEvery&&(this.yieldEvery=125),"never"===this.yieldEvery&&null!=t.onYield)throw new Error("yieldEvery is `never` but you provided an `onYield` callback. Either change `yieldEvery` or remove the callback");LC(this.yieldEvery)&&(this.maybeWait=function Bce(n,t,e){let r,s=null!=e?e():ir();return(...o)=>{const a=null!=e?e():ir();return a-s<t||(s=a,r=n(...o)),r}}(this.maybeWait.bind(this),this.yieldEvery,this.nowFunc)),this.trainBegin=t.onTrainBegin,this.trainEnd=t.onTrainEnd,this.epochBegin=t.onEpochBegin,this.epochEnd=t.onEpochEnd,this.batchBegin=t.onBatchBegin,this.batchEnd=t.onBatchEnd,this.yield=t.onYield}maybeWait(t,e,s){var r=this;return te(function*(){const i=[];null!=r.yield&&(yield il(s),i.push(r.yield(t,e,s))),i.push(r.nextFrameFunc()),yield Promise.all(i)})()}onEpochBegin(t,e){var s=this;return te(function*(){s.currentEpoch=t,null!=s.epochBegin&&(yield il(e),yield s.epochBegin(t,e))})()}onEpochEnd(t,e){var s=this;return te(function*(){const r=[];null!=s.epochEnd&&(yield il(e),r.push(s.epochEnd(t,e))),"epoch"===s.yieldEvery&&r.push(s.nextFrameFunc()),yield Promise.all(r)})()}onBatchBegin(t,e){var s=this;return te(function*(){null!=s.batchBegin&&(yield il(e),yield s.batchBegin(t,e))})()}onBatchEnd(t,e){var s=this;return te(function*(){const r=[];null!=s.batchEnd&&(yield il(e),r.push(s.batchEnd(t,e))),"batch"===s.yieldEvery?r.push(s.nextFrameFunc()):LC(s.yieldEvery)&&r.push(s.maybeWait(s.currentEpoch,t,e)),yield Promise.all(r)})()}onTrainBegin(t){var e=this;return te(function*(){null!=e.trainBegin&&(yield il(t),yield e.trainBegin(t))})()}onTrainEnd(t){var e=this;return te(function*(){null!=e.trainEnd&&(yield il(t),yield e.trainEnd(t))})()}}function lB(n,t){return null==n&&(n={}),n instanceof dd?[n]:Array.isArray(n)&&n[0]instanceof dd?n:sn(n).map(s=>new Ide(s,t))}let Ede=(()=>{class n{constructor(){}static registerCallbackConstructor(e,s){S(e>=0&&Number.isInteger(e),()=>`Verbosity level is expected to be an integer >= 0, but got ${e}`),n.checkForDuplicate(s),null==n.constructors[e]&&(n.constructors[e]=[]),n.constructors[e].push(s)}static checkForDuplicate(e){for(const s in n.constructors)n.constructors[+s].forEach(i=>{if(i===e)throw new $("Duplicate callback constructor.")})}static clear(){n.constructors={}}static createCallbacks(e){const s=[];for(const r in n.constructors){const i=+r;e>=i&&s.push(...n.constructors[i])}return s.map(r=>new r)}}return n.constructors={},n})();function uB(n,t,e,s,r,i,o,a,l){const u=new Sde,c=[new Cde,...Ede.createCallbacks(t)];null!=n&&c.push(...n),c.push(u);const d=new xde(c);return d.setParams({epochs:e,initialEpoch:s,samples:r,steps:i,batchSize:o,verbose:t,doValidation:a,metrics:l}),{callbackList:d,history:u}}function fa(n,t={},e=!1){return _p(n,fi.getMap().classNameMap,t,"layer",e)}function gv(n,t){return z(()=>{"float32"!==n.dtype&&(n=xe(n,"float32"));const e=Re(Cp(n),t,!0),s=Yc(e.shape,is()),r=Bs(oa(e,s));return Pe(n,r)})}function yv(n,t){return z(()=>Nn(Cp(Ne(t,n)),-1))}function uD(n,t){return z(()=>Nn(ns(Ne(t,n)),-1))}function cD(n,t){return z(()=>{const e=Ne(n,t),s=Er(ns(n),is(),Number.MAX_VALUE),r=ns(Pe(e,s));return F(100,Nn(r,-1))})}function Dp(n,t,e=!1){return z(()=>{if(e)t=Kb(t);else{const s=Re(t,t.shape.length-1,!0);t=Pe(t,s)}return t=Er(t,is(),1-is()),dn(Re(F(xe(n,"float32"),jr(t)),t.shape.length-1))})}function bv(n,t,e=!1){return z(()=>{const s=xe(dp(function ede(n){const t=[nl(n.shape)];return O(n,t)}(n)),"int32"),r=(t=Er(t,is(),1-is())).shape;return Dp(O(YI(s,r[r.length-1]),r),t,e)})}function vv(n,t){return z(()=>{let e;return e=Er(t,is(),1-is()),e=jr(Pe(e,Ne(1,e))),Nn(function Rde(n,t){if(!wt(n.shape,t.shape))throw new $(`logits and labels must have the same shape, but got shapes ${JSON.stringify(n.shape)} and ${JSON.stringify(t.shape)}`);return z(()=>{const e=xo(t),s=dn(ns(t));return le(Ne(e,F(t,n)),Lb(Hr(s)))})}(n,e),-1)})}function cB(n,t){return z(()=>{const e=gv(n,-1),s=gv(t,-1),r=F(e,s);return dn(Re(r,-1))})}const _v={meanSquaredError:yv,meanAbsoluteError:uD,meanAbsolutePercentageError:cD,meanSquaredLogarithmicError:function Dde(n,t){return z(()=>{const e=Er(t,is(),Number.MAX_VALUE),s=jr(le(1,e)),r=Er(n,is(),Number.MAX_VALUE),i=jr(le(1,r));return Nn(Cp(Ne(s,i)),-1)})},squaredHinge:function Tde(n,t){return z(()=>{const e=oa(0,Ne(1,F(n,t)));return Nn(Cp(e),-1)})},hinge:function Nde(n,t){return z(()=>{const e=oa(0,Ne(1,F(n,t)));return Nn(e,-1)})},categoricalHinge:function kde(n,t){return z(()=>{const e=Re(F(n,t),-1),s=mi(F(Ne(1,n),t),-1);return oa(0,le(1,Ne(s,e)))})},logcosh:function Ade(n,t){return z(()=>{const e=Math.log(2),s=Ne(t,n),r=Ne(le(s,nd(F(-2,s))),e);return Nn(r,-1)})},categoricalCrossentropy:Dp,sparseCategoricalCrossentropy:bv,binaryCrossentropy:vv,kullbackLeiblerDivergence:function Mde(n,t){return z(()=>{const e=Er(n,is(),1),s=Er(t,is(),1);return Re(F(n,jr(Pe(e,s))),-1)})},poisson:function Fde(n,t){return z(()=>{const e=jr(le(is(),t));return Nn(Ne(t,F(n,e)),-1)})},cosineProximity:cB};function dD(n){if("string"==typeof n){if(n in _v)return _v[n];let t=`Unknown loss ${n}`;throw n.toLowerCase().includes("softmaxcrossentropy")&&(t=`Unknown loss ${n}. Use "categoricalCrossentropy" as the string name for tf.losses.softmaxCrossEntropy`),new $(t)}return n}function dB(n,t){return z(()=>{const e=F(.5,Kr(t)),s=Eo(Dr(t,e),n.dtype);return Nn(Wi(n,s),-1)})}function hB(n,t){return z(()=>Eo(Wi(Qc(n,-1),Qc(t,-1)),"float32"))}function Lde(n,t){return vv(n,t)}function Vde(n,t){return n.rank===t.rank&&(n=lu(n,[n.rank-1])),(t=Qc(t,-1)).dtype!==n.dtype&&(t=xe(t,n.dtype)),xe(Wi(n,t),"float32")}const pB=Dp,mB=bv,wv={binaryAccuracy:dB,categoricalAccuracy:hB,precision:function Pde(n,t){return z(()=>{const e=function fB(n,t){return z(()=>xe(Re(wo(Wi(n,1),Wi(t,1))),"float32"))}(n,t),s=function $de(n,t){return z(()=>xe(Re(wo(Wi(n,0),Wi(t,1))),"float32"))}(n,t),r=le(e,s);return xe(zs(Dr(r,0),Pe(e,r),0),"float32")})},categoricalCrossentropy:pB,sparseCategoricalCrossentropy:mB,mse:yv,MSE:yv,mae:uD,MAE:uD,mape:cD,MAPE:cD,cosine:cB};function qde(n){if("string"==typeof n&&n in wv)return wv[n];if("string"!=typeof n&&null!=n)return n;throw new $(`Unknown metric ${n}`)}function xv(n){if(Yr(null!==n,`Unknown LossOrMetricFn ${n}`),"string"==typeof n)return n;{let t;for(const e of Object.keys(_v))if(_v[e]===n){t=e;break}if(void 0!==t)return t;for(const e of Object.keys(wv))if(wv[e]===n){t=e;break}return void 0!==t?t:n.name}}function yB(n,t,e=!1){if(null==n||"object"!=typeof n||Object.getPrototypeOf(n)!==Object.prototype||!hD(n))throw new Error("User-defined metadata is expected to be a JSON object, but is not.");if(e){const s=JSON.stringify(n);s.length>1048576&&console.warn(`User-defined metadata of model "${t}" is too large in size (length=${s.length} when serialized). It is not recommended to store such large objects in user-defined metadata. Please make sure its serialized length is <= 1048576.`)}}function hD(n){if(null===n)return!0;if("object"==typeof n){if(Object.getPrototypeOf(n)===Object.prototype){const t=Object.keys(n);for(const e of t)if("string"!=typeof e||!hD(n[e]))return!1;return!0}if(Array.isArray(n)){for(const t of n)if(!hD(t))return!1;return!0}return!1}{const t=typeof n;return"string"===t||"number"===t||"boolean"===t}}function Cv(n,t,e=console.log){let s="";for(let r=0;r<n.length;++r)r>0&&(s=s.slice(0,s.length-1)+" "),s+=n[r],s=s.slice(0,t[r]),s+=" ".repeat(t[r]-s.length);e(s)}function Qde(n,t,e){let s,r;try{r=n.inboundNodes.map(l=>JSON.stringify(l.inputShapes)).join(",")}catch{r="multiple"}try{s=JSON.stringify(n.outputShape)}catch{s="multiple"}Cv([`${n.name} (${n.getClassName()})`,r,s,n.countParams().toString()],t,e)}function Jde(n,t,e,s){let r,i;try{i=n.inboundNodes.map(d=>JSON.stringify(d.inputShapes)).join(",")}catch{i="multiple"}try{r=JSON.stringify(n.outputShape)}catch{r="multiple"}const o=[];for(const d of n.inboundNodes)if(!(null!=e&&e.length>0&&-1===e.indexOf(d)))for(let h=0;h<d.inboundLayers.length;++h)o.push(`${d.inboundLayers[h].name}[${d.nodeIndices[h]}][${d.tensorIndices[h]}]`);const a=n.name,l=n.getClassName(),u=0===o.length?"":o[0];Cv([`${a} (${l})`,i,r,n.countParams().toString(),u],t,s);for(let d=1;d<o.length;++d)Cv(["","","","",o[d]],t,s)}function bB(n,t,e){return("inboundNodes"===n||"outputLayers"===n||"inputLayers"===n)&&0===t&&"string"==typeof e}function fD(n,t){if(null===n)return null;if("string"==typeof n)return du(n);if("number"==typeof n||"boolean"==typeof n)return n;if(n instanceof Array){const e=[],s=n.length;for(let r=0;r<s;++r){const i=n[r];bB(t,r,i)?e.push(i):e.push(fD(i,t))}return e}{const e={};for(const s of Object.keys(n)){const r=n[s];if("name"===s&&"string"==typeof r)e[s]=r;else{const i=du(s);e[i]=fD(r,i)}}return e}}function pD(n,t){if(null==n)return null;if("string"==typeof n)return ha(n);if("number"==typeof n||"boolean"==typeof n)return n;if(n instanceof Array){const e=[],s=n.length;for(let r=0;r<s;++r){const i=n[r];bB(t,r,i)?e.push(i):e.push(pD(i,t))}return e}{const e={};for(const s of Object.keys(n)){const r=n[s];e[ha(s)]="name"!==s&&"className"!==s||"string"!=typeof r?pD(r,s):r}return e}}class qi extends yt{constructor(t){if(super({}),this.containerNodes=new Set,this.name=t.name,null==this.name){const b=this.getClassName().toLowerCase();this.name=ov(b)}if(this.supportsMasking=!1,this.trainable_=!0,this.inputs=Array.isArray(t.inputs)?t.inputs.slice():[t.inputs],this.outputs=Array.isArray(t.outputs)?t.outputs.slice():[t.outputs],tl(this.inputs).length!==this.inputs.length)throw new $(`The list of inputs passed to the model is redundant. All inputs should only appear once. Found: ${this.inputs.map(b=>b.name)}`);tl(this.outputs).length!==this.outputs.length&&console.warn(`The list of outputs passed to the model is redundant. All outputs should only appear once. Found: ${this.outputs.map(b=>b.name)}`),this.inputLayers=[],this.inputLayersNodeIndices=[],this.inputLayersTensorIndices=[],this.outputLayers=[],this.outputLayersNodeIndices=[],this.outputLayersTensorIndices=[],this.layers=[],this.internalContainerRefs=[];for(const b of this.outputs){const _=b.nodeIndex,x=b.tensorIndex;this.outputLayers.push(b.sourceLayer),this.outputLayersNodeIndices.push(_),this.outputLayersTensorIndices.push(x)}for(const b of this.inputs){const v=b.sourceLayer,_=b.nodeIndex,x=b.tensorIndex;Yr(0===_,"input layer has >1 nodes"),Yr(0===x,"input layer has >1 tensors"),this.inputLayers.push(v),this.inputLayersNodeIndices.push(_),this.inputLayersTensorIndices.push(x)}this.inputNames=[],this.outputNames=[],this.feedInputShapes=[],this.feedInputNames=[],this.feedOutputNames=[];for(let b=0;b<this.inputLayers.length;b++){const v=this.inputLayers[b];if(!(v instanceof fv))throw new TypeError(`Input layers to a LayersModel must be InputLayer objects. Received inputs: ${t.inputs}. Input ${b} (0-based) originates from layer type ${v.getClassName()}.`);this.inputNames.push(v.name),this.feedInputShapes.push(v.batchInputShape),this.feedInputNames.push(v.name)}for(const b of this.outputLayers)this.outputNames.push(b.name);this.internalInputShapes=this.inputs.map(b=>b.shape),this.internalOutputShapes=this.outputs.map(b=>b.shape);const e={},s={},r={},i={},o={},a=[],l=(b,v,_,x,C,E)=>{(null==x||null==C||null==E)&&(x=b.sourceLayer,C=b.nodeIndex,E=b.tensorIndex);const D=x.inboundNodes[C];if(-1!==_.indexOf(D))throw new vi(`The tensor ${b.name} at layer "${x.name}" is part of a cycle.`);if(-1!==v.indexOf(D))return;this.containerNodes.add(qi.nodeKey(x,C)),x.id in o||(o[x.id]=Object.keys(o).length),-1===_.indexOf(D)&&_.push(D);const N=D.inboundLayers.length;for(let R=0;R<N;R++)l(D.inputTensors[R],v,_,D.inboundLayers[R],D.nodeIndices[R],D.tensorIndices[R]);for(v.push(D);_.indexOf(D)>=0;)_.splice(_.indexOf(D),1);a.push(D)},u=[],c=[];for(const b of this.outputs)l(b,u,c);const d=a.slice().reverse();for(const b of d){s[b.id]=b,b.id in e||(e[b.id]=0);let v=e[b.id];v=Math.max(v,null==r[b.outboundLayer.id]?0:r[b.outboundLayer.id]),r[b.outboundLayer.id]=v,i[b.outboundLayer.id]=b.outboundLayer,e[b.id]=v;for(let x=0;x<b.inboundLayers.length;x++){const D=b.inboundLayers[x].inboundNodes[b.nodeIndices[x]];e[D.id]=Math.max(v+1,null==e[D.id]?0:e[D.id]),s[D.id]=D}}const h={};for(const b in e){const v=e[b];v in h||(h[v]=[]),h[v].push(s[b])}const f={};for(const b in r){const v=r[b];v in f||(f[v]=[]),f[v].push(i[b])}let p=Object.keys(f).map(b=>parseInt(b,10)).sort(rv);this.layers=[];for(const b of p){const v=f[b];v.sort((_,x)=>{const C=o[_.id],E=o[x.id];return C<E?-1:C>E?1:0});for(const _ of v)_ instanceof qi&&this.internalContainerRefs.push(_),this.layers.push(_)}this.layersByDepth=f,p=Object.keys(h).map(b=>parseInt(b,10)).sort(rv);const g=this.inputs.slice(),m=[];for(const b of p)for(const v of h[b]){const _=v.outboundLayer;if(null!=_){for(const x of v.inputTensors)if(-1===g.indexOf(x))throw new vi(`Graph disconnected: cannot obtain value for tensor ${x} at layer "${_.name}". The following previous layers were accessed without issue: ${m}`);for(const x of v.outputTensors)g.push(x);m.push(_.name)}}this.nodesByDepth=h;const y=this.layers.map(b=>b.name);for(const b of y){const v=y.filter(_=>_===b).length;if(1!==v)throw new vi(`The name "${b}" is used ${v} times in the model. All layer names should be unique. Layer names: `+JSON.stringify(y))}this.outboundNodes=[],this.inboundNodes=[],new hv({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:this.inputs.map(b=>null),outputMasks:this.outputs.map(b=>null),inputShapes:this.inputs.map(b=>b.shape),outputShapes:this.outputs.map(b=>b.shape)}),this.built=!0,this._refCount=1}assertNotDisposed(){if(0===this._refCount)throw new Error(`Container '${this.name}' is already disposed.`)}dispose(){this.assertNotDisposed();const t={refCountAfterDispose:null,numDisposedVariables:0};if(0==--this._refCount){for(const e of this.layers)t.numDisposedVariables+=e.dispose().numDisposedVariables;for(const e of this.internalContainerRefs)t.numDisposedVariables+=e.dispose().numDisposedVariables}return t.refCountAfterDispose=this._refCount,t}get trainable(){return this.trainable_}set trainable(t){this.layers.forEach(e=>{e._trainableWeights.forEach(s=>s.trainable=t)}),this.trainable_=t}get trainableWeights(){if(this._trainableWeights.length>0)throw new $("Container instance unexpectedly contains _trainableWeights.The trainable weights of a Container are a union of the trainable weights of its consituent Layers. Its own _trainableWeights must remain an empty Array.");if(!this.trainable)return[];let t=[];for(const e of this.layers)t=t.concat(e.trainableWeights);return t}get nonTrainableWeights(){const t=[];for(const e of this.layers)t.push(...e.nonTrainableWeights);if(!this.trainable){const e=[];for(const s of this.layers)e.push(...s.trainableWeights);return e.concat(t)}return t}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}loadWeights(t,e=!0){const s={};let r=0;for(const o of this.layers)for(const a of o.weights){if(null!=s[a.originalName])throw new $(`Duplicate weight name: ${a.originalName}`);s[a.originalName]=a,r++}const i=[];for(const o in t){let a=o;if(null==s[o]){const l=o.split("/");a=l.slice(0,-2).concat([l[l.length-1]]).join("/")}if(null!=s[a])i.push([s[a],t[o]]);else if(e)throw new $(`Provided weight data has no target variable: ${o}`);delete s[a]}if(e){const o=[];for(const a in s)o.push(a);if(o.length>0)throw new $(`${o.length} of ${r} weights are not set: ${o}`)}oD(i)}updatedConfig(){const t=this.getConfig(),e={};return e.className=this.getClassName(),e.config=t,e.kerasVersion="tfjs-layers 4.5.0",e.backend="TensorFlow.js",e}toJSON(t,e=!0){const s=pD(this.updatedConfig());return e?JSON.stringify(s):s}call(t,e){return z(()=>{t=sn(t);const s=new rl;for(let r=0;r<this.inputs.length;++r)s.add(this.inputs[r],t[r]);return Ip(this.outputs,s,e)})}computeMask(t,e){return z(()=>{let s;return t=sn(t),s=null==e?cu(null,t.length):sn(e),this.runInternalGraph(t,s)[1]})}computeOutputShape(t){const e=cv(t);if(e.length!==this.inputLayers.length)throw new $(`Invalid inputShape argument ${t}: model has ${this.inputLayers.length} tensor inputs.`);const s={};for(let a=0;a<e.length;a++)s[this.inputLayers[a].name+"_0_0"]=e[a];const r=Object.keys(this.nodesByDepth).map(a=>parseInt(a,10)).sort(rv);if(r.length>1)for(const a of r){const l=this.nodesByDepth[a];for(const u of l){const c=u.outboundLayer;if(-1!==this.inputLayers.map(g=>g.id).indexOf(c.id))continue;const d=[];for(let g=0;g<u.inboundLayers.length;g++)d.push(s[`${u.inboundLayers[g].name}_${u.nodeIndices[g]}_${u.tensorIndices[g]}`]);const f=cv(c.computeOutputShape(ur(d))),p=c.inboundNodes.indexOf(u);for(let g=0;g<f.length;g++)s[`${c.name}_${p}_${g}`]=f[g]}}const i=[],o=[];for(let a=0;a<this.outputLayers.length;a++)o.push(`${this.outputLayers[a].name}_${this.outputLayersNodeIndices[a]}_${this.outputLayersTensorIndices[a]}`);for(let a=0;a<o.length;a++){const l=o[a];Yr(l in s),i.push(s[l])}return ur(i)}runInternalGraph(t,e){null==e&&(e=cu(null,t.length));const s={};for(let l=0;l<this.inputs.length;++l)s[this.inputs[l].id]=[t[l],e[l]];const r=Object.keys(this.nodesByDepth).map(l=>parseInt(l,10)).sort(rv);for(const l of r){const u=this.nodesByDepth[l];for(const c of u){const d=c.outboundLayer,h=c.inputTensors,f=c.outputTensors,p=new Array;for(const g of h)g.id in s&&p.push(s[g.id]);if(p.length===h.length){let m,y,b,v,g={};if(null!=c.callArgs&&(g=c.callArgs),1===p.length){const[_,x]=p[0];null==g.mask&&(g.mask=x),b=sn(d.call(_,g)),v=sn(d.computeMask(_,x)),m=[_],y=[x]}else m=p.map(_=>_[0]),y=p.map(_=>_[1]),null==g.mask&&(g.mask=y),b=sn(d.call(m,g)),v=sn(d.computeMask(m,y));if(d.activityRegularizer)throw new ot("LayersModel invocation with concrete Tensor value(s) in the presence of activity regularizer(s) is not supported yet.");for(let _=0;_<f.length;++_)s[f[_].id]=[b[_],v[_]]}}}const i=[],o=[],a=[];for(const l of this.outputs){Yr(l.id in s,`Could not compute output ${l.name} : ${l.id}`);const[u,c]=s[l.id];a.push(u.shape),i.push(u),o.push(c)}return[i,o,a]}buildNodeConversionMap(t){const e={};let s;for(const r of this.layers){s=r instanceof qi?1:0;for(let i=0;i<r.inboundNodes.length;i++){const o=qi.nodeKey(r,i);this.containerNodes.has(o)&&(e[o]=s,s+=1)}}return e}getLayer(t,e){if(null!=e){if(this.layers.length<=e)throw new $(`Was asked to retrieve layer at index ${e}, but model only has ${this.layers.length} layer(s).`);return this.layers[e]}if(null==t)throw new $("Provide either a layer name or layer index");for(const s of this.layers)if(s.name===t)return s;throw new $(`No such layer: ${t}`)}calculateLosses(){return z(()=>{const t=[];for(const e of this.layers)for(let s=0;s<e.inboundNodes.length;++s){const r=qi.nodeKey(e,s);this.containerNodes.has(r)&&t.push(...e.calculateLosses())}return t})}getConfig(){const t={name:this.name},e=this.buildNodeConversionMap(this.layers),s=[];for(const o of this.layers){const a=o.getClassName(),l=o.getConfig(),u=[];for(let d=0;d<o.inboundNodes.length;d++){const h=o.inboundNodes[d],f=qi.nodeKey(o,d);let p={};if(this.containerNodes.has(f)){if(h.callArgs)try{JSON.stringify(h.callArgs),p=h.callArgs}catch{console.warn(`Layer ${o.name} was passed non-serializable keyword arguments: ${h.callArgs}. They will not be included in the serialized model (and thus will be missing at deserialization time).`),p={}}if(h.inboundLayers.length>0){const g=[];for(let m=0;m<h.inboundLayers.length;m++){const y=h.inboundLayers[m],v=h.tensorIndices[m];let x=e[qi.nodeKey(y,h.nodeIndices[m])];null==x&&(x=0),g.push([y.name,x,v,p])}u.push(g)}}}const c={};c.name=o.name,c.className=a,c.config=l,c.inboundNodes=u,s.push(c)}t.layers=s;const r=[];for(let o=0;o<this.inputLayers.length;o++){const a=this.inputLayers[o],u=qi.nodeKey(a,this.inputLayersNodeIndices[o]);if(!this.containerNodes.has(u))continue;let c=e[u];null==c&&(c=0),r.push([a.name,c,this.inputLayersTensorIndices[o]])}t.inputLayers=r;const i=[];for(let o=0;o<this.outputLayers.length;o++){const a=this.outputLayers[o],u=qi.nodeKey(a,this.outputLayersNodeIndices[o]);if(!this.containerNodes.has(u))continue;let c=e[u];null==c&&(c=0),i.push([a.name,c,this.outputLayersTensorIndices[o]])}return t.outputLayers=i,t}static fromConfig(t,e,s={},r=!1){const i={},o={};function a(m,y){m.name in o?o[m.name].push(y):o[m.name]=[y]}function l(m,y){const b=[];let v;for(const _ of y){const x=_[0],C=_[1],E=_[2];if(v=null==_[3]?{}:_[3],!(x in i))return void a(m,y);const D=i[x];if(D.inboundNodes.length<=C)return void a(m,y);b.push(D.inboundNodes[C].outputTensors[E])}b.length>0&&m.apply(ur(b),v)}function u(m){const y=m.name,b=fa(m,null!=e.customObjects?e.customObjects:{});b.setFastWeightInitDuringBuild(r),i[y]=b,m.inboundNodes.forEach(_=>{if(!(_ instanceof Array))throw new $(`Corrupted configuration, expected array for nodeData: ${_}`);a(b,_)})}const c=e.name,d=e.layers;for(const m of d)u(m);for(;!Vce(o);)for(const m of d){const y=i[m.name];if(y.name in o){const b=o[y.name];delete o[y.name];for(const v of b)l(y,v)}}const h=[],f=[],p=e.inputLayers;for(const m of p){const y=m[0],b=m[1],v=m[2];Yr(y in i),h.push(i[y].inboundNodes[b].outputTensors[v])}const g=e.outputLayers;for(const m of g){const y=m[0],b=m[1],v=m[2];Yr(y in i),f.push(i[y].inboundNodes[b].outputTensors[v])}return new t({inputs:h,outputs:f,name:c})}get stateful(){if(this._stateful)throw new $("Container instance unexpectedly has _stateful = true. The statefulness of a Container is determined by the Layers it contains. Its _stateful property must remain the default false.");for(const t of this.layers)if(t.stateful)return!0;return!1}resetStates(){z(()=>{this.layers.forEach(t=>{t.stateful&&t.resetStates()})})}}function _B(n,t){return function vB(n,t,e){const s=t.length;if(null==n||Array.isArray(n)&&0===n.length)return t.map(r=>null);if(1===s)return Array.isArray(n)&&1===n.length?n:"object"==typeof n&&t[0]in n?[n[t[0]]]:[n];if(Array.isArray(n)){if(n.length!==s)throw new Error(`Provided ${e} is an array of ${n.length} element(s), but the model has ${s} outputs. Make sure a set of weights is provided for each model output.`);return n}if("object"==typeof n&&Object.keys(n).length>0&&"object"==typeof n[Object.keys(n)[0]]){const r=[];return t.forEach(i=>{r.push(i in n?n[i]:null)}),r}throw new Error(`The model has multiple (${s}) outputs, so ${e} must be either an array with ${s} elements or an object with ${t} keys. Provided ${e} not understood: ${JSON.stringify(n)}`)}(n,t,"classWeight")}function wB(n,t,e,s){return gD.apply(this,arguments)}function gD(){return(gD=te(function*(n,t,e,s){if(null!=t||null!=s)throw new Error("Support sampleWeight is not implemented yet");if(null!=e){const r=z(()=>{if(1===n.shape.length)return ra(n);if(2===n.shape.length){if(n.shape[1]>1)return Qc(n,1);if(1===n.shape[1])return O(n,[n.shape[0]]);throw new Error(`Encountered unexpected last-dimension size (${n.shape[1]}) during handling of class weights. The size is expected to be >= 1.`)}throw new Error(`Unexpected rank of target (y) tensor (${n.rank}) during handling of class weights. The rank is expected to be 1 or 2.`)}),i=Array.from(yield r.data());gt(r);const o=[];return i.forEach(a=>{if(null==e[a])throw new Error(`classWeight must contain all classes in the training data. The class ${a} exists in the data but not in classWeight`);o.push(e[a])}),lr(o,"float32")}return null})).apply(this,arguments)}function ehe(n,t){return F(n,t)}function xB(n,t){let e,s;e=t.xs,s=t.ys,S(null!=e&&null!=s,()=>`A Dataset iterator for fitDataset() is expected to generate objects of the form \`{xs: xVal, ys: yVal}\`, where the two values may be \`tf.Tensor\`, an array of Tensors, or a map of string to Tensor.  The provided Dataset instead generates ${t}`);const i=CB("input",n.inputNames,e),o=CB("output",n.outputNames,s),a=i[0].shape[0];S(i.length===n.inputs.length,()=>`LayersModel has ${n.inputs.length} inputs, but the dataset provides ${i.length} inputs.  (Expected input keys: ${JSON.stringify(n.inputNames)})`),S(o.length===n.outputs.length,()=>`LayersModel has ${n.outputs.length} outputs, but the dataset provides ${o.length} outputs.  (Expected output keys: ${JSON.stringify(n.outputNames)})`);for(let l=0;l<i.length;l++)S(i[l].shape[0]===a,()=>`Batch size mismatch: input ${n.inputNames[l]} has ${i[l].shape[0]}; expected  ${a} based on input ${n.inputNames[0]}.`);for(let l=0;l<o.length;l++)S(o[l].shape[0]===a,()=>`Batch size mismatch: output ${n.outputNames[l]} has ${o[l].shape[0]}; expected  ${a} based on input ${n.inputNames[0]}.`);return{xs:i,ys:o}}function CB(n,t,e){if(e instanceof pn)return[e];if(Array.isArray(e))return S(e.length===t.length,()=>`Received an array of ${e.length} Tensors, but expected ${t.length} to match the ${n} keys ${t}.`),e;{const s=[];for(const r of t){if(null==e[r])throw new $(`The feature data generated by the dataset lacks the required ${n} key '${r}'.`);s.push(e[r])}return s}}function yD(){return(yD=te(function*(n,t,e){const s=null!=e.batchesPerEpoch;if(S(null!=n.optimizer,()=>"You must compile a model before training/testing. Use LayersModel.compile(modelCompileConfig)."),S(null!=e,()=>"For fitDataset(), the 2nd argument (config) is required, but it is not provided in this call."),S(null!=e.epochs&&e.epochs>0&&Number.isInteger(e.epochs),()=>`For fitDataset(), config.epochs is expected to be a positive integer, but got ${e.epochs}`),S(!s||e.batchesPerEpoch>0&&Number.isInteger(e.batchesPerEpoch),()=>`For fitDataset(), config.batchesPerEpoch is expected to be a positive integer if specified, but got ${e.batchesPerEpoch}`),S(null==e.validationSplit,()=>"`validationSplit` is not supported by `fitDataset()`. Use validationData instead."),n.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");n.isTraining=!0;try{const r=null!=e.validationData;let i,o;if(r)if(SB(e.validationData))S(null==e.validationBatches||e.validationBatches>0&&Number.isInteger(e.validationBatches),()=>`For fitDataset() with dataset-based validation, config.validationBatches is expected not to be provided, or to be a positive integer, but got ${e.validationBatches}`);else{const m=function nhe(n){if(3===n.length)throw new ot("Validation with sample weights is not implemented yet.");return{xs:n[0],ys:n[1]}}(e.validationData);i=m.xs,o=m.ys}const a=n.makeTrainFunction(),l=n.getDedupedMetricsNames();let u;u=r?l.slice().concat(l.map(m=>"val_"+m)):l.slice();const c=lB(e.callbacks,e.yieldEvery),d=null==e.verbose?1:e.verbose,{callbackList:h,history:f}=uB(c,d,e.epochs,null,null,function rhe(n,t){let e=null;return null!=t.batchesPerEpoch?e=t.batchesPerEpoch:Number.isFinite(n.size)&&(e=n.size),e}(t,e),null,r,u);h.setModel(n),n.history=f,yield h.onTrainBegin(),n.stopTraining_=!1;let p=null==e.initialEpoch?0:e.initialEpoch,g=yield t.iterator();for(;p<e.epochs;){const m={};yield h.onEpochBegin(p);let y=0,b=0;for(s||(g=yield t.iterator());!s||y<e.batchesPerEpoch;){const v=yield g.next();if(s&&v.done){console.warn(`You provided \`batchesPerEpoch\` as ${e.batchesPerEpoch}, but your dataset iterator ran out of data after ${y} batches; interrupting training. Make sure that your dataset can generate at least \`batchesPerEpoch * epochs\` batches (in this case, ${e.batchesPerEpoch*e.epochs} batches). You may need to use the repeat() function when building your dataset.`);break}if(null!=v.value){const{xs:_,ys:x}=xB(n,v.value),C={};C.batch=b,C.size=_[0].shape[0],yield h.onBatchBegin(b,C);const E=[];if(null!=e.classWeight){const R=_B(e.classWeight,n.outputNames);for(let V=0;V<R.length;++V)E.push(yield wB(x[V],null,R[V]))}const D=_.concat(x).concat(E),N=a(D);gt(D);for(let R=0;R<l.length;++R){const G=N[R];C[l[R]]=G,vs(G)}yield h.onBatchEnd(b,C),aB(C),b++,y++}if(s?y>=e.batchesPerEpoch:v.done){if(r){let _;_=SB(e.validationData)?sn(yield n.evaluateDataset(e.validationData,{batches:e.validationBatches})):sn(n.evaluate(i,o,{batchSize:null==e.validationBatchSize?32:e.validationBatchSize,verbose:0}));for(let x=0;x<n.metricsNames.length;++x)m[`val_${n.metricsNames[x]}`]=_[x]}break}if(n.stopTraining_)break}if(yield h.onEpochEnd(p,m),p++,n.stopTraining_)break}return yield h.onTrainEnd(),yield n.history.syncData(),n.history}finally{n.isTraining=!1}})).apply(this,arguments)}function SB(n){return"function"==typeof n.iterator}function bD(){return(bD=te(function*(n,t,e){const s=null!=(e=e||{}).batches,r=n.testFunction;let i=[];if(e.verbose>0)throw new ot("Verbose mode is not implemented yet.");S(!s||e.batches>0&&Number.isInteger(e.batches),()=>`Test loop expects \`batches\` to be a positive integer, but received ${JSON.stringify(e.batches)}`);const o=function ihe(n){return"function"==typeof n.next}(t)?t:yield t.iterator();let a=0,l=0;for(;!s||l<e.batches;){const u=yield o.next();if(i=z(()=>{if(u.value){const{xs:c,ys:d}=xB(n,u.value),h=c.concat(d),f=z(()=>r(h));if(gt(h),0===l)for(let g=0;g<f.length;++g)i.push(ze(0));const p=h[0].shape[0];for(let g=0;g<f.length;++g){const m=f[g],y=i[g];i[g]=z(()=>le(i[g],F(p,m))),l>0&&gt(y)}gt(f),a+=p,++l}return i}),u.done){s&&console.warn(`Your dataset iterator ran out of data during evaluateDataset(). Interrupting evalution. Make sure that your dataset can generate at least \`batches\` batches (in this case, ${e.batches} batches). You may need to use the repeat() function when building your dataset.`);break}}for(let u=0;u<i.length;++u){const c=i[u];i[u]=Pe(i[u],a),gt(c)}return ur(i)})).apply(this,arguments)}function vD(n){S(n>0&&Number.isInteger(n),()=>`batchSize is required to be a positive integer, but got ${n}`)}function Tp(n,t,e){return null==n?[null]:Array.isArray(n)?n.map(s=>pu(s,t,e-t)):pu(n,t,e-t)}function _D(n,t){return z(()=>null==n?null:Array.isArray(n)?n.map(e=>_D(e,t)):HV(n,"int32"===t.dtype?t:xe(t,"int32")))}function wD(n,t){const e=[];let s=0,r=null;for(;s<n;)r=s+t,r>=n&&(r=n),e.push([s,r]),s=r;return e}function IB(n){const t=[];n instanceof pn&&(n=[n]);for(let e=0;e<n.length;++e){const s=n[e];if(1===s.rank)t.push(xp(s,1));else{if(0===s.rank)throw new Error("Expected tensor to be at least 1D, but received a 0D tensor (scalar).");t.push(s)}}return t}function Ki(n,t){if(null==n)return;const e=[];if(t instanceof pn)e.push(t.id);else if(Array.isArray(t))t.forEach(r=>e.push(r.id));else if(null!=t)for(const r in t)e.push(t[r].id);const s=[];if(n instanceof pn)-1===e.indexOf(n.id)&&s.push(n);else if(Array.isArray(n))n.forEach(r=>{-1===e.indexOf(r.id)&&s.push(r)});else if(null!=n)for(const r in n){const i=n[r];-1===e.indexOf(i.id)&&s.push(i)}s.forEach(r=>{r.isDisposed||r.dispose()})}function xD(n){return Array.isArray(n)}function EB(n){return!function ahe(n){return n instanceof pn}(n)&&!xD(n)}function DB(n,t,e,s=!0,r=""){if(null==t||0===t.length){if(null!=n){let o=!1;if(xD(n)&&n.length>0)o=!0;else if(EB(n)){for(const a in n)if(n.hasOwnProperty(a)){o=!0;break}}else o=!0;if(o)throw new $(`Error when checking model ${r} expected no data, but got ${n}`)}return[]}if(null==n)return t.map(o=>null);let i;if(EB(n)){i=[];for(const o of t){if(null==n[o])throw new $(`No data provided for "${o}". Need data for each key in: ${t}`);i.push(n[o])}}else if(xD(n)){if(n.length!==t.length)throw new $(`Error when checking model ${r}: the Array of Tensors that you are passing to your model is not the size the model expected. Expected to see ${t.length} Tensor(s), but instead got the following list of Tensor(s): ${n}`);i=n}else{if(t.length>1)throw new $(`The model ${r} expects ${t.length} Tensor(s), but only received one Tensor. Found: Tensor with shape ${n.shape}`);i=[n]}if(i=IB(i),null!=e)for(let o=0;o<t.length;++o){if(null==e[o])continue;const a=i[o];if(a.shape.length!==e[o].length)throw new $(`Error when checking ${r}: expected ${t[o]} to have ${e[o].length} dimension(s). but got array with shape ${a.shape}`);for(let l=0;l<e[o].length;++l){if(0===l&&!s)continue;const c=e[o][l];if(null!=c&&c>=0&&a.shape[l]!==c)throw new $(`${r} expected a batch of elements where each example has shape [${e[o].slice(1,e[o].length)}] (i.e.,tensor shape [*,${e[o].slice(1,e[o].length)}]) but the ${r} received an input with ${a.shape[0]} examples, each with shape [${a.shape.slice(1,a.shape.length)}] (tensor shape [${a.shape}])`)}}return i}function TB(n,t,e,s=!0,r=""){let i;if(Array.isArray(n)){if(n.length!==t.length)throw new $(`Error when checking model ${r}: the Array of Tensors that you are passing to your model is not the size the the model expected. Expected to see ${t.length} Tensor(s), but instead got ${n.length} Tensors(s).`);i=n}else{if(t.length>1)throw new $(`The model expects ${t.length} ${r} Tensors, but only received one Tensor. Found: array with shape ${JSON.stringify(n.shape)}.`);i=[n]}if(null!=e)for(let o=0;o<t.length;++o){if(null==e[o])continue;const a=i[o];if(a.shape.length!==e[o].length)throw new $(`Error when checking ${r}: expected ${t[o]} to have ${e[o].length} dimension(s), but got array with shape ${JSON.stringify(a.shape)}`);for(let l=0;l<e[o].length;++l){if(0===l&&!s)continue;const c=e[o][l];if(null!=c&&c!==a.shape[l])throw new $(`Error when checking ${r}: expected ${t[o]} to have shape ${JSON.stringify(e[o])} but got array with shape ${JSON.stringify(a.shape)}.`)}}}let hd=(()=>{class n extends qi{constructor(e){super(e),this.isTraining=!1}summary(e,s,r=console.log){if(!this.built)throw new $("This model has never been called, thus its weights have not been created yet. So no summary can be displayed. Build the model first (e.g., by calling it on some test data).");!function Xde(n,t,e,s=console.log){const r=function Zde(n){let t=!0;const e=[],s=[];for(const r in n.nodesByDepth)e.push(n.nodesByDepth[r]);for(const r of e){if(r.length>1||1===r.length&&r[0].inboundLayers.length>1){t=!1;break}s.push(...r)}if(t)for(const r of n.layers){let i=!1;for(const o of r.inboundNodes)if(-1!==s.indexOf(o)){if(i){t=!1;break}i=!0}if(!t)break}return t}(n),i=["Layer (type)","Input Shape","Output shape","Param #"];let o;if(r?(t=t||90,e=e||[.32,.61,.89,1]):(t=t||115,e=e||[.24,.48,.7,.8,1]),e[e.length-1]<=1&&(e=e.map(c=>Math.floor(t*c))),!r){i.push("Receives inputs"),o=[];for(const c in n.nodesByDepth)o.push(...n.nodesByDepth[c])}s("_".repeat(t)),Cv(i,e,s),s("=".repeat(t));const a=n.layers;for(let c=0;c<a.length;++c)r?Qde(a[c],e,s):Jde(a[c],e,o,s),s((c===a.length-1?"=":"_").repeat(t));n.checkTrainableWeightsConsistency();const l=function Yde(n){let t;return t=dv(null!=n.collectedTrainableWeights?n.collectedTrainableWeights:n.trainableWeights),t}(n),u=dv(n.nonTrainableWeights);s(`Total params: ${l+u}`),s(`Trainable params: ${l}`),s(`Non-trainable params: ${u}`),s("_".repeat(t))}(this,e,s,r)}compile(e){if(null==e.loss&&(e.loss=[]),this.loss=e.loss,"string"==typeof e.optimizer)this.optimizer_=function Kde(n){const t={Adagrad:()=>ld.adagrad(.01),Adadelta:()=>ld.adadelta(1,.95,is()),Adam:()=>ld.adam(.001,.9,.999,is()),Adamax:()=>ld.adamax(.002,.9,.999,is(),0),RMSProp:()=>ld.rmsprop(.001,.9,0,is()),SGD:()=>ld.sgd(.01)};if(t.adagrad=t.Adagrad,t.adadelta=t.Adadelta,t.adam=t.Adam,t.adamax=t.Adamax,t.rmsprop=t.RMSProp,t.sgd=t.SGD,n in t)return t[n]();throw new $(`Unknown Optimizer ${n}`)}(e.optimizer),this.isOptimizerOwned=!0;else{if(!(e.optimizer instanceof qa))throw new $("User-defined optimizer must be an instance of tf.Optimizer.");this.optimizer_=e.optimizer,this.isOptimizerOwned=!1}let s=[];if(Array.isArray(e.loss)||"string"==typeof e.loss||"function"==typeof e.loss)if(Array.isArray(e.loss)){if(e.loss.length!==this.outputs.length)throw new $(`When passing an Array as loss, it should have one entry per model output. The model has ${this.outputs.length} output(s), but you passed loss=${e.loss}.`);s=e.loss.map(l=>dD(l))}else{const a=dD(e.loss);this.outputs.forEach(l=>{s.push(a)})}else{e.loss=e.loss;for(const a in e.loss)if(-1===this.outputNames.indexOf(a))throw new $(`Unknown entry in loss dictionary: "${a}". Only expected the following keys: ${this.outputNames}`);for(const a of this.outputNames)null==e.loss[a]&&console.warn(`Output "${a}" is missing from loss dictionary. We assume this was done on purpose, and we will not be expecting data to be passed to ${a} during training`),s.push(dD(e.loss[a]))}this.lossFunctions=s,this.feedOutputNames=[],this.feedOutputShapes=[],this.feedLossFns=[];for(let a=0;a<this.outputs.length;++a){const l=this.internalOutputShapes[a];this.feedOutputNames.push(this.outputNames[a]),this.feedOutputShapes.push(l),this.feedLossFns.push(this.lossFunctions[a])}const r=[];this.metrics=e.metrics,this.metricsNames=["loss"],this.metricsTensors=[],fu("loss",()=>{for(let a=0;a<this.outputs.length;++a)-1===r.indexOf(a)&&this.outputs.length>1&&(this.metricsTensors.push([this.lossFunctions[a],a]),this.metricsNames.push(this.outputNames[a]+"_loss"))});const i=function che(n,t){if(null==n||Array.isArray(n)&&0===n.length)return t.map(s=>[]);let e;if("string"==typeof n||"function"==typeof n)e=[n];else{if(!Array.isArray(n)&&"object"!=typeof n)throw new TypeError(`Type of metrics argument not understood. Expected an string,function, Array, or Object, found: ${n}`);e=n}if(Array.isArray(e))return t.map(s=>e);{const s=[];for(const r of t){let i=e.hasOwnProperty(r)?e[r]:[];Array.isArray(i)||(i=[i]),s.push(i)}return s}}(e.metrics,this.outputNames),o=(a,l,u)=>{this.outputNames.length>1&&(l=this.outputNames[a]+"_"+l),this.metricsNames.push(l),this.metricsTensors.push([u,a])};fu("metric",()=>{for(let a=0;a<this.outputs.length;++a)-1===r.indexOf(a)&&(c=>{let h,f,p;for(const g of c){if("string"==typeof g&&-1!==["accuracy","acc","crossentropy","ce"].indexOf(g)){const y=this.internalOutputShapes[a];let b;1===y[y.length-1]||this.lossFunctions[a]===vv?-1!==["accuracy","acc"].indexOf(g)?f=dB:-1!==["crossentropy","ce"].indexOf(g)&&(f=Lde):this.lossFunctions[a]===bv?-1!==["accuracy","acc"].indexOf(g)?f=Vde:-1!==["crossentropy","ce"].indexOf(g)&&(f=mB):-1!==["accuracy","acc"].indexOf(g)?f=hB:-1!==["crossentropy","ce"].indexOf(g)&&(f=pB),-1!==["accuracy","acc"].indexOf(g)?b="acc":-1!==["crossentropy","ce"].indexOf(g)&&(b="ce"),p=f,h=""+b}else p=qde(g),h=""+xv(g);let m;fu(h,()=>{m=p}),o(a,h,m)}})(i[a])}),this.collectedTrainableWeights=this.trainableWeights}checkTrainableWeightsConsistency(){null!=this.collectedTrainableWeights&&this.trainableWeights.length!==this.collectedTrainableWeights.length&&console.warn("Discrepancy between trainableweights and collected trainable weights. Did you set `model.trainable` without calling `model.compile()` afterwards?")}evaluate(e,s,r={}){const i=null==r.batchSize?32:r.batchSize;vD(i);const a=this.standardizeUserDataXY(e,s,!0,i);try{const l=a[0].concat(a[1]);return this.makeTestFunction(),ur(this.testLoop(this.testFunction,l,i,r.verbose,r.steps))}finally{Ki(a[0],e),Ki(a[1],s)}}evaluateDataset(e,s){var r=this;return te(function*(){return r.makeTestFunction(),function ohe(n,t,e){return bD.apply(this,arguments)}(r,e,s)})()}checkNumSamples(e,s,r,i="steps"){let o;if(null!=r){if(o=null,null!=s)throw new $(`If ${i} is set, batchSize must be null or undefined.Got batchSize = ${s}`)}else{if(null==e)throw new $(`Either the input data should have a defined shape, or ${i} shoud be specified.`);o=Array.isArray(e)?e[0].shape[0]:e.shape[0]}return o}execute(e,s){if(Array.isArray(s)&&0===s.length)throw new $("`outputs` is an empty Array, which is not allowed.");const r=Array.isArray(s),o=this.retrieveSymbolicTensors(r?s:[s]),a=new rl;if(e instanceof pn&&(e=[e]),Array.isArray(e)){if(e.length!==this.inputs.length)throw new $(`The number of inputs provided (${e.length}) does not match the number of inputs of this model (${this.inputs.length}).`);for(let u=0;u<this.inputs.length;++u)a.add(this.inputs[u],e[u])}else for(const u of this.inputs){const c=e[u.name];if(null==c)throw new $(`No value is provided for the model's input ${u.name}`);a.add(u,c)}const l=Ip(o,a);return r?l:l[0]}retrieveSymbolicTensors(e){const s=cu(null,e.length);let r=e.length;for(const i of this.layers){const o=Array.isArray(i.output)?i.output:[i.output],a=o.map(l=>l.name);for(let l=0;l<e.length;++l){const u=a.indexOf(e[l]);if(-1!==u&&(s[l]=o[u],r--),0===r)break}if(0===r)break}if(r>0){const i=[];throw s.forEach((o,a)=>{null==o&&i.push(e[a])}),new $(`Cannot find SymbolicTensors for output name(s): ${JSON.stringify(i)}`)}return s}predictLoop(e,s=32,r=!1){return z(()=>{const i=this.checkNumSamples(e);if(r)throw new ot("Verbose predictLoop() is not implemented yet.");const o=wD(i,s),a=this.outputs.map(l=>[]);for(let l=0;l<o.length;++l)z(()=>{const h=Tp(e,o[l][0],o[l][1]),f=[];if(Array.isArray(h))for(let g=0;g<h.length;++g)f.push({key:this.inputs[g],value:h[g]});else f.push({key:this.inputs[0],value:h});const p=new rl(f);return Ip(this.outputs,p)}).forEach((c,d)=>a[d].push(c));return ur(a.map(l=>jn(l,0)))})}predict(e,s={}){const r=IB(e);TB(r,this.inputNames,this.feedInputShapes,!1);try{const i=null==s.batchSize?32:s.batchSize;return vD(i),this.predictLoop(r,i)}finally{Ki(r,e)}}predictOnBatch(e){TB(e,this.inputNames,this.feedInputShapes,!0);const s=(Array.isArray(e)?e[0]:e).shape[0];return this.predictLoop(e,s)}standardizeUserDataXY(e,s,r=!0,i){if(null==this.optimizer_)throw new vi("You must compile a model before training/testing. Use LayersModel.compile(modelCompileArgs).");const o=[];for(let a=0;a<this.feedOutputShapes.length;++a){const l=this.feedOutputShapes[a];o.push(this.feedLossFns[a]===bv?l.slice(0,l.length-1).concat([1]):l)}if(function lhe(n,t,e){const s=tl(n.map(i=>i.shape[0]));s.sort();const r=tl(t.map(i=>i.shape[0]));if(r.sort(),s.length>1)throw new $(`All input Tensors (x) should have the same number of samples. Got array shapes: ${JSON.stringify(n.map(i=>i.shape))}`);if(r.length>1)throw new $(`All target Tensors (y) should have the same number of samples. Got array shapes: ${JSON.stringify(t.map(i=>i.shape))}`);if(s.length>0&&r.length>0&&!wt(s,r))throw new $(`Input Tensors should have the same number of samples as target Tensors. Found ${s[0]} input sample(s) and ${r[0]} target sample(s).`)}(e=DB(e,this.feedInputNames,this.feedInputShapes,!1,"input"),s=DB(s,this.feedOutputNames,o,!1,"target")),function uhe(n,t,e){const s=[yv,vv,Dp];for(let r=0;r<n.length;++r){const i=n[r],o=t[r],a=e[r];if(null!=o){if(o===Dp&&1===i.shape[i.shape.length-1])throw new $(`You are passing a target array of shape ${i.shape} while using a loss 'categorical_crossentropy'. 'categorical_crossentropy'expects targets to be binary matrices (1s and 0s) of shape [samples, classes].`);if(-1!==s.indexOf(o)){const l=i.shape.slice(1),u=a.slice(1);for(let c=0;c<l.length;++c){const h=u[c];if(null!=h&&l[c]!==h)throw new $(`A target Tensor with shape ${i.shape} was passed for an output of shape ${a}, while using a loss function that expects targets to have the same shape as the output.`)}}}}}(s,this.feedLossFns,this.feedOutputShapes),this.stateful&&null!=i&&i>0&&e[0].shape[0]%i!=0)throw new $(`In a stateful network, you should only pass inputs with a number of samples that is divisible by the batch size ${i}. Found: ${e[0].shape[0]} sample(s).`);return[e,s]}standardizeUserData(e,s,r,i,o=!0,a){var l=this;return te(function*(){const[u,c]=l.standardizeUserDataXY(e,s,o,a);if(null!=r)throw new Error("sample weight is not supported yet.");let d=null;if(null!=i){const h=_B(i,l.outputNames);d=[];for(let f=0;f<h.length;++f)d.push(yield wB(c[f],null,h[f]))}return[u,c,d]})()}testLoop(e,s,r,i=0,o){return z(()=>{const a=this.checkNumSamples(s,r,o,"steps"),l=[];if(i>0)throw new ot("Verbose mode is not implemented yet.");if(null!=o)throw new ot("steps mode in testLoop() is not implemented yet");{const u=wD(a,r),c=lr(Gi(0,a));for(let d=0;d<u.length;++d){const h=u[d][0],f=u[d][1],p=pu(c,h,f-h),g=_D(s,p),m=e(g);if(0===d)for(let y=0;y<m.length;++y)l.push(ze(0));for(let y=0;y<m.length;++y)l[y]=le(l[y],F(f-h,m[y]))}for(let d=0;d<l.length;++d)l[d]=Pe(l[d],a)}return l})}getDedupedMetricsNames(){const e=this.metricsNames,s=[];for(let r=0;r<e.length;++r){const i=e[r];let o=i;FV(e,i)>1&&(o+=`_${FV(e.slice(0,r),i)}`),s.push(o)}return s}makeTrainFunction(){return e=>{const s=[],r=e.slice(0,this.inputs.length),i=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),o=e.slice(this.inputs.length+this.outputs.length,this.inputs.length+2*this.outputs.length),a=[],u=this.collectedTrainableWeights.map(h=>h.read());return[this.optimizer_.minimize(()=>{const h=[];for(let m=0;m<this.inputs.length;++m)h.push({key:this.inputs[m],value:r[m]});const f=new rl(h),p=Ip(this.outputs,f,{training:!0});let g;for(let m=0;m<this.lossFunctions.length;++m){let b=(0,this.lossFunctions[m])(i[m],p[m]);null!=o[m]&&(b=ehe(b,o[m]));const v=Nn(b);s.push(v),g=0===m?b:le(g,b)}for(let m=0;m<this.metricsTensors.length;++m){let y;if(this.outputs.length>1&&m<this.outputs.length)y=s[m];else{const v=this.metricsTensors[m][1];y=Nn((0,this.metricsTensors[m][0])(i[v],p[v]))}vs(y),a.push(y)}return g=Nn(g),this.calculateLosses().forEach(m=>{g=le(g,m)}),g},!0,u)].concat(a)}}makeTestFunction(){this.testFunction=e=>z(()=>{const s=[];let r;const i=e.slice(0,this.inputs.length),o=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),a=[];for(let c=0;c<this.inputs.length;++c)a.push({key:this.inputs[c],value:i[c]});const l=new rl(a),u=Ip(this.outputs,l);for(let c=0;c<this.lossFunctions.length;++c){const h=Nn((0,this.lossFunctions[c])(o[c],u[c]));r=0===c?h:le(r,h),s.push(r)}for(let c=0;c<this.metricsTensors.length;++c){const h=this.metricsTensors[c][1],f=Nn((0,this.metricsTensors[c][0])(o[h],u[h]));s.push(f)}return s})}fit(e,s,r={}){var i=this;return te(function*(){if(i.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");let o,a,l,u,c,d,h,f,p;i.isTraining=!0;try{const g=null==r.batchSize?32:r.batchSize;vD(g);const m=!1,y=yield i.standardizeUserData(e,s,r.sampleWeight,r.classWeight,m,g);o=y[0],a=y[1],p=y[2];let v,b=!1;if(null!=r.validationData&&r.validationData.length>0){if(b=!0,2!==r.validationData.length)throw 3===r.validationData.length?new ot("validationData including sample weights is not supported yet."):new $(`When passing validation data, it must contain 2 (valX, valY) or 3 (valX, valY, valSampleWeight) items; ${r.validationData} is invalid.`);c=r.validationData[0],d=r.validationData[1];const V=!0,G=yield i.standardizeUserData(c,d,null,null,V,g);h=G[0],f=G[1],v=h.concat(f)}else if(null!=r.validationSplit&&r.validationSplit>0&&r.validationSplit<1){b=!0;const V=Math.floor(o[0].shape[0]*(1-r.validationSplit)),G=o[0].shape[0];h=Tp(o,V,G),l=o,o=Tp(o,0,V),f=Tp(a,V,G),u=a,a=Tp(a,0,V),v=h.concat(f)}else null!=r.validationSteps&&(b=!0);const _=o.concat(a).concat(p);i.checkTrainableWeightsConsistency();const x=i.makeTrainFunction(),C=i.getDedupedMetricsNames();let E,D;b?(i.makeTestFunction(),E=i.testFunction,D=C.slice().concat(C.map(V=>"val_"+V))):(E=null,v=[],D=C.slice());const N=lB(r.callbacks,r.yieldEvery);return yield i.fitLoop(x,_,C,g,r.epochs,r.verbose,N,E,v,r.shuffle,D,r.initialEpoch,null,null)}finally{i.isTraining=!1,Ki(o,e),Ki(a,s),Ki(l,e),Ki(u,s),Ki(h,c),Ki(f,d),null!=p&&gt(p)}})()}fitLoop(e,s,r,i,o,a,l,u,c,d,h,f,p,g){var m=this;return te(function*(){null==i&&(i=32),null==o&&(o=1),null==d&&(d=!0),null==f&&(f=0);let y=!1;if(null!=u&&null!=c&&(y=!0),null!=g&&(y=!0,null==p))throw new $("Can only use `validationSteps` when doing step-wise training, i.e., `stepsPerEpoch` must be set.");const b=m.checkNumSamples(s,i,p,"steps_per_epoch");let v;null!=b&&(v=Gi(0,b)),null==a&&(a=1);const{callbackList:_,history:x}=uB(l,a,o,f,b,p,i,y,h);_.setModel(m),m.history=x,yield _.onTrainBegin(),m.stopTraining_=!1;for(let C=f;C<o;++C){yield _.onEpochBegin(C);const E={};if(null!=p)throw new ot("stepsPerEpoch mode is not implemented yet.");{if("batch"===d)throw new ot("batch shuffling is not implemneted yet");d&&T2(v);const D=lr(v),N=wD(b,i);for(let R=0;R<N.length;++R){const V={};if(yield _.onBatchBegin(R,V),z(()=>{const G=N[R][0],j=N[R][1],q=pu(D,G,j-G);V.batch=R,V.size=j-G;const K=_D(s,q),P=e(K);for(let B=0;B<r.length;++B){const H=P[B];V[r[B]]=H,vs(H)}if(R===N.length-1&&y){const B=m.testLoop(u,c,i);for(let L=0;L<r.length;++L){const H=r[L],se=B[L];vs(se),E["val_"+H]=se}}}),yield _.onBatchEnd(R,V),aB(V),m.stopTraining_)break}D.dispose()}if(yield _.onEpochEnd(C,E),m.stopTraining_)break}return yield _.onTrainEnd(),yield m.history.syncData(),m.history})()}fitDataset(e,s){var r=this;return te(function*(){return function she(n,t,e){return yD.apply(this,arguments)}(r,e,s)})()}trainOnBatch(e,s){var r=this;return te(function*(){const i=yield r.standardizeUserData(e,s),o=i[0],a=i[1],u=r.makeTrainFunction()(o.concat(a)),c=[];for(const d of u){const h=yield d.data();c.push(h[0])}return gt(u),Ki(i[0],e),Ki(i[1],s),ur(c)})()}getNamedWeights(e){const s=[],r=null!=e&&e.trainableOnly,i=r?this.trainableWeights:this.weights,o=this.getWeights(r);for(let a=0;a<i.length;++a)r&&!i[a].trainable||s.push({name:i[a].originalName,tensor:o[a]});return s}set stopTraining(e){this.stopTraining_=e}get stopTraining(){return this.stopTraining_}get optimizer(){return this.optimizer_}set optimizer(e){this.optimizer_!==e&&(this.optimizer_=e,this.isOptimizerOwned=!1)}dispose(){const e=super.dispose();if(0===e.refCountAfterDispose&&null!=this.optimizer&&this.isOptimizerOwned){const s=_I().numTensors;this.optimizer_.dispose(),e.numDisposedVariables+=s-_I().numTensors}return e}getLossIdentifiers(){let e;if("string"==typeof this.loss)e=ha(this.loss);else if(Array.isArray(this.loss)){for(const s of this.loss)if("string"!=typeof s)throw new Error("Serialization of non-string loss is not supported.");e=this.loss.map(s=>ha(s))}else{const s=Object.keys(this.loss);e={};const r=this.loss;for(const i of s){if("string"!=typeof r[i])throw new Error("Serialization of non-string loss is not supported.");e[i]=ha(r[i])}}return e}getMetricIdentifiers(){if("string"==typeof this.metrics||"function"==typeof this.metrics)return[ha(xv(this.metrics))];if(Array.isArray(this.metrics))return this.metrics.map(e=>ha(xv(e)));{const e={};for(const s in this.metrics)e[s]=ha(xv(this.metrics[s]));return e}}getTrainingConfig(){return{loss:this.getLossIdentifiers(),metrics:this.getMetricIdentifiers(),optimizer_config:{class_name:this.optimizer.getClassName(),config:this.optimizer.getConfig()}}}loadTrainingConfig(e){if(null!=e.weighted_metrics)throw new Error("Loading weight_metrics is not supported yet.");if(null!=e.loss_weights)throw new Error("Loading loss_weights is not supported yet.");if(null!=e.sample_weight_mode)throw new Error("Loading sample_weight_mode is not supported yet.");const r=fa(fD(e.optimizer_config));let i,o;if("string"==typeof e.loss)i=du(e.loss);else if(Array.isArray(e.loss))i=e.loss.map(a=>du(a));else if(null!=e.loss){i={};for(const a in e.loss)i[a]=du(e.loss[a])}if(Array.isArray(e.metrics))o=e.metrics.map(a=>du(a));else if(null!=e.metrics){o={};for(const a in e.metrics)o[a]=du(e.metrics[a])}this.compile({loss:i,metrics:o,optimizer:r})}save(e,s){var r=this;return te(function*(){if("string"==typeof e){const d=cP(e);if(0===d.length)throw new $(`Cannot find any save handlers for URL '${e}'`);if(d.length>1)throw new $(`Found more than one (${d.length}) save handlers for URL '${e}'`);e=d[0]}if(null==e.save)throw new $("LayersModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");const i=yield oI(r.getNamedWeights(s)),u={modelTopology:r.toJSON(null,!1),format:"layers-model",generatedBy:"TensorFlow.js tfjs-layers v4.5.0",convertedBy:null};if(null!=s&&s.includeOptimizer&&null!=r.optimizer){u.trainingConfig=r.getTrainingConfig();const d="optimizer",{data:h,specs:f}=yield oI(yield r.optimizer.getWeights(),d);i.specs.push(...f),i.data=Eb([i.data,h])}return null!=r.userDefinedMetadata&&(yB(r.userDefinedMetadata,r.name,!0),u.userDefinedMetadata=r.userDefinedMetadata),u.weightData=i.data,u.weightSpecs=i.specs,e.save(u)})()}setUserDefinedMetadata(e){yB(e,this.name),this.userDefinedMetadata=e}getUserDefinedMetadata(){return this.userDefinedMetadata}}return n.className="Model",n})();ue(hd),ue((()=>{class n extends hd{}return n.className="Functional",n})()),ue((()=>{class n extends hd{constructor(e){if(super({inputs:[],outputs:[]}),e=e||{},this.trainable=!0,this.built=!1,this.name=null!=e.name?e.name:ov("sequential_"),null!=e.layers)for(const s of e.layers)this.add(s)}checkShape(e){if(e.inboundNodes[0].outputTensors[0].shape.some(r=>r<0))throw new $(`Negative dimension size caused by adding layer ${e.name} with input shape [${e.inboundNodes[0].inputTensors[0].shape}]`)}add(e){const s=e instanceof n||e instanceof hd;let r;if(s){if(r=e,1!==r.outputs.length)throw new $("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");if(1!==r.inputs.length)throw new $("All layers in a Sequential model should have a single input tensor. For multi-input layers, use the functional API.")}if(0===this.outputs.length){if(0===e.inboundNodes.length){if(null==e.batchInputShape)throw new $("The first layer in a Sequential model must get an `inputShape` or `batchInputShape` argument.");const i=function mde(n){if(null==n.batchShape&&null==n.shape)throw new Error("Please provide to Input either a `shape` or a `batchShape` argument. Note that `shape` does not include the batch dimension.");if(null!=n.batchShape&&null!=n.shape)throw new $("Please provide either a `shape` or `batchShape` argument to Input, but not both.");let t=n.batchShape;null!=n.shape&&null==t&&(t=[null].concat(n.shape));let e=n.dtype;return null==e&&(e="float32"),new fv({batchInputShape:t,name:n.name,dtype:e,sparse:n.sparse}).inboundNodes[0].outputTensors[0]}({batchShape:e.batchInputShape,dtype:e.dtype,name:e.name+"_input"});e.apply(i)}if(s)this.outputs=r.outputs,this.inputs=r.inputs;else{if(1!==e.inboundNodes.length)throw new $(`A layer added to a Sequential model must not already be connected somewhere else. LayersModel received layer ${e.name} which has ${e.inboundNodes.length} pre-existing inbound connections.`);if(1!==e.inboundNodes[0].outputTensors.length)throw new $("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(e),this.outputs=[e.inboundNodes[0].outputTensors[0]],this.inputs=sB(this.outputs[0])}this.inboundNodes=[],new hv({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:cu(null,this.inputs.length),outputMasks:[null],inputShapes:this.inputs.map(i=>i.shape),outputShapes:this.outputs[0].shape})}else{const i=e.apply(this.outputs[0]);if(Array.isArray(i))throw new TypeError("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(e),this.outputs=[i],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}this.layers.push(e),this.built=!1}pop(){if(0===this.layers.length)throw new TypeError("There are no layers in the model.");if(this.layers.pop(),0===this.layers.length)this.outputs=[],this.inboundNodes=[],this.outboundNodes=[];else{const e=this.layers.length-1;this.layers[e].outboundNodes=[],this.outputs=[this.layers[e].output],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}}call(e,s){return null==this.model&&this.build(),this.model.call(e,s)}build(e){if(Mt(e),0===this.inputs.length||0===this.outputs.length)throw new TypeError("Sequential model cannot be built: model is empty. Add some layers first.");this.model=new hd({inputs:this.inputs,outputs:this.outputs[0],name:this.name+"_model"}),this.model.trainable=this.trainable,this.supportsMasking=this.model.supportsMasking,this.inputLayers=this.model.inputLayers,this.inputLayersNodeIndices=this.model.inputLayersNodeIndices,this.inputLayersTensorIndices=this.model.inputLayersTensorIndices,this.outputLayers=this.model.outputLayers,this.outputLayersNodeIndices=this.model.outputLayersNodeIndices,this.outputLayersTensorIndices=this.model.outputLayersTensorIndices,this.nodesByDepth=this.model.nodesByDepth,this.containerNodes=this.model.containerNodes,this.outputNames=this.model.outputNames,this.inputNames=this.model.inputNames,this.built=!0}countParams(){return this.built||this.build(),super.countParams()}summary(e,s,r=console.log){this.built||this.build(),super.summary(e,s,r)}setWeights(e){null==this.model&&this.build(),this.model.setWeights(e)}evaluate(e,s,r={}){if(!this.built)throw new vi("The model needs to be compiled before being used.");return this.model.evaluate(e,s,r)}evaluateDataset(e,s){var r=this;return te(function*(){if(!r.built)throw new vi("The model needs to be compiled before being used.");return r.model.evaluateDataset(e,s)})()}predict(e,s={}){return null==this.model&&this.build(),this.model.predict(e,s)}predictOnBatch(e){return null==this.model&&this.build(),this.model.predictOnBatch(e)}compile(e){this.build(),this.model.compile(e),this.optimizer_=this.model.optimizer,this.isOptimizerOwned=this.model.isOptimizerOwned,this.loss=this.model.loss,this.metrics=this.model.metrics,this.metricsTensors=this.model.metricsTensors,this.metricsNames=this.model.metricsNames}get optimizer(){return null==this.model?void 0:this.model.optimizer}set optimizer(e){this.model.optimizer=e}fit(e,s,r={}){var i=this;return te(function*(){if(!i.built)throw new vi("The model needs to be compiled before being used.");return i.model.fit(e,s,r)})()}fitDataset(e,s){var r=this;return te(function*(){if(!r.built)throw new vi("The model needs to be compiled before being used.");return r.model.fitDataset(e,s)})()}trainOnBatch(e,s){var r=this;return te(function*(){return r.model.trainOnBatch(e,s)})()}static fromConfig(e,s,r={},i=!1){let o,a={};if(s instanceof Array){if(null==s[0].className||"Merge"===s[0].className)throw new $("Legacy serialization format not supported yet.");o=s}else S(null!=s.layers,()=>"When the config data for a Sequential model is not an Array, it must be an Object that contains the 'layers' field."),o=s.layers,delete s.layers,a=s;const l=new e(a);if(!(l instanceof n))throw new ot(`Sequential.fromConfig called on non-Sequential input: ${l}`);for(const u of o){const d=fa(u,void 0,i);i&&d.setFastWeightInitDuringBuild(!0),l.add(d)}return l}set stopTraining(e){if(null==this.model)throw new $("Cannot set the stopTraining property of a sequential model before it is compiled.");this.model.stopTraining=e}get stopTraining(){if(null==this.model)throw new $("Cannot get the stopTraining property of a sequential model before it is compiled.");return this.model.stopTraining}getConfig(){const e=[];for(const s of this.layers){const r={};r.className=s.getClassName(),r.config=s.getConfig(),e.push(r)}return{name:this.name,layers:e}}}return n.className="Sequential",n})());class cr extends Xc{getConfig(){return{}}}ue((()=>{class n extends cr{apply(e,s=1){return function nde(n,t=1){if(1!==t)throw new ot(`Support for alpha values other than 1 (${t}) is not implemented yet.`);return lp(n)}(e,s)}}return n.className="elu",n})()),ue((()=>{class n extends cr{apply(e){return sE(e)}}return n.className="selu",n})()),ue((()=>{class n extends cr{apply(e){return xo(e)}}return n.className="relu",n})()),ue((()=>{class n extends cr{apply(e){return z(()=>ou(6,xo(e)))}}return n.className="relu6",n})()),ue((()=>{class n extends cr{apply(e){return e}}return n.className="linear",n})()),ue((()=>{class n extends cr{apply(e){return _o(e)}}return n.className="sigmoid",n})()),ue((()=>{class n extends cr{apply(e){return function rde(n){return z(()=>{const t=le(.5,F(.2,n));return Er(t,0,1)})}(e)}}return n.className="hardSigmoid",n})()),ue((()=>{class n extends cr{apply(e){return nd(e)}}return n.className="softplus",n})()),ue((()=>{class n extends cr{apply(e){return function sde(n){return z(()=>Pe(n,le(ns(n),1)))}(e)}}return n.className="softsign",n})()),ue((()=>{class n extends cr{apply(e){return ed(e)}}return n.className="tanh",n})());let NB=(()=>{class n extends cr{apply(e,s=-1){return Kb(e,s)}}return n.className="softmax",n})();function ol(n){return n.getClassName()}function ED(n,t={}){return _p(n,fi.getMap().classNameMap,t,"activation")}function al(n){if(null==n){return ED({className:"linear",config:{}})}if("string"==typeof n){const t={};return t.className=n,t.config={},ED(t)}return n instanceof cr?n:ED(n)}ue(NB),ue((()=>{class n extends cr{apply(e,s=-1){return jI(e,s)}}return n.className="logSoftmax",n})()),ue((()=>{class n extends cr{apply(e,s=1){return z(()=>F(_o(F(e,s)),e))}}return n.className="swish",n})()),ue((()=>{class n extends cr{apply(e){return z(()=>F(e,ed(nd(e))))}}return n.className="mish",n})());class kB extends Xc{}ue((()=>{class n extends kB{constructor(e){super(),function DD(n){if(null!=n&&"object"!=typeof n)throw new Error(`Argument to L1L2 regularizer's constructor is expected to be an object, but received: ${n}`)}(e),this.l1=null==e||null==e.l1?.01:e.l1,this.l2=null==e||null==e.l2?.01:e.l2,this.hasL1=0!==this.l1,this.hasL2=0!==this.l2}apply(e){return z(()=>{let s=rs([1]);return this.hasL1&&(s=le(s,Re(F(this.l1,ns(e))))),this.hasL2&&(s=le(s,Re(F(this.l2,Cp(e))))),O(s,[])})}getConfig(){return{l1:this.l1,l2:this.l2}}static fromConfig(e,s){return new e({l1:s.l1,l2:s.l2})}}return n.className="L1L2",n})());const AB={l1l2:"L1L2"};function tn(n){return ZE(n)}function RB(n,t={}){return _p(n,fi.getMap().classNameMap,t,"regularizer")}function gn(n){return null==n?null:"string"==typeof n?RB({className:n in AB?AB[n]:n,config:{}}):n instanceof kB?n:RB(n)}function fd(n,t,e){if("number"==typeof n)return cu(n,t);if(n.length!==t)throw new $(`The ${e} argument must be an integer or tuple of ${t} integers. Received: ${n.length} elements.`);for(let s=0;s<t;++s){const r=n[s];if(!Yce(r))throw new $(`The ${e} argument must be an integer or tuple of ${t} integers. Received: ${JSON.stringify(n)} including a non-integer number ${r}`)}return n}function Xi(n,t,e,s,r=1){if(null==n)return n;let o;return o="same"===e?n:n-(t+(t-1)*(r-1))+1,Math.floor((o+s-1)/s)}function ko(n,t,e,s){if(null==n)return null;if("valid"===s)n=n*t+sl([e-t,0]);else{if("same"!==s)throw new $(`Unsupport padding mode: ${s}.`);n*=t}return n}function ND(n,t){return z(()=>(Pn(t),"channelsFirst"===t?Tt(n,[0,2,3,1]):n))}function MB(n,t){return z(()=>(Pn(t),"channelsFirst"===t?Tt(n,[0,2,3,4,1]):n))}function kD(n,t,e,s=[1,1],r="valid",i,o,a=null){return z(()=>{if(null==i&&(i="channelsLast"),Pn(i),3!==n.rank&&4!==n.rank)throw new $(`conv2dWithBiasActivation expects input to be of rank 3 or 4, but received ${n.rank}.`);if(3!==t.rank&&4!==t.rank)throw new $(`conv2dWithBiasActivation expects kernel to be of rank 3 or 4, but received ${n.rank}.`);let l=ND(n,i);if("causal"===r)throw new ot("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");return l=zL({x:l,filter:t,strides:s,pad:"same"===r?"same":"valid",dilations:o,dataFormat:"NHWC",bias:e,activation:a}),"channelsFirst"===i&&(l=Tt(l,[0,3,1,2])),l})}ue((()=>{class n extends yt{constructor(e){super(e??{}),this.supportsMasking=!0,null!=e&&(this.maxValue=e.maxValue)}call(e,s){e=Ke(e);let r=xo(e);return null!=this.maxValue&&(r=Er(r,0,this.maxValue)),r}computeOutputShape(e){return e}getConfig(){const e={maxValue:this.maxValue},s=super.getConfig();return Object.assign(e,s),e}}return n.className="ReLU",n})()),ue((()=>{class n extends yt{constructor(e){super(e??{}),this.DEFAULT_ALPHA=.3,null==e&&(e={}),this.alpha=null==e.alpha?this.DEFAULT_ALPHA:e.alpha}call(e,s){const r=Ke(e);return Pb(r,this.alpha)}computeOutputShape(e){return e}getConfig(){const e={alpha:this.alpha},s=super.getConfig();return Object.assign(e,s),e}}return n.className="LeakyReLU",n})()),ue((()=>{class n extends yt{constructor(e){if(super(e??{}),this.DEFAULT_ALPHA_INITIALIZER="zeros",null==e&&(e={}),this.supportsMasking=!0,this.alphaInitializer=mn(e.alphaInitializer||this.DEFAULT_ALPHA_INITIALIZER),this.alphaRegularizer=gn(e.alphaRegularizer),this.alphaConstraint=ls(e.alphaConstraint),null==e.sharedAxes)this.sharedAxes=null;else if(Array.isArray(e.sharedAxes))this.sharedAxes=e.sharedAxes;else{if("number"!=typeof e.sharedAxes)throw new $(`Expected sharedAxes to be a number or an array of numbers, but got ${e.sharedAxes}`);this.sharedAxes=[e.sharedAxes]}}build(e){const s=(e=Mt(e)).slice(1);if(null!=this.sharedAxes)for(const i of this.sharedAxes)s[i-1]=1;this.alpha=this.addWeight("alpha",s,"float32",this.alphaInitializer,this.alphaRegularizer,!0,this.alphaConstraint);const r={};if(null!=this.sharedAxes)for(let i=1;i<e.length;++i)r[i]=e[i];this.inputSpec=[new os({ndim:e.length,axes:r})],this.built=!0}call(e,s){return e=Ke(e),Gb(e,this.alpha.read())}getConfig(){const e={alphaInitializer:xn(this.alphaInitializer),alphaRegularizer:tn(this.alphaRegularizer),alphaConstraint:as(this.alphaConstraint),sharedAxes:this.sharedAxes},s=super.getConfig();return Object.assign(e,s),e}}return n.className="PReLU",n})()),ue((()=>{class n extends yt{constructor(e){if(super(e??{}),this.DEFAULT_ALPHA=1,null==e&&(e={}),null!=e.alpha&&e.alpha!==this.DEFAULT_ALPHA)throw new ot(`Non-default alpha value (${e.alpha}) is not supported by the ELU layer yet.`);this.alpha=null==e.alpha?this.DEFAULT_ALPHA:e.alpha}call(e,s){const r=Ke(e);return lp(r)}computeOutputShape(e){return e}getConfig(){const e={alpha:this.alpha},s=super.getConfig();return Object.assign(e,s),e}}return n.className="ELU",n})()),ue((()=>{class n extends yt{constructor(e){super(e??{}),this.DEFAULT_THETA=1,null==e&&(e={}),this.theta=null==e.theta?this.DEFAULT_THETA:e.theta}call(e,s){const r=Ke(e);return F(r,xe(Dr(r,this.theta),"float32"))}computeOutputShape(e){return e}getConfig(){const e={theta:this.theta},s=super.getConfig();return Object.assign(e,s),e}}return n.className="ThresholdedReLU",n})()),ue((()=>{class n extends yt{constructor(e){super(e??{}),this.DEFAULT_AXIS=1,null==e&&(e={}),this.softmax=(new NB).apply,this.axis=null==e.axis?this.DEFAULT_AXIS:e.axis}call(e,s){const r=Ke(e);return this.softmax(r,this.axis)}computeOutputShape(e){return e}getConfig(){const e={axis:this.axis},s=super.getConfig();return Object.assign(e,s),e}}return n.className="Softmax",n})());class Sv extends yt{constructor(t,e){if(super(e),this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",Sv.verifyArgs(e),this.rank=t,xs(this.rank,"rank"),1!==this.rank&&2!==this.rank&&3!==this.rank)throw new ot(`Convolution layer for rank other than 1, 2, or 3 (${this.rank}) is not implemented yet.`);if(this.kernelSize=fd(e.kernelSize,t,"kernelSize"),this.strides=fd(null==e.strides?1:e.strides,t,"strides"),this.padding=null==e.padding?"valid":e.padding,Zr(this.padding),this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,Pn(this.dataFormat),this.activation=al(e.activation),this.useBias=null==e.useBias||e.useBias,this.biasInitializer=mn(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.biasConstraint=ls(e.biasConstraint),this.biasRegularizer=gn(e.biasRegularizer),this.activityRegularizer=gn(e.activityRegularizer),this.dilationRate=fd(null==e.dilationRate?1:e.dilationRate,t,"dilationRate"),1===this.rank&&Array.isArray(this.dilationRate)&&1!==this.dilationRate.length)throw new $(`dilationRate must be a number or an array of a single number for 1D convolution, but received ${JSON.stringify(this.dilationRate)}`);if(2===this.rank){if("number"==typeof this.dilationRate)this.dilationRate=[this.dilationRate,this.dilationRate];else if(2!==this.dilationRate.length)throw new $(`dilationRate must be a number or array of two numbers for 2D convolution, but received ${JSON.stringify(this.dilationRate)}`)}else if(3===this.rank)if("number"==typeof this.dilationRate)this.dilationRate=[this.dilationRate,this.dilationRate,this.dilationRate];else if(3!==this.dilationRate.length)throw new $(`dilationRate must be a number or array of three numbers for 3D convolution, but received ${JSON.stringify(this.dilationRate)}`)}static verifyArgs(t){if(Yr("kernelSize"in t,"required key 'kernelSize' not in config"),"number"!=typeof t.kernelSize&&!JE(t.kernelSize,"number",1,3))throw new $(`BaseConv expects config.kernelSize to be number or number[] with length 1, 2, or 3, but received ${JSON.stringify(t.kernelSize)}.`)}getConfig(){const t={kernelSize:this.kernelSize,strides:this.strides,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,activation:ol(this.activation),useBias:this.useBias,biasInitializer:xn(this.biasInitializer),biasRegularizer:tn(this.biasRegularizer),activityRegularizer:tn(this.activityRegularizer),biasConstraint:as(this.biasConstraint)},e=super.getConfig();return Object.assign(t,e),t}}class pd extends Sv{constructor(t,e){super(t,e),this.kernel=null,pd.verifyArgs(e),this.filters=e.filters,xs(this.filters,"filters"),this.kernelInitializer=mn(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.kernelConstraint=ls(e.kernelConstraint),this.kernelRegularizer=gn(e.kernelRegularizer)}build(t){t=Mt(t);const e="channelsFirst"===this.dataFormat?1:t.length-1;if(null==t[e])throw new $(`The channel dimension of the input should be defined. Found ${t[e]}`);const s=t[e],r=this.kernelSize.concat([s,this.filters]);this.kernel=this.addWeight("kernel",r,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[{ndim:this.rank+2,axes:{[e]:s}}],this.built=!0}call(t,e){return z(()=>{let s;t=Ke(t);const r=null==this.bias?null:this.bias.read(),i=$V(this.activation.getClassName());if(null!=i&&2===this.rank)s=kD(t,this.kernel.read(),r,this.strides,this.padding,this.dataFormat,this.dilationRate,i);else{if(1===this.rank)s=function FB(n,t,e,s=1,r="valid",i,o=1){return z(()=>{if(null==i&&(i="channelsLast"),Pn(i),3!==n.shape.length)throw new $(`The input of a conv1dWithBias operation should be 3, but is ${n.shape.length} instead.`);if(3!==t.shape.length)throw new $(`The kernel for a conv1dWithBias operation should be 3, but is ${t.shape.length} instead`);if(null!=e&&1!==e.shape.length)throw new $(`The bias for a conv1dWithBias operation should be 1, but is ${t.shape.length} instead`);if("channelsFirst"===i&&(n=Tt(n,[0,2,1])),"causal"===r)throw new ot("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");let a=LI(n,t,s,"same"===r?"same":"valid","NWC",o);return null!=e&&(a=ji(a,e)),a})}(t,this.kernel.read(),r,this.strides[0],this.padding,this.dataFormat,this.dilationRate[0]);else if(2===this.rank)s=kD(t,this.kernel.read(),r,this.strides,this.padding,this.dataFormat,this.dilationRate);else{if(3!==this.rank)throw new ot("convolutions greater than 3D are not implemented yet.");s=function OB(n,t,e,s=[1,1,1],r="valid",i,o){return z(()=>{if(null==i&&(i="channelsLast"),Pn(i),4!==n.rank&&5!==n.rank)throw new $(`conv3dWithBias expects input to be of rank 4 or 5, but received ${n.rank}.`);if(4!==t.rank&&5!==t.rank)throw new $(`conv3dWithBias expects kernel to be of rank 4 or 5, but received ${n.rank}.`);let a=MB(n,i);if("causal"===r)throw new ot("The support for CAUSAL padding mode in conv3dWithBias is not implemented yet.");return a=aL(a,t,s,"same"===r?"same":"valid","NDHWC",o),null!=e&&(a=ji(a,e)),"channelsFirst"===i&&(a=Tt(a,[0,4,1,2,3])),a})}(t,this.kernel.read(),r,this.strides,this.padding,this.dataFormat,this.dilationRate)}null!=this.activation&&(s=this.activation.apply(s))}return s})}computeOutputShape(t){t=Mt(t);const e=[],s="channelsLast"===this.dataFormat?t.slice(1,t.length-1):t.slice(2);for(let i=0;i<s.length;++i){const o=Xi(s[i],this.kernelSize[i],this.padding,this.strides[i],"number"==typeof this.dilationRate?this.dilationRate:this.dilationRate[i]);e.push(o)}let r=[t[0]];return"channelsLast"===this.dataFormat?(r=r.concat(e),r.push(this.filters)):(r.push(this.filters),r=r.concat(e)),r}getConfig(){const t={filters:this.filters,kernelInitializer:xn(this.kernelInitializer),kernelRegularizer:tn(this.kernelRegularizer),kernelConstraint:as(this.kernelConstraint)},e=super.getConfig();return Object.assign(t,e),t}static verifyArgs(t){if(!("filters"in t)||"number"!=typeof t.filters||t.filters<1)throw new $(`Convolution layer expected config.filters to be a 'number' > 0 but got ${JSON.stringify(t.filters)}`)}}let $B=(()=>{class n extends pd{constructor(e){super(2,e),n.verifyArgs(e)}getConfig(){const e=super.getConfig();return delete e.rank,e}static verifyArgs(e){if("number"!=typeof e.kernelSize&&!JE(e.kernelSize,"number",1,2))throw new $(`Conv2D expects config.kernelSize to be number or number[] with length 1 or 2, but received ${JSON.stringify(e.kernelSize)}.`)}}return n.className="Conv2D",n})();ue($B);let PB=(()=>{class n extends pd{constructor(e){super(3,e),n.verifyArgs(e)}getConfig(){const e=super.getConfig();return delete e.rank,e}static verifyArgs(e){if("number"!=typeof e.kernelSize&&(!Array.isArray(e.kernelSize)||1!==e.kernelSize.length&&3!==e.kernelSize.length))throw new $(`Conv3D expects config.kernelSize to be number or [number, number, number], but received ${JSON.stringify(e.kernelSize)}.`)}}return n.className="Conv3D",n})();ue(PB),ue((()=>{class n extends $B{constructor(e){if(super(e),this.inputSpec=[new os({ndim:4})],"same"!==this.padding&&"valid"!==this.padding)throw new $(`Conv2DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(e){if(4!==(e=Mt(e)).length)throw new $("Input should have rank 4; Received input shape: "+JSON.stringify(e));const s="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[s])throw new $("The channel dimension of the inputs should be defined. Found `None`.");const r=e[s],i=this.kernelSize.concat([this.filters,r]);this.kernel=this.addWeight("kernel",i,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new os({ndim:4,axes:{[s]:r}})],this.built=!0}call(e,s){return z(()=>{let r=Ke(e);if(4!==r.shape.length)throw new $(`Conv2DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${r.shape.length}`);const i=r.shape;let a,l;"channelsFirst"===this.dataFormat?(a=2,l=3):(a=1,l=2);const c=i[l],h=this.kernelSize[1],p=this.strides[1],y=[i[0],ko(i[a],this.strides[0],this.kernelSize[0],this.padding),ko(c,p,h,this.padding),this.filters];"channelsLast"!==this.dataFormat&&(r=Tt(r,[0,2,3,1]));let b=BI(r,this.kernel.read(),y,this.strides,this.padding);return"channelsLast"!==this.dataFormat&&(b=Tt(b,[0,3,1,2])),null!=this.bias&&(b=ji(b,this.bias.read(),this.dataFormat)),null!=this.activation&&(b=this.activation.apply(b)),b})}computeOutputShape(e){const s=(e=Mt(e)).slice();let r,i,o;"channelsFirst"===this.dataFormat?(r=1,i=2,o=3):(r=3,i=1,o=2);const a=this.kernelSize[0],l=this.kernelSize[1],u=this.strides[0],c=this.strides[1];return s[r]=this.filters,s[i]=ko(s[i],u,a,this.padding),s[o]=ko(s[o],c,l,this.padding),s}getConfig(){const e=super.getConfig();return delete e.dilationRate,e}}return n.className="Conv2DTranspose",n})()),ue((()=>{class n extends PB{constructor(e){if(super(e),this.inputSpec=[new os({ndim:5})],"same"!==this.padding&&"valid"!==this.padding)throw new $(`Conv3DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(e){if(5!==(e=Mt(e)).length)throw new $("Input should have rank 5; Received input shape: "+JSON.stringify(e));const s="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[s])throw new $("The channel dimension of the inputs should be defined. Found `None`.");const r=e[s],i=this.kernelSize.concat([this.filters,r]);this.kernel=this.addWeight("kernel",i,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new os({ndim:5,axes:{[s]:r}})],this.built=!0}call(e,s){return z(()=>{let r=Ke(e);if(5!==r.shape.length)throw new $(`Conv3DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${r.shape.length}`);const i=r.shape;let a,l,u;"channelsFirst"===this.dataFormat?(u=2,a=3,l=4):(u=1,a=2,l=3);const d=i[a],h=i[l],p=this.kernelSize[1],g=this.kernelSize[2],y=this.strides[1],b=this.strides[2],C=[i[0],ko(i[u],this.strides[0],this.kernelSize[0],this.padding),ko(d,y,p,this.padding),ko(h,b,g,this.padding),this.filters];"channelsLast"!==this.dataFormat&&(r=Tt(r,[0,2,3,4,1]));let E=uL(r,this.kernel.read(),C,this.strides,this.padding);return"channelsLast"!==this.dataFormat&&(E=Tt(E,[0,4,1,2,3])),null!==this.bias&&(E=ji(E,this.bias.read(),this.dataFormat)),null!==this.activation&&(E=this.activation.apply(E)),E})}computeOutputShape(e){const s=(e=Mt(e)).slice();let r,i,o,a;"channelsFirst"===this.dataFormat?(r=1,i=2,o=3,a=4):(r=4,i=1,o=2,a=3);const l=this.kernelSize[0],u=this.kernelSize[1],c=this.kernelSize[2],d=this.strides[0],h=this.strides[1],f=this.strides[2];return s[r]=this.filters,s[i]=ko(s[i],d,l,this.padding),s[o]=ko(s[o],h,u,this.padding),s[a]=ko(s[a],f,c,this.padding),s}getConfig(){const e=super.getConfig();return delete e.dilationRate,e}}return n.className="Conv3DTranspose",n})());let phe=(()=>{class n extends pd{constructor(e,s){if(super(e,s),this.DEFAULT_DEPTHWISE_INITIALIZER="glorotUniform",this.DEFAULT_POINTWISE_INITIALIZER="glorotUniform",this.depthwiseKernel=null,this.pointwiseKernel=null,null==s.filters)throw new $("The `filters` configuration field is required by SeparableConv, but is unspecified.");if(null!=s.kernelInitializer||null!=s.kernelRegularizer||null!=s.kernelConstraint)throw new $("Fields kernelInitializer, kernelRegularizer and kernelConstraint are invalid for SeparableConv2D. Use depthwiseInitializer, depthwiseRegularizer, depthwiseConstraint, pointwiseInitializer, pointwiseRegularizer and pointwiseConstraint instead.");if(null!=s.padding&&"same"!==s.padding&&"valid"!==s.padding)throw new $(`SeparableConv${this.rank}D supports only padding modes: 'same' and 'valid', but received ${JSON.stringify(s.padding)}`);this.depthMultiplier=null==s.depthMultiplier?1:s.depthMultiplier,this.depthwiseInitializer=mn(s.depthwiseInitializer||this.DEFAULT_DEPTHWISE_INITIALIZER),this.depthwiseRegularizer=gn(s.depthwiseRegularizer),this.depthwiseConstraint=ls(s.depthwiseConstraint),this.pointwiseInitializer=mn(s.depthwiseInitializer||this.DEFAULT_POINTWISE_INITIALIZER),this.pointwiseRegularizer=gn(s.pointwiseRegularizer),this.pointwiseConstraint=ls(s.pointwiseConstraint)}build(e){if((e=Mt(e)).length<this.rank+2)throw new $(`Inputs to SeparableConv${this.rank}D should have rank ${this.rank+2}, but received input shape: ${JSON.stringify(e)}`);const s="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[s]||e[s]<0)throw new $(`The channel dimension of the inputs should be defined, but found ${JSON.stringify(e[s])}`);const r=e[s],i=this.kernelSize.concat([r,this.depthMultiplier]),o=[];for(let l=0;l<this.rank;++l)o.push(1);o.push(r*this.depthMultiplier,this.filters);const a=!0;this.depthwiseKernel=this.addWeight("depthwise_kernel",i,"float32",this.depthwiseInitializer,this.depthwiseRegularizer,a,this.depthwiseConstraint),this.pointwiseKernel=this.addWeight("pointwise_kernel",o,"float32",this.pointwiseInitializer,this.pointwiseRegularizer,a,this.pointwiseConstraint),this.bias=this.useBias?this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,a,this.biasConstraint):null,this.inputSpec=[new os({ndim:this.rank+2,axes:{[s]:r}})],this.built=!0}call(e,s){return z(()=>{let r;if(e=Ke(e),1===this.rank)throw new ot("1D separable convolution is not implemented yet.");return 2===this.rank&&("channelsFirst"===this.dataFormat&&(e=Tt(e,[0,2,3,1])),r=rE(e,this.depthwiseKernel.read(),this.pointwiseKernel.read(),this.strides,this.padding,this.dilationRate,"NHWC")),this.useBias&&(r=ji(r,this.bias.read(),this.dataFormat)),null!=this.activation&&(r=this.activation.apply(r)),"channelsFirst"===this.dataFormat&&(r=Tt(r,[0,3,1,2])),r})}getConfig(){const e=super.getConfig();return delete e.rank,delete e.kernelInitializer,delete e.kernelRegularizer,delete e.kernelConstraint,e.depthwiseInitializer=xn(this.depthwiseInitializer),e.pointwiseInitializer=xn(this.pointwiseInitializer),e.depthwiseRegularizer=tn(this.depthwiseRegularizer),e.pointwiseRegularizer=tn(this.pointwiseRegularizer),e.depthwiseConstraint=as(this.depthwiseConstraint),e.pointwiseConstraint=as(this.pointwiseConstraint),e}}return n.className="SeparableConv",n})();function LB(n,t,e,s){if(Array.isArray(n)){if(null!=t||null!=e)throw new $("When inputs is an array, neither initialState or constants should be provided");null!=s&&(e=n.slice(n.length-s,n.length),n=n.slice(0,n.length-s)),n.length>1&&(t=n.slice(1,n.length)),n=n[0]}function r(i){return null==i||Array.isArray(i)?i:[i]}return{inputs:n,initialState:t=r(t),constants:e=r(e)}}function VB(n,t,e,s=!1,r,i,o=!1,a=!1){return z(()=>{const l=t.shape.length;if(l<3)throw new $(`Input should be at least 3D, but is ${l}D.`);const u=[1,0].concat(Gi(2,l));if(t=Tt(t,u),null!=i)throw new ot("The rnn() functoin of the deeplearn.js backend does not support constants yet.");o&&console.warn("Backend rnn(): the unroll = true option is not applicable to the imperative deeplearn.js backend."),null!=r&&((r=xe(xe(r,"bool"),"float32")).rank===l-1&&(r=ar(r,-1)),r=Tt(r,u)),s&&(t=yi(t,0),null!=r&&(r=yi(r,0)));const c=[];let d,h=e;const f=t.shape[0],p=bi(t);let g,m;null!=r&&(g=bi(r));for(let y=0;y<f;++y){const b=p[y],v=z(()=>n(b,h));if(null==r)d=v[0],h=v[1];else{const _=z(()=>{const x=g[y],C=Ne(Kr(x),x);return{output:le(F(v[0],x),F(h[0],C)),newStates:h.map((N,R)=>le(F(v[1][R],x),F(N,C)))}});d=_.output,h=_.newStates}a&&c.push(d)}return a&&(m=Xr(c,1)),[d,m,h]})}ue((()=>{class n extends phe{constructor(e){super(2,e)}}return n.className="SeparableConv2D",n})()),ue((()=>{class n extends pd{constructor(e){super(1,e),n.verifyArgs(e),this.inputSpec=[{ndim:3}]}getConfig(){const e=super.getConfig();return delete e.rank,delete e.dataFormat,e}static verifyArgs(e){if("number"!=typeof e.kernelSize&&!JE(e.kernelSize,"number",1,1))throw new $(`Conv1D expects config.kernelSize to be number or number[] with length 1, but received ${JSON.stringify(e.kernelSize)}.`)}}return n.className="Conv1D",n})()),ue((()=>{class n extends yt{constructor(e){super(e),this.cropping="number"==typeof e.cropping?[[e.cropping,e.cropping],[e.cropping,e.cropping]]:"number"==typeof e.cropping[0]?[[e.cropping[0],e.cropping[0]],[e.cropping[1],e.cropping[1]]]:e.cropping,this.dataFormat=void 0===e.dataFormat?"channelsLast":e.dataFormat,this.inputSpec=[{ndim:4}]}computeOutputShape(e){return"channelsFirst"===this.dataFormat?[e[0],e[1],e[2]-this.cropping[0][0]-this.cropping[0][1],e[3]-this.cropping[1][0]-this.cropping[1][1]]:[e[0],e[1]-this.cropping[0][0]-this.cropping[0][1],e[2]-this.cropping[1][0]-this.cropping[1][1],e[3]]}call(e,s){return z(()=>{if(e=Ke(e),"channelsLast"===this.dataFormat){const r=lv(e,this.cropping[0][0],e.shape[1]-this.cropping[0][0]-this.cropping[0][1],2);return lv(r,this.cropping[1][0],e.shape[2]-this.cropping[1][1]-this.cropping[1][0],3)}{const r=lv(e,this.cropping[0][0],e.shape[2]-this.cropping[0][0]-this.cropping[0][1],3);return lv(r,this.cropping[1][0],e.shape[3]-this.cropping[1][1]-this.cropping[1][0],4)}})}getConfig(){const e={cropping:this.cropping,dataFormat:this.dataFormat},s=super.getConfig();return Object.assign(e,s),e}}return n.className="Cropping2D",n})()),ue((()=>{class n extends yt{constructor(e){super(e),this.DEFAULT_SIZE=[2,2],this.inputSpec=[{ndim:4}],this.size=null==e.size?this.DEFAULT_SIZE:e.size,this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,Pn(this.dataFormat),this.interpolation=null==e.interpolation?"nearest":e.interpolation,function qce(n){hu(Wce,"InterpolationFormat",n)}(this.interpolation)}computeOutputShape(e){return"channelsFirst"===this.dataFormat?[e[0],e[1],null==e[2]?null:this.size[0]*e[2],null==e[3]?null:this.size[1]*e[3]]:[e[0],null==e[1]?null:this.size[0]*e[1],null==e[2]?null:this.size[1]*e[2],e[3]]}call(e,s){return z(()=>{let r=Ke(e);const i=r.shape;if("channelsFirst"===this.dataFormat){r=Tt(r,[0,2,3,1]);const o=this.size[0]*i[2],a=this.size[1]*i[3],l="nearest"===this.interpolation?Co.resizeNearestNeighbor(r,[o,a]):Co.resizeBilinear(r,[o,a]);return Tt(l,[0,3,1,2])}{const o=this.size[0]*i[1],a=this.size[1]*i[2];return"nearest"===this.interpolation?Co.resizeNearestNeighbor(r,[o,a]):Co.resizeBilinear(r,[o,a])}})}getConfig(){const e={size:this.size,dataFormat:this.dataFormat,interpolation:this.interpolation},s=super.getConfig();return Object.assign(e,s),e}}return n.className="UpSampling2D",n})()),ue((()=>{class n extends Sv{constructor(e){super(2,e),this.depthwiseKernel=null,this.depthMultiplier=null==e.depthMultiplier?1:e.depthMultiplier,this.depthwiseInitializer=mn(e.depthwiseInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.depthwiseConstraint=ls(e.depthwiseConstraint),this.depthwiseRegularizer=gn(e.depthwiseRegularizer)}build(e){if((e=Mt(e)).length<4)throw new $(`Inputs to DepthwiseConv2D should have rank 4. Received input shape: ${JSON.stringify(e)}.`);const s="channelsFirst"===this.dataFormat?1:3;if(null==e[s]||e[s]<0)throw new $(`The channel dimension of the inputs to DepthwiseConv2D should be defined, but is not (${e[s]}).`);const r=e[s];this.depthwiseKernel=this.addWeight("depthwise_kernel",[this.kernelSize[0],this.kernelSize[1],r,this.depthMultiplier],null,this.depthwiseInitializer,this.depthwiseRegularizer,!0,this.depthwiseConstraint),this.bias=this.useBias?this.addWeight("bias",[r*this.depthMultiplier],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):null,this.built=!0}call(e,s){return z(()=>{let r=function mhe(n,t,e=[1,1],s="valid",r,i){return z(()=>{null==r&&(r="channelsLast"),Pn(r);let o=ND(n,r);if(4!==n.rank)throw new $(`Input for depthwiseConv2d is required to be 4-D, but is instead ${n.rank}-D`);if(4!==t.rank)throw new $(`depthwiseKernel is required to be 4-D, but is instead ${t.rank}-D`);return o=ap(o,t,e,"same"===s?"same":"valid","NHWC",i),"channelsFirst"===r&&(o=Tt(o,[0,3,1,2])),o})}(e=Ke(e),this.depthwiseKernel.read(),this.strides,this.padding,this.dataFormat,null);return this.useBias&&(r=ji(r,this.bias.read(),this.dataFormat)),null!=this.activation&&(r=this.activation.apply(r)),r})}computeOutputShape(e){e=Mt(e);const r="channelsFirst"===this.dataFormat?e[3]:e[2],i="channelsFirst"===this.dataFormat?e[1]*this.depthMultiplier:e[3]*this.depthMultiplier,o=Xi("channelsFirst"===this.dataFormat?e[2]:e[1],this.kernelSize[0],this.padding,this.strides[0]),a=Xi(r,this.kernelSize[1],this.padding,this.strides[1]);return"channelsFirst"===this.dataFormat?[e[0],i,o,a]:[e[0],o,a,i]}getConfig(){const e=super.getConfig();return e.depthMultiplier=this.depthMultiplier,e.depthwiseInitializer=xn(this.depthwiseInitializer),e.depthwiseRegularizer=tn(this.depthwiseRegularizer),e.depthwiseConstraint=as(this.depthwiseRegularizer),e}}return n.className="DepthwiseConv2D",n})());let Np=(()=>{class n extends yt{constructor(e){let s;if(super(e),null==e.cell)throw new $("cell property is missing for the constructor of RNN.");if(s=Array.isArray(e.cell)?new UB({cells:e.cell}):e.cell,null==s.stateSize)throw new $("The RNN cell should have an attribute `stateSize` (tuple of integers, one integer per RNN state).");this.cell=s,this.returnSequences=null!=e.returnSequences&&e.returnSequences,this.returnState=null!=e.returnState&&e.returnState,this.goBackwards=null!=e.goBackwards&&e.goBackwards,this._stateful=null!=e.stateful&&e.stateful,this.unroll=null!=e.unroll&&e.unroll,this.supportsMasking=!0,this.inputSpec=[new os({ndim:3})],this.stateSpec=null,this.states_=null,this.numConstants=null,this.keptStates=[]}getStates(){return null==this.states_?Gi(0,Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1).map(s=>null):this.states_}setStates(e){this.states_=e}computeOutputShape(e){rD(e)&&(e=e[0]);let s=this.cell.stateSize;Array.isArray(s)||(s=[s]);const r=s[0];let i;if(i=this.returnSequences?[e[0],e[1],r]:[e[0],r],this.returnState){const o=[];for(const a of s)o.push([e[0],a]);return[i].concat(o)}return i}computeMask(e,s){return z(()=>{Array.isArray(s)&&(s=s[0]);const r=this.returnSequences?s:null;if(this.returnState){const i=this.states.map(o=>null);return[r].concat(i)}return r})}get states(){if(null==this.states_){const e=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1,s=[];for(let r=0;r<e;++r)s.push(null);return s}return this.states_}set states(e){this.states_=e}build(e){if(null!=this.numConstants)throw new ot("Constants support is not implemented in RNN yet.");rD(e)&&(e=e[0]);const r=this.stateful?e[0]:null,i=e.slice(2);this.inputSpec[0]=new os({shape:[r,null,...i]});const o=[e[0]].concat(e.slice(2));let a;if(this.cell.build(o),a=Array.isArray(this.cell.stateSize)?this.cell.stateSize:[this.cell.stateSize],null!=this.stateSpec){if(!wt(this.stateSpec.map(l=>l.shape[l.shape.length-1]),a))throw new $(`An initialState was passed that is not compatible with cell.stateSize. Received stateSpec=${this.stateSpec}; However cell.stateSize is ${this.cell.stateSize}`)}else this.stateSpec=a.map(l=>new os({shape:[null,l]}));this.stateful&&this.resetStates()}resetStates(e,s=!1){z(()=>{if(!this.stateful)throw new Io("Cannot call resetStates() on an RNN Layer that is not stateful.");const r=this.inputSpec[0].shape[0];if(null==r)throw new $("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(null==this.states_)this.states_=Array.isArray(this.cell.stateSize)?this.cell.stateSize.map(i=>rs([r,i])):[rs([r,this.cell.stateSize])];else if(null==e)gt(this.states_),null!=this.keptStates&&(gt(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(i=>rs([r,i])):this.states_[0]=rs([r,this.cell.stateSize]);else{if(Array.isArray(e)||(e=[e]),e.length!==this.states_.length)throw new $(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${e.length} state value(s). Input received: ${e}`);!0===s?this.keptStates.push(this.states_.slice()):gt(this.states_);for(let i=0;i<this.states_.length;++i){const o=e[i],a=Array.isArray(this.cell.stateSize)?this.cell.stateSize[i]:this.cell.stateSize,l=[r,a];if(!wt(o.shape,l))throw new $(`State ${i} is incompatible with layer ${this.name}: expected shape=${l}, received shape=${o.shape}`);this.states_[i]=o}}this.states_=this.states_.map(i=>vs(i.clone()))})}apply(e,s){let r=null==s?null:s.initialState,i=null==s?null:s.constants;null==s&&(s={});const o=LB(e,r,i,this.numConstants);e=o.inputs,r=o.initialState,i=o.constants;let a=[],l=[];if(null!=r){s.initialState=r,a=a.concat(r),this.stateSpec=[];for(const c of r)this.stateSpec.push(new os({shape:c.shape}));l=l.concat(this.stateSpec)}if(null!=i&&(s.constants=i,a=a.concat(i),this.numConstants=i.length),a[0]instanceof No){const c=[e].concat(a),d=this.inputSpec.concat(l),h=this.inputSpec;this.inputSpec=d;const f=super.apply(c,s);return this.inputSpec=h,f}return super.apply(e,s)}call(e,s){return z(()=>{const r=null==s?null:s.mask,i=null==s?null:s.training;let o=null==s?null:s.initialState;e=Ke(e),null==o&&(o=this.stateful?this.states_:this.getInitialState(e));const a=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;if(o.length!==a)throw new $(`RNN Layer has ${a} state(s) but was passed ${o.length} initial state(s).`);this.unroll&&console.warn("Ignoring unroll = true for RNN layer, due to imperative backend.");const l={training:i},c=VB((g,m)=>{const y=this.cell.call([g].concat(m),l);return[y[0],y.slice(1)]},e,o,this.goBackwards,r,null,this.unroll,this.returnSequences),d=c[0],h=c[1],f=c[2];this.stateful&&this.resetStates(f,i);const p=this.returnSequences?h:d;return this.returnState?[p].concat(f):p})}getInitialState(e){return z(()=>{let s=rs(e.shape);return s=Re(s,[1,2]),s=xp(s),Array.isArray(this.cell.stateSize)?this.cell.stateSize.map(r=>r>1?nD(s,[1,r]):s):this.cell.stateSize>1?[nD(s,[1,this.cell.stateSize])]:[s]})}get trainableWeights(){return this.trainable?this.cell.trainableWeights:[]}get nonTrainableWeights(){return this.trainable?this.cell.nonTrainableWeights:this.cell.weights}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),null!=this.cell&&this.cell.setFastWeightInitDuringBuild(e)}getConfig(){const e=super.getConfig(),s={returnSequences:this.returnSequences,returnState:this.returnState,goBackwards:this.goBackwards,stateful:this.stateful,unroll:this.unroll};null!=this.numConstants&&(s.numConstants=this.numConstants);const r=this.cell.getConfig();return this.getClassName()===n.className&&(s.cell={className:this.cell.getClassName(),config:r}),Object.assign(Object.assign(Object.assign({},r),e),s)}static fromConfig(e,s,r={}){const o=fa(s.cell,r);return new e(Object.assign(s,{cell:o}))}}return n.className="RNN",n})();ue(Np);class Iv extends yt{}let BB=(()=>{class n extends Iv{constructor(e){super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=e.units,xs(this.units,"units"),this.activation=al(null==e.activation?this.DEFAULT_ACTIVATION:e.activation),this.useBias=null==e.useBias||e.useBias,this.kernelInitializer=mn(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=mn(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=mn(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=gn(e.kernelRegularizer),this.recurrentRegularizer=gn(e.recurrentRegularizer),this.biasRegularizer=gn(e.biasRegularizer),this.kernelConstraint=ls(e.kernelConstraint),this.recurrentConstraint=ls(e.recurrentConstraint),this.biasConstraint=ls(e.biasConstraint),this.dropout=cd([1,sl([0,null==e.dropout?0:e.dropout])]),this.recurrentDropout=cd([1,sl([0,null==e.recurrentDropout?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){e=Mt(e),this.kernel=this.addWeight("kernel",[e[e.length-1],this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.bias=this.useBias?this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):null,this.built=!0}call(e,s){return z(()=>{if(2!==e.length)throw new $(`SimpleRNNCell expects 2 input Tensors, got ${e.length}.`);let r=e[1];e=e[0];const i=null!=s.training&&s.training;let o;0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=ll({ones:()=>Kr(e),rate:this.dropout,training:i,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=ll({ones:()=>Kr(r),rate:this.recurrentDropout,training:i,dropoutFunc:this.dropoutFunc}));const a=this.dropoutMask,l=this.recurrentDropoutMask;o=Do(null!=a?F(e,a):e,this.kernel.read()),null!=this.bias&&(o=ji(o,this.bias.read())),null!=l&&(r=F(r,l));let u=le(o,Do(r,this.recurrentKernel.read()));return null!=this.activation&&(u=this.activation.apply(u)),[u,u]})}getConfig(){const e=super.getConfig(),s={units:this.units,activation:ol(this.activation),useBias:this.useBias,kernelInitializer:xn(this.kernelInitializer),recurrentInitializer:xn(this.recurrentInitializer),biasInitializer:xn(this.biasInitializer),kernelRegularizer:tn(this.kernelRegularizer),recurrentRegularizer:tn(this.recurrentRegularizer),biasRegularizer:tn(this.biasRegularizer),activityRegularizer:tn(this.activityRegularizer),kernelConstraint:as(this.kernelConstraint),recurrentConstraint:as(this.recurrentConstraint),biasConstraint:as(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout};return Object.assign(Object.assign({},e),s)}}return n.className="SimpleRNNCell",n})();ue(BB),ue((()=>{class n extends Np{constructor(e){e.cell=new BB(e),super(e)}call(e,s){return z(()=>(null!=this.cell.dropoutMask&&(gt(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(gt(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),super.call(e,{mask:null==s?null:s.mask,training:null==s?null:s.training,initialState:null==s?null:s.initialState})))}static fromConfig(e,s){return new e(s)}}return n.className="SimpleRNN",n})());let zB=(()=>{class n extends Iv{constructor(e){if(super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",e.resetAfter)throw new $("GRUCell does not support reset_after parameter set to true.");this.units=e.units,xs(this.units,"units"),this.activation=al(void 0===e.activation?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=al(void 0===e.recurrentActivation?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=null==e.useBias||e.useBias,this.kernelInitializer=mn(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=mn(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=mn(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=gn(e.kernelRegularizer),this.recurrentRegularizer=gn(e.recurrentRegularizer),this.biasRegularizer=gn(e.biasRegularizer),this.kernelConstraint=ls(e.kernelConstraint),this.recurrentConstraint=ls(e.recurrentConstraint),this.biasConstraint=ls(e.biasConstraint),this.dropout=cd([1,sl([0,null==e.dropout?0:e.dropout])]),this.recurrentDropout=cd([1,sl([0,null==e.recurrentDropout?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.implementation=e.implementation,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){e=Mt(e),this.kernel=this.addWeight("kernel",[e[e.length-1],3*this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,3*this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.bias=this.useBias?this.addWeight("bias",[3*this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):null,this.built=!0}call(e,s){return z(()=>{if(2!==e.length)throw new $(`GRUCell expects 2 input Tensors (inputs, h, c), got ${e.length}.`);const r=null!=s.training&&s.training;let i=e[1];e=e[0],0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=ll({ones:()=>Kr(e),rate:this.dropout,training:r,count:3,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=ll({ones:()=>Kr(i),rate:this.recurrentDropout,training:r,count:3,dropoutFunc:this.dropoutFunc}));const a=this.recurrentDropoutMask;let l,u,c;0<this.dropout&&this.dropout<1&&(e=F(e,this.dropoutMask[0]));let d=Do(e,this.kernel.read());this.useBias&&(d=ji(d,this.bias.read())),0<this.recurrentDropout&&this.recurrentDropout<1&&(i=F(i,a[0]));const h=this.recurrentKernel.read(),[f,p]=Tr(h,[2*this.units,this.units],h.rank-1),g=Do(i,f),[m,y,b]=Tr(d,3,d.rank-1),[v,_]=Tr(g,2,g.rank-1);l=this.recurrentActivation.apply(le(m,v)),u=this.recurrentActivation.apply(le(y,_));const x=Do(F(u,i),p);c=this.activation.apply(le(b,x));const C=le(F(l,i),F(le(1,dn(l)),c));return[C,C]})}getConfig(){const e=super.getConfig(),s={units:this.units,activation:ol(this.activation),recurrentActivation:ol(this.recurrentActivation),useBias:this.useBias,kernelInitializer:xn(this.kernelInitializer),recurrentInitializer:xn(this.recurrentInitializer),biasInitializer:xn(this.biasInitializer),kernelRegularizer:tn(this.kernelRegularizer),recurrentRegularizer:tn(this.recurrentRegularizer),biasRegularizer:tn(this.biasRegularizer),activityRegularizer:tn(this.activityRegularizer),kernelConstraint:as(this.kernelConstraint),recurrentConstraint:as(this.recurrentConstraint),biasConstraint:as(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation,resetAfter:!1};return Object.assign(Object.assign({},e),s)}}return n.className="GRUCell",n})();ue(zB),ue((()=>{class n extends Np{constructor(e){0===e.implementation&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new zB(e),super(e)}call(e,s){return z(()=>(null!=this.cell.dropoutMask&&(gt(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(gt(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),super.call(e,{mask:null==s?null:s.mask,training:null==s?null:s.training,initialState:null==s?null:s.initialState})))}static fromConfig(e,s){return 0===s.implmentation&&(s.implementation=1),new e(s)}}return n.className="GRU",n})());let AD=(()=>{class n extends Iv{constructor(e){super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=e.units,xs(this.units,"units"),this.activation=al(void 0===e.activation?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=al(void 0===e.recurrentActivation?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=null==e.useBias||e.useBias,this.kernelInitializer=mn(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=mn(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=mn(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.unitForgetBias=e.unitForgetBias,this.kernelRegularizer=gn(e.kernelRegularizer),this.recurrentRegularizer=gn(e.recurrentRegularizer),this.biasRegularizer=gn(e.biasRegularizer),this.kernelConstraint=ls(e.kernelConstraint),this.recurrentConstraint=ls(e.recurrentConstraint),this.biasConstraint=ls(e.biasConstraint),this.dropout=cd([1,sl([0,null==e.dropout?0:e.dropout])]),this.recurrentDropout=cd([1,sl([0,null==e.recurrentDropout?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.implementation=e.implementation,this.stateSize=[this.units,this.units],this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){var s;let i;if(e=Mt(e),this.kernel=this.addWeight("kernel",[e[e.length-1],4*this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,4*this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){if(this.unitForgetBias){const o=this.biasInitializer,a=this.units;i=new((s=class extends wi{apply(u,c){const d=o.apply([a]),h=(new qV).apply([a]),f=o.apply([2*a]);return GV(GV(d,h),f)}}).className="CustomInit",s)}else i=this.biasInitializer;this.bias=this.addWeight("bias",[4*this.units],null,i,this.biasRegularizer,!0,this.biasConstraint)}else this.bias=null;this.built=!0}call(e,s){return z(()=>{const r=null!=s.training&&s.training;if(3!==e.length)throw new $(`LSTMCell expects 3 input Tensors (inputs, h, c), got ${e.length}.`);let i=e[1];const o=e[2];e=e[0],0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=ll({ones:()=>Kr(e),rate:this.dropout,training:r,count:4,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=ll({ones:()=>Kr(i),rate:this.recurrentDropout,training:r,count:4,dropoutFunc:this.dropoutFunc}));const l=this.recurrentDropoutMask;let u,c,d,h;0<this.dropout&&this.dropout<1&&(e=F(e,this.dropoutMask[0]));let f=Do(e,this.kernel.read());0<this.recurrentDropout&&this.recurrentDropout<1&&(i=F(i,l[0])),f=le(f,Do(i,this.recurrentKernel.read())),this.useBias&&(f=ji(f,this.bias.read()));const[p,g,m,y]=Tr(f,4,f.rank-1);u=this.recurrentActivation.apply(p),c=this.recurrentActivation.apply(g),d=le(F(c,o),F(u,this.activation.apply(m))),h=this.recurrentActivation.apply(y);const b=F(h,this.activation.apply(d));return[b,b,d]})}getConfig(){const e=super.getConfig(),s={units:this.units,activation:ol(this.activation),recurrentActivation:ol(this.recurrentActivation),useBias:this.useBias,kernelInitializer:xn(this.kernelInitializer),recurrentInitializer:xn(this.recurrentInitializer),biasInitializer:xn(this.biasInitializer),unitForgetBias:this.unitForgetBias,kernelRegularizer:tn(this.kernelRegularizer),recurrentRegularizer:tn(this.recurrentRegularizer),biasRegularizer:tn(this.biasRegularizer),activityRegularizer:tn(this.activityRegularizer),kernelConstraint:as(this.kernelConstraint),recurrentConstraint:as(this.recurrentConstraint),biasConstraint:as(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation};return Object.assign(Object.assign({},e),s)}}return n.className="LSTMCell",n})();ue(AD),ue((()=>{class n extends Np{constructor(e){0===e.implementation&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new AD(e),super(e)}call(e,s){return z(()=>(null!=this.cell.dropoutMask&&(gt(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(gt(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),super.call(e,{mask:null==s?null:s.mask,training:null==s?null:s.training,initialState:null==s?null:s.initialState})))}static fromConfig(e,s){return 0===s.implmentation&&(s.implementation=1),new e(s)}}return n.className="LSTM",n})());let UB=(()=>{class n extends Iv{constructor(e){super(e),this.cells=e.cells}get stateSize(){const e=[];for(const s of this.cells.slice().reverse())Array.isArray(s.stateSize)?e.push(...s.stateSize):e.push(s.stateSize);return e}call(e,s){return z(()=>{let r=e.slice(1);const i=[];for(const l of this.cells.slice().reverse())Array.isArray(l.stateSize)?i.push(r.splice(0,l.stateSize.length)):i.push(r.splice(0,1));i.reverse();const o=[];let a;for(let l=0;l<this.cells.length;++l){const u=this.cells[l];r=i[l],a=0===l?[e[0]].concat(r):[a[0]].concat(r),a=u.call(a,s),o.push(a.slice(1))}r=[];for(const l of o.slice().reverse())r.push(...l);return[a[0]].concat(r)})}build(e){let s;rD(e)&&(e=e[0]),this.cells.forEach((r,i)=>{fu(`RNNCell_${i}`,()=>{r.build(e),s=Array.isArray(r.stateSize)?r.stateSize[0]:r.stateSize,e=[e[0],s]})}),this.built=!0}getConfig(){const e=super.getConfig(),i={cells:this.cells.map(o=>({className:o.getClassName(),config:o.getConfig()}))};return Object.assign(Object.assign({},e),i)}static fromConfig(e,s,r={}){const i=[];for(const o of s.cells)i.push(fa(o,r));return new e({cells:i})}get trainableWeights(){if(!this.trainable)return[];const e=[];for(const s of this.cells)e.push(...s.trainableWeights);return e}get nonTrainableWeights(){const e=[];for(const s of this.cells)e.push(...s.nonTrainableWeights);if(!this.trainable){const s=[];for(const r of this.cells)s.push(...r.trainableWeights);return s.concat(e)}return e}getWeights(){const e=[];for(const s of this.cells)e.push(...s.weights);return iD(e)}setWeights(e){const s=[];for(const r of this.cells){const o=e.splice(r.weights.length);for(let a=0;a<r.weights.length;++a)s.push([r.weights[a],o[a]])}oD(s)}}return n.className="StackedRNNCells",n})();function ll(n){const{ones:t,rate:e,training:s=!1,count:r=1,dropoutFunc:i}=n,o=()=>null!=i?i(t(),e):jV(t(),e),a=()=>Sp(o,t,s);return!r||r<=1?vs(a().clone()):Array(r).fill(void 0).map(a).map(u=>vs(u.clone()))}ue(UB);let yhe=(()=>{class n extends Np{constructor(e){if(e.unroll)throw new ot("Unrolling is not possible with convolutional RNNs.");if(Array.isArray(e.cell))throw new ot("It is not possible at the moment to stack convolutional cells.");super(e),this.inputSpec=[new os({ndim:5})]}call(e,s){return z(()=>{if(null!=this.cell.dropoutMask&&(gt(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(gt(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),s&&s.constants)throw new $("ConvRNN2D cell does not support constants");return super.call(e,{mask:null==s?null:s.mask,training:null==s?null:s.training,initialState:null==s?null:s.initialState})})}computeOutputShape(e){let s=this.computeSingleOutputShape(e);return this.returnSequences||(s=[s[0],...s.slice(2)]),this.returnState&&(s=[s,...Array(2).fill([e[0],...s.slice(-3)])]),s}getInitialState(e){return z(()=>{const{stateSize:s}=this.cell,i=this.computeSingleOutputShape(e.shape),a=rs([i[0],...i.slice(2)]);return Array.isArray(s)?Array(s.length).fill(a):[a]})}resetStates(e,s=!1){z(()=>{if(!this.stateful)throw new Io("Cannot call resetStates() on an RNN Layer that is not stateful.");const r=this.inputSpec[0].shape,i=this.computeSingleOutputShape(r),o=[i[0],...i.slice(2)];if(null==r[0])throw new $("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(null==this.getStates())this.states_=Array.isArray(this.cell.stateSize)?this.cell.stateSize.map(()=>rs(o)):[rs(o)];else if(null==e)gt(this.states_),null!=this.keptStates&&(gt(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(()=>rs(o)):this.states_[0]=rs(o);else{if(Array.isArray(e)||(e=[e]),e.length!==this.states_.length)throw new $(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${e.length} state value(s). Input received: ${e}`);s?this.keptStates.push(this.states_.slice()):gt(this.states_);for(let l=0;l<this.states_.length;++l){const u=e[l],c=o;if(!wt(u.shape,c))throw new $(`State ${l} is incompatible with layer ${this.name}: expected shape=${c}, received shape=${u.shape}`);this.states_[l]=u}}this.states_=this.states_.map(l=>vs(l.clone()))})}computeSingleOutputShape(e){const{dataFormat:s,filters:r,kernelSize:i,padding:o,strides:a,dilationRate:l}=this.cell,u="channelsFirst"===s,d=e[u?4:3],h=Xi(e[u?3:2],i[0],o,a[0],l[0]),f=Xi(d,i[1],o,a[1],l[1]);return[...e.slice(0,2),...u?[r,h,f]:[h,f,r]]}}return n.className="ConvRNN2D",n})(),WB=(()=>{class n extends AD{constructor(e){const{filters:s,kernelSize:r,strides:i,padding:o,dataFormat:a,dilationRate:l}=e;super(Object.assign(Object.assign({},e),{units:s})),this.filters=s,xs(this.filters,"filters"),this.kernelSize=fd(r,2,"kernelSize"),this.kernelSize.forEach(u=>xs(u,"kernelSize")),this.strides=fd(i||1,2,"strides"),this.strides.forEach(u=>xs(u,"strides")),this.padding=o||"valid",Zr(this.padding),this.dataFormat=a||"channelsLast",Pn(this.dataFormat),this.dilationRate=fd(l||1,2,"dilationRate"),this.dilationRate.forEach(u=>xs(u,"dilationRate"))}build(e){var s;e=Mt(e);const r="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[r])throw new $(`The channel dimension of the input should be defined. Found ${e[r]}`);const a=this.kernelSize.concat([e[r],4*this.filters]);this.kernel=this.addWeight("kernel",a,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint);const l=this.kernelSize.concat([this.filters,4*this.filters]);if(this.recurrentKernel=this.addWeight("recurrent_kernel",l,null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){let u;if(this.unitForgetBias){const c=this.biasInitializer,d=this.filters;u=new((s=class extends wi{apply(f,p){return tD([c.apply([d]),qr([d]),c.apply([2*d])])}}).className="CustomInit",s)}else u=this.biasInitializer;this.bias=this.addWeight("bias",[4*this.filters],null,u,this.biasRegularizer,!0,this.biasConstraint)}this.built=!0}call(e,s){return z(()=>{if(3!==e.length)throw new $(`ConvLSTM2DCell expects 3 input Tensors (inputs, h, c), got ${e.length}.`);const r=s.training||!1,i=e[0],o=e[1],a=e[2];0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=ll({ones:()=>Kr(i),rate:this.dropout,training:r,count:4,dropoutFunc:this.dropoutFunc}));const u=this.dropoutMask,c=(ie,he,de)=>he&&he[de]?F(he[de],ie):ie;let d=c(i,u,0),h=c(i,u,1),f=c(i,u,2),p=c(i,u,3);0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=ll({ones:()=>Kr(o),rate:this.recurrentDropout,training:r,count:4,dropoutFunc:this.dropoutFunc}));const g=this.recurrentDropoutMask;let m=c(o,g,0),y=c(o,g,1),b=c(o,g,2),v=c(o,g,3);const[x,C,E,D]=Tr(this.kernel.read(),4,3),[N,R,V,G]=this.useBias?Tr(this.bias.read(),4):[null,null,null,null];d=this.inputConv(d,x,N,this.padding),h=this.inputConv(h,C,R,this.padding),f=this.inputConv(f,E,V,this.padding),p=this.inputConv(p,D,G,this.padding);const[j,q,K,P]=Tr(this.recurrentKernel.read(),4,3);m=this.recurrentConv(m,j),y=this.recurrentConv(y,q),b=this.recurrentConv(b,K),v=this.recurrentConv(v,P);const B=this.recurrentActivation.apply(le(d,m)),L=this.recurrentActivation.apply(le(h,y)),H=le(F(L,a),F(B,this.activation.apply(le(f,b)))),se=F(this.recurrentActivation.apply(le(p,v)),this.activation.apply(H));return[se,se,H]})}getConfig(){const r=function(n,t){var e={};for(var s in n)Object.prototype.hasOwnProperty.call(n,s)&&t.indexOf(s)<0&&(e[s]=n[s]);if(null!=n&&"function"==typeof Object.getOwnPropertySymbols){var r=0;for(s=Object.getOwnPropertySymbols(n);r<s.length;r++)t.indexOf(s[r])<0&&Object.prototype.propertyIsEnumerable.call(n,s[r])&&(e[s[r]]=n[s[r]])}return e}(super.getConfig(),["units"]),i={filters:this.filters,kernelSize:this.kernelSize,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,strides:this.strides};return Object.assign(Object.assign({},r),i)}inputConv(e,s,r,i){const o=Za(e,s,this.strides,i||"valid","channelsFirst"===this.dataFormat?"NCHW":"NHWC",this.dilationRate);return r?ji(o,r,this.dataFormat):o}recurrentConv(e,s){return Za(e,s,1,"same","channelsFirst"===this.dataFormat?"NCHW":"NHWC")}}return n.className="ConvLSTM2DCell",n})();ue(WB),ue((()=>{class n extends yhe{constructor(e){const s=new WB(e);super(Object.assign(Object.assign({},e),{cell:s}))}static fromConfig(e,s){return new e(s)}}return n.className="ConvLSTM2D",n})());let GB=(()=>{class n extends yt{constructor(e){super(e),this.rate=Math.max(Math.min(e.rate,1),0),this.noiseShape=e.noiseShape,this.seed=e.seed,this.supportsMasking=!0}getNoiseShape(e){if(null==this.noiseShape)return this.noiseShape;const s=e.shape,r=[];for(let i=0;i<this.noiseShape.length;++i)r.push(null==this.noiseShape[i]?s[i]:this.noiseShape[i]);return r}call(e,s){return z(()=>{this.invokeCallHook(e,s);const r=Ke(e);if(0<this.rate&&this.rate<1){const i=null!=s.training&&s.training,o=this.getNoiseShape(r);return Sp(()=>jV(r,this.rate,o,this.seed),()=>r,i)}return e})}getConfig(){const e={rate:this.rate,noiseShape:this.noiseShape,seed:this.seed},s=super.getConfig();return Object.assign(e,s),e}dispose(){return super.dispose()}}return n.className="Dropout",n})();ue(GB),ue((()=>{class n extends GB{constructor(e){super(e),this.inputSpec=[{ndim:3}]}getNoiseShape(e){const s=e.shape;return[s[0],1,s[2]]}}return n.className="SpatialDropout1D",n})()),ue((()=>{class n extends yt{constructor(e){if(super(e),this.activation=null,this.useBias=!0,this.kernel=null,this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",null==e.batchInputShape&&null==e.inputShape&&null!=e.inputDim){let s=null;null!=e.batchSize&&(s=e.batchSize),this.batchInputShape=[s,e.inputDim]}this.units=e.units,xs(this.units,"units"),this.activation=al(e.activation),null!=e.useBias&&(this.useBias=e.useBias),this.kernelInitializer=mn(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.biasInitializer=mn(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelConstraint=ls(e.kernelConstraint),this.biasConstraint=ls(e.biasConstraint),this.kernelRegularizer=gn(e.kernelRegularizer),this.biasRegularizer=gn(e.biasRegularizer),this.activityRegularizer=gn(e.activityRegularizer),this.supportsMasking=!0,this.inputSpec=[{minNDim:2}]}build(e){const s=(e=Mt(e))[e.length-1];null==this.kernel&&(this.kernel=this.addWeight("kernel",[s,this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint))),this.inputSpec=[{minNDim:2,axes:{[-1]:s}}],this.built=!0}computeOutputShape(e){const s=(e=Mt(e)).slice();return s[s.length-1]=this.units,s}call(e,s){return z(()=>{this.invokeCallHook(e,s);const r=Ke(e),i=$V(this.activation.getClassName());let o;return null!=i?o=Do(r,this.kernel.read(),i,this.bias?this.bias.read():null):(o=Do(r,this.kernel.read()),null!=this.bias&&(o=ji(o,this.bias.read())),null!=this.activation&&(o=this.activation.apply(o))),o})}getConfig(){const e={units:this.units,activation:ol(this.activation),useBias:this.useBias,kernelInitializer:xn(this.kernelInitializer),biasInitializer:xn(this.biasInitializer),kernelRegularizer:tn(this.kernelRegularizer),biasRegularizer:tn(this.biasRegularizer),activityRegularizer:tn(this.activityRegularizer),kernelConstraint:as(this.kernelConstraint),biasConstraint:as(this.biasConstraint)},s=super.getConfig();return Object.assign(e,s),e}}return n.className="Dense",n})()),ue((()=>{class n extends yt{constructor(e){super(e=e||{}),this.inputSpec=[{minNDim:3}],this.dataFormat=e.dataFormat}computeOutputShape(e){e=Mt(e);for(const s of e.slice(1))if(null==s)throw new $(`The shape of the input to "Flatten" is not fully defined (got ${e.slice(1)}). Make sure to pass a complete "input_shape" or "batch_input_shape" argument to the first layer in your model.`);return[e[0],nl(e,1)]}call(e,s){return z(()=>{this.invokeCallHook(e,s);let r=Ke(e);if("channelsFirst"===this.dataFormat&&r.rank>1){const i=[0];for(let o=2;o<r.rank;++o)i.push(o);i.push(1),r=Tt(r,i)}return function tde(n){if(n.rank<=1)throw new $(`batchFlatten requires a minimum rank of 2. Got rank: ${n.rank}.`);const t=[n.shape[0],nl(n.shape,1)];return O(n,t)}(r)})}getConfig(){const e={};null!=this.dataFormat&&(e.dataFormat=this.dataFormat);const s=super.getConfig();return Object.assign(e,s),e}}return n.className="Flatten",n})()),ue((()=>{class n extends yt{constructor(e){super(e),this.supportsMasking=!0,this.activation=al(e.activation)}call(e,s){return z(()=>{this.invokeCallHook(e,s);const r=Ke(e);return this.activation.apply(r)})}getConfig(){const e={activation:ol(this.activation)},s=super.getConfig();return Object.assign(e,s),e}}return n.className="Activation",n})()),ue((()=>{class n extends yt{constructor(e){super(e),this.n=e.n,this.inputSpec=[{ndim:2}]}computeOutputShape(e){return[e[0],this.n,e[1]]}call(e,s){return z(()=>function Jce(n,t){return z(()=>{if(2!==n.shape.length)throw new $(`repeat() expects a rank-2 tensor, but received a rank-${n.shape.length} tensor.`);return nD(xp(n,1),[1,t,1])})}(e=Ke(e),this.n))}getConfig(){const e={n:this.n},s=super.getConfig();return Object.assign(e,s),e}}return n.className="RepeatVector",n})()),ue((()=>{class n extends yt{constructor(e){super(e),this.targetShape=e.targetShape;for(let s=0;s<this.targetShape.length;++s)this.isUnknown(this.targetShape[s])&&(this.targetShape[s]=null)}isUnknown(e){return e<0||null==e}fixUnknownDimension(e,s){const r="Total size of new array must be unchanged.",i=s.slice();let o=1,a=null;for(let u=0;u<i.length;++u){const c=i[u];if(this.isUnknown(c)){if(null!==a)throw new $("Can only specifiy one unknown dimension.");a=u}else o*=c}const l=nl(e);if(null!==a){if(0===o||l%o!=0)throw new $(r);i[a]=l/o}else if(l!==o)throw new $(r);return i}computeOutputShape(e){let s=!1;for(let r=0;r<e.length;++r)if(this.isUnknown(e[r])){s=!0;break}return s?e.slice(0,1).concat(this.targetShape):e.slice(0,1).concat(this.fixUnknownDimension(e.slice(1),this.targetShape))}call(e,s){return z(()=>{this.invokeCallHook(e,s);const r=Ke(e),i=r.shape,o=i.slice(0,1).concat(this.fixUnknownDimension(i.slice(1),this.targetShape));return O(r,o)})}getConfig(){const e={targetShape:this.targetShape},s=super.getConfig();return Object.assign(e,s),e}}return n.className="Reshape",n})()),ue((()=>{class n extends yt{constructor(e){if(super(e),null==e.dims)throw new Error("Required configuration field `dims` is missing during Permute constructor call.");if(!Array.isArray(e.dims))throw new Error(`Permute constructor requires \`dims\` to be an Array, but received ${e.dims} instead.`);const s=Gi(1,e.dims.length+1);if(!wt(e.dims.slice().sort(),s))throw new Error("Invalid permutation `dims`: "+JSON.stringify(e.dims)+" `dims` must contain consecutive integers starting from 1.");this.dims=e.dims,this.dimsIncludingBatch=[0].concat(this.dims),this.inputSpec=[new os({ndim:this.dims.length+1})]}computeOutputShape(e){const s=(e=Mt(e)).slice();return this.dims.forEach((r,i)=>{s[i+1]=e[r]}),s}call(e,s){return Tt(Ke(e),this.dimsIncludingBatch)}getConfig(){const e={dims:this.dims},s=super.getConfig();return Object.assign(e,s),e}}return n.className="Permute",n})()),ue((()=>{class n extends yt{constructor(e){super(e??{}),this.supportsMasking=!0,this.maskValue=null!=e?null==e.maskValue?0:e.maskValue:0}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),s={maskValue:this.maskValue};return Object.assign(s,e),s}computeMask(e,s){const r=Ke(e);return Ab(sd(r,this.maskValue),-1)}call(e,s){return z(()=>{this.invokeCallHook(e,s);const r=Ke(e),a=Ab(sd(r,this.maskValue),-1,!0);return F(r,xe(a,r.dtype))})}}return n.className="Masking",n})()),ue((()=>{class n extends yt{constructor(e){if(super(e),this.embeddings=null,this.DEFAULT_EMBEDDINGS_INITIALIZER="randomUniform",null==e.batchInputShape&&null==e.inputShape){let s=null;null!=e.batchSize&&(s=e.batchSize),this.batchInputShape=null==e.inputLength?[s,null]:[s].concat(sn(e.inputLength))}this.inputDim=e.inputDim,xs(this.inputDim,"inputDim"),this.outputDim=e.outputDim,xs(this.outputDim,"outputDim"),this.embeddingsInitializer=mn(e.embeddingsInitializer||this.DEFAULT_EMBEDDINGS_INITIALIZER),this.embeddingsRegularizer=gn(e.embeddingsRegularizer),this.activityRegularizer=gn(e.activityRegularizer),this.embeddingsConstraint=ls(e.embeddingsConstraint),this.maskZero=e.maskZero,this.supportsMasking=e.maskZero,this.inputLength=e.inputLength}build(e){this.embeddings=this.addWeight("embeddings",[this.inputDim,this.outputDim],this.dtype,this.embeddingsInitializer,this.embeddingsRegularizer,!0,this.embeddingsConstraint),this.built=!0}warnOnIncompatibleInputShape(e){}computeMask(e,s){return z(()=>this.maskZero?(e=Ke(e),sd(e,Et(e))):null)}computeOutputShape(e){if(e=Mt(e),null==this.inputLength)return[...e,this.outputDim];const s=sn(this.inputLength);if(s.length!==e.length-1)throw new $(`"inputLength" is ${this.inputLength}, but received input shape has shape ${e}`);{let r=0;for(let i=0;i<s.length;++i){const o=s[i],a=e[i+1];if(null!=o&&null!=a&&o!==a)throw new $(`"inputLength" is ${this.inputLength}, but received input shape has shape ${e}`);null==o&&(s[r]=a),r++}}return[e[0],...s,this.outputDim]}call(e,s){return z(()=>{this.invokeCallHook(e,s);let r=Ke(e);"int32"!==r.dtype&&(r=Eo(r,"int32"));const i=HV(this.embeddings.read(),O(r,[r.size]));return O(i,Mt(this.computeOutputShape(r.shape)))})}getConfig(){const e={inputDim:this.inputDim,outputDim:this.outputDim,embeddingsInitializer:xn(this.embeddingsInitializer),embeddingsRegularizer:tn(this.embeddingsRegularizer),activityRegularizer:tn(this.activityRegularizer),embeddingsConstraint:as(this.embeddingsConstraint),maskZero:this.maskZero,inputLength:this.inputLength},s=super.getConfig();return Object.assign(e,s),e}}return n.className="Embedding",n})());class mu extends yt{constructor(t){super(t||{}),this.supportsMasking=!0}mergeFunction(t){throw new ot}computeElementwiseOpOutputShape(t,e){if(null==t||null==e)return null;if(t.length<e.length)return this.computeElementwiseOpOutputShape(e,t);if(0===e.length)return t;const s=t.slice(0,t.length-e.length);for(let r=0;r<e.length;++r){const i=t[t.length-e.length+r],o=e[r];if(null==i||null==o||i<0||o<0)s.push(null);else if(1===i)s.push(o);else if(1===o)s.push(i);else{if(i!==o)throw new $("Operands could not be broadcast together with shapes "+JSON.stringify(t)+" "+JSON.stringify(e));s.push(i)}}return s}build(t){if(Array.isArray(t)&&!Array.isArray(t[0])&&(t=[Mt(t)]),t.length<2)throw new $(`A merge layer should be called on an Array of at least 2 inputs. Got ${t.length} input(s).`);let e=[];for(const i of t)null!=i&&null!==i[0]&&e.push(i[0]);if(e=tl(e),e.length>1)throw new $(`Can not merge tensors with different batch sizes. Got tensors with shapes: ${JSON.stringify(t)}.`);let s=null==t[0]?null:t[0].slice(1);for(let i=1;i<t.length;++i){const o=null==t[i]?null:t[i].slice(1);s=this.computeElementwiseOpOutputShape(s,o)}const r=t.map(i=>i.length);this.reshapeRequired=-1!==t.indexOf(null)||1!==tl(r).length}call(t,e){return z(()=>{if(this.reshapeRequired){const s=[],r=t.map(i=>i.rank);if(-1===r.indexOf(null)){const i=sl(r);for(let o of t){const a=o.rank;for(let l=0;l<i-a;++l)o=xp(o,1);s.push(o)}return this.mergeFunction(s)}{let i=!1;for(const l of t){const u=l.rank;if(null==u){const c=l.shape,d=c[0],h=c.slice(1).concat([d]);let f=O(l,[d].concat(nl(c.slice(1))));f=Tt(f,[1,0]),f=O(f,h),s.push(f),i=!0}else if(u>1){const c=Gi(1,u).concat([0]);s.push(Tt(l,c)),i=!0}else s.push(l)}let o=this.mergeFunction(s);const a=o.rank;if(i)if(null==a){const l=o.shape,c=l[l.length-1],d=[c].concat(l.slice(0,l.length-1));o=O(Tt(O(o,[-1,c]),[1,0]),d)}else if(a>1){const l=[a-1].concat(Gi(0,a-1));o=Tt(o,l)}return o}}return this.mergeFunction(t)})}computeOutputShape(t){let e;e=null==t[0]?null:t[0].slice(1);for(let r=1;r<t.length;++r){const i=null==t[r]?null:t[r].slice(1);e=this.computeElementwiseOpOutputShape(e,i)}let s=[];for(const r of t)null!=r&&null!==r[0]&&s.push(r[0]);return s=tl(s),e=1===s.length?s.concat(e):[null].concat(e),e}computeMask(t,e){return z(()=>{if(null==e)return null;if(!Array.isArray(e))throw new $("`mask` should be an Array");if(!Array.isArray(t))throw new $("`inputs` should be an Array");if(e.length!==t.length)throw new $(`The Array 'inputs' and 'mask' are expected to have the same length, but have different lengths (${t.length} vs ${e.length})`);if(e.every(r=>null==r))return null;let s=(e=e.map(r=>null==r?r:ar(r,0)))[0];for(let r=1;r<e.length-1;++r)s=wo(s,e[r]);return s})}}function kp(n,t){for(;n<0;)n+=t;return n}function Ap(n,t,e,s,r,i=.001){let o;if(2===n.rank)o=QP(n,t,e,s,r,i);else if(3===n.rank)o=JP(n,t,e,s,r,i);else{if(4!==n.rank)throw new ot(`batchNormalization is not implemented for array of rank ${n.rank} yet`);o=eL(n,t,e,s,r,i)}return o}function Ev(n,t,e,s,r,i){return z(()=>{let o;Pn(r),LV(i),Zr(s),null==e&&(e=[1,1]),null==s&&(s="valid"),null==r&&(r="channelsLast"),null==i&&(i="max"),n=ND(n,r);const a="same"===s?"same":"valid";return o="max"===i?zb(n,t,e,a):Rb(n,t,e,a),"channelsFirst"===r&&(o=Tt(o,[0,3,1,2])),o})}function HB(n,t,e,s,r,i){return z(()=>{let o;Pn(r),LV(i),Zr(s),null==e&&(e=[1,1,1]),null==s&&(s="valid"),null==r&&(r="channelsLast"),null==i&&(i="max"),n=MB(n,r);const a="same"===s?"same":"valid";return o="max"===i?IL(n,t,e,a):ZP(n,t,e,a),"channelsFirst"===r&&(o=Tt(o,[0,4,1,2,3])),o})}ue((()=>{class n extends mu{constructor(e){super(e)}mergeFunction(e){return z(()=>{let s=e[0].clone();for(let r=1;r<e.length;++r)s=le(s,e[r]);return s})}}return n.className="Add",n})()),ue((()=>{class n extends mu{constructor(e){super(e)}mergeFunction(e){return z(()=>{let s=e[0].clone();for(let r=1;r<e.length;++r)s=F(s,e[r]);return s})}}return n.className="Multiply",n})()),ue((()=>{class n extends mu{constructor(e){super(e)}mergeFunction(e){return z(()=>{let s=e[0].clone();for(let r=1;r<e.length;++r)s=le(s,e[r]);return F(1/e.length,s)})}}return n.className="Average",n})()),ue((()=>{class n extends mu{constructor(e){super(e)}mergeFunction(e){return z(()=>{let s=e[0];for(let r=1;r<e.length;++r)s=oa(s,e[r]);return s})}}return n.className="Maximum",n})()),ue((()=>{class n extends mu{constructor(e){super(e)}mergeFunction(e){return z(()=>{let s=e[0];for(let r=1;r<e.length;++r)s=ou(s,e[r]);return s})}}return n.className="Minimum",n})()),ue((()=>{class n extends mu{constructor(e){super(e),this.DEFAULT_AXIS=-1,null==e&&(e={}),this.axis=null==e.axis?this.DEFAULT_AXIS:e.axis,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){if(!Array.isArray(e)||!Array.isArray(e[0])||1===e.length)throw new $("A `Concatenate` layer should be called on a list of at least 2 inputs");let s=!0;for(const i of e)if(null!=i){s=!1;break}if(s)return;const r=[];for(let i=0;i<e.length;++i){const o=e[i].slice();o.splice(this.axis,1);let a=!1;for(const l of r)if(wt(l,o)){a=!0;break}a||r.push(o)}if(r.length>1)throw new $("A `Concatenate` layer requires inputs with matching shapes except for the concat axis. Got input shapes: "+JSON.stringify(e))}mergeFunction(e){return z(()=>tD(e,this.axis))}computeOutputShape(e){if(!Array.isArray(e)||!Array.isArray(e[0]))throw new $("A `Concatenate` layer should be called on a list of inputs.");const s=e,r=s[0].slice(),i=this.axis<0?r.length+this.axis:this.axis;for(const o of s.slice(1)){if(null==r[i]||null==o[i]){r[i]=null;break}r[i]+=o[i]}return r}computeMask(e,s){if(null==s)return null;if(!Array.isArray(s))throw new $("`mask` should be an array for Concatenate");if(!Array.isArray(e))throw new $("`inputs` should be an array for Concatenate");if(s.length!==e.length)throw new $(`Mismatch in the length of mask (${s.length}) and the legnth of inputs (${e.length})`);return z(()=>{let r=!0;if(s.forEach(a=>{null==a||(r=!1)}),r)return null;const i=[];for(let a=0;a<e.length;++a)i.push(null==s[a]?xe(Kr(e[a]),"bool"):s[a].rank<e[a].rank?ar(s[a],-1):s[a]);const o=jn(i,this.axis);return OI(o,-1,!1)})}getConfig(){const e={axis:this.axis},s=super.getConfig();return Object.assign(e,s),e}}return n.className="Concatenate",n})()),ue((()=>{class n extends mu{constructor(e){super(e),this.axes=e.axes,this.normalize=null!=e.normalize&&e.normalize,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){S(Array.isArray(e)&&2===e.length&&Array.isArray(e[0])&&Array.isArray(e[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");const s=e[0],r=e[1];if(s.length>3||r.length>3)throw new ot("Dot layer does not support tensors of 4D or higher rank yet.");const i=this.interpretAxes(s,r);if(s[i[0]]!==r[i[1]])throw new $(`Dimension incompatibility: ${s[i[0]]} !== ${r[i[1]]}`)}mergeFunction(e){if(2!==e.length)throw new $(`A \`Dot\` layer must be called on exactly 2 inputs, but received ${e.length} input(s).`);let i,s=e[0],r=e[1];return i=Array.isArray(this.axes)?this.axes.map((o,a)=>kp(o,e[a].shape.length)):[kp(this.axes,s.shape.length),kp(this.axes,r.shape.length)],this.normalize&&(s=gv(s,i[0]),r=gv(r,i[1])),function bhe(n,t,e){if(n.shape.length>3||t.shape.length>3)throw new ot("batchDot is not implemented for tensors of 4D or higher rank yet");if(S(n.shape.length>=2,()=>`batchDot requires the rank of x to be >= 2, but got ${n.shape.length}`),S(n.shape.length>=2,()=>`batchDot requires the rank of y to be >= 2, but got ${t.shape.length}`),"number"==typeof e&&(e=[e,e]),"complex64"===n.dtype||"complex64"===t.dtype)throw new ot("batchDot is not implemented for complex64-type Tensors yet.");const s=n.shape.length,r=t.shape.length;null==e&&(e=[s-1,r-2]);const i=e;return z(()=>{let o,a;if(s>r){o=s-r;const l=[];for(let u=0;u<o;++u)l.push(1);t=O(t,t.shape.concat(l))}else if(r>s){o=r-s;const l=[];for(let u=0;u<o;++u)l.push(1);n=O(n,n.shape.concat(l))}else o=0;if(a=2===n.shape.length&&2===t.shape.length?i[0]===i[1]?Re(F(n,t),i[0]):Re(F(Tt(n,[1,0]),t),i[1]):bt(n,t,i[0]!==n.shape.length-1,i[1]===t.shape.length-1),o>0){let l;l=s>r?s+r-3:s-1;const u=[];for(let c=l;c<l+o;++c)u.push(c);a=lu(a,u)}return 1===a.shape.length&&(a=ar(a,1)),a})}(s,r,i)}interpretAxes(e,s){let r;return r=Array.isArray(this.axes)?this.axes:[kp(this.axes,e.length),kp(this.axes,s.length)],r}computeOutputShape(e){S(Array.isArray(e)&&2===e.length&&Array.isArray(e[0])&&Array.isArray(e[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");const s=e[0].slice(),r=e[1].slice();if(s.length>3||r.length>3)throw new ot("Dot layer does not support tensors of 4D or higher rank yet.");const i=this.interpretAxes(s,r);s.splice(i[0],1),r.splice(i[1],1),r.splice(0,1);const o=s.concat(r);return 1===o.length&&o.push(1),o}computeMask(e,s){return null}getConfig(){const e={axes:this.axes,normalize:this.normalize},s=super.getConfig();return Object.assign(e,s),e}}return n.className="Dot",n})()),ue((()=>{class n extends yt{constructor(e){super(e),this.supportsMasking=!0,this.stddev=e.stddev}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),s={stddev:this.stddev};return Object.assign(s,e),s}call(e,s){return z(()=>{this.invokeCallHook(e,s);const r=Ke(e);return Sp(()=>le(uv(r.shape,0,this.stddev),r),()=>r,s.training||!1)})}}return n.className="GaussianNoise",n})()),ue((()=>{class n extends yt{constructor(e){super(e),this.supportsMasking=!0,this.rate=e.rate}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),s={rate:this.rate};return Object.assign(s,e),s}call(e,s){return z(()=>{this.invokeCallHook(e,s);const r=Ke(e);return this.rate>0&&this.rate<1?Sp(()=>{const o=Math.sqrt(this.rate/(1-this.rate));return F(r,uv(r.shape,1,o))},()=>r,s.training||!1):r})}}return n.className="GaussianDropout",n})()),ue((()=>{class n extends yt{constructor(e){super(e),this.supportsMasking=!0,this.rate=e.rate,this.noiseShape=e.noiseShape}_getNoiseShape(e){return this.noiseShape||Ke(e).shape}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),s={rate:this.rate};return Object.assign(s,e),s}call(e,s){return z(()=>{if(this.rate<1&&this.rate>0){const r=this._getNoiseShape(e);return Sp(()=>{const o=Ke(e),u=-1.7580993408473766;let c=Ja(au(r),this.rate);c=Eo(c,"float32");const d=((1-this.rate)*(1+this.rate*u**2))**-.5,h=-d*u*this.rate,f=le(F(o,c),F(le(c,-1),u));return le(F(f,d),h)},()=>Ke(e),s.training||!1)}return e})}}return n.className="AlphaDropout",n})()),ue((()=>{class n extends yt{constructor(e){null==e&&(e={}),super(e),this.supportsMasking=!0,this.axis=null==e.axis?-1:e.axis,this.momentum=null==e.momentum?.99:e.momentum,this.epsilon=null==e.epsilon?.001:e.epsilon,this.center=null==e.center||e.center,this.scale=null==e.scale||e.scale,this.betaInitializer=mn(e.betaInitializer||"zeros"),this.gammaInitializer=mn(e.gammaInitializer||"ones"),this.movingMeanInitializer=mn(e.movingMeanInitializer||"zeros"),this.movingVarianceInitializer=mn(e.movingVarianceInitializer||"ones"),this.betaConstraint=ls(e.betaConstraint),this.gammaConstraint=ls(e.gammaConstraint),this.betaRegularizer=gn(e.betaRegularizer),this.gammaRegularizer=gn(e.gammaRegularizer)}build(e){e=Mt(e);const s=this.axis>=0?this.axis:this.axis+e.length,r=e[s];if(null==r)throw new $(`Axis ${s} of input tensor should have a defined dimension but the layer received an input with shape ${JSON.stringify(e)}.`);this.inputSpec=[new os({ndim:e.length,axes:{[s]:r}})];const i=[r];this.scale&&(this.gamma=this.addWeight("gamma",i,null,this.gammaInitializer,this.gammaRegularizer,!0,this.gammaConstraint)),this.center&&(this.beta=this.addWeight("beta",i,null,this.betaInitializer,this.betaRegularizer,!0,this.betaConstraint)),this.movingMean=this.addWeight("moving_mean",i,null,this.movingMeanInitializer,null,!1),this.movingVariance=this.addWeight("moving_variance",i,null,this.movingVarianceInitializer,null,!1),this.built=!0}call(e,s){return z(()=>{const r=null!=s.training&&s.training,i=Ke(e),o=i.shape,a=o.length,l=Gi(0,a),u=this.axis>=0?this.axis:this.axis+a;l.splice(u,1);const c=cu(1,a);c[u]=o[u];const d=l.slice();d.sort();const h=!wt(d,Gi(0,a).slice(0,a-1));if(!r)return(()=>{if(h){const v=O(this.movingMean.read(),c),_=O(this.movingVariance.read(),c),x=this.center?O(this.beta.read(),c):null,C=this.scale?O(this.gamma.read(),c):null;return Ap(i,v,_,x,C,this.epsilon)}return Ap(i,this.movingMean.read(),this.movingVariance.read(),null==this.beta?null:this.beta.read(),null==this.gamma?null:this.gamma.read(),this.epsilon)})();const[p,g,m]=function whe(n,t,e,s,r=.001){return wt(s.slice().sort(),Gi(0,n.rank-1))?function vhe(n,t,e,s,r=.001){return z(()=>{const i=Ub(n,s),o=i.mean,a=i.variance;return[Ap(n,o,a,e,t,r),o,a]})}(n,t,e,s,r):function _he(n,t,e,s,r=.001){return z(()=>{const i=Ub(n,s),o=i.mean,a=i.variance,l=[];for(const p of Gi(0,n.rank))-1!==s.indexOf(p)?l.push(1):l.push(n.shape[p]);const u=O(o,l),c=O(a,l),d=null==t?null:O(t,l),h=null==e?null:O(e,l);return[Ap(n,u,c,h,d,r),o,a]})}(n,t,e,s,r)}(i,this.gamma.read(),this.beta.read(),l,this.epsilon),y=(v,_,x)=>{z(()=>{const C=1-x,E=v.read(),D=F(Ne(E,_),C);v.write(Ne(E,D))})};return(()=>{y(this.movingMean,g,this.momentum),y(this.movingVariance,m,this.momentum)})(),p})}getConfig(){const e={axis:this.axis,momentum:this.momentum,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:xn(this.betaInitializer),gammaInitializer:xn(this.gammaInitializer),movingMeanInitializer:xn(this.movingMeanInitializer),movingVarianceInitializer:xn(this.movingVarianceInitializer),betaRegularizer:tn(this.betaRegularizer),gammaRegularizer:tn(this.gammaRegularizer),betaConstraint:as(this.betaConstraint),gammaConstraint:as(this.gammaConstraint)},s=super.getConfig();return Object.assign(e,s),e}}return n.className="BatchNormalization",n})()),ue((()=>{class n extends yt{constructor(e){if(null==e&&(e={}),super(e),this.axis=null==e.axis?-1:e.axis,"number"==typeof this.axis){if(!Number.isInteger(this.axis))throw new Error(`Expected axis to be an integer, but received ${this.axis}`)}else{if(!Array.isArray(this.axis))throw new Error(`Expected axis to be an integer or an array of integers, but received ${JSON.stringify(this.axis)}`);for(const s of this.axis)if(!Number.isInteger(s))throw new Error(`Expected axis to be an array of integers, but received ${JSON.stringify(this.axis)}`)}this.epsilon=null==e.epsilon?.001:e.epsilon,this.center=null==e.center||e.center,this.scale=null==e.scale||e.scale,this.betaInitializer=mn(e.betaInitializer||"zeros"),this.gammaInitializer=mn(e.gammaInitializer||"ones"),this.betaRegularizer=gn(e.betaRegularizer),this.gammaRegularizer=gn(e.gammaRegularizer),this.supportsMasking=!0}build(e){const s=(e=Mt(e)).length;"number"==typeof this.axis&&(this.axis=[this.axis]);for(let o=0;o<this.axis.length;++o)this.axis[o]<0&&(this.axis[o]+=s);for(const o of this.axis)if(o<0||o>=s)throw new Error(`Invalid axis: ${o}`);if(this.axis.length!==tl(this.axis).length)throw new Error(`Found duplicate axes in: ${this.axis}`);const r=this.axis.map(o=>e[o]);this.gamma=this.scale?this.addWeight("gamma",r,"float32",this.gammaInitializer,this.gammaRegularizer,!0):null,this.beta=this.center?this.addWeight("beta",r,"float32",this.betaInitializer,this.betaRegularizer,!0):null,this.built=!0}call(e,s){const r=Ke(e),i=r.shape,o=i.length;return z(()=>{let{mean:l,variance:u}=Ub(r,this.axis,!0);const c=cu(1,o);for(const m of this.axis)c[m]=i[m];const d=m=>null!=m&&m.shape.length!==o?O(m,c):m;let h=this.scale?d(this.gamma.read()):null,f=this.center?d(this.beta.read()):null;const p=[],g=[];for(let m=0;m<o;++m)-1!==this.axis.indexOf(m)?(p.push(i[m]),g.push(1)):(p.push(1),g.push(i[m]));return l=gi(l,p),u=gi(u,p),null!=h&&(h=gi(h,g)),null!=f&&(f=gi(f,g)),Ap(r,l,u,f,h,this.epsilon)})}getConfig(){const e={axis:this.axis,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:xn(this.betaInitializer),gammaInitializer:xn(this.gammaInitializer),betaRegularizer:tn(this.betaRegularizer),gammaRegularizer:tn(this.gammaRegularizer)},s=super.getConfig();return Object.assign(e,s),e}}return n.className="LayerNormalization",n})()),ue((()=>{class n extends yt{constructor(e){if(null==e&&(e={}),super(e),this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,null==e.padding)this.padding=[[1,1],[1,1]];else if("number"==typeof e.padding)this.padding=[[e.padding,e.padding],[e.padding,e.padding]];else{if(e.padding=e.padding,2!==e.padding.length)throw new $(`ZeroPadding2D expects padding to be a length-2 array, but received a length-${e.padding.length} array.`);let s,r;if("number"==typeof e.padding[0])s=[e.padding[0],e.padding[0]],r=[e.padding[1],e.padding[1]];else{if(e.padding=e.padding,2!==e.padding[0].length)throw new $(`ZeroPadding2D expects height padding to be a length-2 array, but received a length-${e.padding[0].length} array.`);if(s=e.padding[0],2!==e.padding[1].length)throw new $(`ZeroPadding2D expects width padding to be a length-2 array, but received a length-${e.padding[1].length} array.`);r=e.padding[1]}this.padding=[s,r]}this.inputSpec=[new os({ndim:4})]}computeOutputShape(e){let s,r;return e=Mt(e),"channelsFirst"===this.dataFormat?(s=null!=e[2]&&e[2]>=0?e[2]+this.padding[0][0]+this.padding[0][1]:null,r=null!=e[3]&&e[3]>=0?e[3]+this.padding[1][0]+this.padding[1][1]:null,[e[0],e[1],s,r]):(s=null!=e[1]&&e[1]>=0?e[1]+this.padding[0][0]+this.padding[0][1]:null,r=null!=e[2]&&e[2]>=0?e[2]+this.padding[1][0]+this.padding[1][1]:null,[e[0],s,r,e[3]])}call(e,s){return z(()=>function xhe(n,t,e){return z(()=>{if(4!==n.rank)throw new $(`temporalPadding expects input tensor to be 4-D, but received a ${n.rank}-D tensor.`);if(null==t&&(t=[[1,1],[1,1]]),2!==t.length||2!==t[0].length||2!==t[1].length)throw new $("spatial2dPadding expects `padding` to be an Array of two Arrays, each of which is an Array of two integers.");if(null==e&&(e="channelsLast"),"channelsLast"!==e&&"channelsFirst"!==e)throw new $(`Unknown data format: ${e}. Supported data formats are 'channelsLast' and 'channelsFirst.`);let s;return s="channelsFirst"===e?[[0,0],[0,0],t[0],t[1]]:[[0,0],t[0],t[1],[0,0]],el(n,s)})}(Ke(e),this.padding,this.dataFormat))}getConfig(){const e={padding:this.padding,dataFormat:this.dataFormat},s=super.getConfig();return Object.assign(e,s),e}}return n.className="ZeroPadding2D",n})());class jB extends yt{constructor(t){if(null==t.poolSize&&(t.poolSize=2),super(t),"number"==typeof t.poolSize)this.poolSize=[t.poolSize];else{if(!Array.isArray(t.poolSize)||1!==t.poolSize.length||"number"!=typeof t.poolSize[0])throw new $(`poolSize for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(t.poolSize)}`);this.poolSize=t.poolSize}if(xs(this.poolSize,"poolSize"),null==t.strides)this.strides=this.poolSize;else if("number"==typeof t.strides)this.strides=[t.strides];else{if(!Array.isArray(t.strides)||1!==t.strides.length||"number"!=typeof t.strides[0])throw new $(`strides for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(t.strides)}`);this.strides=t.strides}xs(this.strides,"strides"),this.padding=null==t.padding?"valid":t.padding,Zr(this.padding),this.inputSpec=[new os({ndim:3})]}computeOutputShape(t){const e=Xi((t=Mt(t))[1],this.poolSize[0],this.padding,this.strides[0]);return[t[0],e,t[2]]}call(t,e){return z(()=>{this.invokeCallHook(t,e),t=xp(Ke(t),2);const s=this.poolingFunction(Ke(t),[this.poolSize[0],1],[this.strides[0],1],this.padding,"channelsLast");return lu(s,[2])})}getConfig(){const t={poolSize:this.poolSize,padding:this.padding,strides:this.strides},e=super.getConfig();return Object.assign(t,e),t}}ue((()=>{class n extends jB{constructor(e){super(e)}poolingFunction(e,s,r,i,o){return Pn(o),Zr(i),Ev(e,s,r,i,o,"max")}}return n.className="MaxPooling1D",n})()),ue((()=>{class n extends jB{constructor(e){super(e)}poolingFunction(e,s,r,i,o){return Pn(o),Zr(i),Ev(e,s,r,i,o,"avg")}}return n.className="AveragePooling1D",n})());class qB extends yt{constructor(t){if(null==t.poolSize&&(t.poolSize=[2,2]),super(t),this.poolSize=Array.isArray(t.poolSize)?t.poolSize:[t.poolSize,t.poolSize],null==t.strides)this.strides=this.poolSize;else if(Array.isArray(t.strides)){if(2!==t.strides.length)throw new $(`If the strides property of a 2D pooling layer is an Array, it is expected to have a length of 2, but received length ${t.strides.length}.`);this.strides=t.strides}else this.strides=[t.strides,t.strides];xs(this.poolSize,"poolSize"),xs(this.strides,"strides"),this.padding=null==t.padding?"valid":t.padding,this.dataFormat=null==t.dataFormat?"channelsLast":t.dataFormat,Pn(this.dataFormat),Zr(this.padding),this.inputSpec=[new os({ndim:4})]}computeOutputShape(t){t=Mt(t);let e="channelsFirst"===this.dataFormat?t[2]:t[1],s="channelsFirst"===this.dataFormat?t[3]:t[2];return e=Xi(e,this.poolSize[0],this.padding,this.strides[0]),s=Xi(s,this.poolSize[1],this.padding,this.strides[1]),"channelsFirst"===this.dataFormat?[t[0],t[1],e,s]:[t[0],e,s,t[3]]}call(t,e){return z(()=>(this.invokeCallHook(t,e),this.poolingFunction(Ke(t),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){const t={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(t,e),t}}ue((()=>{class n extends qB{constructor(e){super(e)}poolingFunction(e,s,r,i,o){return Pn(o),Zr(i),Ev(e,s,r,i,o,"max")}}return n.className="MaxPooling2D",n})()),ue((()=>{class n extends qB{constructor(e){super(e)}poolingFunction(e,s,r,i,o){return Pn(o),Zr(i),Ev(e,s,r,i,o,"avg")}}return n.className="AveragePooling2D",n})());class KB extends yt{constructor(t){if(null==t.poolSize&&(t.poolSize=[2,2,2]),super(t),this.poolSize=Array.isArray(t.poolSize)?t.poolSize:[t.poolSize,t.poolSize,t.poolSize],null==t.strides)this.strides=this.poolSize;else if(Array.isArray(t.strides)){if(3!==t.strides.length)throw new $(`If the strides property of a 3D pooling layer is an Array, it is expected to have a length of 3, but received length ${t.strides.length}.`);this.strides=t.strides}else this.strides=[t.strides,t.strides,t.strides];xs(this.poolSize,"poolSize"),xs(this.strides,"strides"),this.padding=null==t.padding?"valid":t.padding,this.dataFormat=null==t.dataFormat?"channelsLast":t.dataFormat,Pn(this.dataFormat),Zr(this.padding),this.inputSpec=[new os({ndim:5})]}computeOutputShape(t){t=Mt(t);let e="channelsFirst"===this.dataFormat?t[2]:t[1],s="channelsFirst"===this.dataFormat?t[3]:t[2],r="channelsFirst"===this.dataFormat?t[4]:t[3];return e=Xi(e,this.poolSize[0],this.padding,this.strides[0]),s=Xi(s,this.poolSize[1],this.padding,this.strides[1]),r=Xi(r,this.poolSize[2],this.padding,this.strides[2]),"channelsFirst"===this.dataFormat?[t[0],t[1],e,s,r]:[t[0],e,s,r,t[4]]}call(t,e){return z(()=>(this.invokeCallHook(t,e),this.poolingFunction(Ke(t),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){const t={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(t,e),t}}ue((()=>{class n extends KB{constructor(e){super(e)}poolingFunction(e,s,r,i,o){return Pn(o),Zr(i),HB(e,s,r,i,o,"max")}}return n.className="MaxPooling3D",n})()),ue((()=>{class n extends KB{constructor(e){super(e)}poolingFunction(e,s,r,i,o){return Pn(o),Zr(i),HB(e,s,r,i,o,"avg")}}return n.className="AveragePooling3D",n})());class XB extends yt{constructor(t){super(t),this.inputSpec=[new os({ndim:3})]}computeOutputShape(t){return[t[0],t[2]]}call(t,e){throw new ot}}ue((()=>{class n extends XB{constructor(e){super(e||{})}call(e,s){return z(()=>{const r=Ke(e);return Nn(r,1)})}}return n.className="GlobalAveragePooling1D",n})()),ue((()=>{class n extends XB{constructor(e){super(e||{})}call(e,s){return z(()=>{const r=Ke(e);return mi(r,1)})}}return n.className="GlobalMaxPooling1D",n})());class YB extends yt{constructor(t){super(t),this.dataFormat=null==t.dataFormat?"channelsLast":t.dataFormat,Pn(this.dataFormat),this.inputSpec=[new os({ndim:4})]}computeOutputShape(t){return"channelsLast"===this.dataFormat?[t[0],t[3]]:[t[0],t[1]]}call(t,e){throw new ot}getConfig(){const t={dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(t,e),t}}ue((()=>{class n extends YB{call(e,s){return z(()=>{const r=Ke(e);return Nn(r,"channelsLast"===this.dataFormat?[1,2]:[2,3])})}}return n.className="GlobalAveragePooling2D",n})()),ue((()=>{class n extends YB{call(e,s){return z(()=>{const r=Ke(e);return mi(r,"channelsLast"===this.dataFormat?[1,2]:[2,3])})}}return n.className="GlobalMaxPooling2D",n})());class ZB extends yt{constructor(t){super(t),this.layer=t.layer}build(t){this.built=!0}get trainable(){return null!=this.layer&&this.layer.trainable}set trainable(t){null!=this.layer&&(this.layer.trainable=t)}get trainableWeights(){return this.layer.trainableWeights}get nonTrainableWeights(){return this.layer.nonTrainableWeights}get updates(){return this.layer._updates}get losses(){return this.layer.losses}getWeights(){return this.layer.getWeights()}setWeights(t){this.layer.setWeights(t)}getConfig(){const t={layer:{className:this.layer.getClassName(),config:this.layer.getConfig()}},e=super.getConfig();return Object.assign(t,e),t}setFastWeightInitDuringBuild(t){super.setFastWeightInitDuringBuild(t),null!=this.layer&&this.layer.setFastWeightInitDuringBuild(t)}static fromConfig(t,e,s={}){const i=fa(e.layer,s);delete e.layer;const o={layer:i};return Object.assign(o,e),new t(o)}}ue((()=>{class n extends ZB{constructor(e){super(e),this.supportsMasking=!0}build(e){if((e=Mt(e)).length<3)throw new $(`TimeDistributed layer expects an input shape >= 3D, but received input shape ${JSON.stringify(e)}`);this.inputSpec=[{shape:e}];const s=[e[0]].concat(e.slice(2));this.layer.built||(this.layer.build(s),this.layer.built=!0),super.build(e)}computeOutputShape(e){const s=[(e=Mt(e))[0]].concat(e.slice(2)),r=this.layer.computeOutputShape(s);return[r[0],e[1]].concat(r.slice(1))}call(e,s){return z(()=>VB((a,l)=>[Ke(this.layer.call(a,s)),[]],e=Ke(e),[],!1,null,null,!1,!0)[1])}}return n.className="TimeDistributed",n})()),ue((()=>{class n extends ZB{constructor(e){super(e);const s=e.layer.getConfig(),r={};r.className=e.layer.getClassName(),r.config=s,this.forwardLayer=fa(r),s.goBackwards=!0!==s.goBackwards;const i={};if(i.className=e.layer.getClassName(),i.config=s,this.backwardLayer=fa(i),this.forwardLayer.name="forward_"+this.forwardLayer.name,this.backwardLayer.name="backward_"+this.backwardLayer.name,this.mergeMode=void 0===e.mergeMode?"concat":e.mergeMode,function Che(n){hu(jce,"BidirectionalMergeMode",n)}(this.mergeMode),e.weights)throw new ot("weights support is not implemented for Bidirectional layer yet.");this._stateful=e.layer.stateful,this.returnSequences=e.layer.returnSequences,this.returnState=e.layer.returnState,this.supportsMasking=!0,this._trainable=!0,this.inputSpec=e.layer.inputSpec,this.numConstants=null}get trainable(){return this._trainable}set trainable(e){this._trainable=e,null!=this.forwardLayer&&(this.forwardLayer.trainable=e),null!=this.backwardLayer&&(this.backwardLayer.trainable=e)}getWeights(){return this.forwardLayer.getWeights().concat(this.backwardLayer.getWeights())}setWeights(e){const r=Math.floor(e.length/2);this.forwardLayer.setWeights(e.slice(0,r)),this.backwardLayer.setWeights(e.slice(r))}computeOutputShape(e){let r,i,o,s=this.forwardLayer.computeOutputShape(e);return Array.isArray(s)&&Array.isArray(s[0])||(s=[s]),this.returnState&&(o=s.slice(1)),r=s[0],"concat"===this.mergeMode?(r[r.length-1]*=2,i=[r]):i=null==this.mergeMode?[r,r.slice()]:[r],this.returnState?null==this.mergeMode?i.concat(o).concat(o.slice()):[r].concat(o).concat(o.slice()):ur(i)}apply(e,s){let r=null==s?null:s.initialState,i=null==s?null:s.constants;null==s&&(s={});const o=LB(e,r,i,this.numConstants);if(e=o.inputs,r=o.initialState,i=o.constants,Array.isArray(e)&&(r=e.slice(1),e=e[0]),(null==r||0===r.length)&&null==i)return super.apply(e,s);const a=[],l=[];if(null!=r){const c=r.length;if(c%2>0)throw new $("When passing `initialState` to a Bidrectional RNN, the state should be an Array containing the states of the underlying RNNs.");s.initialState=r,a.push(...r);const d=r.map(h=>new os({shape:h.shape}));this.forwardLayer.stateSpec=d.slice(0,c/2),this.backwardLayer.stateSpec=d.slice(c/2),l.push(...d)}if(null!=i)throw new ot("Support for constants in Bidirectional layers is not implemented yet.");const u=a[0]instanceof No;for(const c of a)if(c instanceof No!==u)throw new $("The initial state of a Bidirectional layer cannot be specified as a mix of symbolic and non-symbolic tensors");if(u){const c=[e].concat(a),d=this.inputSpec.concat(l),h=this.inputSpec;this.inputSpec=d;const f=super.apply(c,s);return this.inputSpec=h,f}return super.apply(e,s)}call(e,s){return z(()=>{const r=s.initialState;let i,o,a,l;if(null==r)i=this.forwardLayer.call(e,s),o=this.backwardLayer.call(e,s);else{const u=r.slice(0,r.length/2),c=r.slice(r.length/2);i=this.forwardLayer.call(e,Object.assign(s,{initialState:u})),o=this.backwardLayer.call(e,Object.assign(s,{initialState:c}))}return this.returnState&&(Array.isArray(i)&&(a=i.slice(1).concat(o.slice(1))),i=i[0],o=o[0]),this.returnSequences&&(o=yi(o,1)),"concat"===this.mergeMode?l=tD([i,o]):"sum"===this.mergeMode?l=le(i,o):"ave"===this.mergeMode?l=F(.5,le(i,o)):"mul"===this.mergeMode?l=F(i,o):null==this.mergeMode&&(l=[i,o]),this.returnState?null==this.mergeMode?l.concat(a):[l].concat(a):l})}resetStates(e){this.forwardLayer.resetStates(),this.backwardLayer.resetStates()}build(e){fu(this.forwardLayer.name,()=>{this.forwardLayer.build(e)}),fu(this.backwardLayer.name,()=>{this.backwardLayer.build(e)}),this.built=!0}computeMask(e,s){let r;if(Array.isArray(s)&&(s=s[0]),r=this.returnSequences?null==this.mergeMode?[s,s]:s:null==this.mergeMode?[null,null]:null,this.returnState){const o=this.forwardLayer.states.map(a=>null);return Array.isArray(r)?r.concat(o).concat(o):[r].concat(o).concat(o)}return r}get trainableWeights(){return this.forwardLayer.trainableWeights.concat(this.backwardLayer.trainableWeights)}get nonTrainableWeights(){return this.forwardLayer.nonTrainableWeights.concat(this.backwardLayer.nonTrainableWeights)}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),null!=this.forwardLayer&&this.forwardLayer.setFastWeightInitDuringBuild(e),null!=this.backwardLayer&&this.backwardLayer.setFastWeightInitDuringBuild(e)}getConfig(){const e={mergeMode:this.mergeMode},s=super.getConfig();return Object.assign(e,s),e}static fromConfig(e,s){const r=fa(s.layer);if(delete s.layer,null!=s.numConstants)throw new ot("Deserialization of a Bidirectional layer with numConstants present is not supported yet.");const i=s;return i.layer=r,new e(i)}}return n.className="Bidirectional",n})()),ue((()=>{class n extends yt{constructor(e){super(e),this.scale=e.scale,this.offset=e.offset?e.offset:0}getConfig(){const e={scale:this.scale,offset:this.offset},s=super.getConfig();return Object.assign(e,s),e}call(e,s){return z(()=>("float32"!==(e=Ke(e)).dtype&&(e=Eo(e,"float32")),le(F(e,this.scale),this.offset)))}}return n.className="Rescaling",n})());const{resizeBilinear:Ihe,cropAndResize:Ehe}=Co;ue((()=>{class n extends yt{constructor(e){super(e),this.height=e.height,this.width=e.width}centerCrop(e,s,r,i,o,a,l,u){return z(()=>{let c,d=!1;const m=[s/a,r/l,(i+s)/a,(o+r)/l],y=[];3===e.rank?(d=!0,c=Xr([e])):c=e;for(let C=0;C<c.shape[0];C++)y.push(m);const b=Ui(y,[y.length,4]),v=rd(0,y.length,1,"int32"),x=Ehe(c,b,v,[i,o],"nearest");return Eo(d?Ke(bi(x)):x,u)})}upsize(e,s,r,i){return z(()=>Eo(Ihe(e,[s,r]),i))}call(e,s){return z(()=>{const r=Ke(e),i=r.dtype,o=r.shape,a=o[o.length-3],l=o[o.length-2];let u=0;a!==this.height&&(u=Math.floor((a-this.height)/2));let c=0;return l!==this.width&&(c=Math.floor((l-this.width)/2),0===c&&(c=1)),u>=0&&c>=0?this.centerCrop(r,u,c,this.height,this.width,a,l,i):this.upsize(e,this.height,this.width,i)})}getConfig(){const e={height:this.height,width:this.width},s=super.getConfig();return Object.assign(e,s),e}computeOutputShape(e){const r=(e=Mt(e)).length-2;return e[e.length-3]=this.height,e[r]=this.width,e}}return n.className="CenterCrop",n})()),ue((()=>{class n extends yt{constructor(e){super(e),this.numTokens=e.numTokens,this.outputMode=e.outputMode?e.outputMode:"multiHot"}getConfig(){const e={numTokens:this.numTokens,outputMode:this.outputMode},s=super.getConfig();return Object.assign(e,s),e}computeOutputShape(e){return null==(e=Mt(e))?[this.numTokens]:"oneHot"===this.outputMode&&1!==e[e.length-1]?(e.push(this.numTokens),e):(e[e.length-1]=this.numTokens,e)}call(e,s){return z(()=>{let r;if("int32"!==(e=Ke(e)).dtype&&(e=Eo(e,"int32")),typeof s.countWeights<"u"){if("count"!==this.outputMode)throw new $(`countWeights is not used when outputMode !== count.\n              Received countWeights=${s.countWeights}`);r=Ke(s.countWeights)}const i=mi(e),o=up(e),a=Dr(this.numTokens,i).bufferSync().get(0),l=Ja(o,0).bufferSync().get(0);if(!a||!l)throw new $(`Input values must be between 0 < values <= numTokens with numTokens=${this.numTokens}`);return function Dhe(n,t,e,s){let r=Ke(n);if("int32"!==r.dtype&&(r=Eo(r,"int32")),"int"===t)return r;const i=r.shape;if(0===r.rank&&(r=ar(r,-1)),"oneHot"===t&&1!==r.shape[r.shape.length-1]&&(r=ar(r,-1)),r.rank>2)throw new $(`When outputMode is not int, maximum output rank is 2 Received outputMode ${t} and input shape ${i} which would result in output rank ${r.rank}.`);const o=["multiHot","oneHot"].includes(t);let l;if(l=WI(r,typeof s<"u"&&"count"===t?s:[],e,o),"tfIdf"!==t)return l;if(s)return F(l,s);throw new $("When outputMode is 'tfIdf', weights must be provided.")}(e,this.outputMode,this.numTokens,r)})}}return n.className="CategoryEncoding",n})());const QB=new Set(["bilinear","nearest"]);ue((()=>{class n extends yt{constructor(e){if(super(e),this.height=e.height,this.width=e.width,e.interpolation){if(!QB.has(e.interpolation))throw new $(`Invalid interpolation parameter: ${e.interpolation} is not implemented`);this.interpolation=e.interpolation}else this.interpolation="bilinear";this.cropToAspectRatio=!!e.cropToAspectRatio}computeOutputShape(e){return e=Mt(e),[this.height,this.width,e[2]]}getConfig(){const e={height:this.height,width:this.width,interpolation:this.interpolation,cropToAspectRatio:this.cropToAspectRatio},s=super.getConfig();return Object.assign(e,s),e}call(e,s){return z(()=>{const r=[this.height,this.width];if("bilinear"===this.interpolation)return Co.resizeBilinear(e,r,!this.cropToAspectRatio);if("nearest"===this.interpolation)return Co.resizeNearestNeighbor(e,r,!this.cropToAspectRatio);throw new Error(`Interpolation is ${this.interpolation} but only ${[...QB]} are supported`)})}}return n.className="Resizing",n})());let Nhe=(()=>{class n{constructor(e){this.seed=e}next(){if(void 0!==this.seed)return this.seed++}}return n.className="RandomSeed",n})(),khe=(()=>{class n extends yt{constructor(e){super(e),this.randomGenerator=new Nhe(e.seed)}getConfig(){const e={seed:this.randomGenerator.seed},s=super.getConfig();return Object.assign(e,s),e}}return n.className="BaseRandomLayer",n})();const JB=new Set(["bilinear","nearest"]);ue((()=>{class n extends khe{constructor(e){super(e);const{factor:s,interpolation:r="bilinear"}=e;if(this.factor=s,Array.isArray(this.factor)&&2===this.factor.length)this.widthLower=this.factor[0],this.widthUpper=this.factor[1];else{if(Array.isArray(this.factor)||!(this.factor>0))throw new $(`Invalid factor: ${this.factor}. Must be positive number or tuple of 2 numbers`);this.widthLower=-this.factor,this.widthUpper=this.factor}if(this.widthLower<-1||this.widthUpper<-1)throw new $(`factor must have values larger than -1. Got: ${this.factor}`);if(this.widthUpper<this.widthLower)throw new $(`factor cannot have upper bound less than lower bound.\n        Got upper bound: ${this.widthUpper}.\n        Got lower bound: ${this.widthLower}\n      `);if(r){if(!JB.has(r))throw new $(`Invalid interpolation parameter: ${r} is not implemented`);this.interpolation=r}}getConfig(){const e={factor:this.factor,interpolation:this.interpolation},s=super.getConfig();return Object.assign(e,s),e}computeOutputShape(e){return e=Mt(e),[this.imgHeight,-1,e[2]]}call(e,s){return z(()=>{const r=Ke(e);this.imgHeight=r.shape[r.shape.length-3];const i=r.shape[r.shape.length-2];this.widthFactor=au([1],1+this.widthLower,1+this.widthUpper,"float32",this.randomGenerator.next());let o=this.widthFactor.dataSync()[0]*i;o=Math.round(o);const a=[this.imgHeight,o];switch(this.interpolation){case"bilinear":return Co.resizeBilinear(e,a);case"nearest":return Co.resizeNearestNeighbor(e,a);default:throw new Error(`Interpolation is ${this.interpolation}\n          but only ${[...JB]} are supported`)}})}}return n.className="RandomWidth",n})()),W().registerFlag("KEEP_INTERMEDIATE_TENSORS",()=>!1,n=>{n&&console.warn("Keep intermediate tensors is ON. This will print the values of all intermediate tensors during model inference. Not all models support this mode. For details, check e2e/benchmarks/ model_config.js. This significantly impacts performance.")});var rz,ae=(()=>((ae=ae||{})[ae.DT_INVALID=0]="DT_INVALID",ae[ae.DT_FLOAT=1]="DT_FLOAT",ae[ae.DT_DOUBLE=2]="DT_DOUBLE",ae[ae.DT_INT32=3]="DT_INT32",ae[ae.DT_UINT8=4]="DT_UINT8",ae[ae.DT_INT16=5]="DT_INT16",ae[ae.DT_INT8=6]="DT_INT8",ae[ae.DT_STRING=7]="DT_STRING",ae[ae.DT_COMPLEX64=8]="DT_COMPLEX64",ae[ae.DT_INT64=9]="DT_INT64",ae[ae.DT_BOOL=10]="DT_BOOL",ae[ae.DT_QINT8=11]="DT_QINT8",ae[ae.DT_QUINT8=12]="DT_QUINT8",ae[ae.DT_QINT32=13]="DT_QINT32",ae[ae.DT_BFLOAT16=14]="DT_BFLOAT16",ae[ae.DT_QINT16=15]="DT_QINT16",ae[ae.DT_QUINT16=16]="DT_QUINT16",ae[ae.DT_UINT16=17]="DT_UINT16",ae[ae.DT_COMPLEX128=18]="DT_COMPLEX128",ae[ae.DT_HALF=19]="DT_HALF",ae[ae.DT_RESOURCE=20]="DT_RESOURCE",ae[ae.DT_VARIANT=21]="DT_VARIANT",ae[ae.DT_UINT32=22]="DT_UINT32",ae[ae.DT_UINT64=23]="DT_UINT64",ae[ae.DT_FLOAT_REF=101]="DT_FLOAT_REF",ae[ae.DT_DOUBLE_REF=102]="DT_DOUBLE_REF",ae[ae.DT_INT32_REF=103]="DT_INT32_REF",ae[ae.DT_UINT8_REF=104]="DT_UINT8_REF",ae[ae.DT_INT16_REF=105]="DT_INT16_REF",ae[ae.DT_INT8_REF=106]="DT_INT8_REF",ae[ae.DT_STRING_REF=107]="DT_STRING_REF",ae[ae.DT_COMPLEX64_REF=108]="DT_COMPLEX64_REF",ae[ae.DT_INT64_REF=109]="DT_INT64_REF",ae[ae.DT_BOOL_REF=110]="DT_BOOL_REF",ae[ae.DT_QINT8_REF=111]="DT_QINT8_REF",ae[ae.DT_QUINT8_REF=112]="DT_QUINT8_REF",ae[ae.DT_QINT32_REF=113]="DT_QINT32_REF",ae[ae.DT_BFLOAT16_REF=114]="DT_BFLOAT16_REF",ae[ae.DT_QINT16_REF=115]="DT_QINT16_REF",ae[ae.DT_QUINT16_REF=116]="DT_QUINT16_REF",ae[ae.DT_UINT16_REF=117]="DT_UINT16_REF",ae[ae.DT_COMPLEX128_REF=118]="DT_COMPLEX128_REF",ae[ae.DT_HALF_REF=119]="DT_HALF_REF",ae[ae.DT_RESOURCE_REF=120]="DT_RESOURCE_REF",ae[ae.DT_VARIANT_REF=121]="DT_VARIANT_REF",ae[ae.DT_UINT32_REF=122]="DT_UINT32_REF",ae[ae.DT_UINT64_REF=123]="DT_UINT64_REF",ae))();!function(n){let t;var e;(e=t=n.CheckpointFormatVersion||(n.CheckpointFormatVersion={}))[e.LEGACY=0]="LEGACY",e[e.V1=1]="V1",e[e.V2=2]="V2"}(rz||(rz={}));const LD={};function iz(n){return LD[n]}function w(n,t,e,s,r){const i=t.inputParams[n];if(i&&void 0!==i.inputIndexStart){const a=i.inputIndexStart,l=0===i.inputIndexEnd?void 0:void 0===i.inputIndexEnd?a+1:i.inputIndexEnd,u=a<0?t.inputNames.length+a:a;if("tensor"===i.type)return ks(t.inputNames[u],e,s,r);if("tensors"===i.type){const h=t.inputs.slice(a,l);return t.inputNames.slice(a,l).filter((p,g)=>{var m;return"NoOp"!==(null===(m=h[g])||void 0===m?void 0:m.op)}).map(p=>ks(p,e,s,r))}const c=ks(t.inputNames[u],e,s,r),d=c.dataSync();return"number"===i.type?d[0]:di(c.shape,d)}const o=t.attrParams[n];return o&&o.value}function ks(n,t,e,s){const[r,i]=Nr(n,e);if(null!=s){const a=s.getHashTableHandleByName(r);if(null!=a)return a}const o=e.currentContextIds.find(a=>!!t[Tv(r,a)]);return void 0!==o?t[Tv(r,o)][i]:void 0}function oz(n,t,e){return t[Tv(n,e.currentContextId)]}function pa(n,t){const[e,s,r]=Nr(n,t);return[Tv(e,t&&t.currentContextId),s,r]}function Tv(n,t){return t?`${n}-${t}`:n}function Nr(n,t){if(""===n)return["",0,void 0];const e=null!=t&&null!=t.parseNodeNameCache;if(e){const i=t.parseNodeNameCache.get(n);if(null!=i)return i}const s=n.split(":");let r;if(1===s.length)r=[n,0,void 0];else{const o=3===s.length?s[1]:void 0;r=[s[0],Number(s[s.length-1]),o]}return e&&t.parseNodeNameCache.set(n,r),r}function Nv(n,t,e){let s=w("pad",n,t,e);if("explicit"===s){s=w("explicitPaddings",n,t,e);const r=[[0,0],[0,0],[0,0],[0,0]];for(let i=0;i<4;i++)r[i][0]=s[2*i],r[i][1]=s[2*i+1];return r}return s}function ma(n){return n.kept?n:ra(n)}const Ohe=[{tfOpName:"Add",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddV2",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddN",category:"arithmetic",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"BiasAdd",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"Sub",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"RealDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Div",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"DivNoNan",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mul",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Maximum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Minimum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Pow",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SquaredDifference",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorMod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],$he=[{tfOpName:"Abs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan2",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ceil",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ClipByValue",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"clipValueMin",type:"number"},{start:2,name:"clipValueMax",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Complex",category:"basic_math",inputs:[{start:0,name:"real",type:"tensor"},{start:1,name:"imag",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ComplexAbs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Elu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Exp",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Floor",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Imag",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Neg",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Real",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Prelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"alpha",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu6",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Selu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sigmoid",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Rsqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Square",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sign",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Round",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Expm1",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log1p",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Reciprocal",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Softplus",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Erf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LeakyRelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"alpha",name:"alpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsNan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsFinite",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsInf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],Phe=[{tfOpName:"EmptyTensorList",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"maxNumElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"LoopCond",category:"control",inputs:[{start:0,name:"pred",type:"tensor"}]},{tfOpName:"Switch",category:"control",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"pred",type:"tensor"}]},{tfOpName:"Merge",category:"control",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"Enter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"frame_name",name:"frameName",type:"string"},{tfName:"is_constant",name:"isConstant",type:"bool"}]},{tfOpName:"Exit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NextIteration",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayV3",category:"control",inputs:[{start:0,name:"size",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"dynamic_size",name:"dynamicSize",type:"bool"},{tfName:"clear_after_read",name:"clearAfterRead",type:"bool"},{tfName:"identical_element_shapes",name:"identicalElementShapes",type:"bool"},{tfName:"tensor_array_name",name:"name",type:"string"}]},{tfOpName:"TensorArrayWriteV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayReadV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayGatherV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"}]},{tfOpName:"TensorArrayScatterV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArrayConcatV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape_except0",name:"elementShapeExcept0",type:"shape",notSupported:!0}]},{tfOpName:"TensorArraySplitV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"tensor",type:"tensor"},{start:2,name:"lengths",type:"number[]"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArraySizeV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}]},{tfOpName:"TensorArrayCloseV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"}]},{tfOpName:"StatelessIf",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"If",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"StatelessWhile",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"While",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"TensorListScatter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListScatterV2",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"},{start:3,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGather",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListSetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListReserve",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListFromTensor",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListStack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"},{tfName:"num_elements",name:"numElements",type:"dtype"}]},{tfOpName:"TensorListSplit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"},{start:2,name:"lengths",type:"number[]"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcat",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcatV2",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPopBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPushBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListLength",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}]},{tfOpName:"TensorListResize",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"size",type:"number"}]}],Lhe=[{tfOpName:"AvgPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[],notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPoolWithArgmax",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"include_batch_in_index",name:"includeBatchInIndex",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AvgPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Conv1D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"stride",name:"stride",type:"number"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NWC"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"dilation",name:"dilation",type:"number",defaultValue:1}]},{tfOpName:"Conv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"useCudnnOnGpu",name:"useCudnnOnGpu",type:"bool"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"_FusedConv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"use_cudnn_on_gpu",name:"useCudnnOnGpu",type:"bool",defaultValue:!0},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2}]},{tfOpName:"Conv2DBackpropInput",category:"convolution",inputs:[{start:2,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:0,name:"outputShape",type:"number[]"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]",notSupported:!0}]},{tfOpName:"DepthwiseConv2d",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"DepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"FusedDepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]}]},{tfOpName:"Conv3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"Dilation2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"rates",name:"dilations",type:"number[]"},{tfName:"padding",name:"pad",type:"string"}]}],Vhe=[{tfOpName:"Fill",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"},{start:1,name:"value",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"LinSpace",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"num",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"OneHot",category:"creation",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"depth",type:"number"},{start:2,name:"onValue",type:"number",defaultValue:1},{start:3,name:"offValue",type:"number",defaultValue:0}],attrs:[{tfName:"axis",name:"axis",type:"number",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Ones",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"OnesLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"RandomStandardNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniform",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number",defaultValue:0},{tfName:"maxval",name:"maxval",type:"number",defaultValue:1},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniformInt",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number"},{tfName:"maxval",name:"maxval",type:"number"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Range",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"step",type:"number",defaultValue:0}],attrs:[{tfName:"Tidx",name:"dtype",type:"dtype"}]},{tfOpName:"TruncatedNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"means",name:"mean",type:"number",defaultValue:0},{tfName:"stddev",name:"stdDev",type:"number",defaultValue:1},{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Zeros",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"ZerosLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Multinomial",category:"creation",inputs:[{start:0,name:"logits",type:"tensor"},{start:1,name:"numSamples",type:"number"}],attrs:[{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number"},{tfName:"T",name:"dtype",type:"dtype"},{tfName:"output_dtype",name:"output_dtype",type:"dtype"}]}],Bhe=[{tfOpName:"NonMaxSuppressionV2",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV3",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV4",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"T_threshold",name:"threshold",type:"dtype",notSupported:!0},{tfName:"pad_to_max_output_size",name:"padToMaxOutputSize",type:"bool"}]},{tfOpName:"NonMaxSuppressionV5",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"},{start:5,name:"softNmsSigma",type:"number"}]},{tfOpName:"Where",category:"dynamic",inputs:[{start:0,name:"condition",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ListDiff",category:"dynamic",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],zhe=[{tfOpName:"LowerBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"TopKV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"k",type:"number"}],attrs:[{tfName:"sorted",name:"sorted",type:"bool"}]},{tfOpName:"UpperBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"Unique",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"UniqueV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]}],Uhe=[{tfOpName:"PlaceholderWithDefault",category:"graph",inputs:[{start:0,name:"default",type:"tensor"}],attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Placeholder",category:"graph",attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Const",category:"graph"},{tfOpName:"Identity",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IdentityN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Snapshot",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Rank",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Size",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Shape",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"ShapeN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Print",category:"graph",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"data",type:"tensors"}],attrs:[{tfName:"message",name:"message",type:"string"},{tfName:"first_n",name:"firstN",type:"number",notSupported:!0},{tfName:"summarize",name:"summarize",type:"number",defaultValue:3}]},{tfOpName:"NoOp",category:"graph",inputs:[]},{tfOpName:"StopGradient",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"FakeQuantWithMinMaxVars",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"min",name:"min",type:"number"},{tfName:"max",name:"max",type:"number"}]}],Whe=[{tfOpName:"HashTable",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"HashTableV2",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"LookupTableImport",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableImportV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFind",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFindV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableSize",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"LookupTableSizeV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"InitializeTable",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]},{tfOpName:"InitializeTableV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]}],Ghe=[{tfOpName:"ResizeBilinear",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ResizeNearestNeighbor",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"CropAndResize",category:"image",inputs:[{start:0,name:"image",type:"tensor"},{start:1,name:"boxes",type:"tensor"},{start:2,name:"boxInd",type:"tensor"},{start:3,name:"cropSize",type:"number[]"}],attrs:[{tfName:"method",name:"method",type:"string"},{tfName:"extrapolation_value",name:"extrapolationValue",type:"number"}]},{tfOpName:"ImageProjectiveTransformV3",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"transforms",type:"tensor"},{start:2,name:"outputShape",type:"number[]"},{start:3,name:"fillValue",type:"number"}],attrs:[{tfName:"interpolation",name:"interpolation",type:"string"},{tfName:"fill_mode",name:"fillMode",type:"string"}]}],Hhe=[{tfOpName:"Equal",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NotEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Greater",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"GreaterEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Less",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LessEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalAnd",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalNot",category:"logical",inputs:[{start:0,name:"a",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalOr",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Select",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SelectV2",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BitwiseAnd",category:"logical",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}]}],jhe=[{tfOpName:"_FusedMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMulV2",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Transpose",category:"matrices",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"perm",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Einsum",category:"matrices",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"equation",name:"equation",type:"string"},{tfName:"N",name:"n",type:"number",defaultValue:2},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"MatrixBandPart",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"numLower",type:"tensor"},{start:1,name:"numUpper",type:"tensor"}]}],qhe=[{tfOpName:"EuclideanNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",defaultValue:!1}]},{tfOpName:"FusedBatchNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV2",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV3",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"LRN",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"depth_radius",name:"radius",type:"number",defaultValue:5},{tfName:"bias",name:"bias",type:"number",defaultValue:1},{tfName:"alpha",name:"alpha",type:"number",defaultValue:1},{tfName:"beta",name:"beta",type:"number",defaultValue:.5}]},{tfOpName:"Softmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"LogSoftmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]}],Khe=[{tfOpName:"Bincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}]},{tfOpName:"DenseBincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}],attrs:[{tfName:"binary_output",name:"binaryOutput",type:"bool"}]},{tfOpName:"Max",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Mean",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Min",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Sum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"All",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Any",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"ArgMax",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"ArgMin",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"Prod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cumprod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]},{tfOpName:"Cumsum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]}],Xhe=[{tfOpName:"ConcatV2",category:"slice_join",inputs:[{start:0,end:-1,name:"tensors",type:"tensors"},{start:-1,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"Concat",category:"slice_join",inputs:[{start:1,end:0,name:"tensors",type:"tensors"},{start:0,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"GatherV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"axis",type:"number",defaultValue:0}],attrs:[{tfName:"batch_dims",name:"batchDims",type:"number",defaultValue:0}]},{tfOpName:"Gather",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",notSupported:!0}]},{tfOpName:"Reverse",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"dims",type:"bool[]"}]},{tfOpName:"ReverseV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}]},{tfOpName:"Slice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"size",type:"number[]"}]},{tfOpName:"StridedSlice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"end",type:"number[]"},{start:3,name:"strides",type:"number[]"}],attrs:[{tfName:"begin_mask",name:"beginMask",type:"number",defaultValue:0},{tfName:"end_mask",name:"endMask",type:"number",defaultValue:0},{tfName:"new_axis_mask",name:"newAxisMask",type:"number",defaultValue:0},{tfName:"ellipsis_mask",name:"ellipsisMask",type:"number",defaultValue:0},{tfName:"shrink_axis_mask",name:"shrinkAxisMask",type:"number",defaultValue:0}]},{tfOpName:"Pack",category:"slice_join",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0}]},{tfOpName:"Unpack",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0},{tfName:"num",name:"num",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Tile",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"reps",type:"number[]"}]},{tfOpName:"Split",category:"slice_join",inputs:[{start:0,name:"axis",type:"number",defaultValue:0},{start:1,name:"x",type:"tensor"}],attrs:[{tfName:"num_split",name:"numOrSizeSplits",type:"number",defaultValue:1}]},{tfOpName:"SplitV",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"numOrSizeSplits",type:"number[]"},{start:2,name:"axis",type:"number",defaultValue:0}]},{tfOpName:"ScatterNd",category:"slice_join",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"shape",type:"number[]"}]},{tfOpName:"GatherNd",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}]},{tfOpName:"SparseToDense",category:"slice_join",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!1,notSupported:!0}]},{tfOpName:"TensorScatterUpdate",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"values",type:"tensor"}]}],Yhe=[{tfOpName:"SparseFillEmptyRows",category:"sparse",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"denseShape",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}]},{tfOpName:"SparseReshape",category:"sparse",inputs:[{start:0,name:"inputIndices",type:"tensor"},{start:1,name:"inputShape",type:"tensor"},{start:2,name:"newShape",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SparseSegmentMean",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]},{tfOpName:"SparseSegmentSum",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]}],Zhe=[{tfOpName:"FFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"RFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]},{tfOpName:"IRFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]}],Qhe=[{tfOpName:"StaticRegexReplace",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"pattern",name:"pattern",type:"string"},{tfName:"rewrite",name:"rewrite",type:"string"},{tfName:"replace_global",name:"replaceGlobal",type:"bool"}]},{tfOpName:"StringNGrams",category:"string",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"dataSplits",type:"tensor"}],attrs:[{tfName:"separator",name:"separator",type:"string"},{tfName:"ngram_widths",name:"nGramWidths",type:"number[]"},{tfName:"left_pad",name:"leftPad",type:"string"},{tfName:"right_pad",name:"rightPad",type:"string"},{tfName:"pad_width",name:"padWidth",type:"number"},{tfName:"preserve_short_sequences",name:"preserveShortSequences",type:"bool"}],outputs:["ngrams","ngrams_splits"]},{tfOpName:"StringSplit",category:"string",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"delimiter",type:"tensor"}],attrs:[{tfName:"skip_empty",name:"skipEmpty",type:"bool"}],outputs:["indices","values","shape"]},{tfOpName:"StringToHashBucketFast",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"num_buckets",name:"numBuckets",type:"number"}]}],Jhe=[{tfOpName:"Cast",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"SrcT",name:"sdtype",type:"dtype",notSupported:!0},{tfName:"DstT",name:"dtype",type:"dtype"}]},{tfOpName:"ExpandDims",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"MirrorPad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"mode",name:"mode",type:"string"}]},{tfOpName:"Pad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"constant_value",name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"PadV2",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"},{start:2,name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"Reshape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"EnsureShape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"Squeeze",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"axis",tfDeprecatedName:"squeeze_dims",name:"axis",type:"number[]"}]},{tfOpName:"SpaceToBatchND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"paddings",type:"number[]"}]},{tfOpName:"BatchToSpaceND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"crops",type:"number[]"}]},{tfOpName:"DepthToSpace",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"block_size",name:"blockSize",type:"number"},{tfName:"data_format",name:"dataFormat",type:"string"}]},{tfOpName:"BroadcastTo",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}],attrs:[]},{tfOpName:"BroadcastArgs",category:"transformation",inputs:[{start:0,name:"s0",type:"tensor"},{start:1,name:"s1",type:"tensor"}],attrs:[]}];class az{static get Instance(){return this._instance||(this._instance=new this)}constructor(){const e=[].concat(...[Ue,lt,Te,U,ge,_e,re,me,Ae,$e,Bt,Kn,Bn,si,Rr,Ct,Ft,Ot,ce].map(s=>s.json));this.opMappers=e.reduce((s,r)=>(s[r.tfOpName]=r,s),{})}transformGraph(t,e={}){const r=[],i=[],o=[],a=t.node.reduce((g,m)=>(g[m.name]=this.mapNode(m),m.op.startsWith("Placeholder")?r.push(g[m.name]):"Const"===m.op?i.push(g[m.name]):(null==m.input||0===m.input.length)&&o.push(g[m.name]),g),{});let l=[];const u=[];let c={},d={};null!=e&&(c=this.mapSignatureEntries(e.inputs),d=this.mapSignatureEntries(e.outputs));const h=Object.keys(a);h.forEach(g=>{const m=a[g];m.inputNames.forEach((y,b)=>{const[v,,_]=pa(y),x=a[v];if(null!=x.outputs){const C=x.outputs.indexOf(_);-1!==C&&(m.inputNames[b]=`${v}:${C}`)}m.inputs.push(x),x.children.push(m)})}),0===Object.keys(d).length?h.forEach(g=>{const m=a[g];0===m.children.length&&u.push(m)}):Object.keys(d).forEach(g=>{const[m]=pa(g),y=a[m];null!=y&&(y.signatureKey=d[g],u.push(y))}),Object.keys(c).length>0?Object.keys(c).forEach(g=>{const[m]=pa(g),y=a[m];y&&(y.signatureKey=c[g],l.push(y))}):l=r;let f={};null!=t.library&&null!=t.library.function&&(f=t.library.function.reduce((g,m)=>(g[m.signature.name]=this.mapFunction(m),g),{}));const p={nodes:a,inputs:l,outputs:u,weights:i,placeholders:r,signature:e,functions:f};return o.length>0&&(p.initNodes=o),p}mapSignatureEntries(t){return Object.keys(t||{}).reduce((e,s)=>(e[t[s].name]=s,e),{})}mapNode(t){const e=iz(t.op)||this.opMappers[t.op]||{};null==t.attr&&(t.attr={});const s={name:t.name,op:t.op,category:e.category,inputNames:(t.input||[]).map(r=>r.startsWith("^")?r.slice(1):r),inputs:[],children:[],inputParams:{},attrParams:{},rawAttrs:t.attr,outputs:e.outputs};return null!=e.inputs&&(s.inputParams=e.inputs.reduce((r,i)=>(r[i.name]={type:i.type,inputIndexStart:i.start,inputIndexEnd:i.end},r),{})),null!=e.attrs&&(s.attrParams=e.attrs.reduce((r,i)=>{const o=i.type;let a;switch(i.type){case"string":a=VD(t.attr,i.tfName,i.defaultValue),void 0===a&&i.tfDeprecatedName&&(a=VD(t.attr,i.tfDeprecatedName,i.defaultValue));break;case"string[]":a=qD(t.attr,i.tfName,i.defaultValue),void 0===a&&i.tfDeprecatedName&&(a=qD(t.attr,i.tfDeprecatedName,i.defaultValue));break;case"number":a=zD(t.attr,i.tfName,i.defaultValue||0),void 0===a&&i.tfDeprecatedName&&(a=zD(t.attr,i.tfDeprecatedName,i.defaultValue));break;case"number[]":a=jD(t.attr,i.tfName,i.defaultValue),void 0===a&&i.tfDeprecatedName&&(a=jD(t.attr,i.tfDeprecatedName,i.defaultValue));break;case"bool":a=BD(t.attr,i.tfName,i.defaultValue),void 0===a&&i.tfDeprecatedName&&(a=BD(t.attr,i.tfDeprecatedName,i.defaultValue));break;case"bool[]":a=XD(t.attr,i.tfName,i.defaultValue),void 0===a&&i.tfDeprecatedName&&(a=XD(t.attr,i.tfDeprecatedName,i.defaultValue));break;case"shape":a=HD(t.attr,i.tfName,i.defaultValue),void 0===a&&i.tfDeprecatedName&&(a=HD(t.attr,i.tfDeprecatedName,i.defaultValue));break;case"shape[]":a=KD(t.attr,i.tfName,i.defaultValue),void 0===a&&i.tfDeprecatedName&&(a=KD(t.attr,i.tfDeprecatedName,i.defaultValue));break;case"dtype":a=WD(t.attr,i.tfName,i.defaultValue),void 0===a&&i.tfDeprecatedName&&(a=WD(t.attr,i.tfDeprecatedName,i.defaultValue));break;case"dtype[]":a=GD(t.attr,i.tfName,i.defaultValue),void 0===a&&i.tfDeprecatedName&&(a=GD(t.attr,i.tfDeprecatedName,i.defaultValue));break;case"func":a=uz(t.attr,i.tfName,i.defaultValue),void 0===a&&i.tfDeprecatedName&&(a=uz(t.attr,i.tfDeprecatedName,i.defaultValue));break;case"tensor":case"tensors":break;default:throw new Error(`Unsupported param type: ${i.type} for op: ${t.op}`)}return r[i.name]={value:a,type:o},r},{})),s}mapFunction(t){const e=t.nodeDef,r=[];let i={};null!=e&&(i=e.reduce((d,h)=>(d[h.name]=this.mapNode(h),"Const"===h.op&&r.push(d[h.name]),d),{}));const o=[],a=[];t.signature.inputArg.forEach(d=>{const[h]=pa(d.name),f={name:h,op:"Placeholder",inputs:[],inputNames:[],category:"graph",inputParams:{},attrParams:{dtype:{value:UD(d.type),type:"dtype"}},children:[]};f.signatureKey=d.name,o.push(f),i[h]=f}),Object.keys(i).forEach(d=>{const h=i[d];h.inputNames.forEach((f,p)=>{const[g,,m]=pa(f),y=i[g];if(null!=y.outputs){const b=y.outputs.indexOf(m);-1!==b&&(h.inputNames[p]=`${g}:${b}`)}h.inputs.push(y),y.children.push(h)})});const u=t.ret;t.signature.outputArg.forEach(d=>{const[h,f]=pa(u[d.name]),p=i[h];null!=p&&(p.defaultOutput=f,a.push(p))});const c=this.mapArgsToSignature(t);return{nodes:i,inputs:o,outputs:a,weights:r,placeholders:[],signature:c}}mapArgsToSignature(t){return{methodName:t.signature.name,inputs:t.signature.inputArg.reduce((e,s)=>(e[s.name]=this.mapArgToTensorInfo(s),e),{}),outputs:t.signature.outputArg.reduce((e,s)=>(e[s.name]=this.mapArgToTensorInfo(s,t.ret),e),{})}}mapArgToTensorInfo(t,e){let s=t.name;return null!=e&&(s=e[s]),{name:s,dtype:t.type}}}function lz(n,t){const e=Array.isArray(n)?String.fromCharCode.apply(null,n):function efe(n){const t=W().global;if(typeof t.atob<"u")return t.atob(n);if(typeof Buffer<"u")return new Buffer(n,"base64").toString();throw new Error("Unable to decode base64 in this environment. Missing built-in atob() or Buffer()")}(n);return t?e:e.toLowerCase()}function VD(n,t,e,s=!1){const r=n[t];return null!=r?lz(r.s,s):e}function BD(n,t,e){const s=n[t];return s?s.b:e}function zD(n,t,e){const s=n[t]||{},r=null!=s.i?s.i:null!=s.f?s.f:e;return"number"==typeof r?r:parseInt(r,10)}function UD(n){switch("string"==typeof n&&(n=ae[n]),n){case ae.DT_FLOAT:case ae.DT_HALF:return"float32";case ae.DT_INT32:case ae.DT_INT64:case ae.DT_INT8:case ae.DT_UINT8:return"int32";case ae.DT_BOOL:return"bool";case ae.DT_DOUBLE:return"float32";case ae.DT_STRING:return"string";default:return null}}function uz(n,t,e){const s=n[t];return s&&s.func?s.func.name:e}function WD(n,t,e){const s=n[t];return s&&s.type?UD(s.type):e}function GD(n,t,e){const s=n[t];return s&&s.list&&s.list.type?s.list.type.map(r=>UD(r)):e}function cz(n){if(!n.unknownRank)return null!=n.dim?n.dim.map(t=>"number"==typeof t.size?t.size:parseInt(t.size,10)):[]}function HD(n,t,e){const s=n[t];return s&&s.shape?cz(s.shape):e}function jD(n,t,e){const s=n[t];return s?((s.list.f&&s.list.f.length?s.list.f:s.list.i)||[]).map(r=>"number"==typeof r?r:parseInt(r,10)):e}function qD(n,t,e,s=!1){const r=n[t];return r&&r.list&&r.list.s?r.list.s.map(i=>lz(i,s)):e}function KD(n,t,e){const s=n[t];return s&&s.list&&s.list.shape?s.list.shape.map(r=>cz(r)):e}function XD(n,t,e){const s=n[t];return s&&s.list&&s.list.b?s.list.b:e}class tfe{constructor(t,e,s){this.node=t,this.tensorMap=e,this.context=s,this.inputs=[],this.attrs={},this.inputs=t.inputNames.map(r=>this.getInput(r)),null!=t.rawAttrs&&(this.attrs=Object.keys(t.rawAttrs).reduce((r,i)=>(r[i]=this.getAttr(i),r),{}))}getInput(t){return ks(t,this.tensorMap,this.context)}getAttr(t,e){const s=this.node.rawAttrs[t];if(null!=s.tensor)return ks(t,this.tensorMap,this.context);if(null!=s.i||null!=s.f)return zD(this.node.rawAttrs,t,e);if(null!=s.s)return VD(this.node.rawAttrs,t,e);if(null!=s.b)return BD(this.node.rawAttrs,t,e);if(null!=s.shape)return HD(this.node.rawAttrs,t,e);if(null!=s.type)return WD(this.node.rawAttrs,t,e);if(null!=s.list){if(null!=s.list.i||null!=s.list.f)return jD(this.node.rawAttrs,t,e);if(null!=s.list.s)return qD(this.node.rawAttrs,t,e);if(null!=s.list.shape)return KD(this.node.rawAttrs,t,e);if(null!=s.list.b)return XD(this.node.rawAttrs,t,e);if(null!=s.list.type)return GD(this.node.rawAttrs,t,e)}return e}}function xi(n,t,e=""){if("number"!=typeof n&&"number"!=typeof t){S(n.length===t.length,()=>e+` Shapes ${n} and ${t} must match`);for(let s=0;s<n.length;s++){const r=n[s],i=t[s];S(r<0||i<0||r===i,()=>e+` Shapes ${n} and ${t} must match`)}}}function dz(n){return!("number"==typeof n||n.some(t=>t<0))}function Rp(n,t,e){let s=YD(n,e);const r=!dz(s);if(r&&0===t.length)throw new Error(`Tried to calculate elements of an empty list with non-fully-defined elementShape: ${s}`);if(r&&t.forEach(i=>{s=YD(i.shape,s)}),!dz(s))throw new Error(`Non-fully-defined elementShape: ${s}`);return s}function YD(n,t){if("number"==typeof n)return t;if("number"==typeof t)return n;if(n.length!==t.length)throw new Error(`Incompatible ranks during merge: ${n} vs. ${t}`);const e=[];for(let s=0;s<n.length;++s){const r=n[s],i=t[s];if(r>=0&&i>=0&&r!==i)throw new Error(`Incompatible shape during merge: ${n} vs. ${t}`);e[s]=r>=0?r:i}return e}class rfe{constructor(t,e,s,r,i,o,a){this.name=t,this.dtype=e,this.maxSize=s,this.elementShape=r,this.identicalElementShapes=i,this.dynamicSize=o,this.clearAfterRead=a,this.tensors=[],this.closed_=!1,this.idTensor=ze(0),vs(this.idTensor)}get id(){return this.idTensor.id}get closed(){return this.closed_}clearAndClose(t){this.tensors.forEach(e=>{(null==t||!t.has(e.tensor.id))&&e.tensor.dispose()}),this.tensors=[],this.closed_=!0,this.idTensor.dispose()}size(){return this.tensors.length}read(t){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(t<0||t>=this.size())throw new Error(`Tried to read from index ${t}, but array size is: ${this.size()}`);const e=this.tensors[t];if(e.cleared)throw new Error(`TensorArray ${this.name}: Could not read index ${t} twice because it was cleared after a previous read (perhaps try setting clear_after_read = false?).`);return this.clearAfterRead&&(e.cleared=!0),e.read=!0,e.tensor}readMany(t){return t.map(e=>this.read(e))}write(t,e){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(t<0||!this.dynamicSize&&t>=this.maxSize)throw new Error(`Tried to write to index ${t}, but array is not resizeable and size is: ${this.maxSize}`);const s=this.tensors[t]||{};if(e.dtype!==this.dtype)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${t},\n          because the value dtype is ${e.dtype}, but TensorArray dtype is ${this.dtype}.`);if(0===this.size()&&(null==this.elementShape||0===this.elementShape.length)&&(this.elementShape=e.shape),xi(this.elementShape,e.shape,`TensorArray ${this.name}: Could not write to TensorArray index ${t}.`),s.read)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${t}, because it has already been read.`);if(s.written)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${t}, because it has already been written.`);s.tensor=e,vs(e),s.written=!0,this.tensors[t]=s}writeMany(t,e){if(t.length!==e.length)throw new Error(`TensorArray ${this.name}: could not write multiple tensors,because the index size: ${t.length} is not the same as tensors size: ${e.length}.`);t.forEach((s,r)=>this.write(s,e[r]))}gather(t,e){if(e&&e!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but gather requested dtype ${e}`);if(t)t=t.slice(0,this.size());else{t=[];for(let r=0;r<this.size();r++)t.push(r)}if(0===t.length)return Ui([],[0].concat(this.elementShape));const s=this.readMany(t);return xi(this.elementShape,s[0].shape,"TensorArray shape mismatch: "),Xr(s,0)}concat(t){if(t&&t!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but concat requested dtype ${t}`);if(0===this.size())return Ui([],[0].concat(this.elementShape));const e=[];for(let r=0;r<this.size();r++)e.push(r);const s=this.readMany(e);return xi(this.elementShape,s[0].shape,`TensorArray shape mismatch: tensor array shape (${this.elementShape}) vs first tensor shape (${s[0].shape})`),jn(s,0)}scatter(t,e){if(e.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${e.dtype}`);if(t.length!==e.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${t.length} vs. ${e.shape[0]}`);const s=Math.max(...t);if(!this.dynamicSize&&s>=this.maxSize)throw new Error(`Max index must be < array size (${s}  vs. ${this.maxSize})`);this.writeMany(t,bi(e,0))}split(t,e){if(e.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${e.dtype}`);let s=0;const r=t.map(l=>(s+=l,s));if(s!==e.shape[0])throw new Error(`Expected sum of lengths to be equal to\n          tensor.shape[0], but sum of lengths is\n        ${s}, and tensor's shape is: ${e.shape}`);if(!this.dynamicSize&&t.length!==this.maxSize)throw new Error(`TensorArray's size is not equal to the size of lengths (${this.maxSize} vs. ${t.length}), and the TensorArray is not marked as dynamically resizeable`);const i=0===s?0:e.size/s,o=[];z(()=>{e=O(e,[1,s,i]);for(let l=0;l<t.length;++l)o[l]=O(Dt(e,[0,0===l?0:r[l-1],0],[1,t[l],i]),this.elementShape);return o});const a=[];for(let l=0;l<t.length;l++)a[l]=l;this.writeMany(a,o)}}class gu{get id(){return this.idTensor.id}constructor(t,e,s,r=-1){this.tensors=t,this.elementShape=e,this.elementDtype=s,t?.forEach(i=>{if(s!==i.dtype)throw new Error(`Invalid data types; op elements ${s}, but list elements ${i.dtype}`);xi(e,i.shape,"TensorList shape mismatch: "),vs(i)}),this.idTensor=ze(0),this.maxNumElements=r,vs(this.idTensor)}copy(){return new gu([...this.tensors],this.elementShape,this.elementDtype)}clearAndClose(t){this.tensors.forEach(e=>{(null==t||!t.has(e.id))&&e.dispose()}),this.tensors.length=0,this.idTensor.dispose()}size(){return this.tensors.length}stack(t,e,s=-1){if(e!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e}, but list elements ${this.elementDtype}`);if(-1!==s&&this.tensors.length!==s)throw new Error(`Operation expected a list with ${s} elements but got a list with ${this.tensors.length} elements.`);xi(t,this.elementShape,"TensorList shape mismatch: ");const r=Rp(this.elementShape,this.tensors,t);return z(()=>{const i=this.tensors.map(o=>O(o,r));return Xr(i,0)})}popBack(t,e){if(e!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e}, but list elements ${this.elementDtype}`);if(0===this.size())throw new Error("Trying to pop from an empty list.");const s=Rp(this.elementShape,this.tensors,t),r=this.tensors.pop();return r.kept=!1,xi(r.shape,t,"TensorList shape mismatch: "),O(r,s)}pushBack(t){if(t.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t.dtype}, but list elements ${this.elementDtype}`);if(xi(t.shape,this.elementShape,"TensorList shape mismatch: "),this.maxNumElements===this.size())throw new Error("Trying to push element into a full list.");vs(t),this.tensors.push(t)}resize(t){if(t<0)throw new Error(`TensorListResize expects size to be non-negative. Got: ${t}`);if(-1!==this.maxNumElements&&t>this.maxNumElements)throw new Error(`TensorListResize input size ${t} is greater maxNumElement ${this.maxNumElements}.`);const e=new gu([],this.elementShape,this.elementDtype,this.maxNumElements);e.tensors.length=t;for(let s=0;s<Math.min(this.tensors.length,t);++s)e.tensors[s]=this.tensors[s];return e}getItem(t,e,s){if(s!==this.elementDtype)throw new Error(`Invalid data types; op elements ${s}, but list elements ${this.elementDtype}`);if(t<0||t>this.tensors.length)throw new Error(`Trying to access element ${t} in a list with ${this.tensors.length} elements.`);if(null==this.tensors[t])throw new Error(`element at index ${t} is null.`);xi(this.tensors[t].shape,e,"TensorList shape mismatch: ");const r=Rp(this.elementShape,this.tensors,e);return O(this.tensors[t],r)}setItem(t,e){if(e.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e.dtype}, but list elements ${this.elementDtype}`);if(t<0||-1!==this.maxNumElements&&t>=this.maxNumElements)throw new Error(`Trying to set element ${t} in a list with max ${this.maxNumElements} elements.`);xi(this.elementShape,e.shape,"TensorList shape mismatch: "),vs(e),null!=this.tensors[t]&&(this.tensors[t].kept=!1),this.tensors[t]=e}gather(t,e,s){if(e!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e}, but list elements ${this.elementDtype}`);xi(this.elementShape,s,"TensorList shape mismatch: "),t=t.slice(0,this.size());const r=Rp(this.elementShape,this.tensors,s);return 0===t.length?Ui([],[0].concat(r)):z(()=>{const i=t.map(o=>O(this.tensors[o],r));return Xr(i,0)})}concat(t,e){if(t&&t!==this.elementDtype)throw new Error(`TensorList dtype is ${this.elementDtype} but concat requested dtype ${t}`);xi(this.elementShape,e,"TensorList shape mismatch: ");const s=Rp(this.elementShape,this.tensors,e);return 0===this.size()?Ui([],[0].concat(s)):z(()=>{const r=this.tensors.map(i=>O(i,s));return jn(r,0)})}}const ufe=function(){var n=te(function*(t,e,s){switch(t.op){case"If":case"StatelessIf":{const r=w("thenBranch",t,e,s),i=w("elseBranch",t,e,s),o=w("cond",t,e,s),a=w("args",t,e,s);return(yield o.data())[0]?s.functionMap[r].executeFunctionAsync(a,s.tensorArrayMap,s.tensorListMap):s.functionMap[i].executeFunctionAsync(a,s.tensorArrayMap,s.tensorListMap)}case"While":case"StatelessWhile":{const r=w("body",t,e,s),i=w("cond",t,e,s),o=w("args",t,e,s),a=yield s.functionMap[i].executeFunctionAsync(o,s.tensorArrayMap,s.tensorListMap),l=o.map(d=>d.id);let u=yield a[0].data();a.forEach(d=>{!d.kept&&-1===l.indexOf(d.id)&&d.dispose()});let c=o;for(;u[0];){const d=c;c=yield s.functionMap[r].executeFunctionAsync(c,s.tensorArrayMap,s.tensorListMap);const h=c.map(p=>p.id);d.forEach(p=>{!p.kept&&-1===l.indexOf(p.id)&&-1===h.indexOf(p.id)&&p.dispose()});const f=yield s.functionMap[i].executeFunctionAsync(c,s.tensorArrayMap,s.tensorListMap);u=yield f[0].data(),f.forEach(p=>{!p.kept&&-1===l.indexOf(p.id)&&-1===h.indexOf(p.id)&&p.dispose()})}return c}case"LoopCond":return[ma(w("pred",t,e,s))];case"Switch":{const r=w("pred",t,e,s);let i=w("data",t,e,s);return i.kept||(i=ma(i)),(yield r.data())[0]?[void 0,i]:[i,void 0]}case"Merge":{const r=t.inputNames.find(i=>void 0!==ks(i,e,s));return r?[ma(ks(r,e,s))]:void 0}case"Enter":{const r=w("frameName",t,e,s),i=w("tensor",t,e,s);return s.enterFrame(r),[ma(i)]}case"Exit":{const r=w("tensor",t,e,s);return s.exitFrame(),[ma(r)]}case"NextIteration":{const r=w("tensor",t,e,s);return s.nextIteration(),[ma(r)]}case"TensorArrayV3":{const r=w("size",t,e,s),i=w("dtype",t,e,s),o=w("elementShape",t,e,s),a=w("dynamicSize",t,e,s),l=w("clearAfterRead",t,e,s),u=w("identicalElementShapes",t,e,s),c=w("name",t,e,s),d=new rfe(c,i,r,o,u,a,l);return s.addTensorArray(d),[d.idTensor,ze(1)]}case"TensorArrayWriteV3":{const r=w("tensorArrayId",t,e,s),i=w("index",t,e,s),o=w("tensor",t,e,s),a=s.getTensorArray(r.id);return a.write(i,o),[a.idTensor]}case"TensorArrayReadV3":{const r=w("tensorArrayId",t,e,s),i=w("index",t,e,s);return[s.getTensorArray(r.id).read(i)]}case"TensorArrayGatherV3":{const r=w("tensorArrayId",t,e,s),i=w("indices",t,e,s),o=w("dtype",t,e,s);return[s.getTensorArray(r.id).gather(i,o)]}case"TensorArrayScatterV3":{const r=w("tensorArrayId",t,e,s),i=w("indices",t,e,s),o=w("tensor",t,e,s),a=s.getTensorArray(r.id);return a.scatter(i,o),[a.idTensor]}case"TensorArrayConcatV3":{const r=w("tensorArrayId",t,e,s),i=s.getTensorArray(r.id),o=w("dtype",t,e,s);return[i.concat(o)]}case"TensorArraySplitV3":{const r=w("tensorArrayId",t,e,s),i=w("tensor",t,e,s),o=w("lengths",t,e,s),a=s.getTensorArray(r.id);return a.split(o,i),[a.idTensor]}case"TensorArraySizeV3":{const r=w("tensorArrayId",t,e,s);return[ze(s.getTensorArray(r.id).size(),"int32")]}case"TensorArrayCloseV3":{const r=w("tensorArrayId",t,e,s),i=s.getTensorArray(r.id);return i.clearAndClose(),[i.idTensor]}case"TensorListSetItem":{const r=w("tensorListId",t,e,s),i=w("index",t,e,s),o=w("tensor",t,e,s),a=s.getTensorList(r.id);return a.setItem(i,o),[a.idTensor]}case"TensorListGetItem":{const r=w("tensorListId",t,e,s),i=w("index",t,e,s),o=w("elementShape",t,e,s),a=w("elementDType",t,e,s);return[s.getTensorList(r.id).getItem(i,o,a)]}case"TensorListScatterV2":case"TensorListScatter":{const r=w("indices",t,e,s),l=function afe(n,t,e,s){if(t.length!==n.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${t.length} vs. ${n.shape[0]}`);const r=Math.max(...t);if(null!=s&&-1!==s&&r>=s)throw new Error(`Max index must be < array size (${r}  vs. ${s})`);const i=new gu([],e,n.dtype,s),o=bi(n,0);return t.forEach((a,l)=>{i.setItem(a,o[l])}),i}(w("tensor",t,e,s),r,w("elementShape",t,e,s),w("numElements",t,e,s));return s.addTensorList(l),[l.idTensor]}case"TensorListReserve":case"EmptyTensorList":{const r=w("elementShape",t,e,s),i=w("elementDType",t,e,s);let o;o="TensorListReserve"===t.op?"numElements":"maxNumElements";const a=w(o,t,e,s),u=function ofe(n,t,e,s){return new gu([],n,t,s)}(r,i,0,"TensorListReserve"===t.op?-1:a);return s.addTensorList(u),[u.idTensor]}case"TensorListGather":{const r=w("tensorListId",t,e,s),i=w("indices",t,e,s),o=w("elementShape",t,e,s),a=w("elementDType",t,e,s);return[s.getTensorList(r.id).gather(i,a,o)]}case"TensorListStack":{const r=w("tensorListId",t,e,s),i=w("elementShape",t,e,s),o=w("elementDType",t,e,s),a=w("numElements",t,e,s);return[s.getTensorList(r.id).stack(i,o,a)]}case"TensorListFromTensor":{const a=function ife(n,t,e){const s=n.dtype;if(n.shape.length<1)throw new Error(`Tensor must be at least a vector, but saw shape: ${n.shape}`);if(n.dtype!==e)throw new Error(`Invalid data types; op elements ${n.dtype}, but list elements ${e}`);xi(n.shape.slice(1),t,"TensorList shape mismatch: ");const i=bi(n);return new gu(i,t,s)}(w("tensor",t,e,s),w("elementShape",t,e,s),w("elementDType",t,e,s));return s.addTensorList(a),[a.idTensor]}case"TensorListConcat":case"TensorListConcatV2":{const r=w("tensorListId",t,e,s),i=s.getTensorList(r.id),o=w("dtype",t,e,s),a=w("elementShape",t,e,s);return[i.concat(o,a)]}case"TensorListPushBack":{const r=w("tensorListId",t,e,s),i=w("tensor",t,e,s),o=s.getTensorList(r.id);return o.pushBack(i),[o.idTensor]}case"TensorListPopBack":{const r=w("tensorListId",t,e,s),i=w("elementShape",t,e,s),o=w("elementDType",t,e,s);return[s.getTensorList(r.id).popBack(i,o)]}case"TensorListSplit":{const r=w("tensor",t,e,s),i=w("elementShape",t,e,s),a=function lfe(n,t,e){let s=0;const r=t.map(c=>(s+=c,s));if(s!==n.shape[0])throw new Error(`Expected sum of lengths to be equal to\n          tensor.shape[0], but sum of lengths is\n        ${s}, and tensor's shape is: ${n.shape}`);const o=YD(n.shape.slice(1),e),a=0===s?0:n.size/s,l=z(()=>{const c=[];n=O(n,[1,s,a]);for(let d=0;d<t.length;++d)c[d]=O(Dt(n,[0,0===d?0:r[d-1],0],[1,t[d],a]),o);return n.dispose(),c}),u=new gu([],e,n.dtype,t.length);for(let c=0;c<l.length;c++)u.setItem(c,l[c]);return u}(r,w("lengths",t,e,s),i);return s.addTensorList(a),[a.idTensor]}case"TensorListLength":{const r=w("tensorListId",t,e,s);return[ze(s.getTensorList(r.id).size(),"int32")]}case"TensorListResize":{const r=w("tensorListId",t,e,s),i=w("size",t,e,s),a=s.getTensorList(r.id).resize(i);return s.addTensorList(a),[a.idTensor]}default:throw TypeError(`Node type ${t.op} is not implemented`)}});return function(e,s,r){return n.apply(this,arguments)}}();function hz(n,t,e){const[s,r]=w("fusedOps",n,t,e),i="biasadd"===s,o=!i,a="prelu"===r,l="fusedbatchnorm"===s,u=w("numArgs",n,t,e);if(i){if(a&&2!==u)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!a&&i&&1!==u)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd must have one extra argument: bias.")}if(l)throw new Error("FusedConv2d and DepthwiseConv2d with FusedBatchNorm is not supported");const c=w("strides",n,t,e),d=Nv(n,t,e),h=w("dataFormat",n,t,e).toUpperCase(),f=w("dilations",n,t,e);let[p,g]=w("args",n,t,e);return o&&(g=p,p=void 0),{stride:c,pad:d,dataFormat:h,dilations:f,biasArg:p,preluArg:g,activationFunc:r,leakyreluAlpha:w("leakyreluAlpha",n,t,e)}}function ZD(n,t,e){return{boxes:w("boxes",n,t,e),scores:w("scores",n,t,e),maxOutputSize:w("maxOutputSize",n,t,e),iouThreshold:w("iouThreshold",n,t,e),scoreThreshold:w("scoreThreshold",n,t,e),softNmsSigma:w("softNmsSigma",n,t,e)}}const hfe=function(){var n=te(function*(t,e,s,r,i=J){switch(t.op){case"NonMaxSuppressionV5":{const{boxes:o,scores:a,maxOutputSize:l,iouThreshold:u,scoreThreshold:c,softNmsSigma:d}=ZD(t,e,s),h=yield i.image.nonMaxSuppressionWithScoreAsync(o,a,l,u,c,d);return[h.selectedIndices,h.selectedScores]}case"NonMaxSuppressionV4":{const{boxes:o,scores:a,maxOutputSize:l,iouThreshold:u,scoreThreshold:c}=ZD(t,e,s),d=w("padToMaxOutputSize",t,e,s),h=yield i.image.nonMaxSuppressionPaddedAsync(o,a,l,u,c,d);return[h.selectedIndices,h.validOutputs]}case"NonMaxSuppressionV3":case"NonMaxSuppressionV2":{const{boxes:o,scores:a,maxOutputSize:l,iouThreshold:u,scoreThreshold:c}=ZD(t,e,s);return[yield i.image.nonMaxSuppressionAsync(o,a,l,u,c)]}case"Where":{const o=i.cast(w("condition",t,e,s),"bool"),a=[yield i.whereAsync(o)];return o.dispose(),a}case"ListDiff":return i.setdiff1dAsync(w("x",t,e,s),w("y",t,e,s));default:throw TypeError(`Node type ${t.op} is not implemented`)}});return function(e,s,r,i){return n.apply(this,arguments)}}();class mfe{get id(){return this.handle.id}constructor(t,e){this.keyDType=t,this.valueDType=e,this.handle=ze(0),this.tensorMap=new Map,vs(this.handle)}clearAndClose(){this.tensorMap.forEach(t=>t.dispose()),this.tensorMap.clear(),this.handle.dispose()}size(){return this.tensorMap.size}tensorSize(){return ze(this.size(),"int32")}import(t,e){var s=this;return te(function*(){s.checkKeyAndValueTensor(t,e);const r=yield t.data();return s.tensorMap.forEach(i=>i.dispose()),s.tensorMap.clear(),z(()=>{const i=bi(e),o=r.length,a=i.length;S(o===a,()=>`The number of elements doesn't match, keys has ${o} elements, the values has ${a} elements.`);for(let l=0;l<o;l++){const u=r[l],c=i[l];vs(c),s.tensorMap.set(u,c)}return s.handle})})()}find(t,e){var s=this;return te(function*(){s.checkKeyAndValueTensor(t,e);const r=yield t.data();return z(()=>{const i=[];for(let o=0;o<r.length;o++){const l=s.findWithDefault(r[o],e);i.push(l)}return Xr(i)})})()}findWithDefault(t,e){return this.tensorMap.get(t)??e}checkKeyAndValueTensor(t,e){if(t.dtype!==this.keyDType)throw new Error(`Expect key dtype ${this.keyDType}, but got ${t.dtype}`);if(e.dtype!==this.valueDType)throw new Error(`Expect value dtype ${this.valueDType}, but got ${e.dtype}`)}}const gfe=function(){var n=te(function*(t,e,s,r){switch(t.op){case"HashTable":case"HashTableV2":{const i=r.getHashTableHandleByName(t.name);if(null!=i)return[i];{const o=w("keyDType",t,e,s),a=w("valueDType",t,e,s),l=new mfe(o,a);return r.addHashTable(t.name,l),[l.handle]}}case"InitializeTable":case"InitializeTableV2":case"LookupTableImport":case"LookupTableImportV2":{const i=w("tableHandle",t,e,s,r),o=w("keys",t,e,s),a=w("values",t,e,s);return[yield r.getHashTableById(i.id).import(o,a)]}case"LookupTableFind":case"LookupTableFindV2":{const i=w("tableHandle",t,e,s,r),o=w("keys",t,e,s),a=w("defaultValue",t,e,s);return[yield r.getHashTableById(i.id).find(o,a)]}case"LookupTableSize":case"LookupTableSizeV2":{const i=w("tableHandle",t,e,s,r);return[r.getHashTableById(i.id).tensorSize()]}default:throw TypeError(`Node type ${t.op} is not implemented`)}});return function(e,s,r,i){return n.apply(this,arguments)}}();function fz(n,t,e,s,r=z){const i=((o,a,l)=>{switch(o.category){case"arithmetic":return r(()=>((n,t,e,s=J)=>{switch(n.op){case"BiasAdd":case"AddV2":case"Add":return[s.add(w("a",n,t,e),w("b",n,t,e))];case"AddN":return[s.addN(w("tensors",n,t,e))];case"FloorMod":case"Mod":return[s.mod(w("a",n,t,e),w("b",n,t,e))];case"Mul":return[s.mul(w("a",n,t,e),w("b",n,t,e))];case"RealDiv":case"Div":return[s.div(w("a",n,t,e),w("b",n,t,e))];case"DivNoNan":return[s.divNoNan(w("a",n,t,e),w("b",n,t,e))];case"FloorDiv":return[s.floorDiv(w("a",n,t,e),w("b",n,t,e))];case"Sub":return[s.sub(w("a",n,t,e),w("b",n,t,e))];case"Minimum":return[s.minimum(w("a",n,t,e),w("b",n,t,e))];case"Maximum":return[s.maximum(w("a",n,t,e),w("b",n,t,e))];case"Pow":return[s.pow(w("a",n,t,e),w("b",n,t,e))];case"SquaredDifference":return[s.squaredDifference(w("a",n,t,e),w("b",n,t,e))];default:throw TypeError(`Node type ${n.op} is not implemented`)}})(o,a,l));case"basic_math":return r(()=>((n,t,e,s=J)=>{switch(n.op){case"Abs":case"ComplexAbs":return[s.abs(w("x",n,t,e))];case"Acos":return[s.acos(w("x",n,t,e))];case"Acosh":return[s.acosh(w("x",n,t,e))];case"Asin":return[s.asin(w("x",n,t,e))];case"Asinh":return[s.asinh(w("x",n,t,e))];case"Atan":return[s.atan(w("x",n,t,e))];case"Atan2":return[s.atan2(w("x",n,t,e),w("y",n,t,e))];case"Atanh":return[s.atanh(w("x",n,t,e))];case"Ceil":return[s.ceil(w("x",n,t,e))];case"Complex":return[s.complex(w("real",n,t,e),w("imag",n,t,e))];case"Cos":return[s.cos(w("x",n,t,e))];case"Cosh":return[s.cosh(w("x",n,t,e))];case"Elu":return[s.elu(w("x",n,t,e))];case"Erf":return[s.erf(w("x",n,t,e))];case"Exp":return[s.exp(w("x",n,t,e))];case"Expm1":return[s.expm1(w("x",n,t,e))];case"Floor":return[s.floor(w("x",n,t,e))];case"Log":return[s.log(w("x",n,t,e))];case"Log1p":return[s.log1p(w("x",n,t,e))];case"Imag":return[s.imag(w("x",n,t,e))];case"Neg":return[s.neg(w("x",n,t,e))];case"Reciprocal":return[s.reciprocal(w("x",n,t,e))];case"Real":return[s.real(w("x",n,t,e))];case"Relu":return[s.relu(w("x",n,t,e))];case"Round":return[s.round(w("x",n,t,e))];case"Selu":return[s.selu(w("x",n,t,e))];case"Sigmoid":return[s.sigmoid(w("x",n,t,e))];case"Sin":return[s.sin(w("x",n,t,e))];case"Sign":return[s.sign(w("x",n,t,e))];case"Sinh":return[s.sinh(w("x",n,t,e))];case"Softplus":return[s.softplus(w("x",n,t,e))];case"Sqrt":return[s.sqrt(w("x",n,t,e))];case"Square":return[s.square(w("x",n,t,e))];case"Tanh":return[s.tanh(w("x",n,t,e))];case"Tan":return[s.tan(w("x",n,t,e))];case"ClipByValue":return[s.clipByValue(w("x",n,t,e),w("clipValueMin",n,t,e),w("clipValueMax",n,t,e))];case"Relu6":return[s.relu6(w("x",n,t,e))];case"Rsqrt":return[s.rsqrt(ks(n.inputNames[0],t,e))];case"LeakyRelu":return[s.leakyRelu(w("x",n,t,e),w("alpha",n,t,e))];case"Prelu":return[s.prelu(w("x",n,t,e),w("alpha",n,t,e))];case"IsNan":return[s.isNaN(ks(n.inputNames[0],t,e))];case"IsInf":return[s.isInf(ks(n.inputNames[0],t,e))];case"IsFinite":return[s.isFinite(ks(n.inputNames[0],t,e))];default:throw TypeError(`Node type ${n.op} is not implemented`)}})(o,a,l));case"control":return ufe(o,a,l);case"convolution":return r(()=>((n,t,e,s=J)=>{switch(n.op){case"Conv1D":{const r=w("stride",n,t,e),i=w("pad",n,t,e),o=w("dataFormat",n,t,e).toUpperCase(),a=w("dilation",n,t,e);return[s.conv1d(w("x",n,t,e),w("filter",n,t,e),r,i,o,a)]}case"Conv2D":{const r=w("strides",n,t,e),i=Nv(n,t,e),o=w("dataFormat",n,t,e).toUpperCase(),a=w("dilations",n,t,e);return[s.conv2d(w("x",n,t,e),w("filter",n,t,e),[r[1],r[2]],i,o,[a[1],a[2]])]}case"_FusedConv2D":{const{stride:r,pad:i,dataFormat:o,dilations:a,biasArg:l,preluArg:u,activationFunc:c,leakyreluAlpha:d}=hz(n,t,e);return[s.fused.conv2d({x:w("x",n,t,e),filter:w("filter",n,t,e),strides:[r[1],r[2]],pad:i,dataFormat:o,dilations:[a[1],a[2]],bias:l,activation:c,preluActivationWeights:u,leakyreluAlpha:d})]}case"FusedDepthwiseConv2dNative":{const{stride:r,pad:i,dataFormat:o,dilations:a,biasArg:l,preluArg:u,activationFunc:c,leakyreluAlpha:d}=hz(n,t,e);return[s.fused.depthwiseConv2d({x:w("x",n,t,e),filter:w("filter",n,t,e),strides:[r[1],r[2]],pad:i,dataFormat:o,dilations:[a[1],a[2]],bias:l,activation:c,preluActivationWeights:u,leakyreluAlpha:d})]}case"Conv2DBackpropInput":case"Conv2dTranspose":{const r=w("outputShape",n,t,e),i=w("strides",n,t,e),o=Nv(n,t,e);return[s.conv2dTranspose(w("x",n,t,e),w("filter",n,t,e),r,[i[1],i[2]],o)]}case"DepthwiseConv2dNative":case"DepthwiseConv2d":{const r=w("strides",n,t,e),i=Nv(n,t,e),o=w("dilations",n,t,e),a=w("dataFormat",n,t,e).toUpperCase();return[s.depthwiseConv2d(w("input",n,t,e),w("filter",n,t,e),[r[1],r[2]],i,a,[o[1],o[2]])]}case"Conv3D":{const r=w("strides",n,t,e),i=w("pad",n,t,e),o=w("dataFormat",n,t,e).toUpperCase(),a=w("dilations",n,t,e);return[s.conv3d(w("x",n,t,e),w("filter",n,t,e),[r[1],r[2],r[3]],i,o,[a[1],a[2],a[3]])]}case"AvgPool":{const r=w("strides",n,t,e),i=w("pad",n,t,e),o=w("kernelSize",n,t,e);return[s.avgPool(w("x",n,t,e),[o[1],o[2]],[r[1],r[2]],i)]}case"MaxPool":{const r=w("strides",n,t,e),i=w("pad",n,t,e),o=w("kernelSize",n,t,e);return[s.maxPool(w("x",n,t,e),[o[1],o[2]],[r[1],r[2]],i)]}case"MaxPoolWithArgmax":{const r=w("strides",n,t,e),i=w("pad",n,t,e),o=w("kernelSize",n,t,e),a=w("includeBatchInIndex",n,t,e),{result:l,indexes:u}=s.maxPoolWithArgmax(w("x",n,t,e),[o[1],o[2]],[r[1],r[2]],i,a);return[l,u]}case"AvgPool3D":{const r=w("strides",n,t,e),i=w("pad",n,t,e),o=w("kernelSize",n,t,e);return[s.avgPool3d(w("x",n,t,e),[o[1],o[2],o[3]],[r[1],r[2],r[3]],i)]}case"MaxPool3D":{const r=w("strides",n,t,e),i=w("pad",n,t,e),o=w("kernelSize",n,t,e);return[s.maxPool3d(w("x",n,t,e),[o[1],o[2],o[3]],[r[1],r[2],r[3]],i)]}case"Dilation2D":{const r=w("strides",n,t,e),i=w("pad",n,t,e),o=w("dilations",n,t,e),a=r[1],l=r[2],u=o[1],c=o[2];return[s.dilation2d(w("x",n,t,e),w("filter",n,t,e),[a,l],i,[u,c],"NHWC")]}default:throw TypeError(`Node type ${n.op} is not implemented`)}})(o,a,l));case"creation":return r(()=>((n,t,e,s=J)=>{switch(n.op){case"Fill":{const r=w("shape",n,t,e),i=w("dtype",n,t,e),o=w("value",n,t,e);return[s.fill(r,o,i)]}case"LinSpace":{const r=w("start",n,t,e),i=w("stop",n,t,e),o=w("num",n,t,e);return[s.linspace(r,i,o)]}case"Multinomial":{const r=w("logits",n,t,e),i=w("numSamples",n,t,e),o=w("seed",n,t,e);return[s.multinomial(r,i,o)]}case"OneHot":{const r=w("indices",n,t,e),i=w("depth",n,t,e),o=w("onValue",n,t,e),a=w("offValue",n,t,e),l=w("dtype",n,t,e);return[s.oneHot(r,i,o,a,l)]}case"Ones":return[s.ones(w("shape",n,t,e),w("dtype",n,t,e))];case"OnesLike":return[s.onesLike(w("x",n,t,e))];case"RandomStandardNormal":return[s.randomStandardNormal(w("shape",n,t,e),w("dtype",n,t,e),w("seed",n,t,e))];case"RandomUniform":return[s.randomUniform(w("shape",n,t,e),w("minval",n,t,e),w("maxval",n,t,e),w("dtype",n,t,e))];case"RandomUniformInt":return[s.randomUniformInt(w("shape",n,t,e),w("minval",n,t,e),w("maxval",n,t,e),w("seed",n,t,e))];case"Range":{const r=w("start",n,t,e),i=w("stop",n,t,e),o=w("step",n,t,e);return[s.range(r,i,o,w("dtype",n,t,e))]}case"TruncatedNormal":{const r=w("shape",n,t,e),i=w("mean",n,t,e),o=w("stdDev",n,t,e),a=w("seed",n,t,e);return[s.truncatedNormal(r,i,o,w("dtype",n,t,e),a)]}case"Zeros":return[s.zeros(w("shape",n,t,e),w("dtype",n,t,e))];case"ZerosLike":return[s.zerosLike(w("x",n,t,e))];default:throw TypeError(`Node type ${n.op} is not implemented`)}})(o,a,l));case"dynamic":return hfe(o,a,l);case"evaluation":return r(()=>((n,t,e,s=J)=>{switch(n.op){case"LowerBound":{const r=w("sortedSequence",n,t,e),i=w("values",n,t,e);return[s.lowerBound(r,i)]}case"TopKV2":{const r=w("x",n,t,e),i=w("k",n,t,e),o=w("sorted",n,t,e),a=s.topk(r,i,o);return[a.values,a.indices]}case"UpperBound":{const r=w("sortedSequence",n,t,e),i=w("values",n,t,e);return[s.upperBound(r,i)]}case"Unique":{const r=w("x",n,t,e),i=s.unique(r);return[i.values,i.indices]}case"UniqueV2":{const r=w("x",n,t,e),i=w("axis",n,t,e),o=s.unique(r,i);return[o.values,o.indices]}default:throw TypeError(`Node type ${n.op} is not implemented`)}})(o,a,l));case"image":return r(()=>((n,t,e,s=J)=>{switch(n.op){case"ResizeBilinear":{const r=w("images",n,t,e),i=w("size",n,t,e),o=w("alignCorners",n,t,e),a=w("halfPixelCenters",n,t,e);return[s.image.resizeBilinear(r,[i[0],i[1]],o,a)]}case"ResizeNearestNeighbor":{const r=w("images",n,t,e),i=w("size",n,t,e),o=w("alignCorners",n,t,e),a=w("halfPixelCenters",n,t,e);return[s.image.resizeNearestNeighbor(r,[i[0],i[1]],o,a)]}case"CropAndResize":{const r=w("image",n,t,e),i=w("boxes",n,t,e),o=w("boxInd",n,t,e),a=w("cropSize",n,t,e),l=w("method",n,t,e),u=w("extrapolationValue",n,t,e);return[s.image.cropAndResize(r,i,o,a,l,u)]}case"ImageProjectiveTransformV3":{const r=w("images",n,t,e),i=w("transforms",n,t,e),o=w("outputShape",n,t,e),a=w("fillValue",n,t,e),l=w("interpolation",n,t,e),u=w("fillMode",n,t,e);return[s.image.transform(r,i,l.toLowerCase(),u.toLowerCase(),a,o)]}default:throw TypeError(`Node type ${n.op} is not implemented`)}})(o,a,l));case"graph":return r(()=>((n,t,e,s=J)=>{switch(n.op){case"Const":return t[n.name];case"PlaceholderWithDefault":const r=w("default",n,t,e);return[ks(n.name,t,e)||r];case"Placeholder":return[ks(n.name,t,e)];case"Identity":case"StopGradient":case"FakeQuantWithMinMaxVars":case"Snapshot":return[ma(w("x",n,t,e))];case"IdentityN":return w("x",n,t,e).map(c=>ma(c));case"Shape":return[s.tensor1d(w("x",n,t,e).shape,"int32")];case"ShapeN":return w("x",n,t,e).map(c=>s.tensor1d(c.shape));case"Size":return[s.scalar(w("x",n,t,e).size,"int32")];case"Rank":return[s.scalar(w("x",n,t,e).rank,"int32")];case"NoOp":return[s.scalar(1)];case"Print":const o=w("x",n,t,e),a=w("data",n,t,e),l=w("message",n,t,e),u=w("summarize",n,t,e);console.warn("The graph has a tf.print() operation,usually used for debugging, which slows down performance."),console.log(l);for(let c=0;c<a.length;c++)console.log(Array.prototype.slice.call(a[c].dataSync()).slice(0,u));return[o];default:throw TypeError(`Node type ${n.op} is not implemented`)}})(o,a,l));case"logical":return r(()=>((n,t,e,s=J)=>{switch(n.op){case"Equal":return[s.equal(w("a",n,t,e),w("b",n,t,e))];case"NotEqual":return[s.notEqual(w("a",n,t,e),w("b",n,t,e))];case"Greater":return[s.greater(w("a",n,t,e),w("b",n,t,e))];case"GreaterEqual":return[s.greaterEqual(w("a",n,t,e),w("b",n,t,e))];case"Less":return[s.less(w("a",n,t,e),w("b",n,t,e))];case"LessEqual":return[s.lessEqual(w("a",n,t,e),w("b",n,t,e))];case"LogicalAnd":return[s.logicalAnd(w("a",n,t,e),w("b",n,t,e))];case"LogicalNot":return[s.logicalNot(w("a",n,t,e))];case"LogicalOr":return[s.logicalOr(w("a",n,t,e),w("b",n,t,e))];case"Select":case"SelectV2":return[s.where(w("condition",n,t,e),w("a",n,t,e),w("b",n,t,e))];case"BitwiseAnd":return[s.bitwiseAnd(w("a",n,t,e),w("b",n,t,e))];default:throw TypeError(`Node type ${n.op} is not implemented`)}})(o,a,l));case"matrices":return r(()=>((n,t,e,s=J)=>{switch(n.op){case"BatchMatMul":case"BatchMatMulV2":case"MatMul":return[s.matMul(w("a",n,t,e),w("b",n,t,e),w("transposeA",n,t,e),w("transposeB",n,t,e))];case"Einsum":return[s.einsum(w("equation",n,t,e),...w("tensors",n,t,e))];case"Transpose":return[s.transpose(w("x",n,t,e),w("perm",n,t,e))];case"_FusedMatMul":const[r,i]=w("fusedOps",n,t,e),o="biasadd"===r,a="prelu"===i,l=w("numArgs",n,t,e),u=w("leakyreluAlpha",n,t,e);if(o){if(a&&2!==l)throw new Error("Fused MatMul with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!a&&1!==l)throw new Error("Fused MatMul with BiasAdd must have one extra argument: bias.")}const[c,d]=w("args",n,t,e);return[s.fused.matMul({a:w("a",n,t,e),b:w("b",n,t,e),transposeA:w("transposeA",n,t,e),transposeB:w("transposeB",n,t,e),bias:c,activation:i,preluActivationWeights:d,leakyreluAlpha:u})];case"MatrixBandPart":return[s.linalg.bandPart(w("a",n,t,e),w("numLower",n,t,e),w("numUpper",n,t,e))];default:throw TypeError(`Node type ${n.op} is not implemented`)}})(o,a,l));case"normalization":return r(()=>((n,t,e,s=J)=>{switch(n.op){case"EuclideanNorm":return[s.euclideanNorm(w("x",n,t,e),w("axis",n,t,e),w("keepDims",n,t,e))];case"FusedBatchNorm":case"FusedBatchNormV2":case"FusedBatchNormV3":return[s.batchNorm(w("x",n,t,e),w("mean",n,t,e),w("variance",n,t,e),w("offset",n,t,e),w("scale",n,t,e),w("epsilon",n,t,e))];case"LRN":return[s.localResponseNormalization(w("x",n,t,e),w("radius",n,t,e),w("bias",n,t,e),w("alpha",n,t,e),w("beta",n,t,e))];case"Softmax":return[s.softmax(w("x",n,t,e))];case"LogSoftmax":return[s.logSoftmax(w("x",n,t,e))];default:throw TypeError(`Node type ${n.op} is not implemented`)}})(o,a,l));case"ragged":return r(()=>((n,t,e,s=J)=>{switch(n.op){case"RaggedGather":{const{outputNestedSplits:r,outputDenseValues:i}=s.raggedGather(w("paramsNestedSplits",n,t,e),w("paramsDenseValues",n,t,e),w("indices",n,t,e),w("outputRaggedRank",n,t,e));return r.concat(i)}case"RaggedRange":{const{rtNestedSplits:r,rtDenseValues:i}=s.raggedRange(w("starts",n,t,e),w("limits",n,t,e),w("splits",n,t,e));return[r,i]}case"RaggedTensorToTensor":return[s.raggedTensorToTensor(w("shape",n,t,e),w("values",n,t,e),w("defaultValue",n,t,e),w("rowPartitionTensors",n,t,e),w("rowPartitionTypes",n,t,e))];default:throw TypeError(`Node type ${n.op} is not implemented`)}})(o,a,l));case"reduction":return r(()=>((n,t,e,s=J)=>{switch(n.op){case"Max":{const a=w("axis",n,t,e),l=w("keepDims",n,t,e);return[s.max(w("x",n,t,e),a,l)]}case"Mean":{const a=w("axis",n,t,e),l=w("keepDims",n,t,e);return[s.mean(w("x",n,t,e),a,l)]}case"Min":{const a=w("axis",n,t,e),l=w("keepDims",n,t,e);return[s.min(w("x",n,t,e),a,l)]}case"Sum":{const a=w("axis",n,t,e),l=w("keepDims",n,t,e);return[s.sum(w("x",n,t,e),a,l)]}case"All":{const a=w("axis",n,t,e),l=w("keepDims",n,t,e);return[s.all(w("x",n,t,e),a,l)]}case"Any":{const a=w("axis",n,t,e),l=w("keepDims",n,t,e);return[s.any(w("x",n,t,e),a,l)]}case"ArgMax":{const a=w("axis",n,t,e);return[s.argMax(w("x",n,t,e),a)]}case"ArgMin":{const a=w("axis",n,t,e);return[s.argMin(w("x",n,t,e),a)]}case"Prod":{const a=w("axis",n,t,e),l=w("keepDims",n,t,e);return[s.prod(w("x",n,t,e),a,l)]}case"Cumprod":{const a=w("axis",n,t,e),l=w("exclusive",n,t,e),u=w("reverse",n,t,e);return[s.cumprod(w("x",n,t,e),a,l,u)]}case"Cumsum":{const a=w("axis",n,t,e),l=w("exclusive",n,t,e),u=w("reverse",n,t,e);return[s.cumsum(w("x",n,t,e),a,l,u)]}case"Bincount":const r=w("x",n,t,e),i=w("weights",n,t,e),o=w("size",n,t,e);return[s.bincount(r,i,o)];case"DenseBincount":{const a=w("x",n,t,e),l=w("weights",n,t,e),u=w("size",n,t,e),c=w("binaryOutput",n,t,e);return[s.denseBincount(a,l,u,c)]}default:throw TypeError(`Node type ${n.op} is not implemented`)}})(o,a,l));case"slice_join":return r(()=>((n,t,e,s=J)=>{switch(n.op){case"ConcatV2":case"Concat":{const r=w("n",n,t,e),i=w("axis",n,t,e);let o=w("tensors",n,t,e);return o=o.slice(0,r),[s.concat(o,i)]}case"Gather":{const r=w("x",n,t,e),i=w("indices",n,t,e);return[s.gather(r,s.cast(i,"int32"),0)]}case"GatherV2":{const r=w("axis",n,t,e),i=w("batchDims",n,t,e),o=w("x",n,t,e),a=w("indices",n,t,e);return[s.gather(o,s.cast(a,"int32"),r,i)]}case"Reverse":{const r=w("dims",n,t,e),i=[];for(let a=0;a<r.length;a++)r[a]&&i.push(a);const o=w("x",n,t,e);return[s.reverse(o,i)]}case"ReverseV2":{const r=w("axis",n,t,e),i=w("x",n,t,e);return[s.reverse(i,r)]}case"Slice":{const r=w("begin",n,t,e),i=w("size",n,t,e);return[s.slice(w("x",n,t,e),r,i)]}case"StridedSlice":{const r=w("begin",n,t,e),i=w("end",n,t,e),o=w("strides",n,t,e),a=w("beginMask",n,t,e),l=w("endMask",n,t,e),u=w("ellipsisMask",n,t,e),c=w("newAxisMask",n,t,e),d=w("shrinkAxisMask",n,t,e),h=w("x",n,t,e);return[s.stridedSlice(h,r,i,o,a,l,u,c,d)]}case"Pack":return z(()=>{const r=w("axis",n,t,e),i=w("tensors",n,t,e),o=i[0].shape,a=s.squeeze(i[0]).shape,l=i.map(u=>{const c=wt(u.shape,o);if(!c&&!wt(s.squeeze(u).shape,a))throw new Error("the input tensors shape does not match");return c?u:s.reshape(u,o)});return[s.stack(l,r)]});case"Unpack":{const r=w("axis",n,t,e),i=w("tensor",n,t,e);return s.unstack(i,r)}case"Tile":{const r=w("reps",n,t,e);return[s.tile(w("x",n,t,e),r)]}case"Split":case"SplitV":{const r=w("axis",n,t,e),i=w("numOrSizeSplits",n,t,e),o=w("x",n,t,e);return s.split(o,i,r)}case"ScatterNd":{const r=w("indices",n,t,e),i=w("values",n,t,e),o=w("shape",n,t,e);return[s.scatterND(r,i,o)]}case"GatherNd":{const r=w("x",n,t,e),i=w("indices",n,t,e);return[s.gatherND(r,i)]}case"SparseToDense":{const r=w("sparseIndices",n,t,e),i=w("outputShape",n,t,e),o=w("sparseValues",n,t,e),a=w("defaultValue",n,t,e);return[s.sparseToDense(r,o,i,o.dtype===a.dtype?a:s.cast(a,o.dtype))]}case"TensorScatterUpdate":{const r=w("indices",n,t,e),i=w("values",n,t,e),o=w("tensor",n,t,e);return[s.tensorScatterUpdate(o,r,i)]}default:throw TypeError(`Node type ${n.op} is not implemented`)}})(o,a,l));case"sparse":return r(()=>((n,t,e,s=J)=>{switch(n.op){case"SparseFillEmptyRows":{const{outputIndices:r,outputValues:i,emptyRowIndicator:o,reverseIndexMap:a}=s.sparse.sparseFillEmptyRows(w("indices",n,t,e),w("values",n,t,e),w("denseShape",n,t,e),w("defaultValue",n,t,e));return[r,i,o,a]}case"SparseReshape":{const{outputIndices:r,outputShape:i}=s.sparse.sparseReshape(w("inputIndices",n,t,e),w("inputShape",n,t,e),w("newShape",n,t,e));return[r,i]}case"SparseSegmentMean":return[s.sparse.sparseSegmentMean(w("data",n,t,e),w("indices",n,t,e),w("segmentIds",n,t,e))];case"SparseSegmentSum":return[s.sparse.sparseSegmentSum(w("data",n,t,e),w("indices",n,t,e),w("segmentIds",n,t,e))];default:throw TypeError(`Node type ${n.op} is not implemented`)}})(o,a,l));case"spectral":return r(()=>((n,t,e,s=J)=>{switch(n.op){case"FFT":return[s.fft(w("x",n,t,e))];case"IFFT":return[s.ifft(w("x",n,t,e))];case"RFFT":return[s.rfft(w("x",n,t,e))];case"IRFFT":return[s.irfft(w("x",n,t,e))];default:throw TypeError(`Node type ${n.op} is not implemented`)}})(o,a,l));case"string":return r(()=>((n,t,e,s=J)=>{switch(n.op){case"StaticRegexReplace":return[s.string.staticRegexReplace(w("input",n,t,e),w("pattern",n,t,e),w("rewrite",n,t,e),w("replaceGlobal",n,t,e))];case"StringNGrams":{const{nGrams:r,nGramsSplits:i}=s.string.stringNGrams(w("data",n,t,e),w("dataSplits",n,t,e),w("separator",n,t,e),w("nGramWidths",n,t,e),w("leftPad",n,t,e),w("rightPad",n,t,e),w("padWidth",n,t,e),w("preserveShortSequences",n,t,e));return[r,i]}case"StringSplit":{const{indices:r,values:i,shape:o}=s.string.stringSplit(w("input",n,t,e),w("delimiter",n,t,e),w("skipEmpty",n,t,e));return[r,i,o]}case"StringToHashBucketFast":return[s.string.stringToHashBucketFast(w("input",n,t,e),w("numBuckets",n,t,e))];default:throw TypeError(`Node type ${n.op} is not implemented`)}})(o,a,l));case"transformation":return r(()=>((n,t,e,s=J)=>{switch(n.op){case"Cast":return[s.cast(w("x",n,t,e),w("dtype",n,t,e))];case"ExpandDims":{const r=w("axis",n,t,e);return[s.expandDims(w("x",n,t,e),r)]}case"Squeeze":{const r=w("axis",n,t,e);return[s.squeeze(w("x",n,t,e),r)]}case"Reshape":return[s.reshape(w("x",n,t,e),w("shape",n,t,e))];case"EnsureShape":return[s.ensureShape(w("x",n,t,e),w("shape",n,t,e))];case"MirrorPad":return[s.mirrorPad(w("x",n,t,e),w("padding",n,t,e),w("mode",n,t,e))];case"PadV2":case"Pad":return[s.pad(w("x",n,t,e),w("padding",n,t,e),w("constantValue",n,t,e))];case"SpaceToBatchND":{const r=w("blockShape",n,t,e),i=w("paddings",n,t,e);return[s.spaceToBatchND(w("x",n,t,e),r,i)]}case"BatchToSpaceND":{const r=w("blockShape",n,t,e),i=w("crops",n,t,e);return[s.batchToSpaceND(w("x",n,t,e),r,i)]}case"DepthToSpace":{const r=w("blockSize",n,t,e),i=w("dataFormat",n,t,e).toUpperCase();return[s.depthToSpace(w("x",n,t,e),r,i)]}case"BroadcastTo":return[s.broadcastTo(w("x",n,t,e),w("shape",n,t,e))];case"BroadcastArgs":return[s.broadcastArgs(w("s0",n,t,e),w("s1",n,t,e))];default:throw TypeError(`Node type ${n.op} is not implemented`)}})(o,a,l));case"hash_table":return gfe(o,a,l,s);case"custom":const u=iz(o.op);if(u&&u.customExecutor)return u.customExecutor(new tfe(o,a,l));throw TypeError(`Custom op ${o.op} is not registered.`);default:throw TypeError(`Unknown op '${o.op}'. File an issue at https://github.com/tensorflow/tfjs/issues so we can add it, or register a custom execution with tf.registerOp()`)}})(n,t,e);return Zl(i)?i.then(o=>[].concat(o)):[].concat(i)}class pz{constructor(t={},e={},s={},r={},i){this.weightMap=t,this.tensorArrayMap=e,this.tensorListMap=s,this.functionMap=r,this.parseNodeNameCache=i,this.rootContext={id:0,frameName:"",iterationId:0},this.contexts=[this.rootContext],this.lastId=0,this.generateCurrentContextIds()}newFrame(t,e){return{id:t,frameName:e,iterationId:0}}set currentContext(t){this.contexts!==t&&(this.contexts=t,this.generateCurrentContextIds())}get currentContext(){return this.contexts}get currentContextId(){return this._currentContextIds[0]}get currentContextIds(){return this._currentContextIds}generateCurrentContextIds(){const t=[];for(let e=0;e<this.contexts.length-1;e++){const s=this.contexts.slice(0,this.contexts.length-e);t.push(this.contextIdforContexts(s))}t.push(""),this._currentContextIds=t}contextIdforContexts(t){return t?t.map(e=>0===e.id&&0===e.iterationId?"":`${e.frameName}-${e.iterationId}`).join("/"):""}enterFrame(t){this.contexts&&(this.lastId++,this.contexts=this.contexts.slice(),this.contexts.push(this.newFrame(this.lastId,t)),this._currentContextIds.unshift(this.contextIdforContexts(this.contexts)))}exitFrame(){if(!(this.contexts&&this.contexts.length>1))throw new Error("Cannot exit frame, the context is empty");this.contexts=this.contexts.slice(),this.contexts.splice(-1),this.currentContextIds.shift()}nextIteration(){if(!(this.contexts&&this.contexts.length>0))throw new Error("Cannot increase frame iteration, the context is empty");{this.contexts=this.contexts.slice(),this.lastId++;const t=Object.assign({},this.contexts[this.contexts.length-1]);t.iterationId+=1,t.id=this.lastId,this.contexts.splice(-1,1,t),this._currentContextIds.splice(0,1,this.contextIdforContexts(this.contexts))}}getWeight(t){return this.weightMap[t]}addTensorArray(t){this.tensorArrayMap[t.id]=t}getTensorArray(t){return this.tensorArrayMap[t]}addTensorList(t){this.tensorListMap[t.id]=t}getTensorList(t){return this.tensorListMap[t]}dispose(t){for(const e in this.tensorArrayMap)this.tensorArrayMap[e].clearAndClose(t);for(const e in this.tensorListMap)this.tensorListMap[e].clearAndClose(t)}}function mz(n,t,e,s){const r=new Set,i=[];let o=null,a=null;const l=new Set,u=new Set(Object.keys(n).map(h=>Nr(h)[0]));s=s||[];const c=new Set(s.map(h=>Nr(h.name)[0])),d=[...t];for(;d.length>0;){const h=d.pop();if((yu(h)||Ofe(h)||$fe(h))&&null==o&&(o=h,a=o.children.map(f=>f.name).filter(f=>r.has(f))),r.add(h.name),null==e[h.name]&&!u.has(h.name)&&!c.has(h.name)){if(0===h.inputs.length){i.push(h.name);continue}h.inputs.forEach(f=>{l.has(f.name)||(l.add(f.name),d.push(f))})}}return{inputs:n,outputs:t,usedNodes:r,missingInputs:i,dynamicNode:o,syncInputs:a}}class kv extends Error{constructor(t){super(`NodesExecutionOrderError: ${t}`)}}const Rfe=new Set(["Switch","Merge","Enter","Exit","NextIteration","StatelessIf","StatelessWhile","if","While"]),Mfe=new Set(["NonMaxSuppressionV2","NonMaxSuppressionV3","NonMaxSuppressionV5","Where"]),Ffe=new Set(["HashTable","HashTableV2","LookupTableImport","LookupTableImportV2","LookupTableFind","LookupTableFindV2","LookupTableSize","LookupTableSizeV2"]);function yu(n){return Rfe.has(n.op)}function Ofe(n){return Mfe.has(n.op)}function $fe(n){return Ffe.has(n.op)}class Av{get weightIds(){return this.parent?this.parent.weightIds:this._weightIds}get functionExecutorMap(){return this.parent?this.parent.functionExecutorMap:this._functionExecutorMap}get weightMap(){return this.parent?this.parent.weightMap:this._weightMap}set weightMap(t){const e=Object.keys(t).map(s=>t[s].map(r=>r.id));this._weightIds=[].concat(...e),this._weightMap=t}set resourceManager(t){this._resourceManager=t}get inputs(){return this._inputs.map(t=>({name:t.name,shape:t.attrParams.shape?t.attrParams.shape.value:void 0,dtype:t.attrParams.dtype?t.attrParams.dtype.value:void 0}))}get outputs(){return this._outputs.map(t=>({name:t.name,shape:t.attrParams.shape?t.attrParams.shape.value:void 0,dtype:t.attrParams.dtype?t.attrParams.dtype.value:void 0}))}get inputNodes(){return this._inputs.map(t=>t.signatureKey||t.name)}get outputNodes(){return this._outputs.map(t=>{const e=t.signatureKey||t.name;return t.defaultOutput?`${e}:${t.defaultOutput}`:e})}get functions(){return Object.keys(this._functions).reduce((t,e)=>(t[e]=this._functions[e].signature,t),{})}constructor(t,e){this.graph=t,this.parent=e,this.compiledMap=new Map,this.parseNodeNameCache=new Map,this._weightMap={},this.SEPARATOR=",",this._functions={},this._functionExecutorMap={},this.keepIntermediateTensors=!1,this._outputs=t.outputs,this._inputs=t.inputs,this._initNodes=t.initNodes,this._signature=t.signature,this._functions=t.functions,null!=t.functions&&Object.keys(t.functions).forEach(s=>{this._functionExecutorMap[s]=new Av(t.functions[s],this)})}getCompilationKey(t,e){const s=t.map(i=>i.name).sort(),r=e.map(i=>i.name).sort();return s.join(this.SEPARATOR)+"--"+r.join(this.SEPARATOR)}compile(t,e){const s=mz(t,e,this.weightMap,this._initNodes),{missingInputs:r,dynamicNode:i,syncInputs:o}=s;if(null!=i)throw new Error(`This execution contains the node '${i.name}', which has the dynamic op '${i.op}'. Please use model.executeAsync() instead. Alternatively, to avoid the dynamic ops, specify the inputs [${o}]`);if(r.length>0){const u=e.map(d=>d.name),c=Object.keys(t);throw new Error(`Cannot compute the outputs [${u}] from the provided inputs [${c}]. Missing the following inputs: [${r}]`)}const a=function Tfe(n,t){const{usedNodes:e,inputs:s}=t,o=m=>e.has("string"==typeof m?m:m.name);function a(m){return[...new Map(m.map(y=>[y.name,y])).values()]}const l=a([...Object.keys(s).map(m=>Nr(m)[0]).map(m=>n.nodes[m]),...n.weights,...n.initNodes||[]]).filter(o),u=a([...l,...Object.values(n.nodes)]).filter(o),c=new Map(u.map(m=>[m.name,m])),d={};for(const m of u){d[m.name]=d[m.name]||0;for(const y of m.children)o(y)||(d[y.name]=Number.POSITIVE_INFINITY),d[y.name]=(d[y.name]||0)+1}const h=Object.entries(d).filter(([,m])=>0===m).map(([m])=>m),f=[...h];for(;h.length>0;){const m=h.pop(),y=c.get(m);for(const b of y.children.filter(o))0==--d[b.name]&&(f.push(b.name),h.push(b.name))}const g=function Nfe(n,t){const e=new Map(n.map(o=>[o.name,o])),s=t.map(o=>o.name),r=new Set(s);for(;s.length>0;){const o=s.pop(),a=e.get(o);for(const l of a.children)!e.has(l.name)||r.has(l.name)||(r.add(l.name),s.push(l.name))}return n.filter(o=>r.has(o.name))}(f.map(m=>c.get(m)),l);return function kfe(n,t){const e=new Map(n.map((a,l)=>[a.name,l])),s=new Set(t.map(a=>a.name)),r=a=>s.has("string"==typeof a?a:a.name),i=new Set(n.map(a=>a.name)),o=a=>i.has("string"==typeof a?a:a.name);for(const a of n){for(const l of a.children.filter(o)){if(!e.has(l.name))throw new kv(`Child ${l.name} of node ${a.name} is unreachable.`);if(e.get(a.name)>e.get(l.name))throw new kv(`Node ${a.name} is scheduled to run after its child ${l.name}.`)}if(!r(a))for(const l of a.inputs){if(!e.has(l.name))throw new kv(`Input ${l.name} of node ${a.name} is unreachable.`);if(e.get(l.name)>e.get(a.name))throw new kv(`Node ${a.name} is scheduled to run before its input ${l.name}.`)}}}(g,l),g}(this.graph,s),l=function Afe(n){const t=new Map(n.map((a,l)=>[a.name,l])),e=Number.MAX_SAFE_INTEGER,s=n.map((a,l)=>yu(a)?e:l),r=a=>s[t.get(a.name)]??-1,i=n.map((a,l)=>a.children.map(r).reduce((u,c)=>Math.max(u,c),s[l])),o=new Map;for(let a=0;a<n.length;++a){const l=i[a];if(l===e)continue;const u=n[a],c=n[l];o.has(c.name)||o.set(c.name,[]),o.get(c.name).push(u)}return o}(a);return{orderedNodes:a,nodeLiveUntilMap:l}}cloneAndKeepTensor(t){if(null==t)return null;const e=t.clone();return vs(e),e}cloneTensorList(t){return t?t.map(s=>this.cloneAndKeepTensor(s)):null}cloneTensorMap(t){return Object.fromEntries(Object.entries(t).map(([e,s])=>[e,this.cloneTensorList(s)]))}execute(t,e){this.disposeIntermediateTensors(),t=this.mapInputs(t);const s=Object.keys(t).sort();this.checkInputs(t),this.checkInputShapeAndType(t),e=this.mapOutputs(e),this.checkOutputs(e);const r=s.map(h=>this.graph.nodes[Nr(h)[0]]),i=e.map(h=>Nr(h)[0]),o=new Set(i);let a=i.map(h=>this.graph.nodes[h]);0===a.length&&(a=this._outputs);const l=this.getCompilationKey(r,a);let u=this.compiledMap.get(l);null==u&&(u=this.compile(t,a),this.compiledMap.set(l,u));try{this.keepIntermediateTensors=W().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(h){this.keepIntermediateTensors=!1,console.warn(h.message)}const c={},d={};return z(()=>{const h=new pz(this.weightMap,c,d,this.functionExecutorMap,this.parseNodeNameCache),f=Object.assign({},this.weightMap);this.keepIntermediateTensors&&(this.clonedTensorsMap=this.cloneTensorMap(this.weightMap)),Object.keys(t).forEach(y=>{const[b,v]=Nr(y,h),_=[];_[v]=t[y],f[b]=_,this.keepIntermediateTensors&&(this.clonedTensorsMap[b]=this.cloneTensorList(_))});const p=this.getFrozenTensorIds(f),{orderedNodes:g,nodeLiveUntilMap:m}=u;for(const y of g){if(f[y.name])continue;const b=fz(y,f,h,this._resourceManager);if(Zl(b))throw new Error(`The execution of the op '${y.op}' returned a promise. Please use model.executeAsync() instead.`);f[y.name]=b,this.keepIntermediateTensors&&(this.clonedTensorsMap[y.name]=this.cloneTensorList(b)),this.checkTensorForDisposalWithNodeLiveUntilInfo(y,f,h,p,o,m.get(y.name))}return null==this.parent&&h.dispose(p),e.map(y=>ks(y,f,h))})}getFrozenTensorIds(t){const e=[].concat.apply([],Object.keys(t).map(s=>t[s]).map(s=>s.map(r=>r.id)));return new Set(e)}checkTensorForDisposal(t,e,s,r,i,o,a){if(!yu(e)&&!o.has(t)){for(const l of s[t])null!=l&&(a[l.id]=(a[l.id]||0)+e.children.length);for(const l of e.inputs){if(yu(l))continue;const u=oz(l.name,s,r);if(null!=u)for(const c of u){if(!c||c.kept||i.has(c.id))continue;const d=a[c.id];1===d?(c.dispose(),delete a[c.id]):null!=d&&a[c.id]--}}}}checkTensorForDisposalWithNodeLiveUntilInfo(t,e,s,r,i,o){function a(l){return yu(l)||i.has(l.name)}if(!yu(t)&&null!=o)for(const l of o){if(a(l))continue;const u=oz(l.name,e,s);for(const c of u)!c||c.kept||r.has(c.id)||c.dispose()}}executeAsync(t,e){var s=this;return te(function*(){return s._executeAsync(t,e)})()}disposeIntermediateTensors(){this.clonedTensorsMap&&(Object.values(this.clonedTensorsMap).forEach(t=>{for(const e of t)e&&!e.isDisposed&&e.dispose()}),this.clonedTensorsMap=null)}getIntermediateTensors(){return this.clonedTensorsMap}_executeAsync(t,e,s=!1,r={},i={}){var o=this;return te(function*(){o.disposeIntermediateTensors(),s||(t=o.mapInputs(t),o.checkInputs(t),o.checkInputShapeAndType(t),e=o.mapOutputs(e),o.checkOutputs(e));try{o.keepIntermediateTensors=W().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(f){o.keepIntermediateTensors=!1,console.warn(f.message)}const a=new pz(o.weightMap,r,i,o.functionExecutorMap,o.parseNodeNameCache);o.keepIntermediateTensors&&(o.clonedTensorsMap=o.cloneTensorMap(o.weightMap));const l=yield o.executeWithControlFlow(t,a,e,s),u=e.map(f=>ks(f,l,a)),c=u.map(f=>f.id),d=Object.keys(t).map(f=>t[f].id),h=new Set([...c,...d,...o.weightIds]);return Object.values(l).forEach(f=>{f.forEach(p=>{p&&!p.isDisposed&&!h.has(p.id)&&p.dispose()})}),null==o.parent&&a.dispose(h),u})()}executeFunctionAsync(t,e,s){var r=this;return te(function*(){const i=t.reduce((o,a,l)=>(o[r.inputs[l].name]=a,o),{});return r._executeAsync(i,r.outputNodes,!0,e,s)})()}executeWithControlFlow(t,e,s,r){var i=this;return te(function*(){const o=Object.keys(t),a=o.map(x=>i.graph.nodes[Nr(x)[0]]),l=s.map(x=>Nr(x)[0]),u=new Set(l);let c=l.map(x=>i.graph.nodes[x]);0===c.length&&(c=i._outputs);const{usedNodes:d,missingInputs:h,dynamicNode:f,syncInputs:p}=mz(t,c,i.weightMap,i._initNodes),g=[...a,...i.graph.weights,...i._initNodes||[]].map(x=>({node:x,contexts:e.currentContext})),m=Object.assign({},i.weightMap);Object.keys(t).forEach(x=>{const[C,E]=Nr(x),D=[];D[E]=t[x],m[C]=D});const y={},b=i.getFrozenTensorIds(m),v={};for(;g.length>0;){const x=i.processStack(a,g,e,m,v,b,u,y,d);yield Promise.all(x)}null==f&&!r&&console.warn("This model execution did not contain any nodes with control flow or dynamic output shapes. You can use model.execute() instead.");const _=c.filter(x=>!yu(x)&&!ks(x.name,m,e)).map(x=>x.name);if(_.length>0){let x="";throw null!=f&&(x=`Alternatively, to avoid the dynamic ops, use model.execute() and specify the inputs [${p}]`),new Error(`Cannot compute the outputs [${_}] from the provided inputs [${o}]. Consider providing the following inputs: [${h}]. ${x}`)}return m})()}processStack(t,e,s,r,i,o,a,l,u){const c=[];for(;e.length>0;){const d=e.pop();s.currentContext=d.contexts;let h="";if("Enter"===d.node.op&&w("isConstant",d.node,r,s)&&([h]=pa(d.node.name,s)),null==r[d.node.name]){const f=fz(d.node,r,s,this._resourceManager);h||([h]=pa(d.node.name,s));const p=s.currentContext;Zl(f)?c.push(f.then(g=>(r[h]=g,this.keepIntermediateTensors&&(this.clonedTensorsMap[h]=this.cloneTensorList(g)),s.currentContext=p,this.checkTensorForDisposal(h,d.node,r,s,o,a,l),this.processChildNodes(d.node,e,s,r,i,u),g))):(r[h]=f,this.keepIntermediateTensors&&(this.clonedTensorsMap[h]=this.cloneTensorList(f)),this.checkTensorForDisposal(h,d.node,r,s,o,a,l),this.processChildNodes(d.node,e,s,r,i,u))}else this.processChildNodes(d.node,e,s,r,i,u)}return c}processChildNodes(t,e,s,r,i,o){t.children.forEach(a=>{const[l]=pa(a.name,s);i[l]||!o.has(a.name)||("Merge"===a.op?a.inputNames.some(u=>!!ks(u,r,s))&&(i[l]=!0,e.push({contexts:s.currentContext,node:a})):a.inputNames.every(u=>!!ks(u,r,s))&&(i[l]=!0,e.push({contexts:s.currentContext,node:a})))})}dispose(){Object.keys(this.weightMap).forEach(t=>this.weightMap[t].forEach(e=>e.dispose()))}checkInputShapeAndType(t){Object.keys(t).forEach(e=>{const s=t[e],[r]=Nr(e),i=this.graph.nodes[r];if(i.attrParams.shape&&i.attrParams.shape.value){const o=i.attrParams.shape.value;S(o.length===s.shape.length&&s.shape.every((l,u)=>-1===o[u]||o[u]===l),()=>`The shape of dict['${i.name}'] provided in model.execute(dict) must be [${o}], but was [${s.shape}]`)}i.attrParams.dtype&&i.attrParams.dtype.value&&S(s.dtype===i.attrParams.dtype.value,()=>`The dtype of dict['${i.name}'] provided in model.execute(dict) must be ${i.attrParams.dtype.value}, but was ${s.dtype}`)})}mapInputs(t){var e,s;const r={};for(const i in t){const o=null===(s=null===(e=this._signature)||void 0===e?void 0:e.inputs)||void 0===s?void 0:s[i];null!=o?r[o.name]=t[i]:r[i]=t[i]}return r}checkInputs(t){const e=Object.keys(t).filter(s=>{const[r]=Nr(s);return null==this.graph.nodes[r]});if(e.length>0)throw new Error(`The dict provided in model.execute(dict) has keys: [${e}] that are not part of graph`)}mapOutputs(t){return t.map(e=>{var s,r;const i=null===(r=null===(s=this._signature)||void 0===s?void 0:s.outputs)||void 0===r?void 0:r[e];return null!=i?i.name:e},{})}checkOutputs(t){t.forEach(e=>{const[s]=Nr(e);if(!this.graph.nodes[s])throw new Error(`The output '${e}' is not found in the graph`)})}}class Pfe{constructor(t={},e={}){this.hashTableNameToHandle=t,this.hashTableMap=e}addHashTable(t,e){this.hashTableNameToHandle[t]=e.handle,this.hashTableMap[e.id]=e}getHashTableHandleByName(t){return this.hashTableNameToHandle[t]}getHashTableById(t){return this.hashTableMap[t]}dispose(){for(const t in this.hashTableMap)this.hashTableMap[t].clearAndClose(),delete this.hashTableMap[t];for(const t in this.hashTableNameToHandle)this.hashTableNameToHandle[t].dispose(),delete this.hashTableNameToHandle[t]}}const Lfe="?tfjs-format=file",Vfe="model.json";class gz{get modelVersion(){return this.version}get inputNodes(){return this.executor.inputNodes}get outputNodes(){return this.executor.outputNodes}get inputs(){return this.executor.inputs}get outputs(){return this.executor.outputs}get weights(){return this.executor.weightMap}get metadata(){return this.artifacts.userDefinedMetadata}get modelSignature(){return this.signature}get modelStructuredOutputKeys(){return this.structuredOutputKeys}constructor(t,e={},s=We){this.modelUrl=t,this.loadOptions=e,this.version="n/a",this.io=s,null==e&&(this.loadOptions={}),this.resourceManager=new Pfe}findIOHandler(){const t=this.modelUrl;if(null!=t.load)this.handler=t;else if(null!=this.loadOptions.requestInit)this.handler=this.io.browserHTTPRequest(t,this.loadOptions);else{const e=this.io.getLoadHandlers(t,this.loadOptions);if(0===e.length)e.push(this.io.browserHTTPRequest(t,this.loadOptions));else if(e.length>1)throw new Error(`Found more than one (${e.length}) load handlers for URL '${[t]}'`);this.handler=e[0]}}load(){if(this.findIOHandler(),null==this.handler.load)throw new Error("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");const t=this.handler.load();return Zl(t)?t.then(e=>this.loadSync(e)):this.loadSync(t)}loadSync(t){this.artifacts=t;const e=this.artifacts.modelTopology;let s=this.artifacts.signature;if(null!=this.artifacts.userDefinedMetadata){const i=this.artifacts.userDefinedMetadata;null!=i.signature&&(s=i.signature),null!=i.structuredOutputKeys&&(this.structuredOutputKeys=i.structuredOutputKeys)}this.signature=s,this.version=`${e.versions.producer}.${e.versions.minConsumer}`;const r=this.io.decodeWeights(this.artifacts.weightData,this.artifacts.weightSpecs);if(this.executor=new Av(az.Instance.transformGraph(e,this.signature)),this.executor.weightMap=this.convertTensorMapToTensorsMap(r),this.executor.resourceManager=this.resourceManager,null!=t.modelInitializer&&null!=t.modelInitializer.node){const i=az.Instance.transformGraph(t.modelInitializer);this.initializer=new Av(i),this.initializer.weightMap=this.executor.weightMap,this.initializer.resourceManager=this.resourceManager,this.initializerSignature=t.initializerSignature}return!0}save(t,e){var s=this;return te(function*(){if("string"==typeof t){const r=s.io.getSaveHandlers(t);if(0===r.length)throw new Error(`Cannot find any save handlers for URL '${t}'`);if(r.length>1)throw new Error(`Found more than one (${r.length}) save handlers for URL '${t}'`);t=r[0]}if(null==t.save)throw new Error("GraphModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");return t.save(s.artifacts)})()}addStructuredOutputNames(t){if(this.structuredOutputKeys){const s={};return(t instanceof pn?[t]:t).forEach((r,i)=>s[this.structuredOutputKeys[i]]=r),s}return t}predict(t,e){const s=this.execute(t,this.outputNodes);return this.addStructuredOutputNames(s)}predictAsync(t,e){var s=this;return te(function*(){const r=yield s.executeAsync(t,s.outputNodes);return s.addStructuredOutputNames(r)})()}normalizeInputs(t){var e;if(!(t instanceof pn||Array.isArray(t))){const i=null===(e=this.signature)||void 0===e?void 0:e.inputs;if(null!=i)for(const o in i){const a=i[o];null!=a.resourceId&&(t[o]=this.resourceIdToCapturedInput[a.resourceId])}return t}t=Array.isArray(t)?t:[t];const s=Object.keys(this.resourceIdToCapturedInput).length;if(t.length+s!==this.inputNodes.length)throw new Error(`Input tensor count mismatch, the graph model has ${this.inputNodes.length-s} non-resource placeholders, while there are ${t.length} input tensors provided.`);let r=0;return this.inputNodes.reduce((i,o)=>{var a,l,u;const c=null===(u=null===(l=null===(a=this.signature)||void 0===a?void 0:a.inputs)||void 0===l?void 0:l[o])||void 0===u?void 0:u.resourceId;return i[o]=null!=c?this.resourceIdToCapturedInput[c]:t[r++],i},{})}normalizeOutputs(t){return t=t||this.outputNodes,Array.isArray(t)?t:[t]}executeInitializerGraph(){return null==this.initializer?[]:this.initializer.execute({},null==this.initializerSignature?[]:Object.keys(this.initializerSignature.outputs))}executeInitializerGraphAsync(){var t=this;return te(function*(){return null==t.initializer?[]:t.initializer.executeAsync({},null==t.initializerSignature?[]:Object.keys(t.initializerSignature.outputs))})()}setResourceIdToCapturedInput(t){if(this.resourceIdToCapturedInput={},this.initializerSignature){const e=this.initializerSignature.outputs,s=Object.keys(e);for(let r=0;r<s.length;r++)this.resourceIdToCapturedInput[e[s[r]].resourceId]=t[r]}}execute(t,e){null==this.resourceIdToCapturedInput&&this.setResourceIdToCapturedInput(this.executeInitializerGraph()),t=this.normalizeInputs(t),e=this.normalizeOutputs(e);const s=this.executor.execute(t,e);return s.length>1?s:s[0]}executeAsync(t,e){var s=this;return te(function*(){null==s.resourceIdToCapturedInput&&s.setResourceIdToCapturedInput(yield s.executeInitializerGraphAsync()),t=s.normalizeInputs(t),e=s.normalizeOutputs(e);const r=yield s.executor.executeAsync(t,e);return r.length>1?r:r[0]})()}getIntermediateTensors(){return this.executor.getIntermediateTensors()}disposeIntermediateTensors(){this.executor.disposeIntermediateTensors()}convertTensorMapToTensorsMap(t){return Object.keys(t).reduce((e,s)=>(e[s]=[t[s]],e),{})}dispose(){this.executor.dispose(),this.initializer&&(this.initializer.dispose(),this.resourceIdToCapturedInput&&gt(this.resourceIdToCapturedInput)),this.resourceManager.dispose()}}function QD(n){return JD.apply(this,arguments)}function JD(){return(JD=te(function*(n,t={},e=We){if(null==n)throw new Error("modelUrl in loadGraphModel() cannot be null. Please provide a url or an IOHandler that loads the model");null==t&&(t={}),t.fromTFHub&&"string"==typeof n&&(n=function Bfe(n){return n.endsWith("/")||(n+="/"),`${n}${Vfe}${Lfe}`}(n));const s=new gz(n,t,e);return yield s.load(),s})).apply(this,arguments)}function Me(n,t){Array.isArray(n)||(n=[n]),n.forEach(e=>{null!=e&&S("complex64"!==e.dtype,()=>`${t} does not support complex64 tensors in the CPU backend.`)})}Symbol("out"),Symbol("field"),Symbol("quote"),Symbol("quoteafterquote"),Symbol("quoteinquote");const ppe=pE;let mpe=(()=>{class n extends OC{nextDataId(){return n.nextDataId++}constructor(){super(),this.blockSize=48,this.firstUse=!0,this.data=new D2(this,vo())}write(e,s,r){this.firstUse&&(this.firstUse=!1,W().get("IS_NODE")&&Gr("\n============================\nHi, looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, visit https://github.com/tensorflow/tfjs-node for more details. \n============================"));const i={id:this.nextDataId()};return this.data.set(i,{values:e,dtype:r,refCount:1}),i}makeTensorInfo(e,s,r){let i;if("string"===s&&null!=r&&r.length>0&&Jh(r[0])){const o=r.map(a=>Pa(a));i=this.write(o,e,s)}else i=this.write(r,e,s);return{dataId:i,shape:e,dtype:s}}refCount(e){return this.data.has(e)?this.data.get(e).refCount:0}incRef(e){this.data.get(e).refCount++}decRef(e){this.data.has(e)&&this.data.get(e).refCount--}move(e,s,r,i,o){this.data.set(e,{values:s,dtype:i,refCount:o})}numDataIds(){return this.data.numDataIds()}read(e){var s=this;return te(function*(){return s.readSync(e)})()}readSync(e){const{dtype:s,complexTensorInfos:r}=this.data.get(e);return"complex64"===s?ca(this.readSync(r.real.dataId),this.readSync(r.imag.dataId)):function Oee(n,t){if(Array.isArray(n))return n;if("float32"===t)return n instanceof Float32Array?n:new Float32Array(n);if("int32"===t)return n instanceof Int32Array?n:new Int32Array(n);if("bool"===t||"string"===t)return Uint8Array.from(new Int32Array(n));throw new Error(`Unknown dtype ${t}`)}(this.data.get(e).values,s)}bufferSync(e){const s=this.readSync(e.dataId);if("string"===e.dtype)try{const r=s.map(i=>La(i));return dt(e.shape,e.dtype,r)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return dt(e.shape,e.dtype,s)}makeOutput(e,s,r){return vo().makeTensorFromTensorInfo(this.makeTensorInfo(s,r,e),this)}disposeData(e,s=!1){if(this.data.has(e)){if(this.data.get(e).refCount--,!s&&this.data.get(e).refCount>0)return!1;const{complexTensorInfos:r}=this.data.get(e);null!=r&&(this.disposeData(r.real.dataId,!0),this.disposeData(r.imag.dataId,!0)),this.data.delete(e)}return!0}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}time(e){return te(function*(){const s=ir();return e(),{kernelMs:ir()-s}})()}memory(){return{unreliable:!0,reasons:["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."]}}where(e){Me([e],"where");const s=this.readSync(e.dataId);return ppe(e.shape,s)}dispose(){}floatPrecision(){return 32}epsilon(){return super.epsilon()}}return n.nextDataId=0,n})();function Ao(n){return(t,e,s)=>{const r=Fn(e,t.length);for(let i=0;i<t.length;++i)r[i]=n(t[i],s);return r}}function Wt(n,t,e){return ul(n,Ao(t),e)}function ul(n,t,e){return({inputs:s,attrs:r,backend:i})=>{const{x:o}=s;Me(o,n);const a=i,l=a.data.get(o.dataId).values;let u;if("string"===o.dtype){if(!Array.isArray(l))throw new Error("String tensor's value was not an instance of Array");u=da(l)}else u=l;const c=e||o.dtype,d=t(u,c,r);return a.makeTensorInfo(o.shape,c,d)}}vP("cpu",()=>new mpe,1);const Dz=Wt(gf,n=>n>=0?n:Math.exp(n)-1),ype={kernelName:gf,backendName:"cpu",kernelFunc:Dz};function Ro(n){const{inputs:t,backend:e}=n,{x:s}=t;return e.incRef(s.dataId),{dataId:s.dataId,shape:s.shape,dtype:s.dtype}}const bpe={kernelName:Cf,backendName:"cpu",kernelFunc:Ro};function Tz(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{alpha:i}=s;Me([r],"leakyRelu");const o=X(r.shape),a=e.data.get(r.dataId).values,l=Ds("float32",o);for(let u=0;u<a.length;u++)l[u]=a[u]<0?i*a[u]:a[u];return e.makeTensorInfo(r.shape,"float32",l)}const vpe={kernelName:$y,backendName:"cpu",kernelFunc:Tz};function Ln(n){return(t,e,s,r,i)=>{const o=nt(t,e),a=o.length,l=Be(o),c=Ds(i,X(o)),d=t.length,h=e.length,f=Be(t),p=Be(e),g=Zc(t,o),m=Zc(e,o);if(g.length+m.length===0)for(let y=0;y<c.length;++y)c[y]=n(s[y%s.length],r[y%r.length]);else for(let y=0;y<c.length;++y){const b=Bc(y,a,l),v=b.slice(-d);g.forEach(E=>v[E]=0);const _=yo(v,d,f),x=b.slice(-h);m.forEach(E=>x[E]=0);const C=yo(x,h,p);c[y]=n(s[_],r[C])}return[c,o]}}const _pe=Ln((n,t)=>n<0?t*n:n);function Nz(n){const{inputs:t,backend:e}=n,{x:s,alpha:r}=t;Me([s,r],"prelu");const i=e.data.get(s.dataId).values,o=e.data.get(r.dataId).values,[a,l]=_pe(s.shape,r.shape,i,o,"float32");return e.makeTensorInfo(l,"float32",a)}const wpe={kernelName:tb,backendName:"cpu",kernelFunc:Nz},kz=Wt(Of,n=>Math.max(0,n)),xpe={kernelName:Of,backendName:"cpu",kernelFunc:kz},Az=Wt($f,n=>Math.min(Math.max(0,n),6)),Cpe={kernelName:$f,backendName:"cpu",kernelFunc:Az},Spe=Ao(n=>1/(1+Math.exp(-n))),Rz=Wt(Wf,n=>1/(1+Math.exp(-n))),Ipe={kernelName:Wf,backendName:"cpu",kernelFunc:Rz};function Ov(n,t,e,s,r){if("linear"===e)return Ro({inputs:{x:t},backend:n});if("relu"===e)return kz({inputs:{x:t},backend:n});if("elu"===e)return Dz({inputs:{x:t},backend:n});if("relu6"===e)return Az({inputs:{x:t},backend:n});if("prelu"===e)return Nz({inputs:{x:t,alpha:s},backend:n});if("leakyrelu"===e)return Tz({inputs:{x:t},backend:n,attrs:{alpha:r}});if("sigmoid"===e)return Rz({inputs:{x:t},backend:n});throw new Error(`Activation ${e} has not been implemented for the CPU backend.`)}function kr(n){const{inputs:t,backend:e}=n,{real:s,imag:r}=t,i=e.data.get(s.dataId).values,o=e.data.get(r.dataId).values,a=e.makeTensorInfo(s.shape,"complex64");return e.data.get(a.dataId).complexTensorInfos={real:e.makeTensorInfo(s.shape,"float32",i),imag:e.makeTensorInfo(r.shape,"float32",o)},a}const Epe={kernelName:ZC,backendName:"cpu",kernelFunc:kr};function $v(n,t,e="float32"){if("complex64"===e)return kr({inputs:{real:$v(n,t,"float32"),imag:$v(n,t,"float32")},backend:n});const s=Vs(X(t),e);return n.makeTensorInfo(t,e,s)}function bu(n){const{inputs:t,backend:e}=n,{input:s}=t,r=e.data.get(s.dataId).complexTensorInfos.real,i=e.data.get(r.dataId).values;return e.makeTensorInfo(r.shape,r.dtype,i)}const Dpe={kernelName:AS,backendName:"cpu",kernelFunc:bu};function Mz(n,t,e,s){if("int32"===s)return[t,"int32",Int32Array.from(n)];if("bool"===s){const r=eu([0],e),[i,o]=Ln((a,l)=>a!==l?1:0)(t,[],n,r,"bool");return[o,"bool",i]}throw new Error(`Error in Cast: failed to cast ${e} to ${s}`)}function cl(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{dtype:i}=s;if("complex64"===i){if("complex64"===r.dtype)return Ro({inputs:{x:r},backend:e});const c=$v(e,r.shape,r.dtype),d=cl({inputs:{x:r},backend:e,attrs:{dtype:"float32"}}),h=kr({inputs:{real:d,imag:c},backend:e});return e.disposeIntermediateTensorInfo(c),e.disposeIntermediateTensorInfo(d),h}if("complex64"===r.dtype){const c=bu({inputs:{input:r},backend:e}),d=cl({inputs:{x:c},backend:e,attrs:{dtype:i}});return e.disposeIntermediateTensorInfo(c),d}if(!A2(r.dtype,i)){const c=Ro({inputs:{x:r},backend:e});return{dataId:c.dataId,shape:c.shape,dtype:i}}const o=e.data.get(r.dataId).values,[a,l,u]=Mz(o,r.shape,r.dtype,i);return e.makeTensorInfo(a,l,u)}const Tpe={kernelName:cf,backendName:"cpu",kernelFunc:cl};function us(n,t,e,s){return null==e?({inputs:r,backend:i})=>{const{a:o,b:a}=r,l=i;Me([o,a],n);const u=l.data.get(o.dataId).values,c=l.data.get(a.dataId).values,d="string"===o.dtype?da(u):u,h="string"===o.dtype?da(c):c,f=s||o.dtype,[p,g]=t(o.shape,a.shape,d,h,f);return l.makeTensorInfo(g,f,p)}:({inputs:r,backend:i})=>{const{a:o,b:a}=r,l=i;if("complex64"===o.dtype||"complex64"===a.dtype){const u=cl({inputs:{x:o},backend:l,attrs:{dtype:"complex64"}}),c=l.data.get(u.dataId),h=c.complexTensorInfos.imag,f=l.data.get(c.complexTensorInfos.real.dataId).values,p=l.data.get(h.dataId).values,g=cl({inputs:{x:a},backend:l,attrs:{dtype:"complex64"}}),m=l.data.get(g.dataId),b=m.complexTensorInfos.imag,v=l.data.get(m.complexTensorInfos.real.dataId).values,_=l.data.get(b.dataId).values,[x,C,E]=e(o.shape,a.shape,f,p,v,_),D=l.makeTensorInfo(E,"float32",x),N=l.makeTensorInfo(E,"float32",C),R=kr({inputs:{real:D,imag:N},backend:l});return l.disposeIntermediateTensorInfo(u),l.disposeIntermediateTensorInfo(g),l.disposeIntermediateTensorInfo(D),l.disposeIntermediateTensorInfo(N),R}{const u=l.data.get(o.dataId).values,c=l.data.get(a.dataId).values,d=s||o.dtype,[h,f]=t(o.shape,a.shape,u,c,d);return l.makeTensorInfo(f,d,h)}}}function oT(n){return(t,e,s,r,i,o)=>{const a=nt(t,e),l=X(a),u=a.length,c=Be(a),d=Ds("float32",l),h=Ds("float32",l),f=Zc(t,a),p=Zc(e,a),g=ca(s,r),m=ca(i,o),y=t.length,b=Be(t),v=e.length,_=Be(e);if(f.length+p.length===0)for(let x=0;x<d.length;x++){const C=x%g.length,E=x%m.length,D=n(g[2*C],g[2*C+1],m[2*E],m[2*E+1]);d[x]=D.real,h[x]=D.imag}else for(let x=0;x<d.length;x++){const C=Bc(x,u,c),E=C.slice(-y);f.forEach(G=>E[G]=0);const D=yo(E,y,b),N=C.slice(-v);p.forEach(G=>N[G]=0);const R=yo(N,v,_),V=n(g[2*D],g[2*D+1],m[2*R],m[2*R+1]);d[x]=V.real,h[x]=V.imag}return[d,h,a]}}const Fz=Ln((n,t)=>n+t),Npe=oT((n,t,e,s)=>({real:n+e,imag:t+s})),md=us(zc,Fz,Npe),kpe={kernelName:zc,backendName:"cpu",kernelFunc:md};function rn(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{shape:i}=s,o=X(r.shape),a=k2(i,o),l=X(a);S(o===l,()=>`The new shape (${a}) has ${l} elements and the old shape (${r.shape}) has ${o} elements. The new shape and old shape must have the same number of elements.`),e.incRef(r.dataId);const u=e.data.get(r.dataId);if(null!=u.complexTensorInfos){const d=u.complexTensorInfos.imag;u.complexTensorInfos.real.shape=a,d.shape=a}return{dataId:r.dataId,shape:a,dtype:r.dtype}}const Ape={kernelName:sb,backendName:"cpu",kernelFunc:rn};function Oz(n){const{inputs:t,backend:e,attrs:s}=n,{a:r,b:i}=t,{transposeA:o,transposeB:a}=s;Me([r,i],"matMul");const l=r.shape.length,u=i.shape.length,c=o?r.shape[l-2]:r.shape[l-1],d=a?i.shape[u-1]:i.shape[u-2],h=o?r.shape[l-1]:r.shape[l-2],f=a?i.shape[u-2]:i.shape[u-1],p=r.shape.slice(0,-2),g=i.shape.slice(0,-2),m=X(p),y=X(g),v=nt(r.shape.slice(0,-2),i.shape.slice(0,-2)).concat([h,f]);S(c===d,()=>`Error in matMul: inner shapes (${c}) and (${d}) of Tensors with shapes ${r.shape} and ${i.shape} and transposeA=${o} and transposeB=${a} must match.`);const x=a?[y,f,d]:[y,d,f],C=rn({inputs:{x:r},backend:e,attrs:{shape:o?[m,c,h]:[m,h,c]}}),E=rn({inputs:{x:i},backend:e,attrs:{shape:x}}),D=o?C.shape[1]:C.shape[2],N=o?C.shape[2]:C.shape[1],R=a?E.shape[1]:E.shape[2],V=Math.max(m,y),G=e.data.get(C.dataId).values,j=e.data.get(E.dataId).values,q=Be(C.shape),K=Be(E.shape),[P,B,L]=o?[q[0],1,q[1]]:[q[0],q[1],1],[H,se,ie]=a?[1,K[1],K[0]]:[K[1],1,K[0]],he=N*R,de=dt([V,N,R],C.dtype),fe=de.values,ye=e.blockSize;for(let De=0;De<V;De++){const Ce=De%m,Le=De%y;for(let ke=0;ke<N;ke+=ye){const Qe=Math.min(ke+ye,N);for(let st=0;st<R;st+=ye){const Gt=Math.min(st+ye,R);for(let on=0;on<D;on+=ye){const kn=Math.min(on+ye,D);for(let an=ke;an<Qe;an++)for(let Yt=st;Yt<Gt;Yt++){let Cn=0;for(let yn=on;yn<kn;yn++)Cn+=G[Ce*P+an*B+yn*L]*j[yn*H+Yt*se+Le*ie];fe[De*he+(an*R+Yt)]+=Cn}}}}}return e.disposeIntermediateTensorInfo(C),e.disposeIntermediateTensorInfo(E),e.makeTensorInfo(v,de.dtype,de.values)}const Rpe={kernelName:wy,backendName:"cpu",kernelFunc:Oz},Fpe={kernelName:yb,backendName:"cpu",kernelFunc:function Mpe(n){const{inputs:t,backend:e,attrs:s}=n,{a:r,b:i,bias:o,preluActivationWeights:a}=t,{transposeA:l,transposeB:u,activation:c,leakyreluAlpha:d}=s;let h,f,p;const g=[];h=Oz({inputs:{a:r,b:i},attrs:{transposeA:l,transposeB:u},backend:e}),o&&(f=md({inputs:{a:h,b:o},backend:e}),g.push(h),h=f),c&&(p=Ov(e,h,c,a,d),g.push(h),h=p);for(const y of g)e.disposeIntermediateTensorInfo(y);return h}};function $z(n){const t=new Float32Array(n.length);for(let e=0;e<n.length;++e)t[e]=Math.abs(n[e]);return t}const Ope={kernelName:my,backendName:"cpu",kernelFunc:n=>{const{x:t}=n.inputs,e=n.backend;Me(t,"abs");let s=new Float32Array(X(t.shape));return s=$z(e.data.get(t.dataId).values),e.makeOutput(s,t.shape,t.dtype)}},$pe=Wt(ef,n=>Math.acos(n)),Ppe={kernelName:ef,backendName:"cpu",kernelFunc:$pe},Lpe=Wt(nf,n=>Math.acosh(n)),Vpe={kernelName:nf,backendName:"cpu",kernelFunc:Lpe},zpe={kernelName:gy,backendName:"cpu",kernelFunc:function Bpe(n){const{inputs:t,backend:e}=n,s=t;Me(t,"addN");const r=s.map(a=>e.data.get(a.dataId).values),i=dt(s[0].shape,s[0].dtype),o=i.values;for(let a=0;a<s.length;a++){const l=r[a];for(let u=0;u<o.length;u++)o[u]+=l[u]}return e.makeTensorInfo(i.shape,i.dtype,i.values)}};function aT(n,t,e,s,r){const i=t.length,o=X(t),a=Be(t),l=Be(r),u=Ds(e,X(r));for(let c=0;c<o;++c){const d=Bc(c,i,a),h=new Array(d.length);for(let p=0;p<h.length;p++)h[p]=d[s[p]];u[yo(h,i,l)]=n[c]}return u}function dr(n){const{inputs:t,attrs:e,backend:s}=n,{x:r}=t,{perm:i}=e;Me(r,"transpose");const a=new Array(r.shape.length);for(let d=0;d<a.length;d++)a[d]=r.shape[i[d]];const u=aT(s.data.get(r.dataId).values,r.shape,r.dtype,i,a);return{dataId:s.write(u,a,r.dtype),shape:a,dtype:r.dtype}}const Upe={kernelName:Uc,backendName:"cpu",kernelFunc:dr},Gpe={kernelName:"All",backendName:"cpu",kernelFunc:function Wpe(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{axis:i,keepDims:o}=s;Me(r,"all");const a=mt(i,r.shape);let l=a;const u=vn(l,r.shape.length);let c=r;null!=u&&(c=dr({inputs:{x:r},backend:e,attrs:{perm:u}}),l=$n(l.length,r.shape.length)),Ns("all",l,c.shape.length);const[d,h]=ws(c.shape,l),f=X(h),p=Vs(X(d),c.dtype),g=e.data.get(c.dataId).values;for(let y=0;y<p.length;++y){const b=y*f;let v=g[b];for(let _=0;_<f;++_)v=v&&g[b+_];p[y]=v}null!=u&&e.disposeIntermediateTensorInfo(c);const m=e.makeTensorInfo(d,c.dtype,p);if(o){const b=rn({inputs:{x:m},backend:e,attrs:{shape:On(d,a)}});return e.disposeIntermediateTensorInfo(m),b}return m}},jpe={kernelName:"Any",backendName:"cpu",kernelFunc:function Hpe(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{axis:i,keepDims:o}=s;Me(r,"any");const a=mt(i,r.shape);let l=a;const u=vn(l,r.shape.length);let c=r;null!=u&&(c=dr({inputs:{x:r},backend:e,attrs:{perm:u}}),l=$n(l.length,r.shape.length)),Ns("any",l,c.shape.length);const[d,h]=ws(c.shape,l),f=X(h),p=Vs(X(d),c.dtype),g=e.data.get(c.dataId).values;for(let y=0;y<p.length;++y){const b=y*f;let v=g[b];for(let _=0;_<f;++_)v=v||g[b+_];p[y]=v}null!=u&&e.disposeIntermediateTensorInfo(c);const m=e.makeTensorInfo(d,c.dtype,p);if(o){const b=rn({inputs:{x:m},backend:e,attrs:{shape:On(d,a)}});return e.disposeIntermediateTensorInfo(m),b}return m}},Kpe={kernelName:yy,backendName:"cpu",kernelFunc:function qpe(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{axis:i}=s;Me(r,"argMax");let o=mt(i,r.shape);const a=vn(o,r.shape.length);let l=r;const u=[];null!=a&&(l=dr({inputs:{x:r},backend:e,attrs:{perm:a}}),u.push(l),o=$n(o.length,l.shape.length)),o=[o[0]],Ns("argMax",o,l.shape.length);const[c,d]=ws(l.shape,o),f=Vs(X(c),"int32"),p=X(d),g=e.data.get(l.dataId).values;for(let m=0;m<f.length;++m){const y=m*p;let b=g[y],v=0;for(let _=0;_<p;++_){const x=g[y+_];x>b&&(b=x,v=_)}f[m]=v}return u.forEach(m=>e.disposeIntermediateTensorInfo(m)),e.makeTensorInfo(c,"int32",f)}},Ype={kernelName:by,backendName:"cpu",kernelFunc:function Xpe(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{axis:i}=s;Me(r,"argMin");let o=mt(i,r.shape);const a=vn(o,r.shape.length);let l=r;const u=[];null!=a&&(l=dr({inputs:{x:r},backend:e,attrs:{perm:a}}),u.push(l),o=$n(o.length,l.shape.length)),o=[o[0]],Ns("argMin",o,l.shape.length);const[c,d]=ws(l.shape,o),f=Vs(X(c),"int32"),p=X(d),g=e.data.get(l.dataId).values;for(let m=0;m<f.length;++m){const y=m*p;let b=g[y],v=0;for(let _=0;_<p;++_){const x=g[y+_];x<b&&(b=x,v=_)}f[m]=v}return u.forEach(m=>e.disposeIntermediateTensorInfo(m)),e.makeTensorInfo(c,"int32",f)}},Zpe=Wt(sf,n=>Math.asin(n)),Qpe={kernelName:sf,backendName:"cpu",kernelFunc:Zpe},Jpe=Wt(rf,n=>Math.asinh(n)),eme={kernelName:rf,backendName:"cpu",kernelFunc:Jpe},tme=Wt(af,n=>Math.atan(n)),nme={kernelName:af,backendName:"cpu",kernelFunc:tme},sme=Ln((n,t)=>Math.atan2(n,t)),rme=us(uf,sme),ime={kernelName:uf,backendName:"cpu",kernelFunc:rme},ome=Wt(lf,n=>Math.atanh(n)),ame={kernelName:lf,backendName:"cpu",kernelFunc:ome};function lT(n,t,e,s,r,i){const o=r.strideHeight,a=r.strideWidth,l=r.dilationHeight,u=r.dilationWidth,c=r.effectiveFilterHeight,d=r.effectiveFilterWidth,h=r.padInfo.top,f=r.padInfo.left,p="max"===i?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,g=dt(r.outShape,e),m=g.values,y=r.outShape[1]*r.outShape[2]*r.outShape[3],b=r.outShape[2]*r.outShape[3],v=r.outShape[3];for(let _=0;_<r.batchSize;++_){const x=_*y,C=_*s[0];for(let E=0;E<r.inChannels;++E)for(let D=0;D<r.outHeight;++D){const N=D*o-h,R=Math.max(0,N),V=Math.min(r.inHeight,c+N),G=x+D*b;for(let j=0;j<r.outWidth;++j){const q=j*a-f,K=Math.max(0,q),P=Math.min(r.inWidth,d+q);let B=p,L=0,H=0;for(let ie=R;ie<V;ie+=l){const he=C+ie*s[1];for(let de=K;de<P;de+=u){const ye=n[he+de*s[2]+E];"max"===i&&ye>B?B=ye:"avg"===i&&(L+=ye,H++)}if(isNaN(B))break}m[G+j*v+E]="avg"===i?L/H:B}}}return g}function Pz(n,t,e,s,r=!1,i=!1){const o=dt(s.outShape,"int32"),a=s.strideHeight,l=s.strideWidth,u=s.dilationHeight,c=s.dilationWidth,d=s.effectiveFilterHeight,h=s.effectiveFilterWidth,f=s.padInfo.top,p=s.padInfo.left,g=dt(t,e,n);for(let m=0;m<s.batchSize;++m)for(let y=0;y<s.inChannels;++y)for(let b=0;b<s.outHeight;++b){const v=b*a-f;let _=v;for(;_<0;)_+=u;const x=Math.min(s.inHeight,d+v);for(let C=0;C<s.outWidth;++C){const E=C*l-p;let D=E;for(;D<0;)D+=c;const N=Math.min(s.inWidth,h+E);let R=Number.NEGATIVE_INFINITY,V=-1;for(let G=_;G<x;G+=u){const j=G-v;for(let q=D;q<N;q+=c){const K=q-E,P=g.get(m,G,q,y);P>R&&(R=P,V=r?i?((m*s.inHeight+G)*s.inWidth+q)*s.inChannels+y:(G*s.inWidth+q)*s.inChannels+y:j*h+K)}}o.set(V,m,b,C,y)}}return o}function Lz(n,t,e,s,r,i){const o=r.strideDepth,a=r.strideHeight,l=r.strideWidth,u=r.dilationDepth,c=r.dilationHeight,d=r.dilationWidth,h=r.effectiveFilterDepth,f=r.effectiveFilterHeight,p=r.effectiveFilterWidth,g=r.padInfo.front,m=r.padInfo.top,y=r.padInfo.left,b="max"===i?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,v=dt(r.outShape,e),_=v.values,x=r.outShape[1]*r.outShape[2]*r.outShape[3]*r.outShape[4],C=r.outShape[2]*r.outShape[3]*r.outShape[4],E=r.outShape[3]*r.outShape[4],D=r.outShape[4];for(let N=0;N<r.batchSize;++N){const R=N*x,V=N*s[0];for(let G=0;G<r.inChannels;++G)for(let j=0;j<r.outDepth;++j){const q=j*o-g;let K=q;for(;K<0;)K+=u;const P=Math.min(r.inDepth,h+q),B=R+j*C;for(let L=0;L<r.outHeight;++L){const H=L*a-m;let se=H;for(;se<0;)se+=c;const ie=Math.min(r.inHeight,f+H),he=B+L*E;for(let de=0;de<r.outWidth;++de){const fe=de*l-y;let ye=fe;for(;ye<0;)ye+=d;const De=Math.min(r.inWidth,p+fe),Ce=he+de*D;let Le=b,ke=0,Qe=0;for(let Gt=K;Gt<P;Gt+=u){const on=V+Gt*s[1];for(let kn=se;kn<ie;kn+=c){const an=on+kn*s[2];for(let Yt=ye;Yt<De;Yt+=d){const yn=n[an+Yt*s[3]+G];if("max"===i&&yn>Le?Le=yn:"avg"===i&&(ke+=yn,Qe++),isNaN(Le))break}if(isNaN(Le))break}if(isNaN(Le))break}_[Ce+G]="avg"===i?ke/Math.max(Qe,1):Le}}}}return v}const cme={kernelName:vy,backendName:"cpu",kernelFunc:function ume(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t;Me(r,"avgPool");const{filterSize:i,strides:o,pad:a,dimRoundingMode:l}=s;S(Ts(o,1),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${o} and dilations '1'`);const c=pi(r.shape,i,o,1,a,l);let d;if(1===c.filterWidth&&1===c.filterHeight&&wt(c.inShape,c.outShape))d=Ro({inputs:{x:r},backend:e});else{const h=e.data.get(r.dataId).values,f=Be(r.shape),p=lT(h,0,r.dtype,f,c,"avg");d=e.makeTensorInfo(c.outShape,r.dtype,p.values)}return d}},hme={kernelName:_y,backendName:"cpu",kernelFunc:function dme(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{filterSize:i,strides:o,pad:a,dimRoundingMode:l,dataFormat:u}=s;Me(r,"avgPool3d");const c=aa(r.shape,i,o,1,a,l,u),h=Lz(e.data.get(r.dataId).values,0,r.dtype,Be(r.shape),c,"avg");return e.makeTensorInfo(h.shape,"float32",h.values)}},pme={kernelName:qC,backendName:"cpu",kernelFunc:function fme(n){const{inputs:t,backend:e,attrs:s}=n,{dy:r,input:i}=t,{filterSize:o,strides:a,pad:l,dimRoundingMode:u}=s;Me([r,i],"avgPool3DGrad");const c=aa(i.shape,o,a,1,l,u),d=c.strideDepth,h=c.strideHeight,f=c.strideWidth,p=c.filterDepth,g=c.filterHeight,m=c.filterWidth,y=c.dilationDepth,b=c.dilationHeight,v=c.dilationWidth,_=c.effectiveFilterDepth,x=c.effectiveFilterHeight,C=c.effectiveFilterWidth,E=_-1-c.padInfo.front,D=C-1-c.padInfo.left,N=x-1-c.padInfo.top,R=dt(i.shape,"float32"),V=1/(p*g*m),G=e.bufferSync(r);for(let j=0;j<c.batchSize;++j)for(let q=0;q<c.inChannels;++q)for(let K=0;K<c.inDepth;++K)for(let P=0;P<c.inHeight;++P)for(let B=0;B<c.inWidth;++B){const L=K-E,H=P-N,se=B-D;let ie=0;for(let he=0;he<_;he+=y){const de=(L+he)/d;if(!(de<0||de>=c.outDepth||Math.floor(de)!==de))for(let fe=0;fe<x;fe+=b){const ye=(H+fe)/h;if(!(ye<0||ye>=c.outHeight||Math.floor(ye)!==ye))for(let De=0;De<C;De+=v){const Ce=(se+De)/f;Ce<0||Ce>=c.outWidth||Math.floor(Ce)!==Ce||(ie+=G.get(j,de,ye,Ce,q))}}}R.set(ie*V,j,K,P,B,q)}return e.makeTensorInfo(R.shape,R.dtype,R.values)}},gme={kernelName:jC,backendName:"cpu",kernelFunc:function mme(n){const{inputs:t,backend:e,attrs:s}=n,{dy:r,input:i}=t,o=i;Me([r,i],"avgPoolGrad");const{filterSize:a,strides:l,pad:u}=s,c=pi(o.shape,a,l,1,u),d=c.strideHeight,h=c.strideWidth,f=c.filterHeight,p=c.filterWidth,g=c.dilationHeight,m=c.dilationWidth,y=c.effectiveFilterHeight,b=c.effectiveFilterWidth,v=b-1-c.padInfo.left,_=y-1-c.padInfo.top,x=dt(o.shape,"float32"),C=1/(f*p),E=e.data.get(r.dataId).values,D=dt(r.shape,"float32",E);for(let N=0;N<c.batchSize;++N)for(let R=0;R<c.inChannels;++R)for(let V=0;V<c.inHeight;++V)for(let G=0;G<c.inWidth;++G){const j=V-_,q=G-v;let K=0;for(let P=0;P<y;P+=g){const B=(j+P)/d;if(!(B<0||B>=c.outHeight||Math.floor(B)!==B))for(let L=0;L<b;L+=m){const H=(q+L)/h;H<0||H>=c.outWidth||Math.floor(H)!==H||(K+=D.get(N,B,H,R))}}x.set(K*C,N,V,G,R)}return e.makeTensorInfo(x.shape,x.dtype,x.values)}},bme={kernelName:My,backendName:"cpu",kernelFunc:function yme(n){const{inputs:t,backend:e,attrs:s}=n,{x:r,scale:i,offset:o,mean:a,variance:l}=t;S(a.shape.length===l.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),S(null==o||a.shape.length===o.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),S(null==i||a.shape.length===i.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks."),Me([r,a,l,i,o],"batchNorm");let{varianceEpsilon:u}=s;null==u&&(u=.001);const c=e.data.get(r.dataId).values,d=e.data.get(a.dataId).values,h=e.data.get(l.dataId).values,f=i?e.data.get(i.dataId).values:new Float32Array([1]),p=o?e.data.get(o.dataId).values:new Float32Array([0]),g=new Float32Array(c.length),m=p.length,y=f.length,b=h.length,v=d.length;let _=0,x=0,C=0,E=0;for(let D=0;D<c.length;++D)g[D]=p[_++]+(c[D]-d[x++])*f[C++]/Math.sqrt(h[E++]+u),_>=m&&(_=0),x>=v&&(x=0),C>=y&&(C=0),E>=b&&(E=0);return e.makeTensorInfo(r.shape,r.dtype,g)}};function Vz(n,t,e,s,r){const i=RI(s,t,e),o=X(e),a=Be(s);if(i){const d=MI(t,a);return"string"===r?n.slice(d,d+o):n.subarray(d,d+o)}const u=dt(s,r,"string"===r?da(n):n),c=dt(e,r);for(let d=0;d<c.size;++d){const h=c.indexToLoc(d),f=h.map((p,g)=>p+t[g]);c.set(u.get(...f),...h)}return"string"===r?CV(c.values):c.values}function vu(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{begin:i,size:o}=s;Me(r,"slice");const[a,l]=kb(r,i,o);kI(r,a,l);const c=Vz(e.data.get(r.dataId).values,a,l,r.shape,r.dtype);return e.makeTensorInfo(l,r.dtype,c)}const vme={kernelName:lb,backendName:"cpu",kernelFunc:vu},wme={kernelName:xy,backendName:"cpu",kernelFunc:function _me(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{blockShape:i,crops:o}=s;Me([r],"batchToSpaceND");const a=i.reduce((y,b)=>y*b),l=yp(r.shape,i,a),u=bp(l.length,i.length),c=vp(r.shape,i,a),d=AE(o,i.length),h=RE(c,o,i.length),f=rn({inputs:{x:r},backend:e,attrs:{shape:l}}),p=dr({inputs:{x:f},backend:e,attrs:{perm:u}}),g=rn({inputs:{x:p},backend:e,attrs:{shape:c}}),m=vu({inputs:{x:g},backend:e,attrs:{begin:d,size:h}});return e.disposeIntermediateTensorInfo(f),e.disposeIntermediateTensorInfo(p),e.disposeIntermediateTensorInfo(g),m}};function uT(n,t,e,s,r){const i=X(s),o=Vs(r,e);for(let a=0;a<n.length;a++){const l=n[a];if(l<0)throw new Error("Input x must be non-negative!");l>=r||(o[l]+=i>0?t[a]:1)}return o}function Bz(n,t,e,s=!1){const r=n.shape[0],i=n.shape[1],o=dt([r,e],t.dtype);for(let a=0;a<r;a++)for(let l=0;l<i;l++){const u=n.get(a,l);if(u<0)throw new Error("Input x must be non-negative!");u>=e||o.set(s?1:t.size>0?o.get(a,u)+t.get(a,l):o.get(a,u)+1,a,u)}return o}const Cme={kernelName:KC,backendName:"cpu",kernelFunc:function xme(n){const{inputs:t,backend:e,attrs:s}=n,{x:r,weights:i}=t,{size:o}=s,u=uT(e.data.get(r.dataId).values,e.data.get(i.dataId).values,i.dtype,i.shape,o);return e.makeTensorInfo([o],i.dtype,u)}},Sme=Ln((n,t)=>n&t),Ime=us(XC,Sme),Eme={kernelName:XC,backendName:"cpu",kernelFunc:Ime},Tme={kernelName:YC,backendName:"cpu",kernelFunc:function Dme(n){const{inputs:t,backend:e}=n,{s0:s,s1:r}=t,i=e.data.get(s.dataId).values,o=e.data.get(r.dataId).values,a=nt(Array.from(i),Array.from(o));return e.makeTensorInfo([a.length],"int32",Int32Array.from(a))}},zz=Ao(n=>Math.ceil(n)),Nme=ul(df,zz),kme={kernelName:df,backendName:"cpu",kernelFunc:Nme},Ame=Wt(hf,(n,t)=>n>t.clipValueMax?t.clipValueMax:n<t.clipValueMin?t.clipValueMin:n),Rme={kernelName:hf,backendName:"cpu",kernelFunc:Ame},Mme={kernelName:Cy,backendName:"cpu",kernelFunc:n=>{const{x:t}=n.inputs,e=n.backend,s=new Float32Array(X(t.shape)),r=e.data.get(t.dataId),o=r.complexTensorInfos.imag,a=e.data.get(r.complexTensorInfos.real.dataId).values,l=e.data.get(o.dataId).values;for(let u=0;u<a.length;u++)s[u]=Math.hypot(a[u],l[u]);return e.makeOutput(s,t.shape,"float32")}};function Uz(n,t,e,s){const r=Fn(e,X(t));if(s&&"string"!==e){let i=0;n.forEach(o=>{const a=X(o.shape);r.set(o.vals,i),i+=a})}else{let i=0;n.forEach(o=>{const a="string"===e?da(o.vals):o.vals;let l=0;for(let u=0;u<o.shape[0];++u){const c=u*t[1]+i;for(let d=0;d<o.shape[1];++d)r[c+d]=a[l++]}i+=o.shape[1]})}return r}function gd(n){const{inputs:t,backend:e}=n,{input:s}=t,r=e.data.get(s.dataId).complexTensorInfos.imag,i=e.data.get(r.dataId).values;return e.makeTensorInfo(r.shape,r.dtype,i)}const Fme={kernelName:yS,backendName:"cpu",kernelFunc:gd};function yd(n){const{inputs:t,backend:e,attrs:s}=n,{axis:r}=s,i=mt(r,t[0].shape)[0];TE(t.map(g=>g.shape),i);let a=So(t.map(g=>g.shape),i);if(0===X(a))return e.makeTensorInfo(a,t[0].dtype,[]);const l=t.filter(g=>X(g.shape)>0);if(1===l.length)return Ro({inputs:{x:l[0]},backend:e});if("complex64"===l[0].dtype){const g=l.map(_=>bu({inputs:{input:_},backend:e})),m=l.map(_=>gd({inputs:{input:_},backend:e})),y=yd({inputs:g,backend:e,attrs:{axis:i}}),b=yd({inputs:m,backend:e,attrs:{axis:i}}),v=kr({inputs:{real:y,imag:b},backend:e});return g.forEach(_=>e.disposeIntermediateTensorInfo(_)),m.forEach(_=>e.disposeIntermediateTensorInfo(_)),e.disposeIntermediateTensorInfo(y),e.disposeIntermediateTensorInfo(b),v}const u=l.map(g=>{const y=[-1,X(g.shape.slice(i))];return rn({inputs:{x:g},backend:e,attrs:{shape:y}})}),c=u.map(g=>({vals:e.data.get(g.dataId).values,shape:g.shape}));a=So(u.map(g=>g.shape),1);const h=Uz(c,a,t[0].dtype,1===u[0].shape[0]),f=So(l.map(g=>g.shape),i),p=e.makeTensorInfo(f,t[0].dtype,h);return u.forEach(g=>e.disposeIntermediateTensorInfo(g)),p}const Ome={kernelName:Sy,backendName:"cpu",kernelFunc:yd};function Wz(n){const{inputs:t,backend:e,attrs:s}=n,{x:r,filter:i}=t,{strides:o,pad:a,dataFormat:l,dilations:u,dimRoundingMode:c}=s;Me([r,i],"conv2d");const d=la(l),h=_s(r.shape,i.shape,o,u,a,c,!1,d),f=h.filterHeight,p=h.filterWidth,g=h.dilationHeight,m=h.dilationWidth,y=h.padInfo.left,b=h.padInfo.top,v="channelsLast"===h.dataFormat,_=new ts(h.outShape,r.dtype),x=Be(r.shape),C=Be(i.shape),E=x[0],D=v?x[1]:x[2],N=v?x[2]:1,R=v?1:x[1],V=_.strides[0],G=v?_.strides[1]:_.strides[2],j=v?_.strides[2]:1,q=v?1:_.strides[1],K=e.data.get(r.dataId).values,P=e.data.get(i.dataId).values,B=_.values;for(let L=0;L<h.batchSize;++L){const H=L*E,se=L*V;for(let ie=0;ie<h.outHeight;++ie){const he=se+ie*G,de=ie*h.strideHeight-b;for(let fe=0;fe<f;++fe){const ye=de+fe*g;if(ye<0||ye>=h.inHeight)continue;const De=fe*C[0],Ce=H+ye*D;for(let Le=0;Le<h.outWidth;++Le){const ke=he+Le*j,Qe=Le*h.strideWidth-y;for(let st=0;st<p;++st){const Gt=Qe+st*m;if(Gt<0||Gt>=h.inWidth)continue;const kn=Ce+Gt*N;let an=De+st*C[1];for(let Yt=0;Yt<h.inChannels;++Yt){const Cn=K[kn+Yt*R];for(let yn=0;yn<h.outChannels;++yn)B[ke+yn*q]+=Cn*P[an+yn];an+=h.outChannels}}}}}}return e.makeTensorInfo(_.shape,_.dtype,B)}const $me={kernelName:Iy,backendName:"cpu",kernelFunc:Wz},Lme={kernelName:QC,backendName:"cpu",kernelFunc:function Pme(n){const{inputs:t,backend:e,attrs:s}=n,{x:r,dy:i}=t,{strides:o,pad:a,dataFormat:l,dimRoundingMode:u,filterShape:c}=s;Me([r,i],"conv2dBackpropFilter");const d=la(l),h=_s(r.shape,c,o,1,a,u,!1,d),{strideHeight:f,strideWidth:p,filterHeight:g,filterWidth:m}=h,y="channelsLast"===h.dataFormat,b=new ts(h.filterShape,"float32"),v=h.padInfo.left,_=h.padInfo.top,x=e.data.get(r.dataId).values,C=e.data.get(i.dataId).values,E=new ts(r.shape,r.dtype,x),D=new ts(i.shape,i.dtype,C);for(let N=0;N<g;++N){const R=Math.max(0,Math.ceil((_-N)/f)),V=Math.min(h.outHeight,(h.inHeight+_-N)/f);for(let G=0;G<m;++G){const j=Math.max(0,Math.ceil((v-G)/p)),q=Math.min(h.outWidth,(h.inWidth+v-G)/p);for(let K=0;K<h.inChannels;++K)for(let P=0;P<h.outChannels;++P){let B=0;for(let L=0;L<h.batchSize;++L)for(let H=R;H<V;++H){const se=N+H*f-_;for(let ie=j;ie<q;++ie){const he=G+ie*p-v;B+=y?E.get(L,se,he,K)*D.get(L,H,ie,P):E.get(L,K,se,he)*D.get(L,P,H,ie)}}b.set(B,N,G,K,P)}}}return e.makeTensorInfo(b.shape,b.dtype,b.values)}},Bme={kernelName:Ey,backendName:"cpu",kernelFunc:function Vme(n){const{inputs:t,backend:e,attrs:s}=n,{dy:r,filter:i}=t,{inputShape:o,strides:a,pad:l,dataFormat:u,dimRoundingMode:c}=s;Me([r,i],"conv2dBackpropInput");const d=Be(i.shape),h=Be(r.shape);let f=la(u);const p=_s(o,i.shape,a,1,l,c,!1,f),g=new ts(p.inShape,"float32"),m=g.values,y=e.data.get(r.dataId).values,b=e.data.get(i.dataId).values,[v,_,x]=d,{batchSize:C,filterHeight:E,filterWidth:D,inChannels:N,inHeight:R,inWidth:V,outChannels:G,outHeight:j,outWidth:q,strideHeight:K,strideWidth:P}=p;f=p.dataFormat;const B=E-1-p.padInfo.top,L=D-1-p.padInfo.left,H="channelsLast"===f,se=g.strides[0],ie=H?g.strides[1]:g.strides[2],he=H?g.strides[2]:1,de=H?1:g.strides[1],fe=h[0],ye=H?h[1]:h[2],De=H?h[2]:1,Ce=H?1:h[1];for(let Le=0;Le<C;++Le)for(let ke=0;ke<N;++ke)for(let Qe=0;Qe<R;++Qe){const st=Qe-B,Gt=Math.max(0,Math.ceil(st/K)),on=Math.min(j,(E+st)/K);for(let kn=0;kn<V;++kn){const an=kn-L,Yt=Math.max(0,Math.ceil(an/P)),Cn=Math.min(q,(D+an)/P);let yn=0;for(let Rs=Gt;Rs<on;++Rs){const wl=Rs*K-st;for(let ni=Yt;ni<Cn;++ni){const Qi=fe*Le+ye*Rs+De*ni,_a=v*(E-1-wl)+_*(D-1-(ni*P-an))+x*ke;for(let xl=0;xl<G;++xl)yn+=y[Qi+Ce*xl]*b[_a+xl]}}m[se*Le+ie*Qe+he*kn+de*ke]=yn}}return e.makeTensorInfo(g.shape,g.dtype,g.values)}},Ume={kernelName:Dy,backendName:"cpu",kernelFunc:function zme(n){const{inputs:t,backend:e,attrs:s}=n,{x:r,filter:i}=t,{strides:o,pad:a,dilations:l}=s;Me([r,i],"conv3d");const u=Xa(r.shape,i.shape,o,l,a),{filterDepth:c,filterHeight:d,filterWidth:h,dilationDepth:f,dilationHeight:p,dilationWidth:g,padInfo:m}=u,y=m.front,b=m.left,v=m.top,_=new ts(u.outShape,r.dtype),x=e.data.get(r.dataId).values,C=e.data.get(i.dataId).values,E=_.values,D=Be(r.shape),N=Be(i.shape);for(let R=0;R<u.batchSize;++R){const V=R*D[0],G=R*_.strides[0];for(let j=0;j<u.outDepth;++j){const q=G+j*_.strides[1],K=j*u.strideDepth-y;for(let P=0;P<c;++P){const B=K+P*f;if(B<0||B>=u.inDepth)continue;const L=P*N[0],H=V+B*D[1];for(let se=0;se<u.outHeight;++se){const ie=q+se*_.strides[2],he=se*u.strideHeight-v;for(let de=0;de<d;++de){const fe=he+de*p;if(fe<0||fe>=u.inHeight)continue;const ye=L+de*N[1],De=H+fe*D[2];for(let Ce=0;Ce<u.outWidth;++Ce){const Le=ie+Ce*u.outChannels,ke=Ce*u.strideWidth-b;for(let Qe=0;Qe<h;++Qe){const st=ke+Qe*g;if(st<0||st>=u.inWidth)continue;const on=De+st*u.inChannels;let kn=ye+Qe*N[2];for(let an=0;an<u.inChannels;++an){const Yt=x[on+an];for(let Cn=0;Cn<u.outChannels;++Cn)E[Le+Cn]+=Yt*C[kn+Cn];kn+=u.outChannels}}}}}}}}return e.makeTensorInfo(_.shape,_.dtype,_.values)}},Gme={kernelName:JC,backendName:"cpu",kernelFunc:function Wme(n){const{inputs:t,backend:e,attrs:s}=n,{x:r,dy:i}=t,{strides:o,pad:a,filterShape:l}=s;Me([r,i],"conv3dBackpropFilterV2");const u=Be(r.shape),c=Be(i.shape),d=Xa(r.shape,l,o,1,a),h=d.strideDepth,f=d.strideHeight,p=d.strideWidth,g=d.filterDepth,m=d.filterHeight,y=d.filterWidth,b=new ts(d.filterShape,"float32"),v=b.values,[_,x,C,E]=b.strides,D=e.data.get(i.dataId).values,[N,R,V,G]=c,j=e.data.get(r.dataId).values,[q,K,P,B]=u,L=d.padInfo.front,H=d.padInfo.left,se=d.padInfo.top;for(let ie=0;ie<g;++ie){const he=Math.max(0,Math.ceil((L-ie)/h)),de=Math.min(d.outDepth,(d.inDepth+L-ie)/h),fe=ie*_;for(let ye=0;ye<m;++ye){const De=Math.max(0,Math.ceil((se-ye)/f)),Ce=Math.min(d.outHeight,(d.inHeight+se-ye)/f),Le=ye*x+fe;for(let ke=0;ke<y;++ke){const Qe=Math.max(0,Math.ceil((H-ke)/p)),st=Math.min(d.outWidth,(d.inWidth+H-ke)/p),Gt=ke*C+Le;for(let on=0;on<d.inChannels;++on){const kn=on*E+Gt;for(let an=0;an<d.outChannels;++an){let Yt=0;for(let Cn=0;Cn<d.batchSize;++Cn){const yn=Cn*q,va=Cn*N;for(let Rs=he;Rs<de;++Rs){const ni=(ie+Rs*h-L)*K+yn,Mu=Rs*R+va;for(let Qi=De;Qi<Ce;++Qi){const xl=(ye+Qi*f-se)*P+ni,Cl=Qi*V+Mu;for(let Sl=Qe;Sl<st;++Sl)Yt+=j[(ke+Sl*p-H)*B+xl+on]*D[Sl*G+Cl+an]}}}v[kn+an]=Yt}}}}}return e.makeTensorInfo(b.shape,b.dtype,b.values)}},jme={kernelName:eS,backendName:"cpu",kernelFunc:function Hme(n){const{inputs:t,backend:e,attrs:s}=n,{dy:r,filter:i}=t,{pad:o,strides:a,inputShape:l}=s;Me([r],"conv3dBackpropInputV2");const u=Be(r.shape),c=Be(i.shape),d=Xa(l,i.shape,a,1,o),h=new ts(d.inShape,"float32"),f=h.values,[p,g,m,y]=h.strides,b=e.data.get(r.dataId).values,[v,_,x,C]=u,E=e.data.get(i.dataId).values,[D,N,R,V]=c,{batchSize:G,filterDepth:j,filterHeight:q,filterWidth:K,inChannels:P,inDepth:B,inHeight:L,inWidth:H,outChannels:se,outDepth:ie,outHeight:he,outWidth:de,strideDepth:fe,strideHeight:ye,strideWidth:De}=d,Ce=j-1-d.padInfo.front,Le=q-1-d.padInfo.top,ke=K-1-d.padInfo.left;for(let Qe=0;Qe<G;++Qe)for(let st=0;st<P;++st)for(let Gt=0;Gt<B;++Gt){const on=Gt-Ce,kn=Math.max(0,Math.ceil(on/fe)),an=Math.min(ie,(j+on)/fe);for(let Yt=0;Yt<L;++Yt){const Cn=Yt-Le,yn=Math.max(0,Math.ceil(Cn/ye)),va=Math.min(he,(q+Cn)/ye);for(let Rs=0;Rs<H;++Rs){const wl=Rs-ke,ni=Math.max(0,Math.ceil(wl/De)),Mu=Math.min(de,(K+wl)/De);let Qi=0;for(let _a=kn;_a<an;++_a){const xl=_a*fe-on;for(let Cl=yn;Cl<va;++Cl){const Sl=Cl*ye-Cn;for(let am=ni;am<Mu;++am){const AN=v*Qe+_*_a+x*Cl+C*am,zMe=D*(j-1-xl)+N*(q-1-Sl)+R*(K-1-(am*De-wl))+V*st;for(let O_=0;O_<se;++O_)Qi+=b[AN+O_]*E[zMe+O_]}}}f[p*Qe+g*Gt+m*Yt+y*Rs+st]=Qi}}}return e.makeTensorInfo(h.shape,h.dtype,h.values)}},qme=Wt(ff,n=>Math.cos(n)),Kme={kernelName:ff,backendName:"cpu",kernelFunc:qme},Xme=Wt(pf,n=>Math.cosh(n)),Yme={kernelName:pf,backendName:"cpu",kernelFunc:Xme},Qme={kernelName:nS,backendName:"cpu",kernelFunc:function Zme(n){const{inputs:t,backend:e,attrs:s}=n,{image:r,boxes:i,boxInd:o}=t,{cropSize:a,method:l,extrapolationValue:u}=s,[c,d,h,f]=r.shape,p=i.shape[0],[g,m]=a,y=dt([p,g,m,f],"float32"),b=e.data.get(i.dataId).values,v=e.data.get(o.dataId).values,_=e.data.get(r.dataId).values,x=Be(r.shape),C=Be(y.shape);for(let E=0;E<p;E++){const D=4*E,N=b[D],R=b[D+1],V=b[D+2],G=b[D+3],j=v[E];if(j>=c)continue;const q=g>1?(V-N)*(d-1)/(g-1):0,K=m>1?(G-R)*(h-1)/(m-1):0;for(let P=0;P<g;P++){const B=g>1?N*(d-1)+P*q:.5*(N+V)*(d-1);if(B<0||B>d-1)for(let L=0;L<m;L++)for(let H=0;H<f;H++)y.values[H+L*C[2]+P*C[1]+E*C[0]]=u;else if("bilinear"===l){const L=Math.floor(B),H=Math.ceil(B),se=B-L;for(let ie=0;ie<m;ie++){const he=m>1?R*(h-1)+ie*K:.5*(R+G)*(h-1);if(he<0||he>h-1){for(let De=0;De<f;De++)y.values[De+ie*C[2]+P*C[1]+E*C[0]]=u;continue}const de=Math.floor(he),fe=Math.ceil(he),ye=he-de;for(let De=0;De<f;De++){let Ce=De+de*x[2]+L*x[1]+j*x[0];const Le=_[Ce];Ce=De+fe*x[2]+L*x[1]+j*x[0];const ke=_[Ce];Ce=De+de*x[2]+H*x[1]+j*x[0];const Qe=_[Ce];Ce=De+fe*x[2]+H*x[1]+j*x[0];const st=_[Ce],Gt=Le+(ke-Le)*ye;Ce=De+ie*C[2]+P*C[1]+E*C[0],y.values[Ce]=Gt+(Qe+(st-Qe)*ye-Gt)*se}}}else for(let L=0;L<m;++L){const H=m>1?R*(h-1)+L*K:.5*(R+G)*(h-1);if(H<0||H>h-1){for(let he=0;he<f;he++)y.values[he+L*C[2]+P*C[1]+E*C[0]]=u;continue}const se=Math.round(H),ie=Math.round(B);for(let he=0;he<f;he++)y.values[he+L*C[2]+P*C[1]+E*C[0]]=_[he+se*x[2]+ie*x[1]+j*x[0]]}}}return e.makeTensorInfo(y.shape,y.dtype,y.values)}},ege={kernelName:tS,backendName:"cpu",kernelFunc:function Jme(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{axis:i,exclusive:o,reverse:a}=s;Me(r,"cumprod");const l=vn([i],r.shape.length);let u=r;null!=l&&(u=dr({inputs:{x:r},backend:e,attrs:{perm:l}}));const c=$n(1,r.shape.length)[0];if(c!==u.shape.length-1)throw new Error(`backend.cumprod in CPU expects an inner-most axis=${u.shape.length-1} but got axis=${c}`);const d=Ir(u.dtype,"int32"),h=zC(X(u.shape),d),f=e.data.get(u.dataId).values,p=u.shape[u.shape.length-1],g=a?(y,b)=>y+p-b-1:(y,b)=>y+b;for(let y=0;y<f.length;y+=p)for(let b=0;b<p;b++){const v=g(y,b);if(0===b)h[v]=o?1:f[v];else{const _=g(y,b-1);h[v]=o?f[_]*h[_]:f[v]*h[_]}}const m=e.makeTensorInfo(u.shape,d,h);if(null!=l){const b=dr({inputs:{x:m},backend:e,attrs:{perm:Qa(l)}});return e.disposeIntermediateTensorInfo(m),e.disposeIntermediateTensorInfo(u),b}return m}},nge={kernelName:Ty,backendName:"cpu",kernelFunc:function tge(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{axis:i,exclusive:o,reverse:a}=s;Me(r,"cumsum");const l=vn([i],r.shape.length);let u=r;null!=l&&(u=dr({inputs:{x:r},backend:e,attrs:{perm:l}}));const c=$n(1,r.shape.length)[0];if(c!==u.shape.length-1)throw new Error(`backend.cumsum in CPU expects an inner-most axis=${u.shape.length-1} but got axis=${c}`);const d=Ir(u.dtype,"int32"),h=Vs(X(u.shape),d),f=e.data.get(u.dataId).values,p=u.shape[u.shape.length-1],g=a?(y,b)=>y+p-b-1:(y,b)=>y+b;for(let y=0;y<f.length;y+=p)for(let b=0;b<p;b++){const v=g(y,b);if(0===b)h[v]=o?0:f[v];else{const _=g(y,b-1);h[v]=o?f[_]+h[_]:f[v]+h[_]}}const m=e.makeTensorInfo(u.shape,d,h);if(null!=l){const b=dr({inputs:{x:m},backend:e,attrs:{perm:Qa(l)}});return e.disposeIntermediateTensorInfo(m),e.disposeIntermediateTensorInfo(u),b}return m}},rge={kernelName:sS,backendName:"cpu",kernelFunc:function sge(n){const{inputs:t,backend:e,attrs:s}=n,{x:r,weights:i}=t,{size:o,binaryOutput:a}=s;if(1===r.shape.length){const c=uT(e.data.get(r.dataId).values,e.data.get(i.dataId).values,i.dtype,i.shape,o);return e.makeTensorInfo([o],i.dtype,c)}if(2===r.shape.length){const c=Bz(e.bufferSync(r),e.bufferSync(i),o,a);return e.makeTensorInfo(c.shape,i.dtype,c.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${r.shape.length}.`)}},oge={kernelName:rS,backendName:"cpu",kernelFunc:function ige(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{blockSize:i,dataFormat:o}=s;S("NHWC"===o,()=>`Only NHWC dataFormat supported on CPU for depthToSpace. Got ${o}`);const a=r.shape[0],l=r.shape[1],u=r.shape[2],c=r.shape[3],d=l*i,h=u*i,f=c/(i*i),p=e.data.get(r.dataId).values,g=new Float32Array(a*d*h*f);let m=0;for(let y=0;y<a;++y)for(let b=0;b<d;++b){const v=Math.floor(b/i),_=b%i;for(let x=0;x<h;++x){const C=Math.floor(x/i),D=(_*i+x%i)*f;for(let N=0;N<f;++N)g[m++]=p[N+D+c*(C+u*(v+l*y))]}}return e.makeTensorInfo([a,d,h,f],r.dtype,g)}};function Gz(n){const{inputs:t,backend:e,attrs:s}=n,{x:r,filter:i}=t,{strides:o,pad:a,dilations:l,dimRoundingMode:u}=s;Me([r,i],"depthwiseConv2DNative");const c=Be(r.shape),d=Be(i.shape);let h=l;null==h&&(h=[1,1]),S(Ts(o,h),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${o} and dilations '${h}'`);const f=_s(r.shape,i.shape,o,h,a,u,!0),{filterHeight:p,filterWidth:g,dilationHeight:m,dilationWidth:y,padInfo:b}=f,v=b.left,_=b.top,x=f.outChannels/f.inChannels,C=new ts(f.outShape,r.dtype),E=e.data.get(r.dataId).values,D=e.data.get(i.dataId).values,N=C.values;for(let R=0;R<f.batchSize;++R){const V=R*c[0],G=R*C.strides[0];for(let j=0;j<f.outHeight;++j){const q=G+j*C.strides[1],K=j*f.strideHeight-_;for(let P=0;P<p;++P){const B=K+P*m;if(B<0||B>=f.inHeight)continue;const L=P*d[0],H=V+B*c[1];for(let se=0;se<f.outWidth;++se){const ie=q+se*C.strides[2],he=se*f.strideWidth-v;for(let de=0;de<g;++de){const fe=he+de*y;if(fe<0||fe>=f.inWidth)continue;const De=H+fe*f.inChannels;let Ce=ie,Le=L+de*d[1];for(let ke=0;ke<f.inChannels;++ke){const Qe=E[De+ke];for(let st=0;st<x;++st)N[Ce+st]+=Qe*D[Le+st];Ce+=x,Le+=x}}}}}}return e.makeTensorInfo(C.shape,C.dtype,C.values)}const age={kernelName:Ny,backendName:"cpu",kernelFunc:Gz},uge={kernelName:iS,backendName:"cpu",kernelFunc:function lge(n){const{inputs:t,backend:e,attrs:s}=n,{x:r,dy:i}=t,{strides:o,dilations:a,pad:l,dimRoundingMode:u,filterShape:c}=s;Me([r,i],"depthwiseConv2dNativeBackpropFilter");const d=_s(r.shape,c,o,a,l,u,!0),{strideHeight:h,strideWidth:f,filterHeight:p,filterWidth:g}=d,m=new ts(d.filterShape,"float32"),y=d.padInfo.left,b=d.padInfo.top,v=d.outChannels/d.inChannels,_=e.data.get(r.dataId).values,x=new ts(r.shape,r.dtype,_),C=e.data.get(i.dataId).values,E=new ts(i.shape,i.dtype,C);for(let D=0;D<p;++D){const N=Math.max(0,Math.ceil((b-D)/h)),R=Math.min(d.outHeight,(d.inHeight+b-D)/h);for(let V=0;V<g;++V){const G=Math.max(0,Math.ceil((y-V)/f)),j=Math.min(d.outWidth,(d.inWidth+y-V)/f);for(let q=0;q<d.outChannels;++q){const K=Math.trunc(q/v),P=q%v;let B=0;for(let L=0;L<d.batchSize;++L)for(let H=N;H<R;++H){const se=D+H*h-b;for(let ie=G;ie<j;++ie)B+=x.get(L,se,V+ie*f-y,K)*E.get(L,H,ie,q)}m.set(B,D,V,K,P)}}}return e.makeTensorInfo(m.shape,m.dtype,m.values)}},dge={kernelName:oS,backendName:"cpu",kernelFunc:function cge(n){const{inputs:t,backend:e,attrs:s}=n,{dy:r,filter:i}=t,{strides:o,dilations:a,pad:l,dimRoundingMode:u,inputShape:c}=s;Me([r,i],"depthwiseConv2DNativeBackpropInput");const d=Be(r.shape),h=Be(i.shape),f=_s(c,i.shape,o,a,l,u,!0),p=new ts(f.inShape,"float32"),g=p.values,[m,y,b]=p.strides,v=e.data.get(r.dataId).values,[_,x,C]=d,E=e.data.get(i.dataId).values,[D,N,R]=h,{batchSize:V,filterHeight:G,filterWidth:j,inChannels:q,inHeight:K,inWidth:P,outChannels:B,outHeight:L,outWidth:H,strideHeight:se,strideWidth:ie}=f,he=G-1-f.padInfo.top,de=j-1-f.padInfo.left,fe=B/q;for(let ye=0;ye<V;++ye)for(let De=0;De<q;++De)for(let Ce=0;Ce<K;++Ce){const Le=Ce-he,ke=Math.max(0,Math.ceil(Le/se)),Qe=Math.min(L,(G+Le)/se);for(let st=0;st<P;++st){const Gt=st-de,on=Math.max(0,Math.ceil(Gt/ie)),kn=Math.min(H,(j+Gt)/ie);let an=0;for(let Yt=ke;Yt<Qe;++Yt){const Cn=Yt*se-Le;for(let yn=on;yn<kn;++yn){const Rs=_*ye+x*Yt+C*yn,wl=D*(G-1-Cn)+N*(j-1-(yn*ie-Gt))+R*De;for(let ni=0;ni<fe;++ni)an+=v[Rs+(De*fe+ni)]*E[wl+ni]}}g[m*ye+y*Ce+b*st+De]=an}}return e.makeTensorInfo(p.shape,p.dtype,p.values)}},fge={kernelName:aS,backendName:"cpu",kernelFunc:function hge(n){const{inputs:t,backend:e}=n,{x:s}=t,r=X(s.shape),i=e.data.get(s.dataId).values,o=dt([r,r],s.dtype),a=o.values;for(let u=0;u<i.length;u++)a[u*r+u]=i[u];const l=[...s.shape,...s.shape];return e.makeTensorInfo(l,o.dtype,o.values)}},pge={kernelName:ky,backendName:"cpu",kernelFunc:({inputs:n,backend:t,attrs:e})=>{const{x:s,filter:r}=n,{strides:i,pad:o,dilations:a}=e,l=t,u=l.data.get(s.dataId).values,c=s.shape.length,d=l.data.get(r.dataId).values,h=r.shape.length,{batchSize:f,inHeight:p,inWidth:g,inChannels:m,outHeight:y,outWidth:b,padInfo:v,strideHeight:_,strideWidth:x,filterHeight:C,filterWidth:E,dilationHeight:D,dilationWidth:N,outShape:R}=sp(s.shape,r.shape,i,o,"NHWC",a),V=X(R),G=R.length,j=Fn(s.dtype,V);for(let K=0;K<f;++K)for(let P=0;P<y;++P){const B=P*_-v.top;for(let L=0;L<b;++L){const H=L*x-v.left;for(let se=0;se<m;++se){let ie=Number.MIN_SAFE_INTEGER;for(let de=0;de<C;++de){const fe=B+de*D;if(fe>=0&&fe<p)for(let ye=0;ye<E;++ye){const De=H+ye*N;if(De>=0&&De<g){const Ce=yo([K,fe,De,se],c,Be(s.shape)),Le=yo([de,ye,se],h,Be(r.shape)),ke=u[Ce]+d[Le];ke>ie&&(ie=ke)}}}j[yo([K,P,L,se],G,Be(R))]=ie}}}return{dataId:l.write(eu(j,s.dtype),R,s.dtype),shape:R,dtype:s.dtype}}},mge={kernelName:uS,backendName:"cpu",kernelFunc:({inputs:n,backend:t,attrs:e})=>{const{x:s,filter:r,dy:i}=n,{strides:o,pad:a,dilations:l}=e,u=t,c=di(s.shape,u.data.get(s.dataId).values),d=di(r.shape,u.data.get(r.dataId).values),{batchSize:h,inHeight:f,inWidth:p,inChannels:g,outHeight:m,outWidth:y,padInfo:b,strideHeight:v,strideWidth:_,filterHeight:x,filterWidth:C,dilationHeight:E,dilationWidth:D,outShape:N}=sp(s.shape,r.shape,o,a,"NHWC",l);S(i.rank===N.length,()=>`Error in ${uS}, dy must have the same rank as output ${N.length}, but got ${i.rank}`);const R=di(N,u.data.get(i.dataId).values),V=M2(r.shape,r.dtype);for(let j=0;j<h;++j)for(let q=0;q<m;++q){const K=q*v-b.top;for(let P=0;P<y;++P){const B=P*_-b.left;for(let L=0;L<g;++L){let H=Number.MIN_SAFE_INTEGER,se=0,ie=0;for(let he=0;he<x;++he){const de=K+he*E;if(de>=0&&de<f)for(let fe=0;fe<C;++fe){const ye=B+fe*D;if(ye>=0&&ye<p){const De=c[j][de][ye][L]+d[he][fe][L];De>H&&(H=De,se=he,ie=fe)}}}V[se][ie][L]+=R[j][q][P][L]}}}return{dataId:u.write(eu(V,s.dtype),r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}},gge={kernelName:lS,backendName:"cpu",kernelFunc:({inputs:n,backend:t,attrs:e})=>{const{x:s,filter:r,dy:i}=n,{strides:o,pad:a,dilations:l}=e,u=t,c=di(s.shape,u.data.get(s.dataId).values),d=di(r.shape,u.data.get(r.dataId).values),{batchSize:h,inHeight:f,inWidth:p,inChannels:g,outHeight:m,outWidth:y,padInfo:b,strideHeight:v,strideWidth:_,filterHeight:x,filterWidth:C,dilationHeight:E,dilationWidth:D,outShape:N}=sp(s.shape,r.shape,o,a,"NHWC",l);S(i.rank===N.length,()=>`Error in ${lS}, dy must have the same rank as output ${N.length}, but got ${i.rank}`);const R=di(N,u.data.get(i.dataId).values),V=M2(s.shape,s.dtype);for(let j=0;j<h;++j)for(let q=0;q<m;++q){const K=q*v-b.top;for(let P=0;P<y;++P){const B=P*_-b.left;for(let L=0;L<g;++L){let H=Number.MIN_SAFE_INTEGER,se=K<0?0:K,ie=B<0?0:B;for(let he=0;he<x;++he){const de=K+he*E;if(de>=0&&de<f)for(let fe=0;fe<C;++fe){const ye=B+fe*D;if(ye>=0&&ye<p){const De=c[j][de][ye][L]+d[he][fe][L];De>H&&(H=De,se=de,ie=ye)}}}V[j][se][ie][L]+=R[j][q][P][L]}}}return{dataId:u.write(eu(V,s.dtype),s.shape,s.dtype),shape:s.shape,dtype:s.dtype}}},cT=Ln((n,t)=>n*t),yge=oT((n,t,e,s)=>({real:n*e-t*s,imag:n*s+t*e})),Pv=us(Rf,cT,yge),bge={kernelName:Rf,backendName:"cpu",kernelFunc:Pv};function Op(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{axis:i,keepDims:o}=s;let a;Me(r,"sum"),a="bool"===r.dtype?cl({inputs:{x:r},backend:e,attrs:{dtype:"int32"}}):Ro({inputs:{x:r},backend:e});const l=a.shape.length,u=mt(i,a.shape),c=vn(u,l);let d=u,h=a;null!=c&&(h=dr({inputs:{x:a},backend:e,attrs:{perm:c}}),d=$n(d.length,l)),Ns("sum",d,h.shape.length);const[f,p]=ws(h.shape,d);let m=$v(e,f,Ir(h.dtype,"int32"));const y=X(p),b=e.data.get(m.dataId).values,v=e.data.get(h.dataId).values;for(let _=0;_<b.length;++_){const x=_*y;let C=0;for(let E=0;E<y;++E)C+=v[x+E];b[_]=C}if(o){const x=m;m=rn({inputs:{x:m},backend:e,attrs:{shape:On(m.shape,u)}}),e.disposeIntermediateTensorInfo(x)}return e.disposeIntermediateTensorInfo(a),null!=c&&e.disposeIntermediateTensorInfo(h),m}const vge={kernelName:ub,backendName:"cpu",kernelFunc:Op},wge={kernelName:cS,backendName:"cpu",kernelFunc:function _ge(n){const{inputs:t,backend:e,attrs:s}=n,{equation:r}=s,i=t,{allDims:o,summedDims:a,idDims:l}=UE(r,i.length);GE(o.length,l,i);const{path:u,steps:c}=HE(a,l),d=c.length;let h=null,f=o.length;const p=[];for(let g=0;g<d;++g){for(const m of c[g]){const{permutationIndices:y,expandDims:b}=WE(f,l[m]);let v;jE(y)?v=i[m]:(v=dr({inputs:{x:i[m]},backend:e,attrs:{perm:y}}),p.push(v));const _=v.shape.slice();for(let x=0;x<b.length;++x)_.splice(b[x],0,1);wt(v.shape,_)||(v=rn({inputs:{x:v},backend:e,attrs:{shape:_}}),p.push(v)),null===h?h=v:(h=Pv({inputs:{a:v,b:h},backend:e}),p.push(h))}g<d-1&&(u[g]>=0&&(h=Op({inputs:{x:h},backend:e,attrs:{axis:u[g]-(o.length-f),keepDims:!1}}),p.push(h)),f--)}for(const g of p)g!==h&&e.disposeIntermediateTensorInfo(g);return h}},Cge={kernelName:dS,backendName:"cpu",kernelFunc:function xge(n){const{inputs:t,backend:e}=n,{dy:s,y:r}=t;Me([s,r],"eluGrad");const i=new Float32Array(X(r.shape)),o=e.data.get(r.dataId).values,a=e.data.get(s.dataId).values;for(let l=0;l<o.length;++l){const u=o[l];i[l]=u>=0?a[l]:a[l]*(u+1)}return e.makeTensorInfo(r.shape,"float32",i)}},Hz=Ln((n,t)=>n===t?1:0),jz=us(Ay,Hz,null,"bool"),Sge={kernelName:Ay,backendName:"cpu",kernelFunc:jz},Ige=FE,Ege=OE,Dge=$E,Tge=PE,Nge=LE,kge=VE,Age=Wt(yf,n=>{const t=Math.sign(n),e=Math.abs(n),s=1/(1+Ige*e);return t*(1-((((kge*s+Nge)*s+Tge)*s+Dge)*s+Ege)*s*Math.exp(-e*e))}),Rge={kernelName:yf,backendName:"cpu",kernelFunc:Age},qz=Ao(n=>Math.exp(n)),Kz=ul(bf,qz,"float32"),Mge={kernelName:bf,backendName:"cpu",kernelFunc:Kz};function Lv(n){const{inputs:t,backend:e,attrs:s}=n,{input:r}=t,{dim:i}=s,o=r.shape.length,a=r.shape.slice();let l=i;return i<0&&(S(-(o+1)<=i,()=>`Axis must be in the interval [${-(o+1)}, ${o}]`),l=o+i+1),a.splice(l,0,1),rn({inputs:{x:r},backend:e,attrs:{shape:a}})}const Fge={kernelName:Ry,backendName:"cpu",kernelFunc:Lv},Xz=Ao(n=>Math.expm1(n)),Oge=ul(vf,Xz),$ge={kernelName:vf,backendName:"cpu",kernelFunc:Oge},Pge=Ln((n,t)=>n/t),dT=us(mf,Pge),hT={kernelName:mf,backendName:"cpu",kernelFunc:dT},Yz=Ln((n,t)=>n-t),Lge=oT((n,t,e,s)=>({real:n-e,imag:t-s})),fT=us(qf,Yz,Lge),Vge={kernelName:qf,backendName:"cpu",kernelFunc:fT};function Zz(n,t,e){const s=n.shape,r=s[0],i=s[1],o=e.data.get(n.dataId),a=o.complexTensorInfos.real,l=o.complexTensorInfos.imag,u=[r,i],c=X(u),d=Ds("float32",c),h=Ds("float32",c);for(let m=0;m<r;m++){const y=vu({inputs:{x:a},backend:e,attrs:{begin:[m,0],size:[1,i]}}),b=vu({inputs:{x:l},backend:e,attrs:{begin:[m,0],size:[1,i]}}),v=kr({inputs:{real:y,imag:b},backend:e}),{real:_,imag:x}=Bge(v,t,e),C=ca(_,x);for(let E=0;E<i;E++){const D=BE(C,E);d[m*i+E]=D.real,h[m*i+E]=D.imag}e.disposeIntermediateTensorInfo(y),e.disposeIntermediateTensorInfo(b),e.disposeIntermediateTensorInfo(v)}const f=e.makeTensorInfo(u,"float32",d),p=e.makeTensorInfo(u,"float32",h),g=kr({inputs:{real:f,imag:p},backend:e});return e.disposeIntermediateTensorInfo(f),e.disposeIntermediateTensorInfo(p),g}function Bge(n,t,e){const s=X(n.shape),r=e.data.get(n.dataId),i=e.data.get(r.complexTensorInfos.real.dataId).values,o=e.data.get(r.complexTensorInfos.imag.dataId).values;if(function zge(n){return 0==(n&n-1)}(s)){const a=pT(i,o,s,t,e),l=[n.shape[0],n.shape[1]];if(t){const u=e.makeTensorInfo(l,"float32",a.real),c=e.makeTensorInfo(l,"float32",a.imag),d=e.makeTensorInfo([],"float32",$a(s,"float32")),h=Ro({inputs:{x:d},backend:e}),f=hT.kernelFunc({inputs:{a:u,b:d},backend:e}),p=hT.kernelFunc({inputs:{a:c,b:h},backend:e}),g=e.data.get(f.dataId).values,m=e.data.get(p.dataId).values;return e.disposeIntermediateTensorInfo(u),e.disposeIntermediateTensorInfo(c),e.disposeIntermediateTensorInfo(d),e.disposeIntermediateTensorInfo(h),e.disposeIntermediateTensorInfo(f),e.disposeIntermediateTensorInfo(p),{real:g,imag:m}}return a}{const l=function Uge(n,t,e){const s=new Float32Array(2*t);for(let r=0;r<t;r++){let i=0,o=0;for(let a=0;a<t;a++){const l=aV(r*a,t,e),u=BE(n,a);i+=u.real*l.real-u.imag*l.imag,o+=u.real*l.imag+u.imag*l.real}e&&(i/=t,o/=t),iV(s,i,o,r)}return s}(ca(i,o),s,t);return nV(l)}}function pT(n,t,e,s,r){if(1===e)return{real:n,imag:t};const i=ca(n,t),o=e/2,a=sV(i),l=a.real,u=a.imag,c=[l.length],d=r.makeTensorInfo(c,"float32",l),h=r.makeTensorInfo(c,"float32",u),f=kr({inputs:{real:d,imag:h},backend:r}),p=rV(i),g=p.real,m=p.imag,y=[g.length],b=r.makeTensorInfo(y,"float32",g),v=r.makeTensorInfo(y,"float32",m),_=kr({inputs:{real:b,imag:v},backend:r}),x=pT(l,u,o,s,r),C=x.real,E=x.imag,D=[C.length],N=r.makeTensorInfo(D,"float32",C),R=r.makeTensorInfo(D,"float32",E),V=kr({inputs:{real:N,imag:R},backend:r}),G=pT(g,m,o,s,r),j=G.real,q=G.imag,K=[j.length],P=r.makeTensorInfo(K,"float32",j),B=r.makeTensorInfo(K,"float32",q),L=kr({inputs:{real:P,imag:B},backend:r}),H=oV(e,s),se=[H.real.length],ie=r.makeTensorInfo(se,"float32",H.real),he=r.makeTensorInfo(se,"float32",H.imag),de=kr({inputs:{real:ie,imag:he},backend:r}),fe=Pv({inputs:{a:de,b:L},backend:r}),ye=md({inputs:{a:V,b:fe},backend:r}),De=fT({inputs:{a:V,b:fe},backend:r}),Ce=bu({inputs:{input:ye},backend:r}),Le=bu({inputs:{input:De},backend:r}),ke=gd({inputs:{input:ye},backend:r}),Qe=gd({inputs:{input:De},backend:r}),st=yd({inputs:[Ce,Le],backend:r,attrs:{axis:0}}),Gt=yd({inputs:[ke,Qe],backend:r,attrs:{axis:0}}),on=r.data.get(st.dataId).values,kn=r.data.get(Gt.dataId).values;return r.disposeIntermediateTensorInfo(d),r.disposeIntermediateTensorInfo(h),r.disposeIntermediateTensorInfo(f),r.disposeIntermediateTensorInfo(b),r.disposeIntermediateTensorInfo(v),r.disposeIntermediateTensorInfo(_),r.disposeIntermediateTensorInfo(N),r.disposeIntermediateTensorInfo(R),r.disposeIntermediateTensorInfo(V),r.disposeIntermediateTensorInfo(P),r.disposeIntermediateTensorInfo(B),r.disposeIntermediateTensorInfo(L),r.disposeIntermediateTensorInfo(ie),r.disposeIntermediateTensorInfo(he),r.disposeIntermediateTensorInfo(de),r.disposeIntermediateTensorInfo(fe),r.disposeIntermediateTensorInfo(ye),r.disposeIntermediateTensorInfo(De),r.disposeIntermediateTensorInfo(Ce),r.disposeIntermediateTensorInfo(ke),r.disposeIntermediateTensorInfo(Le),r.disposeIntermediateTensorInfo(Qe),r.disposeIntermediateTensorInfo(st),r.disposeIntermediateTensorInfo(Gt),{real:on,imag:kn}}const Gge={kernelName:"FFT",backendName:"cpu",kernelFunc:function Wge(n){const{inputs:t,backend:e}=n,{input:s}=t,r=X(s.shape),i=s.shape[s.shape.length-1],a=rn({inputs:{x:s},backend:e,attrs:{shape:[r/i,i]}}),l=Zz(a,!1,e),u=rn({inputs:{x:l},backend:e,attrs:{shape:s.shape}});return e.disposeIntermediateTensorInfo(a),e.disposeIntermediateTensorInfo(l),u}};function mT(n){const{backend:t,attrs:e}=n,{shape:s,value:r,dtype:i}=e,o=i||Vc(r),a=Fn(o,X(s));return function jge(n,t,e){n.fill(t)}(a,r),t.makeTensorInfo(s,o,a)}const Hge={kernelName:fS,backendName:"cpu",kernelFunc:mT},qge={kernelName:pS,backendName:"cpu",kernelFunc:({inputs:n,backend:e})=>{const{image:s}=n,r=e,i=Ds(s.dtype,X(s.shape)),[o,a,l,u]=s.shape,c=r.data.get(s.dataId).values;for(let h=0;h<o;h++){const f=h*l*a*u;for(let p=0;p<a;p++){const g=p*(l*u);for(let m=0;m<l;m++){const y=m*u;for(let b=0;b<u;b++){const v=Math.round(l-m-1),_=f+g+y+b;let x=c[_];v>=0&&v<l&&(x=c[f+g+v*u+b]),i[_]=x}}}}return{dataId:r.write(i,s.shape,s.dtype),shape:s.shape,dtype:s.dtype}}},Qz=Ao(n=>Math.floor(n)),Kge=ul(_f,Qz),Xge={kernelName:_f,backendName:"cpu",kernelFunc:Kge},Yge=Ln((n,t)=>Math.floor(n/t)),Zge=us(wf,Yge,null,"int32"),Qge={kernelName:wf,backendName:"cpu",kernelFunc:Zge},eye={kernelName:bb,backendName:"cpu",kernelFunc:function Jge(n){const{inputs:t,backend:e,attrs:s}=n,{x:r,filter:i,bias:o,preluActivationWeights:a}=t,{strides:l,pad:u,dataFormat:c,dilations:d,dimRoundingMode:h,activation:f,leakyreluAlpha:p}=s;let g=Wz({inputs:{x:r,filter:i},backend:e,attrs:{strides:l,pad:u,dataFormat:c,dilations:d,dimRoundingMode:h}});if(o){const m=g;if("NCHW"===c&&1===o.shape.length&&1!==o.shape[0]){const y=rn({inputs:{x:o},backend:e,attrs:{shape:[o.shape[0],1,1]}});g=md({inputs:{a:g,b:y},backend:e}),e.disposeIntermediateTensorInfo(y)}else g=md({inputs:{a:g,b:o},backend:e});e.disposeIntermediateTensorInfo(m)}if(f){const m=g;if("NCHW"===c&&"prelu"===f&&1===a.shape.length&&1!==a.shape[0]){const y=rn({inputs:{x:a},backend:e,attrs:{shape:[a.shape[0],1,1]}});g=Ov(e,g,f,y,p),e.disposeIntermediateTensorInfo(y)}else g=Ov(e,g,f,a,p);e.disposeIntermediateTensorInfo(m)}return g}},nye={kernelName:vb,backendName:"cpu",kernelFunc:function tye(n){const{inputs:t,backend:e,attrs:s}=n,{x:r,filter:i,bias:o,preluActivationWeights:a}=t,{strides:l,pad:u,dataFormat:c,dilations:d,dimRoundingMode:h,activation:f,leakyreluAlpha:p}=s;let g=Gz({inputs:{x:r,filter:i},backend:e,attrs:{strides:l,pad:u,dataFormat:c,dilations:d,dimRoundingMode:h}});if(o){const m=g;g=md({inputs:{a:g,b:o},backend:e}),e.disposeIntermediateTensorInfo(m)}if(f){const m=g;g=Ov(e,g,f,a,p),e.disposeIntermediateTensorInfo(m)}return g}};function Jz(n,t,e,s,r,i,o,a,l){const u=dt([s,i],e);for(let c=0;c<s;c++){const d=[];let h=0;for(let f=0;f<r;f++){const p=n[c*r+f];h+=p*o[f],d.push(p)}if(h<0||h>=l/i)throw new Error(`Invalid indices: ${d} does not index into ${a}`);for(let f=0;f<i;f++)u.values[c*i+f]=t.get(...t.indexToLoc(h*i+f))}return u}const rye={kernelName:mS,backendName:"cpu",kernelFunc:function sye(n){const{inputs:t,backend:e}=n,{params:s,indices:r}=t,i=X(s.shape),o=r.shape,a=o[o.length-1],[l,u,c,d]=ME(s,r);if(0===u)return e.makeTensorInfo(l,s.dtype,[]);const p=Jz(e.data.get(r.dataId).values,e.bufferSync(s),s.dtype,u,a,c,d,s.shape,i);return e.makeTensorInfo(l,s.dtype,p.values)}};function e3(n,t,e){const s=dt(e,n.dtype);for(let r=0;r<s.size;++r){const o=s.indexToLoc(r).slice(),u=t.locToIndex([o[0],o[2]]);o[2]=t.values[u];const c=n.locToIndex(o);0<=c&&c<n.values.length&&(s.values[r]=n.values[c])}return s}const oye={kernelName:Fy,backendName:"cpu",kernelFunc:function iye(n){const{inputs:t,backend:e,attrs:s}=n,{x:r,indices:i}=t,{axis:o,batchDims:a}=s;Me([r,i],"gatherV2");const l=mt(o,r.shape)[0],u=e.data.get(i.dataId).values,c=r.shape[l];for(let _=0;_<u.length;++_){const x=u[_];S(x<=c-1&&x>=0,()=>`GatherV2: the index value ${x} is not in [0, ${c-1}]`)}let d=a;null==a&&(d=0);const h=X(i.shape),f=XE(r,i,l,d),p=rn({inputs:{x:r},backend:e,attrs:{shape:[f.batchSize,f.outerSize,f.dimSize,f.sliceSize]}}),g=rn({inputs:{x:i},backend:e,attrs:{shape:[f.batchSize,h/f.batchSize]}}),m=[f.batchSize,f.outerSize,h/f.batchSize,f.sliceSize],y=e.bufferSync(g),v=e3(e.bufferSync(p),y,m);return e.disposeIntermediateTensorInfo(p),e.disposeIntermediateTensorInfo(g),e.makeTensorInfo(f.outputShape,v.dtype,v.values)}},t3=Ln((n,t)=>n>t?1:0),aye=us(Oy,t3,null,"bool"),lye={kernelName:Oy,backendName:"cpu",kernelFunc:aye},n3=Ln((n,t)=>n>=t?1:0),uye=us(xf,n3,null,"bool"),cye={kernelName:xf,backendName:"cpu",kernelFunc:uye},hye={kernelName:gS,backendName:"cpu",kernelFunc:function dye(n){const{inputs:t,backend:e}=n,{input:s}=t,r=X(s.shape),i=s.shape[s.shape.length-1],a=rn({inputs:{x:s},backend:e,attrs:{shape:[r/i,i]}}),l=Zz(a,!0,e),u=rn({inputs:{x:l},backend:e,attrs:{shape:s.shape}});return e.disposeIntermediateTensorInfo(a),e.disposeIntermediateTensorInfo(l),u}},fye=Wt(Sf,n=>Number.isFinite(n)?1:0,"bool"),pye={kernelName:Sf,backendName:"cpu",kernelFunc:fye},mye=Wt(If,n=>Math.abs(n)===1/0?1:0,"bool"),gye={kernelName:If,backendName:"cpu",kernelFunc:mye},yye=Wt(Ef,n=>Number.isNaN(n)?1:0,"bool"),bye={kernelName:Ef,backendName:"cpu",kernelFunc:yye},s3=Ln((n,t)=>n<t?1:0),vye=us(Py,s3,null,"bool"),_ye={kernelName:Py,backendName:"cpu",kernelFunc:vye},r3=Ln((n,t)=>n<=t?1:0),wye=us(Ly,r3,null,"bool"),xye={kernelName:Ly,backendName:"cpu",kernelFunc:wye};function o3(n,t,e){const s=(t-n)/(e-1),r=Vs(e,"float32");r[0]=n;for(let i=1;i<r.length;i++)r[i]=r[i-1]+s;return r}const Sye={kernelName:bS,backendName:"cpu",kernelFunc:function Cye(n){const{backend:t,attrs:e}=n,{start:s,stop:r,num:i}=e,o=o3(s,r,i);return t.makeTensorInfo([o.length],"float32",o)}},a3=Ao(n=>Math.log(n)),Iye=ul(Df,a3),Eye={kernelName:Df,backendName:"cpu",kernelFunc:Iye},Dye=Wt(Tf,n=>Math.log1p(n)),Tye={kernelName:Tf,backendName:"cpu",kernelFunc:Dye},Nye=Ln((n,t)=>n&&t),kye=us(Vy,Nye,null,"bool"),Aye={kernelName:Vy,backendName:"cpu",kernelFunc:kye},Rye=Wt(By,n=>n?0:1,"bool"),Mye={kernelName:By,backendName:"cpu",kernelFunc:Rye},Fye=Ln((n,t)=>n||t),Oye=us(zy,Fye,null,"bool"),$ye={kernelName:zy,backendName:"cpu",kernelFunc:Oye},Lye={kernelName:Uy,backendName:"cpu",kernelFunc:function Pye(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{depthRadius:i,bias:o,alpha:a,beta:l}=s;Me(r,"LRN");const u=r.shape[3],c=u-1,d=e.data.get(r.dataId).values,h=X(r.shape),f=new Float32Array(h);function p(g){const m=g%u;let y=g-m+Math.max(0,m-i);const b=g-m+Math.min(m+i,c);let v=0;for(;y<=b;y++){const _=d[y];v+=_*_}return v}for(let g=0;g<h;g++){const m=p(g),y=d[g]*Math.pow(o+a*m,-l);f[g]=y}return e.makeTensorInfo(r.shape,r.dtype,f)}},Bye={kernelName:vS,backendName:"cpu",kernelFunc:function Vye(n){const{inputs:t,backend:e,attrs:s}=n,{x:r,y:i,dy:o}=t,{depthRadius:a,bias:l,alpha:u,beta:c}=s;Me(o,"LRNGrad");const d=X(o.shape),h=o.shape[3],f=e.data.get(o.dataId).values,p=e.data.get(r.dataId).values,g=e.data.get(i.dataId).values,m=new Float32Array(d),y=d;for(let b=0;b<y;b++){const v=b%h,_=b-v+Math.max(0,v-a),x=b-v+Math.min(h,v+a+1);let C=0;for(let E=_;E<x;E++)C+=Math.pow(p[E],2);C=u*C+l;for(let E=_;E<x;E++){let D=-2*u*c*p[E]*g[b]/C;b===E&&(D+=Math.pow(C,-c)),D*=f[b],m[E]+=D}}return e.makeTensorInfo(o.shape,r.dtype,m)}};function l3(n,t,e,s){const r=Ds(s,X(e));for(let i=0;i<r.length;++i){const o=i*t;let a=n[o];for(let l=0;l<t;++l){const u=n[o+l];(Number.isNaN(u)||u>a)&&(a=u)}r[i]=a}return r}function u3(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{reductionIndices:i,keepDims:o}=s,a=e;let l=r.shape;const u=l.length,c=mt(i,l);let d=c;const h=vn(d,u);let f=a.data.get(r.dataId).values;if(null!=h){const _=new Array(u);for(let x=0;x<_.length;x++)_[x]=l[h[x]];f=aT(f,l,r.dtype,h,_),d=$n(d.length,u),l=_}Me(r,"max"),Ns("max",d,u);const[p,g]=ws(l,d),y=l3(f,X(g),p,r.dtype),b=a.write(y,p,r.dtype);let v=p;return o&&(v=On(p,c)),{dataId:b,shape:v,dtype:r.dtype}}const zye={kernelName:Wy,backendName:"cpu",kernelFunc:u3},c3=Ln((n,t)=>Math.max(n,t)),Uye=us(Nf,c3),Wye={kernelName:Nf,backendName:"cpu",kernelFunc:Uye},Hye={kernelName:Gy,backendName:"cpu",kernelFunc:function Gye(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t;Me(r,"maxPool");const{filterSize:i,strides:o,pad:a,dimRoundingMode:l}=s;S(Ts(o,1),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${o} and dilations '1'`);const c=pi(r.shape,i,o,1,a,l);let d;if(1===c.filterWidth&&1===c.filterHeight&&wt(c.inShape,c.outShape))d=Ro({inputs:{x:r},backend:e});else{const h=e.data.get(r.dataId).values,f=Be(r.shape),p=lT(h,0,r.dtype,f,c,"max");d=e.makeTensorInfo(c.outShape,r.dtype,p.values)}return d}},qye={kernelName:Hy,backendName:"cpu",kernelFunc:function jye(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{filterSize:i,strides:o,pad:a,dimRoundingMode:l,dataFormat:u}=s;Me(r,"maxPool3d");const c=aa(r.shape,i,o,1,a,l,u),h=Lz(e.data.get(r.dataId).values,0,r.dtype,Be(r.shape),c,"max");return e.makeTensorInfo(h.shape,"float32",h.values)}},Xye={kernelName:wS,backendName:"cpu",kernelFunc:function Kye(n){const{inputs:t,backend:e,attrs:s}=n,{dy:r,input:i}=t,{filterSize:o,strides:a,pad:l,dimRoundingMode:u}=s;Me([r,i],"maxPool3DGrad");const c=aa(i.shape,o,a,1,l,u),h=function lme(n,t){const e=dt(t.outShape,"int32"),s=t.strideDepth,r=t.strideHeight,i=t.strideWidth,o=t.dilationDepth,a=t.dilationHeight,l=t.dilationWidth,u=t.effectiveFilterDepth,c=t.effectiveFilterHeight,d=t.effectiveFilterWidth,h=t.padInfo.front,f=t.padInfo.top,p=t.padInfo.left;for(let g=0;g<t.batchSize;++g)for(let m=0;m<t.inChannels;++m)for(let y=0;y<t.outDepth;++y){const b=y*s-h;let v=b;for(;v<0;)v+=o;const _=Math.min(t.inDepth,u+b);for(let x=0;x<t.outHeight;++x){const C=x*r-f;let E=C;for(;E<0;)E+=a;const D=Math.min(t.inHeight,c+C);for(let N=0;N<t.outWidth;++N){const R=N*i-p;let V=R;for(;V<0;)V+=l;const G=Math.min(t.inWidth,d+R);let j=Number.NEGATIVE_INFINITY,q=-1;for(let K=v;K<_;K+=o){const P=K-b;for(let B=E;B<D;B+=a){const L=B-C;for(let H=V;H<G;H+=l){const se=H-R,ie=n.get(g,K,B,H,m);ie>=j&&(j=ie,q=P*c*d+L*c+se)}}}e.set(q,g,y,x,N,m)}}}return e}(e.bufferSync(i),c),f=c.strideDepth,p=c.strideHeight,g=c.strideWidth,m=c.dilationDepth,y=c.dilationHeight,b=c.dilationWidth,v=c.effectiveFilterDepth,_=c.effectiveFilterHeight,x=c.effectiveFilterWidth,C=v-1-c.padInfo.front,E=x-1-c.padInfo.left,D=_-1-c.padInfo.top,N=dt(i.shape,"float32"),R=e.bufferSync(r);for(let V=0;V<c.batchSize;++V)for(let G=0;G<c.inChannels;++G)for(let j=0;j<c.inDepth;++j)for(let q=0;q<c.inHeight;++q)for(let K=0;K<c.inWidth;++K){const P=j-C,B=q-D,L=K-E;let H=0;for(let se=0;se<v;se+=m){const ie=(P+se)/f;if(!(ie<0||ie>=c.outDepth||Math.floor(ie)!==ie))for(let he=0;he<_;he+=y){const de=(B+he)/p;if(!(de<0||de>=c.outHeight||Math.floor(de)!==de))for(let fe=0;fe<x;fe+=b){const ye=(L+fe)/g;if(ye<0||ye>=c.outWidth||Math.floor(ye)!==ye)continue;const Le=v*_*x-1-h.get(V,ie,de,ye,G)===se*_*x+he*x+fe?1:0;0!==Le&&(H+=R.get(V,ie,de,ye,G)*Le)}}}N.set(H,V,j,q,K,G)}return e.makeTensorInfo(N.shape,N.dtype,N.values)}},Zye={kernelName:_S,backendName:"cpu",kernelFunc:function Yye(n){const{inputs:t,backend:e,attrs:s}=n,{dy:r,input:i,output:o}=t,a=i;Me([i,o],"maxPoolGrad");const{filterSize:l,strides:u,pad:c,dimRoundingMode:d}=s,h=pi(a.shape,l,u,1,c,d),f=e.data.get(a.dataId).values,p=dt(h.outShape,a.dtype,Pz(f,a.shape,a.dtype,h).values),g=h.strideHeight,m=h.strideWidth,y=h.dilationHeight,b=h.dilationWidth,v=h.effectiveFilterHeight,_=h.effectiveFilterWidth,x=_-1-h.padInfo.left,C=v-1-h.padInfo.top,E=dt(a.shape,"float32"),D=e.data.get(r.dataId).values,N=dt(r.shape,"float32",D);for(let R=0;R<h.batchSize;++R)for(let V=0;V<h.inChannels;++V)for(let G=0;G<h.inHeight;++G)for(let j=0;j<h.inWidth;++j){const q=G-C,K=j-x;let P=0;for(let B=0;B<v;B+=y){const L=(q+B)/g;if(!(L<0||L>=h.outHeight||Math.floor(L)!==L))for(let H=0;H<_;H+=b){const se=(K+H)/m;if(se<0||se>=h.outWidth||Math.floor(se)!==se)continue;const de=v*_-1-p.get(R,L,se,V)===B*_+H?1:0;0!==de&&(P+=N.get(R,L,se,V)*de)}}E.set(P,R,G,j,V)}return e.makeTensorInfo(E.shape,E.dtype,E.values)}},Jye={kernelName:xS,backendName:"cpu",kernelFunc:({inputs:n,attrs:t,backend:e})=>{const{x:s}=n,{filterSize:r,strides:i,pad:o,includeBatchInIndex:a}=t,l=e;Me(s,"MaxPoolWithArgmax");const u=l.data.get(s.dataId).values,c=pi(s.shape,r,i,[1,1],o),[d,h]=function Qye(n,t,e,s,r){const o=lT(n,0,e,Be(t),r,"max"),a=Pz(n,t,e,r,!0,s);return[o.values,a.values]}(u,s.shape,s.dtype,a,c),f=l.write(d,c.outShape,s.dtype),p=l.write(h,c.outShape,s.dtype);return[{dataId:f,shape:c.outShape,dtype:s.dtype},{dataId:p,shape:c.outShape,dtype:"int32"}]}},tbe={kernelName:jy,backendName:"cpu",kernelFunc:function ebe(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{axis:i,keepDims:o}=s,a=mt(i,r.shape),c=X(ws(r.shape,a)[1]),d=[],h=e.makeTensorInfo([],"float32",new Float32Array([c]));d.push(h);const f=cl({inputs:{x:r},backend:e,attrs:{dtype:"float32"}});d.push(f);const p=dT({inputs:{a:f,b:h},backend:e});d.push(p);const g=Op({inputs:{x:p},backend:e,attrs:{axis:i,keepDims:o}});return d.forEach(m=>e.disposeIntermediateTensorInfo(m)),g}},sbe={kernelName:qy,backendName:"cpu",kernelFunc:function nbe(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{axis:i,keepDims:o}=s;Me(r,"min");const a=mt(i,r.shape);let l=a;const u=vn(l,r.shape.length);let c=r;null!=u&&(c=dr({inputs:{x:r},backend:e,attrs:{perm:u}}),l=$n(l.length,r.shape.length)),Ns("min",l,c.shape.length);const[d,h]=ws(c.shape,l),f=X(h),p=Vs(X(d),c.dtype),g=e.data.get(c.dataId).values;for(let y=0;y<p.length;++y){const b=y*f;let v=g[b];for(let _=0;_<f;++_){const x=g[b+_];(Number.isNaN(x)||x<v)&&(v=x)}p[y]=v}null!=u&&e.disposeIntermediateTensorInfo(c);const m=e.makeTensorInfo(d,c.dtype,p);if(o){const b=rn({inputs:{x:m},backend:e,attrs:{shape:On(d,a)}});return e.disposeIntermediateTensorInfo(m),b}return m}},d3=Ln((n,t)=>Math.min(n,t)),rbe=us(kf,d3),ibe={kernelName:kf,backendName:"cpu",kernelFunc:rbe},abe={kernelName:Ky,backendName:"cpu",kernelFunc:function obe(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{paddings:i,mode:o}=s;Me(r,"mirrorPad");const a=i.map((v,_)=>v[0]+r.shape[_]+v[1]),l=i.map(v=>v[0]),u=i.map((v,_)=>v[0]+r.shape[_]),c="reflect"===o?0:1,d=e.data.get(r.dataId).values,h=r.shape.length,f=Be(r.shape),p=X(a),g=a.length,m=Be(a),y=Ds(r.dtype,p);for(let v=0;v<p;v++){let _=Bc(v,g,m);for(let C=0;C<g;C++)_[C]<l[C]?_[C]=2*l[C]-_[C]-c:_[C]>=u[C]&&(_[C]=2*(u[C]-1)-_[C]+c);_=_.map((C,E)=>C-l[E]);const x=yo(_,h,f);y[v]=d[x]}return{dataId:e.write(y,a,r.dtype),shape:a,dtype:r.dtype}}},lbe=Ln((n,t)=>{const e=n%t;return n<0&&t<0||n>=0&&t>=0?e:(e+t)%t}),ube=us(Af,lbe),cbe={kernelName:Af,backendName:"cpu",kernelFunc:ube};function h3(n){const{inputs:t,backend:e,attrs:s}=n,{logits:r}=t,{dim:i}=s,o=r.shape.length;let a=i;if(-1===a&&(a=o-1),a!==o-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${o} and dim was ${a}`);const l=mt([a],r.shape),u=u3({inputs:{x:r},backend:e,attrs:{reductionIndices:l,keepDims:!1}}),c=On(u.shape,l),d=rn({inputs:{x:u},backend:e,attrs:{shape:c}}),h=fT({inputs:{a:r,b:d},backend:e}),f=Kz({inputs:{x:h},backend:e}),p=Op({inputs:{x:f},backend:e,attrs:{axis:l,keepDims:!1}}),g=rn({inputs:{x:p},backend:e,attrs:{shape:c}}),m=dT({inputs:{a:f,b:g},backend:e});return e.disposeIntermediateTensorInfo(u),e.disposeIntermediateTensorInfo(d),e.disposeIntermediateTensorInfo(h),e.disposeIntermediateTensorInfo(f),e.disposeIntermediateTensorInfo(p),e.disposeIntermediateTensorInfo(g),m}const dbe={kernelName:hb,backendName:"cpu",kernelFunc:h3},fbe={kernelName:CS,backendName:"cpu",kernelFunc:function hbe(n){const{inputs:t,backend:e,attrs:s}=n,{logits:r}=t,{numSamples:i,seed:o,normalized:a}=s;Me(r,"multinomial");const l=a?r:h3({inputs:{logits:r},backend:e,attrs:{dim:-1}}),u=l.shape[0],c=l.shape[1],d=e.data.get(l.dataId).values,h=[u,i],f=Vs(X(h),"int32");for(let p=0;p<u;++p){const g=p*c,m=new Float32Array(c-1);m[0]=d[g];for(let v=1;v<m.length;++v)m[v]=m[v-1]+d[g+v];const y=Hb.alea(o.toString()),b=p*i;for(let v=0;v<i;++v){const _=y();f[b+v]=m.length;for(let x=0;x<m.length;x++)if(_<m[x]){f[b+v]=x;break}}}return a||e.disposeIntermediateTensorInfo(l),e.makeTensorInfo(h,"int32",f)}};function f3(n,t,e){const s=$a(-1,e);return cT([],t,s,n,e)}const mbe={kernelName:Xy,backendName:"cpu",kernelFunc:function pbe(n){const{inputs:t,backend:e}=n,{x:s}=t;Me(s,"neg");const r=e.data.get(s.dataId).values,[i,o]=f3(r,s.shape,s.dtype);return e.makeTensorInfo(o,s.dtype,i)}},gbe=wE,bbe={kernelName:SS,backendName:"cpu",kernelFunc:function ybe(n){const{inputs:t,backend:e,attrs:s}=n,{boxes:r,scores:i}=t,{maxOutputSize:o,iouThreshold:a,scoreThreshold:l}=s;Me(r,"NonMaxSuppression");const u=e.data.get(r.dataId).values,c=e.data.get(i.dataId).values,{selectedIndices:d}=gbe(u,c,o,a,l);return e.makeTensorInfo([d.length],"int32",new Int32Array(d))}},vbe=xE,wbe={kernelName:IS,backendName:"cpu",kernelFunc:function _be(n){const{inputs:t,backend:e,attrs:s}=n,{boxes:r,scores:i}=t,{maxOutputSize:o,iouThreshold:a,scoreThreshold:l,padToMaxOutputSize:u}=s;Me(r,"NonMaxSuppressionPadded");const c=e.data.get(r.dataId).values,d=e.data.get(i.dataId).values,{selectedIndices:h,validOutputs:f}=vbe(c,d,o,a,l,u);return[e.makeTensorInfo([h.length],"int32",new Int32Array(h)),e.makeTensorInfo([],"int32",new Int32Array([f]))]}},xbe=CE,Sbe={kernelName:ES,backendName:"cpu",kernelFunc:function Cbe(n){const{inputs:t,backend:e,attrs:s}=n,{boxes:r,scores:i}=t,{maxOutputSize:o,iouThreshold:a,scoreThreshold:l,softNmsSigma:u}=s;Me(r,"NonMaxSuppressionWithScore");const c=e.data.get(r.dataId).values,d=e.data.get(i.dataId).values,h=o,f=a,p=l,g=u,{selectedIndices:m,selectedScores:y}=xbe(c,d,h,f,p,g);return[e.makeTensorInfo([m.length],"int32",new Int32Array(m)),e.makeTensorInfo([y.length],"float32",new Float32Array(y))]}},p3=Ln((n,t)=>n!==t?1:0),Ibe=us(Yy,p3,null,"bool"),Ebe={kernelName:Yy,backendName:"cpu",kernelFunc:Ibe},Tbe={kernelName:Qy,backendName:"cpu",kernelFunc:function Dbe(n){const{inputs:t,backend:e,attrs:s}=n,{indices:r}=t,{dtype:i,depth:o,onValue:a,offValue:l}=s;Me(r,"oneHot");const u=X(r.shape),c=new Float32Array(u*o);c.fill(l);const d=e.data.get(r.dataId).values;for(let h=0;h<u;++h)d[h]>=0&&d[h]<o&&(c[h*o+d[h]]=a);return e.makeTensorInfo([...r.shape,o],i,c)}};function Vv(n){const{inputs:t,backend:e}=n,{x:s}=t;if("string"===s.dtype)throw new Error("zerosLike is not supported for string tensors");if("complex64"===s.dtype){const r=bu({inputs:{input:s},backend:e}),i=Vv({inputs:{x:r},backend:e}),o=gd({inputs:{input:s},backend:e}),a=Vv({inputs:{x:o},backend:e}),l=kr({inputs:{real:i,imag:a},backend:e});return e.disposeIntermediateTensorInfo(r),e.disposeIntermediateTensorInfo(i),e.disposeIntermediateTensorInfo(o),e.disposeIntermediateTensorInfo(a),l}return mT({backend:e,attrs:{shape:s.shape,value:0,dtype:s.dtype}})}const Nbe={kernelName:gb,backendName:"cpu",kernelFunc:Vv},kbe={kernelName:Zy,backendName:"cpu",kernelFunc:function m3(n){const{inputs:t,backend:e}=n,{x:s}=t;if("string"===s.dtype)throw new Error("onesLike is not supported for string tensors");if("complex64"===s.dtype){const r=bu({inputs:{input:s},backend:e}),i=m3({inputs:{x:r},backend:e}),o=gd({inputs:{input:s},backend:e}),a=Vv({inputs:{x:o},backend:e}),l=kr({inputs:{real:i,imag:a},backend:e});return e.disposeIntermediateTensorInfo(r),e.disposeIntermediateTensorInfo(i),e.disposeIntermediateTensorInfo(o),e.disposeIntermediateTensorInfo(a),l}return mT({backend:e,attrs:{shape:s.shape,value:1,dtype:s.dtype}})}};function g3(n){const{inputs:t,backend:e,attrs:s}=n,{axis:r}=s;if(1===t.length)return Lv({inputs:{input:t[0]},backend:e,attrs:{dim:r}});const i=t[0].shape,o=t[0].dtype;t.forEach(c=>{Sr(i,c.shape,"All tensors passed to stack must have matching shapes"),S(o===c.dtype,()=>"All tensors passed to stack must have matching dtypes")});const a=[],u=yd({inputs:t.map(c=>{const d=Lv({inputs:{input:c},backend:e,attrs:{dim:r}});return a.push(d),d}),backend:e,attrs:{axis:r}});return a.forEach(c=>e.disposeIntermediateTensorInfo(c)),u}const Abe={kernelName:Jy,backendName:"cpu",kernelFunc:g3},y3={kernelName:eb,backendName:"cpu",kernelFunc:function Rbe(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{paddings:i,constantValue:o}=s;Me(r,"pad");const a=i.map((b,v)=>b[0]+r.shape[v]+b[1]),l=i.map(b=>b[0]),u=e.data.get(r.dataId).values,c=X(r.shape),d=r.shape.length,h=Be(r.shape),f=X(a),p=a.length,g=Be(a),m=Ds(r.dtype,f);0!==o&&m.fill(o);for(let b=0;b<c;b++)m[yo(Bc(b,d,h).map((C,E)=>C+l[E]),p,g)]=u[b];return{dataId:e.write(m,a,r.dtype),shape:a,dtype:r.dtype}}},Mbe=Ln((n,t)=>Math.pow(n,t)),Fbe=us(Mf,Mbe),Obe={kernelName:Mf,backendName:"cpu",kernelFunc:Fbe};function b3(n,t,e,s){const[r,i]=ws(n,s),o=Ir(t,"int32"),a=Vs(X(r),o),l=X(i);for(let u=0;u<a.length;++u){const c=u*l;let d=1;for(let h=0;h<l;++h)d*=e[c+h];a[u]=d}return{outVals:a,outShape:r,outDtype:o}}const Pbe={kernelName:nb,backendName:"cpu",kernelFunc:function $be(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{axis:i,keepDims:o}=s;Me(r,"prod");const a=r.shape.length,l=mt(i,r.shape),u=vn(l,a);let c=l,d=r;const h=[];null!=u&&(d=dr({inputs:{x:r},backend:e,attrs:{perm:u}}),h.push(d),c=$n(c.length,a));const f=e.data.get(d.dataId).values,{outVals:p,outShape:g,outDtype:m}=b3(d.shape,d.dtype,f,c);let y=g;return o&&(y=On(g,l)),h.forEach(b=>e.disposeIntermediateTensorInfo(b)),e.makeTensorInfo(y,m,p)}};function v3(n,t){const e=n.slice(0,t);for(;e.length<t;)e.push(1);for(let s=t;s<n.length;s++)e[t-1]*=n[s];return e}function _3(n,t,e,s,r,i,o,a){if(0===n.length)throw new Error("paramsNestedSplits must be non empty");if(0===t[0].length)throw new Error("Split tensors must not be scalars");if(function Lbe(n,t,e){n.forEach((s,r)=>{if(s<0||s>=e){const i=Bc(r,t.length,Be(t)).join(",");throw new Error(`indices[${i}] = ${s} is not in [0, ${e})`)}})}(i,o,t[0][0]-1),0===s.length)throw new Error("params.rank must be nonzero");const u=s[0],{outSplits:c,valueSlices:d,numValues:h}=function Bbe(n,t,e,s){const r=[];let i=0;const a=new Array(t.length-1+e.length).fill(null).map(()=>[0]);!function Vbe(n,t){for(let e=0;e<n.length;++e){const s=n[e],r=e===n.length-1?t:n[e+1].length;if(0===s.length)throw new Error("Ragged splits may not be empty");if(s[0]<0)throw new Error("Ragged splits must be non-negative");if(s[s.length-1]>r)throw new Error("Ragged splits must not point past values");for(let i=1;i<s.length;++i)if(s[i-1]>s[i])throw new Error("Ragged splits must be sorted in ascending order")}}(e,s);let l=1;for(let u=0;u<t.length-1;++u){l*=t[u];const c=t[u+1];for(let d=1;d<l+1;++d)a[u].push(d*c)}for(let u=0;u<n.length;++u){let c=n[u],d=n[u]+1;for(let h=0;h<e.length;++h){const f=e[h],p=h+t.length-1;if(p>=0){const g=a[p],m=g[g.length-1]-f[c];for(let y=c;y<d;++y)a[p].push(f[y+1]+m)}c=f[c],d=f[d]}d!==c&&(r.push([c,d]),i+=d-c)}return{outSplits:a,valueSlices:r,numValues:i}}(i,o,n,u),f=function zbe(n){const t=[];for(let e=0;e<n.length;++e){const r=Fn("int32",n[e].length);t.push(r),n[e].forEach((i,o)=>r[o]=i)}return t}(c),p=function Wbe(n,t,e,s,r){const i=t.slice();i[0]=r;const o=Fn(e,X(i)),a=n.length;return function Ube(n,t,e,s,r,i){const o=v3(t,2)[1],a=v3(i,2)[1];let l=0;for(const u of e)for(let c=u[0];c<u[1];++c){for(let d=0;d<s;++d)r[l*a+d]=n[c*o+d];++l}}(n,t,s,0===a?0:a/t[0],o,i),[o,i]}(e,s,r,d,h);return[f,p[0],p[1]]}const Hbe={kernelName:DS,backendName:"cpu",kernelFunc:function Gbe(n){const{inputs:t,backend:e,attrs:s}=n,{paramsNestedSplits:r,paramsDenseValues:i,indices:o}=t,l=r.map(y=>e.data.get(y.dataId).values),u=r.map(y=>y.shape),c=e.data.get(i.dataId).values,d=e.data.get(o.dataId).values,[h,f,p]=_3(l,u,c,i.shape,i.dtype,d,o.shape),g=h.map(y=>e.makeTensorInfo([y.length],"int32",y)),m=e.makeTensorInfo(p,i.dtype,f);return g.concat([m])}},w3=2147483647;function x3(n,t,e,s,r,i,o){if(t.length>1)throw new Error("starts must be a scalar or vector");if(r.length>1)throw new Error("limits must be a scalar or vector");if(o.length>1)throw new Error("deltas must be a scalar or vector");const a=0===t.length,l=0===r.length,u=0===o.length,c=[];a||c.push(t[0]),l||c.push(r[0]),u||c.push(o[0]);for(let m=1;m<c.length;++m)if(c[m]!==c[m-1])throw new Error("starts, limits, and deltas must have the same shape");const d=0===c.length?1:c[0],h=Fn("int32",d+1);h[0]=0;for(let m=0;m<d;++m){const y=a?n[0]:n[m],b=l?s[0]:s[m],v=u?i[0]:i[m];if(0===v)throw new Error("Requires delta != 0");let _;if(v>0&&b<y||v<0&&b>y)_=0;else if(_=Math.ceil(Math.abs((b-y)/v)),_>w3)throw new Error(`Requires ((limit - start) / delta) <= ${w3}`);h[m+1]=h[m]+_}const p=Fn(e,h[d]);let g=0;for(let m=0;m<d;++m){const y=h[m+1]-h[m];let b=a?n[0]:n[m];const v=u?i[0]:i[m];for(let _=0;_<y;++_)p[g++]=b,b+=v}return[h,p]}const qbe={kernelName:TS,backendName:"cpu",kernelFunc:function jbe(n){const{inputs:t,backend:e}=n,{starts:s,limits:r,deltas:i}=t,o=e.data.get(s.dataId).values,a=e.data.get(r.dataId).values,l=e.data.get(i.dataId).values,[u,c]=x3(o,s.shape,s.dtype,a,r.shape,l,i.shape);return[e.makeTensorInfo([u.length],"int32",u),e.makeTensorInfo([c.length],s.dtype,c)]}};var Ci=wn;class Bv{constructor(t,e,s,r,i,o,a,l,u,c){this.shape=t,this.shapeShape=e,this.values=s,this.valuesShape=r,this.valuesDType=i,this.defaultValue=o,this.defaultValueShape=a,this.rowPartitionValues=l,this.rowPartitionValuesShapes=u,this.rowPartitionTypes=JL(c),this.raggedRank=eV(this.rowPartitionTypes)}getRowPartitionTypeByDimension(t){return this.rowPartitionTypes[0]===Ci.FIRST_DIM_SIZE?this.rowPartitionTypes[t+1]:this.rowPartitionTypes[t]}getRowPartitionTensor(t){return this.rowPartitionTypes[0]===Ci.FIRST_DIM_SIZE?this.rowPartitionValues[t+1]:this.rowPartitionValues[t]}getMaxWidth(t){const e=this.getRowPartitionTensor(t-1);switch(this.getRowPartitionTypeByDimension(t-1)){case Ci.VALUE_ROWIDS:return Bv.getMaxWidthValueRowID(e);case Ci.ROW_SPLITS:return Bv.getMaxWidthRowSplit(e);default:throw new Error(`Cannot handle partition type ${Ci[this.getRowPartitionTypeByDimension(t-1)]}`)}}static getMaxWidthRowSplit(t){const e=t.length;if(0===e||1===e)return 0;let s=0;for(let r=0;r<e-1;++r){const i=t[r+1]-t[r];i>s&&(s=i)}return s}static getMaxWidthValueRowID(t){const e=t.length;if(0===e)return 0;let s=0,r=t[0],i=0;for(let o=1;o<e;++o){const a=t[o];a!==r&&(r=a,i=Math.max(o-s,i),s=o)}return Math.max(e-s,i)}tensorShapeFromTensor(t,e,s=!0){if(0===e.length){if(-1===t[0])return[];throw new Error("The only valid scalar shape tensor is the fully unknown shape specified as -1.")}return S3(t,s)}calculateOutputSize(t){const e=this.valuesShape;tV(this.defaultValueShape,e);const r=this.tensorShapeFromTensor(this.shape,this.shapeShape),o=QL(this.raggedRank,r,e);o[0]<0&&(o[0]=t);for(let a=1;a<=this.raggedRank;++a)o[a]<0&&(o[a]=this.getMaxWidth(a));return o}calculateFirstParentOutputIndex(t,e,s){const r=Math.min(t,s),i=[];let o=0;for(let a=0;a<r;++a,o+=e)i.push(o);for(let a=r;a<t;++a)i.push(-1);return S(i.length===t,()=>"Final length of result must be equal to firstDimension."),i}calculateOutputIndexRowSplit(t,e,s,r){const i=t.length,o=[];for(let a=0;a<i-1;++a){const l=t[a+1]-t[a];let u=Math.min(r,l),c=e[a];-1===c&&(u=0);for(let d=0;d<u;++d)o.push(c),c+=s;for(let d=0;d<l-u;++d)o.push(-1)}if(i>0&&o.length!==t[i-1])throw new Error("Invalid row split size.");return o}calculateOutputIndexValueRowID(t,e,s,r){const i=t.length,o=[];if(0===i)return[];let a=0,l=t[0];if(l>=e.length)throw new Error(`Got currentValueRowId=${l}, which is not less than ${e.length}`);let u=e[l];o.push(u);for(let c=1;c<i;++c){const d=t[c];if(d===l)u>=0&&(++a,a<r?u+=s:u=-1);else{if(a=0,l=d,d>=e.length)throw new Error(`Got nextValueRowId=${d} which is not less than ${e.length}`);u=e[d]}o.push(u)}if(o.length!==t.length)throw new Error("Invalid row ids.");return o}calculateOutputIndex(t,e,s,r){const i=this.getRowPartitionTensor(t),o=this.getRowPartitionTypeByDimension(t);switch(o){case Ci.VALUE_ROWIDS:return this.calculateOutputIndexValueRowID(i,e,s,r);case Ci.ROW_SPLITS:if(i.length-1>e.length)throw new Error(`Row partition size is greater than output size: ${i.length-1} > ${e.length}`);return this.calculateOutputIndexRowSplit(i,e,s,r);default:throw new Error(`Unsupported partition type: ${Ci[o]}`)}}getFirstDimensionSize(){const t=this.rowPartitionValues[0];if(0===this.rowPartitionTypes.length)throw new Error("No row_partition_types given.");const e=this.rowPartitionTypes[0];switch(e){case Ci.FIRST_DIM_SIZE:return t[0];case Ci.VALUE_ROWIDS:throw new Error("Cannot handle VALUE_ROWIDS in first dimension.");case Ci.ROW_SPLITS:return this.rowPartitionValuesShapes[0][0]-1;default:throw new Error(`Cannot handle type ${Ci[e]}`)}}compute(){if(this.rowPartitionValues[0].length<=0)throw new Error("Invalid first partition input. Tensor requires at least one element.");const e=this.getFirstDimensionSize(),s=this.calculateOutputSize(e),r=new Array(this.raggedRank+1);r[r.length-1]=1;for(let l=r.length-2;l>=0;--l)r[l]=r[l+1]*s[l+1];const i=S3(s,!1),o=Fn(this.valuesDType,X(i));if(r[0]*s[0]>0){let l=this.calculateFirstParentOutputIndex(e,r[0],s[0]);for(let u=1;u<=this.raggedRank;++u)l=this.calculateOutputIndex(u-1,l,r[u],s[u]);this.setOutput(this.raggedRank,l,o,i)}return[i,o]}setOutput(t,e,s,r){if(0===s.length)return;const i=this.values,o=s;let a=r.slice();a=a.slice(t+1);const l=X(a),u=e.length;let c=this.defaultValue;if(c.length!==l&&1!==c.length){const p=this.defaultValueShape;z(()=>{const g=O(c,p);c=td(g,a).dataSync()})}let d=0,h=0,f=0;for(let p=0;p<=u;++p){let g=p<u?e[p]:-1;if(g!==f){if(h<f){const m=i.subarray(d*l);C3(o.subarray(h*l),m,(f-h)*l)}if(p>=u&&(g=Math.floor(s.length/l)),g>f)if(1===this.defaultValue.length)o.subarray(f*l,g*l).fill(this.defaultValue[0]),f=g;else for(;g>f;)C3(o.slice(f*l),c,l),++f;g<0?(d=p+1,h=f):(d=p,h=f,f=h+1)}else++f}}}function C3(n,t,e){for(let s=0;s<e;s++)n[s]=t[s]}function S3(n,t){const e=[];for(let s of n){if(s<0){if(!t)throw new Error(`Dimension ${s} must be >= 0`);if(s<-1)throw new Error(`Dimension ${s} must be >= -1`);s=-1}e.push(s)}return e}function I3(n,t,e,s,r,i,o,a,l,u){return new Bv(n,t,e,s,r,i,o,a,l,u).compute()}const Xbe={kernelName:NS,backendName:"cpu",kernelFunc:function Kbe(n){const{inputs:t,backend:e,attrs:s}=n,{shape:r,values:i,defaultValue:o,rowPartitionTensors:a}=t,{rowPartitionTypes:l}=s,u=e.data.get(r.dataId).values,c=e.data.get(i.dataId).values,d=e.data.get(o.dataId).values,h=a.map(m=>e.data.get(m.dataId).values),f=a.map(m=>m.shape),[p,g]=I3(u,r.shape,c,i.shape,i.dtype,d,o.shape,h,f,l);return e.makeTensorInfo(p,i.dtype,g)}};function E3(n,t,e,s){if(n===t||n<t&&e<0||t<n&&e>1)return Vs(0,s);const l=Vs(Math.abs(Math.ceil((t-n)/e)),s);t<n&&1===e&&(e=-1),l[0]=n;for(let u=1;u<l.length;u++)l[u]=l[u-1]+e;return l}const Zbe={kernelName:kS,backendName:"cpu",kernelFunc:function Ybe(n){const{backend:t,attrs:e}=n,{start:s,stop:r,dtype:i,step:o}=e,a=E3(s,r,o,i);return t.makeTensorInfo([a.length],i,a)}},Qbe=Wt(Ff,n=>1/n),Jbe={kernelName:Ff,backendName:"cpu",kernelFunc:Qbe},tve={kernelName:ib,backendName:"cpu",kernelFunc:function eve(n){const{inputs:t,backend:e,attrs:s}=n,{images:r}=t,{alignCorners:i,halfPixelCenters:o,size:a}=s;Me(r,"resizeBilinear");const l=Be(r.shape),[u,c]=a,[d,h,f,p]=r.shape,g=e.data.get(r.dataId).values,m=new Float32Array(X([d,u,c,p])),y=[i&&u>1?h-1:h,i&&c>1?f-1:f],b=[i&&u>1?u-1:u,i&&c>1?c-1:c];let v=0;const _=y[0]/b[0],x=y[1]/b[1];for(let C=0;C<d;C++)for(let E=0;E<u;E++){let D;D=o?_*(E+.5)-.5:_*E;const N=Math.max(0,Math.floor(D)),R=D-N,V=Math.min(h-1,Math.ceil(D)),G=C*l[0]+N*l[1],j=C*l[0]+V*l[1];for(let q=0;q<c;q++){let K;K=o?x*(q+.5)-.5:x*q;const P=Math.max(0,Math.floor(K)),B=K-P,L=Math.min(f-1,Math.ceil(K)),H=G+P*l[2],se=j+P*l[2],ie=G+L*l[2],he=j+L*l[2];for(let de=0;de<p;de++){const fe=g[H+de],ye=g[se+de],Le=fe+(g[ie+de]-fe)*B;m[v++]=Le+(ye+(g[he+de]-ye)*B-Le)*R}}}return e.makeTensorInfo([d,u,c,p],"float32",m)}},sve={kernelName:MS,backendName:"cpu",kernelFunc:function nve(n){const{inputs:t,backend:e,attrs:s}=n,{images:r,dy:i}=t,{alignCorners:o}=s;Me([i,r],"resizeBilinearGrad");const a=Be(r.shape),[l,u,c,d]=r.shape,[,h,f]=i.shape,p=new Float32Array(l*u*c*d),g=[o&&h>1?u-1:u,o&&f>1?c-1:c],m=[o&&h>1?h-1:h,o&&f>1?f-1:f],y=g[0]/m[0],b=g[1]/m[1],v=e.data.get(i.dataId).values;let _=0;for(let x=0;x<l;x++){const C=x*a[0];for(let E=0;E<h;E++){const D=E*y,N=Math.floor(D),R=Math.min(Math.ceil(D),u-1),V=C+N*a[1],G=C+R*a[1],j=D-N,q=1-j;for(let K=0;K<f;K++){const P=K*b,B=Math.floor(P),L=Math.min(Math.ceil(P),c-1),H=P-B,se=1-H,ie=V+B*a[2],he=V+L*a[2],de=G+B*a[2],fe=G+L*a[2],ye=q*se,De=q*H,Ce=j*se,Le=j*H;for(let ke=0;ke<d;ke++){const Qe=v[_++];p[ie+ke]+=Qe*ye,p[he+ke]+=Qe*De,p[de+ke]+=Qe*Ce,p[fe+ke]+=Qe*Le}}}}return e.makeTensorInfo([l,c,u,d],"float32",p)}},ive={kernelName:rb,backendName:"cpu",kernelFunc:function rve(n){const{inputs:t,backend:e,attrs:s}=n,{images:r}=t,{alignCorners:i,halfPixelCenters:o,size:a}=s;Me(r,"resizeNearestNeighbor");const l=Be(r.shape),[u,c]=a,[d,h,f,p]=r.shape,g=e.data.get(r.dataId).values,m=new Float32Array(d*u*c*p),y=[i&&u>1?h-1:h,i&&c>1?f-1:f],b=[i&&u>1?u-1:u,i&&c>1?c-1:c],v=y[0]/b[0],_=y[1]/b[1];let x=0;for(let C=0;C<d;C++){const E=C*l[0];for(let D=0;D<u;D++){const N=o?v*(D+.5):v*D;let R=Math.min(h-1,i?Math.round(N):Math.floor(N));o&&(R=Math.max(0,R));const V=E+R*l[1];for(let G=0;G<c;G++){const j=o?_*(G+.5):_*G;let q=Math.min(f-1,i?Math.round(j):Math.floor(j));o&&(q=Math.max(0,q));const K=V+q*l[2];for(let P=0;P<p;P++)m[x++]=g[K+P]}}}return e.makeTensorInfo([d,u,c,p],r.dtype,m)}},ave={kernelName:RS,backendName:"cpu",kernelFunc:function ove(n){const{inputs:t,backend:e,attrs:s}=n,{images:r,dy:i}=t,{alignCorners:o}=s;Me([i,r],"resizeNearestNeighborGrad");const a=Be(r.shape),l=Be(i.shape),[u,c,d,h]=r.shape,[,f,p]=i.shape,g=new Float32Array(u*c*d*h),m=e.data.get(i.dataId).values,y=[o&&f>1?c-1:c,o&&p>1?d-1:d],b=[o&&f>1?f-1:f,o&&p>1?p-1:p],v=y[0]/b[0],_=y[1]/b[1],x=1/v,C=1/_,E=2*Math.ceil(x)+2,D=2*Math.ceil(C)+2;for(let N=0;N<u;N++){const R=N*a[0];for(let V=0;V<c;V++){const G=R+V*a[1],j=Math.floor(V*x),q=Math.floor(j-E/2);for(let K=0;K<d;K++){const P=G+K*a[2],B=Math.floor(K*C),L=Math.floor(B-D/2);for(let H=0;H<h;H++){let se=0;for(let ie=0;ie<E;ie++){const he=ie+q;if(he<0||he>=f)continue;const de=R+he*l[1],fe=he*v;if(V===Math.min(c-1,o?Math.round(fe):Math.floor(fe)))for(let De=0;De<D;De++){const Ce=De+L;if(Ce<0||Ce>=p)continue;const Le=de+Ce*l[2],ke=Ce*_;K===Math.min(d-1,o?Math.round(ke):Math.floor(ke))&&(se+=m[Le+H])}}g[P+H]=se}}}}return e.makeTensorInfo(r.shape,r.dtype,g)}},uve={kernelName:ob,backendName:"cpu",kernelFunc:function lve(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{dims:i}=s;Me(r,"reverse");const o=r.shape.length,a=mt(i,r.shape);if(0===o)return Ro({inputs:{x:r},backend:e});const l=new ts(r.shape,r.dtype),u=e.bufferSync(r);for(let c=0;c<l.size;c++){const d=l.indexToLoc(c),h=d.slice();a.forEach(f=>h[f]=r.shape[f]-1-h[f]),l.set(u.get(...h),...d)}return e.makeTensorInfo(l.shape,l.dtype,l.values)}},cve={kernelName:YS,backendName:"cpu",kernelFunc:({inputs:n,attrs:t,backend:e})=>{const{image:s}=n,{radians:r,fillValue:i,center:o}=t,a=e,l=Ds(s.dtype,X(s.shape)),[u,c,d,h]=s.shape,[f,p]=kE(o,c,d),m=Math.sin(r),y=Math.cos(r),b=a.data.get(s.dataId).values;for(let _=0;_<u;_++){const x=_*d*c*h;for(let C=0;C<c;C++){const E=C*(d*h);for(let D=0;D<d;D++){const N=D*h;for(let R=0;R<h;R++){const V=[u,C,D,R],G=V[2],j=V[1];let q=(G-f)*y-(j-p)*m,K=(G-f)*m+(j-p)*y;q=Math.round(q+f),K=Math.round(K+p);let P=i;"number"!=typeof i&&(P=3===R?255:i[R]),q>=0&&q<d&&K>=0&&K<c&&(P=b[x+K*(d*h)+q*h+R]),l[x+E+N+R]=P}}}}return{dataId:a.write(l,s.shape,s.dtype),shape:s.shape,dtype:s.dtype}}},dve=Wt(Pf,n=>{const t=Math.floor(n);return n-t<.5?Math.floor(n):n-t>.5?Math.ceil(n):t%2==0?t:t+1}),hve={kernelName:Pf,backendName:"cpu",kernelFunc:dve},D3=Ao(n=>1/Math.sqrt(n)),fve=ul(Lf,D3),pve={kernelName:Lf,backendName:"cpu",kernelFunc:fve};function _u(n,t,e,s,r,i,o,a,l,u){const c=[s/r,r],d=n.values,h=t.values;if(0===s)return dt(e,t.dtype);const f=l instanceof ts?l:dt(c,t.dtype);"string"==typeof l||"number"==typeof l?f.values.fill(l):"boolean"==typeof l&&f.values.fill(+l);for(let p=0;p<i;p++){const g=[];let m=0;for(let y=0;y<o;y++){const b=d[p*o+y];g.push(b),m+=b*a[y]}if(m<0||m>=s/r)throw new Error(`Invalid indices: ${g} does not index into ${e}`);for(let y=0;y<r;y++)u?f.values[m*r+y]+=h[p*r+y]:f.values[m*r+y]=0===t.rank?h[0]:h[p*r+y]}return f}const gve={kernelName:FS,backendName:"cpu",kernelFunc:function mve(n){const{inputs:t,backend:e,attrs:s}=n,{indices:r,updates:i}=t,{shape:o}=s,{sliceRank:a,numUpdates:l,sliceSize:u,strides:c,outputSize:d}=uu(0,r,o),g=_u(e.bufferSync(r),e.bufferSync(i),o,d,u,l,a,c,0,!0);return e.makeTensorInfo(o,g.dtype,g.values)}};function yve(n,t){let e=0,s=n.length,r=0;for(;e<s;)r=Math.floor((e+s)/2),n[r]<t?e=r+1:s=r;return s}function bve(n,t){let e=0,s=n.length,r=0;for(;e<s;)r=Math.floor((e+s)/2),n[r]<=t?e=r+1:s=r;return s}const wve={kernelName:$S,backendName:"cpu",kernelFunc:function _ve(n){const{inputs:t,backend:e,attrs:s}=n,{sortedSequence:r,values:i}=t,{side:o}=s,u=function vve(n,t,e,s,r,i){const o=Fn("int32",e*r);for(let a=0;a<e;++a){const l=n.slice(a*s,(a+1)*s),u=a*r;for(let c=0;c<r;++c)o[u+c]="left"===i?yve(l,t[c+u]):bve(l,t[c+u])}return o}(e.data.get(r.dataId).values,e.data.get(i.dataId).values,r.shape[0],r.shape[1],i.shape[1],o);return e.makeTensorInfo(i.shape,"int32",u)}},Cve={kernelName:ab,backendName:"cpu",kernelFunc:function xve(n){const{inputs:t,backend:e}=n,{condition:s,t:r,e:i}=t;Me([s,r,i],"select");const o=s.shape.length,a=e.data.get(s.dataId).values,l=e.data.get(r.dataId).values,u=e.data.get(i.dataId).values,c=Ir(r.dtype,i.dtype),d=Vs(X(r.shape),c);let h=0;const f=0===o||o>1||1===r.shape.length?1:X(r.shape.slice(1));for(let p=0;p<a.length;p++)for(let g=0;g<f;g++)d[h++]=1===a[p]?l[p]:u[p];return e.makeTensorInfo(r.shape,c,d)}},Sve=nv,Ive=sv,Eve=Wt(Vf,n=>n>=0?Ive*n:Sve*(Math.exp(n)-1)),Dve={kernelName:Vf,backendName:"cpu",kernelFunc:Eve},Tve=Wt(Uf,n=>n<0?-1:n>0?1:0),Nve={kernelName:Uf,backendName:"cpu",kernelFunc:Tve},kve=Wt(Bf,n=>Math.sin(n)),Ave={kernelName:Bf,backendName:"cpu",kernelFunc:kve},Rve=Wt(zf,n=>Math.sinh(n)),Mve={kernelName:zf,backendName:"cpu",kernelFunc:Rve},T3=Math.log(1.1920928955078125e-7)+2,Fve=Wt(Gf,n=>{const t=n>-T3,e=n<T3,s=Math.exp(n);let r;return r=e?s:t?n:Math.log(1+s),r}),Ove={kernelName:Gf,backendName:"cpu",kernelFunc:Fve},Pve={kernelName:cb,backendName:"cpu",kernelFunc:function $ve(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{blockShape:i,paddings:o}=s;Me([r],"spaceToBatchND");const a=X(i),l=[[0,0]];l.push(...o);for(let C=1+i.length;C<r.shape.length;++C)l.push([0,0]);const u=y3.kernelFunc({inputs:{x:r},backend:e,attrs:{paddings:l,constantValue:0}}),c=yp(u.shape,i,a,!1),d=bp(c.length,i.length,!1),h=vp(u.shape,i,a,!1),g=rn({inputs:{x:u},backend:e,attrs:{shape:c}}),b=dr({inputs:{x:g},backend:e,attrs:{perm:d}}),x=rn({inputs:{x:b},backend:e,attrs:{shape:h}});return e.disposeIntermediateTensorInfo(u),e.disposeIntermediateTensorInfo(g),e.disposeIntermediateTensorInfo(b),x}};function N3(n,t,e,s,r,i,o){const a=t[0],l=i[0],u=new Array(l),c=new Array(a),d=t[1];if(0===l){if(0!==a)throw new Error(cV(a));return[Fn(e,0),[0,d],Fn(r,0),u,c]}let h=!0,f=0;const p=new Array(l).fill(0);for(let m=0;m<a;++m){const y=n[m*d];if(y<0)throw new Error(dV(m,y));if(y>=l)throw new Error(hV(m,y,l));++p[y],h=h&&y>=f,f=y}let g=!0;for(let m=0;m<l;++m){const y=0===p[m];u[m]=y,g=g&&!y,p[m]=Math.max(p[m],1),m>0&&(p[m]+=p[m-1])}if(g&&h){const m=n,y=s;for(let b=0;b<a;++b)c[b]=b;return[m,[a,d],y,u,c]}{const m=p[l-1],y=Fn(e,m*d),b=Fn(r,m),v=new Array(l).fill(0);for(let _=0;_<a;++_){const x=n[_*d],E=(0===x?0:p[x-1])+v[x];v[x]++;for(let D=0;D<d;++D)y[E*d+D]=n[_*d+D];b[E]=s[_],c[_]=E}for(let _=0;_<l;++_)if(0===v[_]){const C=0===_?0:p[_-1];y[C*d+0]=_;for(let E=1;E<d;++E)y[C*d+E]=0;b[C]=o}return[y,[m,d],b,u,c]}}const Vve={kernelName:PS,backendName:"cpu",kernelFunc:function Lve(n){const{inputs:t,backend:e}=n,{indices:s,values:r,denseShape:i,defaultValue:o}=t;if(1!==i.shape.length)throw new Error(`Dense shape must be a vector, saw:\n        ${i.shape}`);if(2!==s.shape.length)throw new Error(`Indices must be a matrix, saw:\n        ${s.shape}`);if(1!==r.shape.length)throw new Error(`Values must be a vector, saw:\n        ${r.shape}`);if(0!==o.shape.length)throw new Error(`Default value must be a scalar, saw:\n        ${o.shape}`);const a=e.data.get(s.dataId).values,l=e.data.get(r.dataId).values,u=e.data.get(i.dataId).values,c=e.data.get(o.dataId).values[0],[d,h,f,p,g]=N3(a,s.shape,s.dtype,l,r.dtype,u,c);return[e.makeTensorInfo(h,s.dtype,d),e.makeTensorInfo([h[0]],r.dtype,f),e.makeTensorInfo([p.length],"bool",new Uint8Array(p.map(m=>Number(m)))),e.makeTensorInfo([g.length],s.dtype,new Int32Array(g))]}};function k3(n,t,e,s,r){const i=X(s),o=t[0],a=r.length,l=[];let u=1,c=-1;for(let m=0;m<a;++m){const y=r[m];if(-1===y){if(-1!==c)throw new Error(fV(c,m));c=m,l.push(1)}else{if(y<0)throw new Error(pV(m,y));u*=y,l.push(y)}}if(-1!==c){if(u<=0)throw new Error("reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero");const m=Math.trunc(i/u);if(u*m!==i)throw new Error(gV(s,l));l[c]=m}if(X(l)!==i)throw new Error(yV(s,l));const h=s.length,f=[];if(h>0){f[h-1]=1;for(let m=h-2;m>=0;--m)f[m]=f[m+1]*s[m+1]}const p=[];if(a>0){p[a-1]=1;for(let m=a-2;m>=0;--m)p[m]=p[m+1]*l[m+1]}const g=Fn(e,o*a);for(let m=0;m<o;++m){let y=0;for(let b=0;b<h;++b)y+=n[m*h+b]*f[b];for(let b=0;b<a;++b)g[m*a+b]=Math.trunc(y/p[b]),y%=p[b]}return[g,[o,a],l]}const zve={kernelName:LS,backendName:"cpu",kernelFunc:function Bve(n){const{inputs:t,backend:e}=n,{inputIndices:s,inputShape:r,newShape:i}=t;if(2!==s.shape.length)throw new Error(`Input indices should be a matrix but received shape\n        ${s.shape}`);if(1!==r.shape.length)throw new Error(`Input shape should be a vector but received shape\n        ${r.shape}`);if(1!==i.shape.length)throw new Error(`Target shape should be a vector but received shape ${i.shape}`);const o=Array.from(e.data.get(r.dataId).values),a=e.data.get(s.dataId).values,l=Array.from(e.data.get(i.dataId).values),[u,c,d]=k3(a,s.shape,s.dtype,o,l);return[e.makeTensorInfo(c,s.dtype,u),e.makeTensorInfo([d.length],i.dtype,new Int32Array(d))]}};function gT(n,t,e,s,r,i=!1,o=0){const a=s.length,l=[t[0],n.length/t[0]],u=l[1],d=a>0?r[a-1]+1:0;if(d<0)throw new Error("segment ids must be >= 0");const h=t.slice();h[0]=d;const p=Fn(e,h.reduce((v,_)=>v*_,1));if(0===a)return d>0&&p.fill(o),[p,h];if(d<=0)throw new Error("segment ids must be >= 0");let g=0,m=1,y=0,b=r[g];for(;;){let v=0;if(m<a){if(v=r[m],b===v){++m;continue}if(b>=v)throw new Error("segment ids are not increasing")}if(b<0||b>=d)throw new Error(vV(b,d));b>y&&p.fill(o,y*u,b*u);for(let _=g;_<m;++_){const x=s[_];if(x<0||x>=l[0])throw new Error(_V(_,s[_],l[0]));for(let C=0;C<u;C++)p[b*u+C]+=n[x*u+C]}if(i)for(let _=0;_<u;_++)p[b*u+_]/=m-g;if(g=m,++m,y=b+1,b=v,m>a)break}return y<d&&p.fill(o,y*u,d*u),[p,h]}const Wve={kernelName:VS,backendName:"cpu",kernelFunc:function Uve(n){const{inputs:t,backend:e}=n,{data:s,indices:r,segmentIds:i}=t;if(s.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==r.shape.length)throw new Error(`Indices should be a vector but received shape\n          ${r.shape}`);if(1!==i.shape.length)throw new Error(`Segment ids should be a vector but received shape\n          ${i.shape}`);if(r.shape[0]!==i.shape[0])throw new Error("segmentIds and indices should have same size.");const o=e.data.get(s.dataId).values,a=e.data.get(r.dataId).values,l=e.data.get(i.dataId).values,[u,c]=gT(o,s.shape,s.dtype,a,l,!0);return e.makeTensorInfo(c,s.dtype,u)}},Hve={kernelName:BS,backendName:"cpu",kernelFunc:function Gve(n){const{inputs:t,backend:e}=n,{data:s,indices:r,segmentIds:i}=t;if(s.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==r.shape.length)throw new Error(`Indices should be a vector but received shape\n         ${r.shape}`);if(1!==i.shape.length)throw new Error(`Segment ids should be a vector but received shape\n         ${i.shape}`);if(r.shape[0]!==i.shape[0])throw new Error("segmentIds and indices should have same size.");const o=e.data.get(s.dataId).values,a=e.data.get(r.dataId).values,l=e.data.get(i.dataId).values,[u,c]=gT(o,s.shape,s.dtype,a,l);return e.makeTensorInfo(c,s.dtype,u)}},qve={kernelName:zS,backendName:"cpu",kernelFunc:function jve(n){const{inputs:t,backend:e,attrs:s}=n,{sparseIndices:r,sparseValues:i,defaultValue:o}=t,{outputShape:a}=s,{sliceRank:l,numUpdates:u,sliceSize:c,strides:d,outputSize:h}=uu(0,r,a),f=!1,p=e.bufferSync(r);let g;switch(i.dtype){case"bool":g=_u(p,e.bufferSync(i),a,h,c,u,l,d,!!e.data.get(o.dataId).values[0],f);break;case"float32":case"int32":g=_u(p,e.bufferSync(i),a,h,c,u,l,d,e.data.get(o.dataId).values[0],f);break;case"string":g=_u(p,e.bufferSync(i),a,h,c,u,l,d,La(e.data.get(o.dataId).values[0]),f);break;default:throw new Error(`Unsupported type ${i.dtype}`)}return e.makeTensorInfo(a,g.dtype,g.values)}},Xve={kernelName:db,backendName:"cpu",kernelFunc:function Kve(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{numOrSizeSplits:i,axis:o}=s,a=mt(o,r.shape)[0],l=qE(r,i,a),u=new Array(r.shape.length).fill(0),c=r.shape.slice();return l.map(d=>{const h=[...c];h[a]=d;const f=vu({inputs:{x:r},backend:e,attrs:{begin:u,size:h}});return u[a]+=d,f})}},Yve=Ao(n=>Math.sqrt(n)),Zve=Wt(Hf,n=>Math.sqrt(n)),Qve={kernelName:Hf,backendName:"cpu",kernelFunc:Zve},Jve={kernelName:US,backendName:"cpu",kernelFunc:({inputs:n,backend:t})=>{const{x:e}=n,s=t;Me(e,"square");const r=s.data.get(e.dataId).values,i=new Float32Array(r.length);for(let a=0;a<r.length;++a){const l=r[a];i[a]=l*l}return{dataId:s.write(i,e.shape,e.dtype),shape:e.shape,dtype:e.dtype}}},e_e=Ln((n,t)=>{const e=n-t;return e*e}),t_e=us(jf,e_e),n_e={kernelName:jf,backendName:"cpu",kernelFunc:t_e},A3=Ao((n,t)=>{const{pattern:e,replaceGlobal:s,rewrite:r}=t;return n.replace(new RegExp(e,s?"g":""),r)}),s_e=ul(fb,A3),r_e={kernelName:fb,backendName:"cpu",kernelFunc:s_e},i_e=Wt(Zf,(n,t)=>{const e=t;return isNaN(n)?NaN:n>0?1:e.alpha}),o_e={kernelName:Zf,backendName:"cpu",kernelFunc:i_e};function R3(n,t,e,s){const r=dt(n,t.dtype);for(let i=0;i<r.size;i++){const o=r.indexToLoc(i),a=new Array(o.length);for(let l=0;l<a.length;l++)a[l]=o[l]*e[l]+s[l];r.set(t.get(...a),...o)}return r}const l_e={kernelName:WS,backendName:"cpu",kernelFunc:function a_e(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{begin:i,end:o,strides:a,beginMask:l,endMask:u,ellipsisMask:c,newAxisMask:d,shrinkAxisMask:h}=s;Me(r,"stridedSlice");const{finalShapeSparse:f,finalShape:p,isIdentity:g,sliceDim0:m,isSimpleSlice:y,begin:b,end:v,strides:_}=FI(r.shape,i,o,a,l,u,c,d,h);let x;if(g)x=rn({inputs:{x:r},backend:e,attrs:{shape:p}});else if(m||y){S(r.shape.length>=1,()=>`Input must have rank at least 1, got: ${r.shape.length}`);const C=AI(b,v,_),E=vu({inputs:{x:r},backend:e,attrs:{begin:b,size:C}});x=rn({inputs:{x:E},backend:e,attrs:{shape:p}}),e.disposeIntermediateTensorInfo(E)}else{const E=R3(f,e.bufferSync(r),_,b);x=e.makeTensorInfo(p,E.dtype,E.values)}return x}};class u_e{constructor(t,e,s,r,i,o){this.separator=Pa(t),this.nGramWidths=e,this.leftPad=Pa(s),this.rightPad=Pa(r),this.padWidth=i,this.preserveShort=o}getPadWidth(t){return Math.min(this.padWidth<0?t-1:this.padWidth,t-1)}getNumNGrams(t,e){const s=this.getPadWidth(e);return Math.max(0,t+2*s-e+1)}createNGrams(t,e,s,r,i,o){for(let a=0;a<i;++a){const l=this.getPadWidth(o),u=Math.max(0,l-a),c=Math.max(0,l-(i-(a+1))),d=o-(u+c),h=e+(u>0?0:a-l);let f=0;f+=u*this.leftPad.length;for(let b=0;b<d;++b)f+=t[h+b].length;f+=c*this.rightPad.length,f+=(u+c+d-1)*this.separator.length,s[r+a]=new Uint8Array(f);const g=s[r+a];let m=0;const y=b=>b.forEach(v=>g[m++]=v);for(let b=0;b<u;++b)y(this.leftPad),y(this.separator);for(let b=0;b<d-1;++b)y(t[h+b]),y(this.separator);if(d>0){y(t[h+d-1]);for(let b=0;b<c;++b)y(this.separator),y(this.rightPad)}else{for(let b=0;b<c-1;++b)y(this.rightPad),y(this.separator);y(this.rightPad)}}}compute(t,e){const s=t.length,r=e.length;if(r>0){let l=e[0];if(0!==l)throw new Error(`First split value must be 0, got ${l}`);for(let u=1;u<r;++u){let c=e[u]>=l;if(c=c&&e[u]<=s,!c)throw new Error(`Invalid split value ${e[u]}, must be in [${l}, ${s}]`);l=e[u]}if(l!==s)throw new Error(`Last split value must be data size. Expected ${s}, got ${l}`)}const i=r-1,o=Fn("int32",r);if(0===s||0===r){const l=new Array(s);for(let u=0;u<=i;++u)o[u]=0;return[l,o]}o[0]=0;for(let l=1;l<=i;++l){const u=e[l]-e[l-1];let c=0;this.nGramWidths.forEach(d=>{c+=this.getNumNGrams(u,d)}),this.preserveShort&&u>0&&0===c&&(c=1),o[l]=o[l-1]+c}const a=new Array(o[i]);for(let l=0;l<i;++l){const u=e[l];let c=o[l];if(this.nGramWidths.forEach(d=>{const f=this.getNumNGrams(e[l+1]-e[l],d);this.createNGrams(t,u,a,c,f,d),c+=f}),this.preserveShort&&c===o[l]){const d=e[l+1]-e[l];if(0===d)continue;this.createNGrams(t,u,a,c,1,d+2*this.padWidth)}}return[a,o]}}function M3(n,t,e,s,r,i,o,a){return new u_e(e,s,r,i,o,a).compute(n,t)}const d_e={kernelName:GS,backendName:"cpu",kernelFunc:function c_e(n){const{inputs:t,backend:e,attrs:s}=n,{separator:r,nGramWidths:i,leftPad:o,rightPad:a,padWidth:l,preserveShortSequences:u}=s,{data:c,dataSplits:d}=t,h=e.data.get(c.dataId).values,f=e.data.get(d.dataId).values,[p,g]=M3(h,f,r,i,o,a,l,u);return[e.makeTensorInfo([p.length],"string",p),e.makeTensorInfo(d.shape,"int32",g)]}};function h_e(n,t,e,s){if(!n.length)return;if(0===t.length){for(let i=0;i<n.length;++i)s.push(n.subarray(i,i+1));return}if(1===t.length){const i=t[0];let o=n.indexOf(i);for(;-1!==o;){const a=n.subarray(0,o);(!e||0!==a.length)&&s.push(a),o=(n=n.subarray(o+1)).indexOf(i)}return void((!e||0!==n.length)&&s.push(n))}let r=0;for(let i=0;i<n.length+1;i++)if(i===n.length||-1!==t.indexOf(n[i])){const o=n.subarray(r,i);(!e||0!==o.length)&&s.push(o),r=i+1}}function F3(n,t,e){const s=n.length,r=[];let i=0,o=0;const a=new Array(s);for(let h=0;h<s;++h){const f=r.length;h_e(n[h],t,e,r);const p=r.length-f;a[h]=p,i+=p,o=Math.max(o,p)}const l=Fn("int32",2*i),u=new Array(i),c=[s,o];let d=0;for(let h=0;h<s;++h)for(let f=0;f<a[h];++f)l[2*d]=h,l[2*d+1]=f,u[d]=r[d],++d;return[l,u,c]}const p_e={kernelName:HS,backendName:"cpu",kernelFunc:function f_e(n){const{inputs:t,backend:e,attrs:s}=n,{skipEmpty:r}=s,{input:i,delimiter:o}=t;if("string"!==i.dtype)throw new Error("Input must be of datatype string");if(1!==i.shape.length)throw new Error(`Input must be a vector, got shape: ${i.shape}`);if(0!==o.shape.length)throw new Error(`Delimiter must be a scalar, got shape: ${o.shape}`);const a=e.data.get(i.dataId).values,l=e.data.get(o.dataId).values[0],[u,c,d]=F3(a,l,r),h=c.length;return[e.makeTensorInfo([h,2],"int32",u),e.makeTensorInfo([h],"string",c),e.makeTensorInfo([2],"int32",new Int32Array(d))]}};function O3(n,t){const e=Fn("int32",n.length);for(let s=0;s<n.length;++s)e[s]=Qee(n[s]).modulo(t).getLowBitsUnsigned();return e}const g_e={kernelName:jS,backendName:"cpu",kernelFunc:function m_e(n){const{inputs:t,backend:e,attrs:s}=n,{numBuckets:r}=s,{input:i}=t;if("string"!==i.dtype)throw new Error("Input must be of datatype string");if(r<=0)throw new Error("Number of buckets must be at least 1");const a=O3(e.data.get(i.dataId).values,r);return e.makeTensorInfo(i.shape,"int32",a)}},y_e=Wt(Kf,n=>Math.tan(n)),b_e={kernelName:Kf,backendName:"cpu",kernelFunc:y_e},v_e=Wt(Xf,n=>Math.tanh(n));function $3(n,t){const e=new Array(n.rank);for(let r=0;r<e.length;r++)e[r]=n.shape[r]*t[r];const s=dt(e,n.dtype);for(let r=0;r<s.values.length;++r){const i=s.indexToLoc(r),o=new Array(n.rank);for(let l=0;l<o.length;l++)o[l]=i[l]%n.shape[l];const a=n.locToIndex(o);s.values[r]=n.values[a]}return s}const $p=(n,t)=>{const e=t.value-n.value;return 0===e?n.index-t.index:e};function P3(n,t,e=0,s=n.length-1){for(;s>e;){if(s-e>600){const a=s-e+1,l=t-e+1,u=Math.log(a),c=.5*Math.exp(2*u/3),d=.5*Math.sqrt(u*c*(a-c)/a)*Math.sign(l-a/2);P3(n,t,Math.max(e,Math.floor(t-l*c/a+d)),Math.min(s,Math.floor(t+(a-l)*c/a+d)))}const r=n[t];let i=e,o=s;for(Ma(n,e,t),$p(n[s],r)>0&&Ma(n,e,s);i<o;){for(Ma(n,i,o),i++,o--;$p(n[i],r)<0;)i+=1;for(;$p(n[o],r)>0;)o-=1}0===$p(n[e],r)?Ma(n,e,o):(o+=1,Ma(n,o,s)),o<=t&&(e=o+1),t<=o&&(s=o-1)}}function L3(n,t,e,s,r){const i=t[t.length-1],[o,a]=[n.length/i,i],l=Ds(e,o*s),u=Ds("int32",o*s);for(let d=0;d<o;d++){const h=d*a,f=n.subarray(h,h+a);let p=new Array(f.length);f.forEach((b,v)=>p[v]={value:b,index:v}),s<p.length&&(P3(p,s),p=p.slice(0,s)),r&&p.sort($p);const g=d*s,m=l.subarray(g,g+s),y=u.subarray(g,g+s);for(let b=0;b<s;b++)m[b]=p[b].value,y[b]=p[b].index}const c=t.slice();return c[c.length-1]=s,[dt(c,e,l),dt(c,"int32",u)]}function V3(n,t,e){switch(e){case"reflect":return function N_e(n,t){let e=n;if(e<0)if(t<=1)e=0;else{const s=2*t;e<s&&(e=s*Math.trunc(-e/s)+e),e=e<-t?e+s:-e-1}else if(e>t-1)if(t<=1)e=0;else{const s=2*t;e-=s*Math.trunc(e/s),e>=t&&(e=s-e-1)}return Yl(0,e,t-1)}(n,t);case"wrap":return function k_e(n,t){let e=n;return e<0?t<=1?e=0:e+=t*(Math.trunc(-e/(t-1))+1):e>t-1&&(t<=1?e=0:e-=t*Math.trunc(e/(t-1))),Yl(0,e,t-1)}(n,t);case"nearest":return function R_e(n,t){return Yl(0,n,t-1)}(n,t);default:return function A_e(n,t){return n}(n)}}function Pp(n,t,e,s,r,i,o,a,l,u,c){return 0<=a&&a<t&&0<=l&&l<e?n[o*s+a*r+l*i+u]:c}function M_e(n,t,e,s,r,i,o,a,l,u,c){return Pp(n,t,e,s,r,i,o,Math.round(a),Math.round(l),u,c)}function F_e(n,t,e,s,r,i,o,a,l,u,c){const d=Math.floor(a),h=Math.floor(l),f=d+1,p=h+1;return(f-a)*((p-l)*Pp(n,t,e,s,r,i,o,d,h,u,c)+(l-h)*Pp(n,t,e,s,r,i,o,d,p,u,c))+(a-d)*((p-l)*Pp(n,t,e,s,r,i,o,f,h,u,c)+(l-h)*Pp(n,t,e,s,r,i,o,f,p,u,c))}function B3(n,t,e,s){const r=mt(t,e)[0],i=[1,e[0],1];for(let p=0;p<r;p++)i[0]*=e[p];i[1]=e[r];for(let p=r+1;p<e.length;p++)i[2]*=e[p];const o=new Map,a=new Int32Array(e[r]),l=new ts(i,s,n),u=[],c=1===i[0]&&1===i[2];for(let p=0;p<e[r];p++){let g;if(c)g=n[p].toString();else{const y=[];for(let b=0;b<i[0];b++)for(let v=0;v<i[2];v++)y.push(l.get(b,p,v));g=y.join(",")}const m=o.get(g);if(null!=m)a[p]=m;else{const y=o.size;o.set(g,y),a[p]=y,u.push(p)}}const d=i.slice();d[1]=o.size;const h=new ts(d,s);u.forEach((p,g)=>{for(let m=0;m<i[0];m++)for(let y=0;y<i[2];y++)h.set(l.get(m,p,y),m,g,y)});const f=e.slice();return f[r]=d[1],{outputValues:h.values,outputShape:f,indices:a}}const z_e=[Fpe,Ope,Ppe,Vpe,kpe,zpe,Gpe,jpe,Kpe,Ype,Qpe,eme,nme,ime,ame,cme,hme,pme,gme,Rpe,bme,wme,Cme,Eme,Tme,Tpe,kme,Rme,Epe,Mme,Ome,$me,Lme,Bme,Ume,Gme,jme,Kme,Yme,Qme,ege,nge,rge,oge,age,uge,dge,fge,pge,mge,gge,wge,ype,Cge,Sge,Rge,Mge,Fge,$ge,Gge,Hge,qge,Xge,Qge,eye,nye,rye,oye,lye,cye,bpe,hye,Fme,pye,gye,bye,vpe,_ye,xye,Sye,Eye,Tye,Aye,Mye,$ye,Lye,Bye,zye,Wye,Hye,qye,Xye,Zye,Jye,tbe,sbe,ibe,abe,cbe,fbe,bge,mbe,bbe,wbe,Sbe,Ebe,Tbe,kbe,Abe,y3,Obe,wpe,Pbe,Hbe,qbe,Xbe,Zbe,Dpe,hT,Jbe,xpe,Cpe,Ape,tve,sve,ive,ave,uve,cve,hve,pve,gve,wve,Cve,Dve,Ipe,Nve,Ave,Mve,vme,dbe,Ove,Pve,Vve,zve,Wve,Hve,qve,Xve,Qve,Jve,n_e,r_e,o_e,l_e,d_e,p_e,g_e,Vge,vge,b_e,{kernelName:Xf,backendName:"cpu",kernelFunc:v_e},{kernelName:OS,backendName:"cpu",kernelFunc:function w_e(n){const{inputs:t,backend:e}=n,{tensor:s,indices:r,updates:i}=t,{sliceRank:o,numUpdates:a,sliceSize:l,strides:u,outputSize:c}=uu(0,r,s.shape),h=e.bufferSync(r),f=e.bufferSync(i),p=e.bufferSync(s),g=_u(h,f,s.shape,c,l,a,o,u,p,!1);return e.makeTensorInfo(s.shape,g.dtype,g.values)}},{kernelName:Yf,backendName:"cpu",kernelFunc:function C_e(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{reps:i}=s;Me(r,"tile");const o=$3(e.bufferSync(r),i);return e.makeTensorInfo(o.shape,o.dtype,o.values)}},{kernelName:qS,backendName:"cpu",kernelFunc:function I_e(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{k:i,sorted:o}=s;Me(r,"topk");const a=e.data.get(r.dataId).values,[l,u]=L3(a,r.shape,r.dtype,i,o);return[e.makeTensorInfo(l.shape,l.dtype,l.values),e.makeTensorInfo(u.shape,u.dtype,u.values)]}},{kernelName:KS,backendName:"cpu",kernelFunc:function D_e(n){const{inputs:t,attrs:e,backend:s}=n,{image:r,transforms:i}=t,{interpolation:o,fillMode:a,fillValue:l,outputShape:u}=e,[c,d,h,f]=r.shape,[p,g]=u??[d,h],m=[c,p,g,f],y=Be(r.shape),b=y[0],v=y[1],_=y[2],x=Be(m),C=x[0],E=x[1],D=x[2],N=Ds(r.dtype,X(m));N.fill(l);const R=s.data.get(r.dataId).values,V=s.data.get(i.dataId).values;for(let j=0;j<c;++j){const q=1===i.shape[0]?V:V.subarray(8*j,8*j+8);for(let K=0;K<p;++K)for(let P=0;P<g;++P)for(let B=0;B<f;++B){let L;const H=q[6]*P+q[7]*K+1;if(0===H)continue;const ie=(q[3]*P+q[4]*K+q[5])/H,he=V3((q[0]*P+q[1]*K+q[2])/H,h,a),de=V3(ie,d,a);switch(o){case"nearest":L=M_e(R,d,h,b,v,_,j,de,he,B,l);break;case"bilinear":L=F_e(R,d,h,b,v,_,j,de,he,B,l);break;default:throw new Error(`Error in Transform: Expect 'nearest' or 'bilinear', but got ${o}`)}N[j*C+K*E+P*D+B]=L}return s.makeTensorInfo(m,r.dtype,N)}return{dataId:s.write(N,m,r.dtype),shape:r.shape,dtype:r.dtype}}},Upe,{kernelName:XS,backendName:"cpu",kernelFunc:function O_e(n){const{inputs:t,attrs:e,backend:s}=n,{axis:r}=e,{x:i}=t;Me(i,"unique");const o=s.data.get(i.dataId).values,{outputValues:a,outputShape:l,indices:u}=B3(o,r,i.shape,i.dtype);return[s.makeTensorInfo(l,i.dtype,a),s.makeTensorInfo([u.length],"int32",u)]}},{kernelName:pb,backendName:"cpu",kernelFunc:function P_e(n){const{inputs:t,backend:e,attrs:s}=n,{value:r}=t;let{axis:i}=s;i<0&&(i+=r.shape.length);const o=r.shape.length,a=r.shape[i],l=new Array(o-1);let u=0;for(let f=0;f<o;f++)f!==i&&(l[u++]=r.shape[f]);const c=new Array(o).fill(0),d=r.shape.slice();d[i]=1;const h=new Array(a);for(let f=0;f<h.length;f++){c[i]=f;const p=vu({inputs:{x:r},backend:e,attrs:{begin:c,size:d}});h[f]=rn({inputs:{x:p},backend:e,attrs:{shape:l}}),e.disposeIntermediateTensorInfo(p)}return h}},{kernelName:mb,backendName:"cpu",kernelFunc:function V_e(n){const{inputs:t,backend:e,attrs:s}=n,{x:r,segmentIds:i}=t,{numSegments:o}=s;Me(r,"unsortedSegmentSum");const u=[],c=[],d=r.shape.length-i.shape.length;let h=i;for(let p=0;p<d;++p){const g=Lv({inputs:{input:h},backend:e,attrs:{dim:p+1}});h=g,c.push(g)}for(let p=0;p<o;++p){const g=$a(p,"int32"),m=e.makeTensorInfo([],"int32",g),y=jz({inputs:{a:m,b:h},backend:e}),b=cl({inputs:{x:y},backend:e,attrs:{dtype:"float32"}}),v=Pv({inputs:{a:b,b:r},backend:e}),_=Op({inputs:{x:v},backend:e,attrs:{axis:0,keepDims:!1}});u.push(_),c.push(m),c.push(y),c.push(b),c.push(v),c.push(_)}const f=g3({inputs:u,backend:e,attrs:{axis:0}});return c.forEach(p=>e.disposeIntermediateTensorInfo(p)),f}},Nbe];for(const n of z_e)QS(n);const dl={},zv={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0};function Yi(n,t){if(!(n in dl)||null!=t){const s=function G_e(n,t){if(1!==n&&2!==n)throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");const e=t??function W_e(n){if(!W().getBool("IS_SAFARI")&&typeof OffscreenCanvas<"u"&&2===n)return new OffscreenCanvas(300,150);if(typeof document<"u")return document.createElement("canvas");throw new Error("Cannot create a canvas in this context")}(n);return e.addEventListener("webglcontextlost",s=>{s.preventDefault(),delete dl[n]},!1),W().getBool("SOFTWARE_WEBGL_ENABLED")&&(zv.failIfMajorPerformanceCaveat=!1),1===n?e.getContext("webgl",zv)||e.getContext("experimental-webgl",zv):e.getContext("webgl2",zv)}(n,t);if(null===s)return console.log("Could not get context for WebGL version",n),null;dl[n]=s}const e=dl[n];return null==e||e.isContextLost()?(delete dl[n],Yi(n)):(e.disable(e.DEPTH_TEST),e.disable(e.STENCIL_TEST),e.disable(e.BLEND),e.disable(e.DITHER),e.disable(e.POLYGON_OFFSET_FILL),e.disable(e.SAMPLE_COVERAGE),e.enable(e.SCISSOR_TEST),e.enable(e.CULL_FACE),e.cullFace(e.BACK),dl[n])}var Mo=(()=>((Mo=Mo||{})[Mo.DENSE=0]="DENSE",Mo[Mo.SHARED_BATCH=1]="SHARED_BATCH",Mo))(),Vn=(()=>((Vn=Vn||{})[Vn.RENDER=0]="RENDER",Vn[Vn.UPLOAD=1]="UPLOAD",Vn[Vn.PIXELS=2]="PIXELS",Vn[Vn.DOWNLOAD=3]="DOWNLOAD",Vn))(),Kt=(()=>((Kt=Kt||{})[Kt.UNPACKED_FLOAT16=0]="UNPACKED_FLOAT16",Kt[Kt.UNPACKED_FLOAT32=1]="UNPACKED_FLOAT32",Kt[Kt.PACKED_4X1_UNSIGNED_BYTE=2]="PACKED_4X1_UNSIGNED_BYTE",Kt[Kt.PACKED_2X2_FLOAT32=3]="PACKED_2X2_FLOAT32",Kt[Kt.PACKED_2X2_FLOAT16=4]="PACKED_2X2_FLOAT16",Kt))();function Lp(n,t){return[t,n]}function Uv(n){const t=X(n);return PC(Math.ceil(t/4))}function bd(n,t){return[Math.max(1,Math.ceil(t/2)),Math.max(1,Math.ceil(n/2))]}function yT(n,t){const e=n;let s,r,i,o,a,l,u,c,d,h;return 2===W().getNumber("WEBGL_VERSION")?(s=e.R32F,r=e.R16F,i=e.RGBA16F,o=e.RGBA32F,a=e.RED,u=4,c=1,d=e.HALF_FLOAT,h=e.FLOAT,l=e.RGBA8):(s=n.RGBA,r=n.RGBA,i=n.RGBA,o=e.RGBA,a=n.RGBA,u=4,c=4,d=null!=t?t.HALF_FLOAT_OES:null,h=n.FLOAT,l=n.RGBA),{internalFormatFloat:s,internalFormatHalfFloat:r,internalFormatPackedHalfFloat:i,internalFormatPackedFloat:o,textureFormatFloat:a,downloadTextureFormat:l,downloadUnpackNumChannels:u,defaultNumChannels:c,textureTypeHalfFloat:d,textureTypeFloat:h}}function ve(n,t){const e=t();return W().getBool("DEBUG")&&function q_e(n){const t=n.getError();if(t!==n.NO_ERROR)throw new Error("WebGL Error: "+function Z_e(n,t){switch(t){case n.NO_ERROR:return"NO_ERROR";case n.INVALID_ENUM:return"INVALID_ENUM";case n.INVALID_VALUE:return"INVALID_VALUE";case n.INVALID_OPERATION:return"INVALID_OPERATION";case n.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case n.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case n.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return`Unknown error code ${t}`}}(n,t))}(n),e}function Y_e(n){return!!(W().getBool("WEBGL_RENDER_FLOAT32_ENABLED")||0===n||5.96e-8<Math.abs(n)&&Math.abs(n)<65504)}function Wv(n,t){return ga(n,()=>n.getExtension(t),'Extension "'+t+'" not supported on this browser.')}const ewe=/ERROR: [0-9]+:([0-9]+):/g;function z3(n,t){const e=ewe.exec(t);if(null==e)return console.log(`Couldn't parse line number in error: ${t}`),void console.log(n);const s=+e[1],r=n.split("\n"),i=r.length.toString().length+2,o=r.map((d,h)=>Lc((h+1).toString(),i)+d);let a=0;for(let d=0;d<o.length;d++)a=Math.max(o[d].length,a);const l=o.slice(0,s-1),u=o.slice(s-1,s),c=o.slice(s);console.log(l.join("\n")),console.log(t.split("\n")[0]),console.log(`%c ${Lc(u[0],a)}`,"border:1px solid red; background-color:#e3d2d2; color:#a61717"),console.log(c.join("\n"))}function bT(n,t){if(ve(n,()=>n.validateProgram(t)),!1===n.getProgramParameter(t,n.VALIDATE_STATUS))throw console.log(n.getProgramInfoLog(t)),new Error("Shader program validation failed.")}function U3(n,t,e,s,r,i,o){const a=n.getAttribLocation(t,e);return-1!==a&&(ve(n,()=>n.bindBuffer(n.ARRAY_BUFFER,s)),ve(n,()=>n.vertexAttribPointer(a,r,n.FLOAT,!1,i,o)),ve(n,()=>n.enableVertexAttribArray(a)),!0)}function dwe(n,t,e,s){ve(n,()=>function lwe(n,t,e){(function G3(n,t){const e=n.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,s=t+n.TEXTURE0;if(s<n.TEXTURE0||s>e)throw new Error(`textureUnit must be in [gl.TEXTURE0, gl.TEXTURE${e}].`)})(n,e),ve(n,()=>n.activeTexture(n.TEXTURE0+e)),ve(n,()=>n.bindTexture(n.TEXTURE_2D,t))}(n,t,s)),ve(n,()=>n.uniform1i(e,s))}function vT(n,t,e){ve(n,()=>n.bindFramebuffer(n.FRAMEBUFFER,e)),ve(n,()=>n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,t,0))}function W3(n,t){ve(n,()=>n.bindFramebuffer(n.FRAMEBUFFER,t)),ve(n,()=>n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,null,0))}function Gv(n){const t=n.checkFramebufferStatus(n.FRAMEBUFFER);if(t!==n.FRAMEBUFFER_COMPLETE)throw new Error("Error binding framebuffer: "+function hwe(n,t){switch(t){case n.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case n.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case n.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case n.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return`unknown error ${t}`}}(n,t))}function ga(n,t,e){const s=ve(n,()=>t());if(null==s)throw new Error(e);return s}function vd(n,t=2){return X(n.slice(0,n.length-t))}function _d(n){if(0===n.length)throw Error("Cannot get rows and columns of an empty shape array.");return[n.length>1?n[n.length-2]:1,n[n.length-1]]}function Hv(n){let t=[1,1,1];return 0===n.length||1===n.length&&1===n[0]||(t=[vd(n),..._d(n)]),t}function jv(n){return n%2==0}function qv(n,t){if(wt(n=n.slice(-2),t=t.slice(-2))||!n.length||!t.length||0===n[0]||0===n[1]||0===t[0]||0===t[1])return!0;if(n.length!==t.length){const e=n[n.length-1],s=t[t.length-1];if(e===s||jv(e)&&jv(s)&&(1===n[0]||1===t[0]))return!0}return n[1]===t[1]&&jv(n[0])&&jv(t[0])}let Kv,Xv;function Si(n,t){return null!=n.getExtension(t)}function H3(n){try{if(null!=Yi(n))return!0}catch(t){return console.log("Error when getting WebGL context: ",t),!1}return!1}function _T(n){const t=yT(n),e=n.createTexture();n.bindTexture(n.TEXTURE_2D,e),n.texImage2D(n.TEXTURE_2D,0,t.internalFormatFloat,1,1,0,t.textureFormatFloat,t.textureTypeFloat,null);const i=n.createFramebuffer();n.bindFramebuffer(n.FRAMEBUFFER,i),n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,e,0);const o=n.checkFramebufferStatus(n.FRAMEBUFFER)===n.FRAMEBUFFER_COMPLETE;return n.bindTexture(n.TEXTURE_2D,null),n.bindFramebuffer(n.FRAMEBUFFER,null),n.deleteTexture(e),n.deleteFramebuffer(i),o}function Vp(n,t){Array.isArray(n)||(n=[n]),n.forEach(e=>{null!=e&&S("complex64"!==e.dtype,()=>`${t} does not support complex64 tensors in the WebGL backend.`)})}const Oe=W();function Ys(){let n,t,e,s,r,i,o,a,l,u;return 2===W().getNumber("WEBGL_VERSION")?(n="#version 300 es",t="in",e="out",s="in",r="texture",i="outputColor",o="out vec4 outputColor;",a=W().getBool("WEBGL2_ISNAN_CUSTOM")?"\n      bool isnan_custom(float val) {\n        uint floatToUint = floatBitsToUint(val);\n        return (floatToUint & 0x7fffffffu) > 0x7f800000u;\n      }\n\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan_custom(val.x),\n          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));\n      }\n\n      #define isnan(value) isnan_custom(value)\n    ":"",l="",u="\n      #define round(value) newRound(value)\n      int newRound(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 newRound(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "):(n="",t="attribute",e="varying",s="varying",r="texture2D",i="gl_FragColor",o="",a="\n      #define isnan(value) isnan_custom(value)\n      bool isnan_custom(float val) {\n        return (val > 0. || val < 1. || val == 0.) ? false : true;\n      }\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));\n      }\n    ",l="\n      uniform float INFINITY;\n\n      bool isinf(float val) {\n        return abs(val) == INFINITY;\n      }\n      bvec4 isinf(vec4 val) {\n        return equal(abs(val), vec4(INFINITY));\n      }\n    ",u="\n      int round(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 round(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "),{version:n,attribute:t,varyingVs:e,varyingFs:s,texture2D:r,output:i,defineOutput:o,defineSpecialNaN:a,defineSpecialInf:l,defineRound:u}}function wu(n,t,e="index"){const s=Be(t);return s.map((r,i)=>`int ${n[i]} = ${e} / ${r}; ${i===s.length-1?`int ${n[i+1]} = ${e} - ${n[i]} * ${r}`:`index -= ${n[i]} * ${r}`};`).join("")}function Yv(n,t,e="index"){const s=Be(t);return s.map((r,i)=>`int ${n[i]} = ${e} / outShapeStrides[${i}]; ${i===s.length-1?`int ${n[i+1]} = ${e} - ${n[i]} * outShapeStrides[${i}]`:`index -= ${n[i]} * outShapeStrides[${i}]`};`).join("")}function wT(n){const t=Be(n).map(e=>e.toString());return`\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * ${t[0]} + coords.y * ${t[1]} + coords.z;\n  }\n`}Oe.registerFlag("HAS_WEBGL",()=>Oe.getNumber("WEBGL_VERSION")>0),Oe.registerFlag("WEBGL_VERSION",()=>H3(2)?2:H3(1)?1:0),Oe.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS",()=>!1),Oe.registerFlag("WEBGL_BUFFER_SUPPORTED",()=>2===Oe.get("WEBGL_VERSION")),Oe.registerFlag("WEBGL_CPU_FORWARD",()=>!0),Oe.registerFlag("WEBGL_FORCE_F16_TEXTURES",()=>!1),Oe.registerFlag("WEBGL_PACK",()=>Oe.getBool("HAS_WEBGL")),Oe.registerFlag("WEBGL_PACK_NORMALIZATION",()=>Oe.getBool("WEBGL_PACK")),Oe.registerFlag("WEBGL_PACK_CLIP",()=>Oe.getBool("WEBGL_PACK")),Oe.registerFlag("WEBGL_PACK_DEPTHWISECONV",()=>Oe.getBool("WEBGL_PACK")),Oe.registerFlag("WEBGL_PACK_BINARY_OPERATIONS",()=>Oe.getBool("WEBGL_PACK")),Oe.registerFlag("WEBGL_PACK_UNARY_OPERATIONS",()=>Oe.getBool("WEBGL_PACK")),Oe.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS",()=>Oe.getBool("WEBGL_PACK")),Oe.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS",()=>Oe.getBool("WEBGL_PACK")),Oe.registerFlag("WEBGL_PACK_REDUCE",()=>Oe.getBool("WEBGL_PACK")),Oe.registerFlag("WEBGL_LAZILY_UNPACK",()=>Oe.getBool("WEBGL_PACK")),Oe.registerFlag("WEBGL_CONV_IM2COL",()=>Oe.getBool("WEBGL_PACK")),Oe.registerFlag("WEBGL_MAX_TEXTURE_SIZE",()=>function pwe(n){if(null==Kv){const t=Yi(n);Kv=t.getParameter(t.MAX_TEXTURE_SIZE)}return Kv}(Oe.getNumber("WEBGL_VERSION"))),Oe.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER",()=>function mwe(n){if(null==Xv){const t=Yi(n);Xv=t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,Xv)}(Oe.getNumber("WEBGL_VERSION"))),Oe.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",()=>{const n=Oe.getNumber("WEBGL_VERSION");return 0===n?0:function gwe(n){if(0===n)return 0;let t;const e=Yi(n);return t=Si(e,"EXT_disjoint_timer_query_webgl2")&&2===n?2:Si(e,"EXT_disjoint_timer_query")?1:0,t}(n)}),Oe.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",()=>Oe.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0&&!J2()),Oe.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE",()=>function ywe(n){if(0===n)return!1;const t=Yi(n);if(1===n){if(!Si(t,"OES_texture_float"))return!1}else if(!Si(t,"EXT_color_buffer_float"))return!1;return _T(t)}(Oe.getNumber("WEBGL_VERSION"))),Oe.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED",()=>!Oe.getBool("WEBGL_FORCE_F16_TEXTURES")&&Oe.getBool("WEBGL_RENDER_FLOAT32_CAPABLE")),Oe.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED",()=>function bwe(n){if(0===n)return!1;const t=Yi(n);if(1!==n){if(Si(t,"EXT_color_buffer_float"))return _T(t);const s="EXT_color_buffer_half_float";if(Si(t,s)){const r=t.getExtension(s);return function vwe(n,t){const e=yT(n,t),s=n.createTexture();n.bindTexture(n.TEXTURE_2D,s),n.texImage2D(n.TEXTURE_2D,0,e.internalFormatHalfFloat,1,1,0,e.textureFormatFloat,e.textureTypeHalfFloat,null);const o=n.createFramebuffer();n.bindFramebuffer(n.FRAMEBUFFER,o),n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,s,0);const a=n.checkFramebufferStatus(n.FRAMEBUFFER)===n.FRAMEBUFFER_COMPLETE;return n.bindTexture(n.TEXTURE_2D,null),n.bindFramebuffer(n.FRAMEBUFFER,null),n.deleteTexture(s),n.deleteFramebuffer(o),a}(t,r)}return!1}return!(!Si(t,"OES_texture_float")||!Si(t,"WEBGL_color_buffer_float"))&&_T(t)}(Oe.getNumber("WEBGL_VERSION"))),Oe.registerFlag("WEBGL_FENCE_API_ENABLED",()=>function _we(n){return 2===n&&null!=Yi(n).fenceSync}(Oe.getNumber("WEBGL_VERSION"))),Oe.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM",()=>Oe.getBool("WEBGL_RENDER_FLOAT32_ENABLED")?4:0),Oe.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD",()=>-1,n=>{if(n<0&&-1!==n)throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never delete) or at least 0, but got ${n}.`)}),Oe.registerFlag("WEBGL_FLUSH_THRESHOLD",()=>J2()?1:-1,n=>{if(n<0&&-1!==n)throw new Error(`WEBGL_FLUSH_THRESHOLD must be -1 (indicating never manual flush) or at least 0, but got ${n}.`)}),Oe.registerFlag("CPU_HANDOFF_SIZE_THRESHOLD",()=>128),Oe.registerFlag("WEBGL_USE_SHAPES_UNIFORMS",()=>!1),Oe.registerFlag("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD",()=>1e5),Oe.registerFlag("TOPK_K_CPU_HANDOFF_THRESHOLD",()=>128),Oe.registerFlag("WEBGL_EXP_CONV",()=>!1),Oe.registerFlag("SOFTWARE_WEBGL_ENABLED",()=>Oe.getBool("IS_TEST")),Oe.registerFlag("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE",()=>1/0),Oe.registerFlag("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE",()=>!1),Oe.registerFlag("WEBGL2_ISNAN_CUSTOM",()=>!1),Oe.registerFlag("ENGINE_COMPILE_ONLY",()=>!1);const j3="\n  const float FLOAT_MAX = 1.70141184e38;\n  const float FLOAT_MIN = 1.17549435e-38;\n\n  lowp vec4 encode_float(highp float v) {\n    if (isnan(v)) {\n      return vec4(255, 255, 255, 255);\n    }\n\n    highp float av = abs(v);\n\n    if(av < FLOAT_MIN) {\n      return vec4(0.0, 0.0, 0.0, 0.0);\n    } else if(v > FLOAT_MAX) {\n      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;\n    } else if(v < -FLOAT_MAX) {\n      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;\n    }\n\n    highp vec4 c = vec4(0,0,0,0);\n\n    highp float e = floor(log2(av));\n    highp float m = exp2(fract(log2(av))) - 1.0;\n\n    c[2] = floor(128.0 * m);\n    m -= c[2] / 128.0;\n    c[1] = floor(32768.0 * m);\n    m -= c[1] / 32768.0;\n    c[0] = floor(8388608.0 * m);\n\n    highp float ebias = e + 127.0;\n    c[3] = floor(ebias / 2.0);\n    ebias -= c[3] * 2.0;\n    c[2] += floor(ebias) * 128.0;\n\n    c[3] += 128.0 * step(0.0, -v);\n\n    return c / 255.0;\n  }\n",{getBroadcastDims:q3}=ht;function Cwe(n,t,e){const s=[];if(n.forEach(f=>{const p=X(f.shapeInfo.logicalShape);if(f.shapeInfo.isUniform?s.push(`uniform float ${f.name}${p>1?`[${p}]`:""};`):(s.push(`uniform sampler2D ${f.name};`),s.push(`uniform int offset${f.name};`)),e.enableShapeUniforms){const{uniformShape:g}=CT(e.packedInputs,f.shapeInfo.logicalShape,f.shapeInfo.texShape);switch(g.length){case 1:s.push(`uniform int ${f.name}Shape;`);break;case 2:s.push(`uniform ivec2 ${f.name}Shape;`);break;case 3:s.push(`uniform ivec3 ${f.name}Shape;`);break;case 4:s.push(`uniform ivec4 ${f.name}Shape;`)}s.push(`uniform ivec2 ${f.name}TexShape;`)}}),e.enableShapeUniforms){switch(t.logicalShape.length){case 1:s.push("uniform int outShape;");break;case 2:s.push("uniform ivec2 outShape;"),s.push("uniform int outShapeStrides;");break;case 3:s.push("uniform ivec3 outShape;"),s.push("uniform ivec2 outShapeStrides;");break;case 4:s.push("uniform ivec4 outShape;"),s.push("uniform ivec3 outShapeStrides;")}s.push("uniform ivec2 outTexShape;")}e.customUniforms&&e.customUniforms.forEach(f=>{s.push(`uniform ${f.type} ${f.name}${f.arrayIndex?`[${f.arrayIndex}]`:""};`)});const r=s.join("\n"),i=n.map(f=>function Swe(n,t,e=!1,s){let r="";r+=e?K3(n,s):wd(n,s);return n.shapeInfo.logicalShape.length<=t.logicalShape.length&&(r+=e?function sxe(n,t){const e=n.name,s=e.charAt(0).toUpperCase()+e.slice(1),r="get"+s+"AtOutCoords",i=n.shapeInfo.logicalShape.length,o=t.logicalShape.length,a=q3(n.shapeInfo.logicalShape,t.logicalShape),l=Xt(o),u=o-i;let c;const d=["x","y","z","w","u","v"];c=0===i?"":o<2&&a.length>=1?"coords = 0;":a.map(b=>`coords.${d[b+u]} = 0;`).join("\n");let h="";h=o<2&&i>0?"coords":n.shapeInfo.logicalShape.map((b,v)=>`coords.${d[v+u]}`).join(", ");let f="return outputValue;";const g=1===X(n.shapeInfo.logicalShape),y=1===X(t.logicalShape);if(1!==i||g||y){if(g&&!y)f=1===o?"\n        return vec4(outputValue.x, outputValue.x, 0., 0.);\n      ":"\n        return vec4(outputValue.x);\n      ";else if(a.length){const b=i-2,v=i-1;a.indexOf(b)>-1&&a.indexOf(v)>-1?f="return vec4(outputValue.x);":a.indexOf(b)>-1?f="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":a.indexOf(v)>-1&&(f="return vec4(outputValue.xx, outputValue.zz);")}}else f="\n      return vec4(outputValue.xy, outputValue.xy);\n    ";return`\n    vec4 ${r}() {\n      ${l} coords = getOutputCoords();\n      ${c}\n      vec4 outputValue = get${s}(${h});\n      ${f}\n    }\n  `}(n,t):function rxe(n,t){const e=n.name,s=e.charAt(0).toUpperCase()+e.slice(1),r="get"+s+"AtOutCoords",a=n.shapeInfo.logicalShape.length,l=t.logicalShape.length;if(!n.shapeInfo.isUniform&&a===l&&null==n.shapeInfo.flatOffset&&wt(n.shapeInfo.texShape,t.texShape))return`\n      float ${r}() {\n        return sampleTexture(${e}, resultUV);\n      }\n    `;const u=Xt(l),c=q3(n.shapeInfo.logicalShape,t.logicalShape),d=l-a;let h;const f=["x","y","z","w","u","v"];h=0===a?"":l<2&&c.length>=1?"coords = 0;":c.map(g=>`coords.${f[g+d]} = 0;`).join("\n");let p="";return p=l<2&&a>0?"coords":n.shapeInfo.logicalShape.map((g,m)=>`coords.${f[m+d]}`).join(", "),`\n    float ${r}() {\n      ${u} coords = getOutputCoords();\n      ${h}\n      return get${s}(${p});\n    }\n  `}(n,t)),r}(f,t,e.packedInputs,e.enableShapeUniforms)).join("\n"),o=t.texShape,a=Ys(),l=function Dwe(n){return`\n    float sampleTexture(sampler2D textureSampler, vec2 uv) {\n      return ${n.texture2D}(textureSampler, uv).r;\n    }\n  `}(a);let u,c,d=function kwe(n){return`${n.version}\n    precision highp float;\n    precision highp int;\n    precision highp sampler2D;\n    ${n.varyingFs} vec2 resultUV;\n    ${n.defineOutput}\n    const vec2 halfCR = vec2(0.5, 0.5);\n\n    struct ivec5\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n    };\n\n    struct ivec6\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n      int v;\n    };\n\n    uniform float NAN;\n    ${n.defineSpecialNaN}\n    ${n.defineSpecialInf}\n    ${n.defineRound}\n\n    int imod(int x, int y) {\n      return x - y * (x / y);\n    }\n\n    int idiv(int a, int b, float sign) {\n      int res = a / b;\n      int mod = imod(a, b);\n      if (sign < 0. && mod != 0) {\n        res -= 1;\n      }\n      return res;\n    }\n\n    //Based on the work of Dave Hoskins\n    //https://www.shadertoy.com/view/4djSRW\n    #define HASHSCALE1 443.8975\n    float random(float seed){\n      vec2 p = resultUV * seed;\n      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n      p3 += dot(p3, p3.yzx + 19.19);\n      return fract((p3.x + p3.y) * p3.z);\n    }\n\n    ${Awe}\n    ${Rwe}\n    ${Mwe}\n  `}(a);return t.isPacked?(u=function Iwe(n,t,e){switch(n.length){case 0:return"\n    int getOutputCoords() {\n      return 0;\n    }\n  ";case 1:return function Owe(n,t,e){const s=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];return 1===s[0]?e?"\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * ceil(float(outTexShape[1]) / 2.0));\n      }\n    ":`\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * ${s[1]}.0);\n      }\n    `:1===s[1]?e?"\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * ceil(float(outTexShape[0]) / 2.0));\n      }\n    ":`\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * ${s[0]}.0);\n      }\n    `:e?"\n    int getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      return 2 * (resTexRC.x * packedTexShape[1] + resTexRC.y);\n    }\n  ":`\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${s[0]}, ${s[1]}));\n      return 2 * (resTexRC.x * ${s[1]} + resTexRC.y);\n    }\n  `}(0,t,e);case 2:return function Wwe(n,t,e){const s=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];if(wt(n,t))return e?"\n      ivec2 getOutputCoords() {\n        ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n        return 2 * ivec2(resultUV.yx * vec2(packedTexShape[0], packedTexShape[1]));\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        return 2 * ivec2(resultUV.yx * vec2(${s[0]}, ${s[1]}));\n      }\n    `;const r=Math.ceil(n[1]/2);return e?"\n    ivec2 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      int texelsInLogicalRow = int(ceil(float(outShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec2(r, c);\n    }\n  ":`\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${s[0]}, ${s[1]}));\n\n      int index = resTexRC.x * ${s[1]} + resTexRC.y;\n      int r = 2 * (index / ${r});\n      int c = imod(index, ${r}) * 2;\n\n      return ivec2(r, c);\n    }\n  `}(n,t,e);case 3:return function Pwe(n,t,e){if(e)return"\n    ivec3 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      int texelsInLogicalRow = int(ceil(float(outShape[2]) / 2.0));\n      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n\n      int b = index / texelsInBatch;\n      index -= b * texelsInBatch;\n\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec3(b, r, c);\n    }\n  ";const s=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],r=Math.ceil(n[2]/2),i=r*Math.ceil(n[1]/2);return`\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${s[0]}, ${s[1]}));\n      int index = resTexRC.x * ${s[1]} + resTexRC.y;\n\n      int b = index / ${i};\n      index -= b * ${i};\n\n      int r = 2 * (index / ${r});\n      int c = imod(index, ${r}) * 2;\n\n      return ivec3(b, r, c);\n    }\n  `}(n,t,e);default:return function Vwe(n,t,e){if(e)return"\n    ivec4 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n\n      int texelsInLogicalRow = int(ceil(float(outShape[3]) / 2.0));\n      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[2]) / 2.0));\n      int texelsInBatchN = texelsInBatch * outShape[1];\n\n      int b2 = index / texelsInBatchN;\n      index -= b2 * texelsInBatchN;\n\n      int b = index / texelsInBatch;\n      index -= b * texelsInBatch;\n\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec4(b2, b, r, c);\n    }\n  ";const s=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],r=Math.ceil(n[n.length-1]/2),i=r*Math.ceil(n[n.length-2]/2);let o=i,a="",l="b, r, c";for(let u=2;u<n.length-1;u++)o*=n[n.length-u-1],a=`\n      int b${u} = index / ${o};\n      index -= b${u} * ${o};\n    `+a,l=`b${u}, `+l;return`\n    ivec${n.length} getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${s[0]}, ${s[1]}));\n      int index = resTexRC.x * ${s[1]} + resTexRC.y;\n\n      ${a}\n\n      int b = index / ${i};\n      index -= b * ${i};\n\n      int r = 2 * (index / ${r});\n      int c = imod(index, ${r}) * 2;\n\n      return ivec${n.length}(${l});\n    }\n  `}(n,t,e)}}(t.logicalShape,o,e.enableShapeUniforms),c=function Nwe(n){return`\n    void setOutput(vec4 val) {\n      ${n.output} = val;\n    }\n  `}(a)):(u=function Ewe(n,t,e){switch(n.length){case 0:return"\n    int getOutputCoords() {\n      return 0;\n    }\n  ";case 1:return function $we(n,t,e){return 1===t[0]?e?"\n      int getOutputCoords() {\n        return int(resultUV.x * float(outTexShape[1]));\n      }\n    ":`\n      int getOutputCoords() {\n        return int(resultUV.x * ${t[1]}.0);\n      }\n    `:1===t[1]?e?"\n      int getOutputCoords() {\n        return int(resultUV.y * float(outTexShape[0]));\n      }\n    ":`\n      int getOutputCoords() {\n        return int(resultUV.y * ${t[0]}.0);\n      }\n    `:e?"\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(outTexShape[0], outTexShape[1]));\n      return resTexRC.x * outTexShape[1] + resTexRC.y;\n    }\n  ":`\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${t[0]}, ${t[1]}));\n      return resTexRC.x * ${t[1]} + resTexRC.y;\n    }\n  `}(0,t,e);case 2:return function Gwe(n,t,e){return wt(n,t)?e?"\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(outTexShape[0], outTexShape[1]));\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(${t[0]}, ${t[1]}));\n      }\n    `:1===n[1]?e?"\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(outTexShape[0], outTexShape[1]));\n        int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(${t[0]}, ${t[1]}));\n        int index = resTexRC.x * ${t[1]} + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    `:1===n[0]?e?"\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(outTexShape[0], outTexShape[1]));\n        int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n        return ivec2(0, index);\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(${t[0]}, ${t[1]}));\n        int index = resTexRC.x * ${t[1]} + resTexRC.y;\n        return ivec2(0, index);\n      }\n    `:e?"\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(outTexShape[0], outTexShape[1]));\n      int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n      int r = index / outShape[1];\n      int c = index - r * outShape[1];\n      return ivec2(r, c);\n    }\n  ":`\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n      int r = index / ${n[1]};\n      int c = index - r * ${n[1]};\n      return ivec2(r, c);\n    }\n  `}(n,t,e);case 3:return function Lwe(n,t,e){if(e)return`\n  ivec3 getOutputCoords() {\n    ivec2 resTexRC = ivec2(resultUV.yx *\n                           vec2(outTexShape[0], outTexShape[1]));\n    int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n    ${Yv(["r","c","d"],n)}\n    return ivec3(r, c, d);\n  }\n`;const s=wu(["r","c","d"],n);return`\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n      ${s}\n      return ivec3(r, c, d);\n    }\n  `}(n,t,e);case 4:return function Bwe(n,t,e){if(e)return`\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(outTexShape[0], outTexShape[1]));\n      int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n      ${Yv(["r","c","d","d2"],n)}\n      return ivec4(r, c, d, d2);\n    }\n  `;const s=wu(["r","c","d","d2"],n);return`\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n      ${s}\n      return ivec4(r, c, d, d2);\n    }\n  `}(n,t,e);case 5:return function zwe(n,t){const e=wu(["r","c","d","d2","d3"],n);return`\n    ivec5 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx * vec2(${t[0]},\n                             ${t[1]}));\n\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n\n      ${e}\n\n      ivec5 outShape = ivec5(r, c, d, d2, d3);\n      return outShape;\n    }\n  `}(n,t);case 6:return function Uwe(n,t){const e=wu(["r","c","d","d2","d3","d4"],n);return`\n    ivec6 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n\n      ${e}\n\n      ivec6 result = ivec6(r, c, d, d2, d3, d4);\n      return result;\n    }\n  `}(n,t);default:throw new Error(`${n.length}-D output sampling is not yet supported`)}}(t.logicalShape,o,e.enableShapeUniforms),c=function Twe(n){return`\n    void setOutput(float val) {\n      ${n.output} = vec4(val, 0, 0, 0);\n    }\n  `}(a)),e.packedInputs&&(d+=Fwe),[d,l,c,r,u,i,e.userCode].join("\n")}function wd(n,t=!1){const e=n.shapeInfo.logicalShape;switch(e.length){case 0:return function jwe(n,t){const e=n.name,s="get"+e.charAt(0).toUpperCase()+e.slice(1);if(n.shapeInfo.isUniform)return`float ${s}() {return ${e};}`;const[r,i]=n.shapeInfo.texShape;if(1===r&&1===i)return`\n      float ${s}() {\n        return sampleTexture(${e}, halfCR);\n      }\n    `;const o=xu(e);if(t)return`\n    float ${s}() {\n      vec2 uv = uvFromFlat(${e}TexShape[0], ${e}TexShape[1], ${o});\n      return sampleTexture(${e}, uv);\n    }\n  `;const[a,l]=n.shapeInfo.texShape;return`\n    float ${s}() {\n      vec2 uv = uvFromFlat(${a}, ${l}, ${o});\n      return sampleTexture(${e}, uv);\n    }\n  `}(n,t);case 1:return function Kwe(n,t){const e=n.name,s="get"+e.charAt(0).toUpperCase()+e.slice(1);if(n.shapeInfo.isUniform)return`\n      float ${s}(int index) {\n        ${xd(n)}\n      }\n    `;const r=n.shapeInfo.texShape,i=r[0],o=r[1];if(1===o&&1===i)return`\n      float ${s}(int index) {\n        return sampleTexture(${e}, halfCR);\n      }\n    `;const a=xu(e);return 1===o?t?`\n      float ${s}(int index) {\n        vec2 uv = vec2(0.5, (float(index + ${a}) + 0.5) / float(${e}TexShape[0]));\n        return sampleTexture(${e}, uv);\n      }\n    `:`\n      float ${s}(int index) {\n        vec2 uv = vec2(0.5, (float(index + ${a}) + 0.5) / ${i}.0);\n        return sampleTexture(${e}, uv);\n      }\n    `:1===i?t?`\n      float ${s}(int index) {\n        vec2 uv = vec2((float(index + ${a}) + 0.5) / float(${e}TexShape[1]), 0.5);\n        return sampleTexture(${e}, uv);\n      }\n    `:`\n      float ${s}(int index) {\n        vec2 uv = vec2((float(index + ${a}) + 0.5) / ${o}.0, 0.5);\n        return sampleTexture(${e}, uv);\n      }\n    `:t?`\n    float ${s}(int index) {\n      vec2 uv = uvFromFlat(${e}TexShape[0], ${e}TexShape[1], index + ${a});\n      return sampleTexture(${e}, uv);\n    }\n  `:`\n    float ${s}(int index) {\n      vec2 uv = uvFromFlat(${i}, ${o}, index + ${a});\n      return sampleTexture(${e}, uv);\n    }\n  `}(n,t);case 2:return function Ywe(n,t){const e=n.shapeInfo.logicalShape,s=n.name,r="get"+s.charAt(0).toUpperCase()+s.slice(1),i=n.shapeInfo.texShape;if(null!=i&&wt(e,i))return t?`\n      float ${r}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${s}TexShape[1], ${s}TexShape[0]);\n        return sampleTexture(${s}, uv);\n      }\n    `:`\n    float ${r}(int row, int col) {\n      vec2 uv = (vec2(col, row) + halfCR) / vec2(${i[1]}.0, ${i[0]}.0);\n      return sampleTexture(${s}, uv);\n    }\n  `;const{newShape:o,keptDims:a}=Fa(e);if(o.length<e.length){const f=["row","col"];return`\n      ${wd(Cd(n,o),t)}\n      float ${r}(int row, int col) {\n        return ${r}(${Sd(f,a)});\n      }\n    `}if(n.shapeInfo.isUniform)return`\n      float ${r}(int row, int col) {\n        int index = round(dot(vec2(row, col), vec2(${e[1]}, 1)));\n        ${xd(n)}\n      }\n    `;const u=i[0],c=i[1],d=xu(s);return 1===c?t?`\n      float ${r}(int row, int col) {\n        float index = dot(vec3(row, col, ${d}), vec3(${s}Shape[1], 1, 1));\n        vec2 uv = vec2(0.5, (index + 0.5) / float(${s}TexShape[0]));\n        return sampleTexture(${s}, uv);\n      }\n    `:`\n    float ${r}(int row, int col) {\n      float index = dot(vec3(row, col, ${d}), vec3(${e[1]}, 1, 1));\n      vec2 uv = vec2(0.5, (index + 0.5) / ${u}.0);\n      return sampleTexture(${s}, uv);\n    }\n  `:1===u?t?`\n      float ${r}(int row, int col) {\n        float index = dot(vec3(row, col, ${d}), vec3(${s}Shape[1], 1, 1));\n        vec2 uv = vec2((index + 0.5) / float(${s}TexShape[1]), 0.5);\n        return sampleTexture(${s}, uv);\n      }\n    `:`\n    float ${r}(int row, int col) {\n      float index = dot(vec3(row, col, ${d}), vec3(${e[1]}, 1, 1));\n      vec2 uv = vec2((index + 0.5) / ${c}.0, 0.5);\n      return sampleTexture(${s}, uv);\n    }\n  `:t?`\n      float ${r}(int row, int col) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * ${s}Shape[1] + col + ${d};\n        vec2 uv = uvFromFlat(${s}TexShape[0], ${s}TexShape[1], index);\n        return sampleTexture(${s}, uv);\n      }\n    `:`\n  float ${r}(int row, int col) {\n    // Explicitly use integer operations as dot() only works on floats.\n    int index = row * ${e[1]} + col + ${d};\n    vec2 uv = uvFromFlat(${u}, ${c}, index);\n    return sampleTexture(${s}, uv);\n  }\n`}(n,t);case 3:return function Qwe(n,t){const e=n.shapeInfo.logicalShape,s=n.name,r="get"+s.charAt(0).toUpperCase()+s.slice(1),i=e[1]*e[2],o=e[2],{newShape:a,keptDims:l}=Fa(e);if(a.length<e.length){const m=["row","col","depth"];return`\n        ${wd(Cd(n,a),t)}\n        float ${r}(int row, int col, int depth) {\n          return ${r}(${Sd(m,l)});\n        }\n      `}if(n.shapeInfo.isUniform)return`\n      float ${r}(int row, int col, int depth) {\n        int index = round(dot(vec3(row, col, depth),\n                          vec3(${i}, ${o}, 1)));\n        ${xd(n)}\n      }\n    `;const c=n.shapeInfo.texShape,d=c[0],h=c[1],f=n.shapeInfo.flatOffset;if(h===i&&null==f)return t?`\n      float ${r}(int row, int col, int depth) {\n        int stride1 = ${s}Shape[2];\n        float texR = float(row);\n        float texC = dot(vec2(col, depth), vec2(stride1, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${s}TexShape[1], ${s}TexShape[0]);\n        return sampleTexture(${s}, uv);\n      }\n    `:`\n        float ${r}(int row, int col, int depth) {\n          float texR = float(row);\n          float texC = dot(vec2(col, depth), vec2(${o}, 1));\n          vec2 uv = (vec2(texC, texR) + halfCR) /\n                     vec2(${h}.0, ${d}.0);\n          return sampleTexture(${s}, uv);\n        }\n      `;if(h===o&&null==f)return t?`\n      float ${r}(int row, int col, int depth) {\n        float texR = dot(vec2(row, col), vec2(${s}Shape[1], 1));\n        float texC = float(depth);\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${s}TexShape[1], ${s}TexShape[0]);\n        return sampleTexture(${s}, uv);\n      }\n    `:`\n    float ${r}(int row, int col, int depth) {\n      float texR = dot(vec2(row, col), vec2(${e[1]}, 1));\n      float texC = float(depth);\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${h}.0, ${d}.0);\n      return sampleTexture(${s}, uv);\n    }\n  `;const p=xu(s);return t?`\n    float ${r}(int row, int col, int depth) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int stride0 = ${s}Shape[1] * ${s}Shape[2];\n      int stride1 = ${s}Shape[2];\n      int index = row * stride0 + col * stride1 + depth + ${p};\n      vec2 uv = uvFromFlat(${s}TexShape[0], ${s}TexShape[1], index);\n      return sampleTexture(${s}, uv);\n    }\n    `:`\n      float ${r}(int row, int col, int depth) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * ${i} + col * ${o} + depth + ${p};\n        vec2 uv = uvFromFlat(${d}, ${h}, index);\n        return sampleTexture(${s}, uv);\n      }\n  `}(n,t);case 4:return function exe(n,t){const e=n.shapeInfo.logicalShape,s=n.name,r="get"+s.charAt(0).toUpperCase()+s.slice(1),i=e[3],o=e[2]*i,a=e[1]*o,{newShape:l,keptDims:u}=Fa(e);if(l.length<e.length){const v=["row","col","depth","depth2"];return`\n      ${wd(Cd(n,l),t)}\n      float ${r}(int row, int col, int depth, int depth2) {\n        return ${r}(${Sd(v,u)});\n      }\n    `}if(n.shapeInfo.isUniform)return`\n      float ${r}(int row, int col, int depth, int depth2) {\n        int index = round(dot(vec4(row, col, depth, depth2),\n                          vec4(${a}, ${o}, ${i}, 1)));\n        ${xd(n)}\n      }\n    `;const c=n.shapeInfo.flatOffset,d=n.shapeInfo.texShape,h=d[0],f=d[1],p=`int stride2 = ${s}Shape[3];`,g=`int stride1 = ${s}Shape[2] * stride2;`,m=`int stride0 = ${s}Shape[1] * stride1;`;if(f===a&&null==c)return t?`\n      float ${r}(int row, int col, int depth, int depth2) {\n        ${p}\n        ${g}\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3(stride1, stride2, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${s}TexShape[1], ${s}TexShape[0]);\n        return sampleTexture(${s}, uv);\n      }\n    `:`\n      float ${r}(int row, int col, int depth, int depth2) {\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3(${o}, ${i}, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${f}.0, ${h}.0);\n        return sampleTexture(${s}, uv);\n      }\n    `;if(f===i&&null==c)return t?`\n      float ${r}(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3(${s}Shape[1] * ${s}Shape[2], ${s}Shape[2], 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${s}TexShape[1], ${s}TexShape[0]);\n        return sampleTexture(${s}, uv);\n      }\n    `:`\n      float ${r}(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3(${e[1]*e[2]}, ${e[2]}, 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${f}.0, ${h}.0);\n        return sampleTexture(${s}, uv);\n      }\n    `;const y=xu(s);return t?`\n    float ${r}(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      ${p}\n      ${g}\n      ${m}\n      int index = row * stride0 + col * stride1 +\n          depth * stride2 + depth2;\n      vec2 uv = uvFromFlat(${s}TexShape[0], ${s}TexShape[1], index + ${y});\n      return sampleTexture(${s}, uv);\n    }\n  `:`\n    float ${r}(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${a} + col * ${o} +\n          depth * ${i} + depth2;\n      vec2 uv = uvFromFlat(${h}, ${f}, index + ${y});\n      return sampleTexture(${s}, uv);\n    }\n  `}(n,t);case 5:return function txe(n){const t=n.shapeInfo.logicalShape,e=n.name,s="get"+e.charAt(0).toUpperCase()+e.slice(1),r=t[4],i=t[3]*r,o=t[2]*i,a=t[1]*o,{newShape:l,keptDims:u}=Fa(t);if(l.length<t.length){const m=["row","col","depth","depth2","depth3"];return`\n      ${wd(Cd(n,l))}\n      float ${s}(int row, int col, int depth, int depth2, int depth3) {\n        return ${s}(${Sd(m,u)});\n      }\n    `}if(n.shapeInfo.isUniform)return`\n      float ${s}(int row, int col, int depth, int depth2, int depth3) {\n        float index = dot(\n          vec4(row, col, depth, depth2),\n          vec4(${a}, ${o}, ${i}, ${r})) +\n          depth3;\n        ${xd(n)}\n      }\n    `;const c=n.shapeInfo.flatOffset,d=n.shapeInfo.texShape,h=d[0],f=d[1];if(f===a&&null==c)return`\n      float ${s}(int row, int col, int depth, int depth2, int depth3) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n                         vec4(${o}, ${i}, ${r}, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${f}.0, ${h}.0);\n        return sampleTexture(${e}, uv);\n      }\n    `;if(f===r&&null==c)return`\n      float ${s}(int row, int col, int depth, int depth2, int depth3) {\n        float texR = dot(\n          vec4(row, col, depth, depth2),\n          vec4(${t[1]*t[2]*t[3]},\n               ${t[2]*t[3]}, ${t[3]}, 1));\n        int texC = depth3;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${f}.0, ${h}.0);\n        return sampleTexture(${e}, uv);\n      }\n    `;return`\n    float ${s}(int row, int col, int depth, int depth2, int depth3) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${a} + col * ${o} + depth * ${i} +\n          depth2 * ${r} + depth3 + ${xu(e)};\n      vec2 uv = uvFromFlat(${h}, ${f}, index);\n      return sampleTexture(${e}, uv);\n    }\n  `}(n);case 6:return function nxe(n){const t=n.shapeInfo.logicalShape,e=n.name,s="get"+e.charAt(0).toUpperCase()+e.slice(1),{newShape:r,keptDims:i}=Fa(t);if(r.length<t.length){const y=["row","col","depth","depth2","depth3","depth4"];return`\n      ${wd(Cd(n,r))}\n      float ${s}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        return ${s}(${Sd(y,i)});\n      }\n    `}const o=t[5],a=t[4]*o,l=t[3]*a,u=t[2]*l,c=t[1]*u;if(n.shapeInfo.isUniform)return`\n      float ${s}(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n        int index = round(dot(\n          vec4(row, col, depth, depth2),\n          vec4(${c}, ${u}, ${l}, ${a})) +\n          dot(\n            vec2(depth3, depth4),\n            vec2(${o}, 1)));\n        ${xd(n)}\n      }\n    `;const d=n.shapeInfo.flatOffset,h=n.shapeInfo.texShape,f=h[0],p=h[1];if(p===c&&null==d)return`\n      float ${s}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n          vec4(${u}, ${l}, ${a}, ${o})) +\n               float(depth4);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${p}.0, ${f}.0);\n        return sampleTexture(${e}, uv);\n      }\n    `;if(p===o&&null==d)return`\n      float ${s}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        float texR = dot(vec4(row, col, depth, depth2),\n          vec4(${t[1]*t[2]*t[3]*t[4]},\n               ${t[2]*t[3]*t[4]},\n               ${t[3]*t[4]},\n               ${t[4]})) + float(depth3);\n        int texC = depth4;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${p}.0, ${f}.0);\n        return sampleTexture(${e}, uv);\n      }\n    `;return`\n    float ${s}(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${c} + col * ${u} + depth * ${l} +\n          depth2 * ${a} + depth3 * ${o} + depth4 + ${xu(e)};\n      vec2 uv = uvFromFlat(${f}, ${p}, index);\n      return sampleTexture(${e}, uv);\n    }\n  `}(n);default:throw new Error(`${e.length}-D input sampling is not yet supported`)}}function K3(n,t){switch(n.shapeInfo.logicalShape.length){case 0:return function Hwe(n){const t=n.name;return`\n    vec4 ${"get"+t.charAt(0).toUpperCase()+t.slice(1)}() {\n      return ${Ys().texture2D}(${t}, halfCR);\n    }\n  `}(n);case 1:return function qwe(n,t){const e=n.name,s="get"+e.charAt(0).toUpperCase()+e.slice(1),r=n.shapeInfo.texShape,i=Ys();if(t)return`\n    vec4 ${s}(int index) {\n      ivec2 packedTexShape = ivec2(ceil(float(${e}TexShape[0]) / 2.0), ceil(float(${e}TexShape[1]) / 2.0));\n      vec2 uv = packedUVfrom1D(\n        packedTexShape[0], packedTexShape[1], index);\n      return ${i.texture2D}(${e}, uv);\n    }\n  `;const o=[Math.ceil(r[0]/2),Math.ceil(r[1]/2)];return`\n    vec4 ${s}(int index) {\n      vec2 uv = packedUVfrom1D(\n        ${o[0]}, ${o[1]}, index);\n      return ${i.texture2D}(${e}, uv);\n    }\n  `}(n,t);case 2:return function Xwe(n,t){const e=n.shapeInfo.logicalShape,s=n.name,r="get"+s.charAt(0).toUpperCase()+s.slice(1),i=n.shapeInfo.texShape,o=i[0],a=i[1],l=Ys();if(null!=i&&wt(e,i))return t?`\n      vec4 ${r}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${s}TexShape[1], ${s}TexShape[0]);\n\n        return ${l.texture2D}(${s}, uv);\n      }\n    `:`\n      vec4 ${r}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${a}.0, ${o}.0);\n\n        return ${l.texture2D}(${s}, uv);\n      }\n    `;if(t)return`\n    vec4 ${r}(int row, int col) {\n      ivec2 packedTexShape = ivec2(ceil(float(${s}TexShape[0]) / 2.0), ceil(float(${s}TexShape[1]) / 2.0));\n      int valuesPerRow = int(ceil(float(${s}Shape[1]) / 2.0));\n      vec2 uv = packedUVfrom2D(valuesPerRow, packedTexShape[0], packedTexShape[1], row, col);\n      return ${l.texture2D}(${s}, uv);\n    }\n  `;const u=[Math.ceil(i[0]/2),Math.ceil(i[1]/2)];return`\n    vec4 ${r}(int row, int col) {\n      vec2 uv = packedUVfrom2D(${Math.ceil(e[1]/2)}, ${u[0]}, ${u[1]}, row, col);\n      return ${l.texture2D}(${s}, uv);\n    }\n  `}(n,t);case 3:return function Zwe(n,t){const e=n.shapeInfo.logicalShape,s=n.name,r="get"+s.charAt(0).toUpperCase()+s.slice(1),i=n.shapeInfo.texShape,o=[Math.ceil(i[0]/2),Math.ceil(i[1]/2)];if(1===e[0]){const f=[1,2],g=["b","row","col"];return`\n        ${K3(Cd(n,e.slice(1)),t)}\n        vec4 ${r}(int b, int row, int col) {\n          return ${r}(${Sd(g,f)});\n        }\n      `}const a=Ys();if(t)return`\n    vec4 ${r}(int b, int row, int col) {\n      ivec2 packedTexShape = ivec2(ceil(float(${s}TexShape[0]) / 2.0), ceil(float(${s}TexShape[1]) / 2.0));\n      int valuesPerRow = int(ceil(float(${s}Shape[2]) / 2.0));\n      int texelsInBatch = valuesPerRow * int(ceil(float(${s}Shape[1]) / 2.0));\n      vec2 uv = packedUVfrom3D(\n        packedTexShape[0], packedTexShape[1], texelsInBatch, valuesPerRow, b, row, col);\n      return ${a.texture2D}(${s}, uv);\n    }\n  `;const l=o[0],u=o[1],c=Math.ceil(e[2]/2);return`\n    vec4 ${r}(int b, int row, int col) {\n      vec2 uv = packedUVfrom3D(\n        ${l}, ${u}, ${c*Math.ceil(e[1]/2)}, ${c}, b, row, col);\n      return ${a.texture2D}(${s}, uv);\n    }\n  `}(n,t);default:return function Jwe(n,t){const e=n.name,s="get"+e.charAt(0).toUpperCase()+e.slice(1),r=Ys();if(t)return`\n    vec4 ${s}(int b2, int b, int row, int col) {\n      int valuesPerRow = int(ceil(float(${e}Shape[3]) / 2.0));\n      int texelsInBatch = valuesPerRow * int(ceil(float(${e}Shape[2]) / 2.0));\n      int index = b * texelsInBatch + (row / 2) * valuesPerRow + (col / 2);\n      texelsInBatch *= ${e}Shape[1];\n      index = b2 * texelsInBatch + index;\n      ivec2 packedTexShape = ivec2(ceil(float(${e}TexShape[0]) / 2.0), ceil(float(${e}TexShape[1]) / 2.0));\n      int texR = index / packedTexShape[1];\n      int texC = index - texR * packedTexShape[1];\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(packedTexShape[1], packedTexShape[0]); return ${r.texture2D}(${e}, uv);\n    }\n  `;const i=n.shapeInfo.logicalShape,o=i.length,a=n.shapeInfo.texShape,l=[Math.ceil(a[0]/2),Math.ceil(a[1]/2)],u=l[0],c=l[1],d=Math.ceil(i[o-1]/2);let h=d*Math.ceil(i[o-2]/2),f="int b, int row, int col",p=`b * ${h} + (row / 2) * ${d} + (col / 2)`;for(let g=2;g<o-1;g++)f=`int b${g}, `+f,h*=i[o-g-1],p=`b${g} * ${h} + `+p;return`\n    vec4 ${s}(${f}) {\n      int index = ${p};\n      int texR = index / ${c};\n      int texC = index - texR * ${c};\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${c}, ${u});\n      return ${r.texture2D}(${e}, uv);\n    }\n  `}(n,t)}}const Awe="\nvec2 uvFromFlat(int texNumR, int texNumC, int index) {\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\nvec2 packedUVfrom1D(int texNumR, int texNumC, int index) {\n  int texelIndex = index / 2;\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",Rwe="\nvec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,\n  int texNumC, int row, int col) {\n  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",Mwe="\nvec2 packedUVfrom3D(int texNumR, int texNumC,\n    int texelsInBatch, int texelsInLogicalRow, int b,\n    int row, int col) {\n  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",Fwe="\n  float getChannel(vec4 frag, vec2 innerDims) {\n    vec2 modCoord = mod(innerDims, 2.);\n    return modCoord.x == 0. ?\n      (modCoord.y == 0. ? frag.r : frag.g) :\n      (modCoord.y == 0. ? frag.b : frag.a);\n  }\n  float getChannel(vec4 frag, int dim) {\n    float modCoord = mod(float(dim), 2.);\n    return modCoord == 0. ? frag.r : frag.g;\n  }\n";function xu(n){return`offset${n}`}function xd(n){const t=n.name,e=X(n.shapeInfo.logicalShape);return e<2?`return ${t};`:`\n    for (int i = 0; i < ${e}; i++) {\n      if (i == index) {\n        return ${t}[i];\n      }\n    }\n  `}function Xt(n){if(n<=1)return"int";if(2===n)return"ivec2";if(3===n)return"ivec3";if(4===n)return"ivec4";if(5===n)return"ivec5";if(6===n)return"ivec6";throw Error(`GPU for rank ${n} is not yet supported`)}function CT(n,t,e){const{newShape:s,keptDims:r}=Fa(t),i=t.length,o=n&&3===i&&1===t[0],a=o?t.slice(1):s,l=!n&&i>1&&!wt(t,e)&&s.length<i||o;return{useSqueezeShape:l,uniformShape:l?a:t,keptDims:r}}function Cd(n,t){const e=JSON.parse(JSON.stringify(n));return e.shapeInfo.logicalShape=t,e}function Sd(n,t){return t.map(e=>n[e]).join(", ")}function Y3(n,t,e){const s=[],r=[];let i,o,a,l=null,u=null;u=n.getUniformLocation(e,"NAN",!1),1===W().getNumber("WEBGL_VERSION")&&(l=n.getUniformLocation(e,"INFINITY",!1));const c=!1;for(const d of t.variableNames){const h={name:d,uniform:n.getUniformLocation(e,d,c),offset:n.getUniformLocation(e,`offset${d}`,c)};t.enableShapeUniforms&&(h.shape=n.getUniformLocation(e,`${d}Shape`,c),h.texShape=n.getUniformLocation(e,`${d}TexShape`,c)),s.push(h)}if(t.enableShapeUniforms&&(i=n.getUniformLocation(e,"outShape",c),a=n.getUniformLocation(e,"outShapeStrides",c),o=n.getUniformLocation(e,"outTexShape",c)),t.customUniforms)for(const d of t.customUniforms)r.push(n.getUniformLocation(e,d.name,c));return{variablesLocations:s,customUniformLocations:r,infLoc:l,nanLoc:u,outShapeLocation:i,outShapeStridesLocation:a,outTexShapeLocation:o}}function Z3(n,t){if(n.length!==t.length)throw Error(`Binary was compiled with ${n.length} inputs, but was executed with ${t.length} inputs`);n.forEach((e,s)=>{const r=e.logicalShape,i=t[s],o=i.shape;if(!wt(r,o))throw Error(`Binary was compiled with different shapes than the current args. Shapes ${r} and ${o} must match`);if(e.isUniform&&i.isUniform)return;const a=e.texShape,l=i.isUniform?null:i.texData.texShape;if(!wt(a,l))throw Error(`Binary was compiled with different texture shapes than the current args. Shape ${a} and ${l} must match`)})}function Us(n){return W().getBool("WEBGL_USE_SHAPES_UNIFORMS")&&n<=4}class lxe{constructor(t){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outPackingScheme=Mo.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const e=Ys();this.outputShape=t,this.enableShapeUniforms=Us(this.outputShape.length),this.userCode=`\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ${this.enableShapeUniforms?Yv(["r","c","d"],t):wu(["r","c","d"],t)}\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));\n        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getA(rc.x, rc.y, rc.z);\n        }\n\n        ${e.output} = result;\n      }\n    `}}class uxe{constructor(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outPackingScheme=Mo.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const e=Ys();this.outputShape=t,this.enableShapeUniforms=Us(this.outputShape.length),this.userCode=`\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ${this.enableShapeUniforms?Yv(["r","c","d"],t):wu(["r","c","d"],t)}\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));\n        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));\n        }\n\n        ${e.output} = result;\n      }\n    `}}class cxe{constructor(t){this.variableNames=["A"],this.outTexUsage=Vn.DOWNLOAD;const e=Ys();this.outputShape=t,this.userCode=`\n      ${j3}\n\n      void main() {\n        float x = getAAtOutCoords();\n        ${e.output} = encode_float(x);\n      }\n    `}}class dxe{constructor(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outTexUsage=Vn.DOWNLOAD;const e=Ys();this.outputShape=t,this.userCode=`\n      ${j3}\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));\n        ${e.output} = encode_float(x);\n      }\n    `}}const hxe={R:0,G:1,B:2,A:3};class Q3{constructor(t,e=!1,s="RGBA"){this.variableNames=["A"],this.customUniforms=[{name:"texShape",type:"ivec2"}];const r=Ys();this.outputShape=t,this.enableShapeUniforms=Us(this.outputShape.length);let i="result";e&&(i="floor(result * 255. + 0.5)");let o="";for(let a=0;a<s.length;a++)o+=`\n          if(offset == ${a}) {\n            result = values[${hxe[s[a]]}];\n          }`;this.userCode=`\n      ${this.enableShapeUniforms?"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n":wT(t)}\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int flatIndex = getFlatIndex(coords);\n        float result = 0.;\n        int offset = imod(flatIndex, ${s.length});\n\n        flatIndex = idiv(flatIndex, ${s.length}, 1.);\n\n        int r = flatIndex / texShape[1];\n        if (r < texShape[0]) {\n          int c = imod(flatIndex, texShape[1]);\n          vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);\n          vec4 values = ${r.texture2D}(A, uv);\n          ${o}\n        }\n        ${r.output} = vec4(${i}, 0., 0., 0.);\n      }\n    `}}class fxe{constructor(t,e=!1){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.customUniforms=[{name:"texShape",type:"ivec2"}];const s=Ys();this.outputShape=t,this.enableShapeUniforms=Us(this.outputShape.length);let r="",i="result";e&&(i="floor(result * 255. + 0.5)");for(let o=0;o<=1;o++)for(let a=0;a<=1;a++){const l=2*o+a;r+=`\n          localCoords = coords;\n          if(localCoords[2] + ${a} < ${this.enableShapeUniforms?"outShape[2]":`${t[2]}`}) {\n          localCoords[2] += ${a};\n          if (localCoords[1] + ${o} < ${this.enableShapeUniforms?"outShape[1]":`${t[1]}`}) {\n            localCoords[1] += ${o};\n\n            flatIndex = getFlatIndex(localCoords);\n            offset = imod(flatIndex, 4);\n\n            flatIndex = idiv(flatIndex, 4, 1.);\n\n            int r = flatIndex / texShape[1];\n            int c = imod(flatIndex, texShape[1]);\n            vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);\n            values = ${s.texture2D}(A, uv);\n\n            if (offset == 0) {\n              result[${l}] = values[0];\n            } else if (offset == 1) {\n              result[${l}] = values[1];\n            } else if (offset == 2) {\n              result[${l}] = values[2];\n            } else {\n              result[${l}] = values[3];\n            }\n          }\n        }\n        `}this.userCode=`\n        ${this.enableShapeUniforms?"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n":wT(t)}\n\n        void main() {\n          ivec3 coords = getOutputCoords();\n\n          vec4 result = vec4(0.);\n          int flatIndex, r, c, offset;\n          ivec3 localCoords;\n          vec2 uv;\n          vec4 values;\n\n          ${r}\n\n          ${s.output} = ${i};\n        }\n    `}}function Bp(n,t,e,s,r,i){!function owe(n,t){const e=W().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(n<=0||t<=0)throw new Error(`Requested texture size [${n}x${t}] is invalid.`);if(n>e||t>e)throw new Error(`Requested texture size [${n}x${t}] greater than WebGL maximum on this browser / GPU [${e}x${e}].`)}(t,e);const o=function iwe(n){return ga(n,()=>n.createTexture(),"Unable to create WebGLTexture.")}(n),a=n.TEXTURE_2D;return ve(n,()=>n.bindTexture(a,o)),ve(n,()=>n.texParameteri(a,n.TEXTURE_WRAP_S,n.CLAMP_TO_EDGE)),ve(n,()=>n.texParameteri(a,n.TEXTURE_WRAP_T,n.CLAMP_TO_EDGE)),ve(n,()=>n.texParameteri(a,n.TEXTURE_MIN_FILTER,n.NEAREST)),ve(n,()=>n.texParameteri(a,n.TEXTURE_MAG_FILTER,n.NEAREST)),1===W().getNumber("WEBGL_VERSION")?ve(n,()=>n.texImage2D(a,0,s,t,e,0,r,i,null)):ve(n,()=>n.texStorage2D(a,1,s,t,e)),ve(n,()=>n.bindTexture(n.TEXTURE_2D,null)),{texture:o,texShape:[e,t]}}function J3(n){return n.internalFormatFloat}function eU(n){return n.internalFormatHalfFloat}function tU(n){return n.downloadTextureFormat}function nU(n){return n.internalFormatPackedFloat}function sU(n){return n.internalFormatPackedHalfFloat}class ST{constructor(t){this.outputTexture=null,this.program=null,this.disposed=!1,this.itemsToPoll=[];const e=W().getNumber("WEBGL_VERSION");if(null!=t?(this.gl=t,function U_e(n,t){dl[n]=t}(e,t)):this.gl=Yi(e),t=this.gl,2===W().getNumber("WEBGL_VERSION")){const i=t;this.createVertexArray=()=>ve(i,()=>i.createVertexArray()),this.bindVertexArray=o=>ve(i,()=>i.bindVertexArray(o)),this.deleteVertexArray=o=>ve(i,()=>i.deleteVertexArray(o)),this.getVertexArray=()=>ve(i,()=>i.getParameter(i.VERTEX_ARRAY_BINDING))}else if(null!=t){const i=t.getExtension("OES_vertex_array_object");if(null==i)throw new Error("All WebGL1 implementations are expected to offer OES_vertex_array_object.");this.createVertexArray=()=>ve(t,()=>i.createVertexArrayOES()),this.bindVertexArray=o=>ve(t,()=>i.bindVertexArrayOES(o)),this.deleteVertexArray=o=>ve(t,()=>i.deleteVertexArrayOES(o)),this.getVertexArray=()=>ve(t,()=>t.getParameter(i.VERTEX_ARRAY_BINDING_OES))}let s="WEBGL_color_buffer_float";const r="EXT_color_buffer_half_float";if(this.parallelCompilationExtension=this.gl.getExtension("KHR_parallel_shader_compile"),1===W().getNumber("WEBGL_VERSION")){const o="OES_texture_half_float";if(this.textureFloatExtension=Wv(this.gl,"OES_texture_float"),Si(this.gl,o))this.textureHalfFloatExtension=Wv(this.gl,o);else if(W().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");if(this.colorBufferFloatExtension=this.gl.getExtension(s),Si(this.gl,r))this.colorBufferHalfFloatExtension=Wv(this.gl,r);else if(W().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}else if(s="EXT_color_buffer_float",Si(this.gl,s))this.colorBufferFloatExtension=this.gl.getExtension(s);else{if(!Si(this.gl,r))throw new Error("GL context does not support color renderable floats");this.colorBufferHalfFloatExtension=this.gl.getExtension(r)}this.vertexBuffer=function mxe(n){return function swe(n,t){const e=ga(n,()=>n.createBuffer(),"Unable to create WebGLBuffer");return ve(n,()=>n.bindBuffer(n.ARRAY_BUFFER,e)),ve(n,()=>n.bufferData(n.ARRAY_BUFFER,t,n.STATIC_DRAW)),e}(n,new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]))}(this.gl),this.indexBuffer=function gxe(n){return function rwe(n,t){const e=ga(n,()=>n.createBuffer(),"Unable to create WebGLBuffer");return ve(n,()=>n.bindBuffer(n.ELEMENT_ARRAY_BUFFER,e)),ve(n,()=>n.bufferData(n.ELEMENT_ARRAY_BUFFER,t,n.STATIC_DRAW)),e}(n,new Uint16Array([0,1,2,2,1,3]))}(this.gl),this.framebuffer=function awe(n){return ga(n,()=>n.createFramebuffer(),"Unable to create WebGLFramebuffer.")}(this.gl),this.textureConfig=yT(this.gl,this.textureHalfFloatExtension)}get debug(){return W().getBool("DEBUG")}dispose(){if(this.disposed)return;null!=this.program&&console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."),null!=this.outputTexture&&console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");const t=this.gl;ve(t,()=>t.finish()),ve(t,()=>t.bindFramebuffer(t.FRAMEBUFFER,null)),ve(t,()=>t.deleteFramebuffer(this.framebuffer)),ve(t,()=>t.bindBuffer(t.ARRAY_BUFFER,null)),ve(t,()=>t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,null)),ve(t,()=>t.deleteBuffer(this.indexBuffer)),this.disposed=!0}createFloat32MatrixTexture(t,e){return this.throwIfDisposed(),function yxe(n,t,e,s){const[r,i]=Lp(t,e);return Bp(n,r,i,J3(s),s.textureFormatFloat,n.FLOAT)}(this.gl,t,e,this.textureConfig)}createFloat16MatrixTexture(t,e){return this.throwIfDisposed(),function bxe(n,t,e,s){const[r,i]=Lp(t,e);return Bp(n,r,i,eU(s),s.textureFormatFloat,s.textureTypeHalfFloat)}(this.gl,t,e,this.textureConfig)}createUnsignedBytesMatrixTexture(t,e){return this.throwIfDisposed(),function vxe(n,t,e,s){const[r,i]=Lp(t,e);return Bp(n,r,i,tU(s),n.RGBA,n.UNSIGNED_BYTE)}(this.gl,t,e,this.textureConfig)}uploadPixelDataToTexture(t,e){this.throwIfDisposed(),function Sxe(n,t,e){ve(n,()=>n.bindTexture(n.TEXTURE_2D,t)),e.data instanceof Uint8Array?2===W().getNumber("WEBGL_VERSION")?ve(n,()=>n.texSubImage2D(n.TEXTURE_2D,0,0,0,e.width,e.height,n.RGBA,n.UNSIGNED_BYTE,e.data)):ve(n,()=>n.texImage2D(n.TEXTURE_2D,0,n.RGBA,e.width,e.height,0,n.RGBA,n.UNSIGNED_BYTE,e.data)):2===W().getNumber("WEBGL_VERSION")?ve(n,()=>n.texSubImage2D(n.TEXTURE_2D,0,0,0,n.RGBA,n.UNSIGNED_BYTE,e)):ve(n,()=>n.texImage2D(n.TEXTURE_2D,0,n.RGBA,n.RGBA,n.UNSIGNED_BYTE,e)),ve(n,()=>n.bindTexture(n.TEXTURE_2D,null))}(this.gl,t,e)}uploadDenseMatrixToTexture(t,e,s,r){this.throwIfDisposed(),function Cxe(n,t,e,s,r,i){let o,a,l;ve(n,()=>n.bindTexture(n.TEXTURE_2D,t)),r instanceof Uint8Array?(o=new Uint8Array(e*s*4),a=n.UNSIGNED_BYTE,l=n.RGBA):(o=new Float32Array(e*s*4),a=n.FLOAT,l=i.internalFormatPackedFloat),o.set(r),2===W().getNumber("WEBGL_VERSION")?ve(n,()=>n.texSubImage2D(n.TEXTURE_2D,0,0,0,e,s,n.RGBA,a,o)):ve(n,()=>n.texImage2D(n.TEXTURE_2D,0,l,e,s,0,n.RGBA,a,o)),ve(n,()=>n.bindTexture(n.TEXTURE_2D,null))}(this.gl,t,e,s,r,this.textureConfig)}createFloat16PackedMatrixTexture(t,e){return this.throwIfDisposed(),function wxe(n,t,e,s){const[r,i]=bd(t,e);return Bp(n,r,i,sU(s),n.RGBA,s.textureTypeHalfFloat)}(this.gl,t,e,this.textureConfig)}createPackedMatrixTexture(t,e){return this.throwIfDisposed(),function _xe(n,t,e,s){const[r,i]=bd(t,e);return Bp(n,r,i,nU(s),n.RGBA,n.FLOAT)}(this.gl,t,e,this.textureConfig)}deleteMatrixTexture(t){this.throwIfDisposed(),this.outputTexture===t&&(W3(this.gl,this.framebuffer),this.outputTexture=null),ve(this.gl,()=>this.gl.deleteTexture(t))}downloadByteEncodedFloatMatrixFromOutputTexture(t,e,s){return this.downloadMatrixDriver(t,()=>function Dxe(n,t,e,s){const[r,i]=Lp(t,e),a=new Uint8Array(function H_e(n,t){return n*t}(t*e,4));return ve(n,()=>n.readPixels(0,0,r,i,s.downloadTextureFormat,n.UNSIGNED_BYTE,a)),new Float32Array(a.buffer)}(this.gl,e,s,this.textureConfig))}downloadPackedMatrixFromBuffer(t,e,s,r,i,o){return function Txe(n,t,e,s,r,i,o,a){const l=n,u=new Float32Array(function j_e(n,t){const[e,s]=bd(n,t);return e*s*4}(i,o));return l.bindBuffer(l.PIXEL_PACK_BUFFER,t),l.getBufferSubData(l.PIXEL_PACK_BUFFER,0,u),l.bindBuffer(l.PIXEL_PACK_BUFFER,null),u}(this.gl,t,0,0,0,i,o)}downloadFloat32MatrixFromBuffer(t,e){return function Exe(n,t,e){const s=n,r=new Float32Array(e);return s.bindBuffer(s.PIXEL_PACK_BUFFER,t),s.getBufferSubData(s.PIXEL_PACK_BUFFER,0,r),s.bindBuffer(s.PIXEL_PACK_BUFFER,null),r}(this.gl,t,e)}createBufferFromTexture(t,e,s){this.bindTextureToFrameBuffer(t);const r=function Ixe(n,t,e,s){const r=n.createBuffer();ve(n,()=>n.bindBuffer(n.PIXEL_PACK_BUFFER,r));const a=16*t*e;return ve(n,()=>n.bufferData(n.PIXEL_PACK_BUFFER,a,n.STREAM_READ)),ve(n,()=>n.readPixels(0,0,e,t,n.RGBA,n.FLOAT,0)),ve(n,()=>n.bindBuffer(n.PIXEL_PACK_BUFFER,null)),r}(this.gl,e,s);return this.unbindTextureToFrameBuffer(),r}createAndWaitForFence(){const t=this.createFence(this.gl);return this.pollFence(t)}createFence(t){let e,s;if(W().getBool("WEBGL_FENCE_API_ENABLED")){const r=t,i=r.fenceSync(r.SYNC_GPU_COMMANDS_COMPLETE,0);t.flush(),s=()=>{const o=r.clientWaitSync(i,0,0);return o===r.ALREADY_SIGNALED||o===r.CONDITION_SATISFIED},e=i}else W().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(e=this.beginQuery(),this.endQuery(),s=()=>this.isQueryAvailable(e,W().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))):s=()=>!0;return{query:e,isFencePassed:s}}downloadMatrixFromPackedTexture(t,e,s){return this.downloadMatrixDriver(t,()=>function Nxe(n,t,e){const s=new Float32Array(t*e*4);return ve(n,()=>n.readPixels(0,0,e,t,n.RGBA,n.FLOAT,s)),s}(this.gl,e,s))}createProgram(t){this.throwIfDisposed();const e=this.gl;null==this.vertexShader&&(this.vertexShader=function pxe(n){const t=Ys();return function Q_e(n,t){const e=ga(n,()=>n.createShader(n.VERTEX_SHADER),"Unable to create vertex WebGLShader.");if(ve(n,()=>n.shaderSource(e,t)),ve(n,()=>n.compileShader(e)),!1===n.getShaderParameter(e,n.COMPILE_STATUS))throw console.log(n.getShaderInfoLog(e)),new Error("Failed to compile vertex shader.");return e}(n,`${t.version}\n    precision highp float;\n    ${t.attribute} vec3 clipSpacePos;\n    ${t.attribute} vec2 uv;\n    ${t.varyingVs} vec2 resultUV;\n\n    void main() {\n      gl_Position = vec4(clipSpacePos, 1);\n      resultUV = uv;\n    }`)}(e));const s=function twe(n){return ga(n,()=>n.createProgram(),"Unable to create WebGLProgram.")}(e);ve(e,()=>e.attachShader(s,this.vertexShader)),ve(e,()=>e.attachShader(s,t)),function nwe(n,t){if(ve(n,()=>n.linkProgram(t)),!W().get("ENGINE_COMPILE_ONLY")&&!1===n.getProgramParameter(t,n.LINK_STATUS))throw console.log(n.getProgramInfoLog(t)),new Error("Failed to link vertex and fragment shaders.")}(e,s);const r=Object.assign(s,{vao:this.createVertexArray()});return this.debug&&bT(e,r),r}buildVao(t){this.setProgram(t),this.bindVertexArray(t.vao);const e=this.gl;ve(e,()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,this.indexBuffer)),function xxe(n,t,e){ve(n,()=>n.bindBuffer(n.ARRAY_BUFFER,e)),U3(n,t,"clipSpacePos",e,3,20,0)&&U3(n,t,"uv",e,2,20,12)}(e,t,this.vertexBuffer)}deleteProgram(t){this.throwIfDisposed(),t===this.program&&(this.program=null),null!=t&&(ve(this.gl,()=>this.gl.deleteProgram(t)),this.deleteVertexArray(t.vao))}setProgram(t){this.throwIfDisposed(),this.program=t,null!=this.program&&this.debug&&bT(this.gl,this.program),ve(this.gl,()=>this.gl.useProgram(t))}getUniformLocation(t,e,s=!0){return this.throwIfDisposed(),s?function uwe(n,t,e){return ga(n,()=>n.getUniformLocation(t,e),'uniform "'+e+'" not present in program.')}(this.gl,t,e):function cwe(n,t,e){return n.getUniformLocation(t,e)}(this.gl,t,e)}getAttributeLocation(t,e){return this.throwIfDisposed(),ve(this.gl,()=>this.gl.getAttribLocation(t,e))}getUniformLocationNoThrow(t,e){return this.throwIfDisposed(),this.gl.getUniformLocation(t,e)}setInputMatrixTexture(t,e,s){this.throwIfDisposed(),this.throwIfNoProgram(),dwe(this.gl,t,e,s)}setOutputMatrixTexture(t,e,s){this.setOutputMatrixTextureDriver(t,s,e)}setOutputPackedMatrixTexture(t,e,s){this.throwIfDisposed();const[r,i]=bd(e,s);this.setOutputMatrixTextureDriver(t,r,i)}setOutputMatrixWriteRegion(t,e,s,r){this.setOutputMatrixWriteRegionDriver(s,t,r,e)}setOutputPackedMatrixWriteRegion(t,e,s,r){throw new Error("setOutputPackedMatrixWriteRegion not implemented.")}debugValidate(){null!=this.program&&bT(this.gl,this.program),Gv(this.gl)}executeProgram(){this.throwIfDisposed(),this.throwIfNoProgram();const t=this.gl;if(this.debug){const e=this.getVertexArray();console.assert(e===this.program.vao,"VAO changed between setProgram and executeProgram!"),this.debugValidate()}ve(t,()=>t.drawElements(t.TRIANGLES,6,t.UNSIGNED_SHORT,0))}blockUntilAllProgramsCompleted(){this.throwIfDisposed(),ve(this.gl,()=>this.gl.finish())}getQueryTimerExtension(){return null==this.disjointQueryTimerExtension&&(this.disjointQueryTimerExtension=Wv(this.gl,2===W().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")),this.disjointQueryTimerExtension}getQueryTimerExtensionWebGL2(){return this.getQueryTimerExtension()}getQueryTimerExtensionWebGL1(){return this.getQueryTimerExtension()}beginQuery(){if(2===W().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){const s=this.gl,r=this.getQueryTimerExtensionWebGL2(),i=s.createQuery();return s.beginQuery(r.TIME_ELAPSED_EXT,i),i}const t=this.getQueryTimerExtensionWebGL1(),e=t.createQueryEXT();return t.beginQueryEXT(t.TIME_ELAPSED_EXT,e),e}endQuery(){if(2===W().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){const e=this.gl,s=this.getQueryTimerExtensionWebGL2();return void e.endQuery(s.TIME_ELAPSED_EXT)}const t=this.getQueryTimerExtensionWebGL1();t.endQueryEXT(t.TIME_ELAPSED_EXT)}waitForQueryAndGetTime(t){var e=this;return te(function*(){return yield N2(()=>e.disposed||e.isQueryAvailable(t,W().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))),e.getQueryTime(t,W().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))})()}getQueryTime(t,e){if(0===e)return null;if(2===e){const s=this.gl;return s.getQueryParameter(t,s.QUERY_RESULT)/1e6}{const s=this.getQueryTimerExtensionWebGL1();return s.getQueryObjectEXT(t,s.QUERY_RESULT_EXT)/1e6}}isQueryAvailable(t,e){if(0===e)return!0;if(2===e){const s=this.gl,r=this.getQueryTimerExtensionWebGL2(),i=s.getQueryParameter(t,s.QUERY_RESULT_AVAILABLE);return null==this.disjoint&&(this.disjoint=this.gl.getParameter(r.GPU_DISJOINT_EXT)),i&&!this.disjoint}{const s=this.getQueryTimerExtensionWebGL1(),r=s.getQueryObjectEXT(t,s.QUERY_RESULT_AVAILABLE_EXT);return null==this.disjoint&&(this.disjoint=this.gl.getParameter(s.GPU_DISJOINT_EXT)),r&&!this.disjoint}}pollFence(t){return new Promise(e=>{this.addItemToPoll(()=>t.isFencePassed(),()=>e())})}pollItems(){const t=function kxe(n){let t=0;for(;t<n.length&&n[t]();++t);return t-1}(this.itemsToPoll.map(e=>e.isDoneFn));for(let e=0;e<=t;++e){const{resolveFn:s}=this.itemsToPoll[e];s()}this.itemsToPoll=this.itemsToPoll.slice(t+1)}addItemToPoll(t,e){if(this.itemsToPoll.push({isDoneFn:t,resolveFn:e}),this.itemsToPoll.length>1)return;let s;"setTimeoutCustom"in W().platform&&(s=W().platform.setTimeoutCustom.bind(W().platform)),N2(()=>(this.pollItems(),0===this.itemsToPoll.length),()=>0,null,s)}bindTextureToFrameBuffer(t){this.throwIfDisposed(),vT(this.gl,t,this.framebuffer),this.debug&&Gv(this.gl)}unbindTextureToFrameBuffer(){null!=this.outputTexture?(vT(this.gl,this.outputTexture,this.framebuffer),this.debug&&Gv(this.gl)):W3(this.gl,this.framebuffer)}downloadMatrixDriver(t,e){this.bindTextureToFrameBuffer(t);const s=e();return this.unbindTextureToFrameBuffer(),s}setOutputMatrixTextureDriver(t,e,s){this.throwIfDisposed();const r=this.gl;vT(r,t,this.framebuffer),this.debug&&Gv(r),this.outputTexture=t,ve(r,()=>r.viewport(0,0,e,s)),ve(r,()=>r.scissor(0,0,e,s))}setOutputMatrixWriteRegionDriver(t,e,s,r){this.throwIfDisposed(),ve(this.gl,()=>this.gl.scissor(t,e,s,r))}throwIfDisposed(){if(this.disposed)throw new Error("Attempted to use disposed GPGPUContext.")}throwIfNoProgram(){if(null==this.program)throw new Error("No GPU program is currently set.")}}const{addImpl:Axe,bincountImpl:rU,bincountReduceImpl:Rxe,castImpl:Mxe,ceilImpl:Fxe,concatImpl:Oxe,equalImpl:$xe,expImpl:Pxe,expm1Impl:Lxe,floorImpl:Vxe,gatherNdImpl:Bxe,gatherV2Impl:zxe,greaterImpl:Uxe,greaterEqualImpl:Wxe,lessImpl:Gxe,lessEqualImpl:Hxe,linSpaceImpl:jxe,logImpl:qxe,maxImpl:Kxe,maximumImpl:Xxe,minimumImpl:Yxe,multiplyImpl:Zxe,negImpl:Qxe,notEqualImpl:Jxe,prodImpl:e0e,raggedGatherImpl:t0e,raggedRangeImpl:n0e,raggedTensorToTensorImpl:s0e,rangeImpl:r0e,rsqrtImpl:i0e,scatterImpl:o0e,sigmoidImpl:a0e,simpleAbsImpl:iU,sliceImpl:l0e,sparseFillEmptyRowsImpl:u0e,sparseReshapeImpl:c0e,sparseSegmentReductionImpl:oU,sqrtImpl:d0e,staticRegexReplaceImpl:h0e,stridedSliceImpl:f0e,stringNGramsImpl:p0e,stringSplitImpl:m0e,stringToHashBucketFastImpl:g0e,subImpl:y0e,tileImpl:b0e,topKImpl:v0e,transposeImpl:IT,uniqueImpl:_0e}=T;function aU(n,t){return["x","y","z","w","u","v"].slice(0,t).map(e=>`${n}.${e}`)}function Zs(n,t){return 1===t?[n]:aU(n,t)}class x0e{constructor(t){if(this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outputShape=t,this.rank=t.length,this.enableShapeUniforms=Us(this.outputShape.length),0===this.rank)this.userCode="\n        void main() {\n          setOutput(vec4(getA(), 0., 0., 0.));\n        }\n      ";else{const e=Zs("rc",this.rank),s=Xt(this.rank),r=this.getOutOfBoundsCondition(e),i=this.getSetup(e),o=this.getOutput(e);this.userCode=`\n        void main() {\n          ${s} rc = getOutputCoords();\n\n          if(${r}) {\n            setOutput(vec4(0));\n          } else {\n            ${i}\n\n            setOutput(vec4(${o}));\n          }\n        }\n      `}}getSourceCoordsArr(t){const e=[];for(let s=0;s<=1;s++)for(let r=0;r<=1;r++){let i=`${0===s?"r":"rp1"}, ${0===r?"c":"cp1"}`;for(let o=2;o<this.rank;o++)i=`${t[t.length-1-o]},`+i;e.push(i)}return e}getOutOfBoundsCondition(t){if(1===this.rank)return`rc > ${this.enableShapeUniforms?"outShape":this.outputShape[0]}`;let e="";for(let s=this.rank-2;s<this.rank;s++)e+=`${t[s]} >= ${this.enableShapeUniforms?`outShape[${s}]`:this.outputShape[s]}`,s<this.rank-1&&(e+="||");return e}getSetup(t){if(1===this.rank)return"";const e=t.slice(-2);return`\n      int r = ${e[0]};\n      int c = ${e[1]};\n      int rp1 = r + 1;\n      int cp1 = c + 1;\n\n      bool cEdge = cp1 >= ${this.enableShapeUniforms?`outShape[${this.rank} - 1]`:this.outputShape[this.rank-1]};\n      bool rEdge = rp1 >= ${this.enableShapeUniforms?`outShape[${this.rank} - 2]`:this.outputShape[this.rank-2]};\n    `}getOutput(t){const e=this.getSourceCoordsArr(t);return 1===this.rank?`getA(rc), (rc + 1 >= ${this.enableShapeUniforms?"outShape":this.outputShape[0]} ? 0. : getA(rc + 1)), 0, 0`:`getA(${e[0]}),\n            cEdge ? 0. : getA(${e[1]}),\n            rEdge ? 0. : getA(${e[2]}),\n            rEdge || cEdge ? 0. : getA(${e[3]})`}}class lU{constructor(t,e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec3"}],this.outputShape=t,this.enableShapeUniforms=Us(this.outputShape.length);let s="";for(let r=0;r<4;r++){let i="thisRC = rc;";r%2==1&&(i+="thisRC.z += 1;"),r>1&&(i+="thisRC.y += 1;"),s+=`\n        ${i}\n        ${r>0?"if(thisRC.y < rows && thisRC.z < cols){":""}\n          int flatIndex = getFlatIndex(thisRC);\n\n          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);\n          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));\n\n          result[${r}] =\n            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);\n        ${r>0?"}":""}\n      `}this.userCode=`\n      ${function C0e(n,t){return`\n    ivec3 inputCoordsFromReshapedOutCoords(int index) {\n      ${t?function xwe(n,t,e="index"){const r=function wwe(n,t){const e=n.length,s=n.map(i=>`${t}[${i}]`),r=new Array(e-1);r[e-2]=s[e-1];for(let i=e-3;i>=0;--i)r[i]=`(${r[i+1]} * ${s[i+1]})`;return r}(n.map((i,o)=>o),t);return r.map((i,o)=>`int ${n[o]} = ${e} / ${r[o]}; ${o===r.length-1?`int ${n[o+1]} = ${e} - ${n[o]} * ${r[o]}`:`index -= ${n[o]} * ${r[o]}`};`).join("")}(["r","c","d"],"inputShape"):wu(["r","c","d"],n)}\n      return ivec3(r, c, d);\n    }\n  `}(e,this.enableShapeUniforms)}\n      ${this.enableShapeUniforms?"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n":wT(t)}\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0.);\n\n        ivec3 thisRC;\n        int rows = ${this.enableShapeUniforms?"outShape[1]":t[1]};\n        int cols = ${this.enableShapeUniforms?"outShape[2]":t[2]};\n\n        ${s}\n\n        setOutput(result);\n      }\n    `}}class S0e{constructor(t){this.gpgpu=t,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0,this.freeTextures={},this.usedTextures={},this.logEnabled=!1}acquireTexture(t,e,s){const r=cU(e,s),i=dU(t,r,s);i in this.freeTextures||(this.freeTextures[i]=[]),i in this.usedTextures||(this.usedTextures[i]=[]);const o=uU(t,r,this.gpgpu.gl,this.gpgpu.textureConfig,s);if(this.freeTextures[i].length>0){this.numFreeTextures--,this.numUsedTextures++,this._numBytesFree-=o,this.log();const l=this.freeTextures[i].pop();return this.usedTextures[i].push(l),l}let a;return r===Kt.PACKED_2X2_FLOAT32?a=this.gpgpu.createPackedMatrixTexture(t[0],t[1]):r===Kt.PACKED_2X2_FLOAT16?a=this.gpgpu.createFloat16PackedMatrixTexture(t[0],t[1]):r===Kt.UNPACKED_FLOAT32?a=this.gpgpu.createFloat32MatrixTexture(t[0],t[1]):r===Kt.UNPACKED_FLOAT16?a=this.gpgpu.createFloat16MatrixTexture(t[0],t[1]):r===Kt.PACKED_4X1_UNSIGNED_BYTE&&(a=this.gpgpu.createUnsignedBytesMatrixTexture(t[0],t[1])),this.usedTextures[i].push(a),this.numUsedTextures++,this._numBytesAllocated+=o,this.log(),a}releaseTexture(t,e,s,r){if(null==this.freeTextures)return;const i=cU(s,r),o=dU(e,i,r);o in this.freeTextures||(this.freeTextures[o]=[]);const a=uU(e,i,this.gpgpu.gl,this.gpgpu.textureConfig,r),l=W().get("WEBGL_DELETE_TEXTURE_THRESHOLD");-1!==l&&this._numBytesAllocated>l?(this.gpgpu.deleteMatrixTexture(t.texture),this._numBytesAllocated-=a):(this.freeTextures[o].push(t),this.numFreeTextures++,this._numBytesFree+=a),this.numUsedTextures--;const u=this.usedTextures[o],c=u&&u.indexOf(t);if(null==c||c<0)throw new Error("Cannot release a texture that was never provided by this texture manager");u[c]=u[u.length-1],u.pop(),this.log()}log(){if(!this.logEnabled)return;console.log("Free/Used",`${this.numFreeTextures} / ${this.numUsedTextures}`,`(${this.numFreeTextures+this.numUsedTextures})`);const e=this._numBytesFree/this._numBytesAllocated;console.log(`Bytes allocated: ${this._numBytesAllocated}`),console.log(`Bytes unused: ${this._numBytesFree} (${Math.round(100*e)}%)`)}get numBytesAllocated(){return this._numBytesAllocated}get numBytesFree(){return this._numBytesFree}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){if(null!=this.freeTextures){for(const t in this.freeTextures)this.freeTextures[t].forEach(e=>{this.gpgpu.deleteMatrixTexture(e.texture)});for(const t in this.usedTextures)this.usedTextures[t].forEach(e=>{this.gpgpu.deleteMatrixTexture(e.texture)});this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0}}}function uU(n,t,e,s,r){const i=function E0e(n,t){switch(n){case Kt.PACKED_2X2_FLOAT32:return nU(t);case Kt.PACKED_2X2_FLOAT16:return sU(t);case Kt.UNPACKED_FLOAT32:return J3(t);case Kt.UNPACKED_FLOAT16:return eU(t);case Kt.PACKED_4X1_UNSIGNED_BYTE:return tU(t);default:throw new Error(`Unknown physical texture type ${n}`)}}(t,s);let o;if(r){const[l,u]=bd(n[0],n[1]);o=l*u}else{const[l,u]=Lp(n[0],n[1]);o=l*u}const a=function I0e(n,t){if(t===n.R32F)return 4;if(t===n.R16F)return 2;if(t===n.RGBA32F)return 16;if(t===n.RGBA)return 16;if(t===n.RGBA16F)return 8;if(t===n.RGBA8)return 4;throw new Error(`Unknown internal format ${t}`)}(e,i);return o*a}function cU(n,t){if(n===Vn.UPLOAD)return Kt.PACKED_2X2_FLOAT32;if(n===Vn.RENDER||null==n)return function D0e(n){return W().getBool("WEBGL_RENDER_FLOAT32_ENABLED")?n?Kt.PACKED_2X2_FLOAT32:Kt.UNPACKED_FLOAT32:n?Kt.PACKED_2X2_FLOAT16:Kt.UNPACKED_FLOAT16}(t);if(n===Vn.DOWNLOAD||n===Vn.PIXELS)return Kt.PACKED_4X1_UNSIGNED_BYTE;throw new Error(`Unknown logical texture type ${n}`)}function dU(n,t,e){return`${n[0]}_${n[1]}_${t}_${e}`}class Fo{constructor(t,e){this.variableNames=["A"],this.outputShape=t,this.enableShapeUniforms=Us(this.outputShape.length),this.userCode=`\n      float unaryOperation(float x) {\n        ${e}\n      }\n\n      void main() {\n        float x = getAAtOutCoords();\n        float y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    `}}const Jr="if (isnan(x)) return x;",T0e="return x;",hU="return abs(x);",N0e="return (x >= 0.0) ? x : (exp(x) - 1.0);",k0e=Jr+"\n  return (x < 0.0) ? 0.0 : x;\n",A0e=Jr+"\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n",hl="return x;",R0e="return 1.0 / (1.0 + exp(-1.0 * x));",M0e="return x;",F0e="\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n",O0e="\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",$0e="\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",P0e="return 1.0 / (1.0 + exp(-1.0 * x));";class fl{constructor(t,e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t,this.enableShapeUniforms=Us(this.outputShape.length),this.userCode=`\n      vec4 unaryOperation(vec4 x) {\n        ${e}\n      }\n\n      void main() {\n        vec4 x = getAAtOutCoords();\n        vec4 y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    `}}class L0e{constructor(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outputShape=t,this.enableShapeUniforms=Us(this.outputShape.length);const e=t.length,s=Zs("rc",e),r=Xt(e),i=function w0e(n,t){if(1===n)return"rc";let e="";for(let s=0;s<n;s++)e+=t[s],s<n-1&&(e+=",");return e}(e,s),o=s.slice(-2),a=e<=1?"rc":`vec2(${o.join(",")})`;this.userCode=`\n      void main() {\n        ${r} rc = getOutputCoords();\n        vec4 packedInput = getA(${i});\n\n        setOutput(getChannel(packedInput, ${a}));\n      }\n    `}}const V0e=pE,Qv={},W0e=W().getNumber("CPU_HANDOFF_SIZE_THRESHOLD");let j0e=(()=>{class n extends OC{nextDataId(){return n.nextDataId++}constructor(e){if(super(),this.pendingRead=new WeakMap,this.pendingDisposal=new WeakSet,this.dataRefCount=new WeakMap,this.numBytesInGPU=0,this.uploadWaitMs=0,this.downloadWaitMs=0,this.lastGlFlushTime=0,this.warnedAboutMemory=!1,this.pendingDeletes=0,this.disposed=!1,!W().getBool("HAS_WEBGL"))throw new Error("WebGL is not supported on this device");let s;if(null!=e){if(e instanceof ST)s=e;else{const r=Yi(W().getNumber("WEBGL_VERSION"),e);s=new ST(r)}this.binaryCache={},this.gpgpuCreatedLocally=!1}else{const r=Yi(W().getNumber("WEBGL_VERSION"));s=new ST(r),this.binaryCache=function U0e(n){return n in Qv||(Qv[n]={}),Qv[n]}(W().getNumber("WEBGL_VERSION")),this.gpgpuCreatedLocally=!0}this.gpgpu=s,this.canvas=this.gpgpu.gl.canvas,this.textureManager=new S0e(this.gpgpu),this.numMBBeforeWarning=function H0e(){return null==W().global.screen?1024:W().global.screen.height*W().global.screen.width*window.devicePixelRatio*600/1024/1024}(),this.texData=new D2(this,vo())}numDataIds(){return this.texData.numDataIds()-this.pendingDeletes}writeTexture(e,s,r,i,o,a){const l=this.makeTensorInfo(s,r),u=this.texData.get(l.dataId);u.isPacked=!1,u.texture={texture:e,texShape:[i,o]},u.texShape=[i,o];const c=Hv(s),d=new Q3(c,!1,a),h=this.runWebGLProgram(d,[l],r,[[i,o]]);return h.shape=s,u.texture=null,this.disposeIntermediateTensorInfo(l),h.dataId}write(e,s,r){if((W().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS")||W().getBool("DEBUG"))&&this.checkNumericalProblems(e),"complex64"===r&&null!=e)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");const i={id:this.nextDataId()};return this.texData.set(i,{shape:s,dtype:r,values:e,usage:Vn.UPLOAD,refCount:1}),i}refCount(e){return this.texData.has(e)?this.texData.get(e).refCount:0}incRef(e){this.texData.get(e).refCount++}decRef(e){this.texData.has(e)&&this.texData.get(e).refCount--}move(e,s,r,i,o){if(W().getBool("DEBUG")&&this.checkNumericalProblems(s),"complex64"===i)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.texData.set(e,{shape:r,dtype:i,values:s,usage:Vn.UPLOAD,refCount:o})}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}readSync(e){const s=this.texData.get(e),{values:r,dtype:i,complexTensorInfos:o,slice:a,shape:l,isPacked:u}=s;if(null!=a){let f;f=u?new fl(l,hl):new Fo(l,hl);const p=this.runWebGLProgram(f,[{dataId:e,shape:l,dtype:i}],i),g=this.readSync(p.dataId);return this.disposeIntermediateTensorInfo(p),g}if(null!=r)return this.convertAndCacheOnCPU(e);if("string"===i)return r;const c=null!=this.activeTimers;let d,h;return c&&(d=ir()),h="complex64"===i?ca(this.readSync(o.real.dataId),this.readSync(o.imag.dataId)):this.getValuesFromTexture(e),c&&(this.downloadWaitMs+=ir()-d),this.convertAndCacheOnCPU(e,h)}read(e){var s=this;return te(function*(){if(s.pendingRead.has(e)){const m=s.pendingRead.get(e);return new Promise(y=>m.push(y))}const r=s.texData.get(e),{values:i,shape:o,slice:a,dtype:l,complexTensorInfos:u,isPacked:c}=r;if(null!=a){let m;m=c?new fl(o,hl):new Fo(o,hl);const y=s.runWebGLProgram(m,[{dataId:e,shape:o,dtype:l}],l),b=s.read(y.dataId);return s.disposeIntermediateTensorInfo(y),b}if(null!=i)return s.convertAndCacheOnCPU(e);if(W().getBool("DEBUG")&&!W().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&2===W().getNumber("WEBGL_VERSION"))throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");let h,f,d=null;if("complex64"!==l&&W().get("WEBGL_BUFFER_SUPPORTED")){h=s.decode(e);const m=s.texData.get(h.dataId);d=s.gpgpu.createBufferFromTexture(m.texture.texture,...Uv(o))}if(s.pendingRead.set(e,[]),"complex64"!==l&&(yield s.gpgpu.createAndWaitForFence()),"complex64"===l){const m=yield Promise.all([s.read(u.real.dataId),s.read(u.imag.dataId)]);f=ca(m[0],m[1])}else if(null==d)f=s.getValuesFromTexture(e);else{const m=X(o);f=s.gpgpu.downloadFloat32MatrixFromBuffer(d,m)}if(null!=h&&s.disposeIntermediateTensorInfo(h),null!=d){const m=s.gpgpu.gl;ve(m,()=>m.deleteBuffer(d))}const p=s.convertAndCacheOnCPU(e,f),g=s.pendingRead.get(e);return s.pendingRead.delete(e),g.forEach(m=>m(p)),s.pendingDisposal.has(e)&&(s.pendingDisposal.delete(e),s.disposeData(e)&&vo().removeDataId(e,s),s.pendingDeletes--),p})()}readToGPU(e,s={}){const r=this.texData.get(e),{values:i,shape:o,slice:a,dtype:l,isPacked:u,texture:c}=r;if("complex64"===l)throw new Error("Does not support reading texture for complex64 dtype.");if(null!=a){let p;p=u?new fl(o,hl):new Fo(o,hl);const g=this.runWebGLProgram(p,[{dataId:e,shape:o,dtype:l}],l),m=this.readToGPU(g,s);return this.disposeIntermediateTensorInfo(g),m}if(null==c)throw null!=i?new Error("Data is not on GPU but on CPU."):new Error("There is no data on GPU or CPU.");const d=this.decode(e,s.customTexShape),h=vo().makeTensorFromTensorInfo(d),f=this.texData.get(d.dataId);return Object.assign({tensorRef:h},f.texture)}bufferSync(e){const s=this.readSync(e.dataId);if("string"===e.dtype)try{const r=s.map(i=>La(i));return dt(e.shape,e.dtype,r)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return dt(e.shape,e.dtype,s)}checkNumericalProblems(e){if(null!=e)for(let s=0;s<e.length;s++){const r=e[s];if(!Y_e(r))throw W().getBool("WEBGL_RENDER_FLOAT32_CAPABLE")?Error(`The value ${r} cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'`):Error(`The value ${r} cannot be represented on this device.`)}}getValuesFromTexture(e){const{shape:s,dtype:r,isPacked:i}=this.texData.get(e),o=X(s);if(W().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")){const f=this.decode(e),p=this.texData.get(f.dataId),g=this.gpgpu.downloadMatrixFromPackedTexture(p.texture.texture,...Uv(s)).subarray(0,o);return this.disposeIntermediateTensorInfo(f),g}const a=W().getBool("WEBGL_PACK")&&!0===i,l=a?Hv(s):s,u=a?new dxe(l):new cxe(l),c=this.runWebGLProgram(u,[{shape:l,dtype:r,dataId:e}],"float32"),d=this.texData.get(c.dataId),h=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(d.texture.texture,d.texShape[0],d.texShape[1]).subarray(0,o);return this.disposeIntermediateTensorInfo(c),h}timerAvailable(){return W().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0}time(e){var s=this;const r=this.activeTimers,i=[];let o=!1;null==this.programTimersStack?(this.programTimersStack=i,o=!0):this.activeTimers.push(i),this.activeTimers=i,e();const a=tu(this.activeTimers.map(c=>c.query)).filter(c=>null!=c),l=tu(this.activeTimers.map(c=>c.name)).filter(c=>null!=c);this.activeTimers=r,o&&(this.programTimersStack=null);const u={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null};return te(function*(){if(W().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0){const c=yield Promise.all(a);u.kernelMs=function Nee(n){let t=0;for(let e=0;e<n.length;e++)t+=n[e];return t}(c),u.getExtraProfileInfo=()=>c.map((d,h)=>({name:l[h],ms:d})).map(d=>`${d.name}: ${d.ms}`).join(", ")}else u.kernelMs={error:"WebGL query timers are not supported in this environment."};return s.uploadWaitMs=0,s.downloadWaitMs=0,u})()}memory(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU,numBytesInGPUAllocated:this.textureManager.numBytesAllocated,numBytesInGPUFree:this.textureManager.numBytesFree}}startTimer(){return W().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.beginQuery():{startMs:ir(),endMs:null}}endTimer(e){return W().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?(this.gpgpu.endQuery(),e):(e.endMs=ir(),e)}getQueryTime(e){var s=this;return te(function*(){return W().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?s.gpgpu.waitForQueryAndGetTime(e):e.endMs-e.startMs})()}disposeData(e,s=!1){if(this.pendingDisposal.has(e))return!1;if(!this.texData.has(e))return!0;if(s?this.texData.get(e).refCount=0:this.texData.get(e).refCount--,!s&&this.texData.get(e).refCount>0)return!1;if(this.pendingRead.has(e))return this.pendingDisposal.add(e),this.pendingDeletes++,!1;this.releaseGPUData(e);const{complexTensorInfos:r}=this.texData.get(e);return null!=r&&(this.disposeData(r.real.dataId,s),this.disposeData(r.imag.dataId,s)),this.texData.delete(e),!0}releaseGPUData(e){const{texture:s,dtype:r,texShape:i,usage:o,isPacked:a,slice:l}=this.texData.get(e),u=l&&l.origDataId||e,c=this.dataRefCount.get(u);c>1?this.dataRefCount.set(u,c-1):(this.dataRefCount.delete(u),null!=s&&(this.numBytesInGPU-=this.computeBytes(i,r),this.textureManager.releaseTexture(s,i,o,a)));const d=this.texData.get(e);d.texture=null,d.texShape=null,d.isPacked=!1,d.slice=null}getTexture(e){return this.uploadToGPU(e),this.texData.get(e).texture.texture}getDataInfo(e){return this.texData.get(e)}shouldExecuteOnCPU(e,s=W0e){return W().getBool("WEBGL_CPU_FORWARD")&&e.every(r=>null==this.texData.get(r.dataId).texture&&X(r.shape)<s)}getGPGPUContext(){return this.gpgpu}where(e){Gr("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");const s=e.dataSync();return V0e(e.shape,s)}packedUnaryOp(e,s,r){const i=new fl(e.shape,s),o=this.compileAndRun(i,[e],r);return vo().makeTensorFromTensorInfo(o)}abs(e){if(this.shouldExecuteOnCPU([e])&&"complex64"!==e.dtype){const i=iU(this.texData.get(e.dataId).values);return this.makeOutput(e.shape,e.dtype,i)}if(W().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(e,hU,e.dtype);const s=new Fo(e.shape,hU),r=this.compileAndRun(s,[e]);return vo().makeTensorFromTensorInfo(r)}makeTensorInfo(e,s,r){let i;if("string"===s&&null!=r&&r.length>0&&Jh(r[0])){const o=r.map(a=>Pa(a));i=this.write(o,e,s)}else i=this.write(r,e,s);return this.texData.get(i).usage=null,{dataId:i,shape:e,dtype:s}}makeOutput(e,s,r){return vo().makeTensorFromTensorInfo(this.makeTensorInfo(e,s,r),this)}unpackTensor(e){const s=new L0e(e.shape);return this.runWebGLProgram(s,[e],e.dtype)}packTensor(e){const s=new x0e(e.shape);return this.runWebGLProgram(s,[e],e.dtype,null,!0)}packedReshape(e,s){const r=[vd(e.shape),..._d(e.shape)],i={dtype:e.dtype,shape:r,dataId:e.dataId},o=[vd(s),..._d(s)],a=new lU(o,r),c=this.runWebGLProgram(a,[i],e.dtype,[r],!0);return{dataId:c.dataId,shape:s,dtype:c.dtype}}decode(e,s){const r=this.texData.get(e),{isPacked:i,shape:o,dtype:a}=r;null!=s&&S(X(o)<=s[0]*s[1]*4,()=>"customTexShape is too small. Row * Column * 4 should be equal or larger than the size of the tensor data.");const l=Hv(o);let u;u=i?new uxe(l):new lxe(l);const d=[s??Uv(l)];return{dtype:a,shape:o,dataId:this.runWebGLProgram(u,[{shape:l,dtype:a,dataId:e}],a,d,!0,s).dataId}}runWebGLProgram(e,s,r,i,o=!1,a){const l=this.makeTensorInfo(e.outputShape,r),u=this.texData.get(l.dataId);if(e.packedOutput&&(u.isPacked=!0),e.outPackingScheme===Mo.DENSE){const b=a??Uv(e.outputShape);u.texShape=b.map(v=>2*v)}if(null!=e.outTexUsage&&(u.usage=e.outTexUsage),0===X(l.shape))return u.values=Ds(l.dtype,0),l;const c=[],d=s.map(b=>{if("complex64"===b.dtype)throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");let v=this.texData.get(b.dataId);if(null==v.texture){if(!e.packedInputs&&X(b.shape)<=W().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))return{shape:b.shape,texData:null,isUniform:!0,uniformValues:v.values};e.packedInputs&&(v.isPacked=!0,v.shape=b.shape)}if(this.uploadToGPU(b.dataId),!!v.isPacked!=!!e.packedInputs)b=v.isPacked?this.unpackTensor(b):this.packTensor(b),c.push(b),v=this.texData.get(b.dataId);else if(v.isPacked&&!qv(v.shape,b.shape)){const _=b,x=b.shape;b.shape=v.shape,b=this.packedReshape(b,x),c.push(b),v=this.texData.get(b.dataId),_.shape=x}return{shape:b.shape,texData:v,isUniform:!1}});this.uploadToGPU(l.dataId);const h={shape:l.shape,texData:u,isUniform:!1},f=function axe(n,t,e){let s="";t.concat(e).forEach(o=>{const a=null!=o.texData&&null!=o.texData.slice&&o.texData.slice.flatOffset>0;if(n.enableShapeUniforms&&!o.isUniform){const l=o.texData.texShape,{useSqueezeShape:u,uniformShape:c,keptDims:d}=CT(n.packedInputs,o.shape,l);let h="",f="",p="";if(1===c.length&&n.packedInputs){const x=[Math.ceil(l[0]/2),Math.ceil(l[1]/2)];h=`${x[0]>1}_${x[1]>1}`}else if(2!==c.length||n.packedInputs){if(c.length>2&&!n.packedInputs){const x=Be(c);p=`${x[0]===l[1]}_${x[x.length-1]===l[1]}`}}else f=`${c[0]>1}_${c[1]>1}`;const g=o.shape.length,m=2===c.length&&wt(o.shape,l),y=1===X(o.shape),b=Zc(o.shape,e.shape),v=!n.packedInputs&&g===e.shape.length&&wt(l,e.texData.texShape);s+=`${g}_${v}_${u?d:""}_${c.length}_${y}_${b}_${m}_${h}_${f}_${p}_${n.packedInputs||c.length>2?"":`${l[0]>1}_${l[1]>1}`}_${a}`}else s+=`${o.shape}_${o.isUniform?"uniform":o.texData.texShape}_${a}`});let i=n.constructor.name;return i+="_"+s+"_"+n.userCode+`${W().getNumber("WEBGL_VERSION")}`,i}(e,d,h),p=this.getAndSaveBinary(f,()=>function ixe(n,t,e,s){const r=e.map((c,d)=>{const h={logicalShape:c.shape,texShape:c.isUniform?null:c.texData.texShape,isUniform:c.isUniform,isPacked:!c.isUniform&&c.texData.isPacked,flatOffset:null};return null!=c.texData&&null!=c.texData.slice&&c.texData.slice.flatOffset>0&&(h.flatOffset=c.texData.slice.flatOffset),{name:t.variableNames[d],shapeInfo:h}}),i=r.map(c=>c.shapeInfo),o={logicalShape:s.shape,texShape:s.texData.texShape,isUniform:!1,isPacked:s.texData.isPacked,flatOffset:null},a=Cwe(r,o,t),l=function J_e(n,t){const e=ga(n,()=>n.createShader(n.FRAGMENT_SHADER),"Unable to create fragment WebGLShader.");if(ve(n,()=>n.shaderSource(e,t)),ve(n,()=>n.compileShader(e)),W().get("ENGINE_COMPILE_ONLY"))return e;if(!1===n.getShaderParameter(e,n.COMPILE_STATUS))throw z3(t,n.getShaderInfoLog(e)),new Error("Failed to compile fragment shader.");return e}(n.gl,a),u=n.createProgram(l);return W().get("ENGINE_COMPILE_ONLY")?{program:t,fragmentShader:l,source:a,webGLProgram:u,inShapeInfos:i,outShapeInfo:o,variablesLocations:null,customUniformLocations:null,infLoc:null,nanLoc:null,outShapeLocation:null,outShapeStridesLocation:null,outTexShapeLocation:null}:(n.buildVao(u),Object.assign({program:t,fragmentShader:l,source:a,webGLProgram:u,inShapeInfos:i,outShapeInfo:o},Y3(n,t,u)))}(this.gpgpu,e,d,h)),g=null!=this.activeTimers;let m;g&&(m=this.startTimer()),W().get("ENGINE_COMPILE_ONLY")||function oxe(n,t,e,s,r){t.program.enableShapeUniforms||(Z3(t.inShapeInfos,e),Z3([t.outShapeInfo],[s]));const i=s.texData.texture,o=s.texData.texShape;s.texData.isPacked?n.setOutputPackedMatrixTexture(i.texture,o[0],o[1]):n.setOutputMatrixTexture(i.texture,o[0],o[1]),n.setProgram(t.webGLProgram),n.bindVertexArray(t.webGLProgram.vao),1===W().getNumber("WEBGL_VERSION")&&null!==t.infLoc&&n.gl.uniform1f(t.infLoc,1/0),null!==t.nanLoc&&n.gl.uniform1f(t.nanLoc,NaN);for(let l=0;l<e.length;++l){const u=e[l],{uniform:c,offset:d,shape:h,texShape:f}=t.variablesLocations[l];if(h){const{uniformShape:p}=CT(t.program.packedInputs,u.shape,u.texData.texShape);switch(p.length){case 1:n.gl.uniform1iv(h,new Int32Array(p));break;case 2:n.gl.uniform2iv(h,new Int32Array(p));break;case 3:n.gl.uniform3iv(h,new Int32Array(p));break;case 4:n.gl.uniform4iv(h,new Int32Array(p))}}if(f&&n.gl.uniform2i(f,u.texData.texShape[0],u.texData.texShape[1]),null!=c){if(u.isUniform){if(X(u.shape)<2)n.gl.uniform1f(c,u.uniformValues[0]);else{let p=u.uniformValues;p instanceof Float32Array||(p=new Float32Array(p)),n.gl.uniform1fv(c,p)}continue}null!=u.texData.slice&&null!=d&&n.gl.uniform1i(d,u.texData.slice.flatOffset),n.setInputMatrixTexture(u.texData.texture.texture,c,l)}}const a=t.outShapeLocation;if(a)switch(s.shape.length){case 1:n.gl.uniform1iv(a,new Int32Array(s.shape));break;case 2:n.gl.uniform2iv(a,new Int32Array(s.shape));break;case 3:n.gl.uniform3iv(a,new Int32Array(s.shape));break;case 4:n.gl.uniform4iv(a,new Int32Array(s.shape))}if(t.outShapeStridesLocation){const l=Be(s.shape);switch(s.shape.length){case 2:n.gl.uniform1iv(t.outShapeStridesLocation,new Int32Array(l));break;case 3:n.gl.uniform2iv(t.outShapeStridesLocation,new Int32Array(l));break;case 4:n.gl.uniform3iv(t.outShapeStridesLocation,new Int32Array(l))}}if(t.outTexShapeLocation&&n.gl.uniform2i(t.outTexShapeLocation,s.texData.texShape[0],s.texData.texShape[1]),t.program.customUniforms&&r)for(let l=0;l<t.program.customUniforms.length;++l){const u=t.program.customUniforms[l],c=t.customUniformLocations[l],d=r[l];if("float"===u.type)n.gl.uniform1fv(c,d);else if("vec2"===u.type)n.gl.uniform2fv(c,d);else if("vec3"===u.type)n.gl.uniform3fv(c,d);else if("vec4"===u.type)n.gl.uniform4fv(c,d);else if("int"===u.type)n.gl.uniform1iv(c,d);else if("ivec2"===u.type)n.gl.uniform2iv(c,d);else if("ivec3"===u.type)n.gl.uniform3iv(c,d);else{if("ivec4"!==u.type)throw Error(`uniform type ${u.type} is not supported yet.`);n.gl.uniform4iv(c,d)}}n.executeProgram()}(this.gpgpu,p,d,h,i),c.forEach(b=>this.disposeIntermediateTensorInfo(b)),g&&(m=this.endTimer(m),this.activeTimers.push({name:e.constructor.name,query:this.getQueryTime(m)}));const y=W().get("WEBGL_FLUSH_THRESHOLD");if(y>0){const b=ir();b-this.lastGlFlushTime>y&&(this.gpgpu.gl.flush(),this.lastGlFlushTime=b)}if(!W().getBool("WEBGL_LAZILY_UNPACK")&&u.isPacked&&!1===o){const b=this.unpackTensor(l);return this.disposeIntermediateTensorInfo(l),b}return l}compileAndRun(e,s,r,i,o=!1){return this.runWebGLProgram(e,s,r=r||s[0].dtype,i,o)}getAndSaveBinary(e,s){return e in this.binaryCache||(this.binaryCache[e]=s()),this.binaryCache[e]}getTextureManager(){return this.textureManager}dispose(){this.disposed||(W().getBool("IS_TEST")||Object.keys(this.binaryCache).forEach(s=>{this.gpgpu.deleteProgram(this.binaryCache[s].webGLProgram),delete this.binaryCache[s]}),this.textureManager.dispose(),null!=this.canvas&&typeof HTMLCanvasElement<"u"&&this.canvas instanceof HTMLCanvasElement?this.canvas.remove():this.canvas=null,this.gpgpuCreatedLocally&&(this.gpgpu.program=null,this.gpgpu.dispose()),this.disposed=!0)}floatPrecision(){return null==this.floatPrecisionValue&&(this.floatPrecisionValue=z(()=>{if(!W().get("WEBGL_RENDER_FLOAT32_ENABLED")){const e=W().getBool("DEBUG");W().set("DEBUG",!1);const s=this.abs(ze(1e-8)).dataSync()[0];if(W().set("DEBUG",e),s>0)return 32}return 16})),this.floatPrecisionValue}epsilon(){return 32===this.floatPrecision()?1e-7:1e-4}uploadToGPU(e){const s=this.texData.get(e),{shape:r,dtype:i,values:o,texture:a,usage:l,isPacked:u}=s;if(null!=a)return;const c=null!=this.activeTimers;let d;c&&(d=ir());let h=s.texShape;if(null==h&&(h=function fwe(n,t=!1){let e=W().getNumber("WEBGL_MAX_TEXTURE_SIZE"),s=W().getNumber("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE");s===1/0&&W().getBool("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE")&&(s=e/2),t&&(e*=2,s*=2,1===(n=n.map((a,l)=>l>=n.length-2?$C(n[l]):n[l])).length&&(n=[2,n[0]])),2!==n.length&&(n=Fa(n).newShape);let r=X(n),i=null;n.length<=1&&r<=e?i=[1,r]:2===n.length&&n[0]<=e&&n[1]<=e?i=n:3===n.length&&n[0]*n[1]<=e&&n[2]<=e?i=[n[0]*n[1],n[2]]:3===n.length&&n[0]<=e&&n[1]*n[2]<=e?i=[n[0],n[1]*n[2]]:4===n.length&&n[0]*n[1]*n[2]<=e&&n[3]<=e?i=[n[0]*n[1]*n[2],n[3]]:4===n.length&&n[0]<=e&&n[1]*n[2]*n[3]<=e&&(i=[n[0],n[1]*n[2]*n[3]]);const o=null!=i&&Math.max(...i)>s&&Math.min(...i)<=(t?2:1)&&Math.min(...i)>0;if(null==i||o)if(t){const a=vd(n);let l=2,u=2;n.length&&([l,u]=_d(n)),r=a*(l/2)*(u/2),i=PC(r).map(c=>2*c)}else i=PC(r);return i}(r,u),s.texShape=h),null!=o){const f=Hv(r);let p,g=h[1],m=h[0];const y=o instanceof Uint8Array||o instanceof Uint8ClampedArray;(u||!y)&&([g,m]=bd(h[0],h[1])),p=u?new fxe(f,y):new Q3(f,y);const b=y?[m,g]:h,v=this.makeTensorInfo(b,i),_=this.texData.get(v.dataId);_.usage=y?Vn.PIXELS:Vn.UPLOAD,_.texShape=b,this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(v.dataId),g,m,o);const E=this.runWebGLProgram(p,[v],i,[[m,g]],!0),D=this.texData.get(E.dataId);s.texShape=D.texShape,s.isPacked=D.isPacked,s.usage=D.usage,W().get("ENGINE_COMPILE_ONLY")?this.disposeData(E.dataId):(s.texture=D.texture,s.values=null,this.texData.delete(E.dataId)),this.disposeIntermediateTensorInfo(v),c&&(this.uploadWaitMs+=ir()-d)}else{const f=this.acquireTexture(h,l,i,u);s.texture=f}}convertAndCacheOnCPU(e,s){const r=this.texData.get(e),{dtype:i}=r;return null!=s&&(r.values=function q0e(n,t){if("float32"===t||"complex64"===t)return n;if("int32"===t||"bool"===t){const e="int32"===t?new Int32Array(n.length):new Uint8Array(n.length);for(let s=0;s<e.length;++s)e[s]=Math.round(n[s]);return e}throw new Error(`Unknown dtype ${t}`)}(s,i)),r.values}acquireTexture(e,s,r,i){if(this.numBytesInGPU+=this.computeBytes(e,r),!this.warnedAboutMemory&&this.numBytesInGPU>1024*this.numMBBeforeWarning*1024){const o=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=!0,console.warn(`High memory usage in GPU: ${o} MB, most likely due to a memory leak`)}return this.textureManager.acquireTexture(e,s,i)}computeBytes(e,s){return e[0]*e[1]*py(s)}checkCompileCompletion(){for(const[,e]of Object.entries(this.binaryCache))this.checkCompletion_(e)}checkCompileCompletionAsync(){var e=this;return te(function*(){const s=[];if(e.gpgpu.parallelCompilationExtension){for(const[,r]of Object.entries(e.binaryCache))s.push(e.checkCompletionAsync_(r));return Promise.all(s)}for(const[,r]of Object.entries(e.binaryCache)){const i=new Promise(o=>{try{e.checkCompletion_(r),o(!0)}catch(a){throw a}});s.push(i)}return Promise.all(s)})()}checkCompletionAsync_(e){var s=this;return te(function*(){return s.gpgpu.gl.getProgramParameter(e.webGLProgram,s.gpgpu.parallelCompilationExtension.COMPLETION_STATUS_KHR)?s.checkCompletion_(e):(yield ZL(),s.checkCompletionAsync_(e))})()}checkCompletion_(e){if(!1===this.gpgpu.gl.getProgramParameter(e.webGLProgram,this.gpgpu.gl.LINK_STATUS))throw console.log(this.gpgpu.gl.getProgramInfoLog(e.webGLProgram)),!1===this.gpgpu.gl.getShaderParameter(e.fragmentShader,this.gpgpu.gl.COMPILE_STATUS)?(z3(e.source,this.gpgpu.gl.getShaderInfoLog(e.fragmentShader)),new Error("Failed to compile fragment shader.")):new Error("Failed to link vertex and fragment shaders.");return!0}getUniformLocations(){for(const e of Object.values(this.binaryCache)){this.gpgpu.buildVao(e.webGLProgram);const{variablesLocations:s,customUniformLocations:r,infLoc:i,nanLoc:o,outShapeLocation:a,outShapeStridesLocation:l,outTexShapeLocation:u}=Y3(this.gpgpu,e.program,e.webGLProgram);e.variablesLocations=s,e.customUniformLocations=r,e.infLoc=i,e.nanLoc=o,e.outShapeLocation=a,e.outShapeStridesLocation=l,e.outTexShapeLocation=u}}createTensorFromGPUData(e,s,r){e.channels=e.channels||"RGBA";const{texture:i,height:o,width:a,channels:l}=e,u=vo().backend;if(!u.gpgpu.gl.isTexture(i))throw new Error("The texture is invalid. Also, please make sure the texture and the TFJS WebGL backend are using the same canvas. If you want to use your own custom canvas, you have to create and use the custom TFJS WebGL backend created from the canvas through 'new tf.MathBackendWebGL(customCanvas)'.");const c=u.writeTexture(i,s,r,o,a,l);return vo().makeTensorFromDataId(c,s,r,u)}}return n.nextDataId=0,n})();eP()&&vP("webgl",()=>new j0e,2);const ET="\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n";class Id{constructor(t,e,s){this.variableNames=["A","B"],this.outputShape=nt(e,s),this.enableShapeUniforms=Us(this.outputShape.length),this.userCode=`\n      float binaryOperation(float a, float b) {\n        ${t}\n      }\n\n      void main() {\n        float a = getAAtOutCoords();\n        float b = getBAtOutCoords();\n        setOutput(binaryOperation(a, b));\n      }\n    `}}const Cu="\n  result.r = isNaN.r ? NAN : result.r;\n  result.g = isNaN.g ? NAN : result.g;\n  result.b = isNaN.b ? NAN : result.b;\n  result.a = isNaN.a ? NAN : result.a;\n";class zp{constructor(t,e,s,r=!1){this.variableNames=["A","B"],this.supportsBroadcasting=!0,this.packedInputs=!0,this.packedOutput=!0,this.outputShape=nt(e,s);const i=this.outputShape.length;this.enableShapeUniforms=Us(i);let o="";if(r)if(0===i||1===X(this.outputShape))o="\n          result.y = 0.;\n          result.z = 0.;\n          result.w = 0.;\n        ";else if(o=`\n          ${Xt(i)} coords = getOutputCoords();\n        `,1===i)o+=this.enableShapeUniforms?"\n            result.y = (coords + 1) >= outShape ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          ":`\n            result.y = (coords + 1) >= ${this.outputShape[0]} ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          `;else{const l=Zs("coords",i);o+=this.enableShapeUniforms?`\n            bool nextRowOutOfBounds =\n              (${l[i-2]} + 1) >= outShape[${i} - 2];\n            bool nextColOutOfBounds =\n              (${l[i-1]} + 1) >= outShape[${i} - 1];\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          `:`\n            bool nextRowOutOfBounds =\n              (${l[i-2]} + 1) >= ${this.outputShape[i-2]};\n            bool nextColOutOfBounds =\n              (${l[i-1]} + 1) >= ${this.outputShape[i-1]};\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          `}this.userCode=`\n      vec4 binaryOperation(vec4 a, vec4 b) {\n        ${t}\n      }\n\n      void main() {\n        vec4 a = getAAtOutCoords();\n        vec4 b = getBAtOutCoords();\n\n        vec4 result = binaryOperation(a, b);\n        ${o}\n\n        setOutput(result);\n      }\n    `}}function Ar(n){const{inputs:t,backend:e}=n,{x:s}=t;return e.incRef(s.dataId),{dataId:s.dataId,shape:s.shape,dtype:s.dtype}}const Y0e={kernelName:Cf,backendName:"webgl",kernelFunc:Ar};function pl(n){const{inputs:t,backend:e}=n,{real:s,imag:r}=t,i=e.makeTensorInfo(s.shape,"complex64"),o=e.texData.get(i.dataId),a=Ar({inputs:{x:s},backend:e}),l=Ar({inputs:{x:r},backend:e});return o.complexTensorInfos={real:a,imag:l},i}const Z0e={kernelName:ZC,backendName:"webgl",kernelFunc:pl},fU="return (a < 0.) ? b * a : a;",pU="\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n",J0e={kernelName:$y,backendName:"webgl",kernelFunc:function Q0e(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{alpha:i}=s,o=e.makeTensorInfo([],"float32",$a(i,"float32")),a=W().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new zp(pU,r.shape,o.shape):new Id(fU,r.shape,o.shape),l=e.runWebGLProgram(a,[r,o],"float32");return e.disposeIntermediateTensorInfo(o),l}},mU="return (a < 0.) ? b * a : a;",gU="\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n",tCe={kernelName:tb,backendName:"webgl",kernelFunc:function eCe(n){const{inputs:t,backend:e}=n,{x:s,alpha:r}=t,i=W().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new zp(gU,s.shape,r.shape):new Id(mU,s.shape,r.shape);return e.runWebGLProgram(i,[s,r],"float32")}},Ed="if (isnan(x)) return x;";function Nt({opSnippet:n,packedOpSnippet:t,cpuKernelImpl:e,dtype:s}){return({inputs:r,backend:i})=>{const{x:o}=r,a=i,l=s||o.dtype;if(a.shouldExecuteOnCPU([o])&&null!=e){const d=a.texData.get(o.dataId),h=e(d.values,l);return a.makeTensorInfo(o.shape,l,h)}let c;return c=W().getBool("WEBGL_PACK_UNARY_OPERATIONS")&&null!=t?new fl(o.shape,t):new Fo(o.shape,n),a.runWebGLProgram(c,[o],l)}}function As({opSnippet:n,packedOpSnippet:t,checkOutOfBounds:e=!1,supportsComplex:s=!1,cpuKernelImpl:r,dtype:i}){return({inputs:o,backend:a})=>{const{a:l,b:u}=o,c=a;if(s&&"complex64"===l.dtype){const p=c.texData.get(l.dataId),g=c.texData.get(u.dataId),[m,y]=[[p.complexTensorInfos.real,g.complexTensorInfos.real],[p.complexTensorInfos.imag,g.complexTensorInfos.imag]].map(v=>{const[_,x]=v,C={dataId:_.dataId,dtype:_.dtype,shape:l.shape},E={dataId:x.dataId,dtype:x.dtype,shape:u.shape},D=new Id(n,l.shape,u.shape);return c.runWebGLProgram(D,[C,E],Ir(_.dtype,x.dtype))}),b=pl({inputs:{real:m,imag:y},backend:c});return c.disposeIntermediateTensorInfo(m),c.disposeIntermediateTensorInfo(y),b}const d=i||Ir(l.dtype,u.dtype);if(("string"===l.dtype||"string"===u.dtype||c.shouldExecuteOnCPU([l,u]))&&null!=r){const p=c.texData.get(l.dataId).values,g=c.texData.get(u.dataId).values,m="string"===l.dtype?da(p):p,y="string"===l.dtype?da(g):g,[b,v]=r(l.shape,u.shape,m,y,d),_=c.makeTensorInfo(v,d);return c.texData.get(_.dataId).values=b,_}let f;return f=W().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&null!=t?new zp(t,l.shape,u.shape,e):new Id(n,l.shape,u.shape),c.runWebGLProgram(f,[l,u],d)}}function Up(n,t=!1){if("linear"===n)return t?M0e:T0e;if("relu"===n)return t?O0e:k0e;if("elu"===n)return t?F0e:N0e;if("relu6"===n)return t?$0e:A0e;if("prelu"===n)return t?gU:mU;if("leakyrelu"===n)return t?pU:fU;if("sigmoid"===n)return t?P0e:R0e;throw new Error(`Activation ${n} has not been implemented for the WebGL backend.`)}class yU{constructor(t,e,s,r=!1,i=!1,o=!1,a=null,l=!1,u=!1){this.variableNames=["matrixA","matrixB"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=s,this.enableShapeUniforms=Us(this.outputShape.length);const d=Math.ceil((r?t[1]:t[2])/2),h=r?"i * 2, rc.y":"rc.y, i * 2",f=i?"rc.z, i * 2":"i * 2, rc.z",p=r?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"],g=i?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"];let m="",y="";a&&(m=l?`vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ${a}\n        }`:u?`vec4 activation(vec4 a) {\n          vec4 b = getLeakyreluAlphaAtOutCoords();\n          ${a}\n        }`:`vec4 activation(vec4 x) {\n          ${a}\n        }`,y="result = activation(result);");const b=o?"result += getBiasAtOutCoords();":"";o&&this.variableNames.push("bias"),l&&this.variableNames.push("preluActivationWeights"),u&&this.variableNames.push("leakyreluAlpha");let v="rc.x",_="rc.x";t[0]<e[0]?v=`imod(rc.x, ${t[0]})`:e[0]<t[0]&&(_=`imod(rc.x, ${e[0]})`),this.userCode=`\n      ${m}\n      // Don't use uniform for sharedDimensionPacked for performance.\n      const float sharedDimension = ${d}.0;\n\n      vec4 dot2x2ARowBCol(ivec3 rc) {\n        vec4 result = vec4(0);\n        int batchA = ${v};\n        int batchB = ${_};\n        for (int i = 0; i < ${d}; i++) {\n          vec4 a = getMatrixA(batchA, ${h});\n          vec4 b = getMatrixB(batchB, ${f});\n\n          // These swizzled products need to be separately added.\n          // See: https://github.com/tensorflow/tfjs/issues/1735\n          result += (${p[0]} * ${g[0]});\n          result += (${p[1]} * ${g[1]});\n        }\n        return result;\n      }\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n        vec4 result = dot2x2ARowBCol(rc);\n\n        ${b}\n\n        ${y}\n\n        setOutput(result);\n      }\n    `}}const bU={REAL:"return areal * breal - aimag * bimag;",IMAG:"return areal * bimag + aimag * breal;"};class vU{constructor(t,e,s){this.variableNames=["AReal","AImag","BReal","BImag"],this.outputShape=nt(e,s),this.userCode=`\n      float binaryOpComplex(\n          float areal, float aimag, float breal, float bimag) {\n        ${t}\n      }\n\n      void main() {\n        float areal = getARealAtOutCoords();\n        float aimag = getAImagAtOutCoords();\n        float breal = getBRealAtOutCoords();\n        float bimag = getBImagAtOutCoords();\n        setOutput(binaryOpComplex(areal, aimag, breal, bimag));\n      }\n    `}}const _U="return a * b;";function DT(n){const{inputs:t,backend:e}=n,{a:s,b:r}=t,i=Ir(s.dtype,r.dtype);if("complex64"===s.dtype){const a=e.texData.get(s.dataId),l=e.texData.get(r.dataId),u=new vU(bU.REAL,s.shape,r.shape),c=new vU(bU.IMAG,s.shape,r.shape),d=[{dataId:a.complexTensorInfos.real.dataId,dtype:a.complexTensorInfos.real.dtype,shape:s.shape},{dataId:a.complexTensorInfos.imag.dataId,dtype:a.complexTensorInfos.imag.dtype,shape:s.shape},{dataId:l.complexTensorInfos.real.dataId,dtype:l.complexTensorInfos.real.dtype,shape:r.shape},{dataId:l.complexTensorInfos.imag.dataId,dtype:l.complexTensorInfos.imag.dtype,shape:r.shape}],h=e.runWebGLProgram(u,d,"float32"),f=e.runWebGLProgram(c,d,"float32"),p=pl({inputs:{real:h,imag:f},backend:e});return e.disposeIntermediateTensorInfo(h),e.disposeIntermediateTensorInfo(f),p}if(e.shouldExecuteOnCPU([s,r])){const a=e.texData.get(s.dataId),l=e.texData.get(r.dataId),[u,c]=Zxe(s.shape,r.shape,a.values,l.values,i),d=e.makeTensorInfo(c,i);return e.texData.get(d.dataId).values=u,d}let o;return o=W().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new zp(_U,s.shape,r.shape):new Id(_U,s.shape,r.shape),e.runWebGLProgram(o,[s,r],i)}const nCe={kernelName:Rf,backendName:"webgl",kernelFunc:DT};function be(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{shape:i}=s,o=e,a=X(r.shape),l=k2(i,a),u=X(l);S(a===u,()=>`The new shape (${l}) has ${u} elements and the old shape (${r.shape}) has ${a} elements. The new shape and old shape must have the same number of elements.`);const c=o.texData.get(r.dataId);return!c.isPacked||qv(r.shape,l)||null!==c.texture&&qv(c.shape,l)?(o.incRef(r.dataId),{dataId:r.dataId,shape:l,dtype:r.dtype}):function sCe(n,t,e){const s=[vd(n.shape),..._d(n.shape)],r={dtype:n.dtype,shape:s,dataId:n.dataId},i=[vd(t),..._d(t)],o=new lU(i,s),u=e.runWebGLProgram(o,[r],n.dtype,[s],!0);return{dataId:u.dataId,shape:t,dtype:u.dtype}}(r,l,o)}const rCe={kernelName:sb,backendName:"webgl",kernelFunc:be};class wU{constructor(t,e){this.variableNames=["x"];const{windowSize:s,batchSize:r,inSize:i,outSize:o}=t;this.outputShape=[r,o];const a=4*Math.floor(s/4),l=s%4;let u="sumValue += dot(values, ones);";if(null!=e){const d=1/e;u=`sumValue += dot(values * ${Pc(d)?d.toPrecision(2):d}, ones);`}let c="";i%s>0&&(c=`\n        if (inIdx < 0 || inIdx >= ${i}) {\n          return 0.0;\n        }\n      `),this.userCode=`\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ${c}\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${s};\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ${a}; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ${u}\n        }\n\n        int inIdx = inOffset + ${a};\n        if (${1===l}) {\n          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);\n\n          ${u}\n        } else if (${2===l}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1), 0.0, 0.0);\n\n          ${u}\n        } else if (${3===l}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2), 0.0);\n\n          ${u}\n        }\n        setOutput(sumValue);\n      }\n    `}}class iCe{constructor(t,e){this.variableNames=["x"];const{windowSize:s,batchSize:r,inSize:i,outSize:o}=t;this.outputShape=[r,o];let a="0.0",l="";"prod"===e?a="1.0":"min"===e?(a="1.0 / 1e-20",l="min"):"max"===e&&(a="-1.0 / 1e-20",l="max");let u=`${e}(${e}(${e}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"sum"===e?u="sumValue":"prod"===e?u="prodValue":"all"===e?u="allValue":"any"===e&&(u="anyValue");const c=4*Math.floor(s/4),d=s%4;let h=`\n      if (${"sum"===e}) {\n        sumValue += dot(values, ones);\n      } else if (${"prod"===e}) {\n        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);\n        prodValue *= tmp[0] * tmp[1];\n      } else {\n        minMaxValue = ${l}(values, minMaxValue);\n        if (${"min"===e} || ${"max"===e}) {\n          minMaxValue = ${l}(values, minMaxValue);\n          bvec4 isNaN = isnan(values);\n          if (isNaN.r || isNaN.g || isNaN.b || isNaN.a) {\n            minMaxValue = vec4(NAN);\n          }\n        }\n      }\n    `,f="vec4";"all"===e?(a="1.0",h="\n        bool reducedAllValue = all(values);\n        float floatedReducedAllValue = float(reducedAllValue);\n        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);\n      ",f="bvec4"):"any"===e&&(a="0.0",h="\n        bool reducedAnyValue = any(values);\n        float floatedReducedAnyValue = float(reducedAnyValue);\n        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);\n      ",f="bvec4");let p="";i%s>0&&(p=`\n        if (inIdx < 0 || inIdx >= ${i}) {\n          return initializationValue;\n        }\n      `),this.userCode=`\n      const float initializationValue = ${a};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ${p}\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${s};\n\n        vec4 minMaxValue = vec4(${a});\n        float prodValue = 1.0;\n        float sumValue = 0.0;\n        float allValue = 1.0;\n        float anyValue = 0.0;\n\n        for (int i = 0; i < ${c}; i += 4) {\n          int inIdx = inOffset + i;\n          ${f} values = ${f}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ${h}\n        }\n\n        int inIdx = inOffset + ${c};\n        if (${1===d}) {\n          ${f} values = ${f}(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          ${h}\n        } else if (${2===d}) {\n          ${f} values = ${f}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          ${h}\n        } else if (${3===d}) {\n          ${f} values = ${f}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          ${h}\n        }\n        setOutput(${u});\n      }\n    `}}function Su(n,t,e,s){const r=function oCe(n){const t=[];for(;0===t.length||1!==t[t.length-1].outSize;){const e=t.length?t[t.length-1].outSize:n[1],s=tv(e);t.push({inSize:e,windowSize:s,outSize:Math.ceil(e/s)})}return t}(n.shape);let i=n;for(let o=0;o<r.length;o++){const{inSize:a,windowSize:l,outSize:u}=r[o];let c,d;c="mean"===e?0===o?new wU({windowSize:l,inSize:a,batchSize:n.shape[0],outSize:u},a):new wU({windowSize:l,inSize:a,batchSize:n.shape[0],outSize:u}):new iCe({windowSize:l,inSize:a,batchSize:n.shape[0],outSize:u},e),d=i,i=s.runWebGLProgram(c,[i],t),d.dataId!==n.dataId&&s.disposeIntermediateTensorInfo(d)}return i}class aCe{constructor(t,e){this.variableNames=["A"];const s=new Array(t.length);for(let o=0;o<s.length;o++)s[o]=t[e[o]];this.outputShape=s,this.rank=s.length;const r=Xt(this.rank),i=function lCe(n){const t=n.length;if(t>6)throw Error(`Transpose for rank ${t} is not yet supported`);const e=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"],s=new Array(t);for(let r=0;r<n.length;r++)s[n[r]]=e[r];return s.join()}(e);this.userCode=`\n    void main() {\n      ${r} resRC = getOutputCoords();\n      setOutput(getA(${i}));\n    }\n    `}}class uCe{constructor(t,e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0;const s=new Array(t.length);for(let c=0;c<s.length;c++)s[c]=t[e[c]];if(this.outputShape=s,this.rank=s.length,this.rank>6)throw Error(`Packed transpose for rank ${this.rank} is not yet supported.`);const r=Xt(this.rank),i=aU("rc",this.rank),o=new Array(this.rank);for(let c=0;c<e.length;c++)o[e[c]]=i[c];const a=`vec2(${o.slice(-2).join()})`,l=`++${i[this.rank-1]} < ${s[this.rank-1]}`,u=`getChannel(getA(${o.join()}), ${a})`;this.userCode=`\n    void main() {\n      ${r} rc = getOutputCoords();\n      vec4 result = vec4(0.);\n      result[0] = ${u};\n      if(${l}) {\n        result[1] = ${u};\n      }\n      --${i[this.rank-1]};\n      if(++${i[this.rank-2]} < ${s[this.rank-2]}) {\n        result[2] = ${u};\n        if(${l}) {\n          result[3] = ${u};\n        }\n      }\n      setOutput(result);\n    }\n    `}}function Jv(n,t,e){const s=W().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new uCe(n.shape,t):new aCe(n.shape,t);return e.runWebGLProgram(s,[n],n.dtype)}function e_(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{axis:i,keepDims:o}=s;return function cCe(n,t,e,s){const i=n.shape.length,o=mt(t,n.shape);let a=o;const l=vn(a,i),u=null!=l;let c=n;u&&(c=Jv(n,l,s),a=$n(a.length,i)),Ns("sum",a,i);const[d,h]=ws(c.shape,a);let f=d;e&&(f=On(d,o));const p=X(h),y=be({inputs:{x:c},attrs:{shape:[X(n.shape)/p,p]},backend:s}),v=Su(y,nI(n.dtype),"sum",s),_=be({inputs:{x:v},attrs:{shape:f},backend:s});return s.disposeIntermediateTensorInfo(y),s.disposeIntermediateTensorInfo(v),u&&s.disposeIntermediateTensorInfo(c),_}(r,i,o,e)}const dCe={kernelName:ub,backendName:"webgl",kernelFunc:e_};function Qs(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{perm:i}=s,o=e,l=new Array(r.shape.length);for(let c=0;c<l.length;c++)l[c]=r.shape[i[c]];let u;if(o.shouldExecuteOnCPU([r])){const d=o.texData.get(r.dataId).values,h=IT(d,r.shape,r.dtype,i,l);u=o.makeTensorInfo(l,r.dtype),o.texData.get(u.dataId).values=h}else u=Jv(r,i,o);return u}const hCe={kernelName:Uc,backendName:"webgl",kernelFunc:Qs},xU=1e3;function t_({a:n,b:t,transposeA:e,transposeB:s,backend:r,bias:i=null,preluActivationWeights:o=null,leakyreluAlpha:a=0,activation:l=null}){const u=n.shape.length,c=t.shape.length,d=e?n.shape[u-2]:n.shape[u-1],h=s?t.shape[c-1]:t.shape[c-2],f=e?n.shape[u-1]:n.shape[u-2],p=s?t.shape[c-2]:t.shape[c-1],g=n.shape.slice(0,-2),m=t.shape.slice(0,-2),y=X(g),b=X(m),_=nt(n.shape.slice(0,-2),t.shape.slice(0,-2)).concat([f,p]);S(d===h,()=>`Error in matMul: inner shapes (${d}) and (${h}) of Tensors with shapes ${n.shape} and ${t.shape} and transposeA=${e} and transposeB=${s} must match.`);const x=e?[y,d,f]:[y,f,d],C=s?[b,p,h]:[b,h,p],E=be({inputs:{x:n},backend:r,attrs:{shape:x}}),D=be({inputs:{x:t},backend:r,attrs:{shape:C}}),N=[E,D],R=Math.max(y,b),V=e?E.shape[1]:E.shape[2],G=null!=i,j=null!=o,q="leakyrelu"===l,K=null!=l?Up(l,!0):null;let B;if((1===f||1===p)&&V>xU&&!1===(G||j||q||null!=K)){let H=E,se=D;e&&(H=Qs({inputs:{x:E},backend:r,attrs:{perm:[0,2,1]}}),N.push(H)),s&&(se=Qs({inputs:{x:D},backend:r,attrs:{perm:[0,2,1]}}),N.push(se));const he=1===p;let de=H;1!==p&&(de=be({inputs:{x:H},backend:r,attrs:{shape:[R,V,1]}}),N.push(de));const fe=1===p?2:1;let ye=se;he&&(ye=be({inputs:{x:se},backend:r,attrs:{shape:[R,1,V]}}),N.push(ye));const De=DT({inputs:{a:de,b:ye},backend:r});B=e_({inputs:{x:De},backend:r,attrs:{axis:fe,keepDims:!0}}),N.push(De)}else{const H=Ir(n.dtype,t.dtype),se=new yU(x,C,[R,f,p],e,s,G,K,j,q),ie=[E,D];if(null!=i&&ie.push(i),j&&ie.push(o),q){const he=r.makeTensorInfo([],"float32",$a(a,"float32"));ie.push(he),N.push(he)}B=r.runWebGLProgram(se,ie,H)}const L=be({inputs:{x:B},backend:r,attrs:{shape:_}});N.push(B);for(const H of N)r.disposeIntermediateTensorInfo(H);return L}const pCe={kernelName:yb,backendName:"webgl",kernelFunc:function fCe(n){const{inputs:t,backend:e,attrs:s}=n,{a:r,b:i,bias:o,preluActivationWeights:a}=t,{transposeA:l,transposeB:u,activation:c,leakyreluAlpha:d}=s;return t_({a:r,b:i,transposeA:l,transposeB:u,backend:e,bias:o,preluActivationWeights:a,leakyreluAlpha:d,activation:c})}},CU="return abs(x);",gCe={kernelName:my,backendName:"webgl",kernelFunc:function mCe(n){const{inputs:t,backend:e}=n,{x:s}=t;if(e.shouldExecuteOnCPU([s])&&"complex64"!==s.dtype){const i=e.texData.get(s.dataId),o=iU(i.values);return e.makeTensorInfo(s.shape,s.dtype,o)}let r;return r=W().getBool("WEBGL_PACK_UNARY_OPERATIONS")?new fl(s.shape,CU):new Fo(s.shape,CU),e.runWebGLProgram(r,[s],s.dtype)}},bCe=Nt({opSnippet:Jr+"\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return acos(x);\n"}),vCe={kernelName:ef,backendName:"webgl",kernelFunc:bCe},wCe=Nt({opSnippet:Jr+"\n  if (x < 1.0) return NAN;\nreturn log(x + sqrt(x * x - 1.0));"}),xCe={kernelName:nf,backendName:"webgl",kernelFunc:wCe},SU="return a + b;",CCe=As({opSnippet:SU,packedOpSnippet:SU,supportsComplex:!0,cpuKernelImpl:Axe}),SCe={kernelName:zc,backendName:"webgl",kernelFunc:CCe};class ICe{constructor(t,e){this.outputShape=[],this.outputShape=t,this.variableNames=e.map((i,o)=>`T${o}`);const s=[];this.variableNames.forEach(i=>{s.push(`float v${i} = get${i}AtOutCoords();`)});const r=this.variableNames.map(i=>`v${i}`).join(" + ");this.userCode=`\n      void main() {\n        ${s.join("\n        ")}\n\n        float result = ${r};\n        setOutput(result);\n      }\n    `}}class ECe{constructor(t,e){this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t,this.variableNames=e.map((i,o)=>`T${o}`);const s=[];this.variableNames.forEach(i=>{s.push(`vec4 v${i} = get${i}AtOutCoords();`)});const r=this.variableNames.map(i=>`v${i}`).join(" + ");this.userCode=`\n      void main() {\n        ${s.join("\n        ")}\n\n        vec4 result = ${r};\n        setOutput(result);\n      }\n    `}}const DCe={kernelName:gy,backendName:"webgl",kernelFunc:function n_(n){const{inputs:t,backend:e}=n,s=t;if(1===s.length)return Ar({inputs:{x:s[0]},backend:e});if(s.length>W().get("WEBGL_MAX_TEXTURES_IN_SHADER")){const l=Math.floor(s.length/2),u=n_({inputs:s.slice(0,l),backend:e}),c=n_({inputs:s.slice(l),backend:e});return n_({inputs:[u,c],backend:e})}const r=s.map(l=>l.dtype).reduce((l,u)=>Ir(l,u)),i=s.map(l=>l.shape),a=W().getBool("WEBGL_PACK")?new ECe(s[0].shape,i):new ICe(s[0].shape,i);return e.runWebGLProgram(a,s,r)}},NCe={kernelName:"All",backendName:"webgl",kernelFunc:function TCe(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{axis:i,keepDims:o}=s,a=r.shape.length,l=mt(i,r.shape);let u=l;const c=vn(u,a);let d=r;null!=c&&(d=Qs({inputs:{x:r},backend:e,attrs:{perm:c}}),u=$n(u.length,a)),Ns("all",u,a);const[h,f]=ws(d.shape,u),g=be({inputs:{x:d},backend:e,attrs:{shape:[-1,X(f)]}}),m=Su(g,g.dtype,"all",e);let y;return y=be(o?{inputs:{x:m},backend:e,attrs:{shape:On(h,l)}}:{inputs:{x:m},backend:e,attrs:{shape:h}}),e.disposeIntermediateTensorInfo(g),e.disposeIntermediateTensorInfo(m),null!=c&&e.disposeIntermediateTensorInfo(d),y}},ACe={kernelName:"Any",backendName:"webgl",kernelFunc:function kCe(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{axis:i,keepDims:o}=s,a=r.shape.length,l=mt(i,r.shape);let u=l;const c=vn(u,a);let d=r;null!=c&&(d=Qs({inputs:{x:r},backend:e,attrs:{perm:c}}),u=$n(u.length,a)),Ns("any",u,a);const[h,f]=ws(d.shape,u),g=be({inputs:{x:d},backend:e,attrs:{shape:[-1,X(f)]}}),m=Su(g,g.dtype,"any",e);let y;return y=be(o?{inputs:{x:m},backend:e,attrs:{shape:On(h,l)}}:{inputs:{x:m},backend:e,attrs:{shape:h}}),e.disposeIntermediateTensorInfo(g),e.disposeIntermediateTensorInfo(m),null!=c&&e.disposeIntermediateTensorInfo(d),y}};class RCe{constructor(t,e,s){this.variableNames=["A"];const{windowSize:r,batchSize:i,outSize:o}=t;s||this.variableNames.push("bestIndicesA"),this.outputShape=[i,o],this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${r};\n\n        int bestIndex = inOffset;\n        float bestValue = getA(batch, bestIndex);\n\n        for (int i = 0; i < ${r}; i++) {\n          int inIdx = ${s?"inOffset + i;":"round(getBestIndicesA(batch, inOffset + i));"};\n          float candidate = getA(batch, inIdx);\n          if (candidate ${"max"===e?">":"<"} bestValue) {\n            bestValue = candidate;\n            bestIndex = inIdx;\n          }\n        }\n        setOutput(float(bestIndex));\n      }\n    `}}class MCe{constructor(t,e,s,r){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,S(t.length>2,()=>`Packed arg${s.charAt(0).toUpperCase()+s.slice(1)} supports only inputs with rank above 2.`);const o=Math.ceil(t[t.length-1]/e);this.outputShape=t.slice(0,-1),o>1&&this.outputShape.push(o),r||this.variableNames.push("bestIndicesA");const a=this.outputShape,l=a.length,u=Xt(l),c=Zs("coords",l);let d,h;if(1===o){h=l+1;const D=Xt(h);d=`\n        ${D} sourceLocR = ${D}(${c.join()}, 0);\n        ++${c[l-1]};\n        ${D} sourceLocG = ${D}(${c.join()}, 0);\n        ++${c[l-2]};\n        ${D} sourceLocA = ${D}(${c.join()}, 0);\n        --${c[l-1]};\n        ${D} sourceLocB = ${D}(${c.join()}, 0);\n        --${c[l-2]};`}else h=l,d=`\n        ${u} sourceLocR = coords;\n        ++${c[l-1]};\n        ${u} sourceLocG = coords;\n        ++${c[l-2]};\n        ${u} sourceLocA = coords;\n        --${c[l-1]};\n        ${u} sourceLocB = coords;\n        --${c[l-2]};`;const f=["x","y","z","w","u","v"].slice(0,h),p="."+f[h-1],g=f.map(D=>"int "+D),m=Zs("sourceLocR",h-1).concat("inIdx.r"),y=Zs("sourceLocG",h-1).concat("inIdx.g"),b=Zs("sourceLocB",h-1).concat("inIdx.b"),v=Zs("sourceLocA",h-1).concat("inIdx.a"),_="max"===s?"greaterThan":"lessThan",x=r?"":`\n          inIdx = round(vec4(getBestIndicesAChannel(${m.join()}),\n                             getBestIndicesAChannel(${y.join()}),\n                             getBestIndicesAChannel(${b.join()}),\n                             getBestIndicesAChannel(${v.join()})));`,C=`vec4(\n            getAChannel(${m.join()}),\n            hasNextCol ? getAChannel(${y.join()}) : 0.,\n            hasNextRow ? getAChannel(${b.join()}) : 0.,\n            hasNextRow && hasNextCol ? getAChannel(${v.join()}) : 0.)`,E=r?"":`\n      float getBestIndicesAChannel(${g.join()}) {\n        return getChannel(getBestIndicesA(${f.join()}),\n                                          vec2(${f.slice(-2).join()}));\n      }`;this.userCode=`\n      float getAChannel(${g.join()}) {\n        return getChannel(getA(${f.join()}),\n                               vec2(${f.slice(-2).join()}));\n      }\n      ${E}\n      void main() {\n        ${u} coords = getOutputCoords();\n        bool hasNextCol = ${c[l-1]} < ${a[l-1]-1};\n        bool hasNextRow = ${c[l-2]} < ${a[l-2]-1};\n        ${d}\n        ivec4 srcIdx = ivec4(sourceLocR${p}, sourceLocG${p},\n          sourceLocB${p}, sourceLocA${p}) * ${e};\n        ivec4 inIdx = srcIdx;\n        vec4 bestIndex = vec4(inIdx);\n        vec4 bestValue = ${C};\n\n        for (int i = 0; i < ${e}; i++) {\n          inIdx = srcIdx;\n          ${x}\n          vec4 candidate = ${C};\n          bvec4 nan = isnan(candidate);\n          bvec4 replace = bvec4(\n            vec4(${_}(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));\n\n          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,\n                           replace.y  ? candidate.y : bestValue.y,\n                           replace.z  ? candidate.z : bestValue.z,\n                           replace.w  ? candidate.w : bestValue.w);\n          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));\n          srcIdx++;\n        }\n        setOutput(bestIndex);\n      }\n    `}}function IU(n,t,e,s=null){let r=t.shape[0],i=t.shape[1];null!=s&&(r=s.shape[0],i=s.shape[1]);const o=tv(i),a={windowSize:o,inSize:i,batchSize:r,outSize:Math.ceil(i/o)},l=new RCe(a,e,null==s),u=[t];null!=s&&u.push(s);const c=n.runWebGLProgram(l,u,"int32");if(1===c.shape[1])return c;const d=IU(n,t,e,c);return n.disposeIntermediateTensorInfo(c),d}function EU(n,t,e,s=null){const r=null!=s?s.shape:t.shape,o=tv(r[r.length-1]),a=new MCe(r,o,e,null==s),u=n.runWebGLProgram(a,null==s?[t]:[t,s],"int32");if(u.shape.length===t.shape.length){const c=EU(n,t,e,u);return n.disposeIntermediateTensorInfo(u),c}return u}function DU(n,t,e,s){const r=[e];if(Ns("arg"+s.charAt(0).toUpperCase()+s.slice(1),r,t.shape.length),!W().getBool("WEBGL_PACK_REDUCE")||t.shape.length<=2){const i=[],o=n.texData.get(t.dataId);let l=t;null!==o&&o.isPacked&&(l=n.unpackTensor(t),i.push(l));const[u,c]=ws(l.shape,r),d=X(c),h=be({inputs:{x:l},backend:n,attrs:{shape:[-1,d]}});i.push(h);const f=IU(n,h,s);i.push(f);const p=be({inputs:{x:f},backend:n,attrs:{shape:u}});return i.forEach(g=>n.disposeIntermediateTensorInfo(g)),p}return EU(n,t,s)}const OCe={kernelName:yy,backendName:"webgl",kernelFunc:function FCe(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{axis:i}=s;let o=mt(i,r.shape);const a=vn(o,r.shape.length);let l=r;const u=[];null!=a&&(l=Qs({inputs:{x:r},backend:e,attrs:{perm:a}}),u.push(l),o=$n(o.length,l.shape.length)),Ns("argMax",[o[0]],l.shape.length);const c=DU(e,l,o[0],"max");return u.forEach(d=>e.disposeIntermediateTensorInfo(d)),c}},PCe={kernelName:by,backendName:"webgl",kernelFunc:function $Ce(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{axis:i}=s;let o=mt(i,r.shape);const a=vn(o,r.shape.length);let l=r;const u=[];null!=a&&(l=Qs({inputs:{x:r},backend:e,attrs:{perm:a}}),u.push(l),o=$n(o.length,l.shape.length)),Ns("argMin",[o[0]],l.shape.length);const c=DU(e,l,o[0],"min");return u.forEach(d=>e.disposeIntermediateTensorInfo(d)),c}},VCe=Nt({opSnippet:Jr+"\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return asin(x);\n"}),BCe={kernelName:sf,backendName:"webgl",kernelFunc:VCe},UCe=Nt({opSnippet:Jr+"return log(x + sqrt(x * x + 1.0));"}),WCe={kernelName:rf,backendName:"webgl",kernelFunc:UCe},HCe=Nt({opSnippet:Jr+"\n  return atan(x);\n"}),jCe={kernelName:af,backendName:"webgl",kernelFunc:HCe},XCe=As({opSnippet:ET+"\n  return atan(a, b);\n",packedOpSnippet:"\n  vec4 result = atan(a, b);\n  bvec4 isNaNA = isnan(a);\n  bvec4 isNaNB = isnan(b);\n  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);\n  "+Cu+"\n  return result;\n"}),YCe={kernelName:uf,backendName:"webgl",kernelFunc:XCe},QCe=Nt({opSnippet:Jr+"\n  if ((x < -1.0) || (x > 1.0)) return NAN;\nreturn (log(1.0 + x) - log(1.0 - x)) / 2.0;"}),JCe={kernelName:lf,backendName:"webgl",kernelFunc:QCe};class Wp{constructor(t,e,s,r=!1,i=!1){if(this.variableNames=["x"],"avg"===e&&s)throw new Error("Cannot compute positions for average pool.");const o=t.filterWidth,a=t.strideHeight,l=t.strideWidth,u=t.dilationHeight,c=t.dilationWidth,d=t.effectiveFilterHeight,h=t.effectiveFilterWidth,f=t.padInfo.top,p=t.padInfo.left;this.outputShape=t.outShape;const g="avg"===e;let b="0.0";if(g||(b="-1.0 / 1e-20"),s)return void(this.userCode=`\n        const ivec2 strides = ivec2(${a}, ${l});\n        const ivec2 pads = ivec2(${f}, ${p});\n\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int batch = coords[0];\n          int d = coords[3];\n\n          ivec2 xRCCorner = coords.yz * strides - pads;\n          int xRCorner = xRCCorner.x;\n          int xCCorner = xRCCorner.y;\n\n          // max/min x(?, ?, d) to get y(yR, yC, d).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n          float avgValue = 0.0;\n\n          for (int wR = 0; wR < ${d};\n              wR += ${u}) {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ${t.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${h};\n                wC += ${c}) {\n              int xC = xCCorner + wC;\n\n              if (xC < 0 || xC >= ${t.inWidth}) {\n                continue;\n              }\n\n              float value = getX(batch, xR, xC, d);\n\n              // If a min / max value has already been found, use it. If not,\n              // use the current value.\n              float currMinMaxValue = mix(\n                  value, minMaxValue, minMaxValueFound);\n              if (value >= currMinMaxValue) {\n                minMaxValue = value;\n                minMaxValueFound = 1.0;\n                minMaxPosition = ${r?i?`((batch  * ${t.inHeight} + xR) * ${t.inWidth} + xC) * ${t.inChannels} + d`:`(xR * ${t.inWidth} + xC) * ${t.inChannels} + d`:`wR * ${h} + wC`};\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      `);let _=`${e}(${e}(${e}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"avg"===e&&(_="avgValue / max(count, 1.0)");const x=4*Math.floor(o/4),C=o%4,E=`\n      if (${g}) {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = max(values, minMaxValue);\n      }\n    `;this.userCode=`\n      const ivec2 strides = ivec2(${a}, ${l});\n      const ivec2 pads = ivec2(${f}, ${p});\n      const float initializationValue = ${b};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xR, int xC, int d) {\n        if (xC < 0 || xC >= ${t.inWidth}) {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xR, xC, d);\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d = coords[3];\n\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // max/min x(?, ?, d) to get y(yR, yC, d).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(${b});\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wR = 0; wR < ${d};\n            wR += ${u}) {\n          int xR = xRCorner + wR;\n\n          if (xR < 0 || xR >= ${t.inHeight}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${x}; wC += 4) {\n            int xC = xCCorner + wC * ${c};\n\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${c}, d),\n              getValue(batch, xR, xC + 2 * ${c}, d),\n              getValue(batch, xR, xC + 3 * ${c}, d)\n            );\n\n            ${E}\n          }\n\n          int xC = xCCorner + ${x};\n          if (${1===C}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              initializationValue,\n              initializationValue,\n              initializationValue\n            );\n\n            ${E}\n          } else if (${2===C}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${c}, d),\n              initializationValue,\n              initializationValue\n            );\n\n            ${E}\n          } else if (${3===C}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${c}, d),\n              getValue(batch, xR, xC + 2 * ${c}, d),\n              initializationValue\n            );\n\n            ${E}\n          }\n        }\n        setOutput(${_});\n      }\n    `}}class TT{constructor(t,e,s,r=!1,i=!1){if(this.variableNames=["x"],"avg"===e&&s)throw new Error("Cannot compute positions for average pool.");const o=t.filterWidth,a=t.strideDepth,l=t.strideHeight,u=t.strideWidth,c=t.dilationDepth,d=t.dilationHeight,h=t.dilationWidth,f=t.effectiveFilterDepth,p=t.effectiveFilterHeight,g=t.effectiveFilterWidth,m=t.padInfo.front,y=t.padInfo.top,b=t.padInfo.left;this.outputShape=t.outShape;const v="avg"===e;let _="0.0";if(v||(_="-1.0 / 1e-20"),s)return void(this.userCode=`\n        const ivec3 strides =\n            ivec3(${a}, ${l}, ${u});\n        const ivec3 pads = ivec3(${m}, ${y}, ${b});\n\n        void main() {\n          ivec5 coords = getOutputCoords();\n          int batch = coords.x;\n          int ch = coords.u;\n\n          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n          int xDCorner = xCorner.x;\n          int xRCorner = xCorner.y;\n          int xCCorner = xCorner.z;\n\n          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n\n          for (int wD = 0; wD < ${f};\n              wD += ${c}) {\n            int xD = xDCorner + wD;\n\n            if (xD < 0 || xD >= ${t.inDepth}) {\n              continue;\n            }\n\n            for (int wR = 0; wR < ${p};\n                wR += ${d}) {\n              int xR = xRCorner + wR;\n\n              if (xR < 0 || xR >= ${t.inHeight}) {\n                continue;\n              }\n\n              for (int wC = 0; wC < ${g};\n                  wC += ${h}) {\n                int xC = xCCorner + wC;\n\n                if (xC < 0 || xC >= ${t.inWidth}) {\n                  continue;\n                }\n\n                float value = getX(batch, xD, xR, xC, ch);\n\n                // If a min / max value has already been found, use it. If not,\n                // use the current value.\n                float currMinMaxValue = mix(\n                    value, minMaxValue, minMaxValueFound);\n                if (value >= currMinMaxValue) {\n                  minMaxValue = value;\n                  minMaxValueFound = 1.0;\n                  minMaxPosition = ${r?i?`(((batch * ${t.inDepth} + xD) * ${t.inHeight} + xR) * ${t.inWidth} + xC) * ${t.inChannels} + ch`:`((xD * ${t.inHeight} + xR) * ${t.inWidth} + xC) * ${t.inChannels} + ch`:`wD * ${p} * ${g} +\n                      wR * ${g} + wC`};\n                }\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      `);let C=`${e}(${e}(${e}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"avg"===e&&(C="avgValue / max(count, 1.0)");const E=4*Math.floor(o/4),D=o%4,N=`\n      if (${v}) {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = max(values, minMaxValue);\n      }\n    `;this.userCode=`\n      const ivec3 strides =\n        ivec3(${a}, ${l}, ${u});\n      const ivec3 pads = ivec3(${m}, ${y}, ${b});\n      const float initializationValue = ${_};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xD, int xR, int xC, int ch) {\n        if (xC < 0 || xC >= ${t.inWidth}) {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xD, xR, xC, ch);\n      }\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xDCorner = xCorner.x;\n        int xRCorner = xCorner.y;\n        int xCCorner = xCorner.z;\n\n        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(${_});\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wD = 0; wD < ${f};\n            wD += ${c}) {\n          int xD = xDCorner + wD;\n\n          if (xD < 0 || xD >= ${t.inDepth}) {\n            continue;\n          }\n\n          for (int wR = 0; wR < ${p};\n            wR += ${d}) {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ${t.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${E}; wC += 4) {\n              int xC = xCCorner + wC * ${h};\n\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${h}, ch),\n                getValue(batch, xD, xR, xC + 2 * ${h}, ch),\n                getValue(batch, xD, xR, xC + 3 * ${h}, ch)\n              );\n\n              ${N}\n            }\n\n            int xC = xCCorner + ${E};\n            if (${1===D}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                initializationValue,\n                initializationValue,\n                initializationValue\n              );\n\n              ${N}\n            } else if (${2===D}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${h}, ch),\n                initializationValue,\n                initializationValue\n              );\n\n              ${N}\n            } else if (${3===D}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${h}, ch),\n                getValue(batch, xD, xR, xC + 2 * ${h}, ch),\n                initializationValue\n              );\n\n              ${N}\n            }\n          }\n        }\n        setOutput(${C});\n      }\n    `}}const tSe={kernelName:vy,backendName:"webgl",kernelFunc:function eSe(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t;Vp(r,"avgPool");const{filterSize:i,strides:o,pad:a,dimRoundingMode:l}=s;S(Ts(o,1),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${o} and dilations '1'`);const c=pi(r.shape,i,o,1,a,l);if(1===c.filterWidth&&1===c.filterHeight&&wt(c.inShape,c.outShape))return Ar({inputs:{x:r},backend:e});const d=new Wp(c,"avg",!1);return e.runWebGLProgram(d,[r],"float32")}},sSe={kernelName:_y,backendName:"webgl",kernelFunc:function nSe(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{filterSize:i,strides:o,pad:a,dimRoundingMode:l,dataFormat:u}=s,d=aa(r.shape,i,o,[1,1,1],a,l,u),h=new TT(d,"avg",!1);return e.runWebGLProgram(h,[r],"float32")}};class rSe{constructor(t){this.variableNames=["dy"],this.outputShape=t.inShape;const l=t.effectiveFilterHeight,u=t.effectiveFilterWidth;this.userCode=`\n      const ivec2 pads = ivec2(${l-1-t.padInfo.top}, ${u-1-t.padInfo.left});\n      const float avgMultiplier = float(${1/(t.filterHeight*t.filterWidth)});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${l};\n            wR += ${t.dilationHeight}) {\n          float dyR = float(dyRCorner + wR) / ${t.strideHeight}.0;\n\n          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ${u};\n            wC+= ${t.dilationWidth}) {\n            float dyC = float(dyCCorner + wC) / ${t.strideWidth}.0;\n\n            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n\n            dotProd += dyValue * avgMultiplier;\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class iSe{constructor(t){this.variableNames=["dy"],this.outputShape=t.inShape;const d=t.effectiveFilterDepth,h=t.effectiveFilterHeight,f=t.effectiveFilterWidth;this.userCode=`\n      const ivec3 pads = ivec3(${d-1-t.padInfo.front}, ${h-1-t.padInfo.top}, ${f-1-t.padInfo.left});\n      const float avgMultiplier = float(${1/(t.filterDepth*t.filterHeight*t.filterWidth)});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ${d};\n            wD += ${t.dilationDepth}) {\n          float dyD = float(dyDCorner + wD) / ${t.strideDepth}.0;\n\n          if (dyD < 0.0 || dyD >= ${t.outDepth}.0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ${h};\n              wR += ${t.dilationHeight}) {\n            float dyR = float(dyRCorner + wR) / ${t.strideHeight}.0;\n\n            if (dyR < 0.0 || dyR >= ${t.outHeight}.0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ${f};\n                wC += ${t.dilationWidth}) {\n              float dyC = float(dyCCorner + wC) / ${t.strideWidth}.0;\n\n              if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n\n              dotProd += dyValue * avgMultiplier;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const aSe={kernelName:qC,backendName:"webgl",kernelFunc:function oSe(n){const{inputs:t,backend:e,attrs:s}=n,{dy:r,input:i}=t,o=i,{filterSize:a,strides:l,pad:u,dimRoundingMode:c}=s,h=aa(o.shape,a,l,[1,1,1],u,c),f=new iSe(h);return e.runWebGLProgram(f,[r],o.dtype)}},uSe={kernelName:jC,backendName:"webgl",kernelFunc:function lSe(n){const{inputs:t,backend:e,attrs:s}=n,{dy:r,input:i}=t,o=i;Vp([r,i],"avgPoolGrad");const{filterSize:a,strides:l,pad:u}=s,c=pi(o.shape,a,l,1,u),d=new rSe(c);return e.runWebGLProgram(d,[r],o.dtype)}},dSe={kernelName:wy,backendName:"webgl",kernelFunc:function cSe(n){const{inputs:t,backend:e,attrs:s}=n,{a:r,b:i}=t,{transposeA:o,transposeB:a}=s;return t_({a:r,b:i,transposeA:o,transposeB:a,backend:e})}};class hSe{constructor(t,e,s,r,i,o){this.outputShape=[],this.variableNames=["x","mean","variance"],nt(t,e),nt(t,s);let a="0.0";null!=r&&(nt(t,r),this.variableNames.push("offset"),a="getOffsetAtOutCoords()");let l="1.0";null!=i&&(nt(t,i),this.variableNames.push("scale"),l="getScaleAtOutCoords()"),this.outputShape=t,this.userCode=`\n      void main() {\n        float x = getXAtOutCoords();\n        float mean = getMeanAtOutCoords();\n        float variance = getVarianceAtOutCoords();\n        float offset = ${a};\n        float scale = ${l};\n        float inv = scale * inversesqrt(variance + float(${o}));\n        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));\n      }\n    `}}class fSe{constructor(t,e,s,r,i,o){this.packedInputs=!0,this.packedOutput=!0,this.variableNames=["x","mean","variance"],nt(t,e),nt(t,s);let a="vec4(0.0)";null!=r&&(nt(t,r),this.variableNames.push("offset"),a="getOffsetAtOutCoords()");let l="vec4(1.0)";null!=i&&(nt(t,i),this.variableNames.push("scale"),l="getScaleAtOutCoords()"),this.outputShape=t,this.userCode=`\n      void main() {\n        vec4 offset = ${a};\n        vec4 scale = ${l};\n\n        vec4 x = getXAtOutCoords();\n        vec4 mean = getMeanAtOutCoords();\n        vec4 variance = getVarianceAtOutCoords();\n\n        vec4 inv = scale * inversesqrt(variance + vec4(${o}));\n\n        setOutput((x - mean) * inv + offset);\n      }\n    `}}const pSe={kernelName:My,backendName:"webgl",kernelFunc:({inputs:n,backend:t,attrs:e})=>{const{x:s,mean:r,variance:i,offset:o,scale:a}=n;S(r.shape.length===i.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),S(null==o||r.shape.length===o.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),S(null==a||r.shape.length===a.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");let{varianceEpsilon:l}=e;null==l&&(l=.001);const u=[s,r,i];let c=null;null!=o&&(c=o.shape,u.push(o));let d=null;null!=a&&(d=a.shape,u.push(a));const h=W().getBool("WEBGL_PACK_NORMALIZATION")?new fSe(s.shape,r.shape,i.shape,c,d,l):new hSe(s.shape,r.shape,i.shape,c,d,l);return t.runWebGLProgram(h,u,u[0].dtype)}};class mSe{constructor(t){this.variableNames=["source"],this.outputShape=t,this.rank=t.length;const e=Xt(this.rank);this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const s=function gSe(n){if(1===n)return"sourceLoc";if(n<=6)return NT.slice(0,n).map(t=>"sourceLoc."+t).join(",");throw Error(`Slicing for rank ${n} is not yet supported`)}(this.rank);let r;r=`\n        ${e} sourceLoc;\n        ${e} coords = getOutputCoords();\n        ${t.map((o,a)=>`sourceLoc.${NT[a]} = start[${a}] + coords.${NT[a]};`).join("\n")}\n      `,this.userCode=`\n      void main() {\n        ${r}\n        setOutput(getSource(${s}));\n      }\n    `}}const NT=["x","y","z","w","u","v"];class ySe{constructor(t){this.variableNames=["source"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t,this.rank=t.length,this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const e=Xt(this.rank),s=Zs("coords",this.rank),r=Zs("sourceLoc",this.rank),i=1===this.rank?"sourceLoc":`vec2(${r.slice(-2).join()})`,o=`getChannel(getSource(${r.join()}), ${i})`,a=`\n      result.x = ${o};\n      if (++${s[this.rank-1]} < ${t[this.rank-1]}) {\n        ++${r[this.rank-1]};\n        result.y = ${o};\n        --${r[this.rank-1]};\n      }\n    `,l=1===this.rank?"":`\n      --${s[this.rank-1]};\n      if (++${s[this.rank-2]} < ${t[this.rank-2]}) {\n        ++${r[this.rank-2]};\n        result.z = ${o};\n        if (++${s[this.rank-1]} < ${t[this.rank-1]}) {\n          ++${r[this.rank-1]};\n          result.w = ${o};\n        }\n      }\n    `,u=this.rank<=4?`sourceLoc = coords +\n            ${e}(${t.map((c,d)=>`start[${d}]`).join()});`:t.map((c,d)=>`${r[d]} = ${s[d]} + start[${d}];`).join("\n");this.userCode=`\n      void main() {\n        ${e} coords = getOutputCoords();\n        ${e} sourceLoc;\n        ${u}\n        vec4 result = vec4(0.);\n        ${a}\n        ${l}\n        setOutput(result);\n      }\n    `}}function Dd(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{begin:i,size:o}=s,[a,l]=kb(r,i,o);if(kI(r,a,l),0===X(l))return e.makeTensorInfo(l,r.dtype,[]);if(e.shouldExecuteOnCPU([r])||"string"===r.dtype){const d=e.texData.get(r.dataId),h=l0e(d.values,a,l,r.shape,r.dtype);return e.makeTensorInfo(l,r.dtype,h)}const{isPacked:u}=e.texData.get(r.dataId),c=RI(r.shape,a,l);if(u||!c){const d=W().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new ySe(l):new mSe(l);return e.runWebGLProgram(d,[r],r.dtype,[a])}return e.uploadToGPU(r.dataId),function bSe(n,t,e,s){const r=s.texData.get(n.dataId),i=s.makeTensorInfo(e,n.dtype),o=s.texData.get(i.dataId);Object.assign(o,r),o.refCount=1,o.shape=e,o.dtype=n.dtype;let a=MI(t,Be(n.shape));r.slice&&(a+=r.slice.flatOffset),o.slice={flatOffset:a,origDataId:r.slice&&r.slice.origDataId||n.dataId};const l=s.dataRefCount.get(o.slice.origDataId)||1;return s.dataRefCount.set(o.slice.origDataId,l+1),i}(r,a,l,e)}const vSe={kernelName:lb,backendName:"webgl",kernelFunc:Dd},_Se={kernelName:xy,backendName:"webgl",kernelFunc:n=>{const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{blockShape:i,crops:o}=s;S(r.shape.length<=4,()=>"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet");const a=i.reduce((b,v)=>b*v),l=yp(r.shape,i,a),u=bp(l.length,i.length),c=vp(r.shape,i,a),d=AE(o,i.length),h=RE(c,o,i.length),f=[],p=be({inputs:{x:r},backend:e,attrs:{shape:l}}),g=Qs({inputs:{x:p},backend:e,attrs:{perm:u}}),m=be({inputs:{x:g},backend:e,attrs:{shape:c}}),y=Dd({inputs:{x:m},backend:e,attrs:{begin:d,size:h}});return f.push(p),f.push(g),f.push(m),f.forEach(b=>e.disposeIntermediateTensorInfo(b)),y}},xSe={kernelName:KC,backendName:"webgl",kernelFunc:function wSe(n){const{inputs:t,backend:e,attrs:s}=n,{x:r,weights:i}=t,{size:o}=s,a=e.readSync(r.dataId),l=e.readSync(i.dataId),u=rU(a,l,i.dtype,i.shape,o);return e.makeTensorInfo([o],i.dtype,u)}},SSe={kernelName:YC,backendName:"webgl",kernelFunc:function CSe(n){const{inputs:t,backend:e}=n,{s0:s,s1:r}=t,i=e.readSync(s.dataId),o=e.readSync(r.dataId),a=nt(Array.from(i),Array.from(o));return e.makeTensorInfo([a.length],"int32",Int32Array.from(a))}},TU=As({opSnippet:"return float(a != b);",cpuKernelImpl:Jxe,dtype:"bool"}),ISe={kernelName:Yy,backendName:"webgl",kernelFunc:TU};function Gp(n){const{inputs:t,backend:e}=n,{input:s}=t;return Ar({inputs:{x:e.texData.get(s.dataId).complexTensorInfos.real},backend:e})}const ESe={kernelName:AS,backendName:"webgl",kernelFunc:Gp},NSe={kernelName:cf,backendName:"webgl",kernelFunc:function kT(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{dtype:i}=s;if("complex64"===i){if("complex64"===r.dtype)return Ar({inputs:{x:r},backend:e});const o=rs(r.shape),a=kT({inputs:{x:r},backend:e,attrs:{dtype:"float32"}}),l=pl({inputs:{real:a,imag:o},backend:e});return o.dispose(),e.disposeIntermediateTensorInfo(a),l}if("complex64"===r.dtype){const o=Gp({inputs:{input:r},backend:e}),a=kT({inputs:{x:o},backend:e,attrs:{dtype:i}});return e.disposeIntermediateTensorInfo(o),a}if(!A2(r.dtype,i)){const o=Ar({inputs:{x:r},backend:e});return{dataId:o.dataId,shape:o.shape,dtype:i}}if(e.shouldExecuteOnCPU([r])){const o=e.texData.get(r.dataId).values,[a,l,u]=Mxe(o,r.shape,r.dtype,i);return e.makeTensorInfo(a,l,u)}if("int32"===i)return function TSe(n,t){const e=new Fo(n.shape,"return float(int(x));"),s=t.runWebGLProgram(e,[n],"int32");return{dataId:s.dataId,shape:s.shape,dtype:s.dtype}}(r,e);if("bool"===i){const o=e.makeTensorInfo([],"bool",Ds("bool",1)),l=TU({inputs:{a:r,b:o},backend:e});return e.disposeIntermediateTensorInfo(o),l}throw new Error(`Error in Cast: failed to cast ${r.dtype} to ${i}`)}},NU="return ceil(x);",kSe=Nt({opSnippet:NU,packedOpSnippet:NU,cpuKernelImpl:Fxe}),ASe={kernelName:df,backendName:"webgl",kernelFunc:kSe};class RSe{constructor(t){this.variableNames=["A"],this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=t,this.userCode="\n\n      void main() {\n        float value = getAAtOutCoords();\n        if (isnan(value)) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, minVal, maxVal));\n      }\n    "}}class MSe{constructor(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=t,this.userCode="\n      void main() {\n        vec4 value = getAAtOutCoords();\n\n        if (any(isnan(value))) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));\n      }\n    "}}const OSe={kernelName:hf,backendName:"webgl",kernelFunc:function FSe(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{clipValueMin:i,clipValueMax:o}=s;let a;return a=W().getBool("WEBGL_PACK_CLIP")?new MSe(r.shape):new RSe(r.shape),e.runWebGLProgram(a,[r],r.dtype,[[i],[o]])}};class $Se{constructor(t){this.variableNames=["real","imag"],this.outputShape=t,this.userCode="\n      void main() {\n        float re = abs(getRealAtOutCoords());\n        float im = abs(getImagAtOutCoords());\n        float mx = max(re, im);\n\n        // sadly the length function in glsl is not underflow-safe\n        // (at least not on Intel GPUs). So the safe solution is\n        // to ensure underflow-safety in all cases.\n        setOutput(\n          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))\n        );\n      }\n    "}}function kU(n,t){return{dataId:t.dataId,dtype:t.dtype,shape:n.shape}}const LSe={kernelName:Cy,backendName:"webgl",kernelFunc:function PSe(n){const{inputs:t,backend:e}=n,{x:s}=t,r=e.texData.get(s.dataId),i=new $Se(s.shape),o=[kU(s,r.complexTensorInfos.real),kU(s,r.complexTensorInfos.imag)];return e.runWebGLProgram(i,o,o[0].dtype)}};class VSe{constructor(t){this.outputShape=[],this.outputShape=So(t,1),this.variableNames=t.map((o,a)=>`T${a}`);const e=new Array(t.length-1);e[0]=t[0][1];for(let o=1;o<e.length;o++)e[o]=e[o-1]+t[o][1];const s=[`if (yC < ${e[0]}) setOutput(getT0(yR, yC));`];for(let o=1;o<e.length;o++)s.push(`else if (yC < ${e[o]}) setOutput(getT${o}(yR, yC-${e[o-1]}));`);s.push(`else setOutput(getT${e.length}(yR, yC-${e[e.length-1]}));`),this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int yR = coords.x;\n        int yC = coords.y;\n\n        ${s.join("\n        ")}\n      }\n    `}}class BSe{constructor(t,e){this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[],this.outputShape=So(t,e);const s=this.outputShape,r=s.length,i=Xt(r),o=Zs("coords",r),a=["x","y","z","w","u","v"].slice(0,r);this.variableNames=t.map((g,m)=>`T${m}`);const l=new Array(t.length-1);l[0]=t[0][e];for(let g=1;g<l.length;g++)l[g]=l[g-1]+t[g][e];const u=a[e],c=a.slice(-2),d=a.join();let h=`if (${u} < ${l[0]}) {\n        return getChannel(\n            getT0(${d}), vec2(${c.join()}));\n        }`;for(let g=1;g<l.length;g++){const m=l[g-1];h+=`\n        if (${u} < ${l[g]}  && ${u} >= ${l[g-1]}) {\n          return getChannel(\n            getT${g}(${s_(a,u,m)}),\n            vec2(${s_(c,u,m)}));\n        }`}const p=l[l.length-1];h+=`\n        return getChannel(\n          getT${l.length}(${s_(a,u,p)}),\n          vec2(${s_(c,u,p)}));`,this.userCode=`\n      float getValue(${a.map(g=>"int "+g)}) {\n        ${h}\n      }\n\n      void main() {\n        ${i} coords = getOutputCoords();\n        vec4 result = vec4(getValue(${o}), 0., 0., 0.);\n\n        ${o[r-1]} = ${o[r-1]} + 1;\n        if (${o[r-1]} < ${s[r-1]}) {\n          result.g = getValue(${o});\n        }\n\n        ${o[r-2]} = ${o[r-2]} + 1;\n        if (${o[r-2]} < ${s[r-2]}) {\n          result.a = getValue(${o});\n        }\n\n        ${o[r-1]} = ${o[r-1]} - 1;\n        if (${o[r-2]} < ${s[r-2]} &&\n            ${o[r-1]} < ${s[r-1]}) {\n          result.b = getValue(${o});\n        }\n        setOutput(result);\n      }\n    `}}function s_(n,t,e){const s=n.indexOf(t);return n.map((i,o)=>o===s?`${i} - ${e}`:i).join()}function r_(n){const{inputs:t,backend:e}=n,{input:s}=t;return Ar({inputs:{x:e.texData.get(s.dataId).complexTensorInfos.imag},backend:e})}const zSe={kernelName:yS,backendName:"webgl",kernelFunc:r_};function Hp(n,t,e){const s=n[0].dtype;if("complex64"===s){const f=n.map(b=>Gp({inputs:{input:b},backend:e})),p=n.map(b=>r_({inputs:{input:b},backend:e})),g=Hp(f,t,e),m=Hp(p,t,e),y=pl({inputs:{real:g,imag:m},backend:e});return f.forEach(b=>e.disposeIntermediateTensorInfo(b)),p.forEach(b=>e.disposeIntermediateTensorInfo(b)),e.disposeIntermediateTensorInfo(g),e.disposeIntermediateTensorInfo(m),y}let r=e.shouldExecuteOnCPU(n);if("string"===s&&(r=!0),r){const f=n.map(_=>{const C=[-1,X(_.shape.slice(t))];return be({inputs:{x:_},backend:e,attrs:{shape:C}})}),p=f.map(_=>({vals:e.readSync(_.dataId),shape:_.shape})),g=So(f.map(_=>_.shape),1),y=Oxe(p,g,s,1===f[0].shape[0]),b=So(n.map(_=>_.shape),t),v=e.makeTensorInfo(b,s,y);return f.forEach(_=>e.disposeIntermediateTensorInfo(_)),v}const i=n.filter(f=>X(f.shape)>0),o=W().getBool("WEBGL_PACK_ARRAY_OPERATIONS")&&i[0].shape.length>1;if(1===i.length){const f=o?new Fo(n[0].shape,hl):new fl(n[0].shape,hl);return e.runWebGLProgram(f,n,s)}const a=W().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER");if(i.length>a){const f=[];for(let g=0;g<i.length;g+=a){const m=i.slice(g,g+a);f.push(Hp(m,t,e))}const p=Hp(f,t,e);for(const g of f)e.disposeIntermediateTensorInfo(g);return p}if(o){const f=new BSe(i.map(p=>p.shape),t);return e.runWebGLProgram(f,i,s)}const{tensors2D:l,outShape:u}=function USe(n,t,e){const s=So(n.map(i=>i.shape),t);return{tensors2D:n.map(i=>be({inputs:{x:i},attrs:{shape:[-1,X(i.shape.slice(t))]},backend:e})),outShape:s}}(i,t,e),c=new VSe(l.map(f=>f.shape)),d=e.runWebGLProgram(c,l,s);l.forEach(f=>e.disposeIntermediateTensorInfo(f));const h=be({inputs:{x:d},attrs:{shape:u},backend:e});return e.disposeIntermediateTensorInfo(d),h}function AU(n){const{inputs:t,backend:e,attrs:s}=n,{axis:r}=s,i=mt(r,t[0].shape)[0];TE(t.map(u=>u.shape),i);const a=So(t.map(u=>u.shape),i);if(0===X(a))return e.makeTensorInfo(a,t[0].dtype,[]);const l=t.filter(u=>X(u.shape)>0);return 1===l.length?Ar({inputs:{x:l[0]},backend:e}):Hp(l,i,e)}const WSe={kernelName:Sy,backendName:"webgl",kernelFunc:AU};class RU{constructor(t,e=!1,s=null,r=!1,i=!1){this.variableNames=["x","W"],this.outputShape=t.outShape;const o=t.padInfo.top,a=t.padInfo.left,l=t.strideHeight,u=t.strideWidth,c=t.dilationHeight,d=t.dilationWidth,h=t.filterHeight,f=t.filterWidth,p=4*Math.floor(t.inChannels/4),g=t.inChannels%4,m="channelsLast"===t.dataFormat,y=m?1:2,b=m?2:3,v=m?3:1;let _="",x="";s&&(_=r?`float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ${s}\n        }`:i?`float activation(float a) {\n          float b = getLeakyreluAlphaAtOutCoords();\n          ${s}\n        }`:`\n          float activation(float x) {\n            ${s}\n          }\n        `,x="result = activation(result);");const C=e?"result += getBiasAtOutCoords();":"";e&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),i&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n      ${_}\n\n      const ivec2 strides = ivec2(${l}, ${u});\n      const ivec2 pads = ivec2(${o}, ${a});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d2 = coords[${v}];\n\n        ivec2 xRCCorner =\n            ivec2(coords[${y}], coords[${b}]) * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${h}; wR++) {\n          int xR = xRCorner + wR * ${c};\n\n          if (xR < 0 || xR >= ${t.inHeight}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${f}; wC++) {\n            int xC = xCCorner + wC * ${d};\n\n            if (xC < 0 || xC >= ${t.inWidth}) {\n              continue;\n            }\n\n            for (int d1 = 0; d1 < ${p}; d1 += 4) {\n              vec4 wValues = vec4(\n                getW(wR, wC, d1, d2),\n                getW(wR, wC, d1 + 1, d2),\n                getW(wR, wC, d1 + 2, d2),\n                getW(wR, wC, d1 + 3, d2)\n              );\n\n              if (${m}) {\n                vec4 xValues = vec4(\n                  getX(batch, xR, xC, d1),\n                  getX(batch, xR, xC, d1 + 1),\n                  getX(batch, xR, xC, d1 + 2),\n                  getX(batch, xR, xC, d1 + 3)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec4 xValues = vec4(\n                  getX(batch, d1, xR, xC),\n                  getX(batch, d1 + 1, xR, xC),\n                  getX(batch, d1 + 2, xR, xC),\n                  getX(batch, d1 + 3, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n\n            if (${1===g}) {\n\n              if (${m}) {\n                dotProd +=\n                    getX(batch, xR, xC, ${p}) *\n                    getW(wR, wC, ${p}, d2);\n              } else {\n                dotProd +=\n                    getX(batch, ${p}, xR, xC) *\n                    getW(wR, wC, ${p}, d2);\n              }\n\n            } else if (${2===g}) {\n              vec2 wValues = vec2(\n                getW(wR, wC, ${p}, d2),\n                getW(wR, wC, ${p} + 1, d2)\n              );\n\n              if (${m}) {\n                vec2 xValues = vec2(\n                  getX(batch, xR, xC, ${p}),\n                  getX(batch, xR, xC, ${p} + 1)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec2 xValues = vec2(\n                  getX(batch, ${p}, xR, xC),\n                  getX(batch, ${p} + 1, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            } else if (${3===g}) {\n              vec3 wValues = vec3(\n                getW(wR, wC, ${p}, d2),\n                getW(wR, wC, ${p} + 1, d2),\n                getW(wR, wC, ${p} + 2, d2)\n              );\n\n              if (${m}) {\n                vec3 xValues = vec3(\n                  getX(batch, xR, xC, ${p}),\n                  getX(batch, xR, xC, ${p} + 1),\n                  getX(batch, xR, xC, ${p} + 2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec3 xValues = vec3(\n                  getX(batch, ${p}, xR, xC),\n                  getX(batch, ${p} + 1, xR, xC),\n                  getX(batch, ${p} + 2, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            }\n          }\n        }\n\n        float result = dotProd;\n        ${C}\n        ${x}\n        setOutput(result);\n      }\n    `}}class GSe{constructor(t){this.variableNames=["x","W"],this.outputShape=t.outShape;const e=t.padInfo.front,s=t.padInfo.top,r=t.padInfo.left,i=t.strideDepth,o=t.strideHeight,a=t.strideWidth,l=t.dilationDepth,u=t.dilationHeight,c=t.dilationWidth,d=t.filterDepth,h=t.filterHeight,f=t.filterWidth,p=4*Math.floor(t.inChannels/4),g=t.inChannels%4;this.userCode=`\n      const ivec3 strides = ivec3(${i}, ${o}, ${a});\n      const ivec3 pads = ivec3(${e}, ${s}, ${r});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d2 = coords.u;\n\n        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xFCorner = xFRCCorner.x;\n        int xRCorner = xFRCCorner.y;\n        int xCCorner = xFRCCorner.z;\n\n        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get\n        // y(yF, yR, yC, d2). ? = to be determined. : = across all\n        // values in that axis.\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ${d}; wF++) {\n          int xF = xFCorner + wF * ${l};\n\n          if (xF < 0 || xF >= ${t.inDepth}) {\n            continue;\n          }\n\n          for (int wR = 0; wR < ${h}; wR++) {\n            int xR = xRCorner + wR * ${u};\n\n            if (xR < 0 || xR >= ${t.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${f}; wC++) {\n              int xC = xCCorner + wC * ${c};\n\n              if (xC < 0 || xC >= ${t.inWidth}) {\n                continue;\n              }\n\n              for (int d1 = 0; d1 < ${p}; d1 += 4) {\n                vec4 xValues = vec4(\n                  getX(batch, xF, xR, xC, d1),\n                  getX(batch, xF, xR, xC, d1 + 1),\n                  getX(batch, xF, xR, xC, d1 + 2),\n                  getX(batch, xF, xR, xC, d1 + 3)\n                );\n                vec4 wValues = vec4(\n                  getW(wF, wR, wC, d1, d2),\n                  getW(wF, wR, wC, d1 + 1, d2),\n                  getW(wF, wR, wC, d1 + 2, d2),\n                  getW(wF, wR, wC, d1 + 3, d2)\n                );\n\n                dotProd += dot(xValues, wValues);\n              }\n\n              if (${1===g}) {\n                dotProd +=\n                  getX(batch, xF, xR, xC, ${p}) *\n                  getW(wF, wR, wC, ${p}, d2);\n              } else if (${2===g}) {\n                vec2 xValues = vec2(\n                  getX(batch, xF, xR, xC, ${p}),\n                  getX(batch, xF, xR, xC, ${p} + 1)\n                );\n                vec2 wValues = vec2(\n                  getW(wF, wR, wC, ${p}, d2),\n                  getW(wF, wR, wC, ${p} + 1, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else if (${3===g}) {\n                vec3 xValues = vec3(\n                  getX(batch, xF, xR, xC, ${p}),\n                  getX(batch, xF, xR, xC, ${p} + 1),\n                  getX(batch, xF, xR, xC, ${p} + 2)\n                );\n                vec3 wValues = vec3(\n                  getW(wF, wR, wC, ${p}, d2),\n                  getW(wF, wR, wC, ${p} + 1, d2),\n                  getW(wF, wR, wC, ${p} + 2, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class MU{constructor(t,e=!1,s=null,r=!1,i=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=t.outShape,this.enableShapeUniforms=Us(this.outputShape.length);const o=t.padInfo.left,a=t.strideWidth,l=t.dilationWidth,u=t.filterHeight,c=t.filterWidth,d=c;let h="\n       int xR; int xC; int xCOffset;\n       vec4 wTexel; vec4 previous; vec4 final;";for(let m=0;m<c;m++)h+=`\n           vec4 xTexelC${2*m};\n           int xTexelC${2*m}Ready;\n           vec4 xTexelC${2*m+1};\n           int xTexelC${2*m+1}Ready;\n           vec4 xC${m};`;h+=`\n     for (int r = 0; r < ${u}; r++) {\n      for (int d1 = 0; d1 < ${t.inChannels}; d1 += 2) {\n       `;for(let m=0;m<c;m++)h+=`\n           xTexelC${2*m} = vec4(0.0);\n           xTexelC${2*m}Ready = 0;\n           xTexelC${2*m+1} = vec4(0.0);\n           xTexelC${2*m+1}Ready = 0;\n           xC${m} = vec4(0.0);`;h+="\n         xR = xRCorner + r * dilations[0];\n         if (xR >=0 && xR < inDims[0]) {\n       ";for(let m=0;m<(d+1)/2;m++){const y=2*m;if(h+=`\n           xC = xCCorner + ${y*l};\n           `,1===a){if(y<c&&(o%2==1?(h+=`\n                 xCOffset = xC + 1;\n                 if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y}Ready == 0) {\n                   xTexelC${y} = getX(batch, xR, xCOffset, d1);\n\n                   // Need to manually clear unused channels in case\n                   // we're reading from recycled texture.\n                   if (xCOffset + 1 >= inDims[1]) {\n                     xTexelC${y}.zw = vec2(0.0);\n                   }\n                   xTexelC${y}Ready = 1;\n                 }\n               `,h+=1===l&&y>0?`\n                 xC${y} = vec4(xTexelC${y-2}.zw, xTexelC${y}.xy);\n                 `:`\n                   xCOffset = xC + 1 - 2;\n\n                   if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                     previous = getX(batch, xR, xCOffset, d1);\n\n                     // Need to manually clear unused channels in case\n                     // we're reading from recycled texture.\n                     if (xCOffset + 1 >= inDims[1]) {\n                       previous.zw = vec2(0.0);\n                     }\n\n                     xC${y} = vec4(previous.zw, xTexelC${y}.xy);\n                   } else {\n                     xC${y} = vec4(0.0, 0.0, xTexelC${y}.xy);\n                   }\n                   `):h+=`\n                 if (xC >= 0 && xC < inDims[1] && xTexelC${y}Ready == 0) {\n                   xTexelC${y} = getX(batch, xR, xC, d1);\n                   if (xC + 1 >= inDims[1]) {\n                     xTexelC${y}.zw = vec2(0.0);\n                   }\n                   xTexelC${y}Ready = 1;\n                 }\n\n                 xC${y} = xTexelC${y};\n                 `,y+1<c)){const b=o%2==0?$C(l):l;l%2==0&&o%2==1||l%2!=0&&o%2!=1?(h+=`\n                   xCOffset = xC + imod(pads[1], 2) + ${b};\n\n                   if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y+1}Ready == 0) {\n                     xTexelC${y+1} = getX(batch, xR, xCOffset, d1);\n\n                     // Need to manually clear unused channels in case\n                     // we're reading from recycled texture.\n                     if (xCOffset + 1 >= inDims[1]) {\n                       xTexelC${y+1}.zw = vec2(0.0);\n                     }\n                     xTexelC${y+1}Ready = 1;\n                   }\n                   `,h+=l>1?`\n                     xCOffset -= 2;\n                     if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                      previous = getX(batch, xR, xCOffset, d1);\n                      xC${y+1} = vec4(previous.zw, xTexelC${y+1}.xy);\n                     } else {\n                      xC${y+1} = vec4(0.0, 0.0, xTexelC${y+1}.xy);\n                     }\n                     `:`\n                     xC${y+1} = vec4(xTexelC${y}.zw, xTexelC${y+1}.xy);\n                     `):h+=1===b?`\n                     xC${y+1} = xTexelC${y};\n                     `:`\n                     xCOffset = xC + ${b};\n\n                     if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y+1}Ready == 0) {\n                       xTexelC${y+1} = getX(batch, xR, xCOffset, d1);\n                       if (xCOffset + 1 >= inDims[1]) {\n                         xTexelC${y+1}.zw = vec2(0.0);\n                       }\n                       xTexelC${y+1}Ready = 1;\n                     }\n\n                     xC${y+1} = xTexelC${y+1};\n                     `}}else y<c&&(o%2==1?(h+=`\n                 xCOffset = xC + 1 - strides[1];\n                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y}Ready == 0) {\n                   xTexelC${y} = getX(batch, xR, xCOffset, d1);\n                   // Need to manually clear unused channels in case\n                   // we're reading from recycled texture.\n                   if (xCOffset + 1 >= inDims[1]) {\n                     xTexelC${y}.zw = vec2(0.0);\n                   }\n                   xTexelC${y}Ready = 1;\n                 }\n\n                 if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${y+1}Ready == 0) {\n                   xTexelC${y+1} = getX(batch, xR, xC + 1, d1);\n                   // Need to manually clear unused channels in case\n                   // we're reading from recycled texture.\n                   if (xC + 2 >= inDims[1]) {\n                     xTexelC${y+1}.zw = vec2(0.0);\n                   }\n                   xTexelC${y+1}Ready = 1;\n                 }\n\n                 xC${y} = vec4(xTexelC${y}.zw, xTexelC${y+1}.zw);\n               `,y+1<c&&(h+=`\n                   final = vec4(0.0);\n                   xCOffset = xC + 1 + strides[1];\n                   if(xCOffset >= 0 && xCOffset < inDims[1]) {\n                     final = getX(batch, xR, xCOffset, d1);\n                   }\n                   xC${y+1} = vec4(xTexelC${y+1}.xy, final.xy);\n                 `)):(h+=`\n                 if(xC >= 0 && xC < inDims[1] && xTexelC${y}Ready == 0) {\n                   xTexelC${y} = getX(batch, xR, xC, d1);\n                   if (xC + 1 >= inDims[1]) {\n                     xTexelC${y}.zw = vec2(0.0);\n                   }\n                   xTexelC${y}Ready = 1;\n                 }\n\n                 xCOffset = xC + strides[1];\n                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y+1}Ready == 0) {\n                   xTexelC${y+1} = getX(batch, xR, xCOffset, d1);\n                   if (xCOffset + 1 >= inDims[1]) {\n                     xTexelC${y+1}.zw = vec2(0.);\n                   }\n                   xTexelC${y+1}Ready = 1;\n                 }\n\n                 xC${y} = vec4(\n                   xTexelC${y}.xy, xTexelC${y+1}.xy);\n               `,y+1<c&&(h+=`\n                   xC${y+1} = vec4(xTexelC${y}.zw, xTexelC${y+1}.zw);\n                 `)));y<c&&(h+=`\n             wTexel = getW(r, ${y}, d1, d2);\n             dotProd += xC${y}.xxzz * vec4(wTexel.xy, wTexel.xy);\n             if(d1 + 1 < ${t.inChannels}) {\n               dotProd += xC${y}.yyww * vec4(wTexel.zw, wTexel.zw);\n             }\n           `,y+1<c&&(h+=`\n               wTexel = getW(r, ${y+1}, d1, d2);\n               dotProd += xC${y+1}.xxzz * vec4(wTexel.xy, wTexel.xy);\n               if(d1 + 1 < ${t.inChannels}) {\n                 dotProd += xC${y+1}.yyww * vec4(wTexel.zw, wTexel.zw);\n               }\n             `))}h+="\n     }\n   ",h+="\n     }\n   ",h+="\n     }\n   ";let f="",p="";s&&(f=r?`vec4 activation(vec4 a) {\n           vec4 b = getPreluActivationWeightsAtOutCoords();\n           ${s}\n         }`:i?`vec4 activation(vec4 a) {\n           vec4 b = getLeakyreluAlphaAtOutCoords();\n           ${s}\n         }`:`vec4 activation(vec4 x) {\n           ${s}\n         }`,p="result = activation(result);");const g=e?"result += getBiasAtOutCoords();":"";e&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),i&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n       ${f}\n\n       void main() {\n         ivec4 coords = getOutputCoords();\n         int batch = coords.x;\n         ivec2 xRCCorner = coords.yz * strides - pads;\n         int d2 = coords.w;\n         int xRCorner = xRCCorner.x;\n         int xCCorner = xRCCorner.y;\n\n         //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.\n         vec4 dotProd = vec4(0.000000000000001);\n\n         ${h}\n\n         vec4 result = dotProd - vec4(0.000000000000001);\n         ${g}\n         ${p}\n         setOutput(result);\n       }\n     `}}class HSe{constructor(t,e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec4"},{name:"pad",type:"ivec2"},{name:"stride",type:"ivec2"},{name:"dilation",type:"ivec2"},{name:"inChannels",type:"int"},{name:"itemsPerBlockRow",type:"int"},{name:"outWidth",type:"int"}],this.outputShape=t,this.enableShapeUniforms=Us(this.outputShape.length);const{dataFormat:s}=e,r=Ys(),i="channelsLast"===s,o=i?1:2,a=i?2:3,l=this.enableShapeUniforms?"if(blockIndex < outShape[2] && pos < outShape[1]) {":`if(blockIndex < ${t[2]} && pos < ${t[1]}) {`;let u="";for(let c=0;c<=1;c++)for(let d=0;d<=1;d++)u+=`\n          blockIndex = rc.z + ${d};\n          pos = rc.y + ${c};\n\n          ${l}\n            offsetY = int(blockIndex / outWidth) * stride[0] - pad[0];\n            d0 = offsetY + dilation[0] * (pos / itemsPerBlockRow);\n\n            if(d0 < inputShape[${o}] && d0 >= 0) {\n              // Use custom imod instead mod. On Intel GPU, mod may generate\n              // unexpected value.\n              // https://github.com/tensorflow/tfjs/issues/5447\n              offsetX = imod(blockIndex, outWidth) * stride[1] - pad[1];\n              d1 = offsetX + dilation[1] * (imod(pos, itemsPerBlockRow) /\n                  inChannels);\n\n              if(d1 < inputShape[${a}] && d1 >= 0) {\n\n                ch = imod(pos, inChannels);\n\n                if (${i}) {\n                  innerDims = vec2(d1, ch);\n                  result[${2*c+d}] = getChannel(\n                    getA(rc.x, d0, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                } else {\n                  innerDims = vec2(d0, d1);\n                  result[${2*c+d}] = getChannel(\n                    getA(rc.x, ch, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                }\n              }\n            }\n          }\n        `;this.userCode=`\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0);\n\n        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;\n        vec2 innerDims;\n\n        ${u}\n\n        ${r.output} = result;\n      }\n    `}}function i_(n,t){const e=n.length;return e>=3?t?[...n.slice(0,-3),n[e-3]*n[e-2],n[e-1]]:[...n.slice(0,-3),n[e-3],n[e-2]*n[e-1]]:!t&&1===e&&n[0]>1?[n[0],1]:null}function FU({x:n,filter:t,convInfo:e,backend:s,bias:r=null,preluActivationWeights:i=null,leakyreluAlpha:o=0,activation:a=null}){const l=n.shape,u=s.texData.get(n.dataId),c=e.inChannels,d=l[0]*l[1]*l[2],h=e.outChannels,f="channelsLast"===e.dataFormat;let m;const y=[];if(null!=i){const _=i_(i.shape,f);null!=_&&(i=be({inputs:{x:i},backend:s,attrs:{shape:_}}),y.push(i))}if(null!=r){const _=i_(r.shape,f);null!=_&&(r=be({inputs:{x:r},backend:s,attrs:{shape:_}}),y.push(r))}if((1!==d&&1!==h||!(c>xU))&&u.isPacked&&f&&null!=u.texture&&l[2]%2!=0&&wt(u.shape.slice(-3),l.slice(-3))){const x={dataId:n.dataId,shape:[1,l[0]*l[1]*(l[2]+1),e.inChannels],dtype:n.dtype},C=u.shape;u.shape=u.shape.slice(),u.shape[u.shape.length-2]++,S(qv(u.shape,x.shape),()=>`packed reshape ${u.shape} to ${x.shape} isn't free`);const E=be({inputs:{x:t},backend:s,attrs:{shape:[1,e.inChannels,e.outChannels]}});y.push(E);const D=t_({a:x,b:E,backend:s,transposeA:!1,transposeB:!1,bias:r,activation:a,preluActivationWeights:i,leakyreluAlpha:o}),N=s.texData.get(D.dataId);S(N.isPacked,()=>"batchMatMul result is expected to be packed"),u.shape=C,N.shape=e.outShape,m=Ar({inputs:{x:D},backend:s}),m.shape=e.outShape,y.push(D)}else{const _=e.outHeight*e.outWidth,x=be({inputs:{x:n},backend:s,attrs:{shape:f?[e.batchSize,_,e.inChannels]:[e.batchSize,e.inChannels,_]}}),C=be({inputs:{x:t},backend:s,attrs:{shape:[1,e.inChannels,e.outChannels]}}),E=t_({a:f?x:C,b:f?C:x,transposeA:!f,transposeB:!1,backend:s,bias:r,activation:a,preluActivationWeights:i,leakyreluAlpha:o});m=be({inputs:{x:E},backend:s,attrs:{shape:e.outShape}}),y.push(x),y.push(C),y.push(E)}for(const _ of y)s.disposeIntermediateTensorInfo(_);return m}function OU({x:n,filter:t,convInfo:e,backend:s,bias:r=null,preluActivationWeights:i=null,leakyreluAlpha:o=0,activation:a=null}){const{filterWidth:l,filterHeight:u,inChannels:c,outWidth:d,outHeight:h,dataFormat:f}=e,p="channelsLast"===f,g=l*u*c,m=h*d,y=[e.batchSize,g,m],_=[];if(null!=i){const L=i_(i.shape,p);null!=L&&(i=be({inputs:{x:i},backend:s,attrs:{shape:L}}),_.push(i))}if(null!=r){const L=i_(r.shape,p);null!=L&&(r=be({inputs:{x:r},backend:s,attrs:{shape:L}}),_.push(r))}const x=be({inputs:{x:t},backend:s,attrs:{shape:[1,g,X(t.shape)/g]}});_.push(x);const C=new HSe(y,e),D=s.runWebGLProgram(C,[n],"float32",[n.shape,[e.padInfo.top,e.padInfo.left],[e.strideHeight,e.strideWidth],[e.dilationHeight,e.dilationWidth],[e.inChannels],[e.filterWidth*e.inChannels],[e.outWidth]]),N=be({inputs:{x:D},backend:s,attrs:{shape:y}});_.push(D),_.push(N);const R=null!=r,V=null!=i,G="leakyrelu"===a,j=a?Up(a,!0):null,q=new yU(p?N.shape:x.shape,p?x.shape:N.shape,p?[e.batchSize,m,e.outChannels]:[e.batchSize,e.outChannels,m],!0,!1,R,j,V,G),K=p?[N,x]:[x,N];if(r&&K.push(r),V&&K.push(i),G){const L=s.makeTensorInfo([],"float32",$a(o,"float32"));K.push(L),_.push(L)}const P=s.runWebGLProgram(q,K,"float32"),B=be({inputs:{x:P},backend:s,attrs:{shape:e.outShape}});_.push(P);for(const L of _)s.disposeIntermediateTensorInfo(L);return B}const qSe={kernelName:Iy,backendName:"webgl",kernelFunc:function jSe(n){const{inputs:t,backend:e,attrs:s}=n,{x:r,filter:i}=t,{strides:o,pad:a,dataFormat:l,dilations:u,dimRoundingMode:c}=s,d=la(l),h=_s(r.shape,i.shape,o,u,a,c,!1,d);let f;if(1!==h.filterHeight||1!==h.filterWidth||1!==h.dilationHeight||1!==h.dilationWidth||1!==h.strideHeight||1!==h.strideWidth||"SAME"!==h.padInfo.type&&"VALID"!==h.padInfo.type)if(h.strideWidth<=2&&"channelsLast"===d&&W().getBool("WEBGL_EXP_CONV")){const g=new MU(h);f=e.runWebGLProgram(g,[r,i],"float32",[[h.padInfo.top,h.padInfo.left],[h.strideHeight,h.strideWidth],[h.dilationHeight,h.dilationWidth],[h.inHeight,h.inWidth]])}else if(W().getBool("WEBGL_CONV_IM2COL"))f=OU({x:r,filter:i,convInfo:h,backend:e});else{const g=new RU(h);f=e.runWebGLProgram(g,[r,i],"float32")}else f=FU({x:r,filter:i,convInfo:h,backend:e});const p=be({inputs:{x:f},backend:e,attrs:{shape:h.outShape}});return e.disposeIntermediateTensorInfo(f),p}};class KSe{constructor(t){this.variableNames=["x","dy"],this.outputShape=t.filterShape,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int d2 = coords.w;\n\n        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ${t.batchSize}; b++) {\n          for (int yR = 0; yR < ${t.outHeight}; yR++) {\n            int xR = wR + yR * ${t.strideHeight} - ${t.padInfo.top};\n\n            if (xR < 0 || xR >= ${t.inHeight}) {\n              continue;\n            }\n\n            for (int yC = 0; yC < ${t.outWidth}; yC++) {\n              int xC = wC + yC * ${t.strideWidth} - ${t.padInfo.left};\n\n              if (xC < 0 || xC >= ${t.inWidth}) {\n                continue;\n              }\n\n              ${"channelsLast"===t.dataFormat?"float dyValue = getDy(b, yR, yC, d2);\n              float xValue = getX(b, xR, xC, d1);\n              dotProd += (xValue * dyValue);":"float dyValue = getDy(b, d2, yR, yC);\n              float xValue = getX(b, d1, xR, xC);\n              dotProd += (xValue * dyValue);"}\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class XSe{constructor(t){this.variableNames=["dy","W"],this.outputShape=t.inShape;const e=t.filterHeight,s=t.filterWidth,o="channelsLast"===t.dataFormat;this.userCode=`\n      const ivec2 pads = ivec2(${e-1-t.padInfo.top}, ${s-1-t.padInfo.left});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[${o?3:1}];\n\n        ivec2 dyCorner = ivec2(coords[${o?1:2}], coords[${o?2:3}]) - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${e}; wR++) {\n          float dyR = float(dyRCorner + wR) / ${t.strideHeight}.0;\n\n          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ${e} - 1 - wR;\n\n          for (int wC = 0; wC < ${s}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${t.strideWidth}.0;\n\n            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ${s} - 1 - wC;\n\n            for (int d2 = 0; d2 < ${t.outChannels}; d2++) {\n\n              if (${o}) {\n                float xValue = getDy(batch, idyR, idyC, d2);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              } else {\n                float xValue = getDy(batch, d2, idyR, idyC);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class YSe{constructor(t){this.variableNames=["x","dy"],this.outputShape=t.filterShape,this.userCode=`\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int wF = coords.x;\n        int wR = coords.y;\n        int wC = coords.z;\n        int d1 = coords.w;\n        int d2 = coords.u;\n\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ${t.batchSize}; b++) {\n          for (int yF = 0; yF < ${t.outDepth}; yF++) {\n            int xF = wF + yF * ${t.strideDepth} - ${t.padInfo.front};\n\n            if (xF < 0 || xF >= ${t.inDepth}) {\n              continue;\n            }\n\n            for (int yR = 0; yR < ${t.outHeight}; yR++) {\n              int xR = wR + yR * ${t.strideHeight} - ${t.padInfo.top};\n\n              if (xR < 0 || xR >= ${t.inHeight}) {\n                continue;\n              }\n\n              for (int yC = 0; yC < ${t.outWidth}; yC++) {\n                int xC = wC + yC * ${t.strideWidth} - ${t.padInfo.left};\n\n                if (xC < 0 || xC >= ${t.inWidth}) {\n                  continue;\n                }\n\n                float dyValue = getDy(b, yF, yR, yC, d2);\n                float xValue = getX(b, xF, xR, xC, d1);\n                dotProd += (xValue * dyValue);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class ZSe{constructor(t){this.variableNames=["dy","W"],this.outputShape=t.inShape;const e=t.filterDepth,s=t.filterHeight,r=t.filterWidth;this.userCode=`\n      const ivec3 pads = ivec3(${e-1-t.padInfo.front}, ${s-1-t.padInfo.top}, ${r-1-t.padInfo.left});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.u;\n\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyFCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ${e}; wF++) {\n          float dyF = float(dyFCorner + wF) / ${t.strideDepth}.0;\n\n          if (dyF < 0.0 || dyF >= ${t.outDepth}.0 || fract(dyF) > 0.0) {\n            continue;\n          }\n          int idyF = int(dyF);\n\n          int wFPerm = ${e} - 1 - wF;\n\n          for (int wR = 0; wR < ${s}; wR++) {\n            float dyR = float(dyRCorner + wR) / ${t.strideHeight}.0;\n\n            if (dyR < 0.0 || dyR >= ${t.outHeight}.0 ||\n              fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            int wRPerm = ${s} - 1 - wR;\n\n            for (int wC = 0; wC < ${r}; wC++) {\n              float dyC = float(dyCCorner + wC) / ${t.strideWidth}.0;\n\n              if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              int wCPerm = ${r} - 1 - wC;\n\n              for (int d2 = 0; d2 < ${t.outChannels}; d2++) {\n                float xValue = getDy(batch, idyF, idyR, idyC, d2);\n                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const JSe={kernelName:QC,backendName:"webgl",kernelFunc:function QSe(n){const{inputs:t,backend:e,attrs:s}=n,{x:r,dy:i}=t,{strides:o,pad:a,dataFormat:l,dimRoundingMode:u,filterShape:c}=s,d=la(l),h=_s(r.shape,c,o,1,a,u,!1,d),f=new KSe(h);return e.runWebGLProgram(f,[r,i],"float32")}};class eIe{constructor(t){this.variableNames=["dy","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"strides",type:"vec2"}],this.outputShape=t.inShape,this.enableShapeUniforms=Us(this.outputShape.length);const e=t.filterHeight,s=t.filterWidth;this.userCode=`\n      const ivec2 pads = ivec2(${e-1-t.padInfo.top}, ${s-1-t.padInfo.left});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[3];\n\n        ivec2 dyCorner = ivec2(coords[1], coords[2]) - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        vec4 result = vec4(0.);\n        for (int wR = 0; wR < ${e}; wR++) {\n          float dyR = float(dyRCorner + wR) / strides[0];\n          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n          int wRPerm = ${e} - 1 - wR;\n\n          for (int wC = 0; wC < ${s}; wC++) {\n            int wCPerm = ${s} - 1 - wC;\n\n            float dyC = float(dyCCorner + wC) / strides[1];\n            bool idyCVal = (dyC >= 0.0) && (dyC < ${t.outWidth}.0)\n              && (fract(dyC) == 0.0);\n            int idyC = int(dyC);\n\n            float dyC2 = float(dyCCorner + wC + 1) / strides[1];\n            bool idyCVal2 = (dyC2 >= 0.0) && (dyC2 < ${t.outWidth}.0)\n              && (fract(dyC2) == 0.0);\n            int idyC2 = int(dyC2);\n\n            if (idyCVal && idyCVal2) {\n              for (int d2 = 0; d2 < ${t.outChannels}; d2 += 2) {\n                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);\n                vec4 dySample = getDy(batch, idyR, idyC, d2);\n                vec4 dySample2 = (idyC / 2 == idyC2 / 2) ?\n                  dySample : getDy(batch, idyR, idyC2, d2);\n\n                vec2 dyValue = mod(float(idyC), 2.) == 0. ?\n                  dySample.xy : dySample.zw;\n                result.xy += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n\n                dyValue = mod(float(idyC2), 2.) == 0. ?\n                  dySample2.xy : dySample2.zw;\n                result.zw += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n              }\n            } else if (idyCVal) {\n              for (int d2 = 0; d2 < ${t.outChannels}; d2 += 2) {\n                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);\n                vec4 dySample = getDy(batch, idyR, idyC, d2);\n                vec2 dyValue = mod(float(idyC), 2.) == 0. ?\n                  dySample.xy : dySample.zw;\n                result.xy += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n              }\n            } else if (idyCVal2) {\n              for (int d2 = 0; d2 < ${t.outChannels}; d2 += 2) {\n                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);\n                vec4 dySample = getDy(batch, idyR, idyC2, d2);\n                vec2 dyValue = mod(float(idyC2), 2.) == 0. ?\n                  dySample.xy : dySample.zw;\n                result.zw += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n              }\n            }\n          }\n        }\n        setOutput(result);\n      }\n    `}}const nIe={kernelName:Ey,backendName:"webgl",kernelFunc:function tIe(n){const{inputs:t,backend:e,attrs:s}=n,{dy:r,filter:i}=t,{inputShape:o,strides:a,pad:l,dataFormat:u,dimRoundingMode:c}=s,d=la(u),h=_s(o,i.shape,a,1,l,c,!1,d);if(W().getBool("WEBGL_PACK")&&"channelsLast"===d){const f=[[h.strideHeight,h.strideWidth]],p=new eIe(h);return e.runWebGLProgram(p,[r,i],"float32",f)}{const f=new XSe(h);return e.runWebGLProgram(f,[r,i],"float32")}}},rIe={kernelName:Dy,backendName:"webgl",kernelFunc:function sIe(n){const{inputs:t,backend:e,attrs:s}=n,{x:r,filter:i}=t,{strides:o,pad:a,dilations:l}=s,u=Xa(r.shape,i.shape,o,l,a),c=new GSe(u);return e.runWebGLProgram(c,[r,i],"float32")}},oIe={kernelName:JC,backendName:"webgl",kernelFunc:function iIe(n){const{inputs:t,backend:e,attrs:s}=n,{x:r,dy:i}=t,{strides:o,pad:a,filterShape:l}=s,u=Xa(r.shape,l,o,1,a),c=new YSe(u);return e.runWebGLProgram(c,[r,i],"float32")}},lIe={kernelName:eS,backendName:"webgl",kernelFunc:function aIe(n){const{inputs:t,backend:e,attrs:s}=n,{dy:r,filter:i}=t,{pad:o,strides:a,inputShape:l}=s,u=Xa(l,i.shape,a,1,o),c=new ZSe(u);return e.runWebGLProgram(c,[r,i],"float32")}},dIe=Nt({opSnippet:Ed+"\n  return cos(x);\n",packedOpSnippet:`\n  vec4 result = cos(x);\n  bvec4 isNaN = isnan(x);\n  ${Cu}\n  return result;\n`}),hIe={kernelName:ff,backendName:"webgl",kernelFunc:dIe},fIe=Nt({opSnippet:"\n  float e2x = exp(-x);\n  return (e2x + 1.0 / e2x) / 2.0;\n"}),pIe={kernelName:pf,backendName:"webgl",kernelFunc:fIe};class mIe{constructor(t,e,s,r,i){this.variableNames=["Image","Boxes","BoxInd"],this.outputShape=[];const[o,a,l,u]=t,[c]=e,[d,h]=s;this.outputShape=[c,d,h,u];const f="bilinear"===r?1:0,[p,g]=[a-1+".0",l-1+".0"],[m,y,b]=d>1?[""+(a-1)/(d-1),"(y2-y1) * height_ratio",`y1*${p} + float(y)*(height_scale)`]:["0.0","0.0",`0.5 * (y1+y2) * ${p}`],[v,_,x]=h>1?[""+(l-1)/(h-1),"(x2-x1) * width_ratio",`x1*${g} + float(x)*(width_scale)`]:["0.0","0.0",`0.5 * (x1+x2) * ${g}`];this.userCode=`\n      const float height_ratio = float(${m});\n      const float width_ratio = float(${v});\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int y = coords[1];\n        int x = coords[2];\n        int d = coords[3];\n\n        // get box vals\n        float y1 = getBoxes(b,0);\n        float x1 = getBoxes(b,1);\n        float y2 = getBoxes(b,2);\n        float x2 = getBoxes(b,3);\n\n        // get image in batch index\n        int bInd = round(getBoxInd(b));\n        if(bInd < 0 || bInd >= ${o}) {\n          return;\n        }\n\n        float height_scale = ${y};\n        float width_scale = ${_};\n\n        float in_y = ${b};\n        if( in_y < 0.0 || in_y > ${p} ) {\n          setOutput(float(${i}));\n          return;\n        }\n        float in_x = ${x};\n        if( in_x < 0.0 || in_x > ${g} ) {\n          setOutput(float(${i}));\n          return;\n        }\n\n        vec2 sourceFracIndexCR = vec2(in_x,in_y);\n        if(${f} == 1) {\n          // Compute the four integer indices.\n          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);\n          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));\n\n          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);\n          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);\n          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);\n          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);\n\n          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);\n\n          float top = topLeft + (topRight - topLeft) * fracCR.x;\n          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;\n          float newValue = top + (bottom - top) * fracCR.y;\n          setOutput(newValue);\n        } else {\n          // Compute the coordinators of nearest neighbor point.\n          ivec2 sourceNearestCR = ivec2(floor(\n            sourceFracIndexCR + vec2(0.5,0.5)));\n          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);\n          setOutput(newValue);\n        }\n      }\n    `}}const gIe={kernelName:nS,backendName:"webgl",kernelFunc:n=>{const{inputs:t,backend:e,attrs:s}=n,{image:r,boxes:i,boxInd:o}=t,{cropSize:a,method:l,extrapolationValue:u}=s,c=new mIe(r.shape,i.shape,a,l,u);return e.runWebGLProgram(c,[r,i,o],"float32")}};var ml=(()=>((ml=ml||{}).Prod="*",ml.Sum="+",ml))();class $U{constructor(t,e,s,r){this.op=t,this.outputShape=e,this.variableNames=["x"],this.customUniforms=[{name:"index",type:"float"}];const i=this.outputShape.length,a=s?this.op===ml.Prod?"1.0":"0.0":`getX(${PU(i,"coords",this.op)})`,l=this.outputShape[this.outputShape.length-1];let u="",c="";s?(u=r?"end != "+(l-1):"end != 0",c=r?"end + 1":"end - 1"):(u=r?`end + pow2 < ${l}`:"end >= pow2",c=r?"end + pow2":"end - pow2"),this.userCode=`\n      void main() {\n        ${Xt(i)} coords = getOutputCoords();\n        int end = ${LU(i,"coords",this.op)};\n        float val = ${a};\n        int pow2 = int(pow(2.0, index));\n        if (${u}) {\n          int idx = ${c};\n          ${LU(i,"coords",this.op)} = idx;\n          val ${this.op}= getX(${PU(i,"coords",this.op)});\n        }\n        setOutput(val);\n      }\n    `}}function PU(n,t,e){if(1===n)return`${t}`;if(2===n)return`${t}.x, ${t}.y`;if(3===n)return`${t}.x, ${t}.y, ${t}.z`;if(4===n)return`${t}.x, ${t}.y, ${t}.z, ${t}.w`;throw new Error(`Cumulative ${e} for rank ${n} is not yet supported`)}function LU(n,t,e){if(1===n)return`${t}`;if(2===n)return`${t}.y`;if(3===n)return`${t}.z`;if(4===n)return`${t}.w`;throw new Error(`Cumulative ${e} for rank ${n} is not yet supported`)}function VU(n,t,e,s,r,i){const o=t.shape.length,a=vn([s],o);let l=t;null!=a&&(l=Qs({inputs:{x:t},backend:e,attrs:{perm:a}}));const u=$n(1,o)[0];if(u!==o-1)throw new Error(`WebGL cumprod shader expects an inner-most axis=${t.shape.length-1} but got axis=${s}`);const c=l.shape[u];let d=Ar({inputs:{x:l},backend:e});for(let h=0;h<=Math.ceil(Math.log2(c))-1;h++){const f=new $U(n,l.shape,!1,i),g=d;d=e.runWebGLProgram(f,[d],d.dtype,[[h]]),e.disposeIntermediateTensorInfo(g)}if(r){const h=new $U(n,l.shape,r,i),f=d;d=e.runWebGLProgram(h,[d],d.dtype),e.disposeIntermediateTensorInfo(f)}if(null!=a){const f=Qs({inputs:{x:d},backend:e,attrs:{perm:Qa(a)}});return e.disposeIntermediateTensorInfo(d),e.disposeIntermediateTensorInfo(l),f}return d}const bIe={kernelName:tS,backendName:"webgl",kernelFunc:function yIe(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{axis:i,exclusive:o,reverse:a}=s;return VU(ml.Prod,r,e,i,o,a)}},_Ie={kernelName:Ty,backendName:"webgl",kernelFunc:function vIe(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{axis:i,exclusive:o,reverse:a}=s;return VU(ml.Sum,r,e,i,o,a)}},xIe={kernelName:sS,backendName:"webgl",kernelFunc:function wIe(n){const{inputs:t,backend:e,attrs:s}=n,{x:r,weights:i}=t,{size:o,binaryOutput:a}=s;if(1===r.shape.length){const l=e.readSync(r.dataId),u=e.readSync(i.dataId),c=rU(l,u,i.dtype,i.shape,o);return e.makeTensorInfo([o],i.dtype,c)}if(2===r.shape.length){const l=e.bufferSync(r),u=e.bufferSync(i),c=Rxe(l,u,o,a);return e.makeTensorInfo(c.shape,i.dtype,c.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${r.shape.length}.`)}};class CIe{constructor(t,e,s){this.variableNames=["x"],this.outputShape=[],this.outputShape=t,this.blockSize=e,this.dataFormat=s,this.userCode=`\n    void main() {\n      ivec4 coords = getOutputCoords();\n      int b = coords[0];\n      int h = ${this.getHeightCoordString()};\n      int w = ${this.getWidthCoordString()};\n      int d = ${this.getDepthCoordString()};\n\n      int in_h = h / ${e};\n      int offset_h = imod(h, ${e});\n      int in_w = w / ${e};\n      int offset_w = imod(w, ${e});\n      int offset_d = (offset_h * ${e} + offset_w) *\n        ${this.getOutputDepthSize()};\n      int in_d = d + offset_d;\n\n      float result = ${this.getInputSamplingString()};\n      setOutput(result);\n    }\n  `}getHeightCoordString(){return"NHWC"===this.dataFormat?"coords[1]":"coords[2]"}getWidthCoordString(){return"NHWC"===this.dataFormat?"coords[2]":"coords[3]"}getDepthCoordString(){return"NHWC"===this.dataFormat?"coords[3]":"coords[1]"}getOutputDepthSize(){return"NHWC"===this.dataFormat?this.outputShape[3]:this.outputShape[1]}getInputSamplingString(){return"NHWC"===this.dataFormat?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}}const IIe={kernelName:rS,backendName:"webgl",kernelFunc:function SIe(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{blockSize:i,dataFormat:o}=s,a=r.shape[0],d=("NHWC"===o?r.shape[1]:r.shape[2])*i,h=("NHWC"===o?r.shape[2]:r.shape[3])*i,f=("NHWC"===o?r.shape[3]:r.shape[1])/(i*i),g=new CIe("NHWC"===o?[a,d,h,f]:[a,f,d,h],i,o);return e.runWebGLProgram(g,[r],r.dtype)}};class BU{constructor(t,e=!1,s=null,r=!1,i=!1){this.variableNames=["x","W"],this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=t.outShape,this.enableShapeUniforms=Us(this.outputShape.length);const o=t.filterHeight,a=t.filterWidth,l=t.outChannels/t.inChannels;let u="",c="";s&&(u=r?`float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ${s}\n        }`:i?`float activation(float a) {\n          float b = getLeakyreluAlphaAtOutCoords();\n          ${s}\n        }`:`\n          float activation(float x) {\n            ${s}\n          }\n        `,c="result = activation(result);");const d=e?"result += getBiasAtOutCoords();":"";e&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),i&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n      ${u}\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / ${l};\n        int q = d2 - d1 * ${l};\n\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.\n        for (int wR = 0; wR < ${o}; wR++) {\n          int xR = xRCorner + wR * dilations[0];\n\n          if (xR < 0 || xR >= inDims[0]) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${a}; wC++) {\n            int xC = xCCorner + wC * dilations[1];\n\n            if (xC < 0 || xC >= inDims[1]) {\n              continue;\n            }\n\n            float xVal = getX(batch, xR, xC, d1);\n            float wVal = getW(wR, wC, d1, q);\n            dotProd += xVal * wVal;\n          }\n        }\n\n        float result = dotProd;\n        ${d}\n        ${c}\n        setOutput(result);\n      }\n    `}}class zU{constructor(t,e=!1,s=null,r=!1,i=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=t.outShape,this.enableShapeUniforms=Us(this.outputShape.length);const o=t.outChannels/t.inChannels,a=t.padInfo.left,l=t.strideWidth,u=t.dilationWidth,c=t.filterHeight,d=t.filterWidth,h=d;let f="\n      int xR; int xC; int xCOffset;\n      vec4 wTexel; vec4 previous; vec4 final;";for(let y=0;y<d;y++)f+=`\n          vec4 xTexelC${2*y};\n          int xTexelC${2*y}Ready;\n          vec4 xTexelC${2*y+1};\n          int xTexelC${2*y+1}Ready;\n          vec4 xC${y};`;f+=`\n    for (int r = 0; r < ${c}; r++) {\n      `;for(let y=0;y<d;y++)f+=`\n          xTexelC${2*y} = vec4(0.0);\n          xTexelC${2*y}Ready = 0;\n          xTexelC${2*y+1} = vec4(0.0);\n          xTexelC${2*y+1}Ready = 0;\n          xC${y} = vec4(0.0);`;f+="\n        xR = xRCorner + r * dilations[0];\n        if (xR >=0 && xR < inDims[0]) {\n      ";for(let y=0;y<(h+1)/2;y++){const b=2*y;if(f+=`\n          xC = xCCorner + ${b*u};\n          `,1===l){if(b<d&&(a%2==1?(f+=`\n                xCOffset = xC + 1;\n                if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b}Ready == 0) {\n                  xTexelC${b} = getX(batch, xR, xCOffset, d1);\n\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC${b}.zw = vec2(0.0);\n                  }\n                  xTexelC${b}Ready = 1;\n                }\n              `,f+=1===u&&b>0?`\n                xC${b} = vec4(xTexelC${b-2}.zw, xTexelC${b}.xy);\n                `:`\n                  xCOffset = xC + 1 - 2;\n\n                  if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                    previous = getX(batch, xR, xCOffset, d1);\n\n                    // Need to manually clear unused channels in case\n                    // we're reading from recycled texture.\n                    if (xCOffset + 1 >= inDims[1]) {\n                      previous.zw = vec2(0.0);\n                    }\n\n                    xC${b} = vec4(previous.zw, xTexelC${b}.xy);\n                  } else {\n                    xC${b} = vec4(0.0, 0.0, xTexelC${b}.xy);\n                  }\n                  `):f+=`\n                if (xC >= 0 && xC < inDims[1] && xTexelC${b}Ready == 0) {\n                  xTexelC${b} = getX(batch, xR, xC, d1);\n                  if (xC + 1 >= inDims[1]) {\n                    xTexelC${b}.zw = vec2(0.0);\n                  }\n                  xTexelC${b}Ready = 1;\n                }\n\n                xC${b} = xTexelC${b};\n                `,b+1<d)){const v=a%2==0?$C(u):u;u%2==0&&a%2==1||u%2!=0&&a%2!=1?(f+=`\n                  xCOffset = xC + imod(pads[1], 2) + ${v};\n\n                  if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b+1}Ready == 0) {\n                    xTexelC${b+1} = getX(batch, xR, xCOffset, d1);\n\n                    // Need to manually clear unused channels in case\n                    // we're reading from recycled texture.\n                    if (xCOffset + 1 >= inDims[1]) {\n                      xTexelC${b+1}.zw = vec2(0.0);\n                    }\n                    xTexelC${b+1}Ready = 1;\n                  }\n                  `,f+=u>1?`\n                    xCOffset -= 2;\n                    if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                     previous = getX(batch, xR, xCOffset, d1);\n                     xC${b+1} = vec4(previous.zw, xTexelC${b+1}.xy);\n                    } else {\n                     xC${b+1} = vec4(0.0, 0.0, xTexelC${b+1}.xy);\n                    }\n                    `:`\n                    xC${b+1} = vec4(xTexelC${b}.zw, xTexelC${b+1}.xy);\n                    `):f+=1===v?`\n                    xC${b+1} = xTexelC${b};\n                    `:`\n                    xCOffset = xC + ${v};\n\n                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b+1}Ready == 0) {\n                      xTexelC${b+1} = getX(batch, xR, xCOffset, d1);\n                      if (xCOffset + 1 >= inDims[1]) {\n                        xTexelC${b+1}.zw = vec2(0.0);\n                      }\n                      xTexelC${b+1}Ready = 1;\n                    }\n\n                    xC${b+1} = xTexelC${b+1};\n                    `}}else b<d&&(a%2==1?(f+=`\n                xCOffset = xC + 1 - strides[1];\n                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b}Ready == 0) {\n                  xTexelC${b} = getX(batch, xR, xCOffset, d1);\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC${b}.zw = vec2(0.0);\n                  }\n                  xTexelC${b}Ready = 1;\n                }\n\n                if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${b+1}Ready == 0) {\n                  xTexelC${b+1} = getX(batch, xR, xC + 1, d1);\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xC + 2 >= inDims[1]) {\n                    xTexelC${b+1}.zw = vec2(0.0);\n                  }\n                  xTexelC${b+1}Ready = 1;\n                }\n\n                xC${b} = vec4(xTexelC${b}.zw, xTexelC${b+1}.zw);\n              `,b+1<d&&(f+=`\n                  final = vec4(0.0);\n                  xCOffset = xC + 1 + strides[1];\n                  if(xCOffset >= 0 && xCOffset < inDims[1]) {\n                    final = getX(batch, xR, xCOffset, d1);\n                  }\n                  xC${b+1} = vec4(xTexelC${b+1}.xy, final.xy);\n                `)):(f+=`\n                if(xC >= 0 && xC < inDims[1] && xTexelC${b}Ready == 0) {\n                  xTexelC${b} = getX(batch, xR, xC, d1);\n                  if (xC + 1 >= inDims[1]) {\n                    xTexelC${b}.zw = vec2(0.0);\n                  }\n                  xTexelC${b}Ready = 1;\n                }\n\n                xCOffset = xC + strides[1];\n                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b+1}Ready == 0) {\n                  xTexelC${b+1} = getX(batch, xR, xCOffset, d1);\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC${b+1}.zw = vec2(0.);\n                  }\n                  xTexelC${b+1}Ready = 1;\n                }\n\n                xC${b} = vec4(\n                  xTexelC${b}.xy, xTexelC${b+1}.xy);\n              `,b+1<d&&(f+=`\n                  xC${b+1} = vec4(xTexelC${b}.zw, xTexelC${b+1}.zw);\n                `)));b<d&&(f+=`\n            wTexel = getW(r, ${b}, d1, q);\n            dotProd += xC${b} * vec4(wTexel.xz, wTexel.xz);\n          `,b+1<d&&(f+=`\n              wTexel = getW(r, ${b+1}, d1, q);\n              dotProd += xC${b+1} * vec4(wTexel.xz, wTexel.xz);\n            `))}f+="\n    }\n  ",f+="\n      }\n    ";let p="",g="";s&&(p=r?`vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ${s}\n        }`:i?`vec4 activation(vec4 a) {\n          vec4 b = getLeakyreluAlphaAtOutCoords();\n          ${s}\n        }`:`vec4 activation(vec4 x) {\n          ${s}\n        }`,g="result = activation(result);");const m=e?"result += getBiasAtOutCoords();":"";e&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),i&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n      ${p}\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / ${o};\n        int q = d2 - d1 * ${o};\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.\n        vec4 dotProd = vec4(0.000000000000001);\n\n        ${f}\n\n        vec4 result = dotProd - vec4(0.000000000000001);\n        ${m}\n        ${g}\n        setOutput(result);\n      }\n    `}}const DIe={kernelName:Ny,backendName:"webgl",kernelFunc:function EIe(n){const{inputs:t,backend:e,attrs:s}=n,{x:r,filter:i}=t,{strides:o,pad:a,dilations:l,dimRoundingMode:u}=s;let c=l;null==c&&(c=[1,1]),S(Ts(o,c),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${o} and dilations '${c}'`);const d=_s(r.shape,i.shape,o,c,a,u,!0);let h;return h=W().getBool("WEBGL_PACK_DEPTHWISECONV")&&d.strideWidth<=2&&d.outChannels/d.inChannels==1?new zU(d):new BU(d),e.runWebGLProgram(h,[r,i],"float32",[[d.padInfo.top,d.padInfo.left],[d.strideHeight,d.strideWidth],[d.dilationHeight,d.dilationWidth],[d.inHeight,d.inWidth]])}};class TIe{constructor(t){this.variableNames=["x","dy"],this.outputShape=t.filterShape,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int dm = coords.w;\n        int d2 = d1 * ${t.outChannels/t.inChannels} + dm;\n\n        float dotProd = 0.0;\n\n        // TO DO: Vec4 over the batch size\n        for (int b = 0; b < ${t.batchSize}; b++) {\n          for (int yR = 0; yR < ${t.outHeight}; yR++) {\n            int xR = wR + yR * ${t.strideHeight} - ${t.padInfo.top};\n\n            if (xR < 0 || xR >= ${t.inHeight}) {\n              continue;\n            }\n\n            for (int yC = 0; yC < ${t.outWidth}; yC++) {\n              int xC = wC + yC * ${t.strideWidth} - ${t.padInfo.left};\n\n              if (xC < 0 || xC >= ${t.inWidth}) {\n                continue;\n              }\n\n              float dyValue = getDy(b, yR, yC, d2);\n              float xValue = getX(b, xR, xC, d1);\n              dotProd += (xValue * dyValue);\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class NIe{constructor(t){this.variableNames=["dy","W"],this.outputShape=t.inShape;const e=t.filterHeight,s=t.filterWidth,l=t.outChannels/t.inChannels;this.userCode=`\n      const ivec2 pads = ivec2(${e-1-t.padInfo.top}, ${s-1-t.padInfo.left});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[3];\n        ivec2 dyCorner = coords.yz - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        float dotProd = 0.0;\n\n        for (int wR = 0; wR < ${e}; wR++) {\n          float dyR = float(dyRCorner + wR) / ${t.strideHeight}.0;\n\n          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ${e} - 1 - wR;\n\n          for (int wC = 0; wC < ${s}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${t.strideWidth}.0;\n\n            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ${s} - 1 - wC;\n\n            // TO DO: Vec4 over the channelMul\n            for (int dm = 0; dm < ${l}; dm++) {\n              int d2 = d1 * ${l} + dm;\n              float xValue = getDy(batch, idyR, idyC, d2);\n              float wValue = getW(wRPerm, wCPerm, d1, dm);\n              dotProd += xValue * wValue;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const AIe={kernelName:iS,backendName:"webgl",kernelFunc:function kIe(n){const{inputs:t,backend:e,attrs:s}=n,{x:r,dy:i}=t,{strides:o,dilations:a,pad:l,dimRoundingMode:u,filterShape:c}=s,d=_s(r.shape,c,o,a,l,u,!0),h=new TIe(d);return e.runWebGLProgram(h,[r,i],"float32")}},MIe={kernelName:oS,backendName:"webgl",kernelFunc:function RIe(n){const{inputs:t,backend:e,attrs:s}=n,{dy:r,filter:i}=t,{strides:o,dilations:a,pad:l,dimRoundingMode:u,inputShape:c}=s,d=_s(c,i.shape,o,a,l,u,!0),h=new NIe(d);return e.runWebGLProgram(h,[r,i],"float32")}};class FIe{constructor(t){this.variableNames=["X"],this.outputShape=[t,t],this.userCode="\n      void main() {\n          ivec2 coords = getOutputCoords();\n          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;\n          setOutput(val);\n      }\n    "}}const $Ie={kernelName:aS,backendName:"webgl",kernelFunc:function OIe(n){const{inputs:t,backend:e}=n,{x:s}=t,r=[...s.shape,...s.shape],i=X(s.shape),o=be({inputs:{x:s},backend:e,attrs:{shape:[i]}}),a=new FIe(i),l=e.runWebGLProgram(a,[o],o.dtype),u=be({inputs:{x:l},backend:e,attrs:{shape:r}});return e.disposeIntermediateTensorInfo(o),e.disposeIntermediateTensorInfo(l),u}};class PIe{constructor(t){this.variableNames=["x","W"],this.outputShape=t.outShape;const{inHeight:e,inWidth:s,padInfo:r,strideHeight:i,strideWidth:o,filterHeight:a,filterWidth:l,dilationHeight:u,dilationWidth:c}=t,{top:d,left:h}=r;this.userCode=`\n      const ivec2 strides = ivec2(${i}, ${o});\n      const ivec2 pads = ivec2(${d}, ${h});\n      const float neg_infinity = -3.4e38;\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.w;\n        ivec2 outTopLeftCorner =\n            coords.yz * strides - pads;\n        int hBeg = outTopLeftCorner.x;\n        int wBeg = outTopLeftCorner.y;\n\n        float curVal = neg_infinity;\n        for (int h = 0; h < ${a}; h++) {\n          int hIn = hBeg + h * ${u};\n\n          if (hIn >= 0 && hIn < ${e}) {\n            for (int w = 0; w < ${l}; w++) {\n              int wIn = wBeg + w * ${c};\n\n              if (wIn >= 0 && wIn < ${s}) {\n                float xVal = getX(batch, hIn, wIn, d1);\n                float wVal = getW(h, w, d1);\n\n                float val = xVal + wVal;\n                if (val > curVal) {\n                  curVal = val;\n                }\n              }\n            }\n          }\n        }\n\n        float result = curVal;\n        setOutput(result);\n      }\n    `}}const VIe={kernelName:ky,backendName:"webgl",kernelFunc:function LIe(n){const{inputs:t,backend:e,attrs:s}=n,{x:r,filter:i}=t,{strides:o,pad:a,dilations:l}=s,u=sp(r.shape,i.shape,o,a,"NHWC",l);let c;const d=new PIe(u);c=e.runWebGLProgram(d,[r,i],"float32");const h=be({inputs:{x:c},backend:e,attrs:{shape:u.outShape}});return e.disposeIntermediateTensorInfo(c),h}},zIe={kernelName:cS,backendName:"webgl",kernelFunc:function BIe(n){const{inputs:t,backend:e,attrs:s}=n,{equation:r}=s,i=t,{allDims:o,summedDims:a,idDims:l}=UE(r,i.length);GE(o.length,l,i);const{path:u,steps:c}=HE(a,l),d=c.length;let h=null,f=o.length;const p=[];for(let g=0;g<d;++g){for(const m of c[g]){const{permutationIndices:y,expandDims:b}=WE(f,l[m]);let v;jE(y)?v=i[m]:(v=Qs({inputs:{x:i[m]},backend:e,attrs:{perm:y}}),p.push(v));const _=v.shape.slice();for(let x=0;x<b.length;++x)_.splice(b[x],0,1);wt(v.shape,_)||(v=be({inputs:{x:v},backend:e,attrs:{shape:_}}),p.push(v)),null===h?h=v:(h=DT({inputs:{a:v,b:h},backend:e}),p.push(h))}g<d-1&&(u[g]>=0&&(h=e_({inputs:{x:h},backend:e,attrs:{axis:u[g]-(o.length-f),keepDims:!1}}),p.push(h)),f--)}for(const g of p)g!==h&&e.disposeIntermediateTensorInfo(g);return h}},UIe=Nt({opSnippet:"return (x >= 0.0) ? x : (exp(x) - 1.0);",packedOpSnippet:"\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n"}),WIe={kernelName:gf,backendName:"webgl",kernelFunc:UIe},jIe={kernelName:dS,backendName:"webgl",kernelFunc:n=>{const{inputs:t,backend:e}=n,{dy:s,y:r}=t,i=W().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new zp("\n  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));\n  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));\n",s.shape,r.shape):new Id("return (b >= 0.0) ? a : a * (b + 1.0);",s.shape,r.shape);return e.runWebGLProgram(i,[s,r],s.dtype)}},qIe=As({opSnippet:"return float(a == b);",packedOpSnippet:"\n  return vec4(equal(a, b));\n",dtype:"bool",cpuKernelImpl:$xe}),KIe={kernelName:Ay,backendName:"webgl",kernelFunc:qIe},YIe=Nt({opSnippet:`\n  // Error function is calculated approximately with elementary function.\n  // See "Handbook of Mathematical Functions with Formulas,\n  // Graphs, and Mathematical Tables", Abramowitz and Stegun.\n  float p = ${FE};\n  float a1 = ${OE};\n  float a2 = ${$E};\n  float a3 = ${PE};\n  float a4 = ${LE};\n  float a5 = ${VE};\n\n  float sign = sign(x);\n  x = abs(x);\n  float t = 1.0 / (1.0 + p * x);\n  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));\n`}),ZIe={kernelName:yf,backendName:"webgl",kernelFunc:YIe},UU=Nt({opSnippet:Ed+"\n  return exp(x);\n",packedOpSnippet:"\n  vec4 result = exp(x);\n  bvec4 isNaN = isnan(x);\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",cpuKernelImpl:Pxe,dtype:"float32"}),JIe={kernelName:bf,backendName:"webgl",kernelFunc:UU};function AT(n){const{inputs:t,attrs:e,backend:s}=n,{dim:r}=e,{input:i}=t,o=i.shape.length,a=i.shape.slice();let l=r;return r<0&&(S(-(o+1)<=r,()=>`Axis must be in the interval [${-(o+1)}, ${o}]`),l=o+r+1),a.splice(l,0,1),be({inputs:{x:i},backend:s,attrs:{shape:a}})}const eEe={kernelName:Ry,backendName:"webgl",kernelFunc:AT},WU="return exp(x) - 1.0;",tEe=Nt({opSnippet:WU,packedOpSnippet:WU,cpuKernelImpl:Lxe}),nEe={kernelName:vf,backendName:"webgl",kernelFunc:tEe};class GU{constructor(t,e,s){this.variableNames=["real","imag"];const r=e[1];this.outputShape=e;const i=s?`2.0 * ${Math.PI}`:`-2.0 * ${Math.PI}`,o=s?`${r}.0`:"1.0";let a;if("real"===t)a="return real * expR - imag * expI;";else{if("imag"!==t)throw new Error(`FFT component must be either "real" or "imag", got ${t}.`);a="return real * expI + imag * expR;"}this.userCode=`\n      const float exponentMultiplier = ${i};\n\n      float unaryOpComplex(float real, float expR, float imag, float expI) {\n        ${a}\n      }\n\n      float mulMatDFT(int batch, int index) {\n        float indexRatio = float(index) / float(${r});\n        float exponentMultiplierTimesIndexRatio =\n            exponentMultiplier * indexRatio;\n\n        float result = 0.0;\n\n        for (int i = 0; i < ${r}; i++) {\n          // x = (-2|2 * PI / N) * index * i;\n          float x = exponentMultiplierTimesIndexRatio * float(i);\n          float expR = cos(x);\n          float expI = sin(x);\n          float real = getReal(batch, i);\n          float imag = getImag(batch, i);\n\n          result +=\n              unaryOpComplex(real, expR, imag, expI) / ${o};\n        }\n\n        return result;\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        setOutput(mulMatDFT(coords[0], coords[1]));\n      }\n    `}}function HU(n,t,e){const s=e.texData.get(n.dataId),r=X(n.shape),i=n.shape[n.shape.length-1],a=be({inputs:{x:n},backend:e,attrs:{shape:[r/i,i]}}),l=a.shape,u=new GU("real",l,t),c=new GU("imag",l,t),d=[{dataId:s.complexTensorInfos.real.dataId,dtype:s.complexTensorInfos.real.dtype,shape:l},{dataId:s.complexTensorInfos.imag.dataId,dtype:s.complexTensorInfos.imag.dtype,shape:l}],h=e.runWebGLProgram(u,d,"float32"),f=e.runWebGLProgram(c,d,"float32"),p=pl({inputs:{real:h,imag:f},backend:e});e.disposeIntermediateTensorInfo(h),e.disposeIntermediateTensorInfo(f);const g=be({inputs:{x:p},backend:e,attrs:{shape:n.shape}});return e.disposeIntermediateTensorInfo(a),e.disposeIntermediateTensorInfo(p),g}const rEe={kernelName:"FFT",backendName:"webgl",kernelFunc:function sEe(n){const{inputs:t,backend:e}=n,{input:s}=t;return HU(s,!1,e)}};class iEe{constructor(t,e){this.outputShape=[],this.customUniforms=[{name:"value",type:"float"}],this.variableNames=["x"],this.outputShape=t,this.userCode="\n      void main() {\n        // Input can be obtained from uniform value.\n        setOutput(value);\n      }\n    "}}function jp(n){const{backend:t,attrs:e}=n,{shape:s,value:r}=e;let{dtype:i}=e;if(i=i||Vc(r),"string"===i){const o=Fn(i,X(s));return o.fill(r),t.makeTensorInfo(s,i,o)}{const o=new iEe(s,r);return t.runWebGLProgram(o,[],i,[[r]])}}const oEe={kernelName:fS,backendName:"webgl",kernelFunc:jp};class aEe{constructor(t){this.variableNames=["Image"],this.outputShape=[];const e=t[2];this.outputShape=t,this.userCode=`\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int x = coords[2];\n\n          int coordX = ${e} - x - 1;\n          float outputValue;\n          if(coordX >= 0 && coordX < ${e}) {\n            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);\n          } else {\n            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);\n          }\n          setOutput(outputValue);\n        }\n    `}}const lEe={kernelName:pS,backendName:"webgl",kernelFunc:({inputs:n,backend:t})=>{const{image:e}=n,s=t,r=new aEe(e.shape);return s.runWebGLProgram(r,[e],e.dtype)}},jU="return floor(x);",uEe=Nt({opSnippet:jU,packedOpSnippet:jU,cpuKernelImpl:Vxe}),cEe={kernelName:_f,backendName:"webgl",kernelFunc:uEe},dEe=As({opSnippet:"\n  float s = sign(a) * sign(b);\n  int ia = round(a);\n  int ib = round(b);\n  if (ib != 0) {\n    // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n    return float(idiv(ia, ib, s));\n  } else {\n    return NAN;\n  }\n",packedOpSnippet:"\n  ivec4 ia = round(a);\n  ivec4 ib = round(b);\n  bvec4 cond = notEqual(ib, ivec4(0));\n  ivec4 result = ivec4(0);\n  vec4 s = sign(a) * sign(b);\n\n  // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n  if (cond[0]) {\n    result[0] = idiv(ia[0], ib[0], s[0]);\n  }\n  if (cond[1]) {\n    result[1] = idiv(ia[1], ib[1], s[1]);\n  }\n  if (cond[2]) {\n    result[2] = idiv(ia[2], ib[2], s[2]);\n  }\n  if (cond[3]) {\n    result[3] = idiv(ia[3], ib[3], s[3]);\n  }\n  return vec4(result);\n",dtype:"int32"}),hEe={kernelName:wf,backendName:"webgl",kernelFunc:dEe};class fEe{constructor(t){this.variableNames=["A"];const e=Ys(),[s,r]=t;this.outputShape=t,this.userCode=`\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${r}.0, ${s}.0);\n\n        vec4 values = ${e.texture2D}(A, uv);\n        float value;\n        if (depth == 0) {\n          value = values.r;\n        } else if (depth == 1) {\n          value = values.g;\n        } else if (depth == 2) {\n          value = values.b;\n        } else if (depth == 3) {\n          value = values.a;\n        }\n\n        setOutput(floor(value * 255.0 + 0.5));\n      }\n    `}}class pEe{constructor(t){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;const e=Ys(),[s,r]=t;this.outputShape=t,this.userCode=`\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n\n        vec4 result = vec4(0.);\n\n        for(int row=0; row<=1; row++) {\n          for(int col=0; col<=1; col++) {\n            texC = coords[1] + row;\n            depth = coords[2] + col;\n\n            vec2 uv = (vec2(texC, texR) + halfCR) /\n                       vec2(${r}.0, ${s}.0);\n            vec4 values = ${e.texture2D}(A, uv);\n            float value;\n            if (depth == 0) {\n              value = values.r;\n            } else if (depth == 1) {\n              value = values.g;\n            } else if (depth == 2) {\n              value = values.b;\n            } else if (depth == 3) {\n              value = values.a;\n            }\n\n            result[row * 2 + col] = floor(value * 255.0 + 0.5);\n          }\n        }\n\n        ${e.output} = result;\n      }\n    `}}const mEe={kernelName:"FromPixels",backendName:"webgl",kernelFunc:function gEe(n){const{inputs:t,backend:e,attrs:s}=n;let{pixels:r}=t;const{numChannels:i}=s,o=typeof HTMLVideoElement<"u"&&r instanceof HTMLVideoElement,a=typeof HTMLImageElement<"u"&&r instanceof HTMLImageElement,[l,u]=o?[r.videoWidth,r.videoHeight]:[r.width,r.height],c=[u,l],d=[u,l,i];if(a||o){const g=W().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");(null==Td||g!==RT)&&(RT=g,Td=document.createElement("canvas").getContext("2d",{willReadFrequently:RT})),Td.canvas.width=l,Td.canvas.height=u,Td.drawImage(r,0,0,l,u),r=Td.canvas}const h=e.makeTensorInfo(c,"int32");e.texData.get(h.dataId).usage=Vn.PIXELS,e.gpgpu.uploadPixelDataToTexture(e.getTexture(h.dataId),r);const f=W().getBool("WEBGL_PACK")?new pEe(d):new fEe(d),p=e.runWebGLProgram(f,[h],"int32");return e.disposeData(h.dataId),p}};let Td,RT=W().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");const bEe={kernelName:bb,backendName:"webgl",kernelFunc:function yEe(n){const{inputs:t,backend:e,attrs:s}=n,{x:r,filter:i,bias:o,preluActivationWeights:a}=t,{strides:l,pad:u,dataFormat:c,dilations:d,dimRoundingMode:h,activation:f,leakyreluAlpha:p}=s,g=la(c),m=_s(r.shape,i.shape,l,d,u,h,!1,g);let y;const b=[],v=null!=o,_=null!=a,x="leakyrelu"===f,C=()=>{const D=[r,i],N=(R,V)=>{if("NCHW"===V&&1===R.shape.length&&1!==R.shape[0]){const G=be({inputs:{x:R},backend:e,attrs:{shape:[R.shape[0],1,1]}});return b.push(G),G}return R};if(v&&D.push(N(o,c)),_&&D.push(N(a,c)),x){const R=e.makeTensorInfo([],"float32",$a(p,"float32"));D.push(R),b.push(R)}return D};if(1!==m.filterHeight||1!==m.filterWidth||1!==m.dilationHeight||1!==m.dilationWidth||1!==m.strideHeight||1!==m.strideWidth||"SAME"!==m.padInfo.type&&"VALID"!==m.padInfo.type)if(m.strideWidth<=2&&"channelsLast"===g&&W().getBool("WEBGL_EXP_CONV")){const D=f?Up(f,!0):null,N=new MU(m,v,D,_,x),R=[[m.padInfo.top,m.padInfo.left],[m.strideHeight,m.strideWidth],[m.dilationHeight,m.dilationWidth],[m.inHeight,m.inWidth]],V=C();y=e.runWebGLProgram(N,V,"float32",R)}else if(W().getBool("WEBGL_CONV_IM2COL"))y=OU({x:r,filter:i,convInfo:m,backend:e,bias:o,activation:f,preluActivationWeights:a,leakyreluAlpha:p});else{const D=f?Up(f,!1):null,N=new RU(m,v,D,_,x),R=C();y=e.runWebGLProgram(N,R,"float32")}else y=FU({x:r,filter:i,convInfo:m,backend:e,bias:o,activation:f,preluActivationWeights:a,leakyreluAlpha:p});const E=be({inputs:{x:y},backend:e,attrs:{shape:m.outShape}});return b.push(y),b.forEach(D=>e.disposeIntermediateTensorInfo(D)),E}},_Ee={kernelName:vb,backendName:"webgl",kernelFunc:function vEe(n){const{inputs:t,backend:e,attrs:s}=n,{x:r,filter:i,bias:o,preluActivationWeights:a}=t,{strides:l,pad:u,dilations:c,dimRoundingMode:d,activation:h,leakyreluAlpha:f}=s,p=[];let g=c;null==g&&(g=[1,1]),S(Ts(l,g),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${l} and dilations '${g}'`);const m=_s(r.shape,i.shape,l,g,u,d,!0),y=W().getBool("WEBGL_PACK_DEPTHWISECONV")&&m.strideWidth<=2&&m.outChannels/m.inChannels==1,b=h?Up(h,y):null,v=[r,i],_=null!=o,x=null!=a,C="leakyrelu"===h;if(_&&v.push(o),x&&v.push(a),C){const R=e.makeTensorInfo([],"float32",$a(f,"float32"));v.push(R),p.push(R)}let E;E=y?new zU(m,_,b,x,C):new BU(m,_,b,x,C);const N=e.runWebGLProgram(E,v,"float32",[[m.padInfo.top,m.padInfo.left],[m.strideHeight,m.strideWidth],[m.dilationHeight,m.dilationWidth],[m.inHeight,m.inWidth]]);return p.forEach(R=>e.disposeIntermediateTensorInfo(R)),N}};class wEe{constructor(t,e,s,r){this.sliceDim=t,this.strides=e,this.paramsShape=r,this.variableNames=["x","indices"],this.outputShape=s;const i=Xt(s.length);let o="\n    int index;";for(let a=0;a<this.sliceDim;a++)o+=`\n          index = round(getIndices(coords[0], ${a}));\n          out_of_bounds = out_of_bounds || index < 0;\n          out_of_bounds = out_of_bounds || index >= ${this.paramsShape[a]};\n          flattenIndex += index * ${this.strides[a]};`;this.userCode=`\n         void main() {\n          ${i} coords = getOutputCoords();\n          int flattenIndex = 0;\n          bool out_of_bounds = false;\n\n          ${o}\n\n          setOutput(out_of_bounds ? 0.0 : getX(flattenIndex, coords[1]));\n        }\n      `}}const CEe={kernelName:mS,backendName:"webgl",kernelFunc:function xEe(n){const{inputs:t,backend:e}=n,{params:s,indices:r}=t,i=r.shape,o=i[i.length-1],a=X(s.shape),[l,u,c,d]=ME(s,r),h=be({inputs:{x:r},backend:e,attrs:{shape:[u,o]}}),f=be({inputs:{x:s},backend:e,attrs:{shape:[X(s.shape)/c,c]}});if(e.shouldExecuteOnCPU([s,r])||"string"===s.dtype){const y=e.readSync(r.dataId),b=e.bufferSync(s),v=Bxe(y,b,s.dtype,u,o,c,d,s.shape,a);return e.makeTensorInfo(l,s.dtype,v.values)}const p=new wEe(o,d,[u,c],s.shape),g=e.runWebGLProgram(p,[f,h],f.dtype),m=be({inputs:{x:g},backend:e,attrs:{shape:l}});return e.disposeIntermediateTensorInfo(h),e.disposeIntermediateTensorInfo(f),e.disposeIntermediateTensorInfo(g),m}};class SEe{constructor(t,e){this.variableNames=["A","indices"],this.outputShape=e,this.rank=e.length;const s=Xt(this.rank),r=function IEe(n,t){const e=["resRC.x","resRC.y","resRC.z","resRC.w"],s=[];for(let r=0;r<n.length;r++)s.push(2===r?"index":`${e[r]}`);return s.join()}(t);this.userCode=`\n      void main() {\n        ${s} resRC = getOutputCoords();\n        int index = int(getIndices(resRC.x, resRC.z));\n        float inBounds = (index >= 0) && (index < ${t[2]}) ? 1.0 : 0.0;\n        setOutput(inBounds * getA(${r}));\n      }\n    `}}function qU(n){const{inputs:t,backend:e,attrs:s}=n,{x:r,indices:i}=t,{axis:o,batchDims:a}=s,l=mt(o,r.shape)[0];if(W().get("DEBUG")){const b=e.readSync(i.dataId),v=r.shape[l];for(let _=0;_<b.length;++_){const x=b[_];S(x<=v-1&&x>=0,()=>`GatherV2: the index value ${x} is not in [0, ${v-1}]`)}}const u=XE(r,i,l,a),c=X(i.shape),d=[],h=be({inputs:{x:r},backend:e,attrs:{shape:[u.batchSize,u.outerSize,u.dimSize,u.sliceSize]}}),f=be({inputs:{x:i},backend:e,attrs:{shape:[u.batchSize,c/u.batchSize]}});d.push(h),d.push(f);const p=[u.batchSize,u.outerSize,c/u.batchSize,u.sliceSize];if(e.shouldExecuteOnCPU([r,i])||"string"===r.dtype){const b=e.bufferSync(f),v=e.bufferSync(h),_=zxe(v,b,p);return d.forEach(x=>e.disposeIntermediateTensorInfo(x)),e.makeTensorInfo(u.outputShape,_.dtype,_.values)}const g=new SEe(h.shape,p),m=e.runWebGLProgram(g,[h,f],h.dtype);d.push(m);const y=be({inputs:{x:m},backend:e,attrs:{shape:u.outputShape}});return d.forEach(b=>e.disposeIntermediateTensorInfo(b)),y}const EEe={kernelName:Fy,backendName:"webgl",kernelFunc:qU},DEe=As({opSnippet:"return float(a > b);",packedOpSnippet:"\n  return vec4(greaterThan(a, b));\n",cpuKernelImpl:Uxe,dtype:"bool"}),TEe={kernelName:Oy,backendName:"webgl",kernelFunc:DEe},NEe=As({opSnippet:"return float(a >= b);",packedOpSnippet:"\n  return vec4(greaterThanEqual(a, b));\n",dtype:"bool",cpuKernelImpl:Wxe}),kEe={kernelName:xf,backendName:"webgl",kernelFunc:NEe},REe={kernelName:gS,backendName:"webgl",kernelFunc:function AEe(n){const{inputs:t,backend:e}=n,{input:s}=t;return HU(s,!0,e)}},MEe=Nt({opSnippet:"return float(!isnan(x) && !isinf(x));",dtype:"bool"}),FEe={kernelName:Sf,backendName:"webgl",kernelFunc:MEe},OEe=Nt({opSnippet:"return float(isinf(x));",dtype:"bool"}),$Ee={kernelName:If,backendName:"webgl",kernelFunc:OEe},PEe=Nt({opSnippet:"return float(isnan(x));",dtype:"bool"}),LEe={kernelName:Ef,backendName:"webgl",kernelFunc:PEe},VEe=As({opSnippet:"return float(a < b);",packedOpSnippet:"\n  return vec4(lessThan(a, b));\n",cpuKernelImpl:Gxe,dtype:"bool"}),BEe={kernelName:Py,backendName:"webgl",kernelFunc:VEe},zEe=As({opSnippet:"return float(a <= b);",packedOpSnippet:"\n  return vec4(lessThanEqual(a, b));\n",cpuKernelImpl:Hxe,dtype:"bool"}),UEe={kernelName:Ly,backendName:"webgl",kernelFunc:zEe},GEe={kernelName:bS,backendName:"webgl",kernelFunc:function WEe(n){const{backend:t,attrs:e}=n,{start:s,stop:r,num:i}=e,o=jxe(s,r,i);return t.makeTensorInfo([o.length],"float32",o)}},jEe=Nt({opSnippet:Ed+"\n  return x < 0.0 ? 0./0. : log(x);\n",packedOpSnippet:"\n  vec4 result = log(x);\n  bvec4 isNaN = isnan(x);\n  result.r = isNaN.r ? x.r : (x.r < 0.0 ? 0./0. : result.r);\n  result.g = isNaN.g ? x.g : (x.g < 0.0 ? 0./0. : result.g);\n  result.b = isNaN.b ? x.b : (x.b < 0.0 ? 0./0. : result.b);\n  result.a = isNaN.a ? x.a : (x.a < 0.0 ? 0./0. : result.a);\n  return result;\n",cpuKernelImpl:qxe}),qEe={kernelName:Df,backendName:"webgl",kernelFunc:jEe},XEe=Nt({opSnippet:Ed+"\n  return log(1.0 + x);\n"}),YEe={kernelName:Tf,backendName:"webgl",kernelFunc:XEe},ZEe=As({opSnippet:"return float(a >= 1.0 && b >= 1.0);",packedOpSnippet:"\n  return vec4(\n    vec4(greaterThanEqual(a, vec4(1.0))) *\n    vec4(greaterThanEqual(b, vec4(1.0))));\n",dtype:"bool"}),QEe={kernelName:Vy,backendName:"webgl",kernelFunc:ZEe},JEe=Nt({opSnippet:"return float(!(x >= 1.0));"}),eDe={kernelName:By,backendName:"webgl",kernelFunc:JEe},tDe=As({opSnippet:"return float(a >= 1.0 || b >= 1.0);",packedOpSnippet:"\n  return min(\n    vec4(greaterThanEqual(a, vec4(1.0))) +\n    vec4(greaterThanEqual(b, vec4(1.0))),\n    vec4(1.0));\n",dtype:"bool"}),nDe={kernelName:zy,backendName:"webgl",kernelFunc:tDe};class sDe{constructor(t,e,s,r,i){this.variableNames=["x"],this.outputShape=[];const o=e,a=t[3]-1;let l;this.outputShape=t;const u=`float(${s}) + float(${r}) * sum`;l=.5===i?`inversesqrt(${u})`:1===i?`1.0/(${u})`:`exp(log(${u}) * float(-${i}));`,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n        int d = coords[3];\n        float x = getX(b, r, c, d);\n        float sum = 0.0;\n        for (int j = -${o}; j <= ${o}; j++) {\n          int idx = d + j;\n          if (idx >= 0 && idx <=  ${a}) {\n            float z = getX(b, r, c, idx);\n            sum += z * z;\n          }\n        }\n        float val = x * ${l};\n        setOutput(val);\n      }\n    `}}class rDe{constructor(t,e,s,r,i){this.variableNames=["x"],this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0;const o=e,a=t[3]-1;let l;this.outputShape=t;const u=`float(${s}) + float(${r}) * sum`;l=.5===i?`inversesqrt(${u})`:1===i?`1.0/(${u})`:`exp(log(${u}) * float(-${i}));`,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords.x;\n        int r = coords.y;\n        int c = coords.z;\n        int d = coords.w;\n\n        bool hasNextCol = d < ${this.outputShape[3]};\n        bool hasNextRow = c < ${this.outputShape[2]};\n\n        vec4 sum = vec4(0.);\n        vec4 xFragAtOutputCoords = getX(b, r, c, d);\n\n        vec4 xAtOutputCoords = vec4(\n          getChannel(xFragAtOutputCoords, vec2(c, d)),\n          hasNextCol ?\n            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,\n          hasNextRow ?\n            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0\n        );\n\n        int firstChannel = d - ${o};\n        vec2 cache = vec2(0.);\n        if(firstChannel >= 0){\n          vec4 firstChannelFrag = getX(b, r, c, firstChannel);\n          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));\n            if(hasNextRow){\n              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));\n            }\n        }\n\n        ivec2 depth = ivec2(d, d + 1);\n        for (int j = - ${o}; j <= ${o}; j++) {\n          ivec2 idx = depth + j;\n          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));\n          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(${a}));\n\n          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;\n          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;\n\n          if(depthInRange || depthPlusOneInRange){\n            vec4 z = vec4(0.);\n            vec4 xFragAtCurrentDepth;\n            z.xz = cache.xy;\n            if(depthPlusOneInRange && hasNextCol){\n              xFragAtCurrentDepth = idx.y != d ?\n                getX(b, r, c, idx.y) : xFragAtOutputCoords;\n              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));\n              if(hasNextRow){\n                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));\n              }\n            }\n            cache.xy = z.yw;\n            sum += z * z;\n          }\n        }\n        vec4 result = xAtOutputCoords * ${l};\n        setOutput(result);\n      }\n    `}}const iDe={kernelName:Uy,backendName:"webgl",kernelFunc:n=>{const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{depthRadius:i,bias:o,alpha:a,beta:l}=s,u=W().getBool("WEBGL_PACK_NORMALIZATION")?new rDe(r.shape,i,o,a,l):new sDe(r.shape,i,o,a,l);return e.runWebGLProgram(u,[r],r.dtype)}};class oDe{constructor(t,e,s,r,i){this.variableNames=["inputImage","outputImage","dy"],this.outputShape=[],this.outputShape=t,this.depth=t[3],this.depthRadius=e,this.bias=s,this.alpha=r,this.beta=i,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n\n        float result = 0.0;\n        for (int d = 0; d < ${this.depth}; ++d) {\n          int depthBegin = int(max(0.0, float(d - ${e})));\n          int depthEnd = int(min(float(${this.depth}),\n              float(d + ${e} + 1)));\n\n          const int MIN_DEPTH_BEGIN = 0;\n          const int MAX_DEPTH_END = ${this.depth};\n\n          float norm = 0.0;\n          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd) {\n              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);\n            }\n            else {\n              break;\n            }\n          }\n\n          norm = float(${r}) * norm + float(${s});\n\n          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd){\n              float dyi = -2.0 * float(${r})\n                * float(${i})\n                * getInputImage(b, r, c, k) * getOutputImage(b, r, c, d)\n                / norm;\n              if (k == d) {\n                dyi += pow(norm, -1.0 * ${i});\n              }\n              if (k == coords[3]) {\n                dyi *= getDy(b, r, c, d);\n                result += dyi;\n              }\n            }\n            else {\n              break;\n            }\n          }\n      }\n      setOutput(result);\n      }\n    `}}const aDe={kernelName:vS,backendName:"webgl",kernelFunc:n=>{const{inputs:t,backend:e,attrs:s}=n,{x:r,y:i,dy:o}=t,{depthRadius:a,bias:l,alpha:u,beta:c}=s,d=new oDe(r.shape,a,l,u,c);return e.runWebGLProgram(d,[r,i,o],r.dtype)}};function KU(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{reductionIndices:i,keepDims:o}=s,a=r.shape.length,l=mt(i,r.shape);let u=l;const c=vn(u,a),d=null!=c,h=e.shouldExecuteOnCPU([r]);let f=r;if(d){if(h){const v=e.texData.get(f.dataId).values,_=new Array(a);for(let E=0;E<_.length;E++)_[E]=r.shape[c[E]];const x=IT(v,r.shape,r.dtype,c,_);f=e.makeTensorInfo(_,r.dtype),e.texData.get(f.dataId).values=x}else f=Jv(r,c,e);u=$n(u.length,a)}Ns("max",u,a);const[p,g]=ws(f.shape,u);let y,m=p;if(o&&(m=On(p,l)),h){const v=e.texData.get(f.dataId).values,_=Kxe(v,X(g),m,r.dtype);y=e.makeTensorInfo(m,r.dtype),e.texData.get(y.dataId).values=_}else y=function lDe(n,t,e,s){const r=X(t),a=be({inputs:{x:n},attrs:{shape:[X(n.shape)/r,r]},backend:s}),l=Su(a,n.dtype,"max",s),u=be({inputs:{x:l},attrs:{shape:e},backend:s});return s.disposeIntermediateTensorInfo(a),s.disposeIntermediateTensorInfo(l),u}(f,g,m,e);return d&&e.disposeIntermediateTensorInfo(f),y}const uDe={kernelName:Wy,backendName:"webgl",kernelFunc:KU},hDe=As({opSnippet:ET+"\n  return max(a, b);\n",packedOpSnippet:"\n  vec4 result = vec4(max(a, b));\n  bvec4 isNaNA = isnan(a);\n  bvec4 isNaNB = isnan(b);\n  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);\n  "+Cu+"\n  return result;\n",cpuKernelImpl:Xxe}),fDe={kernelName:Nf,backendName:"webgl",kernelFunc:hDe},mDe={kernelName:Gy,backendName:"webgl",kernelFunc:function pDe(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t;Vp(r,"maxPool");const{filterSize:i,strides:o,pad:a,dimRoundingMode:l}=s;S(Ts(o,1),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${o} and dilations '1'`);const c=pi(r.shape,i,o,1,a,l);if(1===c.filterWidth&&1===c.filterHeight&&wt(c.inShape,c.outShape))return Ar({inputs:{x:r},backend:e});const d=new Wp(c,"max",!1);return e.runWebGLProgram(d,[r],r.dtype)}},yDe={kernelName:Hy,backendName:"webgl",kernelFunc:function gDe(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{filterSize:i,strides:o,pad:a,dataFormat:l,dimRoundingMode:u}=s,d=aa(r.shape,i,o,[1,1,1],a,u,l),h=new TT(d,"max",!1);return e.runWebGLProgram(h,[r],r.dtype)}};class bDe{constructor(t){this.variableNames=["dy","maxPos"],this.outputShape=t.inShape;const i=t.effectiveFilterHeight,o=t.effectiveFilterWidth;this.userCode=`\n      const ivec2 pads = ivec2(${i-1-t.padInfo.top}, ${o-1-t.padInfo.left});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${i};\n          wR += ${t.dilationHeight}) {\n          float dyR = float(dyRCorner + wR) / ${t.strideHeight}.0;\n\n          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ${o}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${t.strideWidth}.0;\n\n            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n            int maxPosValue = ${i*o-1} - int(getMaxPos(b, idyR, idyC, d));\n\n            // Get the current value, check it against the value from the\n            // position matrix.\n            int curPosValue = wR * ${o} + wC;\n            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n            dotProd += dyValue * mask;\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class vDe{constructor(t){this.variableNames=["dy","maxPos"],this.outputShape=t.inShape;const l=t.effectiveFilterDepth,u=t.effectiveFilterHeight,c=t.effectiveFilterWidth;this.userCode=`\n      const ivec3 pads = ivec3(${l-1-t.padInfo.front}, ${u-1-t.padInfo.top}, ${c-1-t.padInfo.left});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ${l};\n           wD += ${t.dilationDepth}) {\n          float dyD = float(dyDCorner + wD) / ${t.strideDepth}.0;\n\n          if (dyD < 0.0 || dyD >= ${t.outDepth}.0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ${u};\n              wR += ${t.dilationHeight}) {\n            float dyR = float(dyRCorner + wR) / ${t.strideHeight}.0;\n\n            if (dyR < 0.0 || dyR >= ${t.outHeight}.0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ${c};\n                wC += ${t.dilationWidth}) {\n              float dyC = float(dyCCorner + wC) / ${t.strideWidth}.0;\n\n              if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n              int maxPosValue = ${l*u*c-1} -\n                  int(getMaxPos(batch, idyD, idyR, idyC, ch));\n\n              // Get the current value, check it against the value from the\n              // position matrix.\n              int curPosValue =\n                  wD * ${u} * ${c} +\n                  wR * ${c} + wC;\n              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n              dotProd += dyValue * mask;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const wDe={kernelName:wS,backendName:"webgl",kernelFunc:function _De(n){const{inputs:t,backend:e,attrs:s}=n,{dy:r,input:i}=t,o=i,{filterSize:a,strides:l,pad:u,dimRoundingMode:c}=s,h=aa(o.shape,a,l,[1,1,1],u,c),f=new TT(h,"max",!0),p=e.runWebGLProgram(f,[o],o.dtype),g=new vDe(h),m=e.runWebGLProgram(g,[r,p],o.dtype);return e.disposeIntermediateTensorInfo(p),m}},CDe={kernelName:_S,backendName:"webgl",kernelFunc:function xDe(n){const{inputs:t,backend:e,attrs:s}=n,{dy:r,input:i,output:o}=t,a=i;Vp([i,o],"maxPoolGrad");const{filterSize:l,strides:u,pad:c,dimRoundingMode:d}=s,h=pi(a.shape,l,u,1,c,d),p=new Wp(h,"max",!0),g=e.runWebGLProgram(p,[a],a.dtype),m=new bDe(h),y=e.runWebGLProgram(m,[r,g],a.dtype);return e.disposeIntermediateTensorInfo(g),y}},IDe={kernelName:xS,backendName:"webgl",kernelFunc:({inputs:n,attrs:t,backend:e})=>{const{x:s}=n,{filterSize:r,strides:i,pad:o,includeBatchInIndex:a}=t,l=e;S(4===s.shape.length,()=>`Error in maxPool: input must be rank 4 but got rank ${s.shape.length}.`);const u=[1,1];S(Ts(i,u),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${u}'`);const c=pi(s.shape,r,i,u,o),[d,h]=function SDe(n,t,e,s){let r=new Wp(e,"max",!1);const i=s.runWebGLProgram(r,[n],"float32");return r=new Wp(e,"max",!0,!0,t),[i,s.runWebGLProgram(r,[n],"float32")]}(s,a,c,l);return[d,h]}},DDe={kernelName:jy,backendName:"webgl",kernelFunc:({inputs:n,attrs:t,backend:e})=>{const{x:s}=n,{keepDims:r,axis:i}=t,o=e,a=s.shape.length,l=mt(i,s.shape);let u=l;const c=vn(u,a),d=null!=c,h=o.shouldExecuteOnCPU([s]),f=[];let p=s;if(d){if(h){const _=o.texData.get(p.dataId).values,x=new Array(a);for(let D=0;D<x.length;D++)x[D]=s.shape[c[D]];const C=IT(_,s.shape,s.dtype,c,x);p=o.makeTensorInfo(x,s.dtype),o.texData.get(p.dataId).values=C}else p=Jv(s,c,o);f.push(p),u=$n(u.length,a)}Ns("sum",u,a);const[g,m]=ws(p.shape,u);let y=g;r&&(y=On(g,l));const b=function EDe(n,t,e,s){const r=X(t),a=be({inputs:{x:n},attrs:{shape:[X(n.shape)/r,r]},backend:s}),l=Su(a,"float32","mean",s),u=be({inputs:{x:l},attrs:{shape:e},backend:s});return s.disposeIntermediateTensorInfo(a),s.disposeIntermediateTensorInfo(l),u}(p,m,y,o);for(const v of f)o.disposeIntermediateTensorInfo(v);return b}},NDe={kernelName:qy,backendName:"webgl",kernelFunc:function TDe(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{axis:i,keepDims:o}=s,a=r.shape.length,l=mt(i,r.shape);let u=l;const c=vn(u,a);let d=r;null!=c&&(d=Qs({inputs:{x:r},backend:e,attrs:{perm:c}}),u=$n(u.length,r.shape.length)),Ns("min",u,a);const[h,f]=ws(d.shape,u),g=be({inputs:{x:d},backend:e,attrs:{shape:[-1,X(f)]}}),m=Su(g,g.dtype,"min",e);let y;return y=be(o?{inputs:{x:m},backend:e,attrs:{shape:On(h,l)}}:{inputs:{x:m},backend:e,attrs:{shape:h}}),e.disposeIntermediateTensorInfo(g),e.disposeIntermediateTensorInfo(m),null!=c&&e.disposeIntermediateTensorInfo(d),y}},RDe=As({opSnippet:ET+"\n  return min(a, b);\n",packedOpSnippet:"\n  vec4 result = vec4(min(a, b));\n  bvec4 isNaNA = isnan(a);\n  bvec4 isNaNB = isnan(b);\n  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);\n  "+Cu+"\n  return result;\n",cpuKernelImpl:Yxe}),MDe={kernelName:kf,backendName:"webgl",kernelFunc:RDe};class FDe{constructor(t,e,s){this.variableNames=["x"],this.outputShape=e.map((c,d)=>c[0]+t[d]+c[1]);const r=t.length,i=Xt(r),o=e.map(c=>c[0]).join(","),a=e.map((c,d)=>c[0]+t[d]).join(","),l=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,r),u="reflect"===s?0:1;this.userCode=1!==r?`\n      ${i} start = ${i}(${o});\n      ${i} end = ${i}(${a});\n\n      void main() {\n        ${i} outC = getOutputCoords();\n        for (int i = 0; i < ${r}; i++) {\n          if (outC[i] < start[i]) {\n            outC[i] = start[i] * 2 - outC[i] - ${u};\n          } else if(outC[i] >= end[i]) {\n            outC[i] = (end[i] - 1) * 2 - outC[i] + ${u};\n          }\n        }\n        ${i} coords = outC - start;\n        setOutput(getX(${l}));\n      }\n    `:`\n        int start = ${o};\n        int end = ${a};\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start) {\n            outC = start * 2 - outC - ${u};\n          } else if(outC >= end) {\n            outC = (end - 1) * 2 - outC + ${u};\n          }\n          setOutput(getX(outC - start));\n        }\n      `}}class ODe{constructor(t,e,s){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e.map((p,g)=>p[0]+t[g]+p[1]);const r=t.length,i=Xt(r),o=e.map(p=>p[0]).join(","),a=e.map((p,g)=>p[0]+t[g]).join(","),l=Zs("rc",r),u=Zs("source",r),c=`${l[r-1]} < ${this.outputShape[r-1]}`,d=1===r?"source":`vec2(${u.slice(-2).join()})`,h="reflect"===s?0:1;let f="";if(1===r){const p=`\n        ${i} source = rc;\n        if (source < start) {\n          source = start * 2 - source - ${h};\n        } else if (source >= end) {\n          source = (end - 1) * 2 - source + ${h};\n        }\n        source -= start;\n      `;f=`\n        ${i} rc = outputLoc;\n        ${p}\n        result[0] = getChannel(getX(${u.join()}), ${d});\n        ${l[r-1]} += 1;\n        if(${c}) {\n          ${p}\n          result[1] = getChannel(getX(${u.join()}), ${d});\n        }\n      `}else{const p=`\n        ${i} source = rc;\n        ${i} lt = ${i}(lessThan(source, start));\n        ${i} gte = ${i}(greaterThanEqual(source, end));\n        ${i} orig = 1 - (lt + gte);\n        source = orig * source +\n                lt * (start * 2 - source - ${h}) +\n                gte * ((end - 1) * 2 - source + ${h});\n        source -= start;\n      `;f=`\n        ${i} rc = outputLoc;\n        ${p}\n        result[0] = getChannel(getX(${u.join()}), ${d});\n        ${l[r-1]} += 1;\n        if(${c}) {\n          ${p}\n          result[1] = getChannel(getX(${u.join()}), ${d});\n        }\n        rc = outputLoc;\n        ${l[r-2]} += 1;\n        if(${l[r-2]} < ${this.outputShape[r-2]}) {\n          ${p}\n          result[2] = getChannel(getX(${u.join()}), ${d});\n          ${l[r-1]} += 1;\n          if(${c}) {\n            ${p}\n            result[3] = getChannel(getX(${u.join()}), ${d});\n          }\n        }\n      `}this.userCode=`\n      const ${i} start = ${i}(${o});\n      const ${i} end = ${i}(${a});\n\n      void main() {\n        ${i} outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        ${f}\n        setOutput(result);\n      }\n    `}}const $De={kernelName:Ky,backendName:"webgl",kernelFunc:({inputs:n,backend:t,attrs:e})=>{const{x:s}=n,{paddings:r,mode:i}=e,o=W().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new ODe(s.shape,r,i):new FDe(s.shape,r,i);return t.runWebGLProgram(o,[s],s.dtype)}},VDe=As({opSnippet:"if (b == 0.0) return NAN;\n  return mod(a, b);",packedOpSnippet:"\n  vec4 result = mod(a, b);\n  bvec4 isNaN = equal(b, vec4(0.0));\n  "+Cu+"\n  return result;\n"}),BDe={kernelName:Af,backendName:"webgl",kernelFunc:VDe};class zDe{constructor(t,e,s){this.variableNames=["probs"],this.customUniforms=[{name:"seed",type:"float"}],this.outputShape=[t,s],this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n\n        float r = random(seed);\n        float cdf = 0.0;\n\n        for (int i = 0; i < ${e-1}; i++) {\n          cdf += getProbs(batch, i);\n\n          if (r < cdf) {\n            setOutput(float(i));\n            return;\n          }\n        }\n\n        // If no other event happened, last event happened.\n        setOutput(float(${e-1}));\n      }\n    `}}const XU=As({opSnippet:"\nif (a == b) {\n  return 1.0;\n};\nreturn a / b;",packedOpSnippet:"\n  // vec4 one = vec4(equal(a, b));\n  // return one + (vec4(1.0) - one) * a / b;\n  vec4 result = a / b;\n  if(a.x == b.x) {\n    result.x = 1.;\n  }\n  if(a.y == b.y) {\n    result.y = 1.;\n  }\n  if(a.z == b.z) {\n    result.z = 1.;\n  }\n  if(a.w == b.w) {\n    result.w = 1.;\n  }\n\n  return result;\n",checkOutOfBounds:!0}),UDe={kernelName:mf,backendName:"webgl",kernelFunc:XU},YU="return a - b;",ZU=As({opSnippet:YU,packedOpSnippet:YU,supportsComplex:!0,cpuKernelImpl:y0e}),WDe={kernelName:qf,backendName:"webgl",kernelFunc:ZU};function QU(n){const{inputs:t,backend:e,attrs:s}=n,{logits:r}=t,{dim:i}=s,o=mt([i],r.shape),a=KU({inputs:{x:r},backend:e,attrs:{reductionIndices:o,keepDims:!1}}),l=On(a.shape,o),u=be({inputs:{x:a},backend:e,attrs:{shape:l}}),c=ZU({inputs:{a:r,b:u},backend:e}),d=UU({inputs:{x:c},backend:e}),h=e_({inputs:{x:d},backend:e,attrs:{axis:o,keepDims:!1}}),f=be({inputs:{x:h},backend:e,attrs:{shape:l}}),p=XU({inputs:{a:d,b:f},backend:e});return e.disposeIntermediateTensorInfo(a),e.disposeIntermediateTensorInfo(u),e.disposeIntermediateTensorInfo(c),e.disposeIntermediateTensorInfo(d),e.disposeIntermediateTensorInfo(h),e.disposeIntermediateTensorInfo(f),p}const GDe={kernelName:hb,backendName:"webgl",kernelFunc:QU},jDe={kernelName:CS,backendName:"webgl",kernelFunc:function HDe(n){const{inputs:t,backend:e,attrs:s}=n,{logits:r}=t,{numSamples:i,seed:o,normalized:a}=s,l=a?r:QU({inputs:{logits:r},backend:e,attrs:{dim:r.shape.length-1}}),d=new zDe(l.shape[0],l.shape[1],i),f=e.runWebGLProgram(d,[l],"int32",[[o]]);return a||e.disposeIntermediateTensorInfo(l),f}},qDe=Jr+"\n  return -x;\n",YDe={kernelName:Xy,backendName:"webgl",kernelFunc:function XDe(n){const{inputs:t,backend:e}=n,{x:s}=t;if(e.shouldExecuteOnCPU([s])){const i=e.texData.get(s.dataId),[o,a]=Qxe(i.values,s.shape,s.dtype);return e.makeTensorInfo(a,s.dtype,o)}let r;return r=W().getBool("WEBGL_PACK_UNARY_OPERATIONS")?new fl(s.shape,"\n  vec4 result = -x;\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"):new Fo(s.shape,qDe),e.runWebGLProgram(r,[s],s.dtype)}},ZDe=wE,JDe={kernelName:SS,backendName:"webgl",kernelFunc:function QDe(n){Gr("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:e,attrs:s}=n,{boxes:r,scores:i}=t,{maxOutputSize:o,iouThreshold:a,scoreThreshold:l}=s,u=e.readSync(r.dataId),c=e.readSync(i.dataId),{selectedIndices:d}=ZDe(u,c,o,a,l);return e.makeTensorInfo([d.length],"int32",new Int32Array(d))}},eTe=xE,nTe={kernelName:IS,backendName:"webgl",kernelFunc:function tTe(n){Gr("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:e,attrs:s}=n,{boxes:r,scores:i}=t,{maxOutputSize:o,iouThreshold:a,scoreThreshold:l,padToMaxOutputSize:u}=s,c=e.readSync(r.dataId),d=e.readSync(i.dataId),{selectedIndices:h,validOutputs:f}=eTe(c,d,o,a,l,u);return[e.makeTensorInfo([h.length],"int32",new Int32Array(h)),e.makeTensorInfo([],"int32",new Int32Array([f]))]}},sTe=CE,iTe={kernelName:ES,backendName:"webgl",kernelFunc:function rTe(n){Gr("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:e,attrs:s}=n,{boxes:r,scores:i}=t,{maxOutputSize:o,iouThreshold:a,scoreThreshold:l,softNmsSigma:u}=s,c=e.readSync(r.dataId),d=e.readSync(i.dataId),h=o,f=a,p=l,g=u,{selectedIndices:m,selectedScores:y}=sTe(c,d,h,f,p,g);return[e.makeTensorInfo([m.length],"int32",new Int32Array(m)),e.makeTensorInfo([y.length],"float32",new Float32Array(y))]}};class oTe{constructor(t,e,s,r){this.variableNames=["indices"],this.outputShape=[t,e],this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int index = round(getIndices(coords.x));\n        setOutput(mix(float(${r}), float(${s}),\n                      float(index == coords.y)));\n      }\n    `}}const aTe={kernelName:Qy,backendName:"webgl",kernelFunc:n=>{const{inputs:t,backend:e,attrs:s}=n,{indices:r}=t,{dtype:i,depth:o,onValue:a,offValue:l}=s,u=X(r.shape),c=new oTe(u,o,a,l),d=be({inputs:{x:r},backend:e,attrs:{shape:[u]}}),h=e.runWebGLProgram(c,[d],i);e.disposeIntermediateTensorInfo(d);const p=be({inputs:{x:h},backend:e,attrs:{shape:[...r.shape,o]}});return e.disposeIntermediateTensorInfo(h),p}};function o_(n){const{inputs:t,backend:e}=n,{x:s}=t;if("complex64"===s.dtype){const r=Gp({inputs:{input:s},backend:e}),i=o_({inputs:{x:r},backend:e}),o=r_({inputs:{input:s},backend:e}),a=o_({inputs:{x:o},backend:e}),l=pl({inputs:{real:i,imag:a},backend:e});return e.disposeIntermediateTensorInfo(r),e.disposeIntermediateTensorInfo(i),e.disposeIntermediateTensorInfo(o),e.disposeIntermediateTensorInfo(a),l}return jp({attrs:{shape:s.shape,dtype:s.dtype,value:"string"===s.dtype?"":0},backend:e})}const lTe={kernelName:gb,backendName:"webgl",kernelFunc:o_},uTe={kernelName:Zy,backendName:"webgl",kernelFunc:function JU(n){const{inputs:t,backend:e}=n,{x:s}=t;if("string"===s.dtype)throw new Error("onesLike is not supported under string dtype");if("complex64"===s.dtype){const r=Gp({inputs:{input:s},backend:e}),i=JU({inputs:{x:r},backend:e}),o=r_({inputs:{input:s},backend:e}),a=o_({inputs:{x:o},backend:e}),l=pl({inputs:{real:i,imag:a},backend:e});return e.disposeIntermediateTensorInfo(r),e.disposeIntermediateTensorInfo(i),e.disposeIntermediateTensorInfo(o),e.disposeIntermediateTensorInfo(a),l}return jp({attrs:{shape:s.shape,dtype:s.dtype,value:1},backend:e})}},dTe={kernelName:Jy,backendName:"webgl",kernelFunc:function cTe(n){const{inputs:t,backend:e,attrs:s}=n,{axis:r}=s;if(1===t.length)return AT({inputs:{input:t[0]},backend:e,attrs:{dim:r}});const i=t[0].shape,o=t[0].dtype;t.forEach(c=>{Sr(i,c.shape,"All tensors passed to stack must have matching shapes"),S(o===c.dtype,()=>"All tensors passed to stack must have matching dtypes")});const a=[],u=AU({inputs:t.map(c=>{const d=AT({inputs:{input:c},backend:e,attrs:{dim:r}});return a.push(d),d}),backend:e,attrs:{axis:r}});return a.forEach(c=>e.disposeIntermediateTensorInfo(c)),u}};class hTe{constructor(t,e,s){this.variableNames=["x"],this.customUniforms=[{name:"value",type:"float"}],this.outputShape=e.map((u,c)=>u[0]+t[c]+u[1]);const r=t.length,i=Xt(r),o=e.map(u=>u[0]).join(","),a=e.map((u,c)=>u[0]+t[c]).join(","),l=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,r);this.userCode=1!==r?`\n      ${i} start = ${i}(${o});\n      ${i} end = ${i}(${a});\n\n      void main() {\n        ${i} outC = getOutputCoords();\n        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {\n          setOutput(value);\n        } else {\n          ${i} coords = outC - start;\n          setOutput(getX(${l}));\n        }\n      }\n    `:`\n        int start = ${o};\n        int end = ${a};\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start || outC >= end) {\n            setOutput(value);\n          } else {\n            setOutput(getX(outC - start));\n          }\n        }\n      `}}class fTe{constructor(t,e,s){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"value",type:"float"}],this.outputShape=e.map((g,m)=>g[0]+t[m]+g[1]);const r=t.length,i=Xt(r),o=e.map(g=>g[0]).join(","),a=e.map((g,m)=>g[0]+t[m]).join(","),l=Zs("rc",r),u=Zs("source",r),c=`${l[r-1]} < ${this.outputShape[r-1]}`,d=1===r?"source":`vec2(${u.slice(-2).join()})`,h=[`${i} rc = outputLoc;`,`${l[r-1]} += 1;\n       if(${c}) {\n      `,1===r?"":`}\n       rc = outputLoc;\n       ${l[r-2]} += 1;\n       if(${l[r-2]} < ${this.outputShape[r-2]}) {`,1===r?"":`  ${l[r-1]} += 1;\n         if(${c}) {`],f=1===r?"rc < start || rc >= end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))";let p="";for(let g=0,m=1===r?2:4;g<m;g++)p+=`\n        ${h[g]}\n        if (${f}) {\n          result[${g}] = float(value);\n        } else {\n          ${i} source = rc - start;\n          result[${g}] = getChannel(getX(${u.join()}), ${d});\n        }\n      `;p+=1===r?"} ":"}}",this.userCode=`\n      const ${i} start = ${i}(${o});\n      const ${i} end = ${i}(${a});\n\n      void main() {\n        ${i} outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        ${p}\n        setOutput(result);\n      }\n    `}}const eW=n=>{const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{paddings:i,constantValue:o}=s;if(0===X(r.shape))return jp({backend:e,attrs:{shape:i.map((c,d)=>c[0]+r.shape[d]+c[1]),value:o,dtype:r.dtype}});const a=W().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new fTe(r.shape,i,o):new hTe(r.shape,i,o);return e.runWebGLProgram(a,[r],r.dtype,[[o]])},pTe={kernelName:eb,backendName:"webgl",kernelFunc:eW},yTe=As({opSnippet:"\n  if(a < 0.0 && floor(b) < b){\n    return NAN;\n  }\n  if (b == 0.0) {\n    return 1.0;\n  }\n  return (round(mod(b, 2.0)) != 1) ?\n      pow(abs(a), b) : sign(a) * pow(abs(a), b);\n",packedOpSnippet:"\n  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.\n  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));\n  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);\n  vec4 result = multiplier * pow(abs(a), b);\n\n  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS\n  bvec4 isExpZero = equal(b, vec4(0.0));\n  result.r = isExpZero.r ? 1.0 : result.r;\n  result.g = isExpZero.g ? 1.0 : result.g;\n  result.b = isExpZero.b ? 1.0 : result.b;\n  result.a = isExpZero.a ? 1.0 : result.a;\n\n  bvec4 isNaN1 = lessThan(a, vec4(0.0));\n  bvec4 isNaN2 = lessThan(floor(b), b);\n  bvec4 isNaN = bvec4(isNaN1.x && isNaN2.x, isNaN1.y && isNaN2.y, isNaN1.z && isNaN2.z, isNaN1.w && isNaN2.w);\n  "+Cu+"\n  return result;\n"}),bTe={kernelName:Mf,backendName:"webgl",kernelFunc:yTe},_Te={kernelName:nb,backendName:"webgl",kernelFunc:function vTe(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{axis:i,keepDims:o}=s,a=r.shape.length,l=[],u=mt(i,r.shape);let c=u;const d=vn(c,a);let f,h=r;if(null!=d&&(h=Qs({inputs:{x:r},backend:e,attrs:{perm:d}}),c=$n(c.length,a),l.push(h)),Ns("prod",c,a),e.shouldExecuteOnCPU([h])){const p=e.texData.get(h.dataId).values,{outVals:g,outShape:m,outDtype:y}=e0e(h.shape,h.dtype,p,c);f=e.makeTensorInfo(m,y,g)}else{const[p,g]=ws(h.shape,c),m=X(g),y=be({inputs:{x:h},backend:e,attrs:{shape:[-1,m]}}),v=Su(y,nI(r.dtype),"prod",e);f=be({inputs:{x:v},backend:e,attrs:{shape:p}}),l.push(y),l.push(v)}if(o){l.push(f);const p=On(f.shape,u);f=be({inputs:{x:f},backend:e,attrs:{shape:p}})}return l.forEach(p=>e.disposeIntermediateTensorInfo(p)),f}},xTe={kernelName:DS,backendName:"webgl",kernelFunc:function wTe(n){const{inputs:t,backend:e,attrs:s}=n,{paramsNestedSplits:r,paramsDenseValues:i,indices:o}=t,{outputRaggedRank:a}=s,l=r.map(y=>e.readSync(y.dataId)),u=r.map(y=>y.shape),c=e.readSync(i.dataId),d=e.readSync(o.dataId),[h,f,p]=t0e(l,u,c,i.shape,i.dtype,d,o.shape,a),g=h.map(y=>e.makeTensorInfo([y.length],"int32",y)),m=e.makeTensorInfo(p,i.dtype,f);return g.concat([m])}},STe={kernelName:TS,backendName:"webgl",kernelFunc:function CTe(n){const{inputs:t,backend:e}=n,{starts:s,limits:r,deltas:i}=t,o=e.readSync(s.dataId),a=e.readSync(r.dataId),l=e.readSync(i.dataId),[u,c]=n0e(o,s.shape,s.dtype,a,r.shape,l,i.shape);return[e.makeTensorInfo([u.length],"int32",u),e.makeTensorInfo([c.length],s.dtype,c)]}},ETe={kernelName:NS,backendName:"webgl",kernelFunc:function ITe(n){const{inputs:t,backend:e,attrs:s}=n,{shape:r,values:i,defaultValue:o,rowPartitionTensors:a}=t,{rowPartitionTypes:l}=s,u=e.readSync(r.dataId),c=e.readSync(i.dataId),d=e.readSync(o.dataId),h=a.map(m=>e.readSync(m.dataId)),f=a.map(m=>m.shape),[p,g]=s0e(u,r.shape,c,i.shape,i.dtype,d,o.shape,h,f,l);return e.makeTensorInfo(p,i.dtype,g)}},tW=n=>{const{backend:t,attrs:e}=n,{start:s,stop:r,step:i,dtype:o}=e,a=r0e(s,r,i,o);return t.makeTensorInfo([a.length],o,a)},DTe={kernelName:kS,backendName:"webgl",kernelFunc:tW},TTe=Nt({opSnippet:"return 1.0 / x;"}),NTe={kernelName:Ff,backendName:"webgl",kernelFunc:TTe},ATe=Nt({opSnippet:Jr+"\n  return (x < 0.0) ? 0.0 : x;\n",packedOpSnippet:"\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"}),RTe={kernelName:Of,backendName:"webgl",kernelFunc:ATe},FTe=Nt({opSnippet:Jr+"\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n",packedOpSnippet:"\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"}),OTe={kernelName:$f,backendName:"webgl",kernelFunc:FTe};class $Te{constructor(t,e,s,r,i){this.variableNames=["A"],this.outputShape=[];const[o,a,l,u]=t;this.outputShape=[o,e,s,u];const c=[r&&e>1?a-1:a,r&&s>1?l-1:l],d=[r&&e>1?e-1:e,r&&s>1?s-1:s];let h;h=i?"(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)":"vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ${c[0]/d[0]},\n          ${c[1]/d[1]});\n      const vec2 inputShapeRC = vec2(${a}.0, ${l}.0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = ${h};\n\n        // Compute the four integer indices.\n        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));\n        ivec2 sourceCeilRC = ivec2(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);\n        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);\n        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);\n        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);\n\n        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);\n\n        float top = topLeft + (topRight - topLeft) * fracRC.y;\n        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;\n        float newValue = top + (bottom - top) * fracRC.x;\n\n        setOutput(newValue);\n      }\n    `}}class PTe{constructor(t,e,s,r,i){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[o,a,l,u]=t;this.outputShape=[o,e,s,u];const c=[r&&e>1?a-1:a,r&&s>1?l-1:l],d=[r&&e>1?e-1:e,r&&s>1?s-1:s];let h;h=i?"(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)":"vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          ${c[0]/d[0]},\n          ${c[1]/d[1]},\n          ${c[1]/d[1]});\n      const vec3 inputShapeRC = vec3(${a}.0, ${l}.0,\n                                     ${l}.0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = ${h};\n\n        // Compute the four integer indices.\n        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));\n        ivec3 sourceCeilRC = ivec3(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < ${u-1};\n        bool hasNextRow = coords.z < ${s-1};\n\n        // In parallel, construct four corners for all four components in\n        // packed 2x2 cell.\n        vec4 topLeft = vec4(\n          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 bottomLeft = vec4(\n          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 topRight = vec4(\n          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec4 bottomRight = vec4(\n          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);\n\n        vec4 top = mix(topLeft, topRight, fracRC.yyzz);\n        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);\n        vec4 newValue = mix(top, bottom, fracRC.x);\n\n        setOutput(newValue);\n      }\n    `}}const VTe={kernelName:ib,backendName:"webgl",kernelFunc:function LTe(n){const{inputs:t,backend:e,attrs:s}=n,{images:r}=t,{alignCorners:i,halfPixelCenters:o,size:a}=s,[l,u]=a,c=W().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new PTe(r.shape,l,u,i,o):new $Te(r.shape,l,u,i,o);return e.runWebGLProgram(c,[r],"float32")}};class BTe{constructor(t,e,s){this.variableNames=["dy"],this.outputShape=[],this.outputShape=e;const[,r,i]=e,[,o,a]=t,l=[s&&o>1?r-1:r,s&&a>1?i-1:i],u=[s&&o>1?o-1:o,s&&a>1?a-1:a],c=l[0]/u[0],d=l[1]/u[1],h=1/c,f=1/d,p=2*Math.ceil(h)+2,g=2*Math.ceil(f)+2;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(${c});\n        const float widthScale = float(${d});\n\n        const float invHeightScale = float(${h});\n        const float invWidthScale = float(${f});\n\n        const int winHeight = int(${p});\n        const int winWidth = int(${g});\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(startRLerp - float(winHeight / 2));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(startCLerp - float(winWidth / 2));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ${o}) {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ${a}) {\n              continue;\n            }\n\n            float dxR = float(dyR) * heightScale;\n            int topDxRIndex = int(floor(dxR));\n            int bottomDxRIndex = int(min(ceil(dxR), ${r-1}.0));\n            float dxRLerp = dxR - float(topDxRIndex);\n            float inverseDxRLerp = 1.0 - dxRLerp;\n\n            float dxC = float(dyC) * widthScale;\n            int leftDxCIndex = int(floor(dxC));\n            int rightDxCIndex = int(min(ceil(dxC), ${i-1}.0));\n            float dxCLerp = dxC - float(leftDxCIndex);\n            float inverseDxCLerp = 1.0 - dxCLerp;\n\n            if (r == topDxRIndex && c == leftDxCIndex) {\n              // topLeft\n              accumulator +=\n                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;\n            }\n\n            if (r == topDxRIndex && c == rightDxCIndex) {\n              // topRight\n              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == leftDxCIndex) {\n              // bottomLeft\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == rightDxCIndex) {\n              // bottomRight\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    `}}const UTe={kernelName:MS,backendName:"webgl",kernelFunc:function zTe(n){const{inputs:t,backend:e,attrs:s}=n,{images:r,dy:i}=t,{alignCorners:o}=s,a=new BTe(i.shape,r.shape,o);return e.runWebGLProgram(a,[i],i.dtype)}};class WTe{constructor(t,e,s,r,i){this.variableNames=["A"],this.outputShape=[];const[o,a,l,u]=t;this.outputShape=[o,e,s,u];const c=[r&&e>1?a-1:a,r&&s>1?l-1:l],d=[r&&e>1?e-1:e,r&&s>1?s-1:s];let f;f=i?"max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC, vec2(0.0))":"vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ${c[0]/d[0]},\n          ${c[1]/d[1]});\n      const vec2 inputShapeRC = vec2(${a}.0, ${l}.0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = ${f};\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec2 sourceNearestRC = ivec2(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${r?"0.5":"0.0"})));\n        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);\n\n        setOutput(newValue);\n      }\n    `}}class GTe{constructor(t,e,s,r,i){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[o,a,l,u]=t;this.outputShape=[o,e,s,u];const c=[r&&e>1?a-1:a,r&&s>1?l-1:l],d=[r&&e>1?e-1:e,r&&s>1?s-1:s];let f;f=i?"max((vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC, vec3(0.0))":"vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          ${c[0]/d[0]},\n          ${c[1]/d[1]},\n          ${c[1]/d[1]});\n      const vec3 inputShapeRC = vec3(${a}.0, ${l}.0,\n                                     ${l}.0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = ${f};\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec3 sourceNearestRC = ivec3(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${r?"0.5":"0.0"})));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < ${u-1};\n        bool hasNextRow = coords.z < ${s-1};\n\n        vec4 newValue = vec4(\n          getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d),\n          hasNextCol ? getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d + 1) : 0.0);\n\n        setOutput(newValue);\n      }\n    `}}const jTe={kernelName:rb,backendName:"webgl",kernelFunc:function HTe(n){const{inputs:t,backend:e,attrs:s}=n,{images:r}=t,{alignCorners:i,halfPixelCenters:o,size:a}=s,[l,u]=a,c=W().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new GTe(r.shape,l,u,i,o):new WTe(r.shape,l,u,i,o);return e.runWebGLProgram(c,[r],r.dtype)}};class qTe{constructor(t,e,s){this.variableNames=["dy"],this.outputShape=[],this.outputShape=e;const[,r,i]=e,[,o,a]=t,l=[s&&o>1?r-1:r,s&&a>1?i-1:i],u=[s&&o>1?o-1:o,s&&a>1?a-1:a],c=l[0]/u[0],d=l[1]/u[1],h=1/c,f=1/d,p=2*Math.ceil(h)+2,g=2*Math.ceil(f)+2;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(${c});\n        const float widthScale = float(${d});\n\n        const float invHeightScale = float(${h});\n        const float invWidthScale = float(${f});\n\n        const int winHeight = int(${p});\n        const int winWidth = int(${g});\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(floor(startRLerp - float(winHeight / 2)));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(floor(startCLerp - float(winWidth / 2)));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ${o}) {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ${a}) {\n              continue;\n            }\n\n            float sourceFracRow =\n              float(${l[0]}) *\n                (float(dyR) / float(${u[0]}));\n\n            float sourceFracCol =\n                float(${l[1]}) *\n                  (float(dyC) / float(${u[1]}));\n\n            int sourceNearestRow = int(min(\n                float(int(${r}) - 1),\n                ${s} ? float(round(sourceFracRow)) :\n                                  float(floor(sourceFracRow))));\n\n            int sourceNearestCol = int(min(\n                float(int(${i}) - 1),\n                ${s} ? float(round(sourceFracCol)) :\n                                  float(floor(sourceFracCol))));\n\n            if (r == sourceNearestRow && c == sourceNearestCol) {\n              accumulator += getDy(b, dyR, dyC, d);\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    `}}const XTe={kernelName:RS,backendName:"webgl",kernelFunc:function KTe(n){const{inputs:t,backend:e,attrs:s}=n,{images:r,dy:i}=t,{alignCorners:o}=s,a=new qTe(i.shape,r.shape,o);return e.runWebGLProgram(a,[i],i.dtype)}};class YTe{constructor(t,e){this.variableNames=["x"];const s=t.length;if(s>4)throw new Error(`WebGL backend: Reverse of rank-${s} tensor is not yet supported`);if(this.outputShape=t,1===s)return void(this.userCode=`\n        void main() {\n          int coord = getOutputCoords();\n          setOutput(getX(${t[0]} - coord - 1));\n        }\n      `);const i=t.map((a,l)=>(a=>-1!==e.indexOf(a)&&1!==t[a]?`${t[a]} - coords[${a}] - 1`:`coords[${a}]`)(l)).join(","),o=Xt(s);this.userCode=`\n      void main() {\n        ${o} coords = getOutputCoords();\n        setOutput(getX(${i}));\n      }\n    `}}class ZTe{constructor(t,e){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0;const s=t.length;if(s>4)throw new Error(`WebGL backend: Reverse of rank-${s} tensor is not yet supported`);this.outputShape=t;const r=Zs("rc",s),i=`${r[s-1]} + 1 < ${this.outputShape[s-1]}`,o=`${r[s-2]} + 1 < ${this.outputShape[s-2]}`,a=Xt(s);function h(p){const g=t.map((b,v)=>function f(p,g){return-1!==e.indexOf(p)&&1!==t[p]?`${t[p]} - ${g[p]} - 1`:`${g[p]}`}(v,p));return`getChannel(getX(${g.join(",")}), vec2(${g.slice(-2).join(",")}))`}this.userCode=1===s?`\n        void main(){\n          int rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = getChannel(getX(${t[0]} - rc - 1),\n            ${t[0]} - rc - 1);\n          if(${i}){\n              result.g = getChannel(getX(${t[0]} - (rc  + 1) - 1),\n                ${t[0]} - (rc  + 1) - 1);\n          }\n          setOutput(result);\n        }\n      `:`\n        void main() {\n          ${a} rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = ${function l(p){return h(p)}(r.slice())};\n          if(${i}){\n            result.g = ${function u(p){return p[s-1]="("+p[s-1]+" + 1)",h(p)}(r.slice())};\n          }\n          if(${o}) {\n            result.b = ${function c(p){return p[s-2]="("+p[s-2]+" + 1)",h(p)}(r.slice())};\n            if(${i}) {\n              result.a = ${function d(p){return p[s-1]="("+p[s-1]+" + 1)",p[s-2]="("+p[s-2]+" + 1)",h(p)}(r.slice())};\n            }\n          }\n          setOutput(result);\n        }\n    `}}const JTe={kernelName:ob,backendName:"webgl",kernelFunc:function QTe(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{dims:i}=s,o=r.shape.length,a=mt(i,r.shape);if(0===o)return Ar({inputs:{x:r},backend:e});const l=W().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new ZTe(r.shape,a):new YTe(r.shape,a);return e.runWebGLProgram(l,[r],r.dtype)}};class eNe{constructor(t,e){this.variableNames=["Image"],this.outputShape=[],this.customUniforms=[{name:"params",type:"vec4"}];const s=t[1],r=t[2];this.outputShape=t;let i="";i="number"==typeof e?`float outputValue = ${e.toFixed(2)};`:`\n        vec3 fill = vec3(${e.join(",")});\n        float outputValue = fill[coords[3]];`,this.userCode=`\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int x = coords[2];\n          int y = coords[1];\n          float coordXFloat = (float(x) - params[0]) * params[3] -\n            (float(y) - params[1]) * params[2];\n          float coordYFloat = (float(x) - params[0]) * params[2] +\n            (float(y) - params[1]) * params[3];\n          int coordX = int(round(coordXFloat + params[0]));\n          int coordY = int(round(coordYFloat + params[1]));\n          ${i}\n          if(coordX >= 0 && coordX < ${r} && coordY >= 0 && coordY < ${s}) {\n            outputValue = getImage(coords[0], coordY, coordX, coords[3]);\n          }\n          setOutput(outputValue);\n        }\n    `}}const tNe={kernelName:YS,backendName:"webgl",kernelFunc:({inputs:n,attrs:t,backend:e})=>{const{image:s}=n,{radians:r,fillValue:i,center:o}=t,a=e,l=new eNe(s.shape,i),[u,c]=kE(o,s.shape[1],s.shape[2]),d=[[u,c,Math.sin(r),Math.cos(r)]];return a.runWebGLProgram(l,[s],s.dtype,d)}},nNe=Nt({opSnippet:"\n  // OpenGL ES does not support round function.\n  // The algorithm is based on banker's rounding.\n  float base = floor(x);\n  if ((x - base) < 0.5) {\n    return floor(x);\n  } else if ((x - base) > 0.5) {\n    return ceil(x);\n  } else {\n    if (mod(base, 2.0) == 0.0) {\n      return base;\n    } else {\n      return base + 1.0;\n    }\n  }\n"}),sNe={kernelName:Pf,backendName:"webgl",kernelFunc:nNe},rNe=Nt({opSnippet:"return inversesqrt(x);",cpuKernelImpl:i0e}),iNe={kernelName:Lf,backendName:"webgl",kernelFunc:rNe};class MT{constructor(t,e,s,r,i,o,a=!0,l=!1){this.variableNames=["updates","indices","defaultValue"],this.outputShape=o;const u=Xt(i.length),c=Xt(o.length);let d="";1===s?d="i":2===s&&(d="i, j");let f="";1===r?f="i":2===r&&(f="i, coords[1]");let g="";l&&(g="coords[0], coords[1]"),this.userCode=`\n        ${u} strides = ${u}(${i});\n\n        void main() {\n          ${c} coords = getOutputCoords();\n          float sum = 0.0;\n          bool found = false;\n          for (int i = 0; i < ${t}; i++) {\n            int flattenedIndex = 0;\n            for (int j = 0; j < ${e}; j++) {\n              int index = round(getIndices(${d}));\n              flattenedIndex += index * ${e>1?"strides[j]":"strides"};\n            }\n            if (flattenedIndex == coords[0]) {\n              sum += getUpdates(${f});\n              found = true;\n            }\n          }\n          setOutput(mix(getDefaultValue(${g}), sum, float(found)));\n        }\n      `}}class oNe{constructor(t,e,s,r,i,o,a=!0,l=!1){this.variableNames=["updates","indices","defaultValue"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=o;const u=Xt(i.length),c=Xt(o.length);let d="";1===s?d="i":2===s&&(d="i, j");let f="";1===r?f="i":2===r&&(f="i, coords[1]");let g="";l&&(g="coords[0], coords[1]"),this.userCode=`\n        ${u} strides = ${u}(${i});\n\n        void main() {\n          ${c} coords = getOutputCoords();\n          vec4 sum = vec4(0.);\n          vec4 found = vec4(0.);\n          for (int i = 0; i < ${t}; i+=2) {\n            ivec2 flattenedIndex = ivec2(0);\n            for (int j = 0; j < ${e}; j+=2) {\n              ivec4 index = round(getIndices(${d}));\n              flattenedIndex += index.xz * ${e>1?"strides[j]":"strides"};\n              if (j + 1 < ${e}) {\n                flattenedIndex += index.yw * ${e>1?"strides[j + 1]":"strides"};\n              }\n            }\n            if (flattenedIndex[0] == coords[0] || flattenedIndex[1] == coords[0] ||\n                flattenedIndex[0] == coords[0] + 1 || flattenedIndex[1] == coords[0] + 1) {\n              vec4 updVals = getUpdates(${f});\n              if (flattenedIndex[0] == coords[0]) {\n                sum.xy += updVals.xy;\n                found.xy = vec2(1.);\n              } else if (flattenedIndex[0] == coords[0] + 1) {\n                sum.zw += updVals.xy;\n                found.zw = vec2(1.);\n              }\n              if (flattenedIndex[1] == coords[0]) {\n                sum.xy += updVals.zw;\n                found.xy = vec2(1.);\n              } else if (flattenedIndex[1] == coords[0] + 1) {\n                sum.zw += updVals.zw;\n                found.zw = vec2(1.);\n              }\n            }\n          }\n          setOutput(mix(getDefaultValue(${g}), sum, found));\n        }\n      `}}const lNe={kernelName:FS,backendName:"webgl",kernelFunc:function aNe(n){const{inputs:t,backend:e,attrs:s}=n,{indices:r,updates:i}=t,{shape:o}=s,{sliceRank:a,numUpdates:l,sliceSize:u,strides:c,outputSize:d}=uu(0,r,o),h=[d/u,u];if(0===d)return e.makeTensorInfo(o,r.dtype);const f=be({inputs:{x:r},backend:e,attrs:{shape:[l,a]}}),p=be({inputs:{x:i},backend:e,attrs:{shape:[l,u]}}),g=e.makeTensorInfo([],"float32",new Float32Array([0]));let m;m=W().getBool("WEBGL_PACK")?new oNe(l,a,f.shape.length,p.shape.length,c,h):new MT(l,a,f.shape.length,p.shape.length,c,h);const y=e.runWebGLProgram(m,[p,f,g],p.dtype),b=be({inputs:{x:y},backend:e,attrs:{shape:o}});return e.disposeIntermediateTensorInfo(f),e.disposeIntermediateTensorInfo(p),e.disposeIntermediateTensorInfo(y),e.disposeIntermediateTensorInfo(g),b}};class uNe{constructor(t,e,s,r){this.variableNames=["sortedSequence","values"],this.customUniforms=[{name:"numInputs",type:"int"}],this.outputShape=[t,s];const o=`for (int i = 0; i < ${Math.ceil(Math.log2(e+1))}; ++i) { if (left >= right) break;`,a=2===W().getNumber("WEBGL_VERSION")?"while (left < right) {":o;this.userCode=`\n       int findBound(int batch, float value) {\n         int left = 0;\n         int right = numInputs;\n         int mid;\n         ${a}\n           mid = (left + right) / 2;\n           if (getSortedSequence(batch, mid) ${"left"===r?"<":"<="} value) {\n             left = mid + 1;\n           } else {\n             right = mid;\n           }\n         }\n         return right;\n       }\n\n       void main() {\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int valueIndex = coords[1];\n\n         float value = getValues(batch, valueIndex);\n\n         setOutput(float(findBound(batch, value)));\n       }\n     `}}const dNe={kernelName:$S,backendName:"webgl",kernelFunc:function cNe(n){const{inputs:t,backend:e,attrs:s}=n,{sortedSequence:r,values:i}=t,{side:o}=s,a=new uNe(r.shape[0],r.shape[1],i.shape[1],o);return e.runWebGLProgram(a,[r,i],"int32",[[r.shape[1]]])}};class hNe{constructor(t,e,s){let r,i;if(this.variableNames=["c","a","b"],this.outputShape=e,s>4)throw Error(`Where for rank ${s} is not yet supported`);if(1===s)i="resRC",r="resRC";else{const a=["resRC.x","resRC.y","resRC.z","resRC.w"],l=[],u=[];for(let c=0;c<e.length;c++)u.push(`${a[c]}`),c<t&&l.push(`${a[c]}`);r=l.join(),i=u.join()}const o=Xt(s);this.userCode=`\n      void main() {\n        ${o} resRC = getOutputCoords();\n        float cVal = getC(${r});\n        if (cVal >= 1.0) {\n          setOutput(getA(${i}));\n        } else {\n          setOutput(getB(${i}));\n        }\n      }\n    `}}const pNe={kernelName:ab,backendName:"webgl",kernelFunc:function fNe(n){const{inputs:t,backend:e}=n,{condition:s,t:r,e:i}=t,o=new hNe(s.shape.length,r.shape,r.shape.length);return e.runWebGLProgram(o,[s,r,i],Ir(r.dtype,i.dtype))}},gNe=Nt({opSnippet:`\n  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.\n  // see: https://arxiv.org/abs/1706.02515\n  float scaleAlpha = ${nv};\n  float scale = ${sv};\n  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);\n`}),yNe={kernelName:Vf,backendName:"webgl",kernelFunc:gNe},vNe=Nt({opSnippet:Ed+"\n  return 1.0 / (1.0 + exp(-1.0 * x));\n",packedOpSnippet:"\n  vec4 result = 1.0 / (1.0 + exp(-1.0 * x));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",cpuKernelImpl:a0e}),_Ne={kernelName:Wf,backendName:"webgl",kernelFunc:vNe},wNe=Nt({opSnippet:"\n  if (isnan(x)) { return 0.0; }\n  return sign(x);\n"}),xNe={kernelName:Uf,backendName:"webgl",kernelFunc:wNe},INe=Nt({opSnippet:Ed+"\n  return sin(x);\n",packedOpSnippet:`\n  vec4 result = sin(x);\n  bvec4 isNaN = isnan(x);\n  ${Cu}\n  return result;\n`}),ENe={kernelName:Bf,backendName:"webgl",kernelFunc:INe},DNe=Nt({opSnippet:"\n  float e2x = exp(x);\n  return (e2x - 1.0 / e2x) / 2.0;\n"}),TNe={kernelName:zf,backendName:"webgl",kernelFunc:DNe},NNe=Nt({opSnippet:"\n  float epsilon = 1.1920928955078125e-7;\n  float threshold = log(epsilon) + 2.0;\n\n  bool too_large = x > -threshold;\n  bool too_small = x < threshold;\n\n  float result;\n  float exp_x = exp(x);\n\n  if (too_large){\n    result = x;\n  }\n  else if (too_small){\n    result = exp_x;\n  }\n  else{\n    result = log(exp_x + 1.0);\n  }\n  return result;\n"}),kNe={kernelName:Gf,backendName:"webgl",kernelFunc:NNe},ANe={kernelName:cb,backendName:"webgl",kernelFunc:n=>{const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{blockShape:i,paddings:o}=s;S(r.shape.length<=4,()=>"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet");const a=i.reduce((y,b)=>y*b),l=[[0,0]];l.push(...o);for(let y=1+i.length;y<r.shape.length;++y)l.push([0,0]);const u=[],c=eW({inputs:{x:r},backend:e,attrs:{paddings:l,constantValue:0}}),d=yp(c.shape,i,a,!1),h=bp(d.length,i.length,!1),f=vp(c.shape,i,a,!1),p=be({inputs:{x:c},backend:e,attrs:{shape:d}}),g=Qs({inputs:{x:p},backend:e,attrs:{perm:h}}),m=be({inputs:{x:g},backend:e,attrs:{shape:f}});return u.push(c),u.push(p),u.push(g),u.forEach(y=>e.disposeIntermediateTensorInfo(y)),m}},MNe={kernelName:PS,backendName:"webgl",kernelFunc:function RNe(n){const{inputs:t,backend:e}=n,{indices:s,values:r,denseShape:i,defaultValue:o}=t;if(1!==i.shape.length)throw new Error(`Dense shape must be a vector, saw:\n         ${i.shape}`);if(2!==s.shape.length)throw new Error(`Indices must be a matrix, saw:\n         ${s.shape}`);if(1!==r.shape.length)throw new Error(`Values must be a vector, saw:\n         ${r.shape}`);if(0!==o.shape.length)throw new Error(`Default value must be a scalar, saw:\n        ${o.shape}`);const a=e.readSync(s.dataId),l=e.readSync(r.dataId),u=e.readSync(i.dataId),c=e.readSync(o.dataId)[0],[d,h,f,p,g]=u0e(a,s.shape,s.dtype,l,r.dtype,u,c);return[e.makeTensorInfo(h,s.dtype,d),e.makeTensorInfo([h[0]],r.dtype,f),e.makeTensorInfo([p.length],"bool",new Uint8Array(p.map(m=>Number(m)))),e.makeTensorInfo([g.length],s.dtype,new Int32Array(g))]}},ONe={kernelName:LS,backendName:"webgl",kernelFunc:function FNe(n){const{inputs:t,backend:e}=n,{inputIndices:s,inputShape:r,newShape:i}=t;if(2!==s.shape.length)throw new Error(`Input indices should be a matrix but received shape ${s.shape}`);if(1!==r.shape.length)throw new Error(`Input shape should be a vector but received shape ${r.shape}`);if(1!==i.shape.length)throw new Error(`Target shape should be a vector but received shape ${i.shape}`);const o=Array.from(e.readSync(r.dataId)),a=e.readSync(s.dataId),l=Array.from(e.readSync(i.dataId)),[u,c,d]=c0e(a,s.shape,s.dtype,o,l);return[e.makeTensorInfo(c,s.dtype,u),e.makeTensorInfo([d.length],i.dtype,new Int32Array(d))]}},PNe={kernelName:VS,backendName:"webgl",kernelFunc:function $Ne(n){const{inputs:t,backend:e}=n,{data:s,indices:r,segmentIds:i}=t;if(s.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==r.shape.length)throw new Error(`Indices should be a vector but received shape\n              ${r.shape}`);if(1!==i.shape.length)throw new Error(`Segment ids should be a vector but received shape\n              ${i.shape}`);const o=e.readSync(s.dataId),a=e.readSync(r.dataId),l=e.readSync(i.dataId),[u,c]=oU(o,s.shape,s.dtype,a,l,!0);return e.makeTensorInfo(c,s.dtype,u)}},VNe={kernelName:BS,backendName:"webgl",kernelFunc:function LNe(n){const{inputs:t,backend:e}=n,{data:s,indices:r,segmentIds:i}=t;if(s.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==r.shape.length)throw new Error(`Indices should be a vector but received shape\n             ${r.shape}`);if(1!==i.shape.length)throw new Error(`Segment ids should be a vector but received shape\n             ${i.shape}`);const o=e.readSync(s.dataId),a=e.readSync(r.dataId),l=e.readSync(i.dataId),[u,c]=oU(o,s.shape,s.dtype,a,l);return e.makeTensorInfo(c,s.dtype,u)}},zNe={kernelName:zS,backendName:"webgl",kernelFunc:function BNe(n){const{inputs:t,backend:e,attrs:s}=n,{sparseIndices:r,sparseValues:i,defaultValue:o}=t,{outputShape:a}=s,{sliceRank:l,numUpdates:u,sliceSize:c,strides:d,outputSize:h}=uu(0,r,a);if("string"===i.dtype){const y=e.bufferSync(r),b=e.bufferSync(i),v=La(e.readSync(o.dataId)[0]),_=o0e(y,b,a,h,c,u,l,d,v,!1);return e.makeTensorInfo(a,_.dtype,_.values)}const p=new MT(u,l,r.shape.length,i.shape.length,d,[h,1],!1),g=e.runWebGLProgram(p,[i,r,o],i.dtype),m=be({inputs:{x:g},backend:e,attrs:{shape:a}});return e.disposeIntermediateTensorInfo(g),m}},WNe={kernelName:db,backendName:"webgl",kernelFunc:function UNe(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{numOrSizeSplits:i,axis:o}=s,a=mt(o,r.shape)[0],l=qE(r,i,a),c=new Array(r.shape.length).fill(0),d=r.shape.slice();return l.map(h=>{const f=[...d];f[a]=h;const p=Dd({inputs:{x:r},backend:e,attrs:{begin:c,size:f}});return c[a]+=h,p})}},nW="return sqrt(x);",GNe=Nt({opSnippet:nW,packedOpSnippet:nW,cpuKernelImpl:d0e}),HNe={kernelName:Hf,backendName:"webgl",kernelFunc:GNe},qNe={kernelName:US,backendName:"webgl",kernelFunc:Nt({opSnippet:"return x * x;"})},sW="return (a - b) * (a - b);",KNe=As({opSnippet:sW,packedOpSnippet:sW}),XNe={kernelName:jf,backendName:"webgl",kernelFunc:KNe},ZNe={kernelName:fb,backendName:"webgl",kernelFunc:function YNe(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t;if("string"!==r.dtype)throw new Error("Input must be of datatype string");const o=da(e.readSync(r.dataId)),a=h0e(o,"string",s);return e.makeTensorInfo(r.shape,"string",a)}},JNe={kernelName:Zf,backendName:"webgl",kernelFunc:function QNe({inputs:n,attrs:t,backend:e}){const{x:s}=n,i=new Fo(s.shape,Jr+`\n    return x > 0.0 ? 1.0 : float(${t.alpha});\n  `);return e.runWebGLProgram(i,[s],s.dtype)}};class e1e{constructor(t,e,s){this.variableNames=["x"],this.outputShape=s;const r=s.length,i=Xt(s.length),o=Xt(s.length);let a="";if(1===r)a="coords * strides + begin";else{let l=0;a=s.map((u,c)=>(l++,1===s.length?`coords * strides[${c}] + begin[${c}]`:`coords[${l-1}] * strides[${c}] + begin[${c}]`)).join(",")}this.userCode=`\n      ${i} begin = ${i}(${t});\n      ${i} strides = ${i}(${e});\n\n      void main() {\n        ${o} coords = getOutputCoords();\n        setOutput(getX(${a}));\n      }\n    `}}const n1e={kernelName:WS,backendName:"webgl",kernelFunc:function t1e(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{begin:i,end:o,strides:a,beginMask:l,endMask:u,ellipsisMask:c,newAxisMask:d,shrinkAxisMask:h}=s,{finalShapeSparse:f,finalShape:p,isIdentity:g,sliceDim0:m,isSimpleSlice:y,begin:b,end:v,strides:_}=FI(r.shape,i,o,a,l,u,c,d,h);let x;if(g)x=be({inputs:{x:r},backend:e,attrs:{shape:p}});else if(m||y){S(r.shape.length>=1,()=>`Input must have rank at least 1, got: ${r.shape.length}`);const E=AI(b,v,_),D=Dd({inputs:{x:r},backend:e,attrs:{begin:b,size:E}});x=be({inputs:{x:D},backend:e,attrs:{shape:p}}),e.disposeIntermediateTensorInfo(D)}else if(e.shouldExecuteOnCPU([r])){const D=e.readSync(r.dataId),N=dt(r.shape,r.dtype,D),R=f0e(f,N,_,b);x=e.makeTensorInfo(p,r.dtype,R.values)}else{const D=new e1e(b,_,f);x=e.runWebGLProgram(D,[r],r.dtype)}const C=be({inputs:{x},backend:e,attrs:{shape:p}});return e.disposeIntermediateTensorInfo(x),C}},r1e={kernelName:GS,backendName:"webgl",kernelFunc:function s1e(n){const{inputs:t,backend:e,attrs:s}=n,{separator:r,nGramWidths:i,leftPad:o,rightPad:a,padWidth:l,preserveShortSequences:u}=s,{data:c,dataSplits:d}=t,h=e.readSync(c.dataId),f=e.readSync(d.dataId),[p,g]=p0e(h,f,r,i,o,a,l,u);return[e.makeTensorInfo([p.length],"string",p),e.makeTensorInfo(d.shape,"int32",g)]}},o1e={kernelName:HS,backendName:"webgl",kernelFunc:function i1e(n){const{inputs:t,backend:e,attrs:s}=n,{skipEmpty:r}=s,{input:i,delimiter:o}=t;if("string"!==i.dtype)throw new Error("Input must be of datatype string");if(1!==i.shape.length)throw new Error(`Input must be a vector, got shape: ${i.shape}`);if(0!==o.shape.length)throw new Error(`Delimiter must be a scalar, got shape: ${o.shape}`);const a=e.readSync(i.dataId),l=e.readSync(o.dataId)[0],[u,c,d]=m0e(a,l,r),h=c.length;return[e.makeTensorInfo([h,2],"int32",u),e.makeTensorInfo([h],"string",c),e.makeTensorInfo([2],"int32",new Int32Array(d))]}},l1e={kernelName:jS,backendName:"webgl",kernelFunc:function a1e(n){const{inputs:t,backend:e,attrs:s}=n,{numBuckets:r}=s,{input:i}=t;if("string"!==i.dtype)throw new Error("Input must be of datatype string");if(r<=0)throw new Error("Number of buckets must be at least 1");const o=e.readSync(i.dataId),a=g0e(o,r);return e.makeTensorInfo(i.shape,"int32",a)}},u1e=Nt({opSnippet:"return tan(x);"}),c1e={kernelName:Kf,backendName:"webgl",kernelFunc:u1e},d1e=Nt({opSnippet:"\n  float e2x = exp(-2.0 * abs(x));\n  return sign(x) * (1.0 - e2x) / (1.0 + e2x);\n"}),h1e={kernelName:Xf,backendName:"webgl",kernelFunc:d1e},p1e={kernelName:OS,backendName:"webgl",kernelFunc:function f1e(n){const{inputs:t,backend:e}=n,{tensor:r,indices:i,updates:o}=t,{sliceRank:a,numUpdates:l,sliceSize:u,strides:c,outputSize:d}=uu(0,i,r.shape),h=[d/u,u];if(0===d)return e.makeTensorInfo(r.shape,i.dtype);const f=be({inputs:{x:i},backend:e,attrs:{shape:[l,a]}}),p=be({inputs:{x:o},backend:e,attrs:{shape:[l,u]}}),g=be({inputs:{x:r},backend:e,attrs:{shape:h}}),m=new MT(l,a,f.shape.length,p.shape.length,c,h,!1,!0),y=e.runWebGLProgram(m,[p,f,g],g.dtype),b=be({inputs:{x:y},backend:e,attrs:{shape:r.shape}});return e.disposeIntermediateTensorInfo(f),e.disposeIntermediateTensorInfo(p),e.disposeIntermediateTensorInfo(g),e.disposeIntermediateTensorInfo(y),b}};class m1e{constructor(t,e){this.variableNames=["A"];const s=new Array(t.length);for(let o=0;o<s.length;o++)s[o]=t[o]*e[o];this.outputShape=s,this.rank=s.length;const r=Xt(this.rank),i=function g1e(n){const t=n.length;if(t>5)throw Error(`Tile for rank ${t} is not yet supported`);if(1===t)return`imod(resRC, ${n[0]})`;const e=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"],s=[];for(let r=0;r<n.length;r++)s.push(`imod(${e[r]}, ${n[r]})`);return s.join()}(t);this.userCode=`\n      void main() {\n        ${r} resRC = getOutputCoords();\n        setOutput(getA(${i}));\n      }\n    `}}function rW(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{reps:i}=s;if("string"===r.dtype||r.shape.length>5){const l=e.readSync(r.dataId),u="string"===r.dtype?l.map(h=>La(h)):l,c=dt(r.shape,r.dtype,u),d=b0e(c,i);return e.makeTensorInfo(d.shape,d.dtype,d.values)}const o=new m1e(r.shape,i);return e.runWebGLProgram(o,[r],r.dtype)}const y1e={kernelName:Yf,backendName:"webgl",kernelFunc:rW};class b1e{constructor(t){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"negativeInf",type:"float"},{name:"dir",type:"int"},{name:"inc",type:"int"}],this.outputShape=t,this.userCode="\n       void main() {\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int elemIdx = coords[1];\n\n         // We compare elements pair-wise within a group of size 2 * inc.\n         // The comparing rule for each group alternates between ascending\n         // and descending. Within each group, we compare each pair at\n         // positions i and i+inc. To decide whether an element at position i\n         // is x0 or x1, we mod it by 2 * inc, if the result is smaller than\n         // inc, it is in the first half of the group, we denote it as x0,\n         // otherwise we denote it as x1.\n         // For example, as shown in the Bitonic top K paper referenced above,\n         // Figure5(a) shows that element[1] is in the\n         // second half of the group when group size is 2, but it is in the\n         // first half of the group when group size is 4.\n\n         bool isFirstInPair = imod(elemIdx, 2 * inc) < inc;\n         int i = isFirstInPair ? elemIdx : elemIdx - inc;\n\n         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));\n         int i1 = firstPass == 1 ? i + inc : int(getIndices(batch, i + inc));\n         float x0 = i0 < n ? getX(batch, i0) : negativeInf;\n         float x1 = i1 < n ? getX(batch, i1) : negativeInf;\n\n         // Denotes which direction indices are in (ascending or descending).\n         bool reverse = imod(elemIdx, 2 * dir) >= dir;\n         bool isGreater = x0 > x1 || (x0 == x1 && i1 > i0);\n         if (reverse == isGreater) { // Elements in opposite order of direction\n           int iTemp = i0;\n           i0 = i1;\n           i1 = iTemp;\n         }\n         if (isFirstInPair) {\n            setOutput(float(i0));\n         } else {\n            setOutput(float(i1));\n         }\n       }\n     "}}class v1e{constructor(t){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"k",type:"int"}],this.outputShape=t,this.userCode="\n    void main() {\n         // Takes max of indices (0, k), (1, k + 1), (2, k + 2) ...\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int elemIdx = coords[1];\n\n         // The output size is half of the previous size.\n         // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _ (k=4),\n         // we only need to output the indices at positions |, the indices at\n         // positions _ can be thrown away, see Figure5(b) After Phase 2\n         // (Merge phase) in the Bitonic Top K paper referenced above.\n         // For example, the paper shows we only need to output the orange bars.\n         // The output sequence should look like this | | | | | | | |.\n         // Because the sequence is halved, to map the output index back\n         // to the previous sequence to find the corresponding value,\n         // we need to double the index. When we double the index,\n         // we basically interpolate a position, so 2i looks like\n         // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k position\n         // of each 2k positions by - elemIdx % k. E.g. for output at\n         // index 4,5,6,7, we want to get the corresponding element at\n         // original index 8,9,10,11, for output at index 8,9,10,11,\n         // we want to get the corresponding element at original index\n         // 16,17,18,19, so on and so forth.\n\n         int i = elemIdx < k ? elemIdx : (elemIdx * 2 - imod(elemIdx, k));\n         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));\n         int i1 = firstPass == 1 ? i + k : int(getIndices(batch, i + k));\n\n         float x0 = getX(batch, i0);\n         float x1 = i1 < n ? getX(batch, i1) : x0;\n\n         setOutput(x0 >= x1 ? float(i0) : float(i1));\n       }\n     "}}function Iu(n,t){null!==t&&n.disposeIntermediateTensorInfo(t)}function iW(n){let t=1;for(;t<n;)t*=2;return t}const w1e={kernelName:qS,backendName:"webgl",kernelFunc:function _1e(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{k:i,sorted:o}=s,a=W().getNumber("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD"),l=W().getNumber("TOPK_K_CPU_HANDOFF_THRESHOLD"),u=r.shape,c=u[u.length-1];if(e.shouldExecuteOnCPU([r])||c<a||i>l){const R=e.readSync(r.dataId),[V,G]=v0e(R,u,r.dtype,i,o);return[e.makeTensorInfo(V.shape,V.dtype,V.values),e.makeTensorInfo(G.shape,G.dtype,G.values)]}if(0===i)return u[u.length-1]=0,[e.makeTensorInfo(u,r.dtype,[]),e.makeTensorInfo(u,"int32",[])];if(1===c)return[r,jp({attrs:{shape:u,dtype:"int32",value:0},backend:e})];const d=e.texData.get(r.dataId),h=null!==d&&d.isPacked,f=h?e.unpackTensor(r):r,g=X(u)/c,m=be({inputs:{x:f},attrs:{shape:[g,c]},backend:e});h&&Iu(e,f);const y=iW(i),b=iW(c);let v=null;const _=()=>null===v?[m,m]:[m,v],x=(R,V,G)=>{const j=_(),q=new b1e(G),B=v;v=e.runWebGLProgram(q,j,"int32",[[c],[null===v?1:0],[Number.NEGATIVE_INFINITY],[R],[V]]),Iu(e,B)};for(let R=1;R<y;R*=2){const V=2*R;for(let G=R;G>=1;G/=2)x(V,G,[g,b])}for(let R=b;R>y;R/=2){const V=_(),G=new v1e([g,R/2]),K=v;v=e.runWebGLProgram(G,V,"int32",[[c],[null===v?1:0],[y]]),Iu(e,K);const P=y/2,B=2*P;for(let L=P;L>=1;L/=2)x(B,L,v.shape)}let C=v;v=Dd({inputs:{x:v},backend:e,attrs:{begin:0,size:[g,i]}}),Iu(e,C);let E=qU({inputs:{x:m,indices:v},backend:e,attrs:{axis:1,batchDims:1}});Iu(e,m);const D=u.slice(0,-1);D.push(i),C=v,v=be({inputs:{x:v},attrs:{shape:D},backend:e}),Iu(e,C);const N=E;return E=be({inputs:{x:E},attrs:{shape:D},backend:e}),Iu(e,N),[E,v]}};class x1e{constructor(t,e,s,r,i,o){this.variableNames=["Image","Transforms"],this.outputShape=o;const a="nearest"===s?1:2;let l;switch(r){case"constant":default:l=1;break;case"reflect":l=2;break;case"wrap":l=3;break;case"nearest":l=4}this.userCode=`\n            float mapCoord(float outCoord, float len) {\n              float inCoord = outCoord;\n              if(${l} == 2) {\n                if (inCoord < 0.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz2 = 2.0 * len;\n                    if (inCoord < sz2) {\n                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +\n                      inCoord;\n                    }\n                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;\n                  }\n                } else if (inCoord > len - 1.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz2 = 2.0 * len;\n                    inCoord -= sz2 * float(int(float(inCoord / sz2)));\n                    if (inCoord >= len) {\n                      inCoord = sz2 - inCoord - 1.0;\n                    }\n                  }\n                }\n                return clamp(inCoord, 0.0, len - 1.0);\n              } else if (${l} == 3) {\n                if (inCoord < 0.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz = len - 1.0;\n                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);\n                  }\n                } else if (inCoord > len - 1.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz = len - 1.0;\n                    inCoord -= len * float(int(float(inCoord / sz)));\n                  }\n                }\n                return clamp(inCoord, 0.0, len - 1.0);\n              } else if (${l} == 4) {\n                return clamp(outCoord, 0.0, len - 1.0);\n              } else {\n                return outCoord;\n              }\n            }\n\n            float readWithFillValue(int batch, int coordY, int coordX,\n              int channel) {\n              float outputValue;\n              if (0 <= coordY && coordY < ${t} && 0 <= coordX && coordX < ${e}) {\n                  outputValue = getImage(batch, coordY, coordX, channel);\n              } else {\n                outputValue = float(${i});\n              }\n              return outputValue;\n            }\n\n            void main() {\n              ivec4 coords = getOutputCoords();\n              float outputValue;\n              int batch = coords[0];\n              int x = coords[2];\n              int y = coords[1];\n              int channel = coords[3];\n              float xf = float(x);\n              float yf = float(y);\n              float a1 = getTransforms(batch, 0);\n              float a2 = getTransforms(batch, 1);\n              float a3 = getTransforms(batch, 2);\n              float b1 = getTransforms(batch, 3);\n              float b2 = getTransforms(batch, 4);\n              float b3 = getTransforms(batch, 5);\n              float c1 = getTransforms(batch, 6);\n              float c2 = getTransforms(batch, 7);\n              float projection = c1 * xf + c2 * yf + 1.0;\n              if (projection == 0.0) {\n                outputValue = float(${i});\n              } else {\n                float inX = (a1 * xf + a2 * yf + a3) / projection;\n                float inY = (b1 * xf + b2 * yf + b3) / projection;\n                float mapX = mapCoord(inX, float(${e}));\n                float mapY = mapCoord(inY, float(${t}));\n\n                if (${a} == 1) {\n                  int coordY = int(round(mapY));\n                  int coordX = int(round(mapX));\n                  outputValue = readWithFillValue(batch, coordY, coordX,\n                    channel);\n                } else {\n                  float yFloor = floor(mapY);\n                  float xFloor = floor(mapX);\n                  float yCeil = yFloor + 1.0;\n                  float xCeil = xFloor + 1.0;\n                  float valueYFloor = (xCeil - mapX) *\n                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);\n                  float valueYCeil = (xCeil - mapX) *\n                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);\n                  outputValue = (yCeil - mapY) * valueYFloor +\n                  (mapY - yFloor) * valueYCeil;\n                }\n              }\n              setOutput(outputValue);\n            }\n        `}}const S1e={kernelName:KS,backendName:"webgl",kernelFunc:function C1e(n){const{inputs:t,backend:e,attrs:s}=n,{image:r,transforms:i}=t,{interpolation:o,fillMode:a,fillValue:l,outputShape:u}=s,[c,d,h,f]=r.shape,[p,g]=u??[d,h],y=new x1e(d,h,o,a,l,[c,p,g,f]);return e.runWebGLProgram(y,[r,i],"float32")}},E1e={kernelName:XS,backendName:"webgl",kernelFunc:function I1e(n){const{inputs:t,attrs:e,backend:s}=n,{axis:r}=e,{x:i}=t;Vp(i,"unique"),console.warn("WARNING: ","UI might be locked temporarily as data is being downloaded");const o=s.readSync(i.dataId),{outputValues:a,outputShape:l,indices:u}=_0e(o,r,i.shape,i.dtype);return[s.makeTensorInfo(l,i.dtype,a),s.makeTensorInfo([u.length],"int32",u)]}},T1e={kernelName:pb,backendName:"webgl",kernelFunc:function D1e(n){const{inputs:t,backend:e,attrs:s}=n,{value:r}=t;let{axis:i}=s;i<0&&(i+=r.shape.length);const o=r,a=o.shape.length,l=r.shape[i],u=new Array(a-1);let c=0;for(let g=0;g<a;g++)g!==i&&(u[c++]=o.shape[g]);const d=[],h=new Array(a).fill(0),f=o.shape.slice();f[i]=1;const p=new Array(l);for(let g=0;g<p.length;g++){h[i]=g;const m=Dd({inputs:{x:o},backend:e,attrs:{begin:h,size:f}}),y=be({inputs:{x:m},backend:e,attrs:{shape:u}});p[g]=y,d.push(m)}return d.forEach(g=>e.disposeIntermediateTensorInfo(g)),p}};class N1e{constructor(t,e){this.variableNames=["x","segmentIds"];const s=t.windowSize,r=t.batchSize,i=t.inSize,o=t.numSegments,a=o*Math.ceil(i/s);this.outputShape=[r,a];const c=4*Math.floor(s/4),d=s%4,h="\n        sumValue += dot(values, segFilter);\n    ";let f="";i%s>0&&(f=`\n        if (inIdx < 0 || inIdx >= ${i}) {\n          return initializationValue;\n        }\n      `);let p="";i%s>0&&(p=`\n        if (inIdx < 0 || inIdx >= ${i}) {\n          return -1.0;\n        }\n      `),this.userCode=`\n      const float initializationValue = 0.0;\n\n      float getValue(int batch, int inIdx) {\n        ${f}\n        return getX(batch, inIdx);\n      }\n\n      float getSegmentIdAtIndex(int inIdx) {\n        ${p}\n        return getSegmentIds(inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = int(floor(float(outIdx) / float(\n          ${o})) * float(${s}));\n        int currentSeg = int(mod(float(outIdx), float(${o})));\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ${c}; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0\n          );\n\n          ${h}\n        }\n\n        int inIdx = inOffset + ${c};\n        if (${1===d}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            0,\n            0,\n            0\n          );\n\n          ${h}\n        } else if (${2===d}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n              0,\n              0\n          );\n\n          ${h}\n        } else if (${3===d}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            0\n          );\n\n          ${h}\n        }\n        setOutput(sumValue);\n      }\n    `}}const R1e=[pCe,gCe,vCe,xCe,SCe,DCe,NCe,ACe,OCe,PCe,BCe,WCe,jCe,YCe,JCe,tSe,sSe,aSe,uSe,dSe,pSe,_Se,xSe,SSe,NSe,ASe,OSe,Z0e,LSe,WSe,qSe,JSe,nIe,rIe,oIe,lIe,hIe,pIe,gIe,bIe,_Ie,xIe,IIe,DIe,AIe,MIe,$Ie,VIe,zIe,WIe,jIe,KIe,ZIe,JIe,eEe,nEe,rEe,oEe,lEe,cEe,hEe,mEe,bEe,_Ee,CEe,EEe,TEe,kEe,Y0e,REe,zSe,FEe,$Ee,LEe,J0e,BEe,UEe,GEe,qEe,YEe,QEe,eDe,nDe,iDe,aDe,uDe,fDe,mDe,yDe,wDe,CDe,IDe,DDe,NDe,MDe,$De,BDe,jDe,nCe,YDe,JDe,nTe,iTe,ISe,aTe,uTe,dTe,pTe,bTe,tCe,_Te,xTe,STe,ETe,DTe,ESe,UDe,NTe,RTe,OTe,rCe,VTe,UTe,jTe,XTe,JTe,tNe,sNe,iNe,lNe,dNe,pNe,yNe,_Ne,xNe,ENe,TNe,vSe,GDe,kNe,ANe,MNe,ONe,PNe,VNe,zNe,WNe,HNe,qNe,XNe,ZNe,JNe,n1e,r1e,o1e,l1e,WDe,dCe,c1e,h1e,p1e,y1e,w1e,S1e,hCe,E1e,T1e,{kernelName:mb,backendName:"webgl",kernelFunc:function k1e(n){const{inputs:t,backend:e,attrs:s}=n,{x:r,segmentIds:i}=t,{numSegments:o}=s,a=r.shape.length,l=[];let u=0;const c=vn([u],a);let d=r;null!=c&&(d=Qs({inputs:{x:r},backend:e,attrs:{perm:c}}),l.push(d),u=$n(1,a)[0]);const h=xV(d.shape,u,o),f=X([d.shape[u]]),p=be({inputs:{x:d},backend:e,attrs:{shape:[-1,f]}});l.push(p);const g=nI(r.dtype),m=(_,x,C,E,D)=>{const N=_.shape[0],R=_.shape[1],V=wV(R,D),j=new N1e({windowSize:V,inSize:R,batchSize:N,numSegments:D},x),q=e.compileAndRun(j,[_,C],E);if(l.push(q),q.shape[1]===D)return q;const K=tW({backend:e,attrs:{start:0,stop:D,step:1,dtype:"float32"}}),P=rW({inputs:{x:K},backend:e,attrs:{reps:[R/V]}});return l.push(K),l.push(P),m(q,x,P,E,D)},b=be({inputs:{x:m(p,"unsortedSegmentSum",i,g,o)},backend:e,attrs:{shape:h}});let v=b;if(null!=c){l.push(b);const _=Qa(c);v=Qs({inputs:{x:v},backend:e,attrs:{perm:_}})}return l.forEach(_=>e.disposeIntermediateTensorInfo(_)),v}},lTe];for(const n of R1e)QS(n);const F1e=new we("cdk-dir-doc",{providedIn:"root",factory:function O1e(){return Fe(Es)}}),$1e=/^(ar|ckb|dv|he|iw|fa|nqo|ps|sd|ug|ur|yi|.*[-_](Adlm|Arab|Hebr|Nkoo|Rohg|Thaa))(?!.*[-_](Latn|Cyrl)($|-|_))($|-|_)/i;let FT,L1e=(()=>{class n{constructor(e){this.value="ltr",this.change=new un,e&&(this.value=function P1e(n){const t=n?.toLowerCase()||"";return"auto"===t&&typeof navigator<"u"&&navigator?.language?$1e.test(navigator.language)?"rtl":"ltr":"rtl"===t?"rtl":"ltr"}((e.body?e.body.dir:null)||(e.documentElement?e.documentElement.dir:null)||"ltr"))}ngOnDestroy(){this.change.complete()}}return n.\u0275fac=function(e){return new(e||n)(Se(F1e,8))},n.\u0275prov=Ve({token:n,factory:n.\u0275fac,providedIn:"root"}),n})(),oW=(()=>{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275mod=Or({type:n}),n.\u0275inj=fr({}),n})();function Nd(n){return null!=n&&"false"!=`${n}`}function Zi(n,t=0){return function V1e(n){return!isNaN(parseFloat(n))&&!isNaN(Number(n))}(n)?Number(n):t}function aW(n){return Array.isArray(n)?n:[n]}function lW(n){return n instanceof ps?n.nativeElement:n}try{FT=typeof Intl<"u"&&Intl.v8BreakIterator}catch{FT=!1}let qp,a_=(()=>{class n{constructor(e){this._platformId=e,this.isBrowser=this._platformId?function HY(n){return n===jO}(this._platformId):"object"==typeof document&&!!document,this.EDGE=this.isBrowser&&/(edge)/i.test(navigator.userAgent),this.TRIDENT=this.isBrowser&&/(msie|trident)/i.test(navigator.userAgent),this.BLINK=this.isBrowser&&!(!window.chrome&&!FT)&&typeof CSS<"u"&&!this.EDGE&&!this.TRIDENT,this.WEBKIT=this.isBrowser&&/AppleWebKit/i.test(navigator.userAgent)&&!this.BLINK&&!this.EDGE&&!this.TRIDENT,this.IOS=this.isBrowser&&/iPad|iPhone|iPod/.test(navigator.userAgent)&&!("MSStream"in window),this.FIREFOX=this.isBrowser&&/(firefox|minefield)/i.test(navigator.userAgent),this.ANDROID=this.isBrowser&&/android/i.test(navigator.userAgent)&&!this.TRIDENT,this.SAFARI=this.isBrowser&&/safari/i.test(navigator.userAgent)&&this.WEBKIT}}return n.\u0275fac=function(e){return new(e||n)(Se(nc))},n.\u0275prov=Ve({token:n,factory:n.\u0275fac,providedIn:"root"}),n})();function l_(n){return function B1e(){if(null==qp&&typeof window<"u")try{window.addEventListener("test",null,Object.defineProperty({},"passive",{get:()=>qp=!0}))}finally{qp=qp||!1}return qp}()?n:!!n.capture}class Y1e extends ut{constructor(t,e){super()}schedule(t,e=0){return this}}const c_={setInterval(n,t,...e){const{delegate:s}=c_;return s?.setInterval?s.setInterval(n,t,...e):setInterval(n,t,...e)},clearInterval(n){const{delegate:t}=c_;return(t?.clearInterval||clearInterval)(n)},delegate:void 0},cW={now:()=>(cW.delegate||Date).now(),delegate:void 0};class Kp{constructor(t,e=Kp.now){this.schedulerActionCtor=t,this.now=e}schedule(t,e=0,s){return new this.schedulerActionCtor(this,t).schedule(s,e)}}Kp.now=cW.now;const J1e=new class Q1e extends Kp{constructor(t,e=Kp.now){super(t,e),this.actions=[],this._active=!1}flush(t){const{actions:e}=this;if(this._active)return void e.push(t);let s;this._active=!0;do{if(s=t.execute(t.state,t.delay))break}while(t=e.shift());if(this._active=!1,s){for(;t=e.shift();)t.unsubscribe();throw s}}}(class Z1e extends Y1e{constructor(t,e){super(t,e),this.scheduler=t,this.work=e,this.pending=!1}schedule(t,e=0){var s;if(this.closed)return this;this.state=t;const r=this.id,i=this.scheduler;return null!=r&&(this.id=this.recycleAsyncId(i,r,e)),this.pending=!0,this.delay=e,this.id=null!==(s=this.id)&&void 0!==s?s:this.requestAsyncId(i,this.id,e),this}requestAsyncId(t,e,s=0){return c_.setInterval(t.flush.bind(t,this),s)}recycleAsyncId(t,e,s=0){if(null!=s&&this.delay===s&&!1===this.pending)return e;null!=e&&c_.clearInterval(e)}execute(t,e){if(this.closed)return new Error("executing a cancelled action");this.pending=!1;const s=this._execute(t,e);if(s)return s;!1===this.pending&&null!=this.id&&(this.id=this.recycleAsyncId(this.scheduler,this.id,null))}_execute(t,e){let r,s=!1;try{this.work(t)}catch(i){s=!0,r=i||new Error("Scheduled action threw falsy error")}if(s)return this.unsubscribe(),r}unsubscribe(){if(!this.closed){const{id:t,scheduler:e}=this,{actions:s}=e;this.work=this.state=this.scheduler=null,this.pending=!1,ft(s,this),null!=t&&(this.id=this.recycleAsyncId(e,t,null)),this.delay=null,super.unsubscribe()}}});function tke(n){return ds((t,e)=>{Mr(n).subscribe(Xn(e,()=>e.complete(),Fs)),!e.closed&&t.subscribe(e)})}const dW=new Set;let Du,nke=(()=>{class n{constructor(e,s){this._platform=e,this._nonce=s,this._matchMedia=this._platform.isBrowser&&window.matchMedia?window.matchMedia.bind(window):rke}matchMedia(e){return(this._platform.WEBKIT||this._platform.BLINK)&&function ske(n,t){if(!dW.has(n))try{Du||(Du=document.createElement("style"),t&&(Du.nonce=t),Du.setAttribute("type","text/css"),document.head.appendChild(Du)),Du.sheet&&(Du.sheet.insertRule(`@media ${n} {body{ }}`,0),dW.add(n))}catch(e){console.error(e)}}(e,this._nonce),this._matchMedia(e)}}return n.\u0275fac=function(e){return new(e||n)(Se(a_),Se(ax,8))},n.\u0275prov=Ve({token:n,factory:n.\u0275fac,providedIn:"root"}),n})();function rke(n){return{matches:"all"===n||""===n,media:n,addListener:()=>{},removeListener:()=>{}}}let ike=(()=>{class n{constructor(e,s){this._mediaMatcher=e,this._zone=s,this._queries=new Map,this._destroySubject=new Ti}ngOnDestroy(){this._destroySubject.next(),this._destroySubject.complete()}isMatched(e){return hW(aW(e)).some(r=>this._registerQuery(r).mql.matches)}observe(e){let i=Xg(hW(aW(e)).map(o=>this._registerQuery(o).observable));return i=Zg(i.pipe(Gl(1)),i.pipe(function X1e(n){return ta((t,e)=>n<=e)}(1),function eke(n,t=J1e){return ds((e,s)=>{let r=null,i=null,o=null;const a=()=>{if(r){r.unsubscribe(),r=null;const u=i;i=null,s.next(u)}};function l(){const u=o+n,c=t.now();if(c<u)return r=this.schedule(void 0,u-c),void s.add(r);a()}e.subscribe(Xn(s,u=>{i=u,o=t.now(),r||(r=t.schedule(l,n),s.add(r))},()=>{a(),s.complete()},void 0,()=>{i=r=null}))})}(0))),i.pipe(Ht(o=>{const a={matches:!1,breakpoints:{}};return o.forEach(({matches:l,query:u})=>{a.matches=a.matches||l,a.breakpoints[u]=l}),a}))}_registerQuery(e){if(this._queries.has(e))return this._queries.get(e);const s=this._mediaMatcher.matchMedia(e),i={observable:new Wn(o=>{const a=l=>this._zone.run(()=>o.next(l));return s.addListener(a),()=>{s.removeListener(a)}}).pipe(x$(s),Ht(({matches:o})=>({query:e,matches:o})),tke(this._destroySubject)),mql:s};return this._queries.set(e,i),i}}return n.\u0275fac=function(e){return new(e||n)(Se(nke),Se(Pt))},n.\u0275prov=Ve({token:n,factory:n.\u0275fac,providedIn:"root"}),n})();function hW(n){return n.map(t=>t.split(",")).reduce((t,e)=>t.concat(e)).map(t=>t.trim())}const gW="cdk-high-contrast-black-on-white",yW="cdk-high-contrast-white-on-black",$T="cdk-high-contrast-active";let gke=(()=>{class n{constructor(e,s){this._platform=e,this._document=s,this._breakpointSubscription=Fe(ike).observe("(forced-colors: active)").subscribe(()=>{this._hasCheckedHighContrastMode&&(this._hasCheckedHighContrastMode=!1,this._applyBodyHighContrastModeCssClasses())})}getHighContrastMode(){if(!this._platform.isBrowser)return 0;const e=this._document.createElement("div");e.style.backgroundColor="rgb(1,2,3)",e.style.position="absolute",this._document.body.appendChild(e);const s=this._document.defaultView||window,r=s&&s.getComputedStyle?s.getComputedStyle(e):null,i=(r&&r.backgroundColor||"").replace(/ /g,"");switch(e.remove(),i){case"rgb(0,0,0)":case"rgb(45,50,54)":case"rgb(32,32,32)":return 2;case"rgb(255,255,255)":case"rgb(255,250,239)":return 1}return 0}ngOnDestroy(){this._breakpointSubscription.unsubscribe()}_applyBodyHighContrastModeCssClasses(){if(!this._hasCheckedHighContrastMode&&this._platform.isBrowser&&this._document.body){const e=this._document.body.classList;e.remove($T,gW,yW),this._hasCheckedHighContrastMode=!0;const s=this.getHighContrastMode();1===s?e.add($T,gW):2===s&&e.add($T,yW)}}}return n.\u0275fac=function(e){return new(e||n)(Se(a_),Se(Es))},n.\u0275prov=Ve({token:n,factory:n.\u0275fac,providedIn:"root"}),n})();const bke=new we("mat-sanity-checks",{providedIn:"root",factory:function yke(){return!0}});let PT=(()=>{class n{constructor(e,s,r){this._sanityChecks=s,this._document=r,this._hasDoneGlobalChecks=!1,e._applyBodyHighContrastModeCssClasses(),this._hasDoneGlobalChecks||(this._hasDoneGlobalChecks=!0)}_checkIsEnabled(e){return!function W1e(){return typeof __karma__<"u"&&!!__karma__||typeof jasmine<"u"&&!!jasmine||typeof jest<"u"&&!!jest||typeof Mocha<"u"&&!!Mocha}()&&("boolean"==typeof this._sanityChecks?this._sanityChecks:!!this._sanityChecks[e])}}return n.\u0275fac=function(e){return new(e||n)(Se(gke),Se(bke,8),Se(Es))},n.\u0275mod=Or({type:n}),n.\u0275inj=fr({imports:[oW,oW]}),n})();function vke(n,t){return class extends n{get color(){return this._color}set color(e){const s=e||this.defaultColor;s!==this._color&&(this._color&&this._elementRef.nativeElement.classList.remove(`mat-${this._color}`),s&&this._elementRef.nativeElement.classList.add(`mat-${s}`),this._color=s)}constructor(...e){super(...e),this.defaultColor=t,this.color=t}}}function _ke(n){return class extends n{get disableRipple(){return this._disableRipple}set disableRipple(t){this._disableRipple=Nd(t)}constructor(...t){super(...t),this._disableRipple=!1}}}class xke{constructor(t,e,s,r=!1){this._renderer=t,this.element=e,this.config=s,this._animationForciblyDisabledThroughCss=r,this.state=3}fadeOut(){this._renderer.fadeOutRipple(this)}}const _W=l_({passive:!0,capture:!0});class Cke{constructor(){this._events=new Map,this._delegateEventHandler=t=>{const e=function U1e(n){return n.composedPath?n.composedPath()[0]:n.target}(t);e&&this._events.get(t.type)?.forEach((s,r)=>{(r===e||r.contains(e))&&s.forEach(i=>i.handleEvent(t))})}}addHandler(t,e,s,r){const i=this._events.get(e);if(i){const o=i.get(s);o?o.add(r):i.set(s,new Set([r]))}else this._events.set(e,new Map([[s,new Set([r])]])),t.runOutsideAngular(()=>{document.addEventListener(e,this._delegateEventHandler,_W)})}removeHandler(t,e,s){const r=this._events.get(t);if(!r)return;const i=r.get(e);i&&(i.delete(s),0===i.size&&r.delete(e),0===r.size&&(this._events.delete(t),document.removeEventListener(t,this._delegateEventHandler,_W)))}}const wW={enterDuration:225,exitDuration:150},xW=l_({passive:!0,capture:!0}),CW=["mousedown","touchstart"],SW=["mouseup","mouseleave","touchend","touchcancel"];class Yp{constructor(t,e,s,r){this._target=t,this._ngZone=e,this._platform=r,this._isPointerDown=!1,this._activeRipples=new Map,this._pointerUpEventsRegistered=!1,r.isBrowser&&(this._containerElement=lW(s))}fadeInRipple(t,e,s={}){const r=this._containerRect=this._containerRect||this._containerElement.getBoundingClientRect(),i={...wW,...s.animation};s.centered&&(t=r.left+r.width/2,e=r.top+r.height/2);const o=s.radius||function Ike(n,t,e){const s=Math.max(Math.abs(n-e.left),Math.abs(n-e.right)),r=Math.max(Math.abs(t-e.top),Math.abs(t-e.bottom));return Math.sqrt(s*s+r*r)}(t,e,r),a=t-r.left,l=e-r.top,u=i.enterDuration,c=document.createElement("div");c.classList.add("mat-ripple-element"),c.style.left=a-o+"px",c.style.top=l-o+"px",c.style.height=2*o+"px",c.style.width=2*o+"px",null!=s.color&&(c.style.backgroundColor=s.color),c.style.transitionDuration=`${u}ms`,this._containerElement.appendChild(c);const d=window.getComputedStyle(c),f=d.transitionDuration,p="none"===d.transitionProperty||"0s"===f||"0s, 0s"===f||0===r.width&&0===r.height,g=new xke(this,c,s,p);c.style.transform="scale3d(1, 1, 1)",g.state=0,s.persistent||(this._mostRecentTransientRipple=g);let m=null;return!p&&(u||i.exitDuration)&&this._ngZone.runOutsideAngular(()=>{const y=()=>this._finishRippleTransition(g),b=()=>this._destroyRipple(g);c.addEventListener("transitionend",y),c.addEventListener("transitioncancel",b),m={onTransitionEnd:y,onTransitionCancel:b}}),this._activeRipples.set(g,m),(p||!u)&&this._finishRippleTransition(g),g}fadeOutRipple(t){if(2===t.state||3===t.state)return;const e=t.element,s={...wW,...t.config.animation};e.style.transitionDuration=`${s.exitDuration}ms`,e.style.opacity="0",t.state=2,(t._animationForciblyDisabledThroughCss||!s.exitDuration)&&this._finishRippleTransition(t)}fadeOutAll(){this._getActiveRipples().forEach(t=>t.fadeOut())}fadeOutAllNonPersistent(){this._getActiveRipples().forEach(t=>{t.config.persistent||t.fadeOut()})}setupTriggerEvents(t){const e=lW(t);!this._platform.isBrowser||!e||e===this._triggerElement||(this._removeTriggerEvents(),this._triggerElement=e,CW.forEach(s=>{Yp._eventManager.addHandler(this._ngZone,s,e,this)}))}handleEvent(t){"mousedown"===t.type?this._onMousedown(t):"touchstart"===t.type?this._onTouchStart(t):this._onPointerUp(),this._pointerUpEventsRegistered||(this._ngZone.runOutsideAngular(()=>{SW.forEach(e=>{this._triggerElement.addEventListener(e,this,xW)})}),this._pointerUpEventsRegistered=!0)}_finishRippleTransition(t){0===t.state?this._startFadeOutTransition(t):2===t.state&&this._destroyRipple(t)}_startFadeOutTransition(t){const e=t===this._mostRecentTransientRipple,{persistent:s}=t.config;t.state=1,!s&&(!e||!this._isPointerDown)&&t.fadeOut()}_destroyRipple(t){const e=this._activeRipples.get(t)??null;this._activeRipples.delete(t),this._activeRipples.size||(this._containerRect=null),t===this._mostRecentTransientRipple&&(this._mostRecentTransientRipple=null),t.state=3,null!==e&&(t.element.removeEventListener("transitionend",e.onTransitionEnd),t.element.removeEventListener("transitioncancel",e.onTransitionCancel)),t.element.remove()}_onMousedown(t){const e=function fke(n){return 0===n.buttons||0===n.offsetX&&0===n.offsetY}(t),s=this._lastTouchStartEvent&&Date.now()<this._lastTouchStartEvent+800;!this._target.rippleDisabled&&!e&&!s&&(this._isPointerDown=!0,this.fadeInRipple(t.clientX,t.clientY,this._target.rippleConfig))}_onTouchStart(t){if(!this._target.rippleDisabled&&!function pke(n){const t=n.touches&&n.touches[0]||n.changedTouches&&n.changedTouches[0];return!(!t||-1!==t.identifier||null!=t.radiusX&&1!==t.radiusX||null!=t.radiusY&&1!==t.radiusY)}(t)){this._lastTouchStartEvent=Date.now(),this._isPointerDown=!0;const e=t.changedTouches;for(let s=0;s<e.length;s++)this.fadeInRipple(e[s].clientX,e[s].clientY,this._target.rippleConfig)}}_onPointerUp(){this._isPointerDown&&(this._isPointerDown=!1,this._getActiveRipples().forEach(t=>{!t.config.persistent&&(1===t.state||t.config.terminateOnPointerUp&&0===t.state)&&t.fadeOut()}))}_getActiveRipples(){return Array.from(this._activeRipples.keys())}_removeTriggerEvents(){const t=this._triggerElement;t&&(CW.forEach(e=>Yp._eventManager.removeHandler(e,t,this)),this._pointerUpEventsRegistered&&SW.forEach(e=>t.removeEventListener(e,this,xW)))}}Yp._eventManager=new Cke;const IW=new we("mat-ripple-global-options");let EW=(()=>{class n{get disabled(){return this._disabled}set disabled(e){e&&this.fadeOutAllNonPersistent(),this._disabled=e,this._setupTriggerEventsIfEnabled()}get trigger(){return this._trigger||this._elementRef.nativeElement}set trigger(e){this._trigger=e,this._setupTriggerEventsIfEnabled()}constructor(e,s,r,i,o){this._elementRef=e,this._animationMode=o,this.radius=0,this._disabled=!1,this._isInitialized=!1,this._globalOptions=i||{},this._rippleRenderer=new Yp(this,s,e,r)}ngOnInit(){this._isInitialized=!0,this._setupTriggerEventsIfEnabled()}ngOnDestroy(){this._rippleRenderer._removeTriggerEvents()}fadeOutAll(){this._rippleRenderer.fadeOutAll()}fadeOutAllNonPersistent(){this._rippleRenderer.fadeOutAllNonPersistent()}get rippleConfig(){return{centered:this.centered,radius:this.radius,color:this.color,animation:{...this._globalOptions.animation,..."NoopAnimations"===this._animationMode?{enterDuration:0,exitDuration:0}:{},...this.animation},terminateOnPointerUp:this._globalOptions.terminateOnPointerUp}}get rippleDisabled(){return this.disabled||!!this._globalOptions.disabled}_setupTriggerEventsIfEnabled(){!this.disabled&&this._isInitialized&&this._rippleRenderer.setupTriggerEvents(this.trigger)}launch(e,s=0,r){return"number"==typeof e?this._rippleRenderer.fadeInRipple(e,s,{...this.rippleConfig,...r}):this._rippleRenderer.fadeInRipple(0,0,{...this.rippleConfig,...e})}}return n.\u0275fac=function(e){return new(e||n)(ne(ps),ne(Pt),ne(a_),ne(IW,8),ne(Jm,8))},n.\u0275dir=qe({type:n,selectors:[["","mat-ripple",""],["","matRipple",""]],hostAttrs:[1,"mat-ripple"],hostVars:2,hostBindings:function(e,s){2&e&&vc("mat-ripple-unbounded",s.unbounded)},inputs:{color:["matRippleColor","color"],unbounded:["matRippleUnbounded","unbounded"],centered:["matRippleCentered","centered"],radius:["matRippleRadius","radius"],animation:["matRippleAnimation","animation"],disabled:["matRippleDisabled","disabled"],trigger:["matRippleTrigger","trigger"]},exportAs:["matRipple"]}),n})(),Eke=(()=>{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275mod=Or({type:n}),n.\u0275inj=fr({imports:[PT,PT]}),n})();const Ii=new we("NgValueAccessor"),EAe=["knob"],DAe=["valueIndicatorContainer"];function TAe(n,t){if(1&n&&(At(0,"div",4,5)(2,"div",6)(3,"span",7),En(4),Rt()()()),2&n){const e=yc();Qn(4),_c(e.valueIndicatorText)}}const NAe=["trackActive"];function kAe(n,t){if(1&n&&Ko(0,"div"),2&n){const e=t.$implicit,s=t.index,r=yc(3);XR(0===e?"mdc-slider__tick-mark--active":"mdc-slider__tick-mark--inactive"),Gx("transform",r._calcTickMarkTransform(s))}}function AAe(n,t){if(1&n&&(bg(0),gc(1,kAe,1,4,"div",11),vg()),2&n){const e=yc(2);Qn(1),zr("ngForOf",e._tickMarks)}}function RAe(n,t){if(1&n&&(At(0,"div",8,9),gc(2,AAe,2,1,"ng-container",10),Rt()),2&n){const e=yc();Qn(2),zr("ngIf",e._cachedWidth)}}function MAe(n,t){if(1&n&&Ko(0,"mat-slider-visual-thumb",7),2&n){const e=yc();zr("discrete",e.discrete)("thumbPosition",1)("valueIndicatorText",e.startValueIndicatorText)}}const FAe=["*"],__=new we("_MatSlider"),k4=new we("_MatSliderThumb"),A4=new we("_MatSliderRangeThumb"),R4=new we("_MatSliderVisualThumb");let OAe=(()=>{class n{constructor(e,s,r,i){this._cdr=e,this._ngZone=s,this._slider=i,this._isHovered=!1,this._isActive=!1,this._isValueIndicatorVisible=!1,this._onPointerMove=o=>{if(this._sliderInput._isFocused)return;const a=this._hostElement.getBoundingClientRect(),l=this._isSliderThumbHovered(o,a);this._isHovered=l,l?this._showHoverRipple():this._hideRipple(this._hoverRippleRef)},this._onMouseLeave=()=>{this._isHovered=!1,this._hideRipple(this._hoverRippleRef)},this._onFocus=()=>{this._hideRipple(this._hoverRippleRef),this._showFocusRipple(),this._hostElement.classList.add("mdc-slider__thumb--focused")},this._onBlur=()=>{this._isActive||this._hideRipple(this._focusRippleRef),this._isHovered&&this._showHoverRipple(),this._hostElement.classList.remove("mdc-slider__thumb--focused")},this._onDragStart=o=>{0===o.button&&(this._isActive=!0,this._showActiveRipple())},this._onDragEnd=()=>{this._isActive=!1,this._hideRipple(this._activeRippleRef),this._sliderInput._isFocused||this._hideRipple(this._focusRippleRef)},this._hostElement=r.nativeElement}ngAfterViewInit(){this._ripple.radius=24,this._sliderInput=this._slider._getInput(this.thumbPosition),this._sliderInputEl=this._sliderInput._hostElement;const e=this._sliderInputEl;this._ngZone.runOutsideAngular(()=>{e.addEventListener("pointermove",this._onPointerMove),e.addEventListener("pointerdown",this._onDragStart),e.addEventListener("pointerup",this._onDragEnd),e.addEventListener("pointerleave",this._onMouseLeave),e.addEventListener("focus",this._onFocus),e.addEventListener("blur",this._onBlur)})}ngOnDestroy(){const e=this._sliderInputEl;e.removeEventListener("pointermove",this._onPointerMove),e.removeEventListener("pointerdown",this._onDragStart),e.removeEventListener("pointerup",this._onDragEnd),e.removeEventListener("pointerleave",this._onMouseLeave),e.removeEventListener("focus",this._onFocus),e.removeEventListener("blur",this._onBlur)}_showHoverRipple(){this._isShowingRipple(this._hoverRippleRef)||(this._hoverRippleRef=this._showRipple({enterDuration:0,exitDuration:0}),this._hoverRippleRef?.element.classList.add("mat-mdc-slider-hover-ripple"))}_showFocusRipple(){this._isShowingRipple(this._focusRippleRef)||(this._focusRippleRef=this._showRipple({enterDuration:0,exitDuration:0},!0),this._focusRippleRef?.element.classList.add("mat-mdc-slider-focus-ripple"))}_showActiveRipple(){this._isShowingRipple(this._activeRippleRef)||(this._activeRippleRef=this._showRipple({enterDuration:225,exitDuration:400}),this._activeRippleRef?.element.classList.add("mat-mdc-slider-active-ripple"))}_isShowingRipple(e){return 0===e?.state||1===e?.state}_showRipple(e,s){if(!this._slider.disabled&&(this._showValueIndicator(),this._slider._isRange&&this._slider._getThumb(1===this.thumbPosition?2:1)._showValueIndicator(),!this._slider._globalRippleOptions?.disabled||s))return this._ripple.launch({animation:this._slider._noopAnimations?{enterDuration:0,exitDuration:0}:e,centered:!0,persistent:!0})}_hideRipple(e){if(e?.fadeOut(),this._isShowingAnyRipple())return;this._slider._isRange||this._hideValueIndicator();const s=this._getSibling();s._isShowingAnyRipple()||(this._hideValueIndicator(),s._hideValueIndicator())}_showValueIndicator(){this._hostElement.classList.add("mdc-slider__thumb--with-indicator")}_hideValueIndicator(){this._hostElement.classList.remove("mdc-slider__thumb--with-indicator")}_getSibling(){return this._slider._getThumb(1===this.thumbPosition?2:1)}_getValueIndicatorContainer(){return this._valueIndicatorContainer?.nativeElement}_getKnob(){return this._knob.nativeElement}_isShowingAnyRipple(){return this._isShowingRipple(this._hoverRippleRef)||this._isShowingRipple(this._focusRippleRef)||this._isShowingRipple(this._activeRippleRef)}_isSliderThumbHovered(e,s){const r=s.width/2,l=e.clientY-(s.y+r);return Math.pow(e.clientX-(s.x+r),2)+Math.pow(l,2)<Math.pow(r,2)}}return n.\u0275fac=function(e){return new(e||n)(ne(Na),ne(Pt),ne(ps),ne(__))},n.\u0275cmp=Vd({type:n,selectors:[["mat-slider-visual-thumb"]],viewQuery:function(e,s){if(1&e&&(Sc(EW,5),Sc(EAe,5),Sc(DAe,5)),2&e){let r;Yo(r=Zo())&&(s._ripple=r.first),Yo(r=Zo())&&(s._knob=r.first),Yo(r=Zo())&&(s._valueIndicatorContainer=r.first)}},hostAttrs:[1,"mdc-slider__thumb","mat-mdc-slider-visual-thumb"],inputs:{discrete:"discrete",thumbPosition:"thumbPosition",valueIndicatorText:"valueIndicatorText"},features:[Jt([{provide:R4,useExisting:n}])],decls:4,vars:2,consts:[["class","mdc-slider__value-indicator-container",4,"ngIf"],[1,"mdc-slider__thumb-knob"],["knob",""],["matRipple","",1,"mat-mdc-focus-indicator",3,"matRippleDisabled"],[1,"mdc-slider__value-indicator-container"],["valueIndicatorContainer",""],[1,"mdc-slider__value-indicator"],[1,"mdc-slider__value-indicator-text"]],template:function(e,s){1&e&&(gc(0,TAe,5,1,"div",0),Ko(1,"div",1,2)(3,"div",3)),2&e&&(zr("ngIf",s.discrete),Qn(3),zr("matRippleDisabled",!0))},dependencies:[X0,EW],styles:[".mat-mdc-slider-visual-thumb .mat-ripple{height:100%;width:100%}.mat-mdc-slider .mdc-slider__tick-marks{justify-content:start}.mat-mdc-slider .mdc-slider__tick-marks .mdc-slider__tick-mark--active,.mat-mdc-slider .mdc-slider__tick-marks .mdc-slider__tick-mark--inactive{position:absolute;left:2px}"],encapsulation:2,changeDetection:0}),n})();const $Ae=vke(_ke(class{constructor(n){this._elementRef=n}}),"primary");let PAe=(()=>{class n extends $Ae{get disabled(){return this._disabled}set disabled(e){this._disabled=Nd(e);const s=this._getInput(2),r=this._getInput(1);s&&(s.disabled=this._disabled),r&&(r.disabled=this._disabled)}get discrete(){return this._discrete}set discrete(e){this._discrete=Nd(e),this._updateValueIndicatorUIs()}get showTickMarks(){return this._showTickMarks}set showTickMarks(e){this._showTickMarks=Nd(e)}get min(){return this._min}set min(e){const s=Zi(e,this._min);this._min!==s&&this._updateMin(s)}_updateMin(e){const s=this._min;this._min=e,this._isRange?this._updateMinRange({old:s,new:e}):this._updateMinNonRange(e),this._onMinMaxOrStepChange()}_updateMinRange(e){const s=this._getInput(2),r=this._getInput(1),i=s.value,o=r.value;r.min=e.new,s.min=Math.max(e.new,r.value),r.max=Math.min(s.max,s.value),r._updateWidthInactive(),s._updateWidthInactive(),e.new<e.old?this._onTranslateXChangeBySideEffect(s,r):this._onTranslateXChangeBySideEffect(r,s),i!==s.value&&this._onValueChange(s),o!==r.value&&this._onValueChange(r)}_updateMinNonRange(e){const s=this._getInput(2);if(s){const r=s.value;s.min=e,s._updateThumbUIByValue(),this._updateTrackUI(s),r!==s.value&&this._onValueChange(s)}}get max(){return this._max}set max(e){const s=Zi(e,this._max);this._max!==s&&this._updateMax(s)}_updateMax(e){const s=this._max;this._max=e,this._isRange?this._updateMaxRange({old:s,new:e}):this._updateMaxNonRange(e),this._onMinMaxOrStepChange()}_updateMaxRange(e){const s=this._getInput(2),r=this._getInput(1),i=s.value,o=r.value;s.max=e.new,r.max=Math.min(e.new,s.value),s.min=r.value,s._updateWidthInactive(),r._updateWidthInactive(),e.new>e.old?this._onTranslateXChangeBySideEffect(r,s):this._onTranslateXChangeBySideEffect(s,r),i!==s.value&&this._onValueChange(s),o!==r.value&&this._onValueChange(r)}_updateMaxNonRange(e){const s=this._getInput(2);if(s){const r=s.value;s.max=e,s._updateThumbUIByValue(),this._updateTrackUI(s),r!==s.value&&this._onValueChange(s)}}get step(){return this._step}set step(e){const s=Zi(e,this._step);this._step!==s&&this._updateStep(s)}_updateStep(e){this._step=e,this._isRange?this._updateStepRange():this._updateStepNonRange(),this._onMinMaxOrStepChange()}_updateStepRange(){const e=this._getInput(2),s=this._getInput(1),r=e.value,i=s.value,o=s.value;e.min=this._min,s.max=this._max,e.step=this._step,s.step=this._step,this._platform.SAFARI&&(e.value=e.value,s.value=s.value),e.min=Math.max(this._min,s.value),s.max=Math.min(this._max,e.value),s._updateWidthInactive(),e._updateWidthInactive(),e.value<o?this._onTranslateXChangeBySideEffect(s,e):this._onTranslateXChangeBySideEffect(e,s),r!==e.value&&this._onValueChange(e),i!==s.value&&this._onValueChange(s)}_updateStepNonRange(){const e=this._getInput(2);if(e){const s=e.value;e.step=this._step,this._platform.SAFARI&&(e.value=e.value),e._updateThumbUIByValue(),s!==e.value&&this._onValueChange(e)}}constructor(e,s,r,i,o,a,l){super(i),this._ngZone=e,this._cdr=s,this._platform=r,this._dir=o,this._globalRippleOptions=a,this._disabled=!1,this._discrete=!1,this._showTickMarks=!1,this._min=0,this._max=100,this._step=0,this.displayWith=u=>`${u}`,this._rippleRadius=24,this.startValueIndicatorText="",this.endValueIndicatorText="",this._isRange=!1,this._isRtl=!1,this._hasViewInitialized=!1,this._tickMarkTrackWidth=0,this._hasAnimation=!1,this._resizeTimer=null,this._knobRadius=8,this._thumbsOverlap=!1,this._noopAnimations="NoopAnimations"===l,this._dirChangeSubscription=this._dir.change.subscribe(()=>this._onDirChange()),this._isRtl="rtl"===this._dir.value}ngAfterViewInit(){this._platform.isBrowser&&this._updateDimensions();const e=this._getInput(2),s=this._getInput(1);this._isRange=!!e&&!!s,this._cdr.detectChanges();const r=this._getThumb(2);this._rippleRadius=r._ripple.radius,this._inputPadding=this._rippleRadius-this._knobRadius,this._inputOffset=this._knobRadius,this._isRange?this._initUIRange(e,s):this._initUINonRange(e),this._updateTrackUI(e),this._updateTickMarkUI(),this._updateTickMarkTrackUI(),this._observeHostResize(),this._cdr.detectChanges()}_initUINonRange(e){e.initProps(),e.initUI(),this._updateValueIndicatorUI(e),this._hasViewInitialized=!0,e._updateThumbUIByValue()}_initUIRange(e,s){e.initProps(),e.initUI(),s.initProps(),s.initUI(),e._updateMinMax(),s._updateMinMax(),e._updateStaticStyles(),s._updateStaticStyles(),this._updateValueIndicatorUIs(),this._hasViewInitialized=!0,e._updateThumbUIByValue(),s._updateThumbUIByValue()}ngOnDestroy(){this._dirChangeSubscription.unsubscribe(),this._resizeObserver?.disconnect(),this._resizeObserver=null}_onDirChange(){this._isRtl="rtl"===this._dir.value,this._isRange?this._onDirChangeRange():this._onDirChangeNonRange(),this._updateTickMarkUI()}_onDirChangeRange(){const e=this._getInput(2),s=this._getInput(1);e._setIsLeftThumb(),s._setIsLeftThumb(),e.translateX=e._calcTranslateXByValue(),s.translateX=s._calcTranslateXByValue(),e._updateStaticStyles(),s._updateStaticStyles(),e._updateWidthInactive(),s._updateWidthInactive(),e._updateThumbUIByValue(),s._updateThumbUIByValue()}_onDirChangeNonRange(){this._getInput(2)._updateThumbUIByValue()}_observeHostResize(){typeof ResizeObserver>"u"||!ResizeObserver||this._ngZone.runOutsideAngular(()=>{this._resizeObserver=new ResizeObserver(()=>{this._isActive()||(this._resizeTimer&&clearTimeout(this._resizeTimer),this._onResize())}),this._resizeObserver.observe(this._elementRef.nativeElement)})}_isActive(){return this._getThumb(1)._isActive||this._getThumb(2)._isActive}_getValue(e=2){const s=this._getInput(e);return s?s.value:this.min}_skipUpdate(){return!(!this._getInput(1)?._skipUIUpdate&&!this._getInput(2)?._skipUIUpdate)}_updateDimensions(){this._cachedWidth=this._elementRef.nativeElement.offsetWidth,this._cachedLeft=this._elementRef.nativeElement.getBoundingClientRect().left}_setTrackActiveStyles(e){const s=this._trackActive.nativeElement.style;s.left=e.left,s.right=e.right,s.transformOrigin=e.transformOrigin,s.transform=e.transform}_calcTickMarkTransform(e){return`translateX(${e*(this._tickMarkTrackWidth/(this._tickMarks.length-1))}px`}_onTranslateXChange(e){this._hasViewInitialized&&(this._updateThumbUI(e),this._updateTrackUI(e),this._updateOverlappingThumbUI(e))}_onTranslateXChangeBySideEffect(e,s){this._hasViewInitialized&&(e._updateThumbUIByValue(),s._updateThumbUIByValue())}_onValueChange(e){this._hasViewInitialized&&(this._updateValueIndicatorUI(e),this._updateTickMarkUI(),this._cdr.detectChanges())}_onMinMaxOrStepChange(){this._hasViewInitialized&&(this._updateTickMarkUI(),this._updateTickMarkTrackUI(),this._cdr.markForCheck())}_onResize(){if(this._hasViewInitialized){if(this._updateDimensions(),this._isRange){const e=this._getInput(2),s=this._getInput(1);e._updateThumbUIByValue(),s._updateThumbUIByValue(),e._updateStaticStyles(),s._updateStaticStyles(),e._updateMinMax(),s._updateMinMax(),e._updateWidthInactive(),s._updateWidthInactive()}else{const e=this._getInput(2);e&&e._updateThumbUIByValue()}this._updateTickMarkUI(),this._updateTickMarkTrackUI(),this._cdr.detectChanges()}}_areThumbsOverlapping(){const e=this._getInput(1),s=this._getInput(2);return!(!e||!s)&&s.translateX-e.translateX<20}_updateOverlappingThumbClassNames(e){const s=e.getSibling(),r=this._getThumb(e.thumbPosition);this._getThumb(s.thumbPosition)._hostElement.classList.remove("mdc-slider__thumb--top"),r._hostElement.classList.toggle("mdc-slider__thumb--top",this._thumbsOverlap)}_updateOverlappingThumbUI(e){!this._isRange||this._skipUpdate()||this._thumbsOverlap!==this._areThumbsOverlapping()&&(this._thumbsOverlap=!this._thumbsOverlap,this._updateOverlappingThumbClassNames(e))}_updateThumbUI(e){this._skipUpdate()||(this._getThumb(2===e.thumbPosition?2:1)._hostElement.style.transform=`translateX(${e.translateX}px)`)}_updateValueIndicatorUI(e){if(this._skipUpdate())return;const s=this.displayWith(e.value);if(this._hasViewInitialized?e._valuetext=s:e._hostElement.setAttribute("aria-valuetext",s),this.discrete){1===e.thumbPosition?this.startValueIndicatorText=s:this.endValueIndicatorText=s;const r=this._getThumb(e.thumbPosition);s.length<3?r._hostElement.classList.add("mdc-slider__thumb--short-value"):r._hostElement.classList.remove("mdc-slider__thumb--short-value")}}_updateValueIndicatorUIs(){const e=this._getInput(2),s=this._getInput(1);e&&this._updateValueIndicatorUI(e),s&&this._updateValueIndicatorUI(s)}_updateTickMarkTrackUI(){if(!this.showTickMarks||this._skipUpdate())return;const e=this._step&&this._step>0?this._step:1,r=(Math.floor(this.max/e)*e-this.min)/(this.max-this.min);this._tickMarkTrackWidth=this._cachedWidth*r-6}_updateTrackUI(e){this._skipUpdate()||(this._isRange?this._updateTrackUIRange(e):this._updateTrackUINonRange(e))}_updateTrackUIRange(e){const s=e.getSibling();if(!s||!this._cachedWidth)return;const r=Math.abs(s.translateX-e.translateX)/this._cachedWidth;this._setTrackActiveStyles(e._isLeftThumb&&this._cachedWidth?{left:"auto",right:this._cachedWidth-s.translateX+"px",transformOrigin:"right",transform:`scaleX(${r})`}:{left:`${s.translateX}px`,right:"auto",transformOrigin:"left",transform:`scaleX(${r})`})}_updateTrackUINonRange(e){this._setTrackActiveStyles(this._isRtl?{left:"auto",right:"0px",transformOrigin:"right",transform:`scaleX(${1-e.fillPercentage})`}:{left:"0px",right:"auto",transformOrigin:"left",transform:`scaleX(${e.fillPercentage})`})}_updateTickMarkUI(){if(!this.showTickMarks||void 0===this.step||void 0===this.min||void 0===this.max)return;const e=this.step>0?this.step:1;this._isRange?this._updateTickMarkUIRange(e):this._updateTickMarkUINonRange(e),this._isRtl&&this._tickMarks.reverse()}_updateTickMarkUINonRange(e){const s=this._getValue();let r=Math.max(Math.round((s-this.min)/e),0),i=Math.max(Math.round((this.max-s)/e),0);this._isRtl?r++:i++,this._tickMarks=Array(r).fill(0).concat(Array(i).fill(1))}_updateTickMarkUIRange(e){const s=this._getValue(),r=this._getValue(1),i=Math.max(Math.floor((r-this.min)/e),0),o=Math.max(Math.floor((s-r)/e)+1,0),a=Math.max(Math.floor((this.max-s)/e),0);this._tickMarks=Array(i).fill(1).concat(Array(o).fill(0),Array(a).fill(1))}_getInput(e){return 2===e&&this._input?this._input:this._inputs?.length?1===e?this._inputs.first:this._inputs.last:void 0}_getThumb(e){return 2===e?this._thumbs?.last:this._thumbs?.first}_setTransition(e){this._hasAnimation=e&&!this._noopAnimations,this._elementRef.nativeElement.classList.toggle("mat-mdc-slider-with-animation",this._hasAnimation)}}return n.\u0275fac=function(e){return new(e||n)(ne(Pt),ne(Na),ne(a_),ne(ps),ne(L1e,8),ne(IW,8),ne(Jm,8))},n.\u0275cmp=Vd({type:n,selectors:[["mat-slider"]],contentQueries:function(e,s,r){if(1&e&&(Ng(r,k4,5),Ng(r,A4,4)),2&e){let i;Yo(i=Zo())&&(s._input=i.first),Yo(i=Zo())&&(s._inputs=i)}},viewQuery:function(e,s){if(1&e&&(Sc(NAe,5),Sc(R4,5)),2&e){let r;Yo(r=Zo())&&(s._trackActive=r.first),Yo(r=Zo())&&(s._thumbs=r)}},hostAttrs:[1,"mat-mdc-slider","mdc-slider"],hostVars:10,hostBindings:function(e,s){2&e&&vc("mdc-slider--range",s._isRange)("mdc-slider--disabled",s.disabled)("mdc-slider--discrete",s.discrete)("mdc-slider--tick-marks",s.showTickMarks)("_mat-animation-noopable",s._noopAnimations)},inputs:{color:"color",disableRipple:"disableRipple",disabled:"disabled",discrete:"discrete",showTickMarks:"showTickMarks",min:"min",max:"max",step:"step",displayWith:"displayWith"},exportAs:["matSlider"],features:[Jt([{provide:__,useExisting:n}]),Vt],ngContentSelectors:FAe,decls:9,vars:5,consts:[[1,"mdc-slider__track"],[1,"mdc-slider__track--inactive"],[1,"mdc-slider__track--active"],[1,"mdc-slider__track--active_fill"],["trackActive",""],["class","mdc-slider__tick-marks",4,"ngIf"],[3,"discrete","thumbPosition","valueIndicatorText",4,"ngIf"],[3,"discrete","thumbPosition","valueIndicatorText"],[1,"mdc-slider__tick-marks"],["tickMarkContainer",""],[4,"ngIf"],[3,"class","transform",4,"ngFor","ngForOf"]],template:function(e,s){1&e&&(function RR(n){const t=oe()[Yn][Gs];if(!t.projection){const s=t.projection=Yd(n?n.length:1,null),r=s.slice();let i=t.child;for(;null!==i;){const o=n?D5(i,n):0;null!==o&&(r[o]?r[o].projectionNext=i:s[o]=i,r[o]=i),i=i.next}}}(),MR(0),At(1,"div",0),Ko(2,"div",1),At(3,"div",2),Ko(4,"div",3,4),Rt(),gc(6,RAe,3,1,"div",5),Rt(),gc(7,MAe,1,3,"mat-slider-visual-thumb",6),Ko(8,"mat-slider-visual-thumb",7)),2&e&&(Qn(6),zr("ngIf",s.showTickMarks),Qn(1),zr("ngIf",s._isRange),Qn(1),zr("discrete",s.discrete)("thumbPosition",2)("valueIndicatorText",s.endValueIndicatorText))},dependencies:[VO,X0,OAe],styles:['.mdc-slider{cursor:pointer;height:48px;margin:0 24px;position:relative;touch-action:pan-y}.mdc-slider .mdc-slider__track{position:absolute;top:50%;transform:translateY(-50%);width:100%}.mdc-slider .mdc-slider__track--active,.mdc-slider .mdc-slider__track--inactive{display:flex;height:100%;position:absolute;width:100%}.mdc-slider .mdc-slider__track--active{overflow:hidden}.mdc-slider .mdc-slider__track--active_fill{border-top-style:solid;box-sizing:border-box;height:100%;width:100%;position:relative;-webkit-transform-origin:left;transform-origin:left}[dir=rtl] .mdc-slider .mdc-slider__track--active_fill,.mdc-slider .mdc-slider__track--active_fill[dir=rtl]{-webkit-transform-origin:right;transform-origin:right}.mdc-slider .mdc-slider__track--inactive{left:0;top:0}.mdc-slider .mdc-slider__track--inactive::before{position:absolute;box-sizing:border-box;width:100%;height:100%;top:0;left:0;border:1px solid rgba(0,0,0,0);border-radius:inherit;content:"";pointer-events:none}@media screen and (forced-colors: active){.mdc-slider .mdc-slider__track--inactive::before{border-color:CanvasText}}.mdc-slider .mdc-slider__value-indicator-container{bottom:44px;left:var(--slider-value-indicator-container-left, 50%);pointer-events:none;position:absolute;right:var(--slider-value-indicator-container-right);transform:var(--slider-value-indicator-container-transform, translateX(-50%))}.mdc-slider .mdc-slider__value-indicator{transition:transform 100ms 0ms cubic-bezier(0.4, 0, 1, 1);align-items:center;border-radius:4px;display:flex;height:32px;padding:0 12px;transform:scale(0);transform-origin:bottom}.mdc-slider .mdc-slider__value-indicator::before{border-left:6px solid rgba(0,0,0,0);border-right:6px solid rgba(0,0,0,0);border-top:6px solid;bottom:-5px;content:"";height:0;left:var(--slider-value-indicator-caret-left, 50%);position:absolute;right:var(--slider-value-indicator-caret-right);transform:var(--slider-value-indicator-caret-transform, translateX(-50%));width:0}.mdc-slider .mdc-slider__value-indicator::after{position:absolute;box-sizing:border-box;width:100%;height:100%;top:0;left:0;border:1px solid rgba(0,0,0,0);border-radius:inherit;content:"";pointer-events:none}@media screen and (forced-colors: active){.mdc-slider .mdc-slider__value-indicator::after{border-color:CanvasText}}.mdc-slider .mdc-slider__thumb--with-indicator .mdc-slider__value-indicator-container{pointer-events:auto}.mdc-slider .mdc-slider__thumb--with-indicator .mdc-slider__value-indicator{transition:transform 100ms 0ms cubic-bezier(0, 0, 0.2, 1);transform:scale(1)}@media(prefers-reduced-motion){.mdc-slider .mdc-slider__value-indicator,.mdc-slider .mdc-slider__thumb--with-indicator .mdc-slider__value-indicator{transition:none}}.mdc-slider .mdc-slider__thumb{display:flex;left:-24px;outline:none;position:absolute;user-select:none;height:48px;width:48px}.mdc-slider .mdc-slider__thumb--top{z-index:1}.mdc-slider .mdc-slider__thumb--top .mdc-slider__thumb-knob,.mdc-slider .mdc-slider__thumb--top.mdc-slider__thumb:hover .mdc-slider__thumb-knob,.mdc-slider .mdc-slider__thumb--top.mdc-slider__thumb--focused .mdc-slider__thumb-knob{border-style:solid;border-width:1px;box-sizing:content-box}.mdc-slider .mdc-slider__thumb-knob{box-sizing:border-box;left:50%;position:absolute;top:50%;transform:translate(-50%, -50%)}.mdc-slider .mdc-slider__tick-marks{align-items:center;box-sizing:border-box;display:flex;height:100%;justify-content:space-between;padding:0 1px;position:absolute;width:100%}.mdc-slider--discrete .mdc-slider__thumb,.mdc-slider--discrete .mdc-slider__track--active_fill{transition:transform 80ms ease}@media(prefers-reduced-motion){.mdc-slider--discrete .mdc-slider__thumb,.mdc-slider--discrete .mdc-slider__track--active_fill{transition:none}}.mdc-slider--disabled{cursor:auto}.mdc-slider--disabled .mdc-slider__thumb{pointer-events:none}.mdc-slider__input{cursor:pointer;left:2px;margin:0;height:44px;opacity:0;pointer-events:none;position:absolute;top:2px;width:44px}.mat-mdc-slider{display:inline-block;box-sizing:border-box;outline:none;vertical-align:middle;margin-left:8px;margin-right:8px;width:auto;min-width:112px;-webkit-tap-highlight-color:rgba(0,0,0,0)}.mat-mdc-slider .mdc-slider__thumb-knob{background-color:var(--mdc-slider-handle-color, var(--mdc-theme-primary, #6200ee));border-color:var(--mdc-slider-handle-color, var(--mdc-theme-primary, #6200ee))}.mat-mdc-slider .mdc-slider__thumb--top .mdc-slider__thumb-knob,.mat-mdc-slider .mdc-slider__thumb--top.mdc-slider__thumb:hover .mdc-slider__thumb-knob,.mat-mdc-slider .mdc-slider__thumb--top.mdc-slider__thumb--focused .mdc-slider__thumb-knob{border-color:#fff}.mat-mdc-slider.mdc-slider--disabled .mdc-slider__thumb-knob{background-color:var(--mdc-slider-disabled-handle-color, var(--mdc-theme-on-surface, #000));border-color:var(--mdc-slider-disabled-handle-color, var(--mdc-theme-on-surface, #000))}.mat-mdc-slider.mdc-slider--disabled .mdc-slider__thumb--top .mdc-slider__thumb-knob,.mat-mdc-slider.mdc-slider--disabled .mdc-slider__thumb--top.mdc-slider__thumb:hover .mdc-slider__thumb-knob,.mat-mdc-slider.mdc-slider--disabled .mdc-slider__thumb--top.mdc-slider__thumb--focused .mdc-slider__thumb-knob{border-color:#fff}.mat-mdc-slider .mdc-slider__thumb::before,.mat-mdc-slider .mdc-slider__thumb::after{background-color:var(--mdc-slider-handle-color, var(--mdc-theme-primary, #6200ee))}.mat-mdc-slider .mdc-slider__thumb:hover::before,.mat-mdc-slider .mdc-slider__thumb.mdc-ripple-surface--hover::before{opacity:var(--mdc-ripple-hover-opacity, 0.04)}.mat-mdc-slider .mdc-slider__thumb.mdc-ripple-upgraded--background-focused::before,.mat-mdc-slider .mdc-slider__thumb:not(.mdc-ripple-upgraded):focus::before{transition-duration:75ms;opacity:var(--mdc-ripple-focus-opacity, 0.12)}.mat-mdc-slider .mdc-slider__thumb:not(.mdc-ripple-upgraded)::after{transition:opacity 150ms linear}.mat-mdc-slider .mdc-slider__thumb:not(.mdc-ripple-upgraded):active::after{transition-duration:75ms;opacity:var(--mdc-ripple-press-opacity, 0.12)}.mat-mdc-slider .mdc-slider__thumb.mdc-ripple-upgraded{--mdc-ripple-fg-opacity:var(--mdc-ripple-press-opacity, 0.12)}.mat-mdc-slider .mdc-slider__track--active_fill{border-color:var(--mdc-slider-active-track-color, var(--mdc-theme-primary, #6200ee))}.mat-mdc-slider.mdc-slider--disabled .mdc-slider__track--active_fill{border-color:var(--mdc-slider-disabled-active-track-color, var(--mdc-theme-on-surface, #000))}.mat-mdc-slider .mdc-slider__track--inactive{background-color:var(--mdc-slider-inactive-track-color, var(--mdc-theme-primary, #6200ee));opacity:.24}.mat-mdc-slider.mdc-slider--disabled .mdc-slider__track--inactive{background-color:var(--mdc-slider-disabled-inactive-track-color, var(--mdc-theme-on-surface, #000));opacity:.24}.mat-mdc-slider .mdc-slider__tick-mark--active{background-color:var(--mdc-slider-with-tick-marks-active-container-color, var(--mdc-theme-on-primary, #fff));opacity:var(--mdc-slider-with-tick-marks-active-container-opacity, 0.6)}.mat-mdc-slider.mdc-slider--disabled .mdc-slider__tick-mark--active{background-color:var(--mdc-slider-with-tick-marks-active-container-color, var(--mdc-theme-on-primary, #fff));opacity:var(--mdc-slider-with-tick-marks-active-container-opacity, 0.6)}.mat-mdc-slider .mdc-slider__tick-mark--inactive{background-color:var(--mdc-slider-with-tick-marks-inactive-container-color, var(--mdc-theme-primary, #6200ee));opacity:var(--mdc-slider-with-tick-marks-inactive-container-opacity, 0.6)}.mat-mdc-slider.mdc-slider--disabled .mdc-slider__tick-mark--inactive{background-color:var(--mdc-slider-with-tick-marks-disabled-container-color, var(--mdc-theme-on-surface, #000));opacity:var(--mdc-slider-with-tick-marks-inactive-container-opacity, 0.6)}.mat-mdc-slider .mdc-slider__value-indicator{background-color:var(--mdc-slider-label-container-color, #666666);opacity:1}.mat-mdc-slider .mdc-slider__value-indicator::before{border-top-color:var(--mdc-slider-label-container-color, #666666)}.mat-mdc-slider .mdc-slider__value-indicator{color:var(--mdc-slider-label-label-text-color, var(--mdc-theme-on-primary, #fff))}.mat-mdc-slider .mdc-slider__track{height:var(--mdc-slider-inactive-track-height, 4px)}.mat-mdc-slider .mdc-slider__track--active{height:var(--mdc-slider-active-track-height, 6px);top:calc((var(--mdc-slider-inactive-track-height, 4px) - var(--mdc-slider-active-track-height, 6px)) / 2)}.mat-mdc-slider .mdc-slider__track--active_fill{border-top-width:var(--mdc-slider-active-track-height, 6px)}.mat-mdc-slider .mdc-slider__track--inactive{height:var(--mdc-slider-inactive-track-height, 4px)}.mat-mdc-slider .mdc-slider__tick-mark--active,.mat-mdc-slider .mdc-slider__tick-mark--inactive{height:var(--mdc-slider-with-tick-marks-container-size, 2px);width:var(--mdc-slider-with-tick-marks-container-size, 2px)}.mat-mdc-slider.mdc-slider--disabled{opacity:0.38}.mat-mdc-slider .mdc-slider__value-indicator-text{letter-spacing:var(--mdc-slider-label-label-text-tracking, 0.0071428571em);font-size:var(--mdc-slider-label-label-text-size, 0.875rem);font-family:var(--mdc-slider-label-label-text-font, Roboto, sans-serif);font-weight:var(--mdc-slider-label-label-text-weight, 500);line-height:var(--mdc-slider-label-label-text-line-height, 1.375rem)}.mat-mdc-slider .mdc-slider__track--active{border-radius:var(--mdc-slider-active-track-shape, 9999px)}.mat-mdc-slider .mdc-slider__track--inactive{border-radius:var(--mdc-slider-inactive-track-shape, 9999px)}.mat-mdc-slider .mdc-slider__thumb-knob{border-radius:var(--mdc-slider-handle-shape, 50%);width:var(--mdc-slider-handle-width, 20px);height:var(--mdc-slider-handle-height, 20px);border-style:solid;border-width:calc(var(--mdc-slider-handle-height, 20px) / 2) calc(var(--mdc-slider-handle-width, 20px) / 2)}.mat-mdc-slider .mdc-slider__tick-mark--active,.mat-mdc-slider .mdc-slider__tick-mark--inactive{border-radius:var(--mdc-slider-with-tick-marks-container-shape, 50%)}.mat-mdc-slider .mdc-slider__thumb-knob{box-shadow:var(--mdc-slider-handle-elevation, 0px 2px 1px -1px rgba(0, 0, 0, 0.2), 0px 1px 1px 0px rgba(0, 0, 0, 0.14), 0px 1px 3px 0px rgba(0, 0, 0, 0.12))}.mat-mdc-slider .mdc-slider__thumb:hover .mdc-slider__thumb-knob{background-color:var(--mdc-slider-hover-handle-color, var(--mdc-theme-primary, #6200ee));border-color:var(--mdc-slider-hover-handle-color, var(--mdc-theme-primary, #6200ee))}.mat-mdc-slider .mdc-slider__thumb:hover .mdc-slider__thumb--top .mdc-slider__thumb-knob,.mat-mdc-slider .mdc-slider__thumb:hover .mdc-slider__thumb--top.mdc-slider__thumb:hover .mdc-slider__thumb-knob,.mat-mdc-slider .mdc-slider__thumb:hover .mdc-slider__thumb--top.mdc-slider__thumb--focused .mdc-slider__thumb-knob{border-color:#fff}.mat-mdc-slider .mdc-slider__thumb--focused .mdc-slider__thumb-knob{background-color:var(--mdc-slider-focus-handle-color, var(--mdc-theme-primary, #6200ee));border-color:var(--mdc-slider-focus-handle-color, var(--mdc-theme-primary, #6200ee))}.mat-mdc-slider .mdc-slider__thumb--focused .mdc-slider__thumb--top .mdc-slider__thumb-knob,.mat-mdc-slider .mdc-slider__thumb--focused .mdc-slider__thumb--top.mdc-slider__thumb:hover .mdc-slider__thumb-knob,.mat-mdc-slider .mdc-slider__thumb--focused .mdc-slider__thumb--top.mdc-slider__thumb--focused .mdc-slider__thumb-knob{border-color:#fff}.mat-mdc-slider .mdc-slider__thumb:not(:disabled):active .mdc-slider__thumb--top .mdc-slider__thumb-knob,.mat-mdc-slider .mdc-slider__thumb:not(:disabled):active .mdc-slider__thumb--top.mdc-slider__thumb:hover .mdc-slider__thumb-knob,.mat-mdc-slider .mdc-slider__thumb:not(:disabled):active .mdc-slider__thumb--top.mdc-slider__thumb--focused .mdc-slider__thumb-knob{border-color:#fff}.mat-mdc-slider .mdc-slider__thumb--top .mdc-slider__thumb-knob,.mat-mdc-slider .mdc-slider__thumb--top.mdc-slider__thumb:hover .mdc-slider__thumb-knob,.mat-mdc-slider .mdc-slider__thumb--top.mdc-slider__thumb--focused .mdc-slider__thumb-knob{border-color:var(--mdc-slider-with-overlap-handle-outline-color, #fff);border-width:var(--mdc-slider-with-overlap-handle-outline-width, 1px)}.mat-mdc-slider .mdc-slider__input{box-sizing:content-box;pointer-events:auto}.mat-mdc-slider .mdc-slider__input.mat-mdc-slider-input-no-pointer-events{pointer-events:none}.mat-mdc-slider .mdc-slider__input.mat-slider__right-input{left:auto;right:0}.mat-mdc-slider .mdc-slider__thumb,.mat-mdc-slider .mdc-slider__track--active_fill{transition-duration:0ms}.mat-mdc-slider.mat-mdc-slider-with-animation .mdc-slider__thumb,.mat-mdc-slider.mat-mdc-slider-with-animation .mdc-slider__track--active_fill{transition-duration:80ms}.mat-mdc-slider.mdc-slider--discrete .mdc-slider__thumb,.mat-mdc-slider.mdc-slider--discrete .mdc-slider__track--active_fill{transition-duration:0ms}.mat-mdc-slider.mat-mdc-slider-with-animation .mdc-slider__thumb,.mat-mdc-slider.mat-mdc-slider-with-animation .mdc-slider__track--active_fill{transition-duration:80ms}.mat-mdc-slider .mdc-slider__track,.mat-mdc-slider .mdc-slider__thumb{pointer-events:none}.mat-mdc-slider .mdc-slider__value-indicator{opacity:var(--mat-mdc-slider-value-indicator-opacity, 1)}.mat-mdc-slider .mat-ripple .mat-ripple-element{background-color:var(--mat-mdc-slider-ripple-color, transparent)}.mat-mdc-slider .mat-ripple .mat-mdc-slider-hover-ripple{background-color:var(--mat-mdc-slider-hover-ripple-color, transparent)}.mat-mdc-slider .mat-ripple .mat-mdc-slider-focus-ripple,.mat-mdc-slider .mat-ripple .mat-mdc-slider-active-ripple{background-color:var(--mat-mdc-slider-focus-ripple-color, transparent)}.mat-mdc-slider._mat-animation-noopable.mdc-slider--discrete .mdc-slider__thumb,.mat-mdc-slider._mat-animation-noopable.mdc-slider--discrete .mdc-slider__track--active_fill,.mat-mdc-slider._mat-animation-noopable .mdc-slider__value-indicator{transition:none}.mat-mdc-slider .mat-mdc-focus-indicator::before{border-radius:50%}.mdc-slider__thumb--focused .mat-mdc-focus-indicator::before{content:""}'],encapsulation:2,changeDetection:0}),n})();const VAe={provide:Ii,useExisting:Qt(()=>iN),multi:!0};let iN=(()=>{class n{get value(){return Zi(this._hostElement.value)}set value(e){const s=Zi(e).toString();this._hasSetInitialValue?this._isActive||(this._hostElement.value=s,this._updateThumbUIByValue(),this._slider._onValueChange(this),this._cdr.detectChanges()):this._initialValue=s}get translateX(){return this._slider.min>=this._slider.max?(this._translateX=0,this._translateX):(void 0===this._translateX&&(this._translateX=this._calcTranslateXByValue()),this._translateX)}set translateX(e){this._translateX=e}get min(){return Zi(this._hostElement.min)}set min(e){this._hostElement.min=Zi(e).toString(),this._cdr.detectChanges()}get max(){return Zi(this._hostElement.max)}set max(e){this._hostElement.max=Zi(e).toString(),this._cdr.detectChanges()}get step(){return Zi(this._hostElement.step)}set step(e){this._hostElement.step=Zi(e).toString(),this._cdr.detectChanges()}get disabled(){return Nd(this._hostElement.disabled)}set disabled(e){this._hostElement.disabled=Nd(e),this._cdr.detectChanges(),this._slider.disabled!==this.disabled&&(this._slider.disabled=this.disabled)}get percentage(){return this._slider.min>=this._slider.max?this._slider._isRtl?1:0:(this.value-this._slider.min)/(this._slider.max-this._slider.min)}get fillPercentage(){return this._slider._cachedWidth?0===this._translateX?0:this.translateX/this._slider._cachedWidth:this._slider._isRtl?1:0}_setIsFocused(e){this._isFocused=e}constructor(e,s,r,i){this._ngZone=e,this._elementRef=s,this._cdr=r,this._slider=i,this.valueChange=new un,this.dragStart=new un,this.dragEnd=new un,this.thumbPosition=2,this._knobRadius=8,this._isActive=!1,this._isFocused=!1,this._hasSetInitialValue=!1,this._destroyed=new Ti,this._skipUIUpdate=!1,this._onTouchedFn=()=>{},this._isControlInitialized=!1,this._hostElement=s.nativeElement,this._ngZone.runOutsideAngular(()=>{this._hostElement.addEventListener("pointerdown",this._onPointerDown.bind(this)),this._hostElement.addEventListener("pointermove",this._onPointerMove.bind(this)),this._hostElement.addEventListener("pointerup",this._onPointerUp.bind(this))})}ngOnDestroy(){this._hostElement.removeEventListener("pointerdown",this._onPointerDown),this._hostElement.removeEventListener("pointermove",this._onPointerMove),this._hostElement.removeEventListener("pointerup",this._onPointerUp),this._destroyed.next(),this._destroyed.complete(),this.dragStart.complete(),this.dragEnd.complete()}initProps(){this._updateWidthInactive(),this.disabled!==this._slider.disabled&&(this._slider.disabled=!0),this.step=this._slider.step,this.min=this._slider.min,this.max=this._slider.max,this._initValue()}initUI(){this._updateThumbUIByValue()}_initValue(){this._hasSetInitialValue=!0,void 0===this._initialValue?this.value=this._getDefaultValue():(this._hostElement.value=this._initialValue,this._updateThumbUIByValue(),this._slider._onValueChange(this),this._cdr.detectChanges())}_getDefaultValue(){return this.min}_onBlur(){this._setIsFocused(!1),this._onTouchedFn()}_onFocus(){this._setIsFocused(!0)}_onChange(){this.valueChange.emit(this.value),this._isActive&&this._updateThumbUIByValue({withAnimation:!0})}_onInput(){this._onChangeFn?.(this.value),(this._slider.step||!this._isActive)&&this._updateThumbUIByValue({withAnimation:!0}),this._slider._onValueChange(this)}_onNgControlValueChange(){(!this._isActive||!this._isFocused)&&(this._slider._onValueChange(this),this._updateThumbUIByValue()),this._slider.disabled=this._formControl.disabled}_onPointerDown(e){this.disabled||0!==e.button||(this._isActive=!0,this._setIsFocused(!0),this._updateWidthActive(),this._slider._updateDimensions(),this._slider.step||this._updateThumbUIByPointerEvent(e,{withAnimation:!0}),this.disabled||(this._handleValueCorrection(e),this.dragStart.emit({source:this,parent:this._slider,value:this.value})))}_handleValueCorrection(e){this._skipUIUpdate=!0,setTimeout(()=>{this._skipUIUpdate=!1,this._fixValue(e)},0)}_fixValue(e){const s=e.clientX-this._slider._cachedLeft,r=this._slider._cachedWidth,i=0===this._slider.step?1:this._slider.step,o=Math.floor((this._slider.max-this._slider.min)/i),u=Math.round((this._slider._isRtl?1-s/r:s/r)*o)/o*(this._slider.max-this._slider.min)+this._slider.min,c=Math.round(u/i)*i;if(c===this.value)return this._slider._onValueChange(this),void(this._slider.step>0?this._updateThumbUIByValue():this._updateThumbUIByPointerEvent(e,{withAnimation:this._slider._hasAnimation}));this.value=c,this.valueChange.emit(this.value),this._onChangeFn?.(this.value),this._slider._onValueChange(this),this._slider.step>0?this._updateThumbUIByValue():this._updateThumbUIByPointerEvent(e,{withAnimation:this._slider._hasAnimation})}_onPointerMove(e){!this._slider.step&&this._isActive&&this._updateThumbUIByPointerEvent(e)}_onPointerUp(){this._isActive&&(this._isActive=!1,this.dragEnd.emit({source:this,parent:this._slider,value:this.value}),setTimeout(()=>this._updateWidthInactive()))}_clamp(e){return Math.max(Math.min(e,this._slider._cachedWidth),0)}_calcTranslateXByValue(){return this._slider._isRtl?(1-this.percentage)*this._slider._cachedWidth:this.percentage*this._slider._cachedWidth}_calcTranslateXByPointerEvent(e){return e.clientX-this._slider._cachedLeft}_updateWidthActive(){this._hostElement.style.padding=`0 ${this._slider._inputPadding}px`,this._hostElement.style.width=`calc(100% + ${this._slider._inputPadding}px)`}_updateWidthInactive(){this._hostElement.style.padding="0px",this._hostElement.style.width="calc(100% + 48px)",this._hostElement.style.left="-24px"}_updateThumbUIByValue(e){this.translateX=this._clamp(this._calcTranslateXByValue()),this._updateThumbUI(e)}_updateThumbUIByPointerEvent(e,s){this.translateX=this._clamp(this._calcTranslateXByPointerEvent(e)),this._updateThumbUI(s)}_updateThumbUI(e){this._slider._setTransition(!!e?.withAnimation),this._slider._onTranslateXChange(this)}writeValue(e){(this._isControlInitialized||null!==e)&&(this.value=e)}registerOnChange(e){this._onChangeFn=e,this._isControlInitialized=!0}registerOnTouched(e){this._onTouchedFn=e}setDisabledState(e){this.disabled=e}focus(){this._hostElement.focus()}blur(){this._hostElement.blur()}}return n.\u0275fac=function(e){return new(e||n)(ne(Pt),ne(ps),ne(Na),ne(__))},n.\u0275dir=qe({type:n,selectors:[["input","matSliderThumb",""]],hostAttrs:["type","range",1,"mdc-slider__input"],hostVars:1,hostBindings:function(e,s){1&e&&ms("change",function(){return s._onChange()})("input",function(){return s._onInput()})("blur",function(){return s._onBlur()})("focus",function(){return s._onFocus()}),2&e&&Ri("aria-valuetext",s._valuetext)},inputs:{value:"value"},outputs:{valueChange:"valueChange",dragStart:"dragStart",dragEnd:"dragEnd"},exportAs:["matSliderThumb"],features:[Jt([VAe,{provide:k4,useExisting:n}])]}),n})(),UAe=(()=>{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275mod=Or({type:n}),n.\u0275inj=fr({imports:[PT,HO,Eke]}),n})(),WAe=(()=>{class n{constructor(){this.title="wams-ml-app",this.heightInInches=68,this.heightInFeetAndInches="5'8\"",this.weightInPounds=170,this.age=30,this.gender="male",this.genderInt=1}ngOnInit(){var e=this;return te(function*(){yield e.loadHipModel(),yield e.loadUpperLegModel(),yield e.loadLowerLegModel(),e.predict()})()}onChangeHeight(e){this.heightInInches=+e.target.value,this.heightInFeetAndInches=this.convertInchesToFeetAndInches(this.heightInInches),this.predict()}convertInchesToFeetAndInches(e){return`${Math.floor(e/12)}'${e%12}"`}onChangeWeight(e){this.weightInPounds=+e.target.value,this.predict()}onChangeAge(e){this.age=+e.target.value,this.predict()}onChangeGender(e){this.gender=e.target.value,"male"===this.gender?this.genderInt=1:"female"===this.gender&&(this.genderInt=2),this.predict()}loadHipModel(){var e=this;return te(function*(){e.hipModel=yield QD("assets/hip_model/model.json")})()}loadUpperLegModel(){var e=this;return te(function*(){e.upperLegModel=yield QD("assets/upper_leg_model/model.json")})()}loadLowerLegModel(){var e=this;return te(function*(){e.lowerLegModel=yield QD("assets/lower_leg_model/model.json")})()}formatLabel(e){return Math.floor(e/12),`${e}`}predict(){const e=od([this.age,this.heightInInches,this.weightInPounds,this.genderInt],[1,4]),s=this.hipModel.predict(e);this.hipPredictionValue=this.roundToNearestQuarterInch(s.dataSync()[0]);const r=this.upperLegModel.predict(e);this.upperLegPredictionValue=this.roundToNearestQuarterInch(r.dataSync()[0]);const i=this.lowerLegModel.predict(e);this.lowerLegPredictionValue=this.roundToNearestQuarterInch(i.dataSync()[0])}roundToNearestQuarterInch(e){return Math.round(4*e)/4}}return n.\u0275fac=function(e){return new(e||n)},n.\u0275cmp=Vd({type:n,selectors:[["app-root"]],decls:69,vars:22,consts:[[1,"bg-gradient-to-tr","from-fuchsia-300","to-sky-500"],["id","login",1,"p-4","flex","flex-col","justify-center","min-h-screen","max-w-md","mx-auto"],[1,"p-6","bg-sky-100","rounded"],[1,"flex","items-center","justify-center","font-black","m-3","mb-12"],[1,"tracking-wide","text-3xl","text-gray-900"],["id","wams_form","action","api_login","method","POST",1,"flex","flex-col"],[1,"flex","justify-between","items-center","mb-3"],["for","height-range",1,"block","font-extrabold","mb-2","underline","text-sm","text-center","text-slate-700"],["for","height-range",1,"block","mb-2","text-sm","font-medium","text-slate-700"],["min","32","max","90","id","height-range","step","1","showTickMarks","","discrete","",3,"displayWith"],["matSliderThumb","",3,"value","change"],["min","90","max","400","id","height-range","step","1","showTickMarks","","discrete","",3,"displayWith"],["min","18","max","120","id","height-range","step","1","showTickMarks","","discrete","",3,"displayWith"],[1,"justify-between","w-full","mb-3","items-center"],["id","male-radio","type","radio","value","male","checked","","name","default-radio",1,"w-4","h-4","text-blue-600","bg-gray-100","border-gray-300","focus:ring-blue-500","dark:focus:ring-blue-600","dark:ring-offset-gray-800","focus:ring-2","dark:bg-gray-700","dark:border-gray-600",3,"change"],["for","default-radio-1",1,"ml-2","pr-5","text-sm","font-medium","text-gray-900"],["id","female-radio","type","radio","value","female","name","default-radio",1,"w-4","h-4","text-blue-600","bg-gray-100","border-gray-300","focus:ring-blue-500","dark:focus:ring-blue-600","dark:ring-offset-gray-800","focus:ring-2","dark:bg-gray-700","dark:border-gray-600",3,"change"],["id","other-radio","type","radio","value","other","name","default-radio",1,"w-4","h-4","text-blue-600","bg-gray-100","border-gray-300","focus:ring-blue-500","dark:focus:ring-blue-600","dark:ring-offset-gray-800","focus:ring-2","dark:bg-gray-700","dark:border-gray-600",3,"change"],[1,"block","border","border-sky-500","justify-center","items-center","mb-3"],[1,"flex","justify-center","items-center","mb-3"],["data-tooltip-target","tooltip-default","id","prediction",1,"text-sm","font-bold","text-center","text-gray-900"],["id","prediction_value",1,"text-xl","p-2","font-bold","text-center","text-gray-900"],["id","prediction",1,"text-sm","font-bold","text-center","text-gray-900"]],template:function(e,s){1&e&&(At(0,"div",0)(1,"section",1)(2,"div",2)(3,"div")(4,"h3"),En(5,"Wheelchair Automated Measurement System"),Rt()(),At(6,"div",3)(7,"h1",4),En(8,"WAMS"),Rt()(),At(9,"form",5)(10,"div",6)(11,"label",7),En(12,"Height:"),Rt(),At(13,"label",8),En(14),Rt()(),At(15,"mat-slider",9)(16,"input",10),ms("change",function(i){return s.onChangeHeight(i)}),Rt()(),At(17,"div",6)(18,"label",7),En(19,"Weight:"),Rt(),At(20,"label",8),En(21),Rt()(),At(22,"mat-slider",11)(23,"input",10),ms("change",function(i){return s.onChangeWeight(i)}),Rt()(),At(24,"div",6)(25,"label",7),En(26,"Age:"),Rt(),At(27,"label",8),En(28),Rt()(),At(29,"mat-slider",12)(30,"input",10),ms("change",function(i){return s.onChangeAge(i)}),Rt()(),At(31,"div",6)(32,"label",7),En(33,"Gender:"),Rt()(),At(34,"div",13)(35,"input",14),ms("change",function(i){return s.onChangeGender(i)}),Rt(),At(36,"label",15),En(37,"Male"),Rt(),At(38,"input",16),ms("change",function(i){return s.onChangeGender(i)}),Rt(),At(39,"label",15),En(40,"Female"),Rt(),At(41,"input",17),ms("change",function(i){return s.onChangeGender(i)}),Rt(),At(42,"label",15),En(43,"Other"),Rt()(),At(44,"div",18)(45,"div",19)(46,"h2",20),En(47,"Hip Width Prediction:"),Rt(),At(48,"h1",21),En(49),Eg(50,"number"),Rt(),At(51,"p"),En(52,"inches"),Rt()(),At(53,"div",19)(54,"h2",22),En(55,"Upper Leg Prediction:"),Rt(),At(56,"h1",21),En(57),Eg(58,"number"),Rt(),At(59,"p"),En(60,"inches"),Rt()(),At(61,"div",19)(62,"h2",22),En(63,"Lower Leg Prediction:"),Rt(),At(64,"h1",21),En(65),Eg(66,"number"),Rt(),At(67,"p"),En(68,"inches"),Rt()()()()()()()),2&e&&(Qn(14),jx("",s.heightInInches," inches (",s.heightInFeetAndInches,")"),Qn(1),zr("displayWith",s.formatLabel),Qn(1),wh("value",s.heightInInches),Qn(5),Ch("",s.weightInPounds," lbs"),Qn(1),zr("displayWith",s.formatLabel),Qn(1),wh("value",s.weightInPounds),Qn(5),Ch("",s.age," y/o"),Qn(1),zr("displayWith",s.formatLabel),Qn(1),wh("value",s.age),Qn(19),_c(Dg(50,13,s.hipPredictionValue,"1.2-2")),Qn(8),_c(Dg(58,16,s.upperLegPredictionValue,"1.2-2")),Qn(8),_c(Dg(66,19,s.lowerLegPredictionValue,"1.2-2")))},dependencies:[PAe,iN,GO]}),n})();class M4{}class GAe{}const ya="*";function F4(n,t=null){return{type:2,steps:n,options:t}}function O4(n){return{type:6,styles:n,offset:null}}function $4(n){Promise.resolve().then(n)}class nm{constructor(t=0,e=0){this._onDoneFns=[],this._onStartFns=[],this._onDestroyFns=[],this._originalOnDoneFns=[],this._originalOnStartFns=[],this._started=!1,this._destroyed=!1,this._finished=!1,this._position=0,this.parentPlayer=null,this.totalTime=t+e}_onFinish(){this._finished||(this._finished=!0,this._onDoneFns.forEach(t=>t()),this._onDoneFns=[])}onStart(t){this._originalOnStartFns.push(t),this._onStartFns.push(t)}onDone(t){this._originalOnDoneFns.push(t),this._onDoneFns.push(t)}onDestroy(t){this._onDestroyFns.push(t)}hasStarted(){return this._started}init(){}play(){this.hasStarted()||(this._onStart(),this.triggerMicrotask()),this._started=!0}triggerMicrotask(){$4(()=>this._onFinish())}_onStart(){this._onStartFns.forEach(t=>t()),this._onStartFns=[]}pause(){}restart(){}finish(){this._onFinish()}destroy(){this._destroyed||(this._destroyed=!0,this.hasStarted()||this._onStart(),this.finish(),this._onDestroyFns.forEach(t=>t()),this._onDestroyFns=[])}reset(){this._started=!1,this._finished=!1,this._onStartFns=this._originalOnStartFns,this._onDoneFns=this._originalOnDoneFns}setPosition(t){this._position=this.totalTime?t*this.totalTime:1}getPosition(){return this.totalTime?this._position/this.totalTime:1}triggerCallback(t){const e="start"==t?this._onStartFns:this._onDoneFns;e.forEach(s=>s()),e.length=0}}class P4{constructor(t){this._onDoneFns=[],this._onStartFns=[],this._finished=!1,this._started=!1,this._destroyed=!1,this._onDestroyFns=[],this.parentPlayer=null,this.totalTime=0,this.players=t;let e=0,s=0,r=0;const i=this.players.length;0==i?$4(()=>this._onFinish()):this.players.forEach(o=>{o.onDone(()=>{++e==i&&this._onFinish()}),o.onDestroy(()=>{++s==i&&this._onDestroy()}),o.onStart(()=>{++r==i&&this._onStart()})}),this.totalTime=this.players.reduce((o,a)=>Math.max(o,a.totalTime),0)}_onFinish(){this._finished||(this._finished=!0,this._onDoneFns.forEach(t=>t()),this._onDoneFns=[])}init(){this.players.forEach(t=>t.init())}onStart(t){this._onStartFns.push(t)}_onStart(){this.hasStarted()||(this._started=!0,this._onStartFns.forEach(t=>t()),this._onStartFns=[])}onDone(t){this._onDoneFns.push(t)}onDestroy(t){this._onDestroyFns.push(t)}hasStarted(){return this._started}play(){this.parentPlayer||this.init(),this._onStart(),this.players.forEach(t=>t.play())}pause(){this.players.forEach(t=>t.pause())}restart(){this.players.forEach(t=>t.restart())}finish(){this._onFinish(),this.players.forEach(t=>t.finish())}destroy(){this._onDestroy()}_onDestroy(){this._destroyed||(this._destroyed=!0,this._onFinish(),this.players.forEach(t=>t.destroy()),this._onDestroyFns.forEach(t=>t()),this._onDestroyFns=[])}reset(){this.players.forEach(t=>t.reset()),this._destroyed=!1,this._finished=!1,this._started=!1}setPosition(t){const e=t*this.totalTime;this.players.forEach(s=>{const r=s.totalTime?Math.min(1,e/s.totalTime):1;s.setPosition(r)})}getPosition(){const t=this.players.reduce((e,s)=>null===e||s.totalTime>e.totalTime?s:e,null);return null!=t?t.getPosition():0}beforeDestroy(){this.players.forEach(t=>{t.beforeDestroy&&t.beforeDestroy()})}triggerCallback(t){const e="start"==t?this._onStartFns:this._onDoneFns;e.forEach(s=>s()),e.length=0}}const oN="!";function L4(n){return new ee(3e3,!1)}function vl(n){switch(n.length){case 0:return new nm;case 1:return n[0];default:return new P4(n)}}function V4(n,t,e,s,r=new Map,i=new Map){const o=[],a=[];let l=-1,u=null;if(s.forEach(c=>{const d=c.get("offset"),h=d==l,f=h&&u||new Map;c.forEach((p,g)=>{let m=g,y=p;if("offset"!==g)switch(m=t.normalizePropertyName(m,o),y){case oN:y=r.get(g);break;case ya:y=i.get(g);break;default:y=t.normalizeStyleValue(g,m,y,o)}f.set(m,y)}),h||a.push(f),u=f,l=d}),o.length)throw function fRe(n){return new ee(3502,!1)}();return a}function aN(n,t,e,s){switch(t){case"start":n.onStart(()=>s(e&&lN(e,"start",n)));break;case"done":n.onDone(()=>s(e&&lN(e,"done",n)));break;case"destroy":n.onDestroy(()=>s(e&&lN(e,"destroy",n)))}}function lN(n,t,e){const i=uN(n.element,n.triggerName,n.fromState,n.toState,t||n.phaseName,e.totalTime??n.totalTime,!!e.disabled),o=n._data;return null!=o&&(i._data=o),i}function uN(n,t,e,s,r="",i=0,o){return{element:n,triggerName:t,fromState:e,toState:s,phaseName:r,totalTime:i,disabled:!!o}}function ei(n,t,e){let s=n.get(t);return s||n.set(t,s=e),s}function B4(n){const t=n.indexOf(":");return[n.substring(1,t),n.slice(t+1)]}const IRe=(()=>typeof document>"u"?null:document.documentElement)();function cN(n){const t=n.parentNode||n.host||null;return t===IRe?null:t}let ku=null,z4=!1;function U4(n,t){for(;t;){if(t===n)return!0;t=cN(t)}return!1}function W4(n,t,e){if(e)return Array.from(n.querySelectorAll(t));const s=n.querySelector(t);return s?[s]:[]}let G4=(()=>{class n{validateStyleProperty(e){return function DRe(n){ku||(ku=function TRe(){return typeof document<"u"?document.body:null}()||{},z4=!!ku.style&&"WebkitAppearance"in ku.style);let t=!0;return ku.style&&!function ERe(n){return"ebkit"==n.substring(1,6)}(n)&&(t=n in ku.style,!t&&z4&&(t="Webkit"+n.charAt(0).toUpperCase()+n.slice(1)in ku.style)),t}(e)}matchesElement(e,s){return!1}containsElement(e,s){return U4(e,s)}getParentElement(e){return cN(e)}query(e,s,r){return W4(e,s,r)}computeStyle(e,s,r){return r||""}animate(e,s,r,i,o,a=[],l){return new nm(r,i)}}return n.\u0275fac=function(e){return new(e||n)},n.\u0275prov=Ve({token:n,factory:n.\u0275fac}),n})(),dN=(()=>{class n{}return n.NOOP=new G4,n})();const NRe=1e3,hN="ng-enter",w_="ng-leave",x_="ng-trigger",C_=".ng-trigger",j4="ng-animating",fN=".ng-animating";function ba(n){if("number"==typeof n)return n;const t=n.match(/^(-?[\.\d]+)(m?s)/);return!t||t.length<2?0:pN(parseFloat(t[1]),t[2])}function pN(n,t){return"s"===t?n*NRe:n}function S_(n,t,e){return n.hasOwnProperty("duration")?n:function ARe(n,t,e){let r,i=0,o="";if("string"==typeof n){const a=n.match(/^(-?[\.\d]+)(m?s)(?:\s+(-?[\.\d]+)(m?s))?(?:\s+([-a-z]+(?:\(.+?\))?))?$/i);if(null===a)return t.push(L4()),{duration:0,delay:0,easing:""};r=pN(parseFloat(a[1]),a[2]);const l=a[3];null!=l&&(i=pN(parseFloat(l),a[4]));const u=a[5];u&&(o=u)}else r=n;if(!e){let a=!1,l=t.length;r<0&&(t.push(function HAe(){return new ee(3100,!1)}()),a=!0),i<0&&(t.push(function jAe(){return new ee(3101,!1)}()),a=!0),a&&t.splice(l,0,L4())}return{duration:r,delay:i,easing:o}}(n,t,e)}function sm(n,t={}){return Object.keys(n).forEach(e=>{t[e]=n[e]}),t}function q4(n){const t=new Map;return Object.keys(n).forEach(e=>{t.set(e,n[e])}),t}function _l(n,t=new Map,e){if(e)for(let[s,r]of e)t.set(s,r);for(let[s,r]of n)t.set(s,r);return t}function Oo(n,t,e){t.forEach((s,r)=>{const i=gN(r);e&&!e.has(r)&&e.set(r,n.style[i]),n.style[i]=s})}function Au(n,t){t.forEach((e,s)=>{const r=gN(s);n.style[r]=""})}function rm(n){return Array.isArray(n)?1==n.length?n[0]:F4(n):n}const mN=new RegExp("{{\\s*(.+?)\\s*}}","g");function X4(n){let t=[];if("string"==typeof n){let e;for(;e=mN.exec(n);)t.push(e[1]);mN.lastIndex=0}return t}function im(n,t,e){const s=n.toString(),r=s.replace(mN,(i,o)=>{let a=t[o];return null==a&&(e.push(function KAe(n){return new ee(3003,!1)}()),a=""),a.toString()});return r==s?n:r}function I_(n){const t=[];let e=n.next();for(;!e.done;)t.push(e.value),e=n.next();return t}const FRe=/-+([a-z0-9])/g;function gN(n){return n.replace(FRe,(...t)=>t[1].toUpperCase())}function ti(n,t,e){switch(t.type){case 7:return n.visitTrigger(t,e);case 0:return n.visitState(t,e);case 1:return n.visitTransition(t,e);case 2:return n.visitSequence(t,e);case 3:return n.visitGroup(t,e);case 4:return n.visitAnimate(t,e);case 5:return n.visitKeyframes(t,e);case 6:return n.visitStyle(t,e);case 8:return n.visitReference(t,e);case 9:return n.visitAnimateChild(t,e);case 10:return n.visitAnimateRef(t,e);case 11:return n.visitQuery(t,e);case 12:return n.visitStagger(t,e);default:throw function XAe(n){return new ee(3004,!1)}()}}function Y4(n,t){return window.getComputedStyle(n)[t]}const E_="*";function PRe(n,t){const e=[];return"string"==typeof n?n.split(/\s*,\s*/).forEach(s=>function LRe(n,t,e){if(":"==n[0]){const l=function VRe(n,t){switch(n){case":enter":return"void => *";case":leave":return"* => void";case":increment":return(e,s)=>parseFloat(s)>parseFloat(e);case":decrement":return(e,s)=>parseFloat(s)<parseFloat(e);default:return t.push(function uRe(n){return new ee(3016,!1)}()),"* => *"}}(n,e);if("function"==typeof l)return void t.push(l);n=l}const s=n.match(/^(\*|[-\w]+)\s*(<?[=-]>)\s*(\*|[-\w]+)$/);if(null==s||s.length<4)return e.push(function lRe(n){return new ee(3015,!1)}()),t;const r=s[1],i=s[2],o=s[3];t.push(Z4(r,o));"<"==i[0]&&!(r==E_&&o==E_)&&t.push(Z4(o,r))}(s,e,t)):e.push(n),e}const D_=new Set(["true","1"]),T_=new Set(["false","0"]);function Z4(n,t){const e=D_.has(n)||T_.has(n),s=D_.has(t)||T_.has(t);return(r,i)=>{let o=n==E_||n==r,a=t==E_||t==i;return!o&&e&&"boolean"==typeof r&&(o=r?D_.has(n):T_.has(n)),!a&&s&&"boolean"==typeof i&&(a=i?D_.has(t):T_.has(t)),o&&a}}const BRe=new RegExp("s*:selfs*,?","g");function yN(n,t,e,s){return new zRe(n).build(t,e,s)}class zRe{constructor(t){this._driver=t}build(t,e,s){const r=new GRe(e);return this._resetContextStyleTimingState(r),ti(this,rm(t),r)}_resetContextStyleTimingState(t){t.currentQuerySelector="",t.collectedStyles=new Map,t.collectedStyles.set("",new Map),t.currentTime=0}visitTrigger(t,e){let s=e.queryCount=0,r=e.depCount=0;const i=[],o=[];return"@"==t.name.charAt(0)&&e.errors.push(function ZAe(){return new ee(3006,!1)}()),t.definitions.forEach(a=>{if(this._resetContextStyleTimingState(e),0==a.type){const l=a,u=l.name;u.toString().split(/\s*,\s*/).forEach(c=>{l.name=c,i.push(this.visitState(l,e))}),l.name=u}else if(1==a.type){const l=this.visitTransition(a,e);s+=l.queryCount,r+=l.depCount,o.push(l)}else e.errors.push(function QAe(){return new ee(3007,!1)}())}),{type:7,name:t.name,states:i,transitions:o,queryCount:s,depCount:r,options:null}}visitState(t,e){const s=this.visitStyle(t.styles,e),r=t.options&&t.options.params||null;if(s.containsDynamicStyles){const i=new Set,o=r||{};s.styles.forEach(a=>{a instanceof Map&&a.forEach(l=>{X4(l).forEach(u=>{o.hasOwnProperty(u)||i.add(u)})})}),i.size&&(I_(i.values()),e.errors.push(function JAe(n,t){return new ee(3008,!1)}()))}return{type:0,name:t.name,style:s,options:r?{params:r}:null}}visitTransition(t,e){e.queryCount=0,e.depCount=0;const s=ti(this,rm(t.animation),e);return{type:1,matchers:PRe(t.expr,e.errors),animation:s,queryCount:e.queryCount,depCount:e.depCount,options:Ru(t.options)}}visitSequence(t,e){return{type:2,steps:t.steps.map(s=>ti(this,s,e)),options:Ru(t.options)}}visitGroup(t,e){const s=e.currentTime;let r=0;const i=t.steps.map(o=>{e.currentTime=s;const a=ti(this,o,e);return r=Math.max(r,e.currentTime),a});return e.currentTime=r,{type:3,steps:i,options:Ru(t.options)}}visitAnimate(t,e){const s=function jRe(n,t){if(n.hasOwnProperty("duration"))return n;if("number"==typeof n)return bN(S_(n,t).duration,0,"");const e=n;if(e.split(/\s+/).some(i=>"{"==i.charAt(0)&&"{"==i.charAt(1))){const i=bN(0,0,"");return i.dynamic=!0,i.strValue=e,i}const r=S_(e,t);return bN(r.duration,r.delay,r.easing)}(t.timings,e.errors);e.currentAnimateTimings=s;let r,i=t.styles?t.styles:O4({});if(5==i.type)r=this.visitKeyframes(i,e);else{let o=t.styles,a=!1;if(!o){a=!0;const u={};s.easing&&(u.easing=s.easing),o=O4(u)}e.currentTime+=s.duration+s.delay;const l=this.visitStyle(o,e);l.isEmptyStep=a,r=l}return e.currentAnimateTimings=null,{type:4,timings:s,style:r,options:null}}visitStyle(t,e){const s=this._makeStyleAst(t,e);return this._validateStyleAst(s,e),s}_makeStyleAst(t,e){const s=[],r=Array.isArray(t.styles)?t.styles:[t.styles];for(let a of r)"string"==typeof a?a===ya?s.push(a):e.errors.push(new ee(3002,!1)):s.push(q4(a));let i=!1,o=null;return s.forEach(a=>{if(a instanceof Map&&(a.has("easing")&&(o=a.get("easing"),a.delete("easing")),!i))for(let l of a.values())if(l.toString().indexOf("{{")>=0){i=!0;break}}),{type:6,styles:s,easing:o,offset:t.offset,containsDynamicStyles:i,options:null}}_validateStyleAst(t,e){const s=e.currentAnimateTimings;let r=e.currentTime,i=e.currentTime;s&&i>0&&(i-=s.duration+s.delay),t.styles.forEach(o=>{"string"!=typeof o&&o.forEach((a,l)=>{const u=e.collectedStyles.get(e.currentQuerySelector),c=u.get(l);let d=!0;c&&(i!=r&&i>=c.startTime&&r<=c.endTime&&(e.errors.push(function tRe(n,t,e,s,r){return new ee(3010,!1)}()),d=!1),i=c.startTime),d&&u.set(l,{startTime:i,endTime:r}),e.options&&function MRe(n,t,e){const s=t.params||{},r=X4(n);r.length&&r.forEach(i=>{s.hasOwnProperty(i)||e.push(function qAe(n){return new ee(3001,!1)}())})}(a,e.options,e.errors)})})}visitKeyframes(t,e){const s={type:5,styles:[],options:null};if(!e.currentAnimateTimings)return e.errors.push(function nRe(){return new ee(3011,!1)}()),s;let i=0;const o=[];let a=!1,l=!1,u=0;const c=t.steps.map(y=>{const b=this._makeStyleAst(y,e);let v=null!=b.offset?b.offset:function HRe(n){if("string"==typeof n)return null;let t=null;if(Array.isArray(n))n.forEach(e=>{if(e instanceof Map&&e.has("offset")){const s=e;t=parseFloat(s.get("offset")),s.delete("offset")}});else if(n instanceof Map&&n.has("offset")){const e=n;t=parseFloat(e.get("offset")),e.delete("offset")}return t}(b.styles),_=0;return null!=v&&(i++,_=b.offset=v),l=l||_<0||_>1,a=a||_<u,u=_,o.push(_),b});l&&e.errors.push(function sRe(){return new ee(3012,!1)}()),a&&e.errors.push(function rRe(){return new ee(3200,!1)}());const d=t.steps.length;let h=0;i>0&&i<d?e.errors.push(function iRe(){return new ee(3202,!1)}()):0==i&&(h=1/(d-1));const f=d-1,p=e.currentTime,g=e.currentAnimateTimings,m=g.duration;return c.forEach((y,b)=>{const v=h>0?b==f?1:h*b:o[b],_=v*m;e.currentTime=p+g.delay+_,g.duration=_,this._validateStyleAst(y,e),y.offset=v,s.styles.push(y)}),s}visitReference(t,e){return{type:8,animation:ti(this,rm(t.animation),e),options:Ru(t.options)}}visitAnimateChild(t,e){return e.depCount++,{type:9,options:Ru(t.options)}}visitAnimateRef(t,e){return{type:10,animation:this.visitReference(t.animation,e),options:Ru(t.options)}}visitQuery(t,e){const s=e.currentQuerySelector,r=t.options||{};e.queryCount++,e.currentQuery=t;const[i,o]=function URe(n){const t=!!n.split(/\s*,\s*/).find(e=>":self"==e);return t&&(n=n.replace(BRe,"")),n=n.replace(/@\*/g,C_).replace(/@\w+/g,e=>C_+"-"+e.slice(1)).replace(/:animating/g,fN),[n,t]}(t.selector);e.currentQuerySelector=s.length?s+" "+i:i,ei(e.collectedStyles,e.currentQuerySelector,new Map);const a=ti(this,rm(t.animation),e);return e.currentQuery=null,e.currentQuerySelector=s,{type:11,selector:i,limit:r.limit||0,optional:!!r.optional,includeSelf:o,animation:a,originalSelector:t.selector,options:Ru(t.options)}}visitStagger(t,e){e.currentQuery||e.errors.push(function oRe(){return new ee(3013,!1)}());const s="full"===t.timings?{duration:0,delay:0,easing:"full"}:S_(t.timings,e.errors,!0);return{type:12,animation:ti(this,rm(t.animation),e),timings:s,options:null}}}class GRe{constructor(t){this.errors=t,this.queryCount=0,this.depCount=0,this.currentTransition=null,this.currentQuery=null,this.currentQuerySelector=null,this.currentAnimateTimings=null,this.currentTime=0,this.collectedStyles=new Map,this.options=null,this.unsupportedCSSPropertiesFound=new Set}}function Ru(n){return n?(n=sm(n)).params&&(n.params=function WRe(n){return n?sm(n):null}(n.params)):n={},n}function bN(n,t,e){return{duration:n,delay:t,easing:e}}function vN(n,t,e,s,r,i,o=null,a=!1){return{type:1,element:n,keyframes:t,preStyleProps:e,postStyleProps:s,duration:r,delay:i,totalTime:r+i,easing:o,subTimeline:a}}class N_{constructor(){this._map=new Map}get(t){return this._map.get(t)||[]}append(t,e){let s=this._map.get(t);s||this._map.set(t,s=[]),s.push(...e)}has(t){return this._map.has(t)}clear(){this._map.clear()}}const XRe=new RegExp(":enter","g"),ZRe=new RegExp(":leave","g");function _N(n,t,e,s,r,i=new Map,o=new Map,a,l,u=[]){return(new QRe).buildKeyframes(n,t,e,s,r,i,o,a,l,u)}class QRe{buildKeyframes(t,e,s,r,i,o,a,l,u,c=[]){u=u||new N_;const d=new wN(t,e,u,r,i,c,[]);d.options=l;const h=l.delay?ba(l.delay):0;d.currentTimeline.delayNextStep(h),d.currentTimeline.setStyles([o],null,d.errors,l),ti(this,s,d);const f=d.timelines.filter(p=>p.containsAnimation());if(f.length&&a.size){let p;for(let g=f.length-1;g>=0;g--){const m=f[g];if(m.element===e){p=m;break}}p&&!p.allowOnlyTimelineStyles()&&p.setStyles([a],null,d.errors,l)}return f.length?f.map(p=>p.buildKeyframes()):[vN(e,[],[],[],0,h,"",!1)]}visitTrigger(t,e){}visitState(t,e){}visitTransition(t,e){}visitAnimateChild(t,e){const s=e.subInstructions.get(e.element);if(s){const r=e.createSubContext(t.options),i=e.currentTimeline.currentTime,o=this._visitSubInstructions(s,r,r.options);i!=o&&e.transformIntoNewTimeline(o)}e.previousNode=t}visitAnimateRef(t,e){const s=e.createSubContext(t.options);s.transformIntoNewTimeline(),this._applyAnimationRefDelays([t.options,t.animation.options],e,s),this.visitReference(t.animation,s),e.transformIntoNewTimeline(s.currentTimeline.currentTime),e.previousNode=t}_applyAnimationRefDelays(t,e,s){for(const r of t){const i=r?.delay;if(i){const o="number"==typeof i?i:ba(im(i,r?.params??{},e.errors));s.delayNextStep(o)}}}_visitSubInstructions(t,e,s){let i=e.currentTimeline.currentTime;const o=null!=s.duration?ba(s.duration):null,a=null!=s.delay?ba(s.delay):null;return 0!==o&&t.forEach(l=>{const u=e.appendInstructionToTimeline(l,o,a);i=Math.max(i,u.duration+u.delay)}),i}visitReference(t,e){e.updateOptions(t.options,!0),ti(this,t.animation,e),e.previousNode=t}visitSequence(t,e){const s=e.subContextCount;let r=e;const i=t.options;if(i&&(i.params||i.delay)&&(r=e.createSubContext(i),r.transformIntoNewTimeline(),null!=i.delay)){6==r.previousNode.type&&(r.currentTimeline.snapshotCurrentStyles(),r.previousNode=k_);const o=ba(i.delay);r.delayNextStep(o)}t.steps.length&&(t.steps.forEach(o=>ti(this,o,r)),r.currentTimeline.applyStylesToKeyframe(),r.subContextCount>s&&r.transformIntoNewTimeline()),e.previousNode=t}visitGroup(t,e){const s=[];let r=e.currentTimeline.currentTime;const i=t.options&&t.options.delay?ba(t.options.delay):0;t.steps.forEach(o=>{const a=e.createSubContext(t.options);i&&a.delayNextStep(i),ti(this,o,a),r=Math.max(r,a.currentTimeline.currentTime),s.push(a.currentTimeline)}),s.forEach(o=>e.currentTimeline.mergeTimelineCollectedStyles(o)),e.transformIntoNewTimeline(r),e.previousNode=t}_visitTiming(t,e){if(t.dynamic){const s=t.strValue;return S_(e.params?im(s,e.params,e.errors):s,e.errors)}return{duration:t.duration,delay:t.delay,easing:t.easing}}visitAnimate(t,e){const s=e.currentAnimateTimings=this._visitTiming(t.timings,e),r=e.currentTimeline;s.delay&&(e.incrementTime(s.delay),r.snapshotCurrentStyles());const i=t.style;5==i.type?this.visitKeyframes(i,e):(e.incrementTime(s.duration),this.visitStyle(i,e),r.applyStylesToKeyframe()),e.currentAnimateTimings=null,e.previousNode=t}visitStyle(t,e){const s=e.currentTimeline,r=e.currentAnimateTimings;!r&&s.hasCurrentStyleProperties()&&s.forwardFrame();const i=r&&r.easing||t.easing;t.isEmptyStep?s.applyEmptyStep(i):s.setStyles(t.styles,i,e.errors,e.options),e.previousNode=t}visitKeyframes(t,e){const s=e.currentAnimateTimings,r=e.currentTimeline.duration,i=s.duration,a=e.createSubContext().currentTimeline;a.easing=s.easing,t.styles.forEach(l=>{a.forwardTime((l.offset||0)*i),a.setStyles(l.styles,l.easing,e.errors,e.options),a.applyStylesToKeyframe()}),e.currentTimeline.mergeTimelineCollectedStyles(a),e.transformIntoNewTimeline(r+i),e.previousNode=t}visitQuery(t,e){const s=e.currentTimeline.currentTime,r=t.options||{},i=r.delay?ba(r.delay):0;i&&(6===e.previousNode.type||0==s&&e.currentTimeline.hasCurrentStyleProperties())&&(e.currentTimeline.snapshotCurrentStyles(),e.previousNode=k_);let o=s;const a=e.invokeQuery(t.selector,t.originalSelector,t.limit,t.includeSelf,!!r.optional,e.errors);e.currentQueryTotal=a.length;let l=null;a.forEach((u,c)=>{e.currentQueryIndex=c;const d=e.createSubContext(t.options,u);i&&d.delayNextStep(i),u===e.element&&(l=d.currentTimeline),ti(this,t.animation,d),d.currentTimeline.applyStylesToKeyframe(),o=Math.max(o,d.currentTimeline.currentTime)}),e.currentQueryIndex=0,e.currentQueryTotal=0,e.transformIntoNewTimeline(o),l&&(e.currentTimeline.mergeTimelineCollectedStyles(l),e.currentTimeline.snapshotCurrentStyles()),e.previousNode=t}visitStagger(t,e){const s=e.parentContext,r=e.currentTimeline,i=t.timings,o=Math.abs(i.duration),a=o*(e.currentQueryTotal-1);let l=o*e.currentQueryIndex;switch(i.duration<0?"reverse":i.easing){case"reverse":l=a-l;break;case"full":l=s.currentStaggerTime}const c=e.currentTimeline;l&&c.delayNextStep(l);const d=c.currentTime;ti(this,t.animation,e),e.previousNode=t,s.currentStaggerTime=r.currentTime-d+(r.startTime-s.currentTimeline.startTime)}}const k_={};class wN{constructor(t,e,s,r,i,o,a,l){this._driver=t,this.element=e,this.subInstructions=s,this._enterClassName=r,this._leaveClassName=i,this.errors=o,this.timelines=a,this.parentContext=null,this.currentAnimateTimings=null,this.previousNode=k_,this.subContextCount=0,this.options={},this.currentQueryIndex=0,this.currentQueryTotal=0,this.currentStaggerTime=0,this.currentTimeline=l||new A_(this._driver,e,0),a.push(this.currentTimeline)}get params(){return this.options.params}updateOptions(t,e){if(!t)return;const s=t;let r=this.options;null!=s.duration&&(r.duration=ba(s.duration)),null!=s.delay&&(r.delay=ba(s.delay));const i=s.params;if(i){let o=r.params;o||(o=this.options.params={}),Object.keys(i).forEach(a=>{(!e||!o.hasOwnProperty(a))&&(o[a]=im(i[a],o,this.errors))})}}_copyOptions(){const t={};if(this.options){const e=this.options.params;if(e){const s=t.params={};Object.keys(e).forEach(r=>{s[r]=e[r]})}}return t}createSubContext(t=null,e,s){const r=e||this.element,i=new wN(this._driver,r,this.subInstructions,this._enterClassName,this._leaveClassName,this.errors,this.timelines,this.currentTimeline.fork(r,s||0));return i.previousNode=this.previousNode,i.currentAnimateTimings=this.currentAnimateTimings,i.options=this._copyOptions(),i.updateOptions(t),i.currentQueryIndex=this.currentQueryIndex,i.currentQueryTotal=this.currentQueryTotal,i.parentContext=this,this.subContextCount++,i}transformIntoNewTimeline(t){return this.previousNode=k_,this.currentTimeline=this.currentTimeline.fork(this.element,t),this.timelines.push(this.currentTimeline),this.currentTimeline}appendInstructionToTimeline(t,e,s){const r={duration:e??t.duration,delay:this.currentTimeline.currentTime+(s??0)+t.delay,easing:""},i=new JRe(this._driver,t.element,t.keyframes,t.preStyleProps,t.postStyleProps,r,t.stretchStartingKeyframe);return this.timelines.push(i),r}incrementTime(t){this.currentTimeline.forwardTime(this.currentTimeline.duration+t)}delayNextStep(t){t>0&&this.currentTimeline.delayNextStep(t)}invokeQuery(t,e,s,r,i,o){let a=[];if(r&&a.push(this.element),t.length>0){t=(t=t.replace(XRe,"."+this._enterClassName)).replace(ZRe,"."+this._leaveClassName);let u=this._driver.query(this.element,t,1!=s);0!==s&&(u=s<0?u.slice(u.length+s,u.length):u.slice(0,s)),a.push(...u)}return!i&&0==a.length&&o.push(function aRe(n){return new ee(3014,!1)}()),a}}class A_{constructor(t,e,s,r){this._driver=t,this.element=e,this.startTime=s,this._elementTimelineStylesLookup=r,this.duration=0,this.easing=null,this._previousKeyframe=new Map,this._currentKeyframe=new Map,this._keyframes=new Map,this._styleSummary=new Map,this._localTimelineStyles=new Map,this._pendingStyles=new Map,this._backFill=new Map,this._currentEmptyStepKeyframe=null,this._elementTimelineStylesLookup||(this._elementTimelineStylesLookup=new Map),this._globalTimelineStyles=this._elementTimelineStylesLookup.get(e),this._globalTimelineStyles||(this._globalTimelineStyles=this._localTimelineStyles,this._elementTimelineStylesLookup.set(e,this._localTimelineStyles)),this._loadKeyframe()}containsAnimation(){switch(this._keyframes.size){case 0:return!1;case 1:return this.hasCurrentStyleProperties();default:return!0}}hasCurrentStyleProperties(){return this._currentKeyframe.size>0}get currentTime(){return this.startTime+this.duration}delayNextStep(t){const e=1===this._keyframes.size&&this._pendingStyles.size;this.duration||e?(this.forwardTime(this.currentTime+t),e&&this.snapshotCurrentStyles()):this.startTime+=t}fork(t,e){return this.applyStylesToKeyframe(),new A_(this._driver,t,e||this.currentTime,this._elementTimelineStylesLookup)}_loadKeyframe(){this._currentKeyframe&&(this._previousKeyframe=this._currentKeyframe),this._currentKeyframe=this._keyframes.get(this.duration),this._currentKeyframe||(this._currentKeyframe=new Map,this._keyframes.set(this.duration,this._currentKeyframe))}forwardFrame(){this.duration+=1,this._loadKeyframe()}forwardTime(t){this.applyStylesToKeyframe(),this.duration=t,this._loadKeyframe()}_updateStyle(t,e){this._localTimelineStyles.set(t,e),this._globalTimelineStyles.set(t,e),this._styleSummary.set(t,{time:this.currentTime,value:e})}allowOnlyTimelineStyles(){return this._currentEmptyStepKeyframe!==this._currentKeyframe}applyEmptyStep(t){t&&this._previousKeyframe.set("easing",t);for(let[e,s]of this._globalTimelineStyles)this._backFill.set(e,s||ya),this._currentKeyframe.set(e,ya);this._currentEmptyStepKeyframe=this._currentKeyframe}setStyles(t,e,s,r){e&&this._previousKeyframe.set("easing",e);const i=r&&r.params||{},o=function eMe(n,t){const e=new Map;let s;return n.forEach(r=>{if("*"===r){s=s||t.keys();for(let i of s)e.set(i,ya)}else _l(r,e)}),e}(t,this._globalTimelineStyles);for(let[a,l]of o){const u=im(l,i,s);this._pendingStyles.set(a,u),this._localTimelineStyles.has(a)||this._backFill.set(a,this._globalTimelineStyles.get(a)??ya),this._updateStyle(a,u)}}applyStylesToKeyframe(){0!=this._pendingStyles.size&&(this._pendingStyles.forEach((t,e)=>{this._currentKeyframe.set(e,t)}),this._pendingStyles.clear(),this._localTimelineStyles.forEach((t,e)=>{this._currentKeyframe.has(e)||this._currentKeyframe.set(e,t)}))}snapshotCurrentStyles(){for(let[t,e]of this._localTimelineStyles)this._pendingStyles.set(t,e),this._updateStyle(t,e)}getFinalKeyframe(){return this._keyframes.get(this.duration)}get properties(){const t=[];for(let e in this._currentKeyframe)t.push(e);return t}mergeTimelineCollectedStyles(t){t._styleSummary.forEach((e,s)=>{const r=this._styleSummary.get(s);(!r||e.time>r.time)&&this._updateStyle(s,e.value)})}buildKeyframes(){this.applyStylesToKeyframe();const t=new Set,e=new Set,s=1===this._keyframes.size&&0===this.duration;let r=[];this._keyframes.forEach((a,l)=>{const u=_l(a,new Map,this._backFill);u.forEach((c,d)=>{c===oN?t.add(d):c===ya&&e.add(d)}),s||u.set("offset",l/this.duration),r.push(u)});const i=t.size?I_(t.values()):[],o=e.size?I_(e.values()):[];if(s){const a=r[0],l=new Map(a);a.set("offset",0),l.set("offset",1),r=[a,l]}return vN(this.element,r,i,o,this.duration,this.startTime,this.easing,!1)}}class JRe extends A_{constructor(t,e,s,r,i,o,a=!1){super(t,e,o.delay),this.keyframes=s,this.preStyleProps=r,this.postStyleProps=i,this._stretchStartingKeyframe=a,this.timings={duration:o.duration,delay:o.delay,easing:o.easing}}containsAnimation(){return this.keyframes.length>1}buildKeyframes(){let t=this.keyframes,{delay:e,duration:s,easing:r}=this.timings;if(this._stretchStartingKeyframe&&e){const i=[],o=s+e,a=e/o,l=_l(t[0]);l.set("offset",0),i.push(l);const u=_l(t[0]);u.set("offset",eG(a)),i.push(u);const c=t.length-1;for(let d=1;d<=c;d++){let h=_l(t[d]);const f=h.get("offset");h.set("offset",eG((e+f*s)/o)),i.push(h)}s=o,e=0,r="",t=i}return vN(this.element,t,this.preStyleProps,this.postStyleProps,s,e,r,!0)}}function eG(n,t=3){const e=Math.pow(10,t-1);return Math.round(n*e)/e}class xN{}const tMe=new Set(["width","height","minWidth","minHeight","maxWidth","maxHeight","left","top","bottom","right","fontSize","outlineWidth","outlineOffset","paddingTop","paddingLeft","paddingBottom","paddingRight","marginTop","marginLeft","marginBottom","marginRight","borderRadius","borderWidth","borderTopWidth","borderLeftWidth","borderRightWidth","borderBottomWidth","textIndent","perspective"]);class nMe extends xN{normalizePropertyName(t,e){return gN(t)}normalizeStyleValue(t,e,s,r){let i="";const o=s.toString().trim();if(tMe.has(e)&&0!==s&&"0"!==s)if("number"==typeof s)i="px";else{const a=s.match(/^[+-]?[\d\.]+([a-z]*)$/);a&&0==a[1].length&&r.push(function YAe(n,t){return new ee(3005,!1)}())}return o+i}}function tG(n,t,e,s,r,i,o,a,l,u,c,d,h){return{type:0,element:n,triggerName:t,isRemovalTransition:r,fromState:e,fromStyles:i,toState:s,toStyles:o,timelines:a,queriedElements:l,preStyleProps:u,postStyleProps:c,totalTime:d,errors:h}}const CN={};class nG{constructor(t,e,s){this._triggerName=t,this.ast=e,this._stateStyles=s}match(t,e,s,r){return function sMe(n,t,e,s,r){return n.some(i=>i(t,e,s,r))}(this.ast.matchers,t,e,s,r)}buildStyles(t,e,s){let r=this._stateStyles.get("*");return void 0!==t&&(r=this._stateStyles.get(t?.toString())||r),r?r.buildStyles(e,s):new Map}build(t,e,s,r,i,o,a,l,u,c){const d=[],h=this.ast.options&&this.ast.options.params||CN,p=this.buildStyles(s,a&&a.params||CN,d),g=l&&l.params||CN,m=this.buildStyles(r,g,d),y=new Set,b=new Map,v=new Map,_="void"===r,x={params:rMe(g,h),delay:this.ast.options?.delay},C=c?[]:_N(t,e,this.ast.animation,i,o,p,m,x,u,d);let E=0;if(C.forEach(N=>{E=Math.max(N.duration+N.delay,E)}),d.length)return tG(e,this._triggerName,s,r,_,p,m,[],[],b,v,E,d);C.forEach(N=>{const R=N.element,V=ei(b,R,new Set);N.preStyleProps.forEach(j=>V.add(j));const G=ei(v,R,new Set);N.postStyleProps.forEach(j=>G.add(j)),R!==e&&y.add(R)});const D=I_(y.values());return tG(e,this._triggerName,s,r,_,p,m,C,D,b,v,E)}}function rMe(n,t){const e=sm(t);for(const s in n)n.hasOwnProperty(s)&&null!=n[s]&&(e[s]=n[s]);return e}class iMe{constructor(t,e,s){this.styles=t,this.defaultParams=e,this.normalizer=s}buildStyles(t,e){const s=new Map,r=sm(this.defaultParams);return Object.keys(t).forEach(i=>{const o=t[i];null!==o&&(r[i]=o)}),this.styles.styles.forEach(i=>{"string"!=typeof i&&i.forEach((o,a)=>{o&&(o=im(o,r,e));const l=this.normalizer.normalizePropertyName(a,e);o=this.normalizer.normalizeStyleValue(a,l,o,e),s.set(a,o)})}),s}}class aMe{constructor(t,e,s){this.name=t,this.ast=e,this._normalizer=s,this.transitionFactories=[],this.states=new Map,e.states.forEach(r=>{this.states.set(r.name,new iMe(r.style,r.options&&r.options.params||{},s))}),sG(this.states,"true","1"),sG(this.states,"false","0"),e.transitions.forEach(r=>{this.transitionFactories.push(new nG(t,r,this.states))}),this.fallbackTransition=function lMe(n,t,e){return new nG(n,{type:1,animation:{type:2,steps:[],options:null},matchers:[(o,a)=>!0],options:null,queryCount:0,depCount:0},t)}(t,this.states)}get containsQueries(){return this.ast.queryCount>0}matchTransition(t,e,s,r){return this.transitionFactories.find(o=>o.match(t,e,s,r))||null}matchStyles(t,e,s){return this.fallbackTransition.buildStyles(t,e,s)}}function sG(n,t,e){n.has(t)?n.has(e)||n.set(e,n.get(t)):n.has(e)&&n.set(t,n.get(e))}const uMe=new N_;class cMe{constructor(t,e,s){this.bodyNode=t,this._driver=e,this._normalizer=s,this._animations=new Map,this._playersById=new Map,this.players=[]}register(t,e){const s=[],i=yN(this._driver,e,s,[]);if(s.length)throw function pRe(n){return new ee(3503,!1)}();this._animations.set(t,i)}_buildPlayer(t,e,s){const r=t.element,i=V4(0,this._normalizer,0,t.keyframes,e,s);return this._driver.animate(r,i,t.duration,t.delay,t.easing,[],!0)}create(t,e,s={}){const r=[],i=this._animations.get(t);let o;const a=new Map;if(i?(o=_N(this._driver,e,i,hN,w_,new Map,new Map,s,uMe,r),o.forEach(c=>{const d=ei(a,c.element,new Map);c.postStyleProps.forEach(h=>d.set(h,null))})):(r.push(function mRe(){return new ee(3300,!1)}()),o=[]),r.length)throw function gRe(n){return new ee(3504,!1)}();a.forEach((c,d)=>{c.forEach((h,f)=>{c.set(f,this._driver.computeStyle(d,f,ya))})});const u=vl(o.map(c=>{const d=a.get(c.element);return this._buildPlayer(c,new Map,d)}));return this._playersById.set(t,u),u.onDestroy(()=>this.destroy(t)),this.players.push(u),u}destroy(t){const e=this._getPlayer(t);e.destroy(),this._playersById.delete(t);const s=this.players.indexOf(e);s>=0&&this.players.splice(s,1)}_getPlayer(t){const e=this._playersById.get(t);if(!e)throw function yRe(n){return new ee(3301,!1)}();return e}listen(t,e,s,r){const i=uN(e,"","","");return aN(this._getPlayer(t),s,i,r),()=>{}}command(t,e,s,r){if("register"==s)return void this.register(t,r[0]);if("create"==s)return void this.create(t,e,r[0]||{});const i=this._getPlayer(t);switch(s){case"play":i.play();break;case"pause":i.pause();break;case"reset":i.reset();break;case"restart":i.restart();break;case"finish":i.finish();break;case"init":i.init();break;case"setPosition":i.setPosition(parseFloat(r[0]));break;case"destroy":this.destroy(t)}}}const rG="ng-animate-queued",SN="ng-animate-disabled",mMe=[],iG={namespaceId:"",setForRemoval:!1,setForMove:!1,hasAnimation:!1,removedBeforeQueried:!1},gMe={namespaceId:"",setForMove:!1,setForRemoval:!1,hasAnimation:!1,removedBeforeQueried:!0},Ei="__ng_removed";class IN{get params(){return this.options.params}constructor(t,e=""){this.namespaceId=e;const s=t&&t.hasOwnProperty("value");if(this.value=function _Me(n){return n??null}(s?t.value:t),s){const i=sm(t);delete i.value,this.options=i}else this.options={};this.options.params||(this.options.params={})}absorbOptions(t){const e=t.params;if(e){const s=this.options.params;Object.keys(e).forEach(r=>{null==s[r]&&(s[r]=e[r])})}}}const om="void",EN=new IN(om);class yMe{constructor(t,e,s){this.id=t,this.hostElement=e,this._engine=s,this.players=[],this._triggers=new Map,this._queue=[],this._elementListeners=new Map,this._hostClassName="ng-tns-"+t,Di(e,this._hostClassName)}listen(t,e,s,r){if(!this._triggers.has(e))throw function bRe(n,t){return new ee(3302,!1)}();if(null==s||0==s.length)throw function vRe(n){return new ee(3303,!1)}();if(!function wMe(n){return"start"==n||"done"==n}(s))throw function _Re(n,t){return new ee(3400,!1)}();const i=ei(this._elementListeners,t,[]),o={name:e,phase:s,callback:r};i.push(o);const a=ei(this._engine.statesByElement,t,new Map);return a.has(e)||(Di(t,x_),Di(t,x_+"-"+e),a.set(e,EN)),()=>{this._engine.afterFlush(()=>{const l=i.indexOf(o);l>=0&&i.splice(l,1),this._triggers.has(e)||a.delete(e)})}}register(t,e){return!this._triggers.has(t)&&(this._triggers.set(t,e),!0)}_getTrigger(t){const e=this._triggers.get(t);if(!e)throw function wRe(n){return new ee(3401,!1)}();return e}trigger(t,e,s,r=!0){const i=this._getTrigger(e),o=new DN(this.id,e,t);let a=this._engine.statesByElement.get(t);a||(Di(t,x_),Di(t,x_+"-"+e),this._engine.statesByElement.set(t,a=new Map));let l=a.get(e);const u=new IN(s,this.id);if(!(s&&s.hasOwnProperty("value"))&&l&&u.absorbOptions(l.options),a.set(e,u),l||(l=EN),u.value!==om&&l.value===u.value){if(!function SMe(n,t){const e=Object.keys(n),s=Object.keys(t);if(e.length!=s.length)return!1;for(let r=0;r<e.length;r++){const i=e[r];if(!t.hasOwnProperty(i)||n[i]!==t[i])return!1}return!0}(l.params,u.params)){const g=[],m=i.matchStyles(l.value,l.params,g),y=i.matchStyles(u.value,u.params,g);g.length?this._engine.reportError(g):this._engine.afterFlush(()=>{Au(t,m),Oo(t,y)})}return}const h=ei(this._engine.playersByElement,t,[]);h.forEach(g=>{g.namespaceId==this.id&&g.triggerName==e&&g.queued&&g.destroy()});let f=i.matchTransition(l.value,u.value,t,u.params),p=!1;if(!f){if(!r)return;f=i.fallbackTransition,p=!0}return this._engine.totalQueuedPlayers++,this._queue.push({element:t,triggerName:e,transition:f,fromState:l,toState:u,player:o,isFallbackTransition:p}),p||(Di(t,rG),o.onStart(()=>{Rd(t,rG)})),o.onDone(()=>{let g=this.players.indexOf(o);g>=0&&this.players.splice(g,1);const m=this._engine.playersByElement.get(t);if(m){let y=m.indexOf(o);y>=0&&m.splice(y,1)}}),this.players.push(o),h.push(o),o}deregister(t){this._triggers.delete(t),this._engine.statesByElement.forEach(e=>e.delete(t)),this._elementListeners.forEach((e,s)=>{this._elementListeners.set(s,e.filter(r=>r.name!=t))})}clearElementCache(t){this._engine.statesByElement.delete(t),this._elementListeners.delete(t);const e=this._engine.playersByElement.get(t);e&&(e.forEach(s=>s.destroy()),this._engine.playersByElement.delete(t))}_signalRemovalForInnerTriggers(t,e){const s=this._engine.driver.query(t,C_,!0);s.forEach(r=>{if(r[Ei])return;const i=this._engine.fetchNamespacesByElement(r);i.size?i.forEach(o=>o.triggerLeaveAnimation(r,e,!1,!0)):this.clearElementCache(r)}),this._engine.afterFlushAnimationsDone(()=>s.forEach(r=>this.clearElementCache(r)))}triggerLeaveAnimation(t,e,s,r){const i=this._engine.statesByElement.get(t),o=new Map;if(i){const a=[];if(i.forEach((l,u)=>{if(o.set(u,l.value),this._triggers.has(u)){const c=this.trigger(t,u,om,r);c&&a.push(c)}}),a.length)return this._engine.markElementAsRemoved(this.id,t,!0,e,o),s&&vl(a).onDone(()=>this._engine.processLeaveNode(t)),!0}return!1}prepareLeaveAnimationListeners(t){const e=this._elementListeners.get(t),s=this._engine.statesByElement.get(t);if(e&&s){const r=new Set;e.forEach(i=>{const o=i.name;if(r.has(o))return;r.add(o);const l=this._triggers.get(o).fallbackTransition,u=s.get(o)||EN,c=new IN(om),d=new DN(this.id,o,t);this._engine.totalQueuedPlayers++,this._queue.push({element:t,triggerName:o,transition:l,fromState:u,toState:c,player:d,isFallbackTransition:!0})})}}removeNode(t,e){const s=this._engine;if(t.childElementCount&&this._signalRemovalForInnerTriggers(t,e),this.triggerLeaveAnimation(t,e,!0))return;let r=!1;if(s.totalAnimations){const i=s.players.length?s.playersByQueriedElement.get(t):[];if(i&&i.length)r=!0;else{let o=t;for(;o=o.parentNode;)if(s.statesByElement.get(o)){r=!0;break}}}if(this.prepareLeaveAnimationListeners(t),r)s.markElementAsRemoved(this.id,t,!1,e);else{const i=t[Ei];(!i||i===iG)&&(s.afterFlush(()=>this.clearElementCache(t)),s.destroyInnerAnimations(t),s._onRemovalComplete(t,e))}}insertNode(t,e){Di(t,this._hostClassName)}drainQueuedTransitions(t){const e=[];return this._queue.forEach(s=>{const r=s.player;if(r.destroyed)return;const i=s.element,o=this._elementListeners.get(i);o&&o.forEach(a=>{if(a.name==s.triggerName){const l=uN(i,s.triggerName,s.fromState.value,s.toState.value);l._data=t,aN(s.player,a.phase,l,a.callback)}}),r.markedForDestroy?this._engine.afterFlush(()=>{r.destroy()}):e.push(s)}),this._queue=[],e.sort((s,r)=>{const i=s.transition.ast.depCount,o=r.transition.ast.depCount;return 0==i||0==o?i-o:this._engine.driver.containsElement(s.element,r.element)?1:-1})}destroy(t){this.players.forEach(e=>e.destroy()),this._signalRemovalForInnerTriggers(this.hostElement,t)}elementContainsData(t){let e=!1;return this._elementListeners.has(t)&&(e=!0),e=!!this._queue.find(s=>s.element===t)||e,e}}class bMe{_onRemovalComplete(t,e){this.onRemovalComplete(t,e)}constructor(t,e,s){this.bodyNode=t,this.driver=e,this._normalizer=s,this.players=[],this.newHostElements=new Map,this.playersByElement=new Map,this.playersByQueriedElement=new Map,this.statesByElement=new Map,this.disabledNodes=new Set,this.totalAnimations=0,this.totalQueuedPlayers=0,this._namespaceLookup={},this._namespaceList=[],this._flushFns=[],this._whenQuietFns=[],this.namespacesByHostElement=new Map,this.collectedEnterElements=[],this.collectedLeaveElements=[],this.onRemovalComplete=(r,i)=>{}}get queuedPlayers(){const t=[];return this._namespaceList.forEach(e=>{e.players.forEach(s=>{s.queued&&t.push(s)})}),t}createNamespace(t,e){const s=new yMe(t,e,this);return this.bodyNode&&this.driver.containsElement(this.bodyNode,e)?this._balanceNamespaceList(s,e):(this.newHostElements.set(e,s),this.collectEnterElement(e)),this._namespaceLookup[t]=s}_balanceNamespaceList(t,e){const s=this._namespaceList,r=this.namespacesByHostElement;if(s.length-1>=0){let o=!1,a=this.driver.getParentElement(e);for(;a;){const l=r.get(a);if(l){const u=s.indexOf(l);s.splice(u+1,0,t),o=!0;break}a=this.driver.getParentElement(a)}o||s.unshift(t)}else s.push(t);return r.set(e,t),t}register(t,e){let s=this._namespaceLookup[t];return s||(s=this.createNamespace(t,e)),s}registerTrigger(t,e,s){let r=this._namespaceLookup[t];r&&r.register(e,s)&&this.totalAnimations++}destroy(t,e){if(!t)return;const s=this._fetchNamespace(t);this.afterFlush(()=>{this.namespacesByHostElement.delete(s.hostElement),delete this._namespaceLookup[t];const r=this._namespaceList.indexOf(s);r>=0&&this._namespaceList.splice(r,1)}),this.afterFlushAnimationsDone(()=>s.destroy(e))}_fetchNamespace(t){return this._namespaceLookup[t]}fetchNamespacesByElement(t){const e=new Set,s=this.statesByElement.get(t);if(s)for(let r of s.values())if(r.namespaceId){const i=this._fetchNamespace(r.namespaceId);i&&e.add(i)}return e}trigger(t,e,s,r){if(R_(e)){const i=this._fetchNamespace(t);if(i)return i.trigger(e,s,r),!0}return!1}insertNode(t,e,s,r){if(!R_(e))return;const i=e[Ei];if(i&&i.setForRemoval){i.setForRemoval=!1,i.setForMove=!0;const o=this.collectedLeaveElements.indexOf(e);o>=0&&this.collectedLeaveElements.splice(o,1)}if(t){const o=this._fetchNamespace(t);o&&o.insertNode(e,s)}r&&this.collectEnterElement(e)}collectEnterElement(t){this.collectedEnterElements.push(t)}markElementAsDisabled(t,e){e?this.disabledNodes.has(t)||(this.disabledNodes.add(t),Di(t,SN)):this.disabledNodes.has(t)&&(this.disabledNodes.delete(t),Rd(t,SN))}removeNode(t,e,s,r){if(R_(e)){const i=t?this._fetchNamespace(t):null;if(i?i.removeNode(e,r):this.markElementAsRemoved(t,e,!1,r),s){const o=this.namespacesByHostElement.get(e);o&&o.id!==t&&o.removeNode(e,r)}}else this._onRemovalComplete(e,r)}markElementAsRemoved(t,e,s,r,i){this.collectedLeaveElements.push(e),e[Ei]={namespaceId:t,setForRemoval:r,hasAnimation:s,removedBeforeQueried:!1,previousTriggersValues:i}}listen(t,e,s,r,i){return R_(e)?this._fetchNamespace(t).listen(e,s,r,i):()=>{}}_buildInstruction(t,e,s,r,i){return t.transition.build(this.driver,t.element,t.fromState.value,t.toState.value,s,r,t.fromState.options,t.toState.options,e,i)}destroyInnerAnimations(t){let e=this.driver.query(t,C_,!0);e.forEach(s=>this.destroyActiveAnimationsForElement(s)),0!=this.playersByQueriedElement.size&&(e=this.driver.query(t,fN,!0),e.forEach(s=>this.finishActiveQueriedAnimationOnElement(s)))}destroyActiveAnimationsForElement(t){const e=this.playersByElement.get(t);e&&e.forEach(s=>{s.queued?s.markedForDestroy=!0:s.destroy()})}finishActiveQueriedAnimationOnElement(t){const e=this.playersByQueriedElement.get(t);e&&e.forEach(s=>s.finish())}whenRenderingDone(){return new Promise(t=>{if(this.players.length)return vl(this.players).onDone(()=>t());t()})}processLeaveNode(t){const e=t[Ei];if(e&&e.setForRemoval){if(t[Ei]=iG,e.namespaceId){this.destroyInnerAnimations(t);const s=this._fetchNamespace(e.namespaceId);s&&s.clearElementCache(t)}this._onRemovalComplete(t,e.setForRemoval)}t.classList?.contains(SN)&&this.markElementAsDisabled(t,!1),this.driver.query(t,".ng-animate-disabled",!0).forEach(s=>{this.markElementAsDisabled(s,!1)})}flush(t=-1){let e=[];if(this.newHostElements.size&&(this.newHostElements.forEach((s,r)=>this._balanceNamespaceList(s,r)),this.newHostElements.clear()),this.totalAnimations&&this.collectedEnterElements.length)for(let s=0;s<this.collectedEnterElements.length;s++)Di(this.collectedEnterElements[s],"ng-star-inserted");if(this._namespaceList.length&&(this.totalQueuedPlayers||this.collectedLeaveElements.length)){const s=[];try{e=this._flushAnimations(s,t)}finally{for(let r=0;r<s.length;r++)s[r]()}}else for(let s=0;s<this.collectedLeaveElements.length;s++)this.processLeaveNode(this.collectedLeaveElements[s]);if(this.totalQueuedPlayers=0,this.collectedEnterElements.length=0,this.collectedLeaveElements.length=0,this._flushFns.forEach(s=>s()),this._flushFns=[],this._whenQuietFns.length){const s=this._whenQuietFns;this._whenQuietFns=[],e.length?vl(e).onDone(()=>{s.forEach(r=>r())}):s.forEach(r=>r())}}reportError(t){throw function xRe(n){return new ee(3402,!1)}()}_flushAnimations(t,e){const s=new N_,r=[],i=new Map,o=[],a=new Map,l=new Map,u=new Map,c=new Set;this.disabledNodes.forEach(P=>{c.add(P);const B=this.driver.query(P,".ng-animate-queued",!0);for(let L=0;L<B.length;L++)c.add(B[L])});const d=this.bodyNode,h=Array.from(this.statesByElement.keys()),f=lG(h,this.collectedEnterElements),p=new Map;let g=0;f.forEach((P,B)=>{const L=hN+g++;p.set(B,L),P.forEach(H=>Di(H,L))});const m=[],y=new Set,b=new Set;for(let P=0;P<this.collectedLeaveElements.length;P++){const B=this.collectedLeaveElements[P],L=B[Ei];L&&L.setForRemoval&&(m.push(B),y.add(B),L.hasAnimation?this.driver.query(B,".ng-star-inserted",!0).forEach(H=>y.add(H)):b.add(B))}const v=new Map,_=lG(h,Array.from(y));_.forEach((P,B)=>{const L=w_+g++;v.set(B,L),P.forEach(H=>Di(H,L))}),t.push(()=>{f.forEach((P,B)=>{const L=p.get(B);P.forEach(H=>Rd(H,L))}),_.forEach((P,B)=>{const L=v.get(B);P.forEach(H=>Rd(H,L))}),m.forEach(P=>{this.processLeaveNode(P)})});const x=[],C=[];for(let P=this._namespaceList.length-1;P>=0;P--)this._namespaceList[P].drainQueuedTransitions(e).forEach(L=>{const H=L.player,se=L.element;if(x.push(H),this.collectedEnterElements.length){const Ce=se[Ei];if(Ce&&Ce.setForMove){if(Ce.previousTriggersValues&&Ce.previousTriggersValues.has(L.triggerName)){const Le=Ce.previousTriggersValues.get(L.triggerName),ke=this.statesByElement.get(L.element);if(ke&&ke.has(L.triggerName)){const Qe=ke.get(L.triggerName);Qe.value=Le,ke.set(L.triggerName,Qe)}}return void H.destroy()}}const ie=!d||!this.driver.containsElement(d,se),he=v.get(se),de=p.get(se),fe=this._buildInstruction(L,s,de,he,ie);if(fe.errors&&fe.errors.length)return void C.push(fe);if(ie)return H.onStart(()=>Au(se,fe.fromStyles)),H.onDestroy(()=>Oo(se,fe.toStyles)),void r.push(H);if(L.isFallbackTransition)return H.onStart(()=>Au(se,fe.fromStyles)),H.onDestroy(()=>Oo(se,fe.toStyles)),void r.push(H);const ye=[];fe.timelines.forEach(Ce=>{Ce.stretchStartingKeyframe=!0,this.disabledNodes.has(Ce.element)||ye.push(Ce)}),fe.timelines=ye,s.append(se,fe.timelines),o.push({instruction:fe,player:H,element:se}),fe.queriedElements.forEach(Ce=>ei(a,Ce,[]).push(H)),fe.preStyleProps.forEach((Ce,Le)=>{if(Ce.size){let ke=l.get(Le);ke||l.set(Le,ke=new Set),Ce.forEach((Qe,st)=>ke.add(st))}}),fe.postStyleProps.forEach((Ce,Le)=>{let ke=u.get(Le);ke||u.set(Le,ke=new Set),Ce.forEach((Qe,st)=>ke.add(st))})});if(C.length){const P=[];C.forEach(B=>{P.push(function CRe(n,t){return new ee(3505,!1)}())}),x.forEach(B=>B.destroy()),this.reportError(P)}const E=new Map,D=new Map;o.forEach(P=>{const B=P.element;s.has(B)&&(D.set(B,B),this._beforeAnimationBuild(P.player.namespaceId,P.instruction,E))}),r.forEach(P=>{const B=P.element;this._getPreviousPlayers(B,!1,P.namespaceId,P.triggerName,null).forEach(H=>{ei(E,B,[]).push(H),H.destroy()})});const N=m.filter(P=>cG(P,l,u)),R=new Map;aG(R,this.driver,b,u,ya).forEach(P=>{cG(P,l,u)&&N.push(P)});const G=new Map;f.forEach((P,B)=>{aG(G,this.driver,new Set(P),l,oN)}),N.forEach(P=>{const B=R.get(P),L=G.get(P);R.set(P,new Map([...Array.from(B?.entries()??[]),...Array.from(L?.entries()??[])]))});const j=[],q=[],K={};o.forEach(P=>{const{element:B,player:L,instruction:H}=P;if(s.has(B)){if(c.has(B))return L.onDestroy(()=>Oo(B,H.toStyles)),L.disabled=!0,L.overrideTotalTime(H.totalTime),void r.push(L);let se=K;if(D.size>1){let he=B;const de=[];for(;he=he.parentNode;){const fe=D.get(he);if(fe){se=fe;break}de.push(he)}de.forEach(fe=>D.set(fe,se))}const ie=this._buildAnimation(L.namespaceId,H,E,i,G,R);if(L.setRealPlayer(ie),se===K)j.push(L);else{const he=this.playersByElement.get(se);he&&he.length&&(L.parentPlayer=vl(he)),r.push(L)}}else Au(B,H.fromStyles),L.onDestroy(()=>Oo(B,H.toStyles)),q.push(L),c.has(B)&&r.push(L)}),q.forEach(P=>{const B=i.get(P.element);if(B&&B.length){const L=vl(B);P.setRealPlayer(L)}}),r.forEach(P=>{P.parentPlayer?P.syncPlayerEvents(P.parentPlayer):P.destroy()});for(let P=0;P<m.length;P++){const B=m[P],L=B[Ei];if(Rd(B,w_),L&&L.hasAnimation)continue;let H=[];if(a.size){let ie=a.get(B);ie&&ie.length&&H.push(...ie);let he=this.driver.query(B,fN,!0);for(let de=0;de<he.length;de++){let fe=a.get(he[de]);fe&&fe.length&&H.push(...fe)}}const se=H.filter(ie=>!ie.destroyed);se.length?xMe(this,B,se):this.processLeaveNode(B)}return m.length=0,j.forEach(P=>{this.players.push(P),P.onDone(()=>{P.destroy();const B=this.players.indexOf(P);this.players.splice(B,1)}),P.play()}),j}elementContainsData(t,e){let s=!1;const r=e[Ei];return r&&r.setForRemoval&&(s=!0),this.playersByElement.has(e)&&(s=!0),this.playersByQueriedElement.has(e)&&(s=!0),this.statesByElement.has(e)&&(s=!0),this._fetchNamespace(t).elementContainsData(e)||s}afterFlush(t){this._flushFns.push(t)}afterFlushAnimationsDone(t){this._whenQuietFns.push(t)}_getPreviousPlayers(t,e,s,r,i){let o=[];if(e){const a=this.playersByQueriedElement.get(t);a&&(o=a)}else{const a=this.playersByElement.get(t);if(a){const l=!i||i==om;a.forEach(u=>{u.queued||!l&&u.triggerName!=r||o.push(u)})}}return(s||r)&&(o=o.filter(a=>!(s&&s!=a.namespaceId||r&&r!=a.triggerName))),o}_beforeAnimationBuild(t,e,s){const i=e.element,o=e.isRemovalTransition?void 0:t,a=e.isRemovalTransition?void 0:e.triggerName;for(const l of e.timelines){const u=l.element,c=u!==i,d=ei(s,u,[]);this._getPreviousPlayers(u,c,o,a,e.toState).forEach(f=>{const p=f.getRealPlayer();p.beforeDestroy&&p.beforeDestroy(),f.destroy(),d.push(f)})}Au(i,e.fromStyles)}_buildAnimation(t,e,s,r,i,o){const a=e.triggerName,l=e.element,u=[],c=new Set,d=new Set,h=e.timelines.map(p=>{const g=p.element;c.add(g);const m=g[Ei];if(m&&m.removedBeforeQueried)return new nm(p.duration,p.delay);const y=g!==l,b=function CMe(n){const t=[];return uG(n,t),t}((s.get(g)||mMe).map(E=>E.getRealPlayer())).filter(E=>!!E.element&&E.element===g),v=i.get(g),_=o.get(g),x=V4(0,this._normalizer,0,p.keyframes,v,_),C=this._buildPlayer(p,x,b);if(p.subTimeline&&r&&d.add(g),y){const E=new DN(t,a,g);E.setRealPlayer(C),u.push(E)}return C});u.forEach(p=>{ei(this.playersByQueriedElement,p.element,[]).push(p),p.onDone(()=>function vMe(n,t,e){let s=n.get(t);if(s){if(s.length){const r=s.indexOf(e);s.splice(r,1)}0==s.length&&n.delete(t)}return s}(this.playersByQueriedElement,p.element,p))}),c.forEach(p=>Di(p,j4));const f=vl(h);return f.onDestroy(()=>{c.forEach(p=>Rd(p,j4)),Oo(l,e.toStyles)}),d.forEach(p=>{ei(r,p,[]).push(f)}),f}_buildPlayer(t,e,s){return e.length>0?this.driver.animate(t.element,e,t.duration,t.delay,t.easing,s):new nm(t.duration,t.delay)}}class DN{constructor(t,e,s){this.namespaceId=t,this.triggerName=e,this.element=s,this._player=new nm,this._containsRealPlayer=!1,this._queuedCallbacks=new Map,this.destroyed=!1,this.parentPlayer=null,this.markedForDestroy=!1,this.disabled=!1,this.queued=!0,this.totalTime=0}setRealPlayer(t){this._containsRealPlayer||(this._player=t,this._queuedCallbacks.forEach((e,s)=>{e.forEach(r=>aN(t,s,void 0,r))}),this._queuedCallbacks.clear(),this._containsRealPlayer=!0,this.overrideTotalTime(t.totalTime),this.queued=!1)}getRealPlayer(){return this._player}overrideTotalTime(t){this.totalTime=t}syncPlayerEvents(t){const e=this._player;e.triggerCallback&&t.onStart(()=>e.triggerCallback("start")),t.onDone(()=>this.finish()),t.onDestroy(()=>this.destroy())}_queueEvent(t,e){ei(this._queuedCallbacks,t,[]).push(e)}onDone(t){this.queued&&this._queueEvent("done",t),this._player.onDone(t)}onStart(t){this.queued&&this._queueEvent("start",t),this._player.onStart(t)}onDestroy(t){this.queued&&this._queueEvent("destroy",t),this._player.onDestroy(t)}init(){this._player.init()}hasStarted(){return!this.queued&&this._player.hasStarted()}play(){!this.queued&&this._player.play()}pause(){!this.queued&&this._player.pause()}restart(){!this.queued&&this._player.restart()}finish(){this._player.finish()}destroy(){this.destroyed=!0,this._player.destroy()}reset(){!this.queued&&this._player.reset()}setPosition(t){this.queued||this._player.setPosition(t)}getPosition(){return this.queued?0:this._player.getPosition()}triggerCallback(t){const e=this._player;e.triggerCallback&&e.triggerCallback(t)}}function R_(n){return n&&1===n.nodeType}function oG(n,t){const e=n.style.display;return n.style.display=t??"none",e}function aG(n,t,e,s,r){const i=[];e.forEach(l=>i.push(oG(l)));const o=[];s.forEach((l,u)=>{const c=new Map;l.forEach(d=>{const h=t.computeStyle(u,d,r);c.set(d,h),(!h||0==h.length)&&(u[Ei]=gMe,o.push(u))}),n.set(u,c)});let a=0;return e.forEach(l=>oG(l,i[a++])),o}function lG(n,t){const e=new Map;if(n.forEach(a=>e.set(a,[])),0==t.length)return e;const s=1,r=new Set(t),i=new Map;function o(a){if(!a)return s;let l=i.get(a);if(l)return l;const u=a.parentNode;return l=e.has(u)?u:r.has(u)?s:o(u),i.set(a,l),l}return t.forEach(a=>{const l=o(a);l!==s&&e.get(l).push(a)}),e}function Di(n,t){n.classList?.add(t)}function Rd(n,t){n.classList?.remove(t)}function xMe(n,t,e){vl(e).onDone(()=>n.processLeaveNode(t))}function uG(n,t){for(let e=0;e<n.length;e++){const s=n[e];s instanceof P4?uG(s.players,t):t.push(s)}}function cG(n,t,e){const s=e.get(n);if(!s)return!1;let r=t.get(n);return r?s.forEach(i=>r.add(i)):t.set(n,s),e.delete(n),!0}class M_{constructor(t,e,s){this.bodyNode=t,this._driver=e,this._normalizer=s,this._triggerCache={},this.onRemovalComplete=(r,i)=>{},this._transitionEngine=new bMe(t,e,s),this._timelineEngine=new cMe(t,e,s),this._transitionEngine.onRemovalComplete=(r,i)=>this.onRemovalComplete(r,i)}registerTrigger(t,e,s,r,i){const o=t+"-"+r;let a=this._triggerCache[o];if(!a){const l=[],c=yN(this._driver,i,l,[]);if(l.length)throw function hRe(n,t){return new ee(3404,!1)}();a=function oMe(n,t,e){return new aMe(n,t,e)}(r,c,this._normalizer),this._triggerCache[o]=a}this._transitionEngine.registerTrigger(e,r,a)}register(t,e){this._transitionEngine.register(t,e)}destroy(t,e){this._transitionEngine.destroy(t,e)}onInsert(t,e,s,r){this._transitionEngine.insertNode(t,e,s,r)}onRemove(t,e,s,r){this._transitionEngine.removeNode(t,e,r||!1,s)}disableAnimations(t,e){this._transitionEngine.markElementAsDisabled(t,e)}process(t,e,s,r){if("@"==s.charAt(0)){const[i,o]=B4(s);this._timelineEngine.command(i,e,o,r)}else this._transitionEngine.trigger(t,e,s,r)}listen(t,e,s,r,i){if("@"==s.charAt(0)){const[o,a]=B4(s);return this._timelineEngine.listen(o,e,a,i)}return this._transitionEngine.listen(t,e,s,r,i)}flush(t=-1){this._transitionEngine.flush(t)}get players(){return this._transitionEngine.players.concat(this._timelineEngine.players)}whenRenderingDone(){return this._transitionEngine.whenRenderingDone()}}let EMe=(()=>{class n{constructor(e,s,r){this._element=e,this._startStyles=s,this._endStyles=r,this._state=0;let i=n.initialStylesByElement.get(e);i||n.initialStylesByElement.set(e,i=new Map),this._initialStyles=i}start(){this._state<1&&(this._startStyles&&Oo(this._element,this._startStyles,this._initialStyles),this._state=1)}finish(){this.start(),this._state<2&&(Oo(this._element,this._initialStyles),this._endStyles&&(Oo(this._element,this._endStyles),this._endStyles=null),this._state=1)}destroy(){this.finish(),this._state<3&&(n.initialStylesByElement.delete(this._element),this._startStyles&&(Au(this._element,this._startStyles),this._endStyles=null),this._endStyles&&(Au(this._element,this._endStyles),this._endStyles=null),Oo(this._element,this._initialStyles),this._state=3)}}return n.initialStylesByElement=new WeakMap,n})();function TN(n){let t=null;return n.forEach((e,s)=>{(function DMe(n){return"display"===n||"position"===n})(s)&&(t=t||new Map,t.set(s,e))}),t}class dG{constructor(t,e,s,r){this.element=t,this.keyframes=e,this.options=s,this._specialStyles=r,this._onDoneFns=[],this._onStartFns=[],this._onDestroyFns=[],this._initialized=!1,this._finished=!1,this._started=!1,this._destroyed=!1,this._originalOnDoneFns=[],this._originalOnStartFns=[],this.time=0,this.parentPlayer=null,this.currentSnapshot=new Map,this._duration=s.duration,this._delay=s.delay||0,this.time=this._duration+this._delay}_onFinish(){this._finished||(this._finished=!0,this._onDoneFns.forEach(t=>t()),this._onDoneFns=[])}init(){this._buildPlayer(),this._preparePlayerBeforeStart()}_buildPlayer(){if(this._initialized)return;this._initialized=!0;const t=this.keyframes;this.domPlayer=this._triggerWebAnimation(this.element,t,this.options),this._finalKeyframe=t.length?t[t.length-1]:new Map,this.domPlayer.addEventListener("finish",()=>this._onFinish())}_preparePlayerBeforeStart(){this._delay?this._resetDomPlayerState():this.domPlayer.pause()}_convertKeyframesToObject(t){const e=[];return t.forEach(s=>{e.push(Object.fromEntries(s))}),e}_triggerWebAnimation(t,e,s){return t.animate(this._convertKeyframesToObject(e),s)}onStart(t){this._originalOnStartFns.push(t),this._onStartFns.push(t)}onDone(t){this._originalOnDoneFns.push(t),this._onDoneFns.push(t)}onDestroy(t){this._onDestroyFns.push(t)}play(){this._buildPlayer(),this.hasStarted()||(this._onStartFns.forEach(t=>t()),this._onStartFns=[],this._started=!0,this._specialStyles&&this._specialStyles.start()),this.domPlayer.play()}pause(){this.init(),this.domPlayer.pause()}finish(){this.init(),this._specialStyles&&this._specialStyles.finish(),this._onFinish(),this.domPlayer.finish()}reset(){this._resetDomPlayerState(),this._destroyed=!1,this._finished=!1,this._started=!1,this._onStartFns=this._originalOnStartFns,this._onDoneFns=this._originalOnDoneFns}_resetDomPlayerState(){this.domPlayer&&this.domPlayer.cancel()}restart(){this.reset(),this.play()}hasStarted(){return this._started}destroy(){this._destroyed||(this._destroyed=!0,this._resetDomPlayerState(),this._onFinish(),this._specialStyles&&this._specialStyles.destroy(),this._onDestroyFns.forEach(t=>t()),this._onDestroyFns=[])}setPosition(t){void 0===this.domPlayer&&this.init(),this.domPlayer.currentTime=t*this.time}getPosition(){return this.domPlayer.currentTime/this.time}get totalTime(){return this._delay+this._duration}beforeDestroy(){const t=new Map;this.hasStarted()&&this._finalKeyframe.forEach((s,r)=>{"offset"!==r&&t.set(r,this._finished?s:Y4(this.element,r))}),this.currentSnapshot=t}triggerCallback(t){const e="start"===t?this._onStartFns:this._onDoneFns;e.forEach(s=>s()),e.length=0}}class TMe{validateStyleProperty(t){return!0}validateAnimatableStyleProperty(t){return!0}matchesElement(t,e){return!1}containsElement(t,e){return U4(t,e)}getParentElement(t){return cN(t)}query(t,e,s){return W4(t,e,s)}computeStyle(t,e,s){return window.getComputedStyle(t)[e]}animate(t,e,s,r,i,o=[]){const l={duration:s,delay:r,fill:0==r?"both":"forwards"};i&&(l.easing=i);const u=new Map,c=o.filter(f=>f instanceof dG);(function ORe(n,t){return 0===n||0===t})(s,r)&&c.forEach(f=>{f.currentSnapshot.forEach((p,g)=>u.set(g,p))});let d=function RRe(n){return n.length?n[0]instanceof Map?n:n.map(t=>q4(t)):[]}(e).map(f=>_l(f));d=function $Re(n,t,e){if(e.size&&t.length){let s=t[0],r=[];if(e.forEach((i,o)=>{s.has(o)||r.push(o),s.set(o,i)}),r.length)for(let i=1;i<t.length;i++){let o=t[i];r.forEach(a=>o.set(a,Y4(n,a)))}}return t}(t,d,u);const h=function IMe(n,t){let e=null,s=null;return Array.isArray(t)&&t.length?(e=TN(t[0]),t.length>1&&(s=TN(t[t.length-1]))):t instanceof Map&&(e=TN(t)),e||s?new EMe(n,e,s):null}(t,d);return new dG(t,d,l,h)}}let NMe=(()=>{class n extends M4{constructor(e,s){super(),this._nextAnimationId=0,this._renderer=e.createRenderer(s.body,{id:"0",encapsulation:mr.None,styles:[],data:{animation:[]}})}build(e){const s=this._nextAnimationId.toString();this._nextAnimationId++;const r=Array.isArray(e)?F4(e):e;return hG(this._renderer,null,s,"register",[r]),new kMe(s,this._renderer)}}return n.\u0275fac=function(e){return new(e||n)(Se(ch),Se(Es))},n.\u0275prov=Ve({token:n,factory:n.\u0275fac}),n})();class kMe extends GAe{constructor(t,e){super(),this._id=t,this._renderer=e}create(t,e){return new AMe(this._id,t,e||{},this._renderer)}}class AMe{constructor(t,e,s,r){this.id=t,this.element=e,this._renderer=r,this.parentPlayer=null,this._started=!1,this.totalTime=0,this._command("create",s)}_listen(t,e){return this._renderer.listen(this.element,`@@${this.id}:${t}`,e)}_command(t,...e){return hG(this._renderer,this.element,this.id,t,e)}onDone(t){this._listen("done",t)}onStart(t){this._listen("start",t)}onDestroy(t){this._listen("destroy",t)}init(){this._command("init")}hasStarted(){return this._started}play(){this._command("play"),this._started=!0}pause(){this._command("pause")}restart(){this._command("restart")}finish(){this._command("finish")}destroy(){this._command("destroy")}reset(){this._command("reset"),this._started=!1}setPosition(t){this._command("setPosition",t)}getPosition(){return this._renderer.engine.players[+this.id]?.getPosition()??0}}function hG(n,t,e,s,r){return n.setProperty(t,`@@${e}:${s}`,r)}const fG="@.disabled";let RMe=(()=>{class n{constructor(e,s,r){this.delegate=e,this.engine=s,this._zone=r,this._currentId=0,this._microtaskId=1,this._animationCallbacksBuffer=[],this._rendererCache=new Map,this._cdRecurDepth=0,this.promise=Promise.resolve(0),s.onRemovalComplete=(i,o)=>{const a=o?.parentNode(i);a&&o.removeChild(a,i)}}createRenderer(e,s){const i=this.delegate.createRenderer(e,s);if(!(e&&s&&s.data&&s.data.animation)){let c=this._rendererCache.get(i);return c||(c=new pG("",i,this.engine,()=>this._rendererCache.delete(i)),this._rendererCache.set(i,c)),c}const o=s.id,a=s.id+"-"+this._currentId;this._currentId++,this.engine.register(a,e);const l=c=>{Array.isArray(c)?c.forEach(l):this.engine.registerTrigger(o,a,e,c.name,c)};return s.data.animation.forEach(l),new MMe(this,a,i,this.engine)}begin(){this._cdRecurDepth++,this.delegate.begin&&this.delegate.begin()}_scheduleCountTask(){this.promise.then(()=>{this._microtaskId++})}scheduleListenerCallback(e,s,r){e>=0&&e<this._microtaskId?this._zone.run(()=>s(r)):(0==this._animationCallbacksBuffer.length&&Promise.resolve(null).then(()=>{this._zone.run(()=>{this._animationCallbacksBuffer.forEach(i=>{const[o,a]=i;o(a)}),this._animationCallbacksBuffer=[]})}),this._animationCallbacksBuffer.push([s,r]))}end(){this._cdRecurDepth--,0==this._cdRecurDepth&&this._zone.runOutsideAngular(()=>{this._scheduleCountTask(),this.engine.flush(this._microtaskId)}),this.delegate.end&&this.delegate.end()}whenRenderingDone(){return this.engine.whenRenderingDone()}}return n.\u0275fac=function(e){return new(e||n)(Se(ch),Se(M_),Se(Pt))},n.\u0275prov=Ve({token:n,factory:n.\u0275fac}),n})();class pG{constructor(t,e,s,r){this.namespaceId=t,this.delegate=e,this.engine=s,this._onDestroy=r,this.destroyNode=this.delegate.destroyNode?i=>e.destroyNode(i):null}get data(){return this.delegate.data}destroy(){this.engine.destroy(this.namespaceId,this.delegate),this.delegate.destroy(),this._onDestroy?.()}createElement(t,e){return this.delegate.createElement(t,e)}createComment(t){return this.delegate.createComment(t)}createText(t){return this.delegate.createText(t)}appendChild(t,e){this.delegate.appendChild(t,e),this.engine.onInsert(this.namespaceId,e,t,!1)}insertBefore(t,e,s,r=!0){this.delegate.insertBefore(t,e,s),this.engine.onInsert(this.namespaceId,e,t,r)}removeChild(t,e,s){this.engine.onRemove(this.namespaceId,e,this.delegate,s)}selectRootElement(t,e){return this.delegate.selectRootElement(t,e)}parentNode(t){return this.delegate.parentNode(t)}nextSibling(t){return this.delegate.nextSibling(t)}setAttribute(t,e,s,r){this.delegate.setAttribute(t,e,s,r)}removeAttribute(t,e,s){this.delegate.removeAttribute(t,e,s)}addClass(t,e){this.delegate.addClass(t,e)}removeClass(t,e){this.delegate.removeClass(t,e)}setStyle(t,e,s,r){this.delegate.setStyle(t,e,s,r)}removeStyle(t,e,s){this.delegate.removeStyle(t,e,s)}setProperty(t,e,s){"@"==e.charAt(0)&&e==fG?this.disableAnimations(t,!!s):this.delegate.setProperty(t,e,s)}setValue(t,e){this.delegate.setValue(t,e)}listen(t,e,s){return this.delegate.listen(t,e,s)}disableAnimations(t,e){this.engine.disableAnimations(t,e)}}class MMe extends pG{constructor(t,e,s,r,i){super(e,s,r,i),this.factory=t,this.namespaceId=e}setProperty(t,e,s){"@"==e.charAt(0)?"."==e.charAt(1)&&e==fG?this.disableAnimations(t,s=void 0===s||!!s):this.engine.process(this.namespaceId,t,e.slice(1),s):this.delegate.setProperty(t,e,s)}listen(t,e,s){if("@"==e.charAt(0)){const r=function FMe(n){switch(n){case"body":return document.body;case"document":return document;case"window":return window;default:return n}}(t);let i=e.slice(1),o="";return"@"!=i.charAt(0)&&([i,o]=function OMe(n){const t=n.indexOf(".");return[n.substring(0,t),n.slice(t+1)]}(i)),this.engine.listen(this.namespaceId,r,i,o,a=>{this.factory.scheduleListenerCallback(a._data||-1,s,a)})}return this.delegate.listen(t,e,s)}}const mG=[{provide:M4,useClass:NMe},{provide:xN,useFactory:function PMe(){return new nMe}},{provide:M_,useClass:(()=>{class n extends M_{constructor(e,s,r,i){super(e.body,s,r)}ngOnDestroy(){this.flush()}}return n.\u0275fac=function(e){return new(e||n)(Se(Es),Se(dN),Se(xN),Se(zl))},n.\u0275prov=Ve({token:n,factory:n.\u0275fac}),n})()},{provide:ch,useFactory:function LMe(n,t,e){return new RMe(n,t,e)},deps:[aC,M_,Pt]}],NN=[{provide:dN,useFactory:()=>new TMe},{provide:Jm,useValue:"BrowserAnimations"},...mG],gG=[{provide:dN,useClass:G4},{provide:Jm,useValue:"NoopAnimations"},...mG];let VMe=(()=>{class n{static withConfig(e){return{ngModule:n,providers:e.disableAnimations?gG:NN}}}return n.\u0275fac=function(e){return new(e||n)},n.\u0275mod=Or({type:n}),n.\u0275inj=fr({providers:NN,imports:[d$]}),n})(),BMe=(()=>{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275mod=Or({type:n,bootstrap:[WAe]}),n.\u0275inj=fr({imports:[d$,Eee,VMe,UAe]}),n})();UZ().bootstrapModule(BMe).catch(n=>console.error(n))},658:xt=>{xt.exports=Q;var vt=null;try{vt=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch{}function Q(J,T,pe){this.low=0|J,this.high=0|T,this.unsigned=!!pe}function We(J){return!0===(J&&J.__isLong__)}Object.defineProperty(Q.prototype,"__isLong__",{value:!0}),Q.isLong=We;var qn={},Xe={};function hn(J,T){var pe,He,St;return T?(St=0<=(J>>>=0)&&J<256)&&(He=Xe[J])?He:(pe=Ue(J,(0|J)<0?-1:0,!0),St&&(Xe[J]=pe),pe):(St=-128<=(J|=0)&&J<128)&&(He=qn[J])?He:(pe=Ue(J,J<0?-1:0,!1),St&&(qn[J]=pe),pe)}function ht(J,T){if(isNaN(J))return T?Kn:Bt;if(T){if(J<0)return Kn;if(J>=me)return Ft}else{if(J<=-Ae)return Ot;if(J+1>=Ae)return Ct}return J<0?ht(-J,T).neg():Ue(J%re|0,J/re|0,T)}function Ue(J,T,pe){return new Q(J,T,pe)}Q.fromInt=hn,Q.fromNumber=ht,Q.fromBits=Ue;var lt=Math.pow;function Te(J,T,pe){if(0===J.length)throw Error("empty string");if("NaN"===J||"Infinity"===J||"+Infinity"===J||"-Infinity"===J)return Bt;if("number"==typeof T?(pe=T,T=!1):T=!!T,(pe=pe||10)<2||36<pe)throw RangeError("radix");var He;if((He=J.indexOf("-"))>0)throw Error("interior hyphen");if(0===He)return Te(J.substring(1),T,pe).neg();for(var St=ht(lt(pe,8)),ft=Bt,ut=0;ut<J.length;ut+=8){var An=Math.min(8,J.length-ut),zn=parseInt(J.substring(ut,ut+An),pe);if(An<8){var cs=ht(lt(pe,An));ft=ft.mul(cs).add(ht(zn))}else ft=(ft=ft.mul(St)).add(ht(zn))}return ft.unsigned=T,ft}function U(J,T){return"number"==typeof J?ht(J,T):"string"==typeof J?Te(J,T):Ue(J.low,J.high,"boolean"==typeof T?T:J.unsigned)}Q.fromString=Te,Q.fromValue=U;var re=4294967296,me=re*re,Ae=me/2,$e=hn(1<<24),Bt=hn(0);Q.ZERO=Bt;var Kn=hn(0,!0);Q.UZERO=Kn;var Bn=hn(1);Q.ONE=Bn;var si=hn(1,!0);Q.UONE=si;var Rr=hn(-1);Q.NEG_ONE=Rr;var Ct=Ue(-1,2147483647,!1);Q.MAX_VALUE=Ct;var Ft=Ue(-1,-1,!0);Q.MAX_UNSIGNED_VALUE=Ft;var Ot=Ue(0,-2147483648,!1);Q.MIN_VALUE=Ot;var ce=Q.prototype;ce.toInt=function(){return this.unsigned?this.low>>>0:this.low},ce.toNumber=function(){return this.unsigned?(this.high>>>0)*re+(this.low>>>0):this.high*re+(this.low>>>0)},ce.toString=function(T){if((T=T||10)<2||36<T)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative()){if(this.eq(Ot)){var pe=ht(T),He=this.div(pe),St=He.mul(pe).sub(this);return He.toString(T)+St.toInt().toString(T)}return"-"+this.neg().toString(T)}for(var ft=ht(lt(T,6),this.unsigned),ut=this,An="";;){var zn=ut.div(ft),Zt=(ut.sub(zn.mul(ft)).toInt()>>>0).toString(T);if((ut=zn).isZero())return Zt+An;for(;Zt.length<6;)Zt="0"+Zt;An=""+Zt+An}},ce.getHighBits=function(){return this.high},ce.getHighBitsUnsigned=function(){return this.high>>>0},ce.getLowBits=function(){return this.low},ce.getLowBitsUnsigned=function(){return this.low>>>0},ce.getNumBitsAbs=function(){if(this.isNegative())return this.eq(Ot)?64:this.neg().getNumBitsAbs();for(var T=0!=this.high?this.high:this.low,pe=31;pe>0&&!(T&1<<pe);pe--);return 0!=this.high?pe+33:pe+1},ce.isZero=function(){return 0===this.high&&0===this.low},ce.eqz=ce.isZero,ce.isNegative=function(){return!this.unsigned&&this.high<0},ce.isPositive=function(){return this.unsigned||this.high>=0},ce.isOdd=function(){return 1==(1&this.low)},ce.isEven=function(){return 0==(1&this.low)},ce.equals=function(T){return We(T)||(T=U(T)),(this.unsigned===T.unsigned||this.high>>>31!=1||T.high>>>31!=1)&&this.high===T.high&&this.low===T.low},ce.eq=ce.equals,ce.notEquals=function(T){return!this.eq(T)},ce.neq=ce.notEquals,ce.ne=ce.notEquals,ce.lessThan=function(T){return this.comp(T)<0},ce.lt=ce.lessThan,ce.lessThanOrEqual=function(T){return this.comp(T)<=0},ce.lte=ce.lessThanOrEqual,ce.le=ce.lessThanOrEqual,ce.greaterThan=function(T){return this.comp(T)>0},ce.gt=ce.greaterThan,ce.greaterThanOrEqual=function(T){return this.comp(T)>=0},ce.gte=ce.greaterThanOrEqual,ce.ge=ce.greaterThanOrEqual,ce.compare=function(T){if(We(T)||(T=U(T)),this.eq(T))return 0;var pe=this.isNegative(),He=T.isNegative();return pe&&!He?-1:!pe&&He?1:this.unsigned?T.high>>>0>this.high>>>0||T.high===this.high&&T.low>>>0>this.low>>>0?-1:1:this.sub(T).isNegative()?-1:1},ce.comp=ce.compare,ce.negate=function(){return!this.unsigned&&this.eq(Ot)?Ot:this.not().add(Bn)},ce.neg=ce.negate,ce.add=function(T){We(T)||(T=U(T));var Zt=0,Ms=0,Un=0,Fs=0;return Un+=(Fs+=(65535&this.low)+(65535&T.low))>>>16,Ms+=(Un+=(this.low>>>16)+(T.low>>>16))>>>16,Zt+=(Ms+=(65535&this.high)+(65535&T.high))>>>16,Zt+=(this.high>>>16)+(T.high>>>16),Ue((Un&=65535)<<16|(Fs&=65535),(Zt&=65535)<<16|(Ms&=65535),this.unsigned)},ce.subtract=function(T){return We(T)||(T=U(T)),this.add(T.neg())},ce.sub=ce.subtract,ce.multiply=function(T){if(this.isZero())return Bt;if(We(T)||(T=U(T)),vt)return Ue(vt.mul(this.low,this.high,T.low,T.high),vt.get_high(),this.unsigned);if(T.isZero())return Bt;if(this.eq(Ot))return T.isOdd()?Ot:Bt;if(T.eq(Ot))return this.isOdd()?Ot:Bt;if(this.isNegative())return T.isNegative()?this.neg().mul(T.neg()):this.neg().mul(T).neg();if(T.isNegative())return this.mul(T.neg()).neg();if(this.lt($e)&&T.lt($e))return ht(this.toNumber()*T.toNumber(),this.unsigned);var St=65535&this.high,ft=this.low>>>16,ut=65535&this.low,zn=65535&T.high,cs=T.low>>>16,Zt=65535&T.low,Ms=0,Un=0,Fs=0,Fu=0;return Fs+=(Fu+=ut*Zt)>>>16,Un+=(Fs+=ft*Zt)>>>16,Fs&=65535,Un+=(Fs+=ut*cs)>>>16,Ms+=(Un+=St*Zt)>>>16,Un&=65535,Ms+=(Un+=ft*cs)>>>16,Un&=65535,Ms+=(Un+=ut*zn)>>>16,Ms+=(this.high>>>16)*Zt+St*cs+ft*zn+ut*(T.high>>>16),Ue((Fs&=65535)<<16|(Fu&=65535),(Ms&=65535)<<16|(Un&=65535),this.unsigned)},ce.mul=ce.multiply,ce.divide=function(T){if(We(T)||(T=U(T)),T.isZero())throw Error("division by zero");var He,St,ft;if(vt)return this.unsigned||-2147483648!==this.high||-1!==T.low||-1!==T.high?Ue((this.unsigned?vt.div_u:vt.div_s)(this.low,this.high,T.low,T.high),vt.get_high(),this.unsigned):this;if(this.isZero())return this.unsigned?Kn:Bt;if(this.unsigned){if(T.unsigned||(T=T.toUnsigned()),T.gt(this))return Kn;if(T.gt(this.shru(1)))return si;ft=Kn}else{if(this.eq(Ot))return T.eq(Bn)||T.eq(Rr)?Ot:T.eq(Ot)?Bn:(He=this.shr(1).div(T).shl(1)).eq(Bt)?T.isNegative()?Bn:Rr:(St=this.sub(T.mul(He)),ft=He.add(St.div(T)));if(T.eq(Ot))return this.unsigned?Kn:Bt;if(this.isNegative())return T.isNegative()?this.neg().div(T.neg()):this.neg().div(T).neg();if(T.isNegative())return this.div(T.neg()).neg();ft=Bt}for(St=this;St.gte(T);){He=Math.max(1,Math.floor(St.toNumber()/T.toNumber()));for(var An=Math.ceil(Math.log(He)/Math.LN2),zn=An<=48?1:lt(2,An-48),cs=ht(He),Zt=cs.mul(T);Zt.isNegative()||Zt.gt(St);)Zt=(cs=ht(He-=zn,this.unsigned)).mul(T);cs.isZero()&&(cs=Bn),ft=ft.add(cs),St=St.sub(Zt)}return ft},ce.div=ce.divide,ce.modulo=function(T){return We(T)||(T=U(T)),vt?Ue((this.unsigned?vt.rem_u:vt.rem_s)(this.low,this.high,T.low,T.high),vt.get_high(),this.unsigned):this.sub(this.div(T).mul(T))},ce.mod=ce.modulo,ce.rem=ce.modulo,ce.not=function(){return Ue(~this.low,~this.high,this.unsigned)},ce.and=function(T){return We(T)||(T=U(T)),Ue(this.low&T.low,this.high&T.high,this.unsigned)},ce.or=function(T){return We(T)||(T=U(T)),Ue(this.low|T.low,this.high|T.high,this.unsigned)},ce.xor=function(T){return We(T)||(T=U(T)),Ue(this.low^T.low,this.high^T.high,this.unsigned)},ce.shiftLeft=function(T){return We(T)&&(T=T.toInt()),0==(T&=63)?this:T<32?Ue(this.low<<T,this.high<<T|this.low>>>32-T,this.unsigned):Ue(0,this.low<<T-32,this.unsigned)},ce.shl=ce.shiftLeft,ce.shiftRight=function(T){return We(T)&&(T=T.toInt()),0==(T&=63)?this:T<32?Ue(this.low>>>T|this.high<<32-T,this.high>>T,this.unsigned):Ue(this.high>>T-32,this.high>=0?0:-1,this.unsigned)},ce.shr=ce.shiftRight,ce.shiftRightUnsigned=function(T){if(We(T)&&(T=T.toInt()),0==(T&=63))return this;var pe=this.high;return T<32?Ue(this.low>>>T|pe<<32-T,pe>>>T,this.unsigned):Ue(32===T?pe:pe>>>T-32,0,this.unsigned)},ce.shru=ce.shiftRightUnsigned,ce.shr_u=ce.shiftRightUnsigned,ce.toSigned=function(){return this.unsigned?Ue(this.low,this.high,!1):this},ce.toUnsigned=function(){return this.unsigned?this:Ue(this.low,this.high,!0)},ce.toBytes=function(T){return T?this.toBytesLE():this.toBytesBE()},ce.toBytesLE=function(){var T=this.high,pe=this.low;return[255&pe,pe>>>8&255,pe>>>16&255,pe>>>24,255&T,T>>>8&255,T>>>16&255,T>>>24]},ce.toBytesBE=function(){var T=this.high,pe=this.low;return[T>>>24,T>>>16&255,T>>>8&255,255&T,pe>>>24,pe>>>16&255,pe>>>8&255,255&pe]},Q.fromBytes=function(T,pe,He){return He?Q.fromBytesLE(T,pe):Q.fromBytesBE(T,pe)},Q.fromBytesLE=function(T,pe){return new Q(T[0]|T[1]<<8|T[2]<<16|T[3]<<24,T[4]|T[5]<<8|T[6]<<16|T[7]<<24,pe)},Q.fromBytesBE=function(T,pe){return new Q(T[4]<<24|T[5]<<16|T[6]<<8|T[7],T[0]<<24|T[1]<<16|T[2]<<8|T[3],pe)}},340:(xt,vt,Q)=>{var We=Q(471),qn=Q(992),Xe=Q(657),hn=Q(583),ht=Q(929),Ue=Q(83),lt=Q(818);lt.alea=We,lt.xor128=qn,lt.xorwow=Xe,lt.xorshift7=hn,lt.xor4096=ht,lt.tychei=Ue,xt.exports=lt},471:function(xt,vt,Q){var We;!function(qn,Xe,hn){function ht(U){var ge=this,_e=function Te(){var U=4022871197;return function(_e){_e=String(_e);for(var re=0;re<_e.length;re++){var me=.02519603282416938*(U+=_e.charCodeAt(re));me-=U=me>>>0,U=(me*=U)>>>0,U+=4294967296*(me-=U)}return 2.3283064365386963e-10*(U>>>0)}}();ge.next=function(){var re=2091639*ge.s0+2.3283064365386963e-10*ge.c;return ge.s0=ge.s1,ge.s1=ge.s2,ge.s2=re-(ge.c=0|re)},ge.c=1,ge.s0=_e(" "),ge.s1=_e(" "),ge.s2=_e(" "),ge.s0-=_e(U),ge.s0<0&&(ge.s0+=1),ge.s1-=_e(U),ge.s1<0&&(ge.s1+=1),ge.s2-=_e(U),ge.s2<0&&(ge.s2+=1),_e=null}function Ue(U,ge){return ge.c=U.c,ge.s0=U.s0,ge.s1=U.s1,ge.s2=U.s2,ge}function lt(U,ge){var _e=new ht(U),re=ge&&ge.state,me=_e.next;return me.int32=function(){return 4294967296*_e.next()|0},me.double=function(){return me()+11102230246251565e-32*(2097152*me()|0)},me.quick=me,re&&("object"==typeof re&&Ue(re,_e),me.state=function(){return Ue(_e,{})}),me}Xe&&Xe.exports?Xe.exports=lt:Q.amdD&&Q.amdO?void 0!==(We=function(){return lt}.call(vt,Q,vt,Xe))&&(Xe.exports=We):this.alea=lt}(0,xt=Q.nmd(xt))},83:function(xt,vt,Q){var We;!function(qn,Xe,hn){function ht(Te){var U=this,ge="";U.next=function(){var re=U.b,me=U.c,Ae=U.d,$e=U.a;return re=re<<25^re>>>7^me,me=me-Ae|0,Ae=Ae<<24^Ae>>>8^$e,$e=$e-re|0,U.b=re=re<<20^re>>>12^me,U.c=me=me-Ae|0,U.d=Ae<<16^me>>>16^$e,U.a=$e-re|0},U.a=0,U.b=0,U.c=-1640531527,U.d=1367130551,Te===Math.floor(Te)?(U.a=Te/4294967296|0,U.b=0|Te):ge+=Te;for(var _e=0;_e<ge.length+20;_e++)U.b^=0|ge.charCodeAt(_e),U.next()}function Ue(Te,U){return U.a=Te.a,U.b=Te.b,U.c=Te.c,U.d=Te.d,U}function lt(Te,U){var ge=new ht(Te),_e=U&&U.state,re=function(){return(ge.next()>>>0)/4294967296};return re.double=function(){do{var $e=((ge.next()>>>11)+(ge.next()>>>0)/4294967296)/(1<<21)}while(0===$e);return $e},re.int32=ge.next,re.quick=re,_e&&("object"==typeof _e&&Ue(_e,ge),re.state=function(){return Ue(ge,{})}),re}Xe&&Xe.exports?Xe.exports=lt:Q.amdD&&Q.amdO?void 0!==(We=function(){return lt}.call(vt,Q,vt,Xe))&&(Xe.exports=We):this.tychei=lt}(0,xt=Q.nmd(xt))},992:function(xt,vt,Q){var We;!function(qn,Xe,hn){function ht(Te){var U=this,ge="";U.x=0,U.y=0,U.z=0,U.w=0,U.next=function(){var re=U.x^U.x<<11;return U.x=U.y,U.y=U.z,U.z=U.w,U.w^=U.w>>>19^re^re>>>8},Te===(0|Te)?U.x=Te:ge+=Te;for(var _e=0;_e<ge.length+64;_e++)U.x^=0|ge.charCodeAt(_e),U.next()}function Ue(Te,U){return U.x=Te.x,U.y=Te.y,U.z=Te.z,U.w=Te.w,U}function lt(Te,U){var ge=new ht(Te),_e=U&&U.state,re=function(){return(ge.next()>>>0)/4294967296};return re.double=function(){do{var $e=((ge.next()>>>11)+(ge.next()>>>0)/4294967296)/(1<<21)}while(0===$e);return $e},re.int32=ge.next,re.quick=re,_e&&("object"==typeof _e&&Ue(_e,ge),re.state=function(){return Ue(ge,{})}),re}Xe&&Xe.exports?Xe.exports=lt:Q.amdD&&Q.amdO?void 0!==(We=function(){return lt}.call(vt,Q,vt,Xe))&&(Xe.exports=We):this.xor128=lt}(0,xt=Q.nmd(xt))},929:function(xt,vt,Q){var We;!function(qn,Xe,hn){function ht(Te){var U=this;U.next=function(){var Ae,$e,_e=U.w,re=U.X,me=U.i;return U.w=_e=_e+1640531527|0,$e=re[me+34&127],Ae=re[me=me+1&127],$e^=$e<<13,Ae^=Ae<<17,$e=re[me]=($e^=$e>>>15)^(Ae^=Ae>>>12),U.i=me,$e+(_e^_e>>>16)|0},function ge(_e,re){var me,Ae,$e,Bt,Kn,Bn=[],si=128;for(re===(0|re)?(Ae=re,re=null):(re+="\0",Ae=0,si=Math.max(si,re.length)),$e=0,Bt=-32;Bt<si;++Bt)re&&(Ae^=re.charCodeAt((Bt+32)%re.length)),0===Bt&&(Kn=Ae),Ae^=Ae<<10,Ae^=Ae>>>15,Ae^=Ae<<4,Ae^=Ae>>>13,Bt>=0&&($e=0==(me=Bn[127&Bt]^=Ae+(Kn=Kn+1640531527|0))?$e+1:0);for($e>=128&&(Bn[127&(re&&re.length||0)]=-1),$e=127,Bt=512;Bt>0;--Bt)Ae=Bn[$e+34&127],me=Bn[$e=$e+1&127],Ae^=Ae<<13,me^=me<<17,Bn[$e]=(Ae^=Ae>>>15)^(me^=me>>>12);_e.w=Kn,_e.X=Bn,_e.i=$e}(U,Te)}function Ue(Te,U){return U.i=Te.i,U.w=Te.w,U.X=Te.X.slice(),U}function lt(Te,U){null==Te&&(Te=+new Date);var ge=new ht(Te),_e=U&&U.state,re=function(){return(ge.next()>>>0)/4294967296};return re.double=function(){do{var $e=((ge.next()>>>11)+(ge.next()>>>0)/4294967296)/(1<<21)}while(0===$e);return $e},re.int32=ge.next,re.quick=re,_e&&(_e.X&&Ue(_e,ge),re.state=function(){return Ue(ge,{})}),re}Xe&&Xe.exports?Xe.exports=lt:Q.amdD&&Q.amdO?void 0!==(We=function(){return lt}.call(vt,Q,vt,Xe))&&(Xe.exports=We):this.xor4096=lt}(0,xt=Q.nmd(xt))},583:function(xt,vt,Q){var We;!function(qn,Xe,hn){function ht(Te){var U=this;U.next=function(){var me,Ae,_e=U.x,re=U.i;return me=_e[re],Ae=(me^=me>>>7)^me<<24,Ae^=(me=_e[re+1&7])^me>>>10,Ae^=(me=_e[re+3&7])^me>>>3,Ae^=(me=_e[re+4&7])^me<<7,me=_e[re+7&7],_e[re]=Ae^=(me^=me<<13)^me<<9,U.i=re+1&7,Ae},function ge(_e,re){var me,$e=[];if(re===(0|re))$e[0]=re;else for(re=""+re,me=0;me<re.length;++me)$e[7&me]=$e[7&me]<<15^re.charCodeAt(me)+$e[me+1&7]<<13;for(;$e.length<8;)$e.push(0);for(me=0;me<8&&0===$e[me];++me);for(8==me&&($e[7]=-1),_e.x=$e,_e.i=0,me=256;me>0;--me)_e.next()}(U,Te)}function Ue(Te,U){return U.x=Te.x.slice(),U.i=Te.i,U}function lt(Te,U){null==Te&&(Te=+new Date);var ge=new ht(Te),_e=U&&U.state,re=function(){return(ge.next()>>>0)/4294967296};return re.double=function(){do{var $e=((ge.next()>>>11)+(ge.next()>>>0)/4294967296)/(1<<21)}while(0===$e);return $e},re.int32=ge.next,re.quick=re,_e&&(_e.x&&Ue(_e,ge),re.state=function(){return Ue(ge,{})}),re}Xe&&Xe.exports?Xe.exports=lt:Q.amdD&&Q.amdO?void 0!==(We=function(){return lt}.call(vt,Q,vt,Xe))&&(Xe.exports=We):this.xorshift7=lt}(0,xt=Q.nmd(xt))},657:function(xt,vt,Q){var We;!function(qn,Xe,hn){function ht(Te){var U=this,ge="";U.next=function(){var re=U.x^U.x>>>2;return U.x=U.y,U.y=U.z,U.z=U.w,U.w=U.v,(U.d=U.d+362437|0)+(U.v=U.v^U.v<<4^re^re<<1)|0},U.x=0,U.y=0,U.z=0,U.w=0,U.v=0,Te===(0|Te)?U.x=Te:ge+=Te;for(var _e=0;_e<ge.length+64;_e++)U.x^=0|ge.charCodeAt(_e),_e==ge.length&&(U.d=U.x<<10^U.x>>>4),U.next()}function Ue(Te,U){return U.x=Te.x,U.y=Te.y,U.z=Te.z,U.w=Te.w,U.v=Te.v,U.d=Te.d,U}function lt(Te,U){var ge=new ht(Te),_e=U&&U.state,re=function(){return(ge.next()>>>0)/4294967296};return re.double=function(){do{var $e=((ge.next()>>>11)+(ge.next()>>>0)/4294967296)/(1<<21)}while(0===$e);return $e},re.int32=ge.next,re.quick=re,_e&&("object"==typeof _e&&Ue(_e,ge),re.state=function(){return Ue(ge,{})}),re}Xe&&Xe.exports?Xe.exports=lt:Q.amdD&&Q.amdO?void 0!==(We=function(){return lt}.call(vt,Q,vt,Xe))&&(Xe.exports=We):this.xorwow=lt}(0,xt=Q.nmd(xt))},818:function(xt,vt,Q){var We;!function(qn,Xe,hn){var me,ht=256,U=hn.pow(ht,6),ge=hn.pow(2,52),_e=2*ge,re=ht-1;function Ae(Ct,Ft,Ot){var ce=[],J=Bn(Kn((Ft=1==Ft?{entropy:!0}:Ft||{}).entropy?[Ct,Rr(Xe)]:Ct??function si(){try{var Ct;return me&&(Ct=me.randomBytes)?Ct=Ct(ht):(Ct=new Uint8Array(ht),(qn.crypto||qn.msCrypto).getRandomValues(Ct)),Rr(Ct)}catch{var Ft=qn.navigator,Ot=Ft&&Ft.plugins;return[+new Date,qn,Ot,qn.screen,Rr(Xe)]}}(),3),ce),T=new $e(ce),pe=function(){for(var He=T.g(6),St=U,ft=0;He<ge;)He=(He+ft)*ht,St*=ht,ft=T.g(1);for(;He>=_e;)He/=2,St/=2,ft>>>=1;return(He+ft)/St};return pe.int32=function(){return 0|T.g(4)},pe.quick=function(){return T.g(4)/4294967296},pe.double=pe,Bn(Rr(T.S),Xe),(Ft.pass||Ot||function(He,St,ft,ut){return ut&&(ut.S&&Bt(ut,T),He.state=function(){return Bt(T,{})}),ft?(hn.random=He,St):He})(pe,J,"global"in Ft?Ft.global:this==hn,Ft.state)}function $e(Ct){var Ft,Ot=Ct.length,ce=this,J=0,T=ce.i=ce.j=0,pe=ce.S=[];for(Ot||(Ct=[Ot++]);J<ht;)pe[J]=J++;for(J=0;J<ht;J++)pe[J]=pe[T=re&T+Ct[J%Ot]+(Ft=pe[J])],pe[T]=Ft;(ce.g=function(He){for(var St,ft=0,ut=ce.i,An=ce.j,zn=ce.S;He--;)St=zn[ut=re&ut+1],ft=ft*ht+zn[re&(zn[ut]=zn[An=re&An+St])+(zn[An]=St)];return ce.i=ut,ce.j=An,ft})(ht)}function Bt(Ct,Ft){return Ft.i=Ct.i,Ft.j=Ct.j,Ft.S=Ct.S.slice(),Ft}function Kn(Ct,Ft){var J,Ot=[],ce=typeof Ct;if(Ft&&"object"==ce)for(J in Ct)try{Ot.push(Kn(Ct[J],Ft-1))}catch{}return Ot.length?Ot:"string"==ce?Ct:Ct+"\0"}function Bn(Ct,Ft){for(var ce,Ot=Ct+"",J=0;J<Ot.length;)Ft[re&J]=re&(ce^=19*Ft[re&J])+Ot.charCodeAt(J++);return Rr(Ft)}function Rr(Ct){return String.fromCharCode.apply(0,Ct)}if(Bn(hn.random(),Xe),xt.exports){xt.exports=Ae;try{me=Q(42)}catch{}}else void 0!==(We=function(){return Ae}.call(vt,Q,vt,xt))&&(xt.exports=We)}(typeof self<"u"?self:this,[],Math)},410:()=>{},628:()=>{},601:()=>{},792:()=>{},977:()=>{},42:()=>{}},xt=>{xt(xt.s=189)}]);