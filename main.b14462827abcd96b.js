(self.webpackChunkwams_ml_app=self.webpackChunkwams_ml_app||[]).push([[179],{165:(me,E,P)=>{"use strict";var F={};P.r(F),P.d(F,{browserFiles:()=>jie,browserHTTPRequest:()=>Yie,concatenateArrayBuffers:()=>H0,copyModel:()=>fie,decodeWeights:()=>T3,encodeWeights:()=>OI,fromMemory:()=>Qie,fromMemorySync:()=>Q3,getLoadHandlers:()=>tie,getModelArtifactsForJSON:()=>FI,getModelArtifactsForJSONSync:()=>E3,getModelArtifactsInfoForJSON:()=>og,getSaveHandlers:()=>k3,getWeightSpecs:()=>D3,http:()=>JI,isHTTPScheme:()=>QI,listModels:()=>hie,loadWeights:()=>Wie,moveModel:()=>mie,registerLoadRouter:()=>eie,registerSaveRouter:()=>Jre,removeModel:()=>pie,weightsLoaderFactory:()=>K3,withSaveHandler:()=>Jie,withSaveHandlerSync:()=>eoe});var A={};P.r(A),P.d(A,{assertParamsValid:()=>nE,computeFlatOffset:()=>oE,computeOutShape:()=>rE,getNormalizedAxes:()=>roe,isSliceContinous:()=>iE,maskToAxes:()=>noe,parseSliceParams:()=>X0,sliceInfo:()=>sE,startForAxis:()=>oB,startIndicesWithElidedDims:()=>nB,stopForAxis:()=>sB,stopIndicesWithElidedDims:()=>rB,stridesForAxis:()=>iB,stridesWithElidedDims:()=>J3});var O={};P.r(O),P.d(O,{conv2d:()=>sV,depthwiseConv2d:()=>Cce,matMul:()=>WE});var k={};P.r(k),P.d(k,{collectGatherOpShapeInfo:()=>xD,computeOutShape:()=>zV,segOpComputeOptimalWindowSize:()=>VV});var S={};P.r(S),P.d(S,{ERF_A1:()=>aD,ERF_A2:()=>lD,ERF_A3:()=>cD,ERF_A4:()=>uD,ERF_A5:()=>dD,ERF_P:()=>sD,PARALLELIZE_THRESHOLD:()=>tD,RowPartitionType:()=>fr,SELU_SCALE:()=>wv,SELU_SCALEALPHA:()=>xv,applyActivation:()=>yv,assertAndGetBroadcastShape:()=>Yt,assertAxesAreInnerMostDims:()=>ki,assertParamsConsistent:()=>eD,assignToTypedArray:()=>SV,axesAreInnerMostDims:()=>gE,calculateShapes:()=>Lu,checkEinsumDimSizes:()=>gD,checkPadOnDimRoundingMode:()=>oo,combineLocations:()=>MB,combineRaggedTensorToTensorShapes:()=>bV,complexWithEvenIndex:()=>wV,complexWithOddIndex:()=>TV,computeConv2DInfo:()=>mi,computeConv3DInfo:()=>xc,computeDefaultPad:()=>lE,computeDilation2DInfo:()=>sg,computeOptimalWindowSize:()=>vv,computeOutAndReduceShapes:()=>gi,computeOutShape:()=>Va,computePool2DInfo:()=>Rs,computePool3DInfo:()=>wl,convertConv2DDataFormat:()=>Tl,decodeEinsumEquation:()=>fD,eitherStridesOrDilationsAreOne:()=>Di,expandShapeToKeepDim:()=>Rr,exponent:()=>IV,exponents:()=>CV,fromStringArrayToUint8:()=>UV,fromUint8ToStringArray:()=>Il,getAxesPermutation:()=>hr,getBroadcastDims:()=>Nh,getComplexWithIndex:()=>hD,getEinsumComputePath:()=>bD,getEinsumPermutation:()=>mD,getFusedBiasGradient:()=>bv,getFusedDyActivation:()=>gv,getImageCenter:()=>nD,getInnerMostAxes:()=>Mr,getPermuted:()=>xg,getRaggedRank:()=>_V,getReductionAxes:()=>ti,getReshaped:()=>vg,getReshapedPermuted:()=>wg,getRowPartitionTypesHelper:()=>yV,getSliceBeginCoords:()=>rD,getSliceSize:()=>iD,getSparseFillEmptyRowsIndicesDenseShapeMismatch:()=>kV,getSparseFillEmptyRowsNegativeIndexErrorMessage:()=>AV,getSparseFillEmptyRowsOutOfRangeIndexErrorMessage:()=>NV,getSparseReshapeEmptyTensorZeroOutputDimErrorMessage:()=>MV,getSparseReshapeInputOutputMismatchErrorMessage:()=>PV,getSparseReshapeInputOutputMultipleErrorMessage:()=>FV,getSparseReshapeMultipleNegativeOneOutputDimErrorMessage:()=>OV,getSparseReshapeNegativeOutputDimErrorMessage:()=>RV,getSparseSegmentReductionIndicesOutOfRangeErrorMessage:()=>BV,getSparseSegmentReductionNegativeSegmentIdsErrorMessage:()=>vD,getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage:()=>$V,getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage:()=>LV,getUndoAxesPermutation:()=>Sc,isIdentityPermutation:()=>yD,log:()=>_re,mergeRealAndImagArrays:()=>Cl,prepareAndValidate:()=>oD,prepareSplitSize:()=>_D,segment_util:()=>k,shouldFuse:()=>_v,slice_util:()=>A,splitRealAndImagArrays:()=>xV,stridesOrDilationsArePositive:()=>Ru,tupleValuesAreOne:()=>wc,upcastType:()=>zo,validateDefaultValueShape:()=>vV,validateInput:()=>$E,validateUpdateShape:()=>JB,warn:()=>as});var C={};P.r(C),P.d(C,{json:()=>cme});var v={};P.r(v),P.d(v,{json:()=>ume});var b={};P.r(b),P.d(b,{json:()=>dme});var h={};P.r(h),P.d(h,{json:()=>hme});var l={};P.r(l),P.d(l,{json:()=>pme});var d={};P.r(d),P.d(d,{json:()=>fme});var f={};P.r(f),P.d(f,{json:()=>mme});var y={};P.r(y),P.d(y,{json:()=>gme});var w={};P.r(w),P.d(w,{json:()=>bme});var D={};P.r(D),P.d(D,{json:()=>yme});var M={};P.r(M),P.d(M,{json:()=>_me});var $={};P.r($),P.d($,{json:()=>vme});var B={};P.r(B),P.d(B,{json:()=>xme});var z={};P.r(z),P.d(z,{json:()=>wme});var G={};P.r(G),P.d(G,{json:()=>Tme});var H={};P.r(H),P.d(H,{json:()=>Sme});var te={};P.r(te),P.d(te,{json:()=>Cme});var ae={};P.r(ae),P.d(ae,{json:()=>Ime});var J={};P.r(J),P.d(J,{json:()=>Eme});var ne={};P.r(ne),P.d(ne,{OP_SCOPE_SUFFIX:()=>w3,abs:()=>ei,acos:()=>lB,acosh:()=>cB,add:()=>Xe,addN:()=>coe,all:()=>aE,any:()=>Y0,argMax:()=>Oh,argMin:()=>uB,asin:()=>dB,asinh:()=>hB,atan:()=>pB,atan2:()=>fB,atanh:()=>mB,avgPool:()=>Z0,avgPool3d:()=>gB,basicLSTMCell:()=>Ooe,batchNorm:()=>cg,batchNorm2d:()=>bB,batchNorm3d:()=>yB,batchNorm4d:()=>_B,batchToSpaceND:()=>Q0,bincount:()=>vB,bitwiseAnd:()=>zoe,booleanMaskAsync:()=>oce,broadcastArgs:()=>joe,broadcastTo:()=>Fh,buffer:()=>sn,cast:()=>ht,ceil:()=>xB,clipByValue:()=>Uo,clone:()=>_l,complex:()=>gc,concat:()=>Ur,concat1d:()=>wB,concat2d:()=>TB,concat3d:()=>SB,concat4d:()=>CB,conv1d:()=>uE,conv2d:()=>Tc,conv2dTranspose:()=>hE,conv3d:()=>IB,conv3dTranspose:()=>DB,cos:()=>J0,cosh:()=>pE,cosineWindow:()=>jE,cumprod:()=>ev,cumsum:()=>fE,denseBincount:()=>mE,depthToSpace:()=>kB,depthwiseConv2d:()=>ug,diag:()=>hse,dilation2d:()=>AB,div:()=>Nt,divNoNan:()=>NB,dot:()=>OB,dropout:()=>iV,einsum:()=>_se,elu:()=>dg,enclosingPowerOfTwo:()=>oV,ensureShape:()=>wse,equal:()=>la,erf:()=>RB,euclideanNorm:()=>PB,exp:()=>ls,expandDims:()=>To,expm1:()=>$B,eye:()=>bE,fft:()=>fv,fill:()=>Ah,floor:()=>fg,floorDiv:()=>qI,fused:()=>O,gather:()=>mg,gatherND:()=>mce,greater:()=>jo,greaterEqual:()=>Cc,ifft:()=>_g,imag:()=>tv,image:()=>Ba,inTopKAsync:()=>_ce,irfft:()=>FE,isFinite:()=>LB,isInf:()=>BB,isNaN:()=>VB,leakyRelu:()=>nv,less:()=>gg,lessEqual:()=>Mu,linalg:()=>mV,linspace:()=>Hse,localResponseNormalization:()=>zB,log:()=>cs,log1p:()=>rv,logSigmoid:()=>UB,logSoftmax:()=>yE,logSumExp:()=>_E,logicalAnd:()=>$a,logicalNot:()=>iv,logicalOr:()=>vE,logicalXor:()=>jB,losses:()=>tde,lowerBound:()=>oae,matMul:()=>hn,max:()=>Ms,maxPool:()=>sv,maxPool3d:()=>GB,maxPoolWithArgmax:()=>cae,maximum:()=>xl,mean:()=>Sr,meshgrid:()=>dae,min:()=>hg,minimum:()=>Fu,mirrorPad:()=>HB,mod:()=>WB,moments:()=>av,movingAverage:()=>lce,mul:()=>fe,multiRNNCell:()=>bae,multinomial:()=>_ae,neg:()=>tr,norm:()=>pg,notEqual:()=>$h,oneHot:()=>wE,ones:()=>us,onesLike:()=>ds,op:()=>ue,outerProduct:()=>Sae,pad:()=>Ic,pad1d:()=>Eae,pad2d:()=>kae,pad3d:()=>Nae,pad4d:()=>Rae,pool:()=>qB,pow:()=>vc,prelu:()=>cv,print:()=>$3,prod:()=>KB,raggedGather:()=>zae,raggedRange:()=>jae,raggedTensorToTensor:()=>Hae,rand:()=>qae,randomGamma:()=>ele,randomNormal:()=>CE,randomStandardNormal:()=>rle,randomUniform:()=>Pu,randomUniformInt:()=>sle,range:()=>Lh,real:()=>bg,reciprocal:()=>XB,relu:()=>La,relu6:()=>IE,reshape:()=>be,reverse:()=>Ps,reverse1d:()=>ple,reverse2d:()=>mle,reverse3d:()=>ble,reverse4d:()=>_le,rfft:()=>mv,round:()=>EE,rsqrt:()=>DE,scalar:()=>Ft,scatterND:()=>uce,searchSorted:()=>xE,selu:()=>kE,separableConv2d:()=>AE,setdiff1dAsync:()=>Cle,sigmoid:()=>Pa,sign:()=>YB,signal:()=>ede,sin:()=>OE,sinh:()=>RE,slice:()=>xn,slice1d:()=>dv,slice2d:()=>ME,slice3d:()=>hv,slice4d:()=>yg,softmax:()=>pv,softplus:()=>Ph,spaceToBatchND:()=>lv,sparse:()=>nde,sparseToDense:()=>pce,spectral:()=>Jue,split:()=>Go,sqrt:()=>ji,square:()=>Hn,squaredDifference:()=>PE,squeeze:()=>$u,stack:()=>hs,step:()=>Bh,stridedSlice:()=>ZB,string:()=>rde,sub:()=>xt,sum:()=>St,tan:()=>QB,tanh:()=>Mh,tensor:()=>aa,tensor1d:()=>So,tensor2d:()=>Vh,tensor3d:()=>Hle,tensor4d:()=>Wle,tensor5d:()=>qle,tensor6d:()=>Kle,tensorScatterUpdate:()=>Yle,tile:()=>Fs,topk:()=>eV,transpose:()=>wn,truncatedNormal:()=>LE,unique:()=>tV,unsortedSegmentSum:()=>BE,unstack:()=>$s,upperBound:()=>nce,variable:()=>nV,where:()=>Gi,whereAsync:()=>rV,zeros:()=>ni,zerosLike:()=>vn});var X={};function K(n){return"function"==typeof n}function ve(n){const e=n(r=>{Error.call(r),r.stack=(new Error).stack});return e.prototype=Object.create(Error.prototype),e.prototype.constructor=e,e}P.r(X),P.d(X,{addImpl:()=>eU,bincountImpl:()=>Fk,bincountReduceImpl:()=>sU,castImpl:()=>Jz,ceilImpl:()=>aU,concatImpl:()=>lU,equalImpl:()=>dU,expImpl:()=>pU,expm1Impl:()=>mU,floorImpl:()=>yU,gatherNdImpl:()=>_U,gatherV2Impl:()=>vU,greaterEqualImpl:()=>wU,greaterImpl:()=>xU,lessEqualImpl:()=>SU,lessImpl:()=>TU,linSpaceImpl:()=>CU,logImpl:()=>IU,maxImpl:()=>EU,maximumImpl:()=>kU,minimumImpl:()=>AU,multiplyImpl:()=>Pk,negImpl:()=>OU,notEqualImpl:()=>RU,prodImpl:()=>$U,raggedGatherImpl:()=>BU,raggedRangeImpl:()=>zU,raggedTensorToTensorImpl:()=>GU,rangeImpl:()=>HU,rsqrtImpl:()=>WU,scatterImpl:()=>Xu,sigmoidImpl:()=>Qge,simpleAbsImpl:()=>nU,sliceImpl:()=>oU,sparseFillEmptyRowsImpl:()=>KU,sparseReshapeImpl:()=>XU,sparseSegmentReductionImpl:()=>Uk,sqrtImpl:()=>Sxe,staticRegexReplaceImpl:()=>YU,stridedSliceImpl:()=>ZU,stringNGramsImpl:()=>QU,stringSplitImpl:()=>JU,stringToHashBucketFastImpl:()=>ej,subImpl:()=>gU,tileImpl:()=>tj,topKImpl:()=>rj,transposeImpl:()=>Rk,uniqueImpl:()=>oj});const q=ve(n=>function(e){n(this),this.message=e?`${e.length} errors occurred during unsubscription:\n${e.map((r,i)=>`${i+1}) ${r.toString()}`).join("\n  ")}`:"",this.name="UnsubscriptionError",this.errors=e});function re(n,t){if(n){const e=n.indexOf(t);0<=e&&n.splice(e,1)}}class le{constructor(t){this.initialTeardown=t,this.closed=!1,this._parentage=null,this._finalizers=null}unsubscribe(){let t;if(!this.closed){this.closed=!0;const{_parentage:e}=this;if(e)if(this._parentage=null,Array.isArray(e))for(const o of e)o.remove(this);else e.remove(this);const{initialTeardown:r}=this;if(K(r))try{r()}catch(o){t=o instanceof q?o.errors:[o]}const{_finalizers:i}=this;if(i){this._finalizers=null;for(const o of i)try{ot(o)}catch(s){t=t??[],s instanceof q?t=[...t,...s.errors]:t.push(s)}}if(t)throw new q(t)}}add(t){var e;if(t&&t!==this)if(this.closed)ot(t);else{if(t instanceof le){if(t.closed||t._hasParent(this))return;t._addParent(this)}(this._finalizers=null!==(e=this._finalizers)&&void 0!==e?e:[]).push(t)}}_hasParent(t){const{_parentage:e}=this;return e===t||Array.isArray(e)&&e.includes(t)}_addParent(t){const{_parentage:e}=this;this._parentage=Array.isArray(e)?(e.push(t),e):e?[e,t]:t}_removeParent(t){const{_parentage:e}=this;e===t?this._parentage=null:Array.isArray(e)&&re(e,t)}remove(t){const{_finalizers:e}=this;e&&re(e,t),t instanceof le&&t._removeParent(this)}}le.EMPTY=(()=>{const n=new le;return n.closed=!0,n})();const He=le.EMPTY;function Le(n){return n instanceof le||n&&"closed"in n&&K(n.remove)&&K(n.add)&&K(n.unsubscribe)}function ot(n){K(n)?n():n.unsubscribe()}const nt={onUnhandledError:null,onStoppedNotification:null,Promise:void 0,useDeprecatedSynchronousErrorHandling:!1,useDeprecatedNextContext:!1},it={setTimeout(n,t,...e){const{delegate:r}=it;return r?.setTimeout?r.setTimeout(n,t,...e):setTimeout(n,t,...e)},clearTimeout(n){const{delegate:t}=it;return(t?.clearTimeout||clearTimeout)(n)},delegate:void 0};function yt(n){it.setTimeout(()=>{const{onUnhandledError:t}=nt;if(!t)throw n;t(n)})}function wt(){}const Pt=ur("C",void 0,void 0);function ur(n,t,e){return{kind:n,value:t,error:e}}let Ir=null;function Ri(n){if(nt.useDeprecatedSynchronousErrorHandling){const t=!Ir;if(t&&(Ir={errorThrown:!1,error:null}),n(),t){const{errorThrown:e,error:r}=Ir;if(Ir=null,e)throw r}}else n()}class jr extends le{constructor(t){super(),this.isStopped=!1,t?(this.destination=t,Le(t)&&t.add(this)):this.destination=qi}static create(t,e,r){return new Lr(t,e,r)}next(t){this.isStopped?Yo(function Cn(n){return ur("N",n,void 0)}(t),this):this._next(t)}error(t){this.isStopped?Yo(function pn(n){return ur("E",void 0,n)}(t),this):(this.isStopped=!0,this._error(t))}complete(){this.isStopped?Yo(Pt,this):(this.isStopped=!0,this._complete())}unsubscribe(){this.closed||(this.isStopped=!0,super.unsubscribe(),this.destination=null)}_next(t){this.destination.next(t)}_error(t){try{this.destination.error(t)}finally{this.unsubscribe()}}_complete(){try{this.destination.complete()}finally{this.unsubscribe()}}}const Xo=Function.prototype.bind;function kn(n,t){return Xo.call(n,t)}class Mi{constructor(t){this.partialObserver=t}next(t){const{partialObserver:e}=this;if(e.next)try{e.next(t)}catch(r){Gr(r)}}error(t){const{partialObserver:e}=this;if(e.error)try{e.error(t)}catch(r){Gr(r)}else Gr(t)}complete(){const{partialObserver:t}=this;if(t.complete)try{t.complete()}catch(e){Gr(e)}}}class Lr extends jr{constructor(t,e,r){let i;if(super(),K(t)||!t)i={next:t??void 0,error:e??void 0,complete:r??void 0};else{let o;this&&nt.useDeprecatedNextContext?(o=Object.create(t),o.unsubscribe=()=>this.unsubscribe(),i={next:t.next&&kn(t.next,o),error:t.error&&kn(t.error,o),complete:t.complete&&kn(t.complete,o)}):i=t}this.destination=new Mi(i)}}function Gr(n){nt.useDeprecatedSynchronousErrorHandling?function Ko(n){nt.useDeprecatedSynchronousErrorHandling&&Ir&&(Ir.errorThrown=!0,Ir.error=n)}(n):yt(n)}function Yo(n,t){const{onStoppedNotification:e}=nt;e&&it.setTimeout(()=>e(n,t))}const qi={closed:!0,next:wt,error:function Fi(n){throw n},complete:wt},ws="function"==typeof Symbol&&Symbol.observable||"@@observable";function Hr(n){return n}function Qa(n){return 0===n.length?Hr:1===n.length?n[0]:function(e){return n.reduce((r,i)=>i(r),e)}}let An=(()=>{class n{constructor(e){e&&(this._subscribe=e)}lift(e){const r=new n;return r.source=this,r.operator=e,r}subscribe(e,r,i){const o=function Bl(n){return n&&n instanceof jr||function Ja(n){return n&&K(n.next)&&K(n.error)&&K(n.complete)}(n)&&Le(n)}(e)?e:new Lr(e,r,i);return Ri(()=>{const{operator:s,source:a}=this;o.add(s?s.call(o,a):a?this._subscribe(o):this._trySubscribe(o))}),o}_trySubscribe(e){try{return this._subscribe(e)}catch(r){e.error(r)}}forEach(e,r){return new(r=Qc(r))((i,o)=>{const s=new Lr({next:a=>{try{e(a)}catch(c){o(c),s.unsubscribe()}},error:o,complete:i});this.subscribe(s)})}_subscribe(e){var r;return null===(r=this.source)||void 0===r?void 0:r.subscribe(e)}[ws](){return this}pipe(...e){return Qa(e)(this)}toPromise(e){return new(e=Qc(e))((r,i)=>{let o;this.subscribe(s=>o=s,s=>i(s),()=>r(o))})}}return n.create=t=>new n(t),n})();function Qc(n){var t;return null!==(t=n??nt.Promise)&&void 0!==t?t:Promise}const Jc=ve(n=>function(){n(this),this.name="ObjectUnsubscribedError",this.message="object unsubscribed"});let Kt=(()=>{class n extends An{constructor(){super(),this.closed=!1,this.currentObservers=null,this.observers=[],this.isStopped=!1,this.hasError=!1,this.thrownError=null}lift(e){const r=new eu(this,this);return r.operator=e,r}_throwIfClosed(){if(this.closed)throw new Jc}next(e){Ri(()=>{if(this._throwIfClosed(),!this.isStopped){this.currentObservers||(this.currentObservers=Array.from(this.observers));for(const r of this.currentObservers)r.next(e)}})}error(e){Ri(()=>{if(this._throwIfClosed(),!this.isStopped){this.hasError=this.isStopped=!0,this.thrownError=e;const{observers:r}=this;for(;r.length;)r.shift().error(e)}})}complete(){Ri(()=>{if(this._throwIfClosed(),!this.isStopped){this.isStopped=!0;const{observers:e}=this;for(;e.length;)e.shift().complete()}})}unsubscribe(){this.isStopped=this.closed=!0,this.observers=this.currentObservers=null}get observed(){var e;return(null===(e=this.observers)||void 0===e?void 0:e.length)>0}_trySubscribe(e){return this._throwIfClosed(),super._trySubscribe(e)}_subscribe(e){return this._throwIfClosed(),this._checkFinalizedStatuses(e),this._innerSubscribe(e)}_innerSubscribe(e){const{hasError:r,isStopped:i,observers:o}=this;return r||i?He:(this.currentObservers=null,o.push(e),new le(()=>{this.currentObservers=null,re(o,e)}))}_checkFinalizedStatuses(e){const{hasError:r,thrownError:i,isStopped:o}=this;r?e.error(i):o&&e.complete()}asObservable(){const e=new An;return e.source=this,e}}return n.create=(t,e)=>new eu(t,e),n})();class eu extends Kt{constructor(t,e){super(),this.destination=t,this.source=e}next(t){var e,r;null===(r=null===(e=this.destination)||void 0===e?void 0:e.next)||void 0===r||r.call(e,t)}error(t){var e,r;null===(r=null===(e=this.destination)||void 0===e?void 0:e.error)||void 0===r||r.call(e,t)}complete(){var t,e;null===(e=null===(t=this.destination)||void 0===t?void 0:t.complete)||void 0===e||e.call(t)}_subscribe(t){var e,r;return null!==(r=null===(e=this.source)||void 0===e?void 0:e.subscribe(t))&&void 0!==r?r:He}}function Vl(n){return K(n?.lift)}function Rn(n){return t=>{if(Vl(t))return t.lift(function(e){try{return n(e,this)}catch(r){this.error(r)}});throw new TypeError("Unable to lift unknown Observable type")}}function Bn(n,t,e,r,i){return new zl(n,t,e,r,i)}class zl extends jr{constructor(t,e,r,i,o,s){super(t),this.onFinalize=o,this.shouldUnsubscribe=s,this._next=e?function(a){try{e(a)}catch(c){t.error(c)}}:super._next,this._error=i?function(a){try{i(a)}catch(c){t.error(c)}finally{this.unsubscribe()}}:super._error,this._complete=r?function(){try{r()}catch(a){t.error(a)}finally{this.unsubscribe()}}:super._complete}unsubscribe(){var t;if(!this.shouldUnsubscribe||this.shouldUnsubscribe()){const{closed:e}=this;super.unsubscribe(),!e&&(null===(t=this.onFinalize)||void 0===t||t.call(this))}}}function ct(n,t){return Rn((e,r)=>{let i=0;e.subscribe(Bn(r,o=>{r.next(n.call(t,o,i++))}))})}function ba(n){return this instanceof ba?(this.v=n,this):new ba(n)}function xp(n){if(!Symbol.asyncIterator)throw new TypeError("Symbol.asyncIterator is not defined.");var e,t=n[Symbol.asyncIterator];return t?t.call(n):(n=function Ve(n){var t="function"==typeof Symbol&&Symbol.iterator,e=t&&n[t],r=0;if(e)return e.call(n);if(n&&"number"==typeof n.length)return{next:function(){return n&&r>=n.length&&(n=void 0),{value:n&&n[r++],done:!n}}};throw new TypeError(t?"Object is not iterable.":"Symbol.iterator is not defined.")}(n),e={},r("next"),r("throw"),r("return"),e[Symbol.asyncIterator]=function(){return this},e);function r(o){e[o]=n[o]&&function(s){return new Promise(function(a,c){!function i(o,s,a,c){Promise.resolve(c).then(function(u){o({value:u,done:a})},s)}(a,c,(s=n[o](s)).done,s.value)})}}}const Tp=n=>n&&"number"==typeof n.length&&"function"!=typeof n;function qn(n){return K(n?.then)}function pd(n){return K(n[ws])}function fd(n){return Symbol.asyncIterator&&K(n?.[Symbol.asyncIterator])}function md(n){return new TypeError(`You provided ${null!==n&&"object"==typeof n?"an invalid object":`'${n}'`} where a stream was expected. You can provide an Observable, Promise, ReadableStream, Array, AsyncIterable, or Iterable.`)}const Sp=function _b(){return"function"==typeof Symbol&&Symbol.iterator?Symbol.iterator:"@@iterator"}();function Cp(n){return K(n?.[Sp])}function Ip(n){return function yb(n,t,e){if(!Symbol.asyncIterator)throw new TypeError("Symbol.asyncIterator is not defined.");var i,r=e.apply(n,t||[]),o=[];return i={},s("next"),s("throw"),s("return"),i[Symbol.asyncIterator]=function(){return this},i;function s(g){r[g]&&(i[g]=function(_){return new Promise(function(x,T){o.push([g,_,x,T])>1||a(g,_)})})}function a(g,_){try{!function c(g){g.value instanceof ba?Promise.resolve(g.value.v).then(u,p):m(o[0][2],g)}(r[g](_))}catch(x){m(o[0][3],x)}}function u(g){a("next",g)}function p(g){a("throw",g)}function m(g,_){g(_),o.shift(),o.length&&a(o[0][0],o[0][1])}}(this,arguments,function*(){const e=n.getReader();try{for(;;){const{value:r,done:i}=yield ba(e.read());if(i)return yield ba(void 0);yield yield ba(r)}}finally{e.releaseLock()}})}function Ep(n){return K(n?.getReader)}function wi(n){if(n instanceof An)return n;if(null!=n){if(pd(n))return function yw(n){return new An(t=>{const e=n[ws]();if(K(e.subscribe))return e.subscribe(t);throw new TypeError("Provided object does not correctly implement Symbol.observable")})}(n);if(Tp(n))return function vb(n){return new An(t=>{for(let e=0;e<n.length&&!t.closed;e++)t.next(n[e]);t.complete()})}(n);if(qn(n))return function xb(n){return new An(t=>{n.then(e=>{t.closed||(t.next(e),t.complete())},e=>t.error(e)).then(null,yt)})}(n);if(fd(n))return Dp(n);if(Cp(n))return function wb(n){return new An(t=>{for(const e of n)if(t.next(e),t.closed)return;t.complete()})}(n);if(Ep(n))return function _w(n){return Dp(Ip(n))}(n)}throw md(n)}function Dp(n){return new An(t=>{(function Tb(n,t){var e,r,i,o;return function vi(n,t,e,r){return new(e||(e=Promise))(function(o,s){function a(p){try{u(r.next(p))}catch(m){s(m)}}function c(p){try{u(r.throw(p))}catch(m){s(m)}}function u(p){p.done?o(p.value):function i(o){return o instanceof e?o:new e(function(s){s(o)})}(p.value).then(a,c)}u((r=r.apply(n,t||[])).next())})}(this,void 0,void 0,function*(){try{for(e=xp(n);!(r=yield e.next()).done;)if(t.next(r.value),t.closed)return}catch(s){i={error:s}}finally{try{r&&!r.done&&(o=e.return)&&(yield o.call(e))}finally{if(i)throw i.error}}t.complete()})})(n,t).catch(e=>t.error(e))})}function Xs(n,t,e,r=0,i=!1){const o=t.schedule(function(){e(),i?n.add(this.schedule(null,r)):this.unsubscribe()},r);if(n.add(o),!i)return o}function yr(n,t,e=1/0){return K(t)?yr((r,i)=>ct((o,s)=>t(r,o,i,s))(wi(n(r,i))),e):("number"==typeof t&&(e=t),Rn((r,i)=>function vw(n,t,e,r,i,o,s,a){const c=[];let u=0,p=0,m=!1;const g=()=>{m&&!c.length&&!u&&t.complete()},_=T=>u<r?x(T):c.push(T),x=T=>{o&&t.next(T),u++;let I=!1;wi(e(T,p++)).subscribe(Bn(t,N=>{i?.(N),o?_(N):t.next(N)},()=>{I=!0},void 0,()=>{if(I)try{for(u--;c.length&&u<r;){const N=c.shift();s?Xs(t,s,()=>x(N)):x(N)}g()}catch(N){t.error(N)}}))};return n.subscribe(Bn(t,_,()=>{m=!0,g()})),()=>{a?.()}}(r,i,n,e)))}function el(n=1/0){return yr(Hr,n)}const ho=new An(n=>n.complete());function gd(n){return n&&K(n.schedule)}function tu(n){return n[n.length-1]}function Ap(n){return K(tu(n))?n.pop():void 0}function Gl(n){return gd(tu(n))?n.pop():void 0}function bd(n,t=0){return Rn((e,r)=>{e.subscribe(Bn(r,i=>Xs(r,n,()=>r.next(i),t),()=>Xs(r,n,()=>r.complete(),t),i=>Xs(r,n,()=>r.error(i),t)))})}function nu(n,t=0){return Rn((e,r)=>{r.add(n.schedule(()=>e.subscribe(r),t))})}function ge(n,t){if(!n)throw new Error("Iterable cannot be null");return new An(e=>{Xs(e,t,()=>{const r=n[Symbol.asyncIterator]();Xs(e,t,()=>{r.next().then(i=>{i.done?e.complete():e.next(i.value)})},0,!0)})})}function tt(n,t){return t?function Be(n,t){if(null!=n){if(pd(n))return function Np(n,t){return wi(n).pipe(nu(t),bd(t))}(n,t);if(Tp(n))return function W(n,t){return new An(e=>{let r=0;return t.schedule(function(){r===n.length?e.complete():(e.next(n[r++]),e.closed||this.schedule())})})}(n,t);if(qn(n))return function Ib(n,t){return wi(n).pipe(nu(t),bd(t))}(n,t);if(fd(n))return ge(n,t);if(Cp(n))return function oe(n,t){return new An(e=>{let r;return Xs(e,t,()=>{r=n[Sp](),Xs(e,t,()=>{let i,o;try{({value:i,done:o}=r.next())}catch(s){return void e.error(s)}o?e.complete():e.next(i)},0,!0)}),()=>K(r?.return)&&r.return()})}(n,t);if(Ep(n))return function ke(n,t){return ge(Ip(n),t)}(n,t)}throw md(n)}(n,t):wi(n)}function Et(...n){const t=Gl(n),e=function Cb(n,t){return"number"==typeof tu(n)?n.pop():t}(n,1/0),r=n;return r.length?1===r.length?wi(r[0]):el(e)(tt(r,t)):ho}function Ki(n,t,...e){if(!0===t)return void n();if(!1===t)return;const r=new Lr({next:()=>{r.unsubscribe(),n()}});return wi(t(...e)).subscribe(r)}function Ht(n){for(let t in n)if(n[t]===Ht)return t;throw Error("Could not find renamed property on target object.")}function Ti(n,t){for(const e in t)t.hasOwnProperty(e)&&!n.hasOwnProperty(e)&&(n[e]=t[e])}function Er(n){if("string"==typeof n)return n;if(Array.isArray(n))return"["+n.map(Er).join(", ")+"]";if(null==n)return""+n;if(n.overriddenName)return`${n.overriddenName}`;if(n.name)return`${n.name}`;const t=n.toString();if(null==t)return""+t;const e=t.indexOf("\n");return-1===e?t:t.substring(0,e)}function yd(n,t){return null==n||""===n?null===t?"":t:null==t||""===t?n:n+" "+t}const Ue=Ht({__forward_ref__:Ht});function Dt(n){return n.__forward_ref__=Dt,n.toString=function(){return Er(this())},n}function vt(n){return Ys(n)?n():n}function Ys(n){return"function"==typeof n&&n.hasOwnProperty(Ue)&&n.__forward_ref__===Dt}function _d(n){return n&&!!n.\u0275providers}const I2="https://g.co/ng/security#xss";class ze extends Error{constructor(t,e){super(function xw(n,t){return`NG0${Math.abs(n)}${t?": "+t:""}`}(t,e)),this.code=t}}function Xt(n){return"string"==typeof n?n:null==n?"":String(n)}function Eb(n,t){throw new ze(-201,!1)}function Ts(n,t){null==n&&function Fn(n,t,e,r){throw new Error(`ASSERTION ERROR: ${n}`+(null==r?"":` [Expected=> ${e} ${r} ${t} <=Actual]`))}(t,n,null,"!=")}function at(n){return{token:n.token,providedIn:n.providedIn||null,factory:n.factory,value:void 0}}function Pn(n){return{providers:n.providers||[],imports:n.imports||[]}}function Db(n){return E2(n,kb)||E2(n,k2)}function E2(n,t){return n.hasOwnProperty(t)?n[t]:null}function D2(n){return n&&(n.hasOwnProperty(ww)||n.hasOwnProperty(GW))?n[ww]:null}const kb=Ht({\u0275prov:Ht}),ww=Ht({\u0275inj:Ht}),k2=Ht({ngInjectableDef:Ht}),GW=Ht({ngInjectorDef:Ht});var Bt=(()=>((Bt=Bt||{})[Bt.Default=0]="Default",Bt[Bt.Host=1]="Host",Bt[Bt.Self=2]="Self",Bt[Bt.SkipSelf=4]="SkipSelf",Bt[Bt.Optional=8]="Optional",Bt))();let Tw;function Ao(n){const t=Tw;return Tw=n,t}function N2(n,t,e){const r=Db(n);return r&&"root"==r.providedIn?void 0===r.value?r.value=r.factory():r.value:e&Bt.Optional?null:void 0!==t?t:void Eb(Er(n))}const Jn=(()=>typeof globalThis<"u"&&globalThis||typeof global<"u"&&global||typeof window<"u"&&window||typeof self<"u"&&typeof WorkerGlobalScope<"u"&&self instanceof WorkerGlobalScope&&self)(),Op={},Sw="__NG_DI_FLAG__",Ab="ngTempTokenPath",WW=/\n/gm,O2="__source";let vd;function Wl(n){const t=vd;return vd=n,t}function XW(n,t=Bt.Default){if(void 0===vd)throw new ze(-203,!1);return null===vd?N2(n,void 0,t):vd.get(n,t&Bt.Optional?null:void 0,t)}function Fe(n,t=Bt.Default){return(function A2(){return Tw}()||XW)(vt(n),t)}function It(n,t=Bt.Default){return Fe(n,Nb(t))}function Nb(n){return typeof n>"u"||"number"==typeof n?n:0|(n.optional&&8)|(n.host&&1)|(n.self&&2)|(n.skipSelf&&4)}function Cw(n){const t=[];for(let e=0;e<n.length;e++){const r=vt(n[e]);if(Array.isArray(r)){if(0===r.length)throw new ze(900,!1);let i,o=Bt.Default;for(let s=0;s<r.length;s++){const a=r[s],c=YW(a);"number"==typeof c?-1===c?i=a.token:o|=c:i=a}t.push(Fe(i,o))}else t.push(Fe(r))}return t}function Rp(n,t){return n[Sw]=t,n.prototype[Sw]=t,n}function YW(n){return n[Sw]}function tl(n){return{toString:n}.toString()}var ya=(()=>((ya=ya||{})[ya.OnPush=0]="OnPush",ya[ya.Default=1]="Default",ya))(),No=(()=>{return(n=No||(No={}))[n.Emulated=0]="Emulated",n[n.None=2]="None",n[n.ShadowDom=3]="ShadowDom",No;var n})();const nl={},Nn=[],Ob=Ht({\u0275cmp:Ht}),Iw=Ht({\u0275dir:Ht}),Ew=Ht({\u0275pipe:Ht}),M2=Ht({\u0275mod:Ht}),rl=Ht({\u0275fac:Ht}),Mp=Ht({__NG_ELEMENT_ID__:Ht}),F2=Ht({__NG_ENV_ID__:Ht});function P2(n,t,e){let r=n.length;for(;;){const i=n.indexOf(t,e);if(-1===i)return i;if(0===i||n.charCodeAt(i-1)<=32){const o=t.length;if(i+o===r||n.charCodeAt(i+o)<=32)return i}e=i+1}}function Dw(n,t,e){let r=0;for(;r<e.length;){const i=e[r];if("number"==typeof i){if(0!==i)break;r++;const o=e[r++],s=e[r++],a=e[r++];n.setAttribute(t,s,a,o)}else{const o=i,s=e[++r];L2(o)?n.setProperty(t,o,s):n.setAttribute(t,o,s),r++}}return r}function $2(n){return 3===n||4===n||6===n}function L2(n){return 64===n.charCodeAt(0)}function Fp(n,t){if(null!==t&&0!==t.length)if(null===n||0===n.length)n=t.slice();else{let e=-1;for(let r=0;r<t.length;r++){const i=t[r];"number"==typeof i?e=i:0===e||B2(n,e,i,null,-1===e||2===e?t[++r]:null)}}return n}function B2(n,t,e,r,i){let o=0,s=n.length;if(-1===t)s=-1;else for(;o<n.length;){const a=n[o++];if("number"==typeof a){if(a===t){s=-1;break}if(a>t){s=o-1;break}}}for(;o<n.length;){const a=n[o];if("number"==typeof a)break;if(a===e){if(null===r)return void(null!==i&&(n[o+1]=i));if(r===n[o+1])return void(n[o+2]=i)}o++,null!==r&&o++,null!==i&&o++}-1!==s&&(n.splice(s,0,t),o=s+1),n.splice(o++,0,e),null!==r&&n.splice(o++,0,r),null!==i&&n.splice(o++,0,i)}const V2="ng-template";function JW(n,t,e){let r=0,i=!0;for(;r<n.length;){let o=n[r++];if("string"==typeof o&&i){const s=n[r++];if(e&&"class"===o&&-1!==P2(s.toLowerCase(),t,0))return!0}else{if(1===o){for(;r<n.length&&"string"==typeof(o=n[r++]);)if(o.toLowerCase()===t)return!0;return!1}"number"==typeof o&&(i=!1)}}return!1}function z2(n){return 4===n.type&&n.value!==V2}function e5(n,t,e){return t===(4!==n.type||e?n.value:V2)}function t5(n,t,e){let r=4;const i=n.attrs||[],o=function o5(n){for(let t=0;t<n.length;t++)if($2(n[t]))return t;return n.length}(i);let s=!1;for(let a=0;a<t.length;a++){const c=t[a];if("number"!=typeof c){if(!s)if(4&r){if(r=2|1&r,""!==c&&!e5(n,c,e)||""===c&&1===t.length){if(Zs(r))return!1;s=!0}}else{const u=8&r?c:t[++a];if(8&r&&null!==n.attrs){if(!JW(n.attrs,u,e)){if(Zs(r))return!1;s=!0}continue}const m=n5(8&r?"class":c,i,z2(n),e);if(-1===m){if(Zs(r))return!1;s=!0;continue}if(""!==u){let g;g=m>o?"":i[m+1].toLowerCase();const _=8&r?g:null;if(_&&-1!==P2(_,u,0)||2&r&&u!==g){if(Zs(r))return!1;s=!0}}}}else{if(!s&&!Zs(r)&&!Zs(c))return!1;if(s&&Zs(c))continue;s=!1,r=c|1&r}}return Zs(r)||s}function Zs(n){return 0==(1&n)}function n5(n,t,e,r){if(null===t)return-1;let i=0;if(r||!e){let o=!1;for(;i<t.length;){const s=t[i];if(s===n)return i;if(3===s||6===s)o=!0;else{if(1===s||2===s){let a=t[++i];for(;"string"==typeof a;)a=t[++i];continue}if(4===s)break;if(0===s){i+=4;continue}}i+=o?1:2}return-1}return function s5(n,t){let e=n.indexOf(4);if(e>-1)for(e++;e<n.length;){const r=n[e];if("number"==typeof r)return-1;if(r===t)return e;e++}return-1}(t,n)}function U2(n,t,e=!1){for(let r=0;r<t.length;r++)if(t5(n,t[r],e))return!0;return!1}function a5(n,t){e:for(let e=0;e<t.length;e++){const r=t[e];if(n.length===r.length){for(let i=0;i<n.length;i++)if(n[i]!==r[i])continue e;return!0}}return!1}function j2(n,t){return n?":not("+t.trim()+")":t}function l5(n){let t=n[0],e=1,r=2,i="",o=!1;for(;e<n.length;){let s=n[e];if("string"==typeof s)if(2&r){const a=n[++e];i+="["+s+(a.length>0?'="'+a+'"':"")+"]"}else 8&r?i+="."+s:4&r&&(i+=" "+s);else""!==i&&!Zs(s)&&(t+=j2(o,i),i=""),r=s,o=o||!Zs(r);e++}return""!==i&&(t+=j2(o,i)),t}function Pi(n){return tl(()=>{const t=H2(n),e={...t,decls:n.decls,vars:n.vars,template:n.template,consts:n.consts||null,ngContentSelectors:n.ngContentSelectors,onPush:n.changeDetection===ya.OnPush,directiveDefs:null,pipeDefs:null,dependencies:t.standalone&&n.dependencies||null,getStandaloneInjector:null,data:n.data||{},encapsulation:n.encapsulation||No.Emulated,styles:n.styles||Nn,_:null,schemas:n.schemas||null,tView:null,id:""};W2(e);const r=n.dependencies;return e.directiveDefs=Rb(r,!1),e.pipeDefs=Rb(r,!0),e.id=function g5(n){let t=0;const e=[n.selectors,n.ngContentSelectors,n.hostVars,n.hostAttrs,n.consts,n.vars,n.decls,n.encapsulation,n.standalone,Object.getOwnPropertyNames(n.type.prototype),!!n.contentQueries,!!n.viewQuery].join("|");for(const i of e)t=Math.imul(31,t)+i.charCodeAt(0)<<0;return t+=2147483648,"c"+t}(e),e})}function h5(n){return On(n)||Xi(n)}function p5(n){return null!==n}function Vn(n){return tl(()=>({type:n.type,bootstrap:n.bootstrap||Nn,declarations:n.declarations||Nn,imports:n.imports||Nn,exports:n.exports||Nn,transitiveCompileScopes:null,schemas:n.schemas||null,id:n.id||null}))}function G2(n,t){if(null==n)return nl;const e={};for(const r in n)if(n.hasOwnProperty(r)){let i=n[r],o=i;Array.isArray(i)&&(o=i[1],i=i[0]),e[i]=r,t&&(t[i]=o)}return e}function _t(n){return tl(()=>{const t=H2(n);return W2(t),t})}function Oo(n){return{type:n.type,name:n.name,factory:null,pure:!1!==n.pure,standalone:!0===n.standalone,onDestroy:n.type.prototype.ngOnDestroy||null}}function On(n){return n[Ob]||null}function Xi(n){return n[Iw]||null}function Ro(n){return n[Ew]||null}function Qo(n,t){const e=n[M2]||null;if(!e&&!0===t)throw new Error(`Type ${Er(n)} does not have '\u0275mod' property.`);return e}function H2(n){const t={};return{type:n.type,providersResolver:null,factory:null,hostBindings:n.hostBindings||null,hostVars:n.hostVars||0,hostAttrs:n.hostAttrs||null,contentQueries:n.contentQueries||null,declaredInputs:t,exportAs:n.exportAs||null,standalone:!0===n.standalone,selectors:n.selectors||Nn,viewQuery:n.viewQuery||null,features:n.features||null,setInput:null,findHostDirectiveDefs:null,hostDirectives:null,inputs:G2(n.inputs,t),outputs:G2(n.outputs)}}function W2(n){n.features?.forEach(t=>t(n))}function Rb(n,t){if(!n)return null;const e=t?Ro:h5;return()=>("function"==typeof n?n():n).map(r=>e(r)).filter(p5)}const Si=0,mt=1,tn=2,vr=3,Qs=4,ru=5,Yi=6,wd=7,Dr=8,Td=9,iu=10,Qt=11,Pp=12,q2=13,Sd=14,Wr=15,$p=16,Cd=17,_a=18,Lp=19,K2=20,ql=21,il=22,Mb=23,Fb=24,bn=25,kw=1,X2=2,va=7,Pb=8,Id=9,$i=11;function Jo(n){return Array.isArray(n)&&"object"==typeof n[kw]}function es(n){return Array.isArray(n)&&!0===n[kw]}function Aw(n){return 0!=(4&n.flags)}function ou(n){return n.componentOffset>-1}function $b(n){return 1==(1&n.flags)}function Js(n){return!!n.template}function Nw(n){return 0!=(512&n[tn])}function su(n,t){return n.hasOwnProperty(rl)?n[rl]:null}let x5=Jn.WeakRef??class v5{constructor(t){this.ref=t}deref(){return this.ref}},T5=0,xa=null,Lb=!1;function Ci(n){const t=xa;return xa=n,t}class eN{constructor(){this.id=T5++,this.ref=function w5(n){return new x5(n)}(this),this.producers=new Map,this.consumers=new Map,this.trackingVersion=0,this.valueVersion=0}consumerPollProducersForChange(){for(const[t,e]of this.producers){const r=e.producerNode.deref();if(void 0!==r&&e.atTrackingVersion===this.trackingVersion){if(r.producerPollStatus(e.seenValueVersion))return!0}else this.producers.delete(t),r?.consumers.delete(this.id)}return!1}producerMayHaveChanged(){const t=Lb;Lb=!0;try{for(const[e,r]of this.consumers){const i=r.consumerNode.deref();void 0!==i&&i.trackingVersion===r.atTrackingVersion?i.onConsumerDependencyMayHaveChanged():(this.consumers.delete(e),i?.producers.delete(this.id))}}finally{Lb=t}}producerAccessed(){if(Lb)throw new Error("");if(null===xa)return;let t=xa.producers.get(this.id);void 0===t?(t={consumerNode:xa.ref,producerNode:this.ref,seenValueVersion:this.valueVersion,atTrackingVersion:xa.trackingVersion},xa.producers.set(this.id,t),this.consumers.set(xa.id,t)):(t.seenValueVersion=this.valueVersion,t.atTrackingVersion=xa.trackingVersion)}get hasProducers(){return this.producers.size>0}get producerUpdatesAllowed(){return!1!==xa?.consumerAllowSignalWrites}producerPollStatus(t){return this.valueVersion!==t||(this.onProducerUpdateValueVersion(),this.valueVersion!==t)}}let tN=null;const nN=()=>{};class E5 extends eN{constructor(t,e,r){super(),this.watch=t,this.schedule=e,this.dirty=!1,this.cleanupFn=nN,this.registerOnCleanup=i=>{this.cleanupFn=i},this.consumerAllowSignalWrites=r}notify(){this.dirty||this.schedule(this),this.dirty=!0}onConsumerDependencyMayHaveChanged(){this.notify()}onProducerUpdateValueVersion(){}run(){if(this.dirty=!1,0!==this.trackingVersion&&!this.consumerPollProducersForChange())return;const t=Ci(this);this.trackingVersion++;try{this.cleanupFn(),this.cleanupFn=nN,this.watch(this.registerOnCleanup)}finally{Ci(t)}}cleanup(){this.cleanupFn()}}class D5{constructor(t,e,r){this.previousValue=t,this.currentValue=e,this.firstChange=r}isFirstChange(){return this.firstChange}}function po(){return rN}function rN(n){return n.type.prototype.ngOnChanges&&(n.setInput=A5),k5}function k5(){const n=oN(this),t=n?.current;if(t){const e=n.previous;if(e===nl)n.previous=t;else for(let r in t)e[r]=t[r];n.current=null,this.ngOnChanges(t)}}function A5(n,t,e,r){const i=this.declaredInputs[e],o=oN(n)||function N5(n,t){return n[iN]=t}(n,{previous:nl,current:null}),s=o.current||(o.current={}),a=o.previous,c=a[i];s[i]=new D5(c&&c.currentValue,t,a===nl),n[r]=t}po.ngInherit=!0;const iN="__ngSimpleChanges__";function oN(n){return n[iN]||null}const wa=function(n,t,e){};function rr(n){for(;Array.isArray(n);)n=n[Si];return n}function zb(n,t){return rr(t[n])}function Mo(n,t){return rr(t[n.index])}function lN(n,t){return n.data[t]}function Ed(n,t){return n[t]}function Fo(n,t){const e=t[n];return Jo(e)?e:e[Si]}function Ub(n){return 128==(128&n[tn])}function Kl(n,t){return null==t?null:n[t]}function cN(n){n[Cd]=0}function $5(n){1024&n[tn]||(n[tn]|=1024,dN(n,1))}function uN(n){1024&n[tn]&&(n[tn]&=-1025,dN(n,-1))}function dN(n,t){let e=n[vr];if(null===e)return;e[ru]+=t;let r=e;for(e=e[vr];null!==e&&(1===t&&1===r[ru]||-1===t&&0===r[ru]);)e[ru]+=t,r=e,e=e[vr]}const Gt={lFrame:wN(null),bindingsEnabled:!0,skipHydrationRootTNode:null};function fN(){return Gt.bindingsEnabled}function qe(){return Gt.lFrame.lView}function In(){return Gt.lFrame.tView}function ol(n){return Gt.lFrame.contextLView=n,n[Dr]}function sl(n){return Gt.lFrame.contextLView=null,n}function Li(){let n=mN();for(;null!==n&&64===n.type;)n=n.parent;return n}function mN(){return Gt.lFrame.currentTNode}function Ta(n,t){const e=Gt.lFrame;e.currentTNode=n,e.isParent=t}function $w(){return Gt.lFrame.isParent}function Lw(){Gt.lFrame.isParent=!1}function fo(){const n=Gt.lFrame;let t=n.bindingRootIndex;return-1===t&&(t=n.bindingRootIndex=n.tView.bindingStartIndex),t}function Dd(){return Gt.lFrame.bindingIndex++}function ll(n){const t=Gt.lFrame,e=t.bindingIndex;return t.bindingIndex=t.bindingIndex+n,e}function X5(n,t){const e=Gt.lFrame;e.bindingIndex=e.bindingRootIndex=n,Bw(t)}function Bw(n){Gt.lFrame.currentDirectiveIndex=n}function _N(){return Gt.lFrame.currentQueryIndex}function zw(n){Gt.lFrame.currentQueryIndex=n}function Z5(n){const t=n[mt];return 2===t.type?t.declTNode:1===t.type?n[Yi]:null}function vN(n,t,e){if(e&Bt.SkipSelf){let i=t,o=n;for(;!(i=i.parent,null!==i||e&Bt.Host||(i=Z5(o),null===i||(o=o[Sd],10&i.type))););if(null===i)return!1;t=i,n=o}const r=Gt.lFrame=xN();return r.currentTNode=t,r.lView=n,!0}function Uw(n){const t=xN(),e=n[mt];Gt.lFrame=t,t.currentTNode=e.firstChild,t.lView=n,t.tView=e,t.contextLView=n,t.bindingIndex=e.bindingStartIndex,t.inI18n=!1}function xN(){const n=Gt.lFrame,t=null===n?null:n.child;return null===t?wN(n):t}function wN(n){const t={currentTNode:null,isParent:!0,lView:null,tView:null,selectedIndex:-1,contextLView:null,elementDepthCount:0,currentNamespace:null,currentDirectiveIndex:-1,bindingRootIndex:-1,bindingIndex:-1,currentQueryIndex:0,parent:n,child:null,inI18n:!1};return null!==n&&(n.child=t),t}function TN(){const n=Gt.lFrame;return Gt.lFrame=n.parent,n.currentTNode=null,n.lView=null,n}const SN=TN;function jw(){const n=TN();n.isParent=!0,n.tView=null,n.selectedIndex=-1,n.contextLView=null,n.elementDepthCount=0,n.currentDirectiveIndex=-1,n.currentNamespace=null,n.bindingRootIndex=-1,n.bindingIndex=-1,n.currentQueryIndex=0}function mo(){return Gt.lFrame.selectedIndex}function au(n){Gt.lFrame.selectedIndex=n}function xr(){const n=Gt.lFrame;return lN(n.tView,n.selectedIndex)}let IN=!0;function jb(){return IN}function Xl(n){IN=n}function Gb(n,t){for(let e=t.directiveStart,r=t.directiveEnd;e<r;e++){const o=n.data[e].type.prototype,{ngAfterContentInit:s,ngAfterContentChecked:a,ngAfterViewInit:c,ngAfterViewChecked:u,ngOnDestroy:p}=o;s&&(n.contentHooks??=[]).push(-e,s),a&&((n.contentHooks??=[]).push(e,a),(n.contentCheckHooks??=[]).push(e,a)),c&&(n.viewHooks??=[]).push(-e,c),u&&((n.viewHooks??=[]).push(e,u),(n.viewCheckHooks??=[]).push(e,u)),null!=p&&(n.destroyHooks??=[]).push(e,p)}}function Hb(n,t,e){EN(n,t,3,e)}function Wb(n,t,e,r){(3&n[tn])===e&&EN(n,t,e,r)}function Gw(n,t){let e=n[tn];(3&e)===t&&(e&=4095,e+=1,n[tn]=e)}function EN(n,t,e,r){const o=r??-1,s=t.length-1;let a=0;for(let c=void 0!==r?65535&n[Cd]:0;c<s;c++)if("number"==typeof t[c+1]){if(a=t[c],null!=r&&a>=r)break}else t[c]<0&&(n[Cd]+=65536),(a<o||-1==o)&&(o8(n,e,t,c),n[Cd]=(4294901760&n[Cd])+c+2),c++}function DN(n,t){wa(4,n,t);const e=Ci(null);try{t.call(n)}finally{Ci(e),wa(5,n,t)}}function o8(n,t,e,r){const i=e[r]<0,o=e[r+1],a=n[i?-e[r]:e[r]];i?n[tn]>>12<n[Cd]>>16&&(3&n[tn])===t&&(n[tn]+=4096,DN(a,o)):DN(a,o)}const kd=-1;class Up{constructor(t,e,r){this.factory=t,this.resolving=!1,this.canSeeViewProviders=e,this.injectImpl=r}}function kN(n){return n!==kd}function qb(n){return 32767&n}function Kb(n,t){let e=function c8(n){return n>>16}(n),r=t;for(;e>0;)r=r[Sd],e--;return r}let Ww=!0;function Xb(n){const t=Ww;return Ww=n,t}const AN=255,NN=5;let u8=0;const Sa={};function Yb(n,t){const e=ON(n,t);if(-1!==e)return e;const r=t[mt];r.firstCreatePass&&(n.injectorIndex=t.length,qw(r.data,n),qw(t,null),qw(r.blueprint,null));const i=Kw(n,t),o=n.injectorIndex;if(kN(i)){const s=qb(i),a=Kb(i,t),c=a[mt].data;for(let u=0;u<8;u++)t[o+u]=a[s+u]|c[s+u]}return t[o+8]=i,o}function qw(n,t){n.push(0,0,0,0,0,0,0,0,t)}function ON(n,t){return-1===n.injectorIndex||n.parent&&n.parent.injectorIndex===n.injectorIndex||null===t[n.injectorIndex+8]?-1:n.injectorIndex}function Kw(n,t){if(n.parent&&-1!==n.parent.injectorIndex)return n.parent.injectorIndex;let e=0,r=null,i=t;for(;null!==i;){if(r=BN(i),null===r)return kd;if(e++,i=i[Sd],-1!==r.injectorIndex)return r.injectorIndex|e<<16}return kd}function Xw(n,t,e){!function d8(n,t,e){let r;"string"==typeof e?r=e.charCodeAt(0)||0:e.hasOwnProperty(Mp)&&(r=e[Mp]),null==r&&(r=e[Mp]=u8++);const i=r&AN;t.data[n+(i>>NN)]|=1<<i}(n,t,e)}function RN(n,t,e){if(e&Bt.Optional||void 0!==n)return n;Eb()}function MN(n,t,e,r){if(e&Bt.Optional&&void 0===r&&(r=null),!(e&(Bt.Self|Bt.Host))){const i=n[Td],o=Ao(void 0);try{return i?i.get(t,r,e&Bt.Optional):N2(t,r,e&Bt.Optional)}finally{Ao(o)}}return RN(r,0,e)}function FN(n,t,e,r=Bt.Default,i){if(null!==n){if(2048&t[tn]){const s=function g8(n,t,e,r,i){let o=n,s=t;for(;null!==o&&null!==s&&2048&s[tn]&&!(512&s[tn]);){const a=PN(o,s,e,r|Bt.Self,Sa);if(a!==Sa)return a;let c=o.parent;if(!c){const u=s[K2];if(u){const p=u.get(e,Sa,r);if(p!==Sa)return p}c=BN(s),s=s[Sd]}o=c}return i}(n,t,e,r,Sa);if(s!==Sa)return s}const o=PN(n,t,e,r,Sa);if(o!==Sa)return o}return MN(t,e,r,i)}function PN(n,t,e,r,i){const o=function f8(n){if("string"==typeof n)return n.charCodeAt(0)||0;const t=n.hasOwnProperty(Mp)?n[Mp]:void 0;return"number"==typeof t?t>=0?t&AN:m8:t}(e);if("function"==typeof o){if(!vN(t,n,r))return r&Bt.Host?RN(i,0,r):MN(t,e,r,i);try{const s=o(r);if(null!=s||r&Bt.Optional)return s;Eb()}finally{SN()}}else if("number"==typeof o){let s=null,a=ON(n,t),c=kd,u=r&Bt.Host?t[Wr][Yi]:null;for((-1===a||r&Bt.SkipSelf)&&(c=-1===a?Kw(n,t):t[a+8],c!==kd&&LN(r,!1)?(s=t[mt],a=qb(c),t=Kb(c,t)):a=-1);-1!==a;){const p=t[mt];if($N(o,a,p.data)){const m=p8(a,t,e,s,r,u);if(m!==Sa)return m}c=t[a+8],c!==kd&&LN(r,t[mt].data[a+8]===u)&&$N(o,a,t)?(s=p,a=qb(c),t=Kb(c,t)):a=-1}}return i}function p8(n,t,e,r,i,o){const s=t[mt],a=s.data[n+8],p=Zb(a,s,e,null==r?ou(a)&&Ww:r!=s&&0!=(3&a.type),i&Bt.Host&&o===a);return null!==p?lu(t,s,p,a):Sa}function Zb(n,t,e,r,i){const o=n.providerIndexes,s=t.data,a=1048575&o,c=n.directiveStart,p=o>>20,g=i?a+p:n.directiveEnd;for(let _=r?a:a+p;_<g;_++){const x=s[_];if(_<c&&e===x||_>=c&&x.type===e)return _}if(i){const _=s[c];if(_&&Js(_)&&_.type===e)return c}return null}function lu(n,t,e,r){let i=n[e];const o=t.data;if(function s8(n){return n instanceof Up}(i)){const s=i;s.resolving&&function $W(n,t){const e=t?`. Dependency path: ${t.join(" > ")} > ${n}`:"";throw new ze(-200,`Circular dependency in DI detected for ${n}${e}`)}(function Mn(n){return"function"==typeof n?n.name||n.toString():"object"==typeof n&&null!=n&&"function"==typeof n.type?n.type.name||n.type.toString():Xt(n)}(o[e]));const a=Xb(s.canSeeViewProviders);s.resolving=!0;const c=s.injectImpl?Ao(s.injectImpl):null;vN(n,r,Bt.Default);try{i=n[e]=s.factory(void 0,o,n,r),t.firstCreatePass&&e>=r.directiveStart&&function i8(n,t,e){const{ngOnChanges:r,ngOnInit:i,ngDoCheck:o}=t.type.prototype;if(r){const s=rN(t);(e.preOrderHooks??=[]).push(n,s),(e.preOrderCheckHooks??=[]).push(n,s)}i&&(e.preOrderHooks??=[]).push(0-n,i),o&&((e.preOrderHooks??=[]).push(n,o),(e.preOrderCheckHooks??=[]).push(n,o))}(e,o[e],t)}finally{null!==c&&Ao(c),Xb(a),s.resolving=!1,SN()}}return i}function $N(n,t,e){return!!(e[t+(n>>NN)]&1<<n)}function LN(n,t){return!(n&Bt.Self||n&Bt.Host&&t)}class Ad{constructor(t,e){this._tNode=t,this._lView=e}get(t,e,r){return FN(this._tNode,this._lView,t,Nb(r),e)}}function m8(){return new Ad(Li(),qe())}function qr(n){return tl(()=>{const t=n.prototype.constructor,e=t[rl]||Yw(t),r=Object.prototype;let i=Object.getPrototypeOf(n.prototype).constructor;for(;i&&i!==r;){const o=i[rl]||Yw(i);if(o&&o!==e)return o;i=Object.getPrototypeOf(i)}return o=>new o})}function Yw(n){return Ys(n)?()=>{const t=Yw(vt(n));return t&&t()}:su(n)}function BN(n){const t=n[mt],e=t.type;return 2===e?t.declTNode:1===e?n[Yi]:null}const Od="__parameters__";function Md(n,t,e){return tl(()=>{const r=function Zw(n){return function(...e){if(n){const r=n(...e);for(const i in r)this[i]=r[i]}}}(t);function i(...o){if(this instanceof i)return r.apply(this,o),this;const s=new i(...o);return a.annotation=s,a;function a(c,u,p){const m=c.hasOwnProperty(Od)?c[Od]:Object.defineProperty(c,Od,{value:[]})[Od];for(;m.length<=p;)m.push(null);return(m[p]=m[p]||[]).push(s),c}}return e&&(i.prototype=Object.create(e.prototype)),i.prototype.ngMetadataName=n,i.annotationCls=i,i})}function Wp(n,t){n.forEach(e=>Array.isArray(e)?Wp(e,t):t(e))}function zN(n,t,e){t>=n.length?n.push(e):n.splice(t,0,e)}function Qb(n,t){return t>=n.length-1?n.pop():n.splice(t,1)[0]}function qp(n,t){const e=[];for(let r=0;r<n;r++)e.push(t);return e}function ts(n,t,e){let r=Fd(n,t);return r>=0?n[1|r]=e:(r=~r,function x8(n,t,e,r){let i=n.length;if(i==t)n.push(e,r);else if(1===i)n.push(r,n[0]),n[0]=e;else{for(i--,n.push(n[i-1],n[i]);i>t;)n[i]=n[i-2],i--;n[t]=e,n[t+1]=r}}(n,r,t,e)),r}function Qw(n,t){const e=Fd(n,t);if(e>=0)return n[1|e]}function Fd(n,t){return function UN(n,t,e){let r=0,i=n.length>>e;for(;i!==r;){const o=r+(i-r>>1),s=n[o<<e];if(t===s)return o<<e;s>t?i=o:r=o+1}return~(i<<e)}(n,t,1)}const ey=Rp(Md("Optional"),8),ty=Rp(Md("SkipSelf"),4);var Po=(()=>((Po=Po||{})[Po.Important=1]="Important",Po[Po.DashCase=2]="DashCase",Po))();const U8=/^>|^->|<!--|-->|--!>|<!-$/g,j8=/(<|>)/,G8="\u200b$1\u200b";const oT=new Map;let H8=0;const aT="__ngContext__";function Zi(n,t){Jo(t)?(n[aT]=t[Lp],function q8(n){oT.set(n[Lp],n)}(t)):n[aT]=t}let lT;function cT(n,t){return lT(n,t)}function Yp(n){const t=n[vr];return es(t)?t[vr]:t}function uT(n){return sO(n[Pp])}function dT(n){return sO(n[Qs])}function sO(n){for(;null!==n&&!es(n);)n=n[Qs];return n}function $d(n,t,e,r,i){if(null!=r){let o,s=!1;es(r)?o=r:Jo(r)&&(s=!0,r=r[Si]);const a=rr(r);0===n&&null!==e?null==i?dO(t,e,a):cu(t,e,a,i||null,!0):1===n&&null!==e?cu(t,e,a,i||null,!0):2===n?function ly(n,t,e){const r=sy(n,t);r&&function hq(n,t,e,r){n.removeChild(t,e,r)}(n,r,t,e)}(t,a,s):3===n&&t.destroyNode(a),null!=o&&function mq(n,t,e,r,i){const o=e[va];o!==rr(e)&&$d(t,n,r,o,i);for(let a=$i;a<e.length;a++){const c=e[a];Qp(c[mt],c,n,t,r,o)}}(t,n,o,e,i)}}function hT(n,t){return n.createComment(function QN(n){return n.replace(U8,t=>t.replace(j8,G8))}(t))}function oy(n,t,e){return n.createElement(t,e)}function lO(n,t){const e=n[Id],r=e.indexOf(t);uN(t),e.splice(r,1)}function pT(n,t){if(n.length<=$i)return;const e=$i+t,r=n[e];if(r){const i=r[$p];null!==i&&i!==n&&lO(i,r),t>0&&(n[e-1][Qs]=r[Qs]);const o=Qb(n,$i+t);!function iq(n,t){Qp(n,t,t[Qt],2,null,null),t[Si]=null,t[Yi]=null}(r[mt],r);const s=o[_a];null!==s&&s.detachView(o[mt]),r[vr]=null,r[Qs]=null,r[tn]&=-129}return r}function cO(n,t){if(!(256&t[tn])){const e=t[Qt];t[Mb]?.destroy(),t[Fb]?.destroy(),e.destroyNode&&Qp(n,t,e,3,null,null),function aq(n){let t=n[Pp];if(!t)return fT(n[mt],n);for(;t;){let e=null;if(Jo(t))e=t[Pp];else{const r=t[$i];r&&(e=r)}if(!e){for(;t&&!t[Qs]&&t!==n;)Jo(t)&&fT(t[mt],t),t=t[vr];null===t&&(t=n),Jo(t)&&fT(t[mt],t),e=t&&t[Qs]}t=e}}(t)}}function fT(n,t){if(!(256&t[tn])){t[tn]&=-129,t[tn]|=256,function dq(n,t){let e;if(null!=n&&null!=(e=n.destroyHooks))for(let r=0;r<e.length;r+=2){const i=t[e[r]];if(!(i instanceof Up)){const o=e[r+1];if(Array.isArray(o))for(let s=0;s<o.length;s+=2){const a=i[o[s]],c=o[s+1];wa(4,a,c);try{c.call(a)}finally{wa(5,a,c)}}else{wa(4,i,o);try{o.call(i)}finally{wa(5,i,o)}}}}}(n,t),function uq(n,t){const e=n.cleanup,r=t[wd];if(null!==e)for(let o=0;o<e.length-1;o+=2)if("string"==typeof e[o]){const s=e[o+3];s>=0?r[s]():r[-s].unsubscribe(),o+=2}else e[o].call(r[e[o+1]]);null!==r&&(t[wd]=null);const i=t[ql];if(null!==i){for(let o=0;o<i.length;o++)(0,i[o])();t[ql]=null}}(n,t),1===t[mt].type&&t[Qt].destroy();const e=t[$p];if(null!==e&&es(t[vr])){e!==t[vr]&&lO(e,t);const r=t[_a];null!==r&&r.detachView(n)}!function K8(n){oT.delete(n[Lp])}(t)}}function mT(n,t,e){return function uO(n,t,e){let r=t;for(;null!==r&&40&r.type;)r=(t=r).parent;if(null===r)return e[Si];{const{componentOffset:i}=r;if(i>-1){const{encapsulation:o}=n.data[r.directiveStart+i];if(o===No.None||o===No.Emulated)return null}return Mo(r,e)}}(n,t.parent,e)}function cu(n,t,e,r,i){n.insertBefore(t,e,r,i)}function dO(n,t,e){n.appendChild(t,e)}function hO(n,t,e,r,i){null!==r?cu(n,t,e,r,i):dO(n,t,e)}function sy(n,t){return n.parentNode(t)}function pO(n,t,e){return mO(n,t,e)}let gT,vT,mO=function fO(n,t,e){return 40&n.type?Mo(n,e):null};function ay(n,t,e,r){const i=mT(n,r,t),o=t[Qt],a=pO(r.parent||t[Yi],r,t);if(null!=i)if(Array.isArray(e))for(let c=0;c<e.length;c++)hO(o,i,e[c],a,!1);else hO(o,i,e,a,!1);void 0!==gT&&gT(o,r,t,e,i)}function Zp(n,t){if(null!==t){const e=t.type;if(3&e)return Mo(t,n);if(4&e)return bT(-1,n[t.index]);if(8&e){const r=t.child;if(null!==r)return Zp(n,r);{const i=n[t.index];return es(i)?bT(-1,i):rr(i)}}if(32&e)return cT(t,n)()||rr(n[t.index]);{const r=bO(n,t);return null!==r?Array.isArray(r)?r[0]:Zp(Yp(n[Wr]),r):Zp(n,t.next)}}return null}function bO(n,t){return null!==t?n[Wr][Yi].projection[t.projection]:null}function bT(n,t){const e=$i+n+1;if(e<t.length){const r=t[e],i=r[mt].firstChild;if(null!==i)return Zp(r,i)}return t[va]}function yT(n,t,e,r,i,o,s){for(;null!=e;){const a=r[e.index],c=e.type;if(s&&0===t&&(a&&Zi(rr(a),r),e.flags|=2),32!=(32&e.flags))if(8&c)yT(n,t,e.child,r,i,o,!1),$d(t,n,i,a,o);else if(32&c){const u=cT(e,r);let p;for(;p=u();)$d(t,n,i,p,o);$d(t,n,i,a,o)}else 16&c?_O(n,t,r,e,i,o):$d(t,n,i,a,o);e=s?e.projectionNext:e.next}}function Qp(n,t,e,r,i,o){yT(e,r,n.firstChild,t,i,o,!1)}function _O(n,t,e,r,i,o){const s=e[Wr],c=s[Yi].projection[r.projection];if(Array.isArray(c))for(let u=0;u<c.length;u++)$d(t,n,i,c[u],o);else yT(n,t,c,s[vr],i,o,!0)}function vO(n,t,e){""===e?n.removeAttribute(t,"class"):n.setAttribute(t,"class",e)}function xO(n,t,e){const{mergedAttrs:r,classes:i,styles:o}=e;null!==r&&Dw(n,t,r),null!==i&&vO(n,t,i),null!==o&&function bq(n,t,e){n.setAttribute(t,"style",e)}(n,t,o)}class CO{constructor(t){this.changingThisBreaksApplicationSecurity=t}toString(){return`SafeValue must use [property]=binding: ${this.changingThisBreaksApplicationSecurity} (see ${I2})`}}function Yl(n){return n instanceof CO?n.changingThisBreaksApplicationSecurity:n}const Nq=/^(?!javascript:)(?:[a-z0-9+.-]+:|[^&:\/?#]*(?:[\/?#]|$))/i;var Kr=(()=>((Kr=Kr||{})[Kr.NONE=0]="NONE",Kr[Kr.HTML=1]="HTML",Kr[Kr.STYLE=2]="STYLE",Kr[Kr.SCRIPT=3]="SCRIPT",Kr[Kr.URL=4]="URL",Kr[Kr.RESOURCE_URL=5]="RESOURCE_URL",Kr))();function IT(n){const t=function rf(){const n=qe();return n&&n[iu].sanitizer}();return t?t.sanitize(Kr.URL,n)||"":function ef(n,t){const e=function Eq(n){return n instanceof CO&&n.getTypeName()||null}(n);if(null!=e&&e!==t){if("ResourceURL"===e&&"URL"===t)return!0;throw new Error(`Required a safe ${t}, got a ${e} (see ${I2})`)}return e===t}(n,"URL")?Yl(n):function wT(n){return(n=String(n)).match(Nq)?n:"unsafe:"+n}(Xt(n))}class Qe{constructor(t,e){this._desc=t,this.ngMetadataName="InjectionToken",this.\u0275prov=void 0,"number"==typeof e?this.__NG_ELEMENT_ID__=e:void 0!==e&&(this.\u0275prov=at({token:this,providedIn:e.providedIn||"root",factory:e.factory}))}get multi(){return this}toString(){return`InjectionToken ${this._desc}`}}const sf=new Qe("ENVIRONMENT_INITIALIZER"),MO=new Qe("INJECTOR",-1),FO=new Qe("INJECTOR_DEF_TYPES");class PO{get(t,e=Op){if(e===Op){const r=new Error(`NullInjectorError: No provider for ${Er(t)}!`);throw r.name="NullInjectorError",r}return e}}function Gq(...n){return{\u0275providers:LO(0,n),\u0275fromNgModule:!0}}function LO(n,...t){const e=[],r=new Set;let i;return Wp(t,o=>{const s=o;ET(s,e,[],r)&&(i||=[],i.push(s))}),void 0!==i&&BO(i,e),e}function BO(n,t){for(let e=0;e<n.length;e++){const{providers:i}=n[e];DT(i,o=>{t.push(o)})}}function ET(n,t,e,r){if(!(n=vt(n)))return!1;let i=null,o=D2(n);const s=!o&&On(n);if(o||s){if(s&&!s.standalone)return!1;i=n}else{const c=n.ngModule;if(o=D2(c),!o)return!1;i=c}const a=r.has(i);if(s){if(a)return!1;if(r.add(i),s.dependencies){const c="function"==typeof s.dependencies?s.dependencies():s.dependencies;for(const u of c)ET(u,t,e,r)}}else{if(!o)return!1;{if(null!=o.imports&&!a){let u;r.add(i);try{Wp(o.imports,p=>{ET(p,t,e,r)&&(u||=[],u.push(p))})}finally{}void 0!==u&&BO(u,t)}if(!a){const u=su(i)||(()=>new i);t.push({provide:i,useFactory:u,deps:Nn},{provide:FO,useValue:i,multi:!0},{provide:sf,useValue:()=>Fe(i),multi:!0})}const c=o.providers;null==c||a||DT(c,p=>{t.push(p)})}}return i!==n&&void 0!==n.providers}function DT(n,t){for(let e of n)_d(e)&&(e=e.\u0275providers),Array.isArray(e)?DT(e,t):t(e)}const Hq=Ht({provide:String,useValue:Ht});function kT(n){return null!==n&&"object"==typeof n&&Hq in n}function uu(n){return"function"==typeof n}const AT=new Qe("Set Injector scope."),hy={},qq={};let NT;function py(){return void 0===NT&&(NT=new PO),NT}class ul{}class OT extends ul{get destroyed(){return this._destroyed}constructor(t,e,r,i){super(),this.parent=e,this.source=r,this.scopes=i,this.records=new Map,this._ngOnDestroyHooks=new Set,this._onDestroyHooks=[],this._destroyed=!1,MT(t,s=>this.processProvider(s)),this.records.set(MO,Bd(void 0,this)),i.has("environment")&&this.records.set(ul,Bd(void 0,this));const o=this.records.get(AT);null!=o&&"string"==typeof o.value&&this.scopes.add(o.value),this.injectorDefTypes=new Set(this.get(FO.multi,Nn,Bt.Self))}destroy(){this.assertNotDestroyed(),this._destroyed=!0;try{for(const t of this._ngOnDestroyHooks)t.ngOnDestroy();for(const t of this._onDestroyHooks)t()}finally{this.records.clear(),this._ngOnDestroyHooks.clear(),this.injectorDefTypes.clear(),this._onDestroyHooks.length=0}}onDestroy(t){return this.assertNotDestroyed(),this._onDestroyHooks.push(t),()=>this.removeOnDestroy(t)}runInContext(t){this.assertNotDestroyed();const e=Wl(this),r=Ao(void 0);try{return t()}finally{Wl(e),Ao(r)}}get(t,e=Op,r=Bt.Default){if(this.assertNotDestroyed(),t.hasOwnProperty(F2))return t[F2](this);r=Nb(r);const i=Wl(this),o=Ao(void 0);try{if(!(r&Bt.SkipSelf)){let a=this.records.get(t);if(void 0===a){const c=function Qq(n){return"function"==typeof n||"object"==typeof n&&n instanceof Qe}(t)&&Db(t);a=c&&this.injectableDefInScope(c)?Bd(RT(t),hy):null,this.records.set(t,a)}if(null!=a)return this.hydrate(t,a)}return(r&Bt.Self?py():this.parent).get(t,e=r&Bt.Optional&&e===Op?null:e)}catch(s){if("NullInjectorError"===s.name){if((s[Ab]=s[Ab]||[]).unshift(Er(t)),i)throw s;return function ZW(n,t,e,r){const i=n[Ab];throw t[O2]&&i.unshift(t[O2]),n.message=function QW(n,t,e,r=null){n=n&&"\n"===n.charAt(0)&&"\u0275"==n.charAt(1)?n.slice(2):n;let i=Er(t);if(Array.isArray(t))i=t.map(Er).join(" -> ");else if("object"==typeof t){let o=[];for(let s in t)if(t.hasOwnProperty(s)){let a=t[s];o.push(s+":"+("string"==typeof a?JSON.stringify(a):Er(a)))}i=`{${o.join(", ")}}`}return`${e}${r?"("+r+")":""}[${i}]: ${n.replace(WW,"\n  ")}`}("\n"+n.message,i,e,r),n.ngTokenPath=i,n[Ab]=null,n}(s,t,"R3InjectorError",this.source)}throw s}finally{Ao(o),Wl(i)}}resolveInjectorInitializers(){const t=Wl(this),e=Ao(void 0);try{const r=this.get(sf.multi,Nn,Bt.Self);for(const i of r)i()}finally{Wl(t),Ao(e)}}toString(){const t=[],e=this.records;for(const r of e.keys())t.push(Er(r));return`R3Injector[${t.join(", ")}]`}assertNotDestroyed(){if(this._destroyed)throw new ze(205,!1)}processProvider(t){let e=uu(t=vt(t))?t:vt(t&&t.provide);const r=function Xq(n){return kT(n)?Bd(void 0,n.useValue):Bd(UO(n),hy)}(t);if(uu(t)||!0!==t.multi)this.records.get(e);else{let i=this.records.get(e);i||(i=Bd(void 0,hy,!0),i.factory=()=>Cw(i.multi),this.records.set(e,i)),e=t,i.multi.push(t)}this.records.set(e,r)}hydrate(t,e){return e.value===hy&&(e.value=qq,e.value=e.factory()),"object"==typeof e.value&&e.value&&function Zq(n){return null!==n&&"object"==typeof n&&"function"==typeof n.ngOnDestroy}(e.value)&&this._ngOnDestroyHooks.add(e.value),e.value}injectableDefInScope(t){if(!t.providedIn)return!1;const e=vt(t.providedIn);return"string"==typeof e?"any"===e||this.scopes.has(e):this.injectorDefTypes.has(e)}removeOnDestroy(t){const e=this._onDestroyHooks.indexOf(t);-1!==e&&this._onDestroyHooks.splice(e,1)}}function RT(n){const t=Db(n),e=null!==t?t.factory:su(n);if(null!==e)return e;if(n instanceof Qe)throw new ze(204,!1);if(n instanceof Function)return function Kq(n){const t=n.length;if(t>0)throw qp(t,"?"),new ze(204,!1);const e=function jW(n){return n&&(n[kb]||n[k2])||null}(n);return null!==e?()=>e.factory(n):()=>new n}(n);throw new ze(204,!1)}function UO(n,t,e){let r;if(uu(n)){const i=vt(n);return su(i)||RT(i)}if(kT(n))r=()=>vt(n.useValue);else if(function zO(n){return!(!n||!n.useFactory)}(n))r=()=>n.useFactory(...Cw(n.deps||[]));else if(function VO(n){return!(!n||!n.useExisting)}(n))r=()=>Fe(vt(n.useExisting));else{const i=vt(n&&(n.useClass||n.provide));if(!function Yq(n){return!!n.deps}(n))return su(i)||RT(i);r=()=>new i(...Cw(n.deps))}return r}function Bd(n,t,e=!1){return{factory:n,value:t,multi:e?[]:void 0}}function MT(n,t){for(const e of n)Array.isArray(e)?MT(e,t):e&&_d(e)?MT(e.\u0275providers,t):t(e)}const fy=new Qe("AppId",{providedIn:"root",factory:()=>Jq}),Jq="ng",jO=new Qe("Platform Initializer"),Vd=new Qe("Platform ID",{providedIn:"platform",factory:()=>"unknown"}),ns=new Qe("AnimationModuleType"),FT=new Qe("CSP nonce",{providedIn:"root",factory:()=>function Jp(){return void 0!==vT?vT:typeof document<"u"?document:void 0}().body?.querySelector("[ngCspNonce]")?.getAttribute("ngCspNonce")||null});let HO=(n,t)=>null;function WO(n,t){return HO(n,t)}class c7{}class XO{}class d7{resolveComponentFactory(t){throw function u7(n){const t=Error(`No component factory found for ${Er(n)}.`);return t.ngComponent=n,t}(t)}}let du=(()=>{class n{}return n.NULL=new d7,n})();function h7(){return zd(Li(),qe())}function zd(n,t){return new yn(Mo(n,t))}let yn=(()=>{class n{constructor(e){this.nativeElement=e}}return n.__NG_ELEMENT_ID__=h7,n})();function p7(n){return n instanceof yn?n.nativeElement:n}class uf{}let dl=(()=>{class n{}return n.__NG_ELEMENT_ID__=()=>function f7(){const n=qe(),e=Fo(Li().index,n);return(Jo(e)?e:n)[Qt]}(),n})(),m7=(()=>{class n{}return n.\u0275prov=at({token:n,providedIn:"root",factory:()=>null}),n})();class hu{constructor(t){this.full=t,this.major=t.split(".")[0],this.minor=t.split(".")[1],this.patch=t.split(".").slice(2).join(".")}}const g7=new hu("16.0.0"),WT={};function df(n){for(;n;){n[tn]|=64;const t=Yp(n);if(Nw(n)&&!t)return n;n=t}return null}function qT(n){return n.ngOriginalError}class pu{constructor(){this._console=console}handleError(t){const e=this._findOriginalError(t);this._console.error("ERROR",t),e&&this._console.error("ORIGINAL ERROR",e)}_findOriginalError(t){let e=t&&qT(t);for(;e&&qT(e);)e=qT(e);return e||null}}const eR=new Qe("",{providedIn:"root",factory:()=>!1});function hl(n){return n instanceof Function?n():n}class rR extends eN{constructor(){super(...arguments),this.consumerAllowSignalWrites=!1,this._lView=null}set lView(t){this._lView=t}onConsumerDependencyMayHaveChanged(){df(this._lView)}onProducerUpdateValueVersion(){}get hasReadASignal(){return this.hasProducers}runInContext(t,e,r){const i=Ci(this);this.trackingVersion++;try{t(e,r)}finally{Ci(i)}}destroy(){this.trackingVersion++}}let xy=null;function iR(){return xy??=new rR,xy}function oR(n,t){return n[t]??iR()}function sR(n,t){const e=iR();e.hasReadASignal&&(n[t]=xy,e.lView=n,xy=new rR)}const Jt={};function At(n){aR(In(),qe(),mo()+n,!1)}function aR(n,t,e,r){if(!r)if(3==(3&t[tn])){const o=n.preOrderCheckHooks;null!==o&&Hb(t,o,e)}else{const o=n.preOrderHooks;null!==o&&Wb(t,o,0,e)}au(e)}function dR(n,t=null,e=null,r){const i=hR(n,t,e,r);return i.resolveInjectorInitializers(),i}function hR(n,t=null,e=null,r,i=new Set){const o=[e||Nn,Gq(n)];return r=r||("object"==typeof n?void 0:Er(n)),new OT(o,t||py(),r||null,i)}let Qi=(()=>{class n{static create(e,r){if(Array.isArray(e))return dR({name:""},r,e,"");{const i=e.name??"";return dR({name:i},e.parent,e.providers,i)}}}return n.THROW_IF_NOT_FOUND=Op,n.NULL=new PO,n.\u0275prov=at({token:n,providedIn:"any",factory:()=>Fe(MO)}),n.__NG_ELEMENT_ID__=-1,n})();function de(n,t=Bt.Default){const e=qe();return null===e?Fe(n,t):FN(Li(),e,vt(n),t)}function wy(){throw new Error("invalid")}function Ty(n,t,e,r,i,o,s,a,c,u,p){const m=t.blueprint.slice();return m[Si]=i,m[tn]=140|r,(null!==u||n&&2048&n[tn])&&(m[tn]|=2048),cN(m),m[vr]=m[Sd]=n,m[Dr]=e,m[iu]=s||n&&n[iu],m[Qt]=a||n&&n[Qt],m[Td]=c||n&&n[Td]||null,m[Yi]=o,m[Lp]=function W8(){return H8++}(),m[il]=p,m[K2]=u,m[Wr]=2==t.type?n[Wr]:m,m}function Gd(n,t,e,r,i){let o=n.data[t];if(null===o)o=function KT(n,t,e,r,i){const o=mN(),s=$w(),c=n.data[t]=function $7(n,t,e,r,i,o){return{type:e,index:r,insertBeforeIndex:null,injectorIndex:t?t.injectorIndex:-1,directiveStart:-1,directiveEnd:-1,directiveStylingLast:-1,componentOffset:-1,propertyBindings:null,flags:0,providerIndexes:0,value:i,attrs:o,mergedAttrs:null,localNames:null,initialInputs:void 0,inputs:null,outputs:null,tView:null,next:null,prev:null,projectionNext:null,child:null,parent:t,projection:null,styles:null,stylesWithoutHost:null,residualStyles:void 0,classes:null,classesWithoutHost:null,residualClasses:void 0,classBindings:0,styleBindings:0}}(0,s?o:o&&o.parent,e,t,r,i);return null===n.firstChild&&(n.firstChild=c),null!==o&&(s?null==o.child&&null!==c.parent&&(o.child=c):null===o.next&&(o.next=c,c.prev=o)),c}(n,t,e,r,i),function K5(){return Gt.lFrame.inI18n}()&&(o.flags|=32);else if(64&o.type){o.type=e,o.value=r,o.attrs=i;const s=function zp(){const n=Gt.lFrame,t=n.currentTNode;return n.isParent?t:t.parent}();o.injectorIndex=null===s?-1:s.injectorIndex}return Ta(o,!0),o}function hf(n,t,e,r){if(0===e)return-1;const i=t.length;for(let o=0;o<e;o++)t.push(r),n.blueprint.push(r),n.data.push(null);return i}function pR(n,t,e,r,i){const o=oR(t,Mb),s=mo(),a=2&r;try{if(au(-1),a&&t.length>bn&&aR(n,t,bn,!1),wa(a?2:0,i),a)o.runInContext(e,r,i);else{const u=Ci(null);try{e(r,i)}finally{Ci(u)}}}finally{a&&null===t[Mb]&&sR(t,Mb),au(s),wa(a?3:1,i)}}function XT(n,t,e){if(Aw(t)){const r=Ci(null);try{const o=t.directiveEnd;for(let s=t.directiveStart;s<o;s++){const a=n.data[s];a.contentQueries&&a.contentQueries(1,e[s],s)}}finally{Ci(r)}}}function YT(n,t,e){fN()&&(function G7(n,t,e,r){const i=e.directiveStart,o=e.directiveEnd;ou(e)&&function Z7(n,t,e){const r=Mo(t,n),s=Sy(n,Ty(n,fR(e),null,e.onPush?64:16,r,t,null,n[iu].rendererFactory.createRenderer(r,e),null,null,null));n[t.index]=s}(t,e,n.data[i+e.componentOffset]),n.firstCreatePass||Yb(e,t),Zi(r,t);const s=e.initialInputs;for(let a=i;a<o;a++){const c=n.data[a],u=lu(t,n,a,e);Zi(u,t),null!==s&&Q7(0,a-i,u,c,0,s),Js(c)&&(Fo(e.index,t)[Dr]=lu(t,n,a,e))}}(n,t,e,Mo(e,t)),64==(64&e.flags)&&_R(n,t,e))}function ZT(n,t,e=Mo){const r=t.localNames;if(null!==r){let i=t.index+1;for(let o=0;o<r.length;o+=2){const s=r[o+1],a=-1===s?e(t,n):n[s];n[i++]=a}}}function fR(n){const t=n.tView;return null===t||t.incompleteFirstPass?n.tView=QT(1,null,n.template,n.decls,n.vars,n.directiveDefs,n.pipeDefs,n.viewQuery,n.schemas,n.consts,n.id):t}function QT(n,t,e,r,i,o,s,a,c,u,p){const m=bn+r,g=m+i,_=function N7(n,t){const e=[];for(let r=0;r<t;r++)e.push(r<n?null:Jt);return e}(m,g),x="function"==typeof u?u():u;return _[mt]={type:n,blueprint:_,template:e,queries:null,viewQuery:a,declTNode:t,data:_.slice().fill(null,m),bindingStartIndex:m,expandoStartIndex:g,hostBindingOpCodes:null,firstCreatePass:!0,firstUpdatePass:!0,staticViewQueries:!1,staticContentQueries:!1,preOrderHooks:null,preOrderCheckHooks:null,contentHooks:null,contentCheckHooks:null,viewHooks:null,viewCheckHooks:null,destroyHooks:null,cleanup:null,contentQueries:null,components:null,directiveRegistry:"function"==typeof o?o():o,pipeRegistry:"function"==typeof s?s():s,firstChild:null,schemas:c,consts:x,incompleteFirstPass:!1,ssrId:p}}let mR=n=>null;function gR(n,t,e,r){for(let i in n)if(n.hasOwnProperty(i)){e=null===e?{}:e;const o=n[i];null===r?bR(e,t,i,o):r.hasOwnProperty(i)&&bR(e,t,r[i],o)}return e}function bR(n,t,e,r){n.hasOwnProperty(e)?n[e].push(t,r):n[e]=[t,r]}function rs(n,t,e,r,i,o,s,a){const c=Mo(t,e);let p,u=t.inputs;!a&&null!=u&&(p=u[r])?(r1(n,e,p,r,i),ou(t)&&function V7(n,t){const e=Fo(t,n);16&e[tn]||(e[tn]|=64)}(e,t.index)):3&t.type&&(r=function B7(n){return"class"===n?"className":"for"===n?"htmlFor":"formaction"===n?"formAction":"innerHtml"===n?"innerHTML":"readonly"===n?"readOnly":"tabindex"===n?"tabIndex":n}(r),i=null!=s?s(i,t.value||"",r):i,o.setProperty(c,r,i))}function JT(n,t,e,r){if(fN()){const i=null===r?null:{"":-1},o=function W7(n,t){const e=n.directiveRegistry;let r=null,i=null;if(e)for(let o=0;o<e.length;o++){const s=e[o];if(U2(t,s.selectors,!1))if(r||(r=[]),Js(s))if(null!==s.findHostDirectiveDefs){const a=[];i=i||new Map,s.findHostDirectiveDefs(s,a,i),r.unshift(...a,s),e1(n,t,a.length)}else r.unshift(s),e1(n,t,0);else i=i||new Map,s.findHostDirectiveDefs?.(s,r,i),r.push(s)}return null===r?null:[r,i]}(n,e);let s,a;null===o?s=a=null:[s,a]=o,null!==s&&yR(n,t,e,s,i,a),i&&function q7(n,t,e){if(t){const r=n.localNames=[];for(let i=0;i<t.length;i+=2){const o=e[t[i+1]];if(null==o)throw new ze(-301,!1);r.push(t[i],o)}}}(e,r,i)}e.mergedAttrs=Fp(e.mergedAttrs,e.attrs)}function yR(n,t,e,r,i,o){for(let u=0;u<r.length;u++)Xw(Yb(e,t),n,r[u].type);!function X7(n,t,e){n.flags|=1,n.directiveStart=t,n.directiveEnd=t+e,n.providerIndexes=t}(e,n.data.length,r.length);for(let u=0;u<r.length;u++){const p=r[u];p.providersResolver&&p.providersResolver(p)}let s=!1,a=!1,c=hf(n,t,r.length,null);for(let u=0;u<r.length;u++){const p=r[u];e.mergedAttrs=Fp(e.mergedAttrs,p.hostAttrs),Y7(n,e,t,c,p),K7(c,p,i),null!==p.contentQueries&&(e.flags|=4),(null!==p.hostBindings||null!==p.hostAttrs||0!==p.hostVars)&&(e.flags|=64);const m=p.type.prototype;!s&&(m.ngOnChanges||m.ngOnInit||m.ngDoCheck)&&((n.preOrderHooks??=[]).push(e.index),s=!0),!a&&(m.ngOnChanges||m.ngDoCheck)&&((n.preOrderCheckHooks??=[]).push(e.index),a=!0),c++}!function L7(n,t,e){const i=t.directiveEnd,o=n.data,s=t.attrs,a=[];let c=null,u=null;for(let p=t.directiveStart;p<i;p++){const m=o[p],g=e?e.get(m):null,x=g?g.outputs:null;c=gR(m.inputs,p,c,g?g.inputs:null),u=gR(m.outputs,p,u,x);const T=null===c||null===s||z2(t)?null:J7(c,p,s);a.push(T)}null!==c&&(c.hasOwnProperty("class")&&(t.flags|=8),c.hasOwnProperty("style")&&(t.flags|=16)),t.initialInputs=a,t.inputs=c,t.outputs=u}(n,e,o)}function _R(n,t,e){const r=e.directiveStart,i=e.directiveEnd,o=e.index,s=function Y5(){return Gt.lFrame.currentDirectiveIndex}();try{au(o);for(let a=r;a<i;a++){const c=n.data[a],u=t[a];Bw(a),(null!==c.hostBindings||0!==c.hostVars||null!==c.hostAttrs)&&H7(c,u)}}finally{au(-1),Bw(s)}}function H7(n,t){null!==n.hostBindings&&n.hostBindings(1,t)}function e1(n,t,e){t.componentOffset=e,(n.components??=[]).push(t.index)}function K7(n,t,e){if(e){if(t.exportAs)for(let r=0;r<t.exportAs.length;r++)e[t.exportAs[r]]=n;Js(t)&&(e[""]=n)}}function Y7(n,t,e,r,i){n.data[r]=i;const o=i.factory||(i.factory=su(i.type)),s=new Up(o,Js(i),de);n.blueprint[r]=s,e[r]=s,function U7(n,t,e,r,i){const o=i.hostBindings;if(o){let s=n.hostBindingOpCodes;null===s&&(s=n.hostBindingOpCodes=[]);const a=~t.index;(function j7(n){let t=n.length;for(;t>0;){const e=n[--t];if("number"==typeof e&&e<0)return e}return 0})(s)!=a&&s.push(a),s.push(e,r,o)}}(n,t,r,hf(n,e,i.hostVars,Jt),i)}function Ca(n,t,e,r,i,o){const s=Mo(n,t);!function t1(n,t,e,r,i,o,s){if(null==o)n.removeAttribute(t,i,e);else{const a=null==s?Xt(o):s(o,r||"",i);n.setAttribute(t,i,a,e)}}(t[Qt],s,o,n.value,e,r,i)}function Q7(n,t,e,r,i,o){const s=o[t];if(null!==s)for(let a=0;a<s.length;)vR(r,e,s[a++],s[a++],s[a++])}function vR(n,t,e,r,i){const o=Ci(null);try{null!==n.setInput?n.setInput(t,i,e,r):t[r]=i}finally{Ci(o)}}function J7(n,t,e){let r=null,i=0;for(;i<e.length;){const o=e[i];if(0!==o)if(5!==o){if("number"==typeof o)break;if(n.hasOwnProperty(o)){null===r&&(r=[]);const s=n[o];for(let a=0;a<s.length;a+=2)if(s[a]===t){r.push(o,s[a+1],e[i+1]);break}}i+=2}else i+=2;else i+=4}return r}function xR(n,t,e,r){return[n,!0,!1,t,null,0,r,e,null,null,null]}function wR(n,t){const e=n.contentQueries;if(null!==e)for(let r=0;r<e.length;r+=2){const o=e[r+1];if(-1!==o){const s=n.data[o];zw(e[r]),s.contentQueries(2,t[o],o)}}}function Sy(n,t){return n[Pp]?n[q2][Qs]=t:n[Pp]=t,n[q2]=t,t}function n1(n,t,e){zw(0);const r=Ci(null);try{t(n,e)}finally{Ci(r)}}function TR(n){return n[wd]||(n[wd]=[])}function SR(n){return n.cleanup||(n.cleanup=[])}function IR(n,t){const e=n[Td],r=e?e.get(pu,null):null;r&&r.handleError(t)}function r1(n,t,e,r,i){for(let o=0;o<e.length;){const s=e[o++],a=e[o++];vR(n.data[s],t[s],r,a,i)}}function pl(n,t,e){const r=zb(t,n);!function aO(n,t,e){n.setValue(t,e)}(n[Qt],r,e)}function e9(n,t){const e=Fo(t,n),r=e[mt];!function t9(n,t){for(let e=t.length;e<n.blueprint.length;e++)t.push(n.blueprint[e])}(r,e);const i=e[Si];null!==i&&null===e[il]&&(e[il]=WO(i,e[Td])),o1(r,e,e[Dr])}function o1(n,t,e){Uw(t);try{const r=n.viewQuery;null!==r&&n1(1,r,e);const i=n.template;null!==i&&pR(n,t,i,1,e),n.firstCreatePass&&(n.firstCreatePass=!1),n.staticContentQueries&&wR(n,t),n.staticViewQueries&&n1(2,n.viewQuery,e);const o=n.components;null!==o&&function n9(n,t){for(let e=0;e<t.length;e++)e9(n,t[e])}(t,o)}catch(r){throw n.firstCreatePass&&(n.incompleteFirstPass=!0,n.firstCreatePass=!1),r}finally{t[tn]&=-5,jw()}}let ER=(()=>{class n{constructor(){this.all=new Set,this.queue=new Map}create(e,r,i){const o=typeof Zone>"u"?null:Zone.current,s=new E5(e,u=>{this.all.has(u)&&this.queue.set(u,o)},i);let a;this.all.add(s),s.notify();const c=()=>{s.cleanup(),a?.(),this.all.delete(s),this.queue.delete(s)};return a=r?.onDestroy(c),{destroy:c}}flush(){if(0!==this.queue.size)for(const[e,r]of this.queue)this.queue.delete(e),r?r.run(()=>e.run()):e.run()}get isQueueEmpty(){return 0===this.queue.size}}return n.\u0275prov=at({token:n,providedIn:"root",factory:()=>new n}),n})();function Cy(n,t,e){let r=e?n.styles:null,i=e?n.classes:null,o=0;if(null!==t)for(let s=0;s<t.length;s++){const a=t[s];"number"==typeof a?o=a:1==o?i=yd(i,a):2==o&&(r=yd(r,a+": "+t[++s]+";"))}e?n.styles=r:n.stylesWithoutHost=r,e?n.classes=i:n.classesWithoutHost=i}function pf(n,t,e,r,i=!1){for(;null!==e;){const o=t[e.index];if(null!==o&&r.push(rr(o)),es(o)){for(let a=$i;a<o.length;a++){const c=o[a],u=c[mt].firstChild;null!==u&&pf(c[mt],c,u,r)}o[va]!==o[Si]&&r.push(o[va])}const s=e.type;if(8&s)pf(n,t,e.child,r);else if(32&s){const a=cT(e,t);let c;for(;c=a();)r.push(c)}else if(16&s){const a=bO(t,e);if(Array.isArray(a))r.push(...a);else{const c=Yp(t[Wr]);pf(c[mt],c,a,r,!0)}}e=i?e.projectionNext:e.next}return r}function Iy(n,t,e,r=!0){const i=t[iu].rendererFactory;i.begin&&i.begin();try{Ey(n,t,n.template,e)}catch(s){throw r&&IR(t,s),s}finally{i.end&&i.end(),t[iu].effectManager?.flush()}}function Ey(n,t,e,r){const i=t[tn];if(256!=(256&i)){t[iu].effectManager?.flush(),Uw(t);try{cN(t),function bN(n){return Gt.lFrame.bindingIndex=n}(n.bindingStartIndex),null!==e&&pR(n,t,e,2,r);const s=3==(3&i);if(s){const u=n.preOrderCheckHooks;null!==u&&Hb(t,u,null)}else{const u=n.preOrderHooks;null!==u&&Wb(t,u,0,null),Gw(t,0)}if(function l9(n){for(let t=uT(n);null!==t;t=dT(t)){if(!t[X2])continue;const e=t[Id];for(let r=0;r<e.length;r++){$5(e[r])}}}(t),function a9(n){for(let t=uT(n);null!==t;t=dT(t))for(let e=$i;e<t.length;e++){const r=t[e],i=r[mt];Ub(r)&&Ey(i,r,i.template,r[Dr])}}(t),null!==n.contentQueries&&wR(n,t),s){const u=n.contentCheckHooks;null!==u&&Hb(t,u)}else{const u=n.contentHooks;null!==u&&Wb(t,u,1),Gw(t,1)}!function A7(n,t){const e=n.hostBindingOpCodes;if(null===e)return;const r=oR(t,Fb);try{for(let i=0;i<e.length;i++){const o=e[i];if(o<0)au(~o);else{const s=o,a=e[++i],c=e[++i];X5(a,s),r.runInContext(c,2,t[s])}}}finally{null===t[Fb]&&sR(t,Fb),au(-1)}}(n,t);const a=n.components;null!==a&&function u9(n,t){for(let e=0;e<t.length;e++)c9(n,t[e])}(t,a);const c=n.viewQuery;if(null!==c&&n1(2,c,r),s){const u=n.viewCheckHooks;null!==u&&Hb(t,u)}else{const u=n.viewHooks;null!==u&&Wb(t,u,2),Gw(t,2)}!0===n.firstUpdatePass&&(n.firstUpdatePass=!1),t[tn]&=-73,uN(t)}finally{jw()}}}function c9(n,t){const e=Fo(t,n);if(Ub(e)){const r=e[mt];80&e[tn]?Ey(r,e,r.template,e[Dr]):e[ru]>0&&s1(e)}}function s1(n){for(let r=uT(n);null!==r;r=dT(r))for(let i=$i;i<r.length;i++){const o=r[i];if(Ub(o))if(1024&o[tn]){const s=o[mt];Ey(s,o,s.template,o[Dr])}else o[ru]>0&&s1(o)}const e=n[mt].components;if(null!==e)for(let r=0;r<e.length;r++){const i=Fo(e[r],n);Ub(i)&&i[ru]>0&&s1(i)}}class ff{get rootNodes(){const t=this._lView,e=t[mt];return pf(e,t,e.firstChild,[])}constructor(t,e){this._lView=t,this._cdRefInjectingView=e,this._appRef=null,this._attachedToViewContainer=!1}get context(){return this._lView[Dr]}set context(t){this._lView[Dr]=t}get destroyed(){return 256==(256&this._lView[tn])}destroy(){if(this._appRef)this._appRef.detachView(this);else if(this._attachedToViewContainer){const t=this._lView[vr];if(es(t)){const e=t[Pb],r=e?e.indexOf(this):-1;r>-1&&(pT(t,r),Qb(e,r))}this._attachedToViewContainer=!1}cO(this._lView[mt],this._lView)}onDestroy(t){!function hN(n,t){if(256==(256&n[tn]))throw new ze(911,!1);null===n[ql]&&(n[ql]=[]),n[ql].push(t)}(this._lView,t)}markForCheck(){df(this._cdRefInjectingView||this._lView)}detach(){this._lView[tn]&=-129}reattach(){this._lView[tn]|=128}detectChanges(){Iy(this._lView[mt],this._lView,this.context)}checkNoChanges(){}attachToViewContainerRef(){if(this._appRef)throw new ze(902,!1);this._attachedToViewContainer=!0}detachFromAppRef(){this._appRef=null,function sq(n,t){Qp(n,t,t[Qt],2,null,null)}(this._lView[mt],this._lView)}attachToAppRef(t){if(this._attachedToViewContainer)throw new ze(902,!1);this._appRef=t}}class d9 extends ff{constructor(t){super(t),this._view=t}detectChanges(){const t=this._view;Iy(t[mt],t,t[Dr],!1)}checkNoChanges(){}get context(){return null}}class DR extends du{constructor(t){super(),this.ngModule=t}resolveComponentFactory(t){const e=On(t);return new mf(e,this.ngModule)}}function kR(n){const t=[];for(let e in n)n.hasOwnProperty(e)&&t.push({propName:n[e],templateName:e});return t}class p9{constructor(t,e){this.injector=t,this.parentInjector=e}get(t,e,r){r=Nb(r);const i=this.injector.get(t,WT,r);return i!==WT||e===WT?i:this.parentInjector.get(t,e,r)}}class mf extends XO{get inputs(){return kR(this.componentDef.inputs)}get outputs(){return kR(this.componentDef.outputs)}constructor(t,e){super(),this.componentDef=t,this.ngModule=e,this.componentType=t.type,this.selector=function c5(n){return n.map(l5).join(",")}(t.selectors),this.ngContentSelectors=t.ngContentSelectors?t.ngContentSelectors:[],this.isBoundToModule=!!e}create(t,e,r,i){let o=(i=i||this.ngModule)instanceof ul?i:i?.injector;o&&null!==this.componentDef.getStandaloneInjector&&(o=this.componentDef.getStandaloneInjector(o)||o);const s=o?new p9(t,o):t,a=s.get(uf,null);if(null===a)throw new ze(407,!1);const p={rendererFactory:a,sanitizer:s.get(m7,null),effectManager:s.get(ER,null)},m=a.createRenderer(null,this.componentDef),g=this.componentDef.selectors[0][0]||"div",_=r?function O7(n,t,e,r){const o=r.get(eR,!1)||e===No.ShadowDom,s=n.selectRootElement(t,o);return function R7(n){mR(n)}(s),s}(m,r,this.componentDef.encapsulation,s):oy(m,g,function h9(n){const t=n.toLowerCase();return"svg"===t?"svg":"math"===t?"math":null}(g)),x=this.componentDef.onPush?576:528,T=QT(0,null,null,1,0,null,null,null,null,null,null),I=Ty(null,T,null,x,null,null,p,m,s,null,null);let N,R;Uw(I);try{const L=this.componentDef;let V,j=null;L.findHostDirectiveDefs?(V=[],j=new Map,L.findHostDirectiveDefs(L,V,j),V.push(L)):V=[L];const Y=function m9(n,t){const e=n[mt],r=bn;return n[r]=t,Gd(e,r,2,"#host",null)}(I,_),ee=function g9(n,t,e,r,i,o,s){const a=i[mt];!function b9(n,t,e,r){for(const i of n)t.mergedAttrs=Fp(t.mergedAttrs,i.hostAttrs);null!==t.mergedAttrs&&(Cy(t,t.mergedAttrs,!0),null!==e&&xO(r,e,t))}(r,n,t,s);let c=null;null!==t&&(c=WO(t,i[Td]));const u=o.rendererFactory.createRenderer(t,e),p=Ty(i,fR(e),null,e.onPush?64:16,i[n.index],n,o,u,null,null,c);return a.firstCreatePass&&e1(a,n,r.length-1),Sy(i,p),i[n.index]=p}(Y,_,L,V,I,p,m);R=lN(T,bn),_&&function _9(n,t,e,r){if(r)Dw(n,e,["ng-version",g7.full]);else{const{attrs:i,classes:o}=function u5(n){const t=[],e=[];let r=1,i=2;for(;r<n.length;){let o=n[r];if("string"==typeof o)2===i?""!==o&&t.push(o,n[++r]):8===i&&e.push(o);else{if(!Zs(i))break;i=o}r++}return{attrs:t,classes:e}}(t.selectors[0]);i&&Dw(n,e,i),o&&o.length>0&&vO(n,e,o.join(" "))}}(m,L,_,r),void 0!==e&&function v9(n,t,e){const r=n.projection=[];for(let i=0;i<t.length;i++){const o=e[i];r.push(null!=o?Array.from(o):null)}}(R,this.ngContentSelectors,e),N=function y9(n,t,e,r,i,o){const s=Li(),a=i[mt],c=Mo(s,i);yR(a,i,s,e,null,r);for(let p=0;p<e.length;p++)Zi(lu(i,a,s.directiveStart+p,s),i);_R(a,i,s),c&&Zi(c,i);const u=lu(i,a,s.directiveStart+s.componentOffset,s);if(n[Dr]=i[Dr]=u,null!==o)for(const p of o)p(u,t);return XT(a,s,n),u}(ee,L,V,j,I,[x9]),o1(T,I,null)}finally{jw()}return new f9(this.componentType,N,zd(R,I),I,R)}}class f9 extends c7{constructor(t,e,r,i,o){super(),this.location=r,this._rootLView=i,this._tNode=o,this.previousInputValues=null,this.instance=e,this.hostView=this.changeDetectorRef=new d9(i),this.componentType=t}setInput(t,e){const r=this._tNode.inputs;let i;if(null!==r&&(i=r[t])){if(this.previousInputValues??=new Map,this.previousInputValues.has(t)&&Object.is(this.previousInputValues.get(t),e))return;const o=this._rootLView;r1(o[mt],o,i,t,e),this.previousInputValues.set(t,e),df(Fo(this._tNode.index,o))}}get injector(){return new Ad(this._tNode,this._rootLView)}destroy(){this.hostView.destroy()}onDestroy(t){this.hostView.onDestroy(t)}}function x9(){const n=Li();Gb(qe()[mt],n)}function $t(n){let t=function AR(n){return Object.getPrototypeOf(n.prototype).constructor}(n.type),e=!0;const r=[n];for(;t;){let i;if(Js(n))i=t.\u0275cmp||t.\u0275dir;else{if(t.\u0275cmp)throw new ze(903,!1);i=t.\u0275dir}if(i){if(e){r.push(i);const s=n;s.inputs=a1(n.inputs),s.declaredInputs=a1(n.declaredInputs),s.outputs=a1(n.outputs);const a=i.hostBindings;a&&C9(n,a);const c=i.viewQuery,u=i.contentQueries;if(c&&T9(n,c),u&&S9(n,u),Ti(n.inputs,i.inputs),Ti(n.declaredInputs,i.declaredInputs),Ti(n.outputs,i.outputs),Js(i)&&i.data.animation){const p=n.data;p.animation=(p.animation||[]).concat(i.data.animation)}}const o=i.features;if(o)for(let s=0;s<o.length;s++){const a=o[s];a&&a.ngInherit&&a(n),a===$t&&(e=!1)}}t=Object.getPrototypeOf(t)}!function w9(n){let t=0,e=null;for(let r=n.length-1;r>=0;r--){const i=n[r];i.hostVars=t+=i.hostVars,i.hostAttrs=Fp(i.hostAttrs,e=Fp(e,i.hostAttrs))}}(r)}function a1(n){return n===nl?{}:n===Nn?[]:n}function T9(n,t){const e=n.viewQuery;n.viewQuery=e?(r,i)=>{t(r,i),e(r,i)}:t}function S9(n,t){const e=n.contentQueries;n.contentQueries=e?(r,i,o)=>{t(r,i,o),e(r,i,o)}:t}function C9(n,t){const e=n.hostBindings;n.hostBindings=e?(r,i)=>{t(r,i),e(r,i)}:t}function Dy(n){return!!l1(n)&&(Array.isArray(n)||!(n instanceof Map)&&Symbol.iterator in n)}function l1(n){return null!==n&&("function"==typeof n||"object"==typeof n)}function Ia(n,t,e){return n[t]=e}function Ji(n,t,e){return!Object.is(n[t],e)&&(n[t]=e,!0)}function fu(n,t,e,r){const i=Ji(n,t,e);return Ji(n,t+1,r)||i}function ui(n,t,e,r){const i=qe();return Ji(i,Dd(),t)&&(In(),Ca(xr(),i,n,t,e,r)),ui}function Wd(n,t,e,r){return Ji(n,Dd(),e)?t+Xt(e)+r:Jt}function qd(n,t,e,r,i,o){const a=fu(n,function al(){return Gt.lFrame.bindingIndex}(),e,i);return ll(2),a?t+Xt(e)+r+Xt(i)+o:Jt}function Xr(n,t,e,r,i,o,s,a){const c=qe(),u=In(),p=n+bn,m=u.firstCreatePass?function Y9(n,t,e,r,i,o,s,a,c){const u=t.consts,p=Gd(t,n,4,s||null,Kl(u,a));JT(t,e,p,Kl(u,c)),Gb(t,p);const m=p.tView=QT(2,p,r,i,o,t.directiveRegistry,t.pipeRegistry,null,t.schemas,u,null);return null!==t.queries&&(t.queries.template(t,p),m.queries=t.queries.embeddedTView(p)),p}(p,u,c,t,e,r,i,o,s):u.data[p];Ta(m,!1);const g=WR(u,c,m,n);jb()&&ay(u,c,g,m),Zi(g,c),Sy(c,c[p]=xR(g,c,g,m)),$b(m)&&YT(u,c,m),null!=s&&ZT(c,m,a)}let WR=function qR(n,t,e,r){return Xl(!0),t[Qt].createComment("")};function vf(n){return Ed(function q5(){return Gt.lFrame.contextLView}(),bn+n)}function nn(n,t,e){const r=qe();return Ji(r,Dd(),t)&&rs(In(),xr(),r,n,t,r[Qt],e,!1),nn}function f1(n,t,e,r,i){const s=i?"class":"style";r1(n,e,t.inputs[s],s,r)}function ut(n,t,e,r){const i=qe(),o=In(),s=bn+n,a=i[Qt],c=o.firstCreatePass?function eK(n,t,e,r,i,o){const s=t.consts,c=Gd(t,n,2,r,Kl(s,i));return JT(t,e,c,Kl(s,o)),null!==c.attrs&&Cy(c,c.attrs,!1),null!==c.mergedAttrs&&Cy(c,c.mergedAttrs,!0),null!==t.queries&&t.queries.elementStart(t,c),c}(s,o,i,t,e,r):o.data[s],u=KR(o,i,c,a,t,n);i[s]=u;const p=$b(c);return Ta(c,!0),xO(a,u,c),32!=(32&c.flags)&&jb()&&ay(o,i,u,c),0===function B5(){return Gt.lFrame.elementDepthCount}()&&Zi(u,i),function V5(){Gt.lFrame.elementDepthCount++}(),p&&(YT(o,i,c),XT(o,c,i)),null!==r&&ZT(i,c),ut}function ft(){let n=Li();$w()?Lw():(n=n.parent,Ta(n,!1));const t=n;(function U5(n){return Gt.skipHydrationRootTNode===n})(t)&&function W5(){Gt.skipHydrationRootTNode=null}(),function z5(){Gt.lFrame.elementDepthCount--}();const e=In();return e.firstCreatePass&&(Gb(e,n),Aw(n)&&e.queries.elementEnd(n)),null!=t.classesWithoutHost&&function a8(n){return 0!=(8&n.flags)}(t)&&f1(e,t,qe(),t.classesWithoutHost,!0),null!=t.stylesWithoutHost&&function l8(n){return 0!=(16&n.flags)}(t)&&f1(e,t,qe(),t.stylesWithoutHost,!1),ft}function kr(n,t,e,r){return ut(n,t,e,r),ft(),kr}let KR=(n,t,e,r,i,o)=>(Xl(!0),oy(r,i,function CN(){return Gt.lFrame.currentNamespace}()));function Ry(n,t,e){const r=qe(),i=In(),o=n+bn,s=i.firstCreatePass?function rK(n,t,e,r,i){const o=t.consts,s=Kl(o,r),a=Gd(t,n,8,"ng-container",s);return null!==s&&Cy(a,s,!0),JT(t,e,a,Kl(o,i)),null!==t.queries&&t.queries.elementStart(t,a),a}(o,i,r,t,e):i.data[o];Ta(s,!0);const a=YR(i,r,s,n);return r[o]=a,jb()&&ay(i,r,a,s),Zi(a,r),$b(s)&&(YT(i,r,s),XT(i,s,r)),null!=e&&ZT(r,s),Ry}function My(){let n=Li();const t=In();return $w()?Lw():(n=n.parent,Ta(n,!1)),t.firstCreatePass&&(Gb(t,n),Aw(n)&&t.queries.elementEnd(n)),My}let YR=(n,t,e,r)=>(Xl(!0),hT(t[Qt],""));function xf(){return qe()}function wf(n){return!!n&&"function"==typeof n.then}function ZR(n){return!!n&&"function"==typeof n.subscribe}function an(n,t,e,r){const i=qe(),o=In(),s=Li();return function JR(n,t,e,r,i,o,s){const a=$b(r),u=n.firstCreatePass&&SR(n),p=t[Dr],m=TR(t);let g=!0;if(3&r.type||s){const T=Mo(r,t),I=s?s(T):T,N=m.length,R=s?V=>s(rr(V[r.index])):r.index;let L=null;if(!s&&a&&(L=function sK(n,t,e,r){const i=n.cleanup;if(null!=i)for(let o=0;o<i.length-1;o+=2){const s=i[o];if(s===e&&i[o+1]===r){const a=t[wd],c=i[o+2];return a.length>c?a[c]:null}"string"==typeof s&&(o+=2)}return null}(n,t,i,r.index)),null!==L)(L.__ngLastListenerFn__||L).__ngNextListenerFn__=o,L.__ngLastListenerFn__=o,g=!1;else{o=tM(r,t,p,o,!1);const V=e.listen(I,i,o);m.push(o,V),u&&u.push(i,R,N,N+1)}}else o=tM(r,t,p,o,!1);const _=r.outputs;let x;if(g&&null!==_&&(x=_[i])){const T=x.length;if(T)for(let I=0;I<T;I+=2){const j=t[x[I]][x[I+1]].subscribe(o),Y=m.length;m.push(o,j),u&&u.push(i,r.index,Y,-(Y+1))}}}(o,i,i[Qt],s,n,t,r),an}function eM(n,t,e,r){try{return wa(6,t,e),!1!==e(r)}catch(i){return IR(n,i),!1}finally{wa(7,t,e)}}function tM(n,t,e,r,i){return function o(s){if(s===Function)return r;df(n.componentOffset>-1?Fo(n.index,t):t);let c=eM(t,e,r,s),u=o.__ngNextListenerFn__;for(;u;)c=eM(t,e,u,s)&&c,u=u.__ngNextListenerFn__;return i&&!1===c&&(s.preventDefault(),s.returnValue=!1),c}}function Ar(n=1){return function Q5(n){return(Gt.lFrame.contextLView=function J5(n,t){for(;n>0;)t=t[Sd],n--;return t}(n,Gt.lFrame.contextLView))[Dr]}(n)}function aK(n,t){let e=null;const r=function r5(n){const t=n.attrs;if(null!=t){const e=t.indexOf(5);if(!(1&e))return t[e+1]}return null}(n);for(let i=0;i<t.length;i++){const o=t[i];if("*"!==o){if(null===r?U2(n,o,!0):a5(r,o))return i}else e=i}return e}function Tf(n){const t=qe()[Wr][Yi];if(!t.projection){const r=t.projection=qp(n?n.length:1,null),i=r.slice();let o=t.child;for(;null!==o;){const s=n?aK(o,n):0;null!==s&&(i[s]?i[s].projectionNext=o:r[s]=o,i[s]=o),o=o.next}}}function Sf(n,t=0,e){const r=qe(),i=In(),o=Gd(i,bn+n,16,null,e||null);null===o.projection&&(o.projection=t),Lw(),(!r[il]||function Vp(){return null!==Gt.skipHydrationRootTNode}())&&32!=(32&o.flags)&&function fq(n,t,e){_O(t[Qt],0,t,e,mT(n,e,t),pO(e.parent||t[Yi],e,t))}(i,r,o)}function Cf(n,t,e){return m1(n,"",t,"",e),Cf}function m1(n,t,e,r,i){const o=qe(),s=Wd(o,t,e,r);return s!==Jt&&rs(In(),xr(),o,n,s,o[Qt],i,!1),m1}function Fy(n,t){return n<<17|t<<2}function Zl(n){return n>>17&32767}function g1(n){return 2|n}function mu(n){return(131068&n)>>2}function b1(n,t){return-131069&n|t<<2}function y1(n){return 1|n}function uM(n,t,e,r,i){const o=n[e+1],s=null===t;let a=r?Zl(o):mu(o),c=!1;for(;0!==a&&(!1===c||s);){const p=n[a+1];pK(n[a],t)&&(c=!0,n[a+1]=r?y1(p):g1(p)),a=r?Zl(p):mu(p)}c&&(n[e+1]=r?g1(o):y1(o))}function pK(n,t){return null===n||null==t||(Array.isArray(n)?n[1]:n)===t||!(!Array.isArray(n)||"string"!=typeof t)&&Fd(n,t)>=0}const di={textEnd:0,key:0,keyEnd:0,value:0,valueEnd:0};function dM(n){return n.substring(di.key,di.keyEnd)}function hM(n,t){const e=di.textEnd;return e===t?-1:(t=di.keyEnd=function bK(n,t,e){for(;t<e&&n.charCodeAt(t)>32;)t++;return t}(n,di.key=t,e),eh(n,t,e))}function eh(n,t,e){for(;t<e&&n.charCodeAt(t)<=32;)t++;return t}function _1(n,t,e){return ea(n,t,e,!1),_1}function Yr(n,t){return ea(n,t,null,!0),Yr}function bM(n){!function ta(n,t,e,r){const i=In(),o=ll(2);i.firstUpdatePass&&_M(i,null,o,r);const s=qe();if(e!==Jt&&Ji(s,o,e)){const a=i.data[mo()];if(TM(a,r)&&!yM(i,o)){let c=r?a.classesWithoutHost:a.stylesWithoutHost;null!==c&&(e=yd(c,e||"")),f1(i,a,s,e,r)}else!function EK(n,t,e,r,i,o,s,a){i===Jt&&(i=Nn);let c=0,u=0,p=0<i.length?i[0]:null,m=0<o.length?o[0]:null;for(;null!==p||null!==m;){const g=c<i.length?i[c+1]:void 0,_=u<o.length?o[u+1]:void 0;let T,x=null;p===m?(c+=2,u+=2,g!==_&&(x=m,T=_)):null===m||null!==p&&p<m?(c+=2,x=p):(u+=2,x=m,T=_),null!==x&&xM(n,t,e,r,x,T,s,a),p=c<i.length?i[c]:null,m=u<o.length?o[u]:null}}(i,a,s,s[Qt],s[o+1],s[o+1]=function CK(n,t,e){if(null==e||""===e)return Nn;const r=[],i=Yl(e);if(Array.isArray(i))for(let o=0;o<i.length;o++)n(r,i[o],!0);else if("object"==typeof i)for(const o in i)i.hasOwnProperty(o)&&n(r,o,i[o]);else"string"==typeof i&&t(r,i);return r}(n,t,e),r,o)}}(IK,Da,n,!0)}function Da(n,t){for(let e=function mK(n){return function fM(n){di.key=0,di.keyEnd=0,di.value=0,di.valueEnd=0,di.textEnd=n.length}(n),hM(n,eh(n,0,di.textEnd))}(t);e>=0;e=hM(t,e))ts(n,dM(t),!0)}function ea(n,t,e,r){const i=qe(),o=In(),s=ll(2);o.firstUpdatePass&&_M(o,n,s,r),t!==Jt&&Ji(i,s,t)&&xM(o,o.data[mo()],i,i[Qt],n,i[s+1]=function DK(n,t){return null==n||""===n||("string"==typeof t?n+=t:"object"==typeof n&&(n=Er(Yl(n)))),n}(t,e),r,s)}function yM(n,t){return t>=n.expandoStartIndex}function _M(n,t,e,r){const i=n.data;if(null===i[e+1]){const o=i[mo()],s=yM(n,e);TM(o,r)&&null===t&&!s&&(t=!1),t=function xK(n,t,e,r){const i=function Vw(n){const t=Gt.lFrame.currentDirectiveIndex;return-1===t?null:n[t]}(n);let o=r?t.residualClasses:t.residualStyles;if(null===i)0===(r?t.classBindings:t.styleBindings)&&(e=If(e=v1(null,n,t,e,r),t.attrs,r),o=null);else{const s=t.directiveStylingLast;if(-1===s||n[s]!==i)if(e=v1(i,n,t,e,r),null===o){let c=function wK(n,t,e){const r=e?t.classBindings:t.styleBindings;if(0!==mu(r))return n[Zl(r)]}(n,t,r);void 0!==c&&Array.isArray(c)&&(c=v1(null,n,t,c[1],r),c=If(c,t.attrs,r),function TK(n,t,e,r){n[Zl(e?t.classBindings:t.styleBindings)]=r}(n,t,r,c))}else o=function SK(n,t,e){let r;const i=t.directiveEnd;for(let o=1+t.directiveStylingLast;o<i;o++)r=If(r,n[o].hostAttrs,e);return If(r,t.attrs,e)}(n,t,r)}return void 0!==o&&(r?t.residualClasses=o:t.residualStyles=o),e}(i,o,t,r),function dK(n,t,e,r,i,o){let s=o?t.classBindings:t.styleBindings,a=Zl(s),c=mu(s);n[r]=e;let p,u=!1;if(Array.isArray(e)?(p=e[1],(null===p||Fd(e,p)>0)&&(u=!0)):p=e,i)if(0!==c){const g=Zl(n[a+1]);n[r+1]=Fy(g,a),0!==g&&(n[g+1]=b1(n[g+1],r)),n[a+1]=function cK(n,t){return 131071&n|t<<17}(n[a+1],r)}else n[r+1]=Fy(a,0),0!==a&&(n[a+1]=b1(n[a+1],r)),a=r;else n[r+1]=Fy(c,0),0===a?a=r:n[c+1]=b1(n[c+1],r),c=r;u&&(n[r+1]=g1(n[r+1])),uM(n,p,r,!0),uM(n,p,r,!1),function hK(n,t,e,r,i){const o=i?n.residualClasses:n.residualStyles;null!=o&&"string"==typeof t&&Fd(o,t)>=0&&(e[r+1]=y1(e[r+1]))}(t,p,n,r,o),s=Fy(a,c),o?t.classBindings=s:t.styleBindings=s}(i,o,t,e,s,r)}}function v1(n,t,e,r,i){let o=null;const s=e.directiveEnd;let a=e.directiveStylingLast;for(-1===a?a=e.directiveStart:a++;a<s&&(o=t[a],r=If(r,o.hostAttrs,i),o!==n);)a++;return null!==n&&(e.directiveStylingLast=a),r}function If(n,t,e){const r=e?1:2;let i=-1;if(null!==t)for(let o=0;o<t.length;o++){const s=t[o];"number"==typeof s?i=s:i===r&&(Array.isArray(n)||(n=void 0===n?[]:["",n]),ts(n,s,!!e||t[++o]))}return void 0===n?null:n}function IK(n,t,e){const r=String(t);""!==r&&!r.includes(" ")&&ts(n,r,e)}function xM(n,t,e,r,i,o,s,a){if(!(3&t.type))return;const c=n.data,u=c[a+1],p=function uK(n){return 1==(1&n)}(u)?wM(c,t,e,i,mu(u),s):void 0;Py(p)||(Py(o)||function lK(n){return 2==(2&n)}(u)&&(o=wM(c,null,e,i,a,s)),function gq(n,t,e,r,i){if(t)i?n.addClass(e,r):n.removeClass(e,r);else{let o=-1===r.indexOf("-")?void 0:Po.DashCase;null==i?n.removeStyle(e,r,o):("string"==typeof i&&i.endsWith("!important")&&(i=i.slice(0,-10),o|=Po.Important),n.setStyle(e,r,i,o))}}(r,s,zb(mo(),e),i,o))}function wM(n,t,e,r,i,o){const s=null===t;let a;for(;i>0;){const c=n[i],u=Array.isArray(c),p=u?c[1]:c,m=null===p;let g=e[i+1];g===Jt&&(g=m?Nn:void 0);let _=m?Qw(g,r):p===r?g:void 0;if(u&&!Py(_)&&(_=Qw(c,r)),Py(_)&&(a=_,s))return a;const x=n[i+1];i=s?Zl(x):mu(x)}if(null!==t){let c=o?t.residualClasses:t.residualStyles;null!=c&&(a=Qw(c,r))}return a}function Py(n){return void 0!==n}function TM(n,t){return 0!=(n.flags&(t?8:16))}function _n(n,t=""){const e=qe(),r=In(),i=n+bn,o=r.firstCreatePass?Gd(r,i,1,t,null):r.data[i],s=SM(r,e,o,t,n);e[i]=s,jb()&&ay(r,e,s,o),Ta(o,!1)}let SM=(n,t,e,r,i)=>(Xl(!0),function iy(n,t){return n.createText(t)}(t[Qt],r));function Ii(n){return Ql("",n,""),Ii}function Ql(n,t,e){const r=qe(),i=Wd(r,n,t,e);return i!==Jt&&pl(r,mo(),i),Ql}function x1(n,t,e,r,i){const o=qe(),s=qd(o,n,t,e,r,i);return s!==Jt&&pl(o,mo(),s),x1}function $y(n,t,e){const r=qe();return Ji(r,Dd(),t)&&rs(In(),xr(),r,n,t,r[Qt],e,!0),$y}const gu=void 0;var YK=["en",[["a","p"],["AM","PM"],gu],[["AM","PM"],gu,gu],[["S","M","T","W","T","F","S"],["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],["Su","Mo","Tu","We","Th","Fr","Sa"]],gu,[["J","F","M","A","M","J","J","A","S","O","N","D"],["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],["January","February","March","April","May","June","July","August","September","October","November","December"]],gu,[["B","A"],["BC","AD"],["Before Christ","Anno Domini"]],0,[6,0],["M/d/yy","MMM d, y","MMMM d, y","EEEE, MMMM d, y"],["h:mm a","h:mm:ss a","h:mm:ss a z","h:mm:ss a zzzz"],["{1}, {0}",gu,"{1} 'at' {0}",gu],[".",",",";","%","+","-","E","\xd7","\u2030","\u221e","NaN",":"],["#,##0.###","#,##0%","\xa4#,##0.00","#E0"],"USD","$","US Dollar",{},"ltr",function XK(n){const e=Math.floor(Math.abs(n)),r=n.toString().replace(/^[^.]*\.?/,"").length;return 1===e&&0===r?1:5}];let th={};function go(n){const t=function ZK(n){return n.toLowerCase().replace(/_/g,"-")}(n);let e=jM(t);if(e)return e;const r=t.split("-")[0];if(e=jM(r),e)return e;if("en"===r)return YK;throw new ze(701,!1)}function jM(n){return n in th||(th[n]=Jn.ng&&Jn.ng.common&&Jn.ng.common.locales&&Jn.ng.common.locales[n]),th[n]}var gt=(()=>((gt=gt||{})[gt.LocaleId=0]="LocaleId",gt[gt.DayPeriodsFormat=1]="DayPeriodsFormat",gt[gt.DayPeriodsStandalone=2]="DayPeriodsStandalone",gt[gt.DaysFormat=3]="DaysFormat",gt[gt.DaysStandalone=4]="DaysStandalone",gt[gt.MonthsFormat=5]="MonthsFormat",gt[gt.MonthsStandalone=6]="MonthsStandalone",gt[gt.Eras=7]="Eras",gt[gt.FirstDayOfWeek=8]="FirstDayOfWeek",gt[gt.WeekendRange=9]="WeekendRange",gt[gt.DateFormat=10]="DateFormat",gt[gt.TimeFormat=11]="TimeFormat",gt[gt.DateTimeFormat=12]="DateTimeFormat",gt[gt.NumberSymbols=13]="NumberSymbols",gt[gt.NumberFormats=14]="NumberFormats",gt[gt.CurrencyCode=15]="CurrencyCode",gt[gt.CurrencySymbol=16]="CurrencySymbol",gt[gt.CurrencyName=17]="CurrencyName",gt[gt.Currencies=18]="Currencies",gt[gt.Directionality=19]="Directionality",gt[gt.PluralCase=20]="PluralCase",gt[gt.ExtraData=21]="ExtraData",gt))();const nh="en-US";let GM=nh;function S1(n,t,e,r,i){if(n=vt(n),Array.isArray(n))for(let o=0;o<n.length;o++)S1(n[o],t,e,r,i);else{const o=In(),s=qe();let a=uu(n)?n:vt(n.provide),c=UO(n);const u=Li(),p=1048575&u.providerIndexes,m=u.directiveStart,g=u.providerIndexes>>20;if(uu(n)||!n.multi){const _=new Up(c,i,de),x=I1(a,t,i?p:p+g,m);-1===x?(Xw(Yb(u,s),o,a),C1(o,n,t.length),t.push(a),u.directiveStart++,u.directiveEnd++,i&&(u.providerIndexes+=1048576),e.push(_),s.push(_)):(e[x]=_,s[x]=_)}else{const _=I1(a,t,p+g,m),x=I1(a,t,p,p+g),I=x>=0&&e[x];if(i&&!I||!i&&!(_>=0&&e[_])){Xw(Yb(u,s),o,a);const N=function KX(n,t,e,r,i){const o=new Up(n,e,de);return o.multi=[],o.index=t,o.componentProviders=0,mF(o,i,r&&!e),o}(i?qX:WX,e.length,i,r,c);!i&&I&&(e[x].providerFactory=N),C1(o,n,t.length,0),t.push(a),u.directiveStart++,u.directiveEnd++,i&&(u.providerIndexes+=1048576),e.push(N),s.push(N)}else C1(o,n,_>-1?_:x,mF(e[i?x:_],c,!i&&r));!i&&r&&I&&e[x].componentProviders++}}}function C1(n,t,e,r){const i=uu(t),o=function Wq(n){return!!n.useClass}(t);if(i||o){const c=(o?vt(t.useClass):t).prototype.ngOnDestroy;if(c){const u=n.destroyHooks||(n.destroyHooks=[]);if(!i&&t.multi){const p=u.indexOf(e);-1===p?u.push(e,[r,c]):u[p+1].push(r,c)}else u.push(e,c)}}}function mF(n,t,e){return e&&n.componentProviders++,n.multi.push(t)-1}function I1(n,t,e,r){for(let i=e;i<r;i++)if(t[i]===n)return i;return-1}function WX(n,t,e,r){return E1(this.multi,[])}function qX(n,t,e,r){const i=this.multi;let o;if(this.providerFactory){const s=this.providerFactory.componentProviders,a=lu(e,e[mt],this.providerFactory.index,r);o=a.slice(0,s),E1(i,o);for(let c=s;c<a.length;c++)o.push(a[c])}else o=[],E1(i,o);return o}function E1(n,t){for(let e=0;e<n.length;e++)t.push((0,n[e])());return t}function En(n,t=[]){return e=>{e.providersResolver=(r,i)=>function HX(n,t,e){const r=In();if(r.firstCreatePass){const i=Js(n);S1(e,r.data,r.blueprint,i,!0),S1(t,r.data,r.blueprint,i,!1)}}(r,i?i(n):n,t)}}class rh{}class gF{}class D1 extends rh{constructor(t,e,r){super(),this._parent=e,this._bootstrapComponents=[],this.destroyCbs=[],this.componentFactoryResolver=new DR(this);const i=Qo(t);this._bootstrapComponents=hl(i.bootstrap),this._r3Injector=hR(t,e,[{provide:rh,useValue:this},{provide:du,useValue:this.componentFactoryResolver},...r],Er(t),new Set(["environment"])),this._r3Injector.resolveInjectorInitializers(),this.instance=this._r3Injector.get(t)}get injector(){return this._r3Injector}destroy(){const t=this._r3Injector;!t.destroyed&&t.destroy(),this.destroyCbs.forEach(e=>e()),this.destroyCbs=null}onDestroy(t){this.destroyCbs.push(t)}}class k1 extends gF{constructor(t){super(),this.moduleType=t}create(t){return new D1(this.moduleType,t,[])}}class bF extends rh{constructor(t){super(),this.componentFactoryResolver=new DR(this),this.instance=null;const e=new OT([...t.providers,{provide:rh,useValue:this},{provide:du,useValue:this.componentFactoryResolver}],t.parent||py(),t.debugName,new Set(["environment"]));this.injector=e,t.runEnvironmentInitializers&&e.resolveInjectorInitializers()}destroy(){this.injector.destroy()}onDestroy(t){this.injector.onDestroy(t)}}function A1(n,t,e=null){return new bF({providers:n,parent:t,debugName:e,runEnvironmentInitializers:!0}).injector}let ZX=(()=>{class n{constructor(e){this._injector=e,this.cachedInjectors=new Map}getOrCreateStandaloneInjector(e){if(!e.standalone)return null;if(!this.cachedInjectors.has(e.id)){const r=LO(0,e.type),i=r.length>0?A1([r],this._injector,`Standalone[${e.type.name}]`):null;this.cachedInjectors.set(e.id,i)}return this.cachedInjectors.get(e.id)}ngOnDestroy(){try{for(const e of this.cachedInjectors.values())null!==e&&e.destroy()}finally{this.cachedInjectors.clear()}}}return n.\u0275prov=at({token:n,providedIn:"environment",factory:()=>new n(Fe(ul))}),n})();function yF(n){n.getStandaloneInjector=t=>t.get(ZX).getOrCreateStandaloneInjector(n)}function Uy(n,t,e){const r=fo()+n,i=qe();return i[r]===Jt?Ia(i,r,e?t.call(e):t()):function gf(n,t){return n[t]}(i,r)}function CF(n,t,e,r){return function EF(n,t,e,r,i,o){const s=t+e;return Ji(n,s,i)?Ia(n,s+1,o?r.call(o,i):r(i)):Rf(n,s+1)}(qe(),fo(),n,t,e,r)}function Of(n,t,e,r,i,o){return function kF(n,t,e,r,i,o,s,a){const c=t+e;return function ky(n,t,e,r,i){const o=fu(n,t,e,r);return Ji(n,t+2,i)||o}(n,c,i,o,s)?Ia(n,c+3,a?r.call(a,i,o,s):r(i,o,s)):Rf(n,c+3)}(qe(),fo(),n,t,e,r,i,o)}function Rf(n,t){const e=n[t];return e===Jt?void 0:e}function DF(n,t,e,r,i,o,s){const a=t+e;return fu(n,a,i,o)?Ia(n,a+2,s?r.call(s,i,o):r(i,o)):Rf(n,a+2)}function bo(n,t){const e=In();let r;const i=n+bn;e.firstCreatePass?(r=function hY(n,t){if(t)for(let e=t.length-1;e>=0;e--){const r=t[e];if(n===r.name)return r}}(t,e.pipeRegistry),e.data[i]=r,r.onDestroy&&(e.destroyHooks??=[]).push(i,r.onDestroy)):r=e.data[i];const o=r.factory||(r.factory=su(r.type)),s=Ao(de);try{const a=Xb(!1),c=o();return Xb(a),function J9(n,t,e,r){e>=n.data.length&&(n.data[e]=null,n.blueprint[e]=null),t[e]=r}(e,qe(),i,c),c}finally{Ao(s)}}function yo(n,t,e,r){const i=n+bn,o=qe(),s=Ed(o,i);return function Mf(n,t){return n[mt].data[t].pure}(o,i)?DF(o,fo(),t,s.transform,e,r,s):s.transform(e,r)}function O1(n){return t=>{setTimeout(n,void 0,t)}}const rn=class bY extends Kt{constructor(t=!1){super(),this.__isAsync=t}emit(t){super.next(t)}subscribe(t,e,r){let i=t,o=e||(()=>null),s=r;if(t&&"object"==typeof t){const c=t;i=c.next?.bind(c),o=c.error?.bind(c),s=c.complete?.bind(c)}this.__isAsync&&(o=O1(o),i&&(i=O1(i)),s&&(s=O1(s)));const a=super.subscribe({next:i,error:o,complete:s});return t instanceof le&&t.add(a),a}};function yY(){return this._results[Symbol.iterator]()}class ih{get changes(){return this._changes||(this._changes=new rn)}constructor(t=!1){this._emitDistinctChangesOnly=t,this.dirty=!0,this._results=[],this._changesDetected=!1,this._changes=null,this.length=0,this.first=void 0,this.last=void 0;const e=ih.prototype;e[Symbol.iterator]||(e[Symbol.iterator]=yY)}get(t){return this._results[t]}map(t){return this._results.map(t)}filter(t){return this._results.filter(t)}find(t){return this._results.find(t)}reduce(t,e){return this._results.reduce(t,e)}forEach(t){this._results.forEach(t)}some(t){return this._results.some(t)}toArray(){return this._results.slice()}toString(){return this._results.toString()}reset(t,e){const r=this;r.dirty=!1;const i=function Ss(n){return n.flat(Number.POSITIVE_INFINITY)}(t);(this._changesDetected=!function _8(n,t,e){if(n.length!==t.length)return!1;for(let r=0;r<n.length;r++){let i=n[r],o=t[r];if(e&&(i=e(i),o=e(o)),o!==i)return!1}return!0}(r._results,i,e))&&(r._results=i,r.length=i.length,r.last=i[this.length-1],r.first=i[0])}notifyOnChanges(){this._changes&&(this._changesDetected||!this._emitDistinctChangesOnly)&&this._changes.emit(this)}setDirty(){this.dirty=!0}destroy(){this.changes.complete(),this.changes.unsubscribe()}}let _o=(()=>{class n{}return n.__NG_ELEMENT_ID__=xY,n})();const _Y=_o,vY=class extends _Y{constructor(t,e,r){super(),this._declarationLView=t,this._declarationTContainer=e,this.elementRef=r}get ssrId(){return this._declarationTContainer.tView?.ssrId||null}createEmbeddedView(t,e){return this.createEmbeddedViewImpl(t,e,null)}createEmbeddedViewImpl(t,e,r){const i=this._declarationTContainer.tView,o=Ty(this._declarationLView,i,t,16,null,i.declTNode,null,null,null,e||null,r||null);o[$p]=this._declarationLView[this._declarationTContainer.index];const a=this._declarationLView[_a];return null!==a&&(o[_a]=a.createEmbeddedView(i)),o1(i,o,t),new ff(o)}};function xY(){return jy(Li(),qe())}function jy(n,t){return 4&n.type?new vY(t,n,zd(n,t)):null}let eo=(()=>{class n{}return n.__NG_ELEMENT_ID__=DY,n})();function DY(){return $F(Li(),qe())}const kY=eo,FF=class extends kY{constructor(t,e,r){super(),this._lContainer=t,this._hostTNode=e,this._hostLView=r}get element(){return zd(this._hostTNode,this._hostLView)}get injector(){return new Ad(this._hostTNode,this._hostLView)}get parentInjector(){const t=Kw(this._hostTNode,this._hostLView);if(kN(t)){const e=Kb(t,this._hostLView),r=qb(t);return new Ad(e[mt].data[r+8],e)}return new Ad(null,this._hostLView)}clear(){for(;this.length>0;)this.remove(this.length-1)}get(t){const e=PF(this._lContainer);return null!==e&&e[t]||null}get length(){return this._lContainer.length-$i}createEmbeddedView(t,e,r){let i,o;"number"==typeof r?i=r:null!=r&&(i=r.index,o=r.injector);const a=t.createEmbeddedViewImpl(e||{},o,null);return this.insertImpl(a,i,!1),a}createComponent(t,e,r,i,o){const s=t&&!function Hp(n){return"function"==typeof n}(t);let a;if(s)a=e;else{const x=e||{};a=x.index,r=x.injector,i=x.projectableNodes,o=x.environmentInjector||x.ngModuleRef}const c=s?t:new mf(On(t)),u=r||this.parentInjector;if(!o&&null==c.ngModule){const T=(s?u:this.parentInjector).get(ul,null);T&&(o=T)}On(c.componentType??{});const _=c.create(u,i,null,o);return this.insertImpl(_.hostView,a,!1),_}insert(t,e){return this.insertImpl(t,e,!1)}insertImpl(t,e,r){const i=t._lView,o=i[mt];if(function P5(n){return es(n[vr])}(i)){const c=this.indexOf(t);if(-1!==c)this.detach(c);else{const u=i[vr],p=new FF(u,u[Yi],u[vr]);p.detach(p.indexOf(t))}}const s=this._adjustIndex(e),a=this._lContainer;if(function lq(n,t,e,r){const i=$i+r,o=e.length;r>0&&(e[i-1][Qs]=t),r<o-$i?(t[Qs]=e[i],zN(e,$i+r,t)):(e.push(t),t[Qs]=null),t[vr]=e;const s=t[$p];null!==s&&e!==s&&function cq(n,t){const e=n[Id];t[Wr]!==t[vr][vr][Wr]&&(n[X2]=!0),null===e?n[Id]=[t]:e.push(t)}(s,t);const a=t[_a];null!==a&&a.insertView(n),t[tn]|=128}(o,i,a,s),!r){const c=bT(s,a),u=i[Qt],p=sy(u,a[va]);null!==p&&function oq(n,t,e,r,i,o){r[Si]=i,r[Yi]=t,Qp(n,r,e,1,i,o)}(o,a[Yi],u,i,p,c)}return t.attachToViewContainerRef(),zN(M1(a),s,t),t}move(t,e){return this.insert(t,e)}indexOf(t){const e=PF(this._lContainer);return null!==e?e.indexOf(t):-1}remove(t){const e=this._adjustIndex(t,-1),r=pT(this._lContainer,e);r&&(Qb(M1(this._lContainer),e),cO(r[mt],r))}detach(t){const e=this._adjustIndex(t,-1),r=pT(this._lContainer,e);return r&&null!=Qb(M1(this._lContainer),e)?new ff(r):null}_adjustIndex(t,e=0){return t??this.length+e}};function PF(n){return n[Pb]}function M1(n){return n[Pb]||(n[Pb]=[])}function $F(n,t){let e;const r=t[n.index];return es(r)?e=r:(e=xR(r,t,null,n),t[n.index]=e,Sy(t,e)),LF(e,t,n,r),new FF(e,n,t)}let LF=function BF(n,t,e,r){if(n[va])return;let i;i=8&e.type?rr(r):function AY(n,t){const e=n[Qt],r=e.createComment(""),i=Mo(t,n);return cu(e,sy(e,i),r,function pq(n,t){return n.nextSibling(t)}(e,i),!1),r}(t,e),n[va]=i};class F1{constructor(t){this.queryList=t,this.matches=null}clone(){return new F1(this.queryList)}setDirty(){this.queryList.setDirty()}}class P1{constructor(t=[]){this.queries=t}createEmbeddedView(t){const e=t.queries;if(null!==e){const r=null!==t.contentQueries?t.contentQueries[0]:e.length,i=[];for(let o=0;o<r;o++){const s=e.getByIndex(o);i.push(this.queries[s.indexInDeclarationView].clone())}return new P1(i)}return null}insertView(t){this.dirtyQueriesWithMatches(t)}detachView(t){this.dirtyQueriesWithMatches(t)}dirtyQueriesWithMatches(t){for(let e=0;e<this.queries.length;e++)null!==GF(t,e).matches&&this.queries[e].setDirty()}}class VF{constructor(t,e,r=null){this.predicate=t,this.flags=e,this.read=r}}class $1{constructor(t=[]){this.queries=t}elementStart(t,e){for(let r=0;r<this.queries.length;r++)this.queries[r].elementStart(t,e)}elementEnd(t){for(let e=0;e<this.queries.length;e++)this.queries[e].elementEnd(t)}embeddedTView(t){let e=null;for(let r=0;r<this.length;r++){const i=null!==e?e.length:0,o=this.getByIndex(r).embeddedTView(t,i);o&&(o.indexInDeclarationView=r,null!==e?e.push(o):e=[o])}return null!==e?new $1(e):null}template(t,e){for(let r=0;r<this.queries.length;r++)this.queries[r].template(t,e)}getByIndex(t){return this.queries[t]}get length(){return this.queries.length}track(t){this.queries.push(t)}}class L1{constructor(t,e=-1){this.metadata=t,this.matches=null,this.indexInDeclarationView=-1,this.crossesNgTemplate=!1,this._appliesToNextNode=!0,this._declarationNodeIndex=e}elementStart(t,e){this.isApplyingToNode(e)&&this.matchTNode(t,e)}elementEnd(t){this._declarationNodeIndex===t.index&&(this._appliesToNextNode=!1)}template(t,e){this.elementStart(t,e)}embeddedTView(t,e){return this.isApplyingToNode(t)?(this.crossesNgTemplate=!0,this.addMatch(-t.index,e),new L1(this.metadata)):null}isApplyingToNode(t){if(this._appliesToNextNode&&1!=(1&this.metadata.flags)){const e=this._declarationNodeIndex;let r=t.parent;for(;null!==r&&8&r.type&&r.index!==e;)r=r.parent;return e===(null!==r?r.index:-1)}return this._appliesToNextNode}matchTNode(t,e){const r=this.metadata.predicate;if(Array.isArray(r))for(let i=0;i<r.length;i++){const o=r[i];this.matchTNodeWithReadOption(t,e,RY(e,o)),this.matchTNodeWithReadOption(t,e,Zb(e,t,o,!1,!1))}else r===_o?4&e.type&&this.matchTNodeWithReadOption(t,e,-1):this.matchTNodeWithReadOption(t,e,Zb(e,t,r,!1,!1))}matchTNodeWithReadOption(t,e,r){if(null!==r){const i=this.metadata.read;if(null!==i)if(i===yn||i===eo||i===_o&&4&e.type)this.addMatch(e.index,-2);else{const o=Zb(e,t,i,!1,!1);null!==o&&this.addMatch(e.index,o)}else this.addMatch(e.index,r)}}addMatch(t,e){null===this.matches?this.matches=[t,e]:this.matches.push(t,e)}}function RY(n,t){const e=n.localNames;if(null!==e)for(let r=0;r<e.length;r+=2)if(e[r]===t)return e[r+1];return null}function FY(n,t,e,r){return-1===e?function MY(n,t){return 11&n.type?zd(n,t):4&n.type?jy(n,t):null}(t,n):-2===e?function PY(n,t,e){return e===yn?zd(t,n):e===_o?jy(t,n):e===eo?$F(t,n):void 0}(n,t,r):lu(n,n[mt],e,t)}function zF(n,t,e,r){const i=t[_a].queries[r];if(null===i.matches){const o=n.data,s=e.matches,a=[];for(let c=0;c<s.length;c+=2){const u=s[c];a.push(u<0?null:FY(t,o[u],s[c+1],e.metadata.read))}i.matches=a}return i.matches}function B1(n,t,e,r){const i=n.queries.getByIndex(e),o=i.matches;if(null!==o){const s=zF(n,t,i,e);for(let a=0;a<o.length;a+=2){const c=o[a];if(c>0)r.push(s[a/2]);else{const u=o[a+1],p=t[-c];for(let m=$i;m<p.length;m++){const g=p[m];g[$p]===g[vr]&&B1(g[mt],g,u,r)}if(null!==p[Id]){const m=p[Id];for(let g=0;g<m.length;g++){const _=m[g];B1(_[mt],_,u,r)}}}}}return r}function ir(n){const t=qe(),e=In(),r=_N();zw(r+1);const i=GF(e,r);if(n.dirty&&function F5(n){return 4==(4&n[tn])}(t)===(2==(2&i.metadata.flags))){if(null===i.matches)n.reset([]);else{const o=i.crossesNgTemplate?B1(e,t,r,[]):zF(e,t,i,r);n.reset(o,p7),n.notifyOnChanges()}return!0}return!1}function Bi(n,t,e){const r=In();r.firstCreatePass&&(jF(r,new VF(n,t,e),-1),2==(2&t)&&(r.staticViewQueries=!0)),UF(r,qe(),t)}function fl(n,t,e,r){const i=In();if(i.firstCreatePass){const o=Li();jF(i,new VF(t,e,r),o.index),function LY(n,t){const e=n.contentQueries||(n.contentQueries=[]);t!==(e.length?e[e.length-1]:-1)&&e.push(n.queries.length-1,t)}(i,n),2==(2&e)&&(i.staticContentQueries=!0)}UF(i,qe(),e)}function or(){return function $Y(n,t){return n[_a].queries[t].queryList}(qe(),_N())}function UF(n,t,e){const r=new ih(4==(4&e));(function P7(n,t,e,r){const i=TR(t);i.push(e),n.firstCreatePass&&SR(n).push(r,i.length-1)})(n,t,r,r.destroy),null===t[_a]&&(t[_a]=new P1),t[_a].queries.push(new F1(r))}function jF(n,t,e){null===n.queries&&(n.queries=new $1),n.queries.track(new L1(t,e))}function GF(n,t){return n.queries.getByIndex(t)}function HF(n,t){return jy(n,t)}const H1=new Qe("Application Initializer");let W1=(()=>{class n{constructor(){this.initialized=!1,this.done=!1,this.donePromise=new Promise((e,r)=>{this.resolve=e,this.reject=r}),this.appInits=It(H1,{optional:!0})??[]}runInitializers(){if(this.initialized)return;const e=[];for(const i of this.appInits){const o=i();if(wf(o))e.push(o);else if(ZR(o)){const s=new Promise((a,c)=>{o.subscribe({complete:a,error:c})});e.push(s)}}const r=()=>{this.done=!0,this.resolve()};Promise.all(e).then(()=>{r()}).catch(i=>{this.reject(i)}),0===e.length&&r(),this.initialized=!0}}return n.\u0275fac=function(e){return new(e||n)},n.\u0275prov=at({token:n,factory:n.\u0275fac,providedIn:"root"}),n})(),lP=(()=>{class n{log(e){console.log(e)}warn(e){console.warn(e)}}return n.\u0275fac=function(e){return new(e||n)},n.\u0275prov=at({token:n,factory:n.\u0275fac,providedIn:"platform"}),n})();const ka=new Qe("LocaleId",{providedIn:"root",factory:()=>It(ka,Bt.Optional|Bt.SkipSelf)||function oZ(){return typeof $localize<"u"&&$localize.locale||nh}()});class aZ{constructor(t,e){this.ngModuleFactory=t,this.componentFactories=e}}let cP=(()=>{class n{compileModuleSync(e){return new k1(e)}compileModuleAsync(e){return Promise.resolve(this.compileModuleSync(e))}compileModuleAndAllComponentsSync(e){const r=this.compileModuleSync(e),o=hl(Qo(e).declarations).reduce((s,a)=>{const c=On(a);return c&&s.push(new mf(c)),s},[]);return new aZ(r,o)}compileModuleAndAllComponentsAsync(e){return Promise.resolve(this.compileModuleAndAllComponentsSync(e))}clearCache(){}clearCacheFor(e){}getModuleId(e){}}return n.\u0275fac=function(e){return new(e||n)},n.\u0275prov=at({token:n,factory:n.\u0275fac,providedIn:"root"}),n})();const uZ=(()=>Promise.resolve(0))();function q1(n){typeof Zone>"u"?uZ.then(()=>{n&&n.apply(null,null)}):Zone.current.scheduleMicroTask("scheduleMicrotask",n)}function hP(...n){}class Vt{constructor({enableLongStackTrace:t=!1,shouldCoalesceEventChangeDetection:e=!1,shouldCoalesceRunChangeDetection:r=!1}){if(this.hasPendingMacrotasks=!1,this.hasPendingMicrotasks=!1,this.isStable=!0,this.onUnstable=new rn(!1),this.onMicrotaskEmpty=new rn(!1),this.onStable=new rn(!1),this.onError=new rn(!1),typeof Zone>"u")throw new ze(908,!1);Zone.assertZonePatched();const i=this;i._nesting=0,i._outer=i._inner=Zone.current,Zone.TaskTrackingZoneSpec&&(i._inner=i._inner.fork(new Zone.TaskTrackingZoneSpec)),t&&Zone.longStackTraceZoneSpec&&(i._inner=i._inner.fork(Zone.longStackTraceZoneSpec)),i.shouldCoalesceEventChangeDetection=!r&&e,i.shouldCoalesceRunChangeDetection=r,i.lastRequestAnimationFrameId=-1,i.nativeRequestAnimationFrame=function dZ(){let n=Jn.requestAnimationFrame,t=Jn.cancelAnimationFrame;if(typeof Zone<"u"&&n&&t){const e=n[Zone.__symbol__("OriginalDelegate")];e&&(n=e);const r=t[Zone.__symbol__("OriginalDelegate")];r&&(t=r)}return{nativeRequestAnimationFrame:n,nativeCancelAnimationFrame:t}}().nativeRequestAnimationFrame,function fZ(n){const t=()=>{!function pZ(n){n.isCheckStableRunning||-1!==n.lastRequestAnimationFrameId||(n.lastRequestAnimationFrameId=n.nativeRequestAnimationFrame.call(Jn,()=>{n.fakeTopEventTask||(n.fakeTopEventTask=Zone.root.scheduleEventTask("fakeTopEventTask",()=>{n.lastRequestAnimationFrameId=-1,X1(n),n.isCheckStableRunning=!0,K1(n),n.isCheckStableRunning=!1},void 0,()=>{},()=>{})),n.fakeTopEventTask.invoke()}),X1(n))}(n)};n._inner=n._inner.fork({name:"angular",properties:{isAngularZone:!0},onInvokeTask:(e,r,i,o,s,a)=>{try{return pP(n),e.invokeTask(i,o,s,a)}finally{(n.shouldCoalesceEventChangeDetection&&"eventTask"===o.type||n.shouldCoalesceRunChangeDetection)&&t(),fP(n)}},onInvoke:(e,r,i,o,s,a,c)=>{try{return pP(n),e.invoke(i,o,s,a,c)}finally{n.shouldCoalesceRunChangeDetection&&t(),fP(n)}},onHasTask:(e,r,i,o)=>{e.hasTask(i,o),r===i&&("microTask"==o.change?(n._hasPendingMicrotasks=o.microTask,X1(n),K1(n)):"macroTask"==o.change&&(n.hasPendingMacrotasks=o.macroTask))},onHandleError:(e,r,i,o)=>(e.handleError(i,o),n.runOutsideAngular(()=>n.onError.emit(o)),!1)})}(i)}static isInAngularZone(){return typeof Zone<"u"&&!0===Zone.current.get("isAngularZone")}static assertInAngularZone(){if(!Vt.isInAngularZone())throw new ze(909,!1)}static assertNotInAngularZone(){if(Vt.isInAngularZone())throw new ze(909,!1)}run(t,e,r){return this._inner.run(t,e,r)}runTask(t,e,r,i){const o=this._inner,s=o.scheduleEventTask("NgZoneEvent: "+i,t,hZ,hP,hP);try{return o.runTask(s,e,r)}finally{o.cancelTask(s)}}runGuarded(t,e,r){return this._inner.runGuarded(t,e,r)}runOutsideAngular(t){return this._outer.run(t)}}const hZ={};function K1(n){if(0==n._nesting&&!n.hasPendingMicrotasks&&!n.isStable)try{n._nesting++,n.onMicrotaskEmpty.emit(null)}finally{if(n._nesting--,!n.hasPendingMicrotasks)try{n.runOutsideAngular(()=>n.onStable.emit(null))}finally{n.isStable=!0}}}function X1(n){n.hasPendingMicrotasks=!!(n._hasPendingMicrotasks||(n.shouldCoalesceEventChangeDetection||n.shouldCoalesceRunChangeDetection)&&-1!==n.lastRequestAnimationFrameId)}function pP(n){n._nesting++,n.isStable&&(n.isStable=!1,n.onUnstable.emit(null))}function fP(n){n._nesting--,K1(n)}class mZ{constructor(){this.hasPendingMicrotasks=!1,this.hasPendingMacrotasks=!1,this.isStable=!0,this.onUnstable=new rn,this.onMicrotaskEmpty=new rn,this.onStable=new rn,this.onError=new rn}run(t,e,r){return t.apply(e,r)}runGuarded(t,e,r){return t.apply(e,r)}runOutsideAngular(t){return t()}runTask(t,e,r,i){return t.apply(e,r)}}const mP=new Qe("",{providedIn:"root",factory:gP});function gP(){const n=It(Vt);let t=!0;return Et(new An(i=>{t=n.isStable&&!n.hasPendingMacrotasks&&!n.hasPendingMicrotasks,n.runOutsideAngular(()=>{i.next(t),i.complete()})}),new An(i=>{let o;n.runOutsideAngular(()=>{o=n.onStable.subscribe(()=>{Vt.assertNotInAngularZone(),q1(()=>{!t&&!n.hasPendingMacrotasks&&!n.hasPendingMicrotasks&&(t=!0,i.next(!0))})})});const s=n.onUnstable.subscribe(()=>{Vt.assertInAngularZone(),t&&(t=!1,n.runOutsideAngular(()=>{i.next(!1)}))});return()=>{o.unsubscribe(),s.unsubscribe()}}).pipe(function _r(n={}){const{connector:t=(()=>new Kt),resetOnError:e=!0,resetOnComplete:r=!0,resetOnRefCountZero:i=!0}=n;return o=>{let s,a,c,u=0,p=!1,m=!1;const g=()=>{a?.unsubscribe(),a=void 0},_=()=>{g(),s=c=void 0,p=m=!1},x=()=>{const T=s;_(),T?.unsubscribe()};return Rn((T,I)=>{u++,!m&&!p&&g();const N=c=c??t();I.add(()=>{u--,0===u&&!m&&!p&&(a=Ki(x,i))}),N.subscribe(I),!s&&u>0&&(s=new Lr({next:R=>N.next(R),error:R=>{m=!0,g(),a=Ki(_,e,R),N.error(R)},complete:()=>{p=!0,g(),a=Ki(_,r),N.complete()}}),wi(T).subscribe(s))})(o)}}()))}const bP=new Qe(""),Hy=new Qe("");let Q1,Y1=(()=>{class n{constructor(e,r,i){this._ngZone=e,this.registry=r,this._pendingCount=0,this._isZoneStable=!0,this._didWork=!1,this._callbacks=[],this.taskTrackingZone=null,Q1||(function gZ(n){Q1=n}(i),i.addToWindow(r)),this._watchAngularEvents(),e.run(()=>{this.taskTrackingZone=typeof Zone>"u"?null:Zone.current.get("TaskTrackingZone")})}_watchAngularEvents(){this._ngZone.onUnstable.subscribe({next:()=>{this._didWork=!0,this._isZoneStable=!1}}),this._ngZone.runOutsideAngular(()=>{this._ngZone.onStable.subscribe({next:()=>{Vt.assertNotInAngularZone(),q1(()=>{this._isZoneStable=!0,this._runCallbacksIfReady()})}})})}increasePendingRequestCount(){return this._pendingCount+=1,this._didWork=!0,this._pendingCount}decreasePendingRequestCount(){if(this._pendingCount-=1,this._pendingCount<0)throw new Error("pending async requests below zero");return this._runCallbacksIfReady(),this._pendingCount}isStable(){return this._isZoneStable&&0===this._pendingCount&&!this._ngZone.hasPendingMacrotasks}_runCallbacksIfReady(){if(this.isStable())q1(()=>{for(;0!==this._callbacks.length;){let e=this._callbacks.pop();clearTimeout(e.timeoutId),e.doneCb(this._didWork)}this._didWork=!1});else{let e=this.getPendingTasks();this._callbacks=this._callbacks.filter(r=>!r.updateCb||!r.updateCb(e)||(clearTimeout(r.timeoutId),!1)),this._didWork=!0}}getPendingTasks(){return this.taskTrackingZone?this.taskTrackingZone.macroTasks.map(e=>({source:e.source,creationLocation:e.creationLocation,data:e.data})):[]}addCallback(e,r,i){let o=-1;r&&r>0&&(o=setTimeout(()=>{this._callbacks=this._callbacks.filter(s=>s.timeoutId!==o),e(this._didWork,this.getPendingTasks())},r)),this._callbacks.push({doneCb:e,timeoutId:o,updateCb:i})}whenStable(e,r,i){if(i&&!this.taskTrackingZone)throw new Error('Task tracking zone is required when passing an update callback to whenStable(). Is "zone.js/plugins/task-tracking" loaded?');this.addCallback(e,r,i),this._runCallbacksIfReady()}getPendingRequestCount(){return this._pendingCount}registerApplication(e){this.registry.registerApplication(e,this)}unregisterApplication(e){this.registry.unregisterApplication(e)}findProviders(e,r,i){return[]}}return n.\u0275fac=function(e){return new(e||n)(Fe(Vt),Fe(Z1),Fe(Hy))},n.\u0275prov=at({token:n,factory:n.\u0275fac}),n})(),Z1=(()=>{class n{constructor(){this._applications=new Map}registerApplication(e,r){this._applications.set(e,r)}unregisterApplication(e){this._applications.delete(e)}unregisterAllApplications(){this._applications.clear()}getTestability(e){return this._applications.get(e)||null}getAllTestabilities(){return Array.from(this._applications.values())}getAllRootElements(){return Array.from(this._applications.keys())}findTestabilityInTree(e,r=!0){return Q1?.findTestabilityInTree(this,e,r)??null}}return n.\u0275fac=function(e){return new(e||n)},n.\u0275prov=at({token:n,factory:n.\u0275fac,providedIn:"platform"}),n})(),Jl=null;const yP=new Qe("AllowMultipleToken"),J1=new Qe("PlatformDestroyListeners"),eS=new Qe("appBootstrapListener");class vP{constructor(t,e){this.name=t,this.token=e}}function wP(n,t,e=[]){const r=`Platform: ${t}`,i=new Qe(r);return(o=[])=>{let s=tS();if(!s||s.injector.get(yP,!1)){const a=[...e,...o,{provide:i,useValue:!0}];n?n(a):function _Z(n){if(Jl&&!Jl.get(yP,!1))throw new ze(400,!1);(function _P(){!function C5(n){tN=n}(()=>{throw new ze(600,!1)})})(),Jl=n;const t=n.get(SP);(function xP(n){n.get(jO,null)?.forEach(e=>e())})(n)}(function TP(n=[],t){return Qi.create({name:t,providers:[{provide:AT,useValue:"platform"},{provide:J1,useValue:new Set([()=>Jl=null])},...n]})}(a,r))}return function xZ(n){const t=tS();if(!t)throw new ze(401,!1);return t}()}}function tS(){return Jl?.get(SP)??null}let SP=(()=>{class n{constructor(e){this._injector=e,this._modules=[],this._destroyListeners=[],this._destroyed=!1}bootstrapModuleFactory(e,r){const i=function wZ(n="zone.js",t){return"noop"===n?new mZ:"zone.js"===n?new Vt(t):n}(r?.ngZone,function CP(n){return{enableLongStackTrace:!1,shouldCoalesceEventChangeDetection:n?.eventCoalescing??!1,shouldCoalesceRunChangeDetection:n?.runCoalescing??!1}}({eventCoalescing:r?.ngZoneEventCoalescing,runCoalescing:r?.ngZoneRunCoalescing}));return i.run(()=>{const o=function YX(n,t,e){return new D1(n,t,e)}(e.moduleType,this.injector,function AP(n){return[{provide:Vt,useFactory:n},{provide:sf,multi:!0,useFactory:()=>{const t=It(SZ,{optional:!0});return()=>t.initialize()}},{provide:kP,useFactory:TZ},{provide:mP,useFactory:gP}]}(()=>i)),s=o.injector.get(pu,null);return i.runOutsideAngular(()=>{const a=i.onError.subscribe({next:c=>{s.handleError(c)}});o.onDestroy(()=>{Wy(this._modules,o),a.unsubscribe()})}),function IP(n,t,e){try{const r=e();return wf(r)?r.catch(i=>{throw t.runOutsideAngular(()=>n.handleError(i)),i}):r}catch(r){throw t.runOutsideAngular(()=>n.handleError(r)),r}}(s,i,()=>{const a=o.injector.get(W1);return a.runInitializers(),a.donePromise.then(()=>(function HM(n){Ts(n,"Expected localeId to be defined"),"string"==typeof n&&(GM=n.toLowerCase().replace(/_/g,"-"))}(o.injector.get(ka,nh)||nh),this._moduleDoBootstrap(o),o))})})}bootstrapModule(e,r=[]){const i=EP({},r);return function bZ(n,t,e){const r=new k1(e);return Promise.resolve(r)}(0,0,e).then(o=>this.bootstrapModuleFactory(o,i))}_moduleDoBootstrap(e){const r=e.injector.get(ec);if(e._bootstrapComponents.length>0)e._bootstrapComponents.forEach(i=>r.bootstrap(i));else{if(!e.instance.ngDoBootstrap)throw new ze(-403,!1);e.instance.ngDoBootstrap(r)}this._modules.push(e)}onDestroy(e){this._destroyListeners.push(e)}get injector(){return this._injector}destroy(){if(this._destroyed)throw new ze(404,!1);this._modules.slice().forEach(r=>r.destroy()),this._destroyListeners.forEach(r=>r());const e=this._injector.get(J1,null);e&&(e.forEach(r=>r()),e.clear()),this._destroyed=!0}get destroyed(){return this._destroyed}}return n.\u0275fac=function(e){return new(e||n)(Fe(Qi))},n.\u0275prov=at({token:n,factory:n.\u0275fac,providedIn:"platform"}),n})();function EP(n,t){return Array.isArray(t)?t.reduce(EP,n):{...n,...t}}let ec=(()=>{class n{constructor(){this._bootstrapListeners=[],this._runningTick=!1,this._destroyed=!1,this._destroyListeners=[],this._views=[],this.internalErrorHandler=It(kP),this.componentTypes=[],this.components=[],this.isStable=It(mP),this._injector=It(ul)}get destroyed(){return this._destroyed}get injector(){return this._injector}bootstrap(e,r){const i=e instanceof XO;if(!this._injector.get(W1).done)throw!i&&function xd(n){const t=On(n)||Xi(n)||Ro(n);return null!==t&&t.standalone}(e),new ze(405,!1);let s;s=i?e:this._injector.get(du).resolveComponentFactory(e),this.componentTypes.push(s.componentType);const a=function yZ(n){return n.isBoundToModule}(s)?void 0:this._injector.get(rh),u=s.create(Qi.NULL,[],r||s.selector,a),p=u.location.nativeElement,m=u.injector.get(bP,null);return m?.registerApplication(p),u.onDestroy(()=>{this.detachView(u.hostView),Wy(this.components,u),m?.unregisterApplication(p)}),this._loadComponent(u),u}tick(){if(this._runningTick)throw new ze(101,!1);try{this._runningTick=!0;for(let e of this._views)e.detectChanges()}catch(e){this.internalErrorHandler(e)}finally{this._runningTick=!1}}attachView(e){const r=e;this._views.push(r),r.attachToAppRef(this)}detachView(e){const r=e;Wy(this._views,r),r.detachFromAppRef()}_loadComponent(e){this.attachView(e.hostView),this.tick(),this.components.push(e);const r=this._injector.get(eS,[]);r.push(...this._bootstrapListeners),r.forEach(i=>i(e))}ngOnDestroy(){if(!this._destroyed)try{this._destroyListeners.forEach(e=>e()),this._views.slice().forEach(e=>e.destroy())}finally{this._destroyed=!0,this._views=[],this._bootstrapListeners=[],this._destroyListeners=[]}}onDestroy(e){return this._destroyListeners.push(e),()=>Wy(this._destroyListeners,e)}destroy(){if(this._destroyed)throw new ze(406,!1);const e=this._injector;e.destroy&&!e.destroyed&&e.destroy()}get viewCount(){return this._views.length}warnIfDestroyed(){}}return n.\u0275fac=function(e){return new(e||n)},n.\u0275prov=at({token:n,factory:n.\u0275fac,providedIn:"root"}),n})();function Wy(n,t){const e=n.indexOf(t);e>-1&&n.splice(e,1)}const kP=new Qe("",{providedIn:"root",factory:()=>It(pu).handleError.bind(void 0)});function TZ(){const n=It(Vt),t=It(pu);return e=>n.runOutsideAngular(()=>t.handleError(e))}let SZ=(()=>{class n{constructor(){this.zone=It(Vt),this.applicationRef=It(ec)}initialize(){this._onMicrotaskEmptySubscription||(this._onMicrotaskEmptySubscription=this.zone.onMicrotaskEmpty.subscribe({next:()=>{this.zone.run(()=>{this.applicationRef.tick()})}}))}ngOnDestroy(){this._onMicrotaskEmptySubscription?.unsubscribe()}}return n.\u0275fac=function(e){return new(e||n)},n.\u0275prov=at({token:n,factory:n.\u0275fac,providedIn:"root"}),n})();let Vi=(()=>{class n{}return n.__NG_ELEMENT_ID__=IZ,n})();function IZ(n){return function EZ(n,t,e){if(ou(n)&&!e){const r=Fo(n.index,t);return new ff(r,r)}return 47&n.type?new ff(t[Wr],t):null}(Li(),qe(),16==(16&n))}class MP{constructor(){}supports(t){return Dy(t)}create(t){return new RZ(t)}}const OZ=(n,t)=>t;class RZ{constructor(t){this.length=0,this._linkedRecords=null,this._unlinkedRecords=null,this._previousItHead=null,this._itHead=null,this._itTail=null,this._additionsHead=null,this._additionsTail=null,this._movesHead=null,this._movesTail=null,this._removalsHead=null,this._removalsTail=null,this._identityChangesHead=null,this._identityChangesTail=null,this._trackByFn=t||OZ}forEachItem(t){let e;for(e=this._itHead;null!==e;e=e._next)t(e)}forEachOperation(t){let e=this._itHead,r=this._removalsHead,i=0,o=null;for(;e||r;){const s=!r||e&&e.currentIndex<PP(r,i,o)?e:r,a=PP(s,i,o),c=s.currentIndex;if(s===r)i--,r=r._nextRemoved;else if(e=e._next,null==s.previousIndex)i++;else{o||(o=[]);const u=a-i,p=c-i;if(u!=p){for(let g=0;g<u;g++){const _=g<o.length?o[g]:o[g]=0,x=_+g;p<=x&&x<u&&(o[g]=_+1)}o[s.previousIndex]=p-u}}a!==c&&t(s,a,c)}}forEachPreviousItem(t){let e;for(e=this._previousItHead;null!==e;e=e._nextPrevious)t(e)}forEachAddedItem(t){let e;for(e=this._additionsHead;null!==e;e=e._nextAdded)t(e)}forEachMovedItem(t){let e;for(e=this._movesHead;null!==e;e=e._nextMoved)t(e)}forEachRemovedItem(t){let e;for(e=this._removalsHead;null!==e;e=e._nextRemoved)t(e)}forEachIdentityChange(t){let e;for(e=this._identityChangesHead;null!==e;e=e._nextIdentityChange)t(e)}diff(t){if(null==t&&(t=[]),!Dy(t))throw new ze(900,!1);return this.check(t)?this:null}onDestroy(){}check(t){this._reset();let i,o,s,e=this._itHead,r=!1;if(Array.isArray(t)){this.length=t.length;for(let a=0;a<this.length;a++)o=t[a],s=this._trackByFn(a,o),null!==e&&Object.is(e.trackById,s)?(r&&(e=this._verifyReinsertion(e,o,s,a)),Object.is(e.item,o)||this._addIdentityChange(e,o)):(e=this._mismatch(e,o,s,a),r=!0),e=e._next}else i=0,function O9(n,t){if(Array.isArray(n))for(let e=0;e<n.length;e++)t(n[e]);else{const e=n[Symbol.iterator]();let r;for(;!(r=e.next()).done;)t(r.value)}}(t,a=>{s=this._trackByFn(i,a),null!==e&&Object.is(e.trackById,s)?(r&&(e=this._verifyReinsertion(e,a,s,i)),Object.is(e.item,a)||this._addIdentityChange(e,a)):(e=this._mismatch(e,a,s,i),r=!0),e=e._next,i++}),this.length=i;return this._truncate(e),this.collection=t,this.isDirty}get isDirty(){return null!==this._additionsHead||null!==this._movesHead||null!==this._removalsHead||null!==this._identityChangesHead}_reset(){if(this.isDirty){let t;for(t=this._previousItHead=this._itHead;null!==t;t=t._next)t._nextPrevious=t._next;for(t=this._additionsHead;null!==t;t=t._nextAdded)t.previousIndex=t.currentIndex;for(this._additionsHead=this._additionsTail=null,t=this._movesHead;null!==t;t=t._nextMoved)t.previousIndex=t.currentIndex;this._movesHead=this._movesTail=null,this._removalsHead=this._removalsTail=null,this._identityChangesHead=this._identityChangesTail=null}}_mismatch(t,e,r,i){let o;return null===t?o=this._itTail:(o=t._prev,this._remove(t)),null!==(t=null===this._unlinkedRecords?null:this._unlinkedRecords.get(r,null))?(Object.is(t.item,e)||this._addIdentityChange(t,e),this._reinsertAfter(t,o,i)):null!==(t=null===this._linkedRecords?null:this._linkedRecords.get(r,i))?(Object.is(t.item,e)||this._addIdentityChange(t,e),this._moveAfter(t,o,i)):t=this._addAfter(new MZ(e,r),o,i),t}_verifyReinsertion(t,e,r,i){let o=null===this._unlinkedRecords?null:this._unlinkedRecords.get(r,null);return null!==o?t=this._reinsertAfter(o,t._prev,i):t.currentIndex!=i&&(t.currentIndex=i,this._addToMoves(t,i)),t}_truncate(t){for(;null!==t;){const e=t._next;this._addToRemovals(this._unlink(t)),t=e}null!==this._unlinkedRecords&&this._unlinkedRecords.clear(),null!==this._additionsTail&&(this._additionsTail._nextAdded=null),null!==this._movesTail&&(this._movesTail._nextMoved=null),null!==this._itTail&&(this._itTail._next=null),null!==this._removalsTail&&(this._removalsTail._nextRemoved=null),null!==this._identityChangesTail&&(this._identityChangesTail._nextIdentityChange=null)}_reinsertAfter(t,e,r){null!==this._unlinkedRecords&&this._unlinkedRecords.remove(t);const i=t._prevRemoved,o=t._nextRemoved;return null===i?this._removalsHead=o:i._nextRemoved=o,null===o?this._removalsTail=i:o._prevRemoved=i,this._insertAfter(t,e,r),this._addToMoves(t,r),t}_moveAfter(t,e,r){return this._unlink(t),this._insertAfter(t,e,r),this._addToMoves(t,r),t}_addAfter(t,e,r){return this._insertAfter(t,e,r),this._additionsTail=null===this._additionsTail?this._additionsHead=t:this._additionsTail._nextAdded=t,t}_insertAfter(t,e,r){const i=null===e?this._itHead:e._next;return t._next=i,t._prev=e,null===i?this._itTail=t:i._prev=t,null===e?this._itHead=t:e._next=t,null===this._linkedRecords&&(this._linkedRecords=new FP),this._linkedRecords.put(t),t.currentIndex=r,t}_remove(t){return this._addToRemovals(this._unlink(t))}_unlink(t){null!==this._linkedRecords&&this._linkedRecords.remove(t);const e=t._prev,r=t._next;return null===e?this._itHead=r:e._next=r,null===r?this._itTail=e:r._prev=e,t}_addToMoves(t,e){return t.previousIndex===e||(this._movesTail=null===this._movesTail?this._movesHead=t:this._movesTail._nextMoved=t),t}_addToRemovals(t){return null===this._unlinkedRecords&&(this._unlinkedRecords=new FP),this._unlinkedRecords.put(t),t.currentIndex=null,t._nextRemoved=null,null===this._removalsTail?(this._removalsTail=this._removalsHead=t,t._prevRemoved=null):(t._prevRemoved=this._removalsTail,this._removalsTail=this._removalsTail._nextRemoved=t),t}_addIdentityChange(t,e){return t.item=e,this._identityChangesTail=null===this._identityChangesTail?this._identityChangesHead=t:this._identityChangesTail._nextIdentityChange=t,t}}class MZ{constructor(t,e){this.item=t,this.trackById=e,this.currentIndex=null,this.previousIndex=null,this._nextPrevious=null,this._prev=null,this._next=null,this._prevDup=null,this._nextDup=null,this._prevRemoved=null,this._nextRemoved=null,this._nextAdded=null,this._nextMoved=null,this._nextIdentityChange=null}}class FZ{constructor(){this._head=null,this._tail=null}add(t){null===this._head?(this._head=this._tail=t,t._nextDup=null,t._prevDup=null):(this._tail._nextDup=t,t._prevDup=this._tail,t._nextDup=null,this._tail=t)}get(t,e){let r;for(r=this._head;null!==r;r=r._nextDup)if((null===e||e<=r.currentIndex)&&Object.is(r.trackById,t))return r;return null}remove(t){const e=t._prevDup,r=t._nextDup;return null===e?this._head=r:e._nextDup=r,null===r?this._tail=e:r._prevDup=e,null===this._head}}class FP{constructor(){this.map=new Map}put(t){const e=t.trackById;let r=this.map.get(e);r||(r=new FZ,this.map.set(e,r)),r.add(t)}get(t,e){const i=this.map.get(t);return i?i.get(t,e):null}remove(t){const e=t.trackById;return this.map.get(e).remove(t)&&this.map.delete(e),t}get isEmpty(){return 0===this.map.size}clear(){this.map.clear()}}function PP(n,t,e){const r=n.previousIndex;if(null===r)return r;let i=0;return e&&r<e.length&&(i=e[r]),r+t+i}class $P{constructor(){}supports(t){return t instanceof Map||l1(t)}create(){return new PZ}}class PZ{constructor(){this._records=new Map,this._mapHead=null,this._appendAfter=null,this._previousMapHead=null,this._changesHead=null,this._changesTail=null,this._additionsHead=null,this._additionsTail=null,this._removalsHead=null,this._removalsTail=null}get isDirty(){return null!==this._additionsHead||null!==this._changesHead||null!==this._removalsHead}forEachItem(t){let e;for(e=this._mapHead;null!==e;e=e._next)t(e)}forEachPreviousItem(t){let e;for(e=this._previousMapHead;null!==e;e=e._nextPrevious)t(e)}forEachChangedItem(t){let e;for(e=this._changesHead;null!==e;e=e._nextChanged)t(e)}forEachAddedItem(t){let e;for(e=this._additionsHead;null!==e;e=e._nextAdded)t(e)}forEachRemovedItem(t){let e;for(e=this._removalsHead;null!==e;e=e._nextRemoved)t(e)}diff(t){if(t){if(!(t instanceof Map||l1(t)))throw new ze(900,!1)}else t=new Map;return this.check(t)?this:null}onDestroy(){}check(t){this._reset();let e=this._mapHead;if(this._appendAfter=null,this._forEach(t,(r,i)=>{if(e&&e.key===i)this._maybeAddToChanges(e,r),this._appendAfter=e,e=e._next;else{const o=this._getOrCreateRecordForKey(i,r);e=this._insertBeforeOrAppend(e,o)}}),e){e._prev&&(e._prev._next=null),this._removalsHead=e;for(let r=e;null!==r;r=r._nextRemoved)r===this._mapHead&&(this._mapHead=null),this._records.delete(r.key),r._nextRemoved=r._next,r.previousValue=r.currentValue,r.currentValue=null,r._prev=null,r._next=null}return this._changesTail&&(this._changesTail._nextChanged=null),this._additionsTail&&(this._additionsTail._nextAdded=null),this.isDirty}_insertBeforeOrAppend(t,e){if(t){const r=t._prev;return e._next=t,e._prev=r,t._prev=e,r&&(r._next=e),t===this._mapHead&&(this._mapHead=e),this._appendAfter=t,t}return this._appendAfter?(this._appendAfter._next=e,e._prev=this._appendAfter):this._mapHead=e,this._appendAfter=e,null}_getOrCreateRecordForKey(t,e){if(this._records.has(t)){const i=this._records.get(t);this._maybeAddToChanges(i,e);const o=i._prev,s=i._next;return o&&(o._next=s),s&&(s._prev=o),i._next=null,i._prev=null,i}const r=new $Z(t);return this._records.set(t,r),r.currentValue=e,this._addToAdditions(r),r}_reset(){if(this.isDirty){let t;for(this._previousMapHead=this._mapHead,t=this._previousMapHead;null!==t;t=t._next)t._nextPrevious=t._next;for(t=this._changesHead;null!==t;t=t._nextChanged)t.previousValue=t.currentValue;for(t=this._additionsHead;null!=t;t=t._nextAdded)t.previousValue=t.currentValue;this._changesHead=this._changesTail=null,this._additionsHead=this._additionsTail=null,this._removalsHead=null}}_maybeAddToChanges(t,e){Object.is(e,t.currentValue)||(t.previousValue=t.currentValue,t.currentValue=e,this._addToChanges(t))}_addToAdditions(t){null===this._additionsHead?this._additionsHead=this._additionsTail=t:(this._additionsTail._nextAdded=t,this._additionsTail=t)}_addToChanges(t){null===this._changesHead?this._changesHead=this._changesTail=t:(this._changesTail._nextChanged=t,this._changesTail=t)}_forEach(t,e){t instanceof Map?t.forEach(e):Object.keys(t).forEach(r=>e(t[r],r))}}class $Z{constructor(t){this.key=t,this.previousValue=null,this.currentValue=null,this._nextPrevious=null,this._next=null,this._prev=null,this._nextAdded=null,this._nextRemoved=null,this._nextChanged=null}}function LP(){return new Xy([new MP])}let Xy=(()=>{class n{constructor(e){this.factories=e}static create(e,r){if(null!=r){const i=r.factories.slice();e=e.concat(i)}return new n(e)}static extend(e){return{provide:n,useFactory:r=>n.create(e,r||LP()),deps:[[n,new ty,new ey]]}}find(e){const r=this.factories.find(i=>i.supports(e));if(null!=r)return r;throw new ze(901,!1)}}return n.\u0275prov=at({token:n,providedIn:"root",factory:LP}),n})();function BP(){return new Pf([new $P])}let Pf=(()=>{class n{constructor(e){this.factories=e}static create(e,r){if(r){const i=r.factories.slice();e=e.concat(i)}return new n(e)}static extend(e){return{provide:n,useFactory:r=>n.create(e,r||BP()),deps:[[n,new ty,new ey]]}}find(e){const r=this.factories.find(i=>i.supports(e));if(r)return r;throw new ze(901,!1)}}return n.\u0275prov=at({token:n,providedIn:"root",factory:BP}),n})();const VZ=wP(null,"core",[]);let zZ=(()=>{class n{constructor(e){}}return n.\u0275fac=function(e){return new(e||n)(Fe(ec))},n.\u0275mod=Vn({type:n}),n.\u0275inj=Pn({}),n})(),HP=(()=>{class n{get whenAllTasksComplete(){return 0===this.collection.size&&this.complete(),this.promise}constructor(){this.taskId=0,this.collection=new Set,this.ngZone=It(Vt),this.completed=!1,this.ngZone.runOutsideAngular(()=>{this.promise=new Promise(e=>{this.resolve=e})})}add(){if(this.completed)return-1;const e=this.taskId++;return this.collection.add(e),e}remove(e){this.completed||(this.collection.delete(e),0===this.collection.size&&this.complete())}ngOnDestroy(){this.complete(),this.collection.clear()}complete(){this.completed=!0,this.resolve()}}return n.\u0275fac=function(e){return new(e||n)},n.\u0275prov=at({token:n,factory:n.\u0275fac,providedIn:"root"}),n})();let lS=null;function tc(){return lS}class JZ{}const Tn=new Qe("DocumentToken");let cS=(()=>{class n{historyGo(e){throw new Error("Not implemented")}}return n.\u0275fac=function(e){return new(e||n)},n.\u0275prov=at({token:n,factory:function(){return function eQ(){return Fe(qP)}()},providedIn:"platform"}),n})();const tQ=new Qe("Location Initialized");let qP=(()=>{class n extends cS{constructor(e){super(),this._doc=e,this._location=window.location,this._history=window.history}getBaseHrefFromDOM(){return tc().getBaseHref(this._doc)}onPopState(e){const r=tc().getGlobalEventTarget(this._doc,"window");return r.addEventListener("popstate",e,!1),()=>r.removeEventListener("popstate",e)}onHashChange(e){const r=tc().getGlobalEventTarget(this._doc,"window");return r.addEventListener("hashchange",e,!1),()=>r.removeEventListener("hashchange",e)}get href(){return this._location.href}get protocol(){return this._location.protocol}get hostname(){return this._location.hostname}get port(){return this._location.port}get pathname(){return this._location.pathname}get search(){return this._location.search}get hash(){return this._location.hash}set pathname(e){this._location.pathname=e}pushState(e,r,i){KP()?this._history.pushState(e,r,i):this._location.hash=i}replaceState(e,r,i){KP()?this._history.replaceState(e,r,i):this._location.hash=i}forward(){this._history.forward()}back(){this._history.back()}historyGo(e=0){this._history.go(e)}getState(){return this._history.state}}return n.\u0275fac=function(e){return new(e||n)(Fe(Tn))},n.\u0275prov=at({token:n,factory:function(){return function nQ(){return new qP(Fe(Tn))}()},providedIn:"platform"}),n})();function KP(){return!!window.history.pushState}function uS(n,t){if(0==n.length)return t;if(0==t.length)return n;let e=0;return n.endsWith("/")&&e++,t.startsWith("/")&&e++,2==e?n+t.substring(1):1==e?n+t:n+"/"+t}function XP(n){const t=n.match(/#|\?|$/),e=t&&t.index||n.length;return n.slice(0,e-("/"===n[e-1]?1:0))+n.slice(e)}function ml(n){return n&&"?"!==n[0]?"?"+n:n}let yu=(()=>{class n{historyGo(e){throw new Error("Not implemented")}}return n.\u0275fac=function(e){return new(e||n)},n.\u0275prov=at({token:n,factory:function(){return It(ZP)},providedIn:"root"}),n})();const YP=new Qe("appBaseHref");let ZP=(()=>{class n extends yu{constructor(e,r){super(),this._platformLocation=e,this._removeListenerFns=[],this._baseHref=r??this._platformLocation.getBaseHrefFromDOM()??It(Tn).location?.origin??""}ngOnDestroy(){for(;this._removeListenerFns.length;)this._removeListenerFns.pop()()}onPopState(e){this._removeListenerFns.push(this._platformLocation.onPopState(e),this._platformLocation.onHashChange(e))}getBaseHref(){return this._baseHref}prepareExternalUrl(e){return uS(this._baseHref,e)}path(e=!1){const r=this._platformLocation.pathname+ml(this._platformLocation.search),i=this._platformLocation.hash;return i&&e?`${r}${i}`:r}pushState(e,r,i,o){const s=this.prepareExternalUrl(i+ml(o));this._platformLocation.pushState(e,r,s)}replaceState(e,r,i,o){const s=this.prepareExternalUrl(i+ml(o));this._platformLocation.replaceState(e,r,s)}forward(){this._platformLocation.forward()}back(){this._platformLocation.back()}getState(){return this._platformLocation.getState()}historyGo(e=0){this._platformLocation.historyGo?.(e)}}return n.\u0275fac=function(e){return new(e||n)(Fe(cS),Fe(YP,8))},n.\u0275prov=at({token:n,factory:n.\u0275fac,providedIn:"root"}),n})(),rQ=(()=>{class n extends yu{constructor(e,r){super(),this._platformLocation=e,this._baseHref="",this._removeListenerFns=[],null!=r&&(this._baseHref=r)}ngOnDestroy(){for(;this._removeListenerFns.length;)this._removeListenerFns.pop()()}onPopState(e){this._removeListenerFns.push(this._platformLocation.onPopState(e),this._platformLocation.onHashChange(e))}getBaseHref(){return this._baseHref}path(e=!1){let r=this._platformLocation.hash;return null==r&&(r="#"),r.length>0?r.substring(1):r}prepareExternalUrl(e){const r=uS(this._baseHref,e);return r.length>0?"#"+r:r}pushState(e,r,i,o){let s=this.prepareExternalUrl(i+ml(o));0==s.length&&(s=this._platformLocation.pathname),this._platformLocation.pushState(e,r,s)}replaceState(e,r,i,o){let s=this.prepareExternalUrl(i+ml(o));0==s.length&&(s=this._platformLocation.pathname),this._platformLocation.replaceState(e,r,s)}forward(){this._platformLocation.forward()}back(){this._platformLocation.back()}getState(){return this._platformLocation.getState()}historyGo(e=0){this._platformLocation.historyGo?.(e)}}return n.\u0275fac=function(e){return new(e||n)(Fe(cS),Fe(YP,8))},n.\u0275prov=at({token:n,factory:n.\u0275fac}),n})(),$f=(()=>{class n{constructor(e){this._subject=new rn,this._urlChangeListeners=[],this._urlChangeSubscription=null,this._locationStrategy=e;const r=this._locationStrategy.getBaseHref();this._basePath=function sQ(n){if(new RegExp("^(https?:)?//").test(n)){const[,e]=n.split(/\/\/[^\/]+/);return e}return n}(XP(QP(r))),this._locationStrategy.onPopState(i=>{this._subject.emit({url:this.path(!0),pop:!0,state:i.state,type:i.type})})}ngOnDestroy(){this._urlChangeSubscription?.unsubscribe(),this._urlChangeListeners=[]}path(e=!1){return this.normalize(this._locationStrategy.path(e))}getState(){return this._locationStrategy.getState()}isCurrentPathEqualTo(e,r=""){return this.path()==this.normalize(e+ml(r))}normalize(e){return n.stripTrailingSlash(function oQ(n,t){if(!n||!t.startsWith(n))return t;const e=t.substring(n.length);return""===e||["/",";","?","#"].includes(e[0])?e:t}(this._basePath,QP(e)))}prepareExternalUrl(e){return e&&"/"!==e[0]&&(e="/"+e),this._locationStrategy.prepareExternalUrl(e)}go(e,r="",i=null){this._locationStrategy.pushState(i,"",e,r),this._notifyUrlChangeListeners(this.prepareExternalUrl(e+ml(r)),i)}replaceState(e,r="",i=null){this._locationStrategy.replaceState(i,"",e,r),this._notifyUrlChangeListeners(this.prepareExternalUrl(e+ml(r)),i)}forward(){this._locationStrategy.forward()}back(){this._locationStrategy.back()}historyGo(e=0){this._locationStrategy.historyGo?.(e)}onUrlChange(e){return this._urlChangeListeners.push(e),this._urlChangeSubscription||(this._urlChangeSubscription=this.subscribe(r=>{this._notifyUrlChangeListeners(r.url,r.state)})),()=>{const r=this._urlChangeListeners.indexOf(e);this._urlChangeListeners.splice(r,1),0===this._urlChangeListeners.length&&(this._urlChangeSubscription?.unsubscribe(),this._urlChangeSubscription=null)}}_notifyUrlChangeListeners(e="",r){this._urlChangeListeners.forEach(i=>i(e,r))}subscribe(e,r,i){return this._subject.subscribe({next:e,error:r,complete:i})}}return n.normalizeQueryParams=ml,n.joinWithSlash=uS,n.stripTrailingSlash=XP,n.\u0275fac=function(e){return new(e||n)(Fe(yu))},n.\u0275prov=at({token:n,factory:function(){return function iQ(){return new $f(Fe(yu))}()},providedIn:"root"}),n})();function QP(n){return n.replace(/\/index.html$/,"")}var Lo=(()=>((Lo=Lo||{})[Lo.Decimal=0]="Decimal",Lo[Lo.Percent=1]="Percent",Lo[Lo.Currency=2]="Currency",Lo[Lo.Scientific=3]="Scientific",Lo))(),Lt=(()=>((Lt=Lt||{})[Lt.Decimal=0]="Decimal",Lt[Lt.Group=1]="Group",Lt[Lt.List=2]="List",Lt[Lt.PercentSign=3]="PercentSign",Lt[Lt.PlusSign=4]="PlusSign",Lt[Lt.MinusSign=5]="MinusSign",Lt[Lt.Exponential=6]="Exponential",Lt[Lt.SuperscriptingExponent=7]="SuperscriptingExponent",Lt[Lt.PerMille=8]="PerMille",Lt[Lt.Infinity=9]="Infinity",Lt[Lt.NaN=10]="NaN",Lt[Lt.TimeSeparator=11]="TimeSeparator",Lt[Lt.CurrencyDecimal=12]="CurrencyDecimal",Lt[Lt.CurrencyGroup=13]="CurrencyGroup",Lt))();function Is(n,t){const e=go(n),r=e[gt.NumberSymbols][t];if(typeof r>"u"){if(t===Lt.CurrencyDecimal)return e[gt.NumberSymbols][Lt.Decimal];if(t===Lt.CurrencyGroup)return e[gt.NumberSymbols][Lt.Group]}return r}const OQ=/^(\d+)?\.((\d+)(-(\d+))?)?$/;function yS(n){const t=parseInt(n);if(isNaN(t))throw new Error("Invalid integer literal when parsing "+n);return t}const vS=/\s+/,a$=[];let s_=(()=>{class n{constructor(e,r,i,o){this._iterableDiffers=e,this._keyValueDiffers=r,this._ngEl=i,this._renderer=o,this.initialClasses=a$,this.stateMap=new Map}set klass(e){this.initialClasses=null!=e?e.trim().split(vS):a$}set ngClass(e){this.rawClass="string"==typeof e?e.trim().split(vS):e}ngDoCheck(){for(const r of this.initialClasses)this._updateState(r,!0);const e=this.rawClass;if(Array.isArray(e)||e instanceof Set)for(const r of e)this._updateState(r,!0);else if(null!=e)for(const r of Object.keys(e))this._updateState(r,!!e[r]);this._applyStateDiff()}_updateState(e,r){const i=this.stateMap.get(e);void 0!==i?(i.enabled!==r&&(i.changed=!0,i.enabled=r),i.touched=!0):this.stateMap.set(e,{enabled:r,changed:!0,touched:!0})}_applyStateDiff(){for(const e of this.stateMap){const r=e[0],i=e[1];i.changed?(this._toggleClass(r,i.enabled),i.changed=!1):i.touched||(i.enabled&&this._toggleClass(r,!1),this.stateMap.delete(r)),i.touched=!1}}_toggleClass(e,r){(e=e.trim()).length>0&&e.split(vS).forEach(i=>{r?this._renderer.addClass(this._ngEl.nativeElement,i):this._renderer.removeClass(this._ngEl.nativeElement,i)})}}return n.\u0275fac=function(e){return new(e||n)(de(Xy),de(Pf),de(yn),de(dl))},n.\u0275dir=_t({type:n,selectors:[["","ngClass",""]],inputs:{klass:["class","klass"],ngClass:"ngClass"},standalone:!0}),n})();class HQ{constructor(t,e,r,i){this.$implicit=t,this.ngForOf=e,this.index=r,this.count=i}get first(){return 0===this.index}get last(){return this.index===this.count-1}get even(){return this.index%2==0}get odd(){return!this.even}}let a_=(()=>{class n{set ngForOf(e){this._ngForOf=e,this._ngForOfDirty=!0}set ngForTrackBy(e){this._trackByFn=e}get ngForTrackBy(){return this._trackByFn}constructor(e,r,i){this._viewContainer=e,this._template=r,this._differs=i,this._ngForOf=null,this._ngForOfDirty=!0,this._differ=null}set ngForTemplate(e){e&&(this._template=e)}ngDoCheck(){if(this._ngForOfDirty){this._ngForOfDirty=!1;const e=this._ngForOf;!this._differ&&e&&(this._differ=this._differs.find(e).create(this.ngForTrackBy))}if(this._differ){const e=this._differ.diff(this._ngForOf);e&&this._applyChanges(e)}}_applyChanges(e){const r=this._viewContainer;e.forEachOperation((i,o,s)=>{if(null==i.previousIndex)r.createEmbeddedView(this._template,new HQ(i.item,this._ngForOf,-1,-1),null===s?void 0:s);else if(null==s)r.remove(null===o?void 0:o);else if(null!==o){const a=r.get(o);r.move(a,s),c$(a,i)}});for(let i=0,o=r.length;i<o;i++){const a=r.get(i).context;a.index=i,a.count=o,a.ngForOf=this._ngForOf}e.forEachIdentityChange(i=>{c$(r.get(i.currentIndex),i)})}static ngTemplateContextGuard(e,r){return!0}}return n.\u0275fac=function(e){return new(e||n)(de(eo),de(_o),de(Xy))},n.\u0275dir=_t({type:n,selectors:[["","ngFor","","ngForOf",""]],inputs:{ngForOf:"ngForOf",ngForTrackBy:"ngForTrackBy",ngForTemplate:"ngForTemplate"},standalone:!0}),n})();function c$(n,t){n.context.$implicit=t.item}let nc=(()=>{class n{constructor(e,r){this._viewContainer=e,this._context=new WQ,this._thenTemplateRef=null,this._elseTemplateRef=null,this._thenViewRef=null,this._elseViewRef=null,this._thenTemplateRef=r}set ngIf(e){this._context.$implicit=this._context.ngIf=e,this._updateView()}set ngIfThen(e){u$("ngIfThen",e),this._thenTemplateRef=e,this._thenViewRef=null,this._updateView()}set ngIfElse(e){u$("ngIfElse",e),this._elseTemplateRef=e,this._elseViewRef=null,this._updateView()}_updateView(){this._context.$implicit?this._thenViewRef||(this._viewContainer.clear(),this._elseViewRef=null,this._thenTemplateRef&&(this._thenViewRef=this._viewContainer.createEmbeddedView(this._thenTemplateRef,this._context))):this._elseViewRef||(this._viewContainer.clear(),this._thenViewRef=null,this._elseTemplateRef&&(this._elseViewRef=this._viewContainer.createEmbeddedView(this._elseTemplateRef,this._context)))}static ngTemplateContextGuard(e,r){return!0}}return n.\u0275fac=function(e){return new(e||n)(de(eo),de(_o))},n.\u0275dir=_t({type:n,selectors:[["","ngIf",""]],inputs:{ngIf:"ngIf",ngIfThen:"ngIfThen",ngIfElse:"ngIfElse"},standalone:!0}),n})();class WQ{constructor(){this.$implicit=null,this.ngIf=null}}function u$(n,t){if(t&&!t.createEmbeddedView)throw new Error(`${n} must be a TemplateRef, but received '${Er(t)}'.`)}let l_=(()=>{class n{constructor(e){this._locale=e}transform(e,r,i){if(!function TS(n){return!(null==n||""===n||n!=n)}(e))return null;i=i||this._locale;try{return function LQ(n,t,e){return function gS(n,t,e,r,i,o,s=!1){let a="",c=!1;if(isFinite(n)){let u=function VQ(n){let r,i,o,s,a,t=Math.abs(n)+"",e=0;for((i=t.indexOf("."))>-1&&(t=t.replace(".","")),(o=t.search(/e/i))>0?(i<0&&(i=o),i+=+t.slice(o+1),t=t.substring(0,o)):i<0&&(i=t.length),o=0;"0"===t.charAt(o);o++);if(o===(a=t.length))r=[0],i=1;else{for(a--;"0"===t.charAt(a);)a--;for(i-=o,r=[],s=0;o<=a;o++,s++)r[s]=Number(t.charAt(o))}return i>22&&(r=r.splice(0,21),e=i-1,i=1),{digits:r,exponent:e,integerLen:i}}(n);s&&(u=function BQ(n){if(0===n.digits[0])return n;const t=n.digits.length-n.integerLen;return n.exponent?n.exponent+=2:(0===t?n.digits.push(0,0):1===t&&n.digits.push(0),n.integerLen+=2),n}(u));let p=t.minInt,m=t.minFrac,g=t.maxFrac;if(o){const R=o.match(OQ);if(null===R)throw new Error(`${o} is not a valid digit info`);const L=R[1],V=R[3],j=R[5];null!=L&&(p=yS(L)),null!=V&&(m=yS(V)),null!=j?g=yS(j):null!=V&&m>g&&(g=m)}!function zQ(n,t,e){if(t>e)throw new Error(`The minimum number of digits after fraction (${t}) is higher than the maximum (${e}).`);let r=n.digits,i=r.length-n.integerLen;const o=Math.min(Math.max(t,i),e);let s=o+n.integerLen,a=r[s];if(s>0){r.splice(Math.max(n.integerLen,s));for(let m=s;m<r.length;m++)r[m]=0}else{i=Math.max(0,i),n.integerLen=1,r.length=Math.max(1,s=o+1),r[0]=0;for(let m=1;m<s;m++)r[m]=0}if(a>=5)if(s-1<0){for(let m=0;m>s;m--)r.unshift(0),n.integerLen++;r.unshift(1),n.integerLen++}else r[s-1]++;for(;i<Math.max(0,o);i++)r.push(0);let c=0!==o;const u=t+n.integerLen,p=r.reduceRight(function(m,g,_,x){return x[_]=(g+=m)<10?g:g-10,c&&(0===x[_]&&_>=u?x.pop():c=!1),g>=10?1:0},0);p&&(r.unshift(p),n.integerLen++)}(u,m,g);let _=u.digits,x=u.integerLen;const T=u.exponent;let I=[];for(c=_.every(R=>!R);x<p;x++)_.unshift(0);for(;x<0;x++)_.unshift(0);x>0?I=_.splice(x,_.length):(I=_,_=[0]);const N=[];for(_.length>=t.lgSize&&N.unshift(_.splice(-t.lgSize,_.length).join(""));_.length>t.gSize;)N.unshift(_.splice(-t.gSize,_.length).join(""));_.length&&N.unshift(_.join("")),a=N.join(Is(e,r)),I.length&&(a+=Is(e,i)+I.join("")),T&&(a+=Is(e,Lt.Exponential)+"+"+T)}else a=Is(e,Lt.Infinity);return a=n<0&&!c?t.negPre+a+t.negSuf:t.posPre+a+t.posSuf,a}(n,function bS(n,t="-"){const e={minInt:1,minFrac:0,maxFrac:0,posPre:"",posSuf:"",negPre:"",negSuf:"",gSize:0,lgSize:0},r=n.split(";"),i=r[0],o=r[1],s=-1!==i.indexOf(".")?i.split("."):[i.substring(0,i.lastIndexOf("0")+1),i.substring(i.lastIndexOf("0")+1)],a=s[0],c=s[1]||"";e.posPre=a.substring(0,a.indexOf("#"));for(let p=0;p<c.length;p++){const m=c.charAt(p);"0"===m?e.minFrac=e.maxFrac=p+1:"#"===m?e.maxFrac=p+1:e.posSuf+=m}const u=a.split(",");if(e.gSize=u[1]?u[1].length:0,e.lgSize=u[2]||u[1]?(u[2]||u[1]).length:0,o){const p=i.length-e.posPre.length-e.posSuf.length,m=o.indexOf("#");e.negPre=o.substring(0,m).replace(/'/g,""),e.negSuf=o.slice(m+p).replace(/'/g,"")}else e.negPre=t+e.posPre,e.negSuf=e.posSuf;return e}(function dS(n,t){return go(n)[gt.NumberFormats][t]}(t,Lo.Decimal),Is(t,Lt.MinusSign)),t,Lt.Group,Lt.Decimal,e)}(function SS(n){if("string"==typeof n&&!isNaN(Number(n)-parseFloat(n)))return Number(n);if("number"!=typeof n)throw new Error(`${n} is not a number`);return n}(e),i,r)}catch(o){throw function ia(n,t){return new ze(2100,!1)}()}}}return n.\u0275fac=function(e){return new(e||n)(de(ka,16))},n.\u0275pipe=Oo({name:"number",type:n,pure:!0,standalone:!0}),n})();let Vf=(()=>{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275mod=Vn({type:n}),n.\u0275inj=Pn({}),n})();const p$="browser";function f$(n){return"server"===n}let vJ=(()=>{class n{}return n.\u0275prov=at({token:n,providedIn:"root",factory:()=>new xJ(Fe(Tn),window)}),n})();class xJ{constructor(t,e){this.document=t,this.window=e,this.offset=()=>[0,0]}setOffset(t){this.offset=Array.isArray(t)?()=>t:t}getScrollPosition(){return this.supportsScrolling()?[this.window.pageXOffset,this.window.pageYOffset]:[0,0]}scrollToPosition(t){this.supportsScrolling()&&this.window.scrollTo(t[0],t[1])}scrollToAnchor(t){if(!this.supportsScrolling())return;const e=function wJ(n,t){const e=n.getElementById(t)||n.getElementsByName(t)[0];if(e)return e;if("function"==typeof n.createTreeWalker&&n.body&&"function"==typeof n.body.attachShadow){const r=n.createTreeWalker(n.body,NodeFilter.SHOW_ELEMENT);let i=r.currentNode;for(;i;){const o=i.shadowRoot;if(o){const s=o.getElementById(t)||o.querySelector(`[name="${t}"]`);if(s)return s}i=r.nextNode()}}return null}(this.document,t);e&&(this.scrollToElement(e),e.focus())}setHistoryScrollRestoration(t){if(this.supportScrollRestoration()){const e=this.window.history;e&&e.scrollRestoration&&(e.scrollRestoration=t)}}scrollToElement(t){const e=t.getBoundingClientRect(),r=e.left+this.window.pageXOffset,i=e.top+this.window.pageYOffset,o=this.offset();this.window.scrollTo(r-o[0],i-o[1])}supportScrollRestoration(){try{if(!this.supportsScrolling())return!1;const t=m$(this.window.history)||m$(Object.getPrototypeOf(this.window.history));return!(!t||!t.writable&&!t.set)}catch{return!1}}supportsScrolling(){try{return!!this.window&&!!this.window.scrollTo&&"pageXOffset"in this.window}catch{return!1}}}function m$(n){return Object.getOwnPropertyDescriptor(n,"scrollRestoration")}class YJ extends JZ{constructor(){super(...arguments),this.supportsDOMEvents=!0}}class ES extends YJ{static makeCurrent(){!function QZ(n){lS||(lS=n)}(new ES)}onAndCancel(t,e,r){return t.addEventListener(e,r),()=>{t.removeEventListener(e,r)}}dispatchEvent(t,e){t.dispatchEvent(e)}remove(t){t.parentNode&&t.parentNode.removeChild(t)}createElement(t,e){return(e=e||this.getDefaultDocument()).createElement(t)}createHtmlDocument(){return document.implementation.createHTMLDocument("fakeTitle")}getDefaultDocument(){return document}isElementNode(t){return t.nodeType===Node.ELEMENT_NODE}isShadowRoot(t){return t instanceof DocumentFragment}getGlobalEventTarget(t,e){return"window"===e?window:"document"===e?t:"body"===e?t.body:null}getBaseHref(t){const e=function ZJ(){return Uf=Uf||document.querySelector("base"),Uf?Uf.getAttribute("href"):null}();return null==e?null:function QJ(n){d_=d_||document.createElement("a"),d_.setAttribute("href",n);const t=d_.pathname;return"/"===t.charAt(0)?t:`/${t}`}(e)}resetBaseElement(){Uf=null}getUserAgent(){return window.navigator.userAgent}getCookie(t){return function jQ(n,t){t=encodeURIComponent(t);for(const e of n.split(";")){const r=e.indexOf("="),[i,o]=-1==r?[e,""]:[e.slice(0,r),e.slice(r+1)];if(i.trim()===t)return decodeURIComponent(o)}return null}(document.cookie,t)}}let d_,Uf=null,eee=(()=>{class n{build(){return new XMLHttpRequest}}return n.\u0275fac=function(e){return new(e||n)},n.\u0275prov=at({token:n,factory:n.\u0275fac}),n})();const DS=new Qe("EventManagerPlugins");let v$=(()=>{class n{constructor(e,r){this._zone=r,this._eventNameToPlugin=new Map,e.forEach(i=>{i.manager=this}),this._plugins=e.slice().reverse()}addEventListener(e,r,i){return this._findPluginFor(r).addEventListener(e,r,i)}getZone(){return this._zone}_findPluginFor(e){const r=this._eventNameToPlugin.get(e);if(r)return r;const i=this._plugins;for(let o=0;o<i.length;o++){const s=i[o];if(s.supports(e))return this._eventNameToPlugin.set(e,s),s}throw new Error(`No event manager plugin found for event ${e}`)}}return n.\u0275fac=function(e){return new(e||n)(Fe(DS),Fe(Vt))},n.\u0275prov=at({token:n,factory:n.\u0275fac}),n})();class x${constructor(t){this._doc=t}}const kS="ng-app-id";let w$=(()=>{class n{constructor(e,r,i,o={}){this.doc=e,this.appId=r,this.nonce=i,this.platformId=o,this.styleRef=new Map,this.hostNodes=new Set,this.styleNodesInDOM=this.collectServerRenderedStyles(),this.platformIsServer=f$(o),this.resetHostNodes()}addStyles(e){for(const r of e)1===this.changeUsageCount(r,1)&&this.onStyleAdded(r)}removeStyles(e){for(const r of e)this.changeUsageCount(r,-1)<=0&&this.onStyleRemoved(r)}ngOnDestroy(){const e=this.styleNodesInDOM;e&&(e.forEach(r=>r.remove()),e.clear());for(const r of this.getAllStyles())this.onStyleRemoved(r);this.resetHostNodes()}addHost(e){this.hostNodes.add(e);for(const r of this.getAllStyles())this.addStyleToHost(e,r)}removeHost(e){this.hostNodes.delete(e)}getAllStyles(){return this.styleRef.keys()}onStyleAdded(e){for(const r of this.hostNodes)this.addStyleToHost(r,e)}onStyleRemoved(e){const r=this.styleRef;r.get(e)?.elements?.forEach(i=>i.remove()),r.delete(e)}collectServerRenderedStyles(){const e=this.doc.head?.querySelectorAll(`style[${kS}="${this.appId}"]`);if(e?.length){const r=new Map;return e.forEach(i=>{null!=i.textContent&&r.set(i.textContent,i)}),r}return null}changeUsageCount(e,r){const i=this.styleRef;if(i.has(e)){const o=i.get(e);return o.usage+=r,o.usage}return i.set(e,{usage:r,elements:[]}),r}getStyleElement(e,r){const i=this.styleNodesInDOM,o=i?.get(r);if(o?.parentNode===e)return i.delete(r),o.removeAttribute(kS),o;{const s=this.doc.createElement("style");return this.nonce&&s.setAttribute("nonce",this.nonce),s.textContent=r,this.platformIsServer&&s.setAttribute(kS,this.appId),s}}addStyleToHost(e,r){const i=this.getStyleElement(e,r);e.appendChild(i);const o=this.styleRef,s=o.get(r)?.elements;s?s.push(i):o.set(r,{elements:[i],usage:1})}resetHostNodes(){const e=this.hostNodes;e.clear(),e.add(this.doc.head)}}return n.\u0275fac=function(e){return new(e||n)(Fe(Tn),Fe(fy),Fe(FT,8),Fe(Vd))},n.\u0275prov=at({token:n,factory:n.\u0275fac}),n})();const AS={svg:"http://www.w3.org/2000/svg",xhtml:"http://www.w3.org/1999/xhtml",xlink:"http://www.w3.org/1999/xlink",xml:"http://www.w3.org/XML/1998/namespace",xmlns:"http://www.w3.org/2000/xmlns/",math:"http://www.w3.org/1998/MathML/"},NS=/%COMP%/g,iee=new Qe("RemoveStylesOnCompDestory",{providedIn:"root",factory:()=>!1});function S$(n,t){return t.map(e=>e.replace(NS,n))}let OS=(()=>{class n{constructor(e,r,i,o,s,a,c,u=null){this.eventManager=e,this.sharedStylesHost=r,this.appId=i,this.removeStylesOnCompDestory=o,this.doc=s,this.platformId=a,this.ngZone=c,this.nonce=u,this.rendererByCompId=new Map,this.platformIsServer=f$(a),this.defaultRenderer=new RS(e,s,c,this.platformIsServer)}createRenderer(e,r){if(!e||!r)return this.defaultRenderer;this.platformIsServer&&r.encapsulation===No.ShadowDom&&(r={...r,encapsulation:No.Emulated});const i=this.getOrCreateRenderer(e,r);return i instanceof I$?i.applyToHost(e):i instanceof MS&&i.applyStyles(),i}getOrCreateRenderer(e,r){const i=this.rendererByCompId;let o=i.get(r.id);if(!o){const s=this.doc,a=this.ngZone,c=this.eventManager,u=this.sharedStylesHost,p=this.removeStylesOnCompDestory,m=this.platformIsServer;switch(r.encapsulation){case No.Emulated:o=new I$(c,u,r,this.appId,p,s,a,m);break;case No.ShadowDom:return new lee(c,u,e,r,s,a,this.nonce,m);default:o=new MS(c,u,r,p,s,a,m)}o.onDestroy=()=>i.delete(r.id),i.set(r.id,o)}return o}ngOnDestroy(){this.rendererByCompId.clear()}}return n.\u0275fac=function(e){return new(e||n)(Fe(v$),Fe(w$),Fe(fy),Fe(iee),Fe(Tn),Fe(Vd),Fe(Vt),Fe(FT))},n.\u0275prov=at({token:n,factory:n.\u0275fac}),n})();class RS{constructor(t,e,r,i){this.eventManager=t,this.doc=e,this.ngZone=r,this.platformIsServer=i,this.data=Object.create(null),this.destroyNode=null}destroy(){}createElement(t,e){return e?this.doc.createElementNS(AS[e]||e,t):this.doc.createElement(t)}createComment(t){return this.doc.createComment(t)}createText(t){return this.doc.createTextNode(t)}appendChild(t,e){(C$(t)?t.content:t).appendChild(e)}insertBefore(t,e,r){t&&(C$(t)?t.content:t).insertBefore(e,r)}removeChild(t,e){t&&t.removeChild(e)}selectRootElement(t,e){let r="string"==typeof t?this.doc.querySelector(t):t;if(!r)throw new Error(`The selector "${t}" did not match any elements`);return e||(r.textContent=""),r}parentNode(t){return t.parentNode}nextSibling(t){return t.nextSibling}setAttribute(t,e,r,i){if(i){e=i+":"+e;const o=AS[i];o?t.setAttributeNS(o,e,r):t.setAttribute(e,r)}else t.setAttribute(e,r)}removeAttribute(t,e,r){if(r){const i=AS[r];i?t.removeAttributeNS(i,e):t.removeAttribute(`${r}:${e}`)}else t.removeAttribute(e)}addClass(t,e){t.classList.add(e)}removeClass(t,e){t.classList.remove(e)}setStyle(t,e,r,i){i&(Po.DashCase|Po.Important)?t.style.setProperty(e,r,i&Po.Important?"important":""):t.style[e]=r}removeStyle(t,e,r){r&Po.DashCase?t.style.removeProperty(e):t.style[e]=""}setProperty(t,e,r){t[e]=r}setValue(t,e){t.nodeValue=e}listen(t,e,r){if("string"==typeof t&&!(t=tc().getGlobalEventTarget(this.doc,t)))throw new Error(`Unsupported event target ${t} for event ${e}`);return this.eventManager.addEventListener(t,e,this.decoratePreventDefault(r))}decoratePreventDefault(t){return e=>{if("__ngUnwrap__"===e)return t;!1===(this.platformIsServer?this.ngZone.runGuarded(()=>t(e)):t(e))&&(e.preventDefault(),e.returnValue=!1)}}}function C$(n){return"TEMPLATE"===n.tagName&&void 0!==n.content}class lee extends RS{constructor(t,e,r,i,o,s,a,c){super(t,o,s,c),this.sharedStylesHost=e,this.hostEl=r,this.shadowRoot=r.attachShadow({mode:"open"}),this.sharedStylesHost.addHost(this.shadowRoot);const u=S$(i.id,i.styles);for(const p of u){const m=document.createElement("style");a&&m.setAttribute("nonce",a),m.textContent=p,this.shadowRoot.appendChild(m)}}nodeOrShadowRoot(t){return t===this.hostEl?this.shadowRoot:t}appendChild(t,e){return super.appendChild(this.nodeOrShadowRoot(t),e)}insertBefore(t,e,r){return super.insertBefore(this.nodeOrShadowRoot(t),e,r)}removeChild(t,e){return super.removeChild(this.nodeOrShadowRoot(t),e)}parentNode(t){return this.nodeOrShadowRoot(super.parentNode(this.nodeOrShadowRoot(t)))}destroy(){this.sharedStylesHost.removeHost(this.shadowRoot)}}class MS extends RS{constructor(t,e,r,i,o,s,a,c){super(t,o,s,a),this.sharedStylesHost=e,this.removeStylesOnCompDestory=i,this.rendererUsageCount=0,this.styles=c?S$(c,r.styles):r.styles}applyStyles(){this.sharedStylesHost.addStyles(this.styles),this.rendererUsageCount++}destroy(){this.removeStylesOnCompDestory&&(this.sharedStylesHost.removeStyles(this.styles),this.rendererUsageCount--,0===this.rendererUsageCount&&this.onDestroy?.())}}class I$ extends MS{constructor(t,e,r,i,o,s,a,c){const u=i+"-"+r.id;super(t,e,r,o,s,a,c,u),this.contentAttr=function oee(n){return"_ngcontent-%COMP%".replace(NS,n)}(u),this.hostAttr=function see(n){return"_nghost-%COMP%".replace(NS,n)}(u)}applyToHost(t){this.applyStyles(),this.setAttribute(t,this.hostAttr,"")}createElement(t,e){const r=super.createElement(t,e);return super.setAttribute(r,this.contentAttr,""),r}}let cee=(()=>{class n extends x${constructor(e){super(e)}supports(e){return!0}addEventListener(e,r,i){return e.addEventListener(r,i,!1),()=>this.removeEventListener(e,r,i)}removeEventListener(e,r,i){return e.removeEventListener(r,i)}}return n.\u0275fac=function(e){return new(e||n)(Fe(Tn))},n.\u0275prov=at({token:n,factory:n.\u0275fac}),n})();const E$=["alt","control","meta","shift"],uee={"\b":"Backspace","\t":"Tab","\x7f":"Delete","\x1b":"Escape",Del:"Delete",Esc:"Escape",Left:"ArrowLeft",Right:"ArrowRight",Up:"ArrowUp",Down:"ArrowDown",Menu:"ContextMenu",Scroll:"ScrollLock",Win:"OS"},dee={alt:n=>n.altKey,control:n=>n.ctrlKey,meta:n=>n.metaKey,shift:n=>n.shiftKey};let hee=(()=>{class n extends x${constructor(e){super(e)}supports(e){return null!=n.parseEventName(e)}addEventListener(e,r,i){const o=n.parseEventName(r),s=n.eventCallback(o.fullKey,i,this.manager.getZone());return this.manager.getZone().runOutsideAngular(()=>tc().onAndCancel(e,o.domEventName,s))}static parseEventName(e){const r=e.toLowerCase().split("."),i=r.shift();if(0===r.length||"keydown"!==i&&"keyup"!==i)return null;const o=n._normalizeKey(r.pop());let s="",a=r.indexOf("code");if(a>-1&&(r.splice(a,1),s="code."),E$.forEach(u=>{const p=r.indexOf(u);p>-1&&(r.splice(p,1),s+=u+".")}),s+=o,0!=r.length||0===o.length)return null;const c={};return c.domEventName=i,c.fullKey=s,c}static matchEventFullKeyCode(e,r){let i=uee[e.key]||e.key,o="";return r.indexOf("code.")>-1&&(i=e.code,o="code."),!(null==i||!i)&&(i=i.toLowerCase()," "===i?i="space":"."===i&&(i="dot"),E$.forEach(s=>{s!==i&&(0,dee[s])(e)&&(o+=s+".")}),o+=i,o===r)}static eventCallback(e,r,i){return o=>{n.matchEventFullKeyCode(o,e)&&i.runGuarded(()=>r(o))}}static _normalizeKey(e){return"esc"===e?"escape":e}}return n.\u0275fac=function(e){return new(e||n)(Fe(Tn))},n.\u0275prov=at({token:n,factory:n.\u0275fac}),n})();const gee=wP(VZ,"browser",[{provide:Vd,useValue:p$},{provide:jO,useValue:function pee(){ES.makeCurrent()},multi:!0},{provide:Tn,useFactory:function mee(){return function xq(n){vT=n}(document),document},deps:[]}]),bee=new Qe(""),A$=[{provide:Hy,useClass:class JJ{addToWindow(t){Jn.getAngularTestability=(r,i=!0)=>{const o=t.findTestabilityInTree(r,i);if(null==o)throw new Error("Could not find testability for element.");return o},Jn.getAllAngularTestabilities=()=>t.getAllTestabilities(),Jn.getAllAngularRootElements=()=>t.getAllRootElements(),Jn.frameworkStabilizers||(Jn.frameworkStabilizers=[]),Jn.frameworkStabilizers.push(r=>{const i=Jn.getAllAngularTestabilities();let o=i.length,s=!1;const a=function(c){s=s||c,o--,0==o&&r(s)};i.forEach(function(c){c.whenStable(a)})})}findTestabilityInTree(t,e,r){return null==e?null:t.getTestability(e)??(r?tc().isShadowRoot(e)?this.findTestabilityInTree(t,e.host,!0):this.findTestabilityInTree(t,e.parentElement,!0):null)}},deps:[]},{provide:bP,useClass:Y1,deps:[Vt,Z1,Hy]},{provide:Y1,useClass:Y1,deps:[Vt,Z1,Hy]}],N$=[{provide:AT,useValue:"root"},{provide:pu,useFactory:function fee(){return new pu},deps:[]},{provide:DS,useClass:cee,multi:!0,deps:[Tn,Vt,Vd]},{provide:DS,useClass:hee,multi:!0,deps:[Tn]},OS,w$,v$,{provide:uf,useExisting:OS},{provide:class TJ{},useClass:eee,deps:[]},[]];let O$=(()=>{class n{constructor(e){}static withServerTransition(e){return{ngModule:n,providers:[{provide:fy,useValue:e.appId}]}}}return n.\u0275fac=function(e){return new(e||n)(Fe(bee,12))},n.\u0275mod=Vn({type:n}),n.\u0275inj=Pn({providers:[...N$,...A$],imports:[Vf,zZ]}),n})(),R$=(()=>{class n{constructor(e){this._doc=e}getTitle(){return this._doc.title}setTitle(e){this._doc.title=e||""}}return n.\u0275fac=function(e){return new(e||n)(Fe(Tn))},n.\u0275prov=at({token:n,factory:function(e){let r=null;return r=e?new e:function _ee(){return new R$(Fe(Tn))}(),r},providedIn:"root"}),n})();function jt(...n){return tt(n,Gl(n))}typeof window<"u"&&window;class Ds extends Kt{constructor(t){super(),this._value=t}get value(){return this.getValue()}_subscribe(t){const e=super._subscribe(t);return!e.closed&&t.next(this._value),e}getValue(){const{hasError:t,thrownError:e,_value:r}=this;if(t)throw e;return this._throwIfClosed(),r}next(t){super.next(this._value=t)}}const{isArray:Cee}=Array,{getPrototypeOf:Iee,prototype:Eee,keys:Dee}=Object;function $$(n){if(1===n.length){const t=n[0];if(Cee(t))return{args:t,keys:null};if(function kee(n){return n&&"object"==typeof n&&Iee(n)===Eee}(t)){const e=Dee(t);return{args:e.map(r=>t[r]),keys:e}}}return{args:n,keys:null}}const{isArray:Aee}=Array;function PS(n){return ct(t=>function Nee(n,t){return Aee(t)?n(...t):n(t)}(n,t))}function L$(n,t){return n.reduce((e,r,i)=>(e[r]=t[i],e),{})}function h_(...n){const t=Gl(n),e=Ap(n),{args:r,keys:i}=$$(n);if(0===r.length)return tt([],t);const o=new An(function Oee(n,t,e=Hr){return r=>{B$(t,()=>{const{length:i}=n,o=new Array(i);let s=i,a=i;for(let c=0;c<i;c++)B$(t,()=>{const u=tt(n[c],t);let p=!1;u.subscribe(Bn(r,m=>{o[c]=m,p||(p=!0,a--),a||r.next(e(o.slice()))},()=>{--s||r.complete()}))},r)},r)}}(r,t,i?s=>L$(i,s):Hr));return e?o.pipe(PS(e)):o}function B$(n,t,e){n?Xs(e,n,t):t()}const p_=ve(n=>function(){n(this),this.name="EmptyError",this.message="no elements in sequence"});function f_(...n){return function Ree(){return el(1)}()(tt(n,Gl(n)))}function m_(n){return new An(t=>{wi(n()).subscribe(t)})}function jf(n,t){const e=K(n)?n:()=>n,r=i=>i.error(e());return new An(t?i=>t.schedule(r,0,i):r)}function $S(){return Rn((n,t)=>{let e=null;n._refCount++;const r=Bn(t,void 0,void 0,void 0,()=>{if(!n||n._refCount<=0||0<--n._refCount)return void(e=null);const i=n._connection,o=e;e=null,i&&(!o||i===o)&&i.unsubscribe(),t.unsubscribe()});n.subscribe(r),r.closed||(e=n.connect())})}class V$ extends An{constructor(t,e){super(),this.source=t,this.subjectFactory=e,this._subject=null,this._refCount=0,this._connection=null,Vl(t)&&(this.lift=t.lift)}_subscribe(t){return this.getSubject().subscribe(t)}getSubject(){const t=this._subject;return(!t||t.isStopped)&&(this._subject=this.subjectFactory()),this._subject}_teardown(){this._refCount=0;const{_connection:t}=this;this._subject=this._connection=null,t?.unsubscribe()}connect(){let t=this._connection;if(!t){t=this._connection=new le;const e=this.getSubject();t.add(this.source.subscribe(Bn(e,void 0,()=>{this._teardown(),e.complete()},r=>{this._teardown(),e.error(r)},()=>this._teardown()))),t.closed&&(this._connection=null,t=le.EMPTY)}return t}refCount(){return $S()(this)}}function Aa(n,t){return Rn((e,r)=>{let i=null,o=0,s=!1;const a=()=>s&&!i&&r.complete();e.subscribe(Bn(r,c=>{i?.unsubscribe();let u=0;const p=o++;wi(n(c,p)).subscribe(i=Bn(r,m=>r.next(t?t(c,m,p,u++):m),()=>{i=null,a()}))},()=>{s=!0,a()}))})}function is(n){return n<=0?()=>ho:Rn((t,e)=>{let r=0;t.subscribe(Bn(e,i=>{++r<=n&&(e.next(i),n<=r&&e.complete())}))})}function _u(...n){const t=Gl(n);return Rn((e,r)=>{(t?f_(n,e,t):f_(n,e)).subscribe(r)})}function zi(n,t){return Rn((e,r)=>{let i=0;e.subscribe(Bn(r,o=>n.call(t,o,i++)&&r.next(o)))})}function g_(n){return Rn((t,e)=>{let r=!1;t.subscribe(Bn(e,i=>{r=!0,e.next(i)},()=>{r||e.next(n),e.complete()}))})}function z$(n=Mee){return Rn((t,e)=>{let r=!1;t.subscribe(Bn(e,i=>{r=!0,e.next(i)},()=>r?e.complete():e.error(n())))})}function Mee(){return new p_}function vu(n,t){const e=arguments.length>=2;return r=>r.pipe(n?zi((i,o)=>n(i,o,r)):Hr,is(1),e?g_(t):z$(()=>new p_))}function Gf(n,t){return K(t)?yr(n,t,1):yr(n,1)}function to(n,t,e){const r=K(n)||t||e?{next:n,error:t,complete:e}:n;return r?Rn((i,o)=>{var s;null===(s=r.subscribe)||void 0===s||s.call(r);let a=!0;i.subscribe(Bn(o,c=>{var u;null===(u=r.next)||void 0===u||u.call(r,c),o.next(c)},()=>{var c;a=!1,null===(c=r.complete)||void 0===c||c.call(r),o.complete()},c=>{var u;a=!1,null===(u=r.error)||void 0===u||u.call(r,c),o.error(c)},()=>{var c,u;a&&(null===(c=r.unsubscribe)||void 0===c||c.call(r)),null===(u=r.finalize)||void 0===u||u.call(r)}))}):Hr}function xu(n){return Rn((t,e)=>{let o,r=null,i=!1;r=t.subscribe(Bn(e,void 0,void 0,s=>{o=wi(n(s,xu(n)(t))),r?(r.unsubscribe(),r=null,o.subscribe(e)):i=!0})),i&&(r.unsubscribe(),r=null,o.subscribe(e))})}function LS(n){return n<=0?()=>ho:Rn((t,e)=>{let r=[];t.subscribe(Bn(e,i=>{r.push(i),n<r.length&&r.shift()},()=>{for(const i of r)e.next(i);e.complete()},void 0,()=>{r=null}))})}function BS(n){return Rn((t,e)=>{try{t.subscribe(e)}finally{e.add(n)}})}const on="primary",Hf=Symbol("RouteTitle");class Bee{constructor(t){this.params=t||{}}has(t){return Object.prototype.hasOwnProperty.call(this.params,t)}get(t){if(this.has(t)){const e=this.params[t];return Array.isArray(e)?e[0]:e}return null}getAll(t){if(this.has(t)){const e=this.params[t];return Array.isArray(e)?e:[e]}return[]}get keys(){return Object.keys(this.params)}}function lh(n){return new Bee(n)}function Vee(n,t,e){const r=e.path.split("/");if(r.length>n.length||"full"===e.pathMatch&&(t.hasChildren()||r.length<n.length))return null;const i={};for(let o=0;o<r.length;o++){const s=r[o],a=n[o];if(s.startsWith(":"))i[s.substring(1)]=a;else if(s!==a.path)return null}return{consumed:n.slice(0,r.length),posParams:i}}function Na(n,t){const e=n?Object.keys(n):void 0,r=t?Object.keys(t):void 0;if(!e||!r||e.length!=r.length)return!1;let i;for(let o=0;o<e.length;o++)if(i=e[o],!U$(n[i],t[i]))return!1;return!0}function U$(n,t){if(Array.isArray(n)&&Array.isArray(t)){if(n.length!==t.length)return!1;const e=[...n].sort(),r=[...t].sort();return e.every((i,o)=>r[o]===i)}return n===t}function j$(n){return n.length>0?n[n.length-1]:null}function ic(n){return function See(n){return!!n&&(n instanceof An||K(n.lift)&&K(n.subscribe))}(n)?n:wf(n)?tt(Promise.resolve(n)):jt(n)}const Uee={exact:function W$(n,t,e){if(!wu(n.segments,t.segments)||!b_(n.segments,t.segments,e)||n.numberOfChildren!==t.numberOfChildren)return!1;for(const r in t.children)if(!n.children[r]||!W$(n.children[r],t.children[r],e))return!1;return!0},subset:q$},G$={exact:function jee(n,t){return Na(n,t)},subset:function Gee(n,t){return Object.keys(t).length<=Object.keys(n).length&&Object.keys(t).every(e=>U$(n[e],t[e]))},ignored:()=>!0};function H$(n,t,e){return Uee[e.paths](n.root,t.root,e.matrixParams)&&G$[e.queryParams](n.queryParams,t.queryParams)&&!("exact"===e.fragment&&n.fragment!==t.fragment)}function q$(n,t,e){return K$(n,t,t.segments,e)}function K$(n,t,e,r){if(n.segments.length>e.length){const i=n.segments.slice(0,e.length);return!(!wu(i,e)||t.hasChildren()||!b_(i,e,r))}if(n.segments.length===e.length){if(!wu(n.segments,e)||!b_(n.segments,e,r))return!1;for(const i in t.children)if(!n.children[i]||!q$(n.children[i],t.children[i],r))return!1;return!0}{const i=e.slice(0,n.segments.length),o=e.slice(n.segments.length);return!!(wu(n.segments,i)&&b_(n.segments,i,r)&&n.children[on])&&K$(n.children[on],t,o,r)}}function b_(n,t,e){return t.every((r,i)=>G$[e](n[i].parameters,r.parameters))}class ch{constructor(t=new zn([],{}),e={},r=null){this.root=t,this.queryParams=e,this.fragment=r}get queryParamMap(){return this._queryParamMap||(this._queryParamMap=lh(this.queryParams)),this._queryParamMap}toString(){return qee.serialize(this)}}class zn{constructor(t,e){this.segments=t,this.children=e,this.parent=null,Object.values(e).forEach(r=>r.parent=this)}hasChildren(){return this.numberOfChildren>0}get numberOfChildren(){return Object.keys(this.children).length}toString(){return y_(this)}}class Wf{constructor(t,e){this.path=t,this.parameters=e}get parameterMap(){return this._parameterMap||(this._parameterMap=lh(this.parameters)),this._parameterMap}toString(){return Z$(this)}}function wu(n,t){return n.length===t.length&&n.every((e,r)=>e.path===t[r].path)}let qf=(()=>{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275prov=at({token:n,factory:function(){return new VS},providedIn:"root"}),n})();class VS{parse(t){const e=new ite(t);return new ch(e.parseRootSegment(),e.parseQueryParams(),e.parseFragment())}serialize(t){const e=`/${Kf(t.root,!0)}`,r=function Yee(n){const t=Object.keys(n).map(e=>{const r=n[e];return Array.isArray(r)?r.map(i=>`${__(e)}=${__(i)}`).join("&"):`${__(e)}=${__(r)}`}).filter(e=>!!e);return t.length?`?${t.join("&")}`:""}(t.queryParams);return`${e}${r}${"string"==typeof t.fragment?`#${function Kee(n){return encodeURI(n)}(t.fragment)}`:""}`}}const qee=new VS;function y_(n){return n.segments.map(t=>Z$(t)).join("/")}function Kf(n,t){if(!n.hasChildren())return y_(n);if(t){const e=n.children[on]?Kf(n.children[on],!1):"",r=[];return Object.entries(n.children).forEach(([i,o])=>{i!==on&&r.push(`${i}:${Kf(o,!1)}`)}),r.length>0?`${e}(${r.join("//")})`:e}{const e=function Wee(n,t){let e=[];return Object.entries(n.children).forEach(([r,i])=>{r===on&&(e=e.concat(t(i,r)))}),Object.entries(n.children).forEach(([r,i])=>{r!==on&&(e=e.concat(t(i,r)))}),e}(n,(r,i)=>i===on?[Kf(n.children[on],!1)]:[`${i}:${Kf(r,!1)}`]);return 1===Object.keys(n.children).length&&null!=n.children[on]?`${y_(n)}/${e[0]}`:`${y_(n)}/(${e.join("//")})`}}function X$(n){return encodeURIComponent(n).replace(/%40/g,"@").replace(/%3A/gi,":").replace(/%24/g,"$").replace(/%2C/gi,",")}function __(n){return X$(n).replace(/%3B/gi,";")}function zS(n){return X$(n).replace(/\(/g,"%28").replace(/\)/g,"%29").replace(/%26/gi,"&")}function v_(n){return decodeURIComponent(n)}function Y$(n){return v_(n.replace(/\+/g,"%20"))}function Z$(n){return`${zS(n.path)}${function Xee(n){return Object.keys(n).map(t=>`;${zS(t)}=${zS(n[t])}`).join("")}(n.parameters)}`}const Zee=/^[^\/()?;#]+/;function US(n){const t=n.match(Zee);return t?t[0]:""}const Qee=/^[^\/()?;=#]+/,ete=/^[^=?&#]+/,nte=/^[^&#]+/;class ite{constructor(t){this.url=t,this.remaining=t}parseRootSegment(){return this.consumeOptional("/"),""===this.remaining||this.peekStartsWith("?")||this.peekStartsWith("#")?new zn([],{}):new zn([],this.parseChildren())}parseQueryParams(){const t={};if(this.consumeOptional("?"))do{this.parseQueryParam(t)}while(this.consumeOptional("&"));return t}parseFragment(){return this.consumeOptional("#")?decodeURIComponent(this.remaining):null}parseChildren(){if(""===this.remaining)return{};this.consumeOptional("/");const t=[];for(this.peekStartsWith("(")||t.push(this.parseSegment());this.peekStartsWith("/")&&!this.peekStartsWith("//")&&!this.peekStartsWith("/(");)this.capture("/"),t.push(this.parseSegment());let e={};this.peekStartsWith("/(")&&(this.capture("/"),e=this.parseParens(!0));let r={};return this.peekStartsWith("(")&&(r=this.parseParens(!1)),(t.length>0||Object.keys(e).length>0)&&(r[on]=new zn(t,e)),r}parseSegment(){const t=US(this.remaining);if(""===t&&this.peekStartsWith(";"))throw new ze(4009,!1);return this.capture(t),new Wf(v_(t),this.parseMatrixParams())}parseMatrixParams(){const t={};for(;this.consumeOptional(";");)this.parseParam(t);return t}parseParam(t){const e=function Jee(n){const t=n.match(Qee);return t?t[0]:""}(this.remaining);if(!e)return;this.capture(e);let r="";if(this.consumeOptional("=")){const i=US(this.remaining);i&&(r=i,this.capture(r))}t[v_(e)]=v_(r)}parseQueryParam(t){const e=function tte(n){const t=n.match(ete);return t?t[0]:""}(this.remaining);if(!e)return;this.capture(e);let r="";if(this.consumeOptional("=")){const s=function rte(n){const t=n.match(nte);return t?t[0]:""}(this.remaining);s&&(r=s,this.capture(r))}const i=Y$(e),o=Y$(r);if(t.hasOwnProperty(i)){let s=t[i];Array.isArray(s)||(s=[s],t[i]=s),s.push(o)}else t[i]=o}parseParens(t){const e={};for(this.capture("(");!this.consumeOptional(")")&&this.remaining.length>0;){const r=US(this.remaining),i=this.remaining[r.length];if("/"!==i&&")"!==i&&";"!==i)throw new ze(4010,!1);let o;r.indexOf(":")>-1?(o=r.slice(0,r.indexOf(":")),this.capture(o),this.capture(":")):t&&(o=on);const s=this.parseChildren();e[o]=1===Object.keys(s).length?s[on]:new zn([],s),this.consumeOptional("//")}return e}peekStartsWith(t){return this.remaining.startsWith(t)}consumeOptional(t){return!!this.peekStartsWith(t)&&(this.remaining=this.remaining.substring(t.length),!0)}capture(t){if(!this.consumeOptional(t))throw new ze(4011,!1)}}function Q$(n){return n.segments.length>0?new zn([],{[on]:n}):n}function J$(n){const t={};for(const r of Object.keys(n.children)){const o=J$(n.children[r]);if(r===on&&0===o.segments.length&&o.hasChildren())for(const[s,a]of Object.entries(o.children))t[s]=a;else(o.segments.length>0||o.hasChildren())&&(t[r]=o)}return function ote(n){if(1===n.numberOfChildren&&n.children[on]){const t=n.children[on];return new zn(n.segments.concat(t.segments),t.children)}return n}(new zn(n.segments,t))}function Tu(n){return n instanceof ch}function eL(n){let t;const i=Q$(function e(o){const s={};for(const c of o.children){const u=e(c);s[c.outlet]=u}const a=new zn(o.url,s);return o===n&&(t=a),a}(n.root));return t??i}function tL(n,t,e,r){let i=n;for(;i.parent;)i=i.parent;if(0===t.length)return jS(i,i,i,e,r);const o=function ate(n){if("string"==typeof n[0]&&1===n.length&&"/"===n[0])return new rL(!0,0,n);let t=0,e=!1;const r=n.reduce((i,o,s)=>{if("object"==typeof o&&null!=o){if(o.outlets){const a={};return Object.entries(o.outlets).forEach(([c,u])=>{a[c]="string"==typeof u?u.split("/"):u}),[...i,{outlets:a}]}if(o.segmentPath)return[...i,o.segmentPath]}return"string"!=typeof o?[...i,o]:0===s?(o.split("/").forEach((a,c)=>{0==c&&"."===a||(0==c&&""===a?e=!0:".."===a?t++:""!=a&&i.push(a))}),i):[...i,o]},[]);return new rL(e,t,r)}(t);if(o.toRoot())return jS(i,i,new zn([],{}),e,r);const s=function lte(n,t,e){if(n.isAbsolute)return new w_(t,!0,0);if(!e)return new w_(t,!1,NaN);if(null===e.parent)return new w_(e,!0,0);const r=x_(n.commands[0])?0:1;return function cte(n,t,e){let r=n,i=t,o=e;for(;o>i;){if(o-=i,r=r.parent,!r)throw new ze(4005,!1);i=r.segments.length}return new w_(r,!1,i-o)}(e,e.segments.length-1+r,n.numberOfDoubleDots)}(o,i,n),a=s.processChildren?Yf(s.segmentGroup,s.index,o.commands):iL(s.segmentGroup,s.index,o.commands);return jS(i,s.segmentGroup,a,e,r)}function x_(n){return"object"==typeof n&&null!=n&&!n.outlets&&!n.segmentPath}function Xf(n){return"object"==typeof n&&null!=n&&n.outlets}function jS(n,t,e,r,i){let s,o={};r&&Object.entries(r).forEach(([c,u])=>{o[c]=Array.isArray(u)?u.map(p=>`${p}`):`${u}`}),s=n===t?e:nL(n,t,e);const a=Q$(J$(s));return new ch(a,o,i)}function nL(n,t,e){const r={};return Object.entries(n.children).forEach(([i,o])=>{r[i]=o===t?e:nL(o,t,e)}),new zn(n.segments,r)}class rL{constructor(t,e,r){if(this.isAbsolute=t,this.numberOfDoubleDots=e,this.commands=r,t&&r.length>0&&x_(r[0]))throw new ze(4003,!1);const i=r.find(Xf);if(i&&i!==j$(r))throw new ze(4004,!1)}toRoot(){return this.isAbsolute&&1===this.commands.length&&"/"==this.commands[0]}}class w_{constructor(t,e,r){this.segmentGroup=t,this.processChildren=e,this.index=r}}function iL(n,t,e){if(n||(n=new zn([],{})),0===n.segments.length&&n.hasChildren())return Yf(n,t,e);const r=function dte(n,t,e){let r=0,i=t;const o={match:!1,pathIndex:0,commandIndex:0};for(;i<n.segments.length;){if(r>=e.length)return o;const s=n.segments[i],a=e[r];if(Xf(a))break;const c=`${a}`,u=r<e.length-1?e[r+1]:null;if(i>0&&void 0===c)break;if(c&&u&&"object"==typeof u&&void 0===u.outlets){if(!sL(c,u,s))return o;r+=2}else{if(!sL(c,{},s))return o;r++}i++}return{match:!0,pathIndex:i,commandIndex:r}}(n,t,e),i=e.slice(r.commandIndex);if(r.match&&r.pathIndex<n.segments.length){const o=new zn(n.segments.slice(0,r.pathIndex),{});return o.children[on]=new zn(n.segments.slice(r.pathIndex),n.children),Yf(o,0,i)}return r.match&&0===i.length?new zn(n.segments,{}):r.match&&!n.hasChildren()?GS(n,t,e):r.match?Yf(n,0,i):GS(n,t,e)}function Yf(n,t,e){if(0===e.length)return new zn(n.segments,{});{const r=function ute(n){return Xf(n[0])?n[0].outlets:{[on]:n}}(e),i={};if(!r[on]&&n.children[on]&&1===n.numberOfChildren&&0===n.children[on].segments.length){const o=Yf(n.children[on],t,e);return new zn(n.segments,o.children)}return Object.entries(r).forEach(([o,s])=>{"string"==typeof s&&(s=[s]),null!==s&&(i[o]=iL(n.children[o],t,s))}),Object.entries(n.children).forEach(([o,s])=>{void 0===r[o]&&(i[o]=s)}),new zn(n.segments,i)}}function GS(n,t,e){const r=n.segments.slice(0,t);let i=0;for(;i<e.length;){const o=e[i];if(Xf(o)){const c=hte(o.outlets);return new zn(r,c)}if(0===i&&x_(e[0])){r.push(new Wf(n.segments[t].path,oL(e[0]))),i++;continue}const s=Xf(o)?o.outlets[on]:`${o}`,a=i<e.length-1?e[i+1]:null;s&&a&&x_(a)?(r.push(new Wf(s,oL(a))),i+=2):(r.push(new Wf(s,{})),i++)}return new zn(r,{})}function hte(n){const t={};return Object.entries(n).forEach(([e,r])=>{"string"==typeof r&&(r=[r]),null!==r&&(t[e]=GS(new zn([],{}),0,r))}),t}function oL(n){const t={};return Object.entries(n).forEach(([e,r])=>t[e]=`${r}`),t}function sL(n,t,e){return n==e.path&&Na(t,e.parameters)}const Zf="imperative";class Oa{constructor(t,e){this.id=t,this.url=e}}class HS extends Oa{constructor(t,e,r="imperative",i=null){super(t,e),this.type=0,this.navigationTrigger=r,this.restoredState=i}toString(){return`NavigationStart(id: ${this.id}, url: '${this.url}')`}}class Su extends Oa{constructor(t,e,r){super(t,e),this.urlAfterRedirects=r,this.type=1}toString(){return`NavigationEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}')`}}class T_ extends Oa{constructor(t,e,r,i){super(t,e),this.reason=r,this.code=i,this.type=2}toString(){return`NavigationCancel(id: ${this.id}, url: '${this.url}')`}}class Qf extends Oa{constructor(t,e,r,i){super(t,e),this.reason=r,this.code=i,this.type=16}}class WS extends Oa{constructor(t,e,r,i){super(t,e),this.error=r,this.target=i,this.type=3}toString(){return`NavigationError(id: ${this.id}, url: '${this.url}', error: ${this.error})`}}class pte extends Oa{constructor(t,e,r,i){super(t,e),this.urlAfterRedirects=r,this.state=i,this.type=4}toString(){return`RoutesRecognized(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`}}class fte extends Oa{constructor(t,e,r,i){super(t,e),this.urlAfterRedirects=r,this.state=i,this.type=7}toString(){return`GuardsCheckStart(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`}}class mte extends Oa{constructor(t,e,r,i,o){super(t,e),this.urlAfterRedirects=r,this.state=i,this.shouldActivate=o,this.type=8}toString(){return`GuardsCheckEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state}, shouldActivate: ${this.shouldActivate})`}}class gte extends Oa{constructor(t,e,r,i){super(t,e),this.urlAfterRedirects=r,this.state=i,this.type=5}toString(){return`ResolveStart(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`}}class bte extends Oa{constructor(t,e,r,i){super(t,e),this.urlAfterRedirects=r,this.state=i,this.type=6}toString(){return`ResolveEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`}}class yte{constructor(t){this.route=t,this.type=9}toString(){return`RouteConfigLoadStart(path: ${this.route.path})`}}class _te{constructor(t){this.route=t,this.type=10}toString(){return`RouteConfigLoadEnd(path: ${this.route.path})`}}class vte{constructor(t){this.snapshot=t,this.type=11}toString(){return`ChildActivationStart(path: '${this.snapshot.routeConfig&&this.snapshot.routeConfig.path||""}')`}}class xte{constructor(t){this.snapshot=t,this.type=12}toString(){return`ChildActivationEnd(path: '${this.snapshot.routeConfig&&this.snapshot.routeConfig.path||""}')`}}class wte{constructor(t){this.snapshot=t,this.type=13}toString(){return`ActivationStart(path: '${this.snapshot.routeConfig&&this.snapshot.routeConfig.path||""}')`}}class Tte{constructor(t){this.snapshot=t,this.type=14}toString(){return`ActivationEnd(path: '${this.snapshot.routeConfig&&this.snapshot.routeConfig.path||""}')`}}class aL{constructor(t,e,r){this.routerEvent=t,this.position=e,this.anchor=r,this.type=15}toString(){return`Scroll(anchor: '${this.anchor}', position: '${this.position?`${this.position[0]}, ${this.position[1]}`:null}')`}}class Ste{constructor(){this.outlet=null,this.route=null,this.injector=null,this.children=new Jf,this.attachRef=null}}let Jf=(()=>{class n{constructor(){this.contexts=new Map}onChildOutletCreated(e,r){const i=this.getOrCreateContext(e);i.outlet=r,this.contexts.set(e,i)}onChildOutletDestroyed(e){const r=this.getContext(e);r&&(r.outlet=null,r.attachRef=null)}onOutletDeactivated(){const e=this.contexts;return this.contexts=new Map,e}onOutletReAttached(e){this.contexts=e}getOrCreateContext(e){let r=this.getContext(e);return r||(r=new Ste,this.contexts.set(e,r)),r}getContext(e){return this.contexts.get(e)||null}}return n.\u0275fac=function(e){return new(e||n)},n.\u0275prov=at({token:n,factory:n.\u0275fac,providedIn:"root"}),n})();class lL{constructor(t){this._root=t}get root(){return this._root.value}parent(t){const e=this.pathFromRoot(t);return e.length>1?e[e.length-2]:null}children(t){const e=qS(t,this._root);return e?e.children.map(r=>r.value):[]}firstChild(t){const e=qS(t,this._root);return e&&e.children.length>0?e.children[0].value:null}siblings(t){const e=KS(t,this._root);return e.length<2?[]:e[e.length-2].children.map(i=>i.value).filter(i=>i!==t)}pathFromRoot(t){return KS(t,this._root).map(e=>e.value)}}function qS(n,t){if(n===t.value)return t;for(const e of t.children){const r=qS(n,e);if(r)return r}return null}function KS(n,t){if(n===t.value)return[t];for(const e of t.children){const r=KS(n,e);if(r.length)return r.unshift(t),r}return[]}class bl{constructor(t,e){this.value=t,this.children=e}toString(){return`TreeNode(${this.value})`}}function uh(n){const t={};return n&&n.children.forEach(e=>t[e.value.outlet]=e),t}class cL extends lL{constructor(t,e){super(t),this.snapshot=e,XS(this,t)}toString(){return this.snapshot.toString()}}function uL(n,t){const e=function Cte(n,t){const s=new S_([],{},{},"",{},on,t,null,{});return new hL("",new bl(s,[]))}(0,t),r=new Ds([new Wf("",{})]),i=new Ds({}),o=new Ds({}),s=new Ds({}),a=new Ds(""),c=new dh(r,i,s,a,o,on,t,e.root);return c.snapshot=e.root,new cL(new bl(c,[]),e)}class dh{constructor(t,e,r,i,o,s,a,c){this.urlSubject=t,this.paramsSubject=e,this.queryParamsSubject=r,this.fragmentSubject=i,this.dataSubject=o,this.outlet=s,this.component=a,this._futureSnapshot=c,this.title=this.dataSubject?.pipe(ct(u=>u[Hf]))??jt(void 0),this.url=t,this.params=e,this.queryParams=r,this.fragment=i,this.data=o}get routeConfig(){return this._futureSnapshot.routeConfig}get root(){return this._routerState.root}get parent(){return this._routerState.parent(this)}get firstChild(){return this._routerState.firstChild(this)}get children(){return this._routerState.children(this)}get pathFromRoot(){return this._routerState.pathFromRoot(this)}get paramMap(){return this._paramMap||(this._paramMap=this.params.pipe(ct(t=>lh(t)))),this._paramMap}get queryParamMap(){return this._queryParamMap||(this._queryParamMap=this.queryParams.pipe(ct(t=>lh(t)))),this._queryParamMap}toString(){return this.snapshot?this.snapshot.toString():`Future(${this._futureSnapshot})`}}function dL(n,t="emptyOnly"){const e=n.pathFromRoot;let r=0;if("always"!==t)for(r=e.length-1;r>=1;){const i=e[r],o=e[r-1];if(i.routeConfig&&""===i.routeConfig.path)r--;else{if(o.component)break;r--}}return function Ite(n){return n.reduce((t,e)=>({params:{...t.params,...e.params},data:{...t.data,...e.data},resolve:{...e.data,...t.resolve,...e.routeConfig?.data,...e._resolvedData}}),{params:{},data:{},resolve:{}})}(e.slice(r))}class S_{get title(){return this.data?.[Hf]}constructor(t,e,r,i,o,s,a,c,u){this.url=t,this.params=e,this.queryParams=r,this.fragment=i,this.data=o,this.outlet=s,this.component=a,this.routeConfig=c,this._resolve=u}get root(){return this._routerState.root}get parent(){return this._routerState.parent(this)}get firstChild(){return this._routerState.firstChild(this)}get children(){return this._routerState.children(this)}get pathFromRoot(){return this._routerState.pathFromRoot(this)}get paramMap(){return this._paramMap||(this._paramMap=lh(this.params)),this._paramMap}get queryParamMap(){return this._queryParamMap||(this._queryParamMap=lh(this.queryParams)),this._queryParamMap}toString(){return`Route(url:'${this.url.map(r=>r.toString()).join("/")}', path:'${this.routeConfig?this.routeConfig.path:""}')`}}class hL extends lL{constructor(t,e){super(e),this.url=t,XS(this,e)}toString(){return pL(this._root)}}function XS(n,t){t.value._routerState=n,t.children.forEach(e=>XS(n,e))}function pL(n){const t=n.children.length>0?` { ${n.children.map(pL).join(", ")} } `:"";return`${n.value}${t}`}function YS(n){if(n.snapshot){const t=n.snapshot,e=n._futureSnapshot;n.snapshot=e,Na(t.queryParams,e.queryParams)||n.queryParamsSubject.next(e.queryParams),t.fragment!==e.fragment&&n.fragmentSubject.next(e.fragment),Na(t.params,e.params)||n.paramsSubject.next(e.params),function zee(n,t){if(n.length!==t.length)return!1;for(let e=0;e<n.length;++e)if(!Na(n[e],t[e]))return!1;return!0}(t.url,e.url)||n.urlSubject.next(e.url),Na(t.data,e.data)||n.dataSubject.next(e.data)}else n.snapshot=n._futureSnapshot,n.dataSubject.next(n._futureSnapshot.data)}function ZS(n,t){const e=Na(n.params,t.params)&&function Hee(n,t){return wu(n,t)&&n.every((e,r)=>Na(e.parameters,t[r].parameters))}(n.url,t.url);return e&&!(!n.parent!=!t.parent)&&(!n.parent||ZS(n.parent,t.parent))}let fL=(()=>{class n{constructor(){this.activated=null,this._activatedRoute=null,this.name=on,this.activateEvents=new rn,this.deactivateEvents=new rn,this.attachEvents=new rn,this.detachEvents=new rn,this.parentContexts=It(Jf),this.location=It(eo),this.changeDetector=It(Vi),this.environmentInjector=It(ul),this.inputBinder=It(C_,{optional:!0}),this.supportsBindingToComponentInputs=!0}get activatedComponentRef(){return this.activated}ngOnChanges(e){if(e.name){const{firstChange:r,previousValue:i}=e.name;if(r)return;this.isTrackedInParentContexts(i)&&(this.deactivate(),this.parentContexts.onChildOutletDestroyed(i)),this.initializeOutletWithName()}}ngOnDestroy(){this.isTrackedInParentContexts(this.name)&&this.parentContexts.onChildOutletDestroyed(this.name),this.inputBinder?.unsubscribeFromRouteData(this)}isTrackedInParentContexts(e){return this.parentContexts.getContext(e)?.outlet===this}ngOnInit(){this.initializeOutletWithName()}initializeOutletWithName(){if(this.parentContexts.onChildOutletCreated(this.name,this),this.activated)return;const e=this.parentContexts.getContext(this.name);e?.route&&(e.attachRef?this.attach(e.attachRef,e.route):this.activateWith(e.route,e.injector))}get isActivated(){return!!this.activated}get component(){if(!this.activated)throw new ze(4012,!1);return this.activated.instance}get activatedRoute(){if(!this.activated)throw new ze(4012,!1);return this._activatedRoute}get activatedRouteData(){return this._activatedRoute?this._activatedRoute.snapshot.data:{}}detach(){if(!this.activated)throw new ze(4012,!1);this.location.detach();const e=this.activated;return this.activated=null,this._activatedRoute=null,this.detachEvents.emit(e.instance),e}attach(e,r){this.activated=e,this._activatedRoute=r,this.location.insert(e.hostView),this.inputBinder?.bindActivatedRouteToOutletComponent(this),this.attachEvents.emit(e.instance)}deactivate(){if(this.activated){const e=this.component;this.activated.destroy(),this.activated=null,this._activatedRoute=null,this.deactivateEvents.emit(e)}}activateWith(e,r){if(this.isActivated)throw new ze(4013,!1);this._activatedRoute=e;const i=this.location,s=e.snapshot.component,a=this.parentContexts.getOrCreateContext(this.name).children,c=new Ete(e,a,i.injector);this.activated=i.createComponent(s,{index:i.length,injector:c,environmentInjector:r??this.environmentInjector}),this.changeDetector.markForCheck(),this.inputBinder?.bindActivatedRouteToOutletComponent(this),this.activateEvents.emit(this.activated.instance)}}return n.\u0275fac=function(e){return new(e||n)},n.\u0275dir=_t({type:n,selectors:[["router-outlet"]],inputs:{name:"name"},outputs:{activateEvents:"activate",deactivateEvents:"deactivate",attachEvents:"attach",detachEvents:"detach"},exportAs:["outlet"],standalone:!0,features:[po]}),n})();class Ete{constructor(t,e,r){this.route=t,this.childContexts=e,this.parent=r}get(t,e){return t===dh?this.route:t===Jf?this.childContexts:this.parent.get(t,e)}}const C_=new Qe("");let mL=(()=>{class n{constructor(){this.outletDataSubscriptions=new Map}bindActivatedRouteToOutletComponent(e){this.unsubscribeFromRouteData(e),this.subscribeToRouteData(e)}unsubscribeFromRouteData(e){this.outletDataSubscriptions.get(e)?.unsubscribe(),this.outletDataSubscriptions.delete(e)}subscribeToRouteData(e){const{activatedRoute:r}=e,i=h_([r.queryParams,r.params,r.data]).pipe(Aa(([o,s,a],c)=>(a={...o,...s,...a},0===c?jt(a):Promise.resolve(a)))).subscribe(o=>{if(!e.isActivated||!e.activatedComponentRef||e.activatedRoute!==r||null===r.component)return void this.unsubscribeFromRouteData(e);const s=function ZZ(n){const t=On(n);if(!t)return null;const e=new mf(t);return{get selector(){return e.selector},get type(){return e.componentType},get inputs(){return e.inputs},get outputs(){return e.outputs},get ngContentSelectors(){return e.ngContentSelectors},get isStandalone(){return t.standalone}}}(r.component);if(s)for(const{templateName:a}of s.inputs)e.activatedComponentRef.setInput(a,o[a]);else this.unsubscribeFromRouteData(e)});this.outletDataSubscriptions.set(e,i)}}return n.\u0275fac=function(e){return new(e||n)},n.\u0275prov=at({token:n,factory:n.\u0275fac}),n})();function em(n,t,e){if(e&&n.shouldReuseRoute(t.value,e.value.snapshot)){const r=e.value;r._futureSnapshot=t.value;const i=function kte(n,t,e){return t.children.map(r=>{for(const i of e.children)if(n.shouldReuseRoute(r.value,i.value.snapshot))return em(n,r,i);return em(n,r)})}(n,t,e);return new bl(r,i)}{if(n.shouldAttach(t.value)){const o=n.retrieve(t.value);if(null!==o){const s=o.route;return s.value._futureSnapshot=t.value,s.children=t.children.map(a=>em(n,a)),s}}const r=function Ate(n){return new dh(new Ds(n.url),new Ds(n.params),new Ds(n.queryParams),new Ds(n.fragment),new Ds(n.data),n.outlet,n.component,n)}(t.value),i=t.children.map(o=>em(n,o));return new bl(r,i)}}const QS="ngNavigationCancelingError";function gL(n,t){const{redirectTo:e,navigationBehaviorOptions:r}=Tu(t)?{redirectTo:t,navigationBehaviorOptions:void 0}:t,i=bL(!1,0,t);return i.url=e,i.navigationBehaviorOptions=r,i}function bL(n,t,e){const r=new Error("NavigationCancelingError: "+(n||""));return r[QS]=!0,r.cancellationCode=t,e&&(r.url=e),r}function yL(n){return _L(n)&&Tu(n.url)}function _L(n){return n&&n[QS]}let vL=(()=>{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275cmp=Pi({type:n,selectors:[["ng-component"]],standalone:!0,features:[yF],decls:1,vars:0,template:function(e,r){1&e&&kr(0,"router-outlet")},dependencies:[fL],encapsulation:2}),n})();function JS(n){const t=n.children&&n.children.map(JS),e=t?{...n,children:t}:{...n};return!e.component&&!e.loadComponent&&(t||e.loadChildren)&&e.outlet&&e.outlet!==on&&(e.component=vL),e}function oa(n){return n.outlet||on}function tm(n){if(!n)return null;if(n.routeConfig?._injector)return n.routeConfig._injector;for(let t=n.parent;t;t=t.parent){const e=t.routeConfig;if(e?._loadedInjector)return e._loadedInjector;if(e?._injector)return e._injector}return null}class $te{constructor(t,e,r,i,o){this.routeReuseStrategy=t,this.futureState=e,this.currState=r,this.forwardEvent=i,this.inputBindingEnabled=o}activate(t){const e=this.futureState._root,r=this.currState?this.currState._root:null;this.deactivateChildRoutes(e,r,t),YS(this.futureState.root),this.activateChildRoutes(e,r,t)}deactivateChildRoutes(t,e,r){const i=uh(e);t.children.forEach(o=>{const s=o.value.outlet;this.deactivateRoutes(o,i[s],r),delete i[s]}),Object.values(i).forEach(o=>{this.deactivateRouteAndItsChildren(o,r)})}deactivateRoutes(t,e,r){const i=t.value,o=e?e.value:null;if(i===o)if(i.component){const s=r.getContext(i.outlet);s&&this.deactivateChildRoutes(t,e,s.children)}else this.deactivateChildRoutes(t,e,r);else o&&this.deactivateRouteAndItsChildren(e,r)}deactivateRouteAndItsChildren(t,e){t.value.component&&this.routeReuseStrategy.shouldDetach(t.value.snapshot)?this.detachAndStoreRouteSubtree(t,e):this.deactivateRouteAndOutlet(t,e)}detachAndStoreRouteSubtree(t,e){const r=e.getContext(t.value.outlet),i=r&&t.value.component?r.children:e,o=uh(t);for(const s of Object.keys(o))this.deactivateRouteAndItsChildren(o[s],i);if(r&&r.outlet){const s=r.outlet.detach(),a=r.children.onOutletDeactivated();this.routeReuseStrategy.store(t.value.snapshot,{componentRef:s,route:t,contexts:a})}}deactivateRouteAndOutlet(t,e){const r=e.getContext(t.value.outlet),i=r&&t.value.component?r.children:e,o=uh(t);for(const s of Object.keys(o))this.deactivateRouteAndItsChildren(o[s],i);r&&(r.outlet&&(r.outlet.deactivate(),r.children.onOutletDeactivated()),r.attachRef=null,r.route=null)}activateChildRoutes(t,e,r){const i=uh(e);t.children.forEach(o=>{this.activateRoutes(o,i[o.value.outlet],r),this.forwardEvent(new Tte(o.value.snapshot))}),t.children.length&&this.forwardEvent(new xte(t.value.snapshot))}activateRoutes(t,e,r){const i=t.value,o=e?e.value:null;if(YS(i),i===o)if(i.component){const s=r.getOrCreateContext(i.outlet);this.activateChildRoutes(t,e,s.children)}else this.activateChildRoutes(t,e,r);else if(i.component){const s=r.getOrCreateContext(i.outlet);if(this.routeReuseStrategy.shouldAttach(i.snapshot)){const a=this.routeReuseStrategy.retrieve(i.snapshot);this.routeReuseStrategy.store(i.snapshot,null),s.children.onOutletReAttached(a.contexts),s.attachRef=a.componentRef,s.route=a.route.value,s.outlet&&s.outlet.attach(a.componentRef,a.route.value),YS(a.route.value),this.activateChildRoutes(t,null,s.children)}else{const a=tm(i.snapshot);s.attachRef=null,s.route=i,s.injector=a,s.outlet&&s.outlet.activateWith(i,s.injector),this.activateChildRoutes(t,null,s.children)}}else this.activateChildRoutes(t,null,r)}}class xL{constructor(t){this.path=t,this.route=this.path[this.path.length-1]}}class I_{constructor(t,e){this.component=t,this.route=e}}function Lte(n,t,e){const r=n._root;return nm(r,t?t._root:null,e,[r.value])}function hh(n,t){const e=Symbol(),r=t.get(n,e);return r===e?"function"!=typeof n||function UW(n){return null!==Db(n)}(n)?t.get(n):n:r}function nm(n,t,e,r,i={canDeactivateChecks:[],canActivateChecks:[]}){const o=uh(t);return n.children.forEach(s=>{(function Vte(n,t,e,r,i={canDeactivateChecks:[],canActivateChecks:[]}){const o=n.value,s=t?t.value:null,a=e?e.getContext(n.value.outlet):null;if(s&&o.routeConfig===s.routeConfig){const c=function zte(n,t,e){if("function"==typeof e)return e(n,t);switch(e){case"pathParamsChange":return!wu(n.url,t.url);case"pathParamsOrQueryParamsChange":return!wu(n.url,t.url)||!Na(n.queryParams,t.queryParams);case"always":return!0;case"paramsOrQueryParamsChange":return!ZS(n,t)||!Na(n.queryParams,t.queryParams);default:return!ZS(n,t)}}(s,o,o.routeConfig.runGuardsAndResolvers);c?i.canActivateChecks.push(new xL(r)):(o.data=s.data,o._resolvedData=s._resolvedData),nm(n,t,o.component?a?a.children:null:e,r,i),c&&a&&a.outlet&&a.outlet.isActivated&&i.canDeactivateChecks.push(new I_(a.outlet.component,s))}else s&&rm(t,a,i),i.canActivateChecks.push(new xL(r)),nm(n,null,o.component?a?a.children:null:e,r,i)})(s,o[s.value.outlet],e,r.concat([s.value]),i),delete o[s.value.outlet]}),Object.entries(o).forEach(([s,a])=>rm(a,e.getContext(s),i)),i}function rm(n,t,e){const r=uh(n),i=n.value;Object.entries(r).forEach(([o,s])=>{rm(s,i.component?t?t.children.getContext(o):null:t,e)}),e.canDeactivateChecks.push(new I_(i.component&&t&&t.outlet&&t.outlet.isActivated?t.outlet.component:null,i))}function im(n){return"function"==typeof n}function wL(n){return n instanceof p_||"EmptyError"===n?.name}const E_=Symbol("INITIAL_VALUE");function ph(){return Aa(n=>h_(n.map(t=>t.pipe(is(1),_u(E_)))).pipe(ct(t=>{for(const e of t)if(!0!==e){if(e===E_)return E_;if(!1===e||e instanceof ch)return e}return!0}),zi(t=>t!==E_),is(1)))}function TL(n){return function uo(...n){return Qa(n)}(to(t=>{if(Tu(t))throw gL(0,t)}),ct(t=>!0===t))}class D_{constructor(t){this.segmentGroup=t||null}}class SL{constructor(t){this.urlTree=t}}function fh(n){return jf(new D_(n))}function CL(n){return jf(new SL(n))}class ane{constructor(t,e){this.urlSerializer=t,this.urlTree=e}noMatchError(t){return new ze(4002,!1)}lineralizeSegments(t,e){let r=[],i=e.root;for(;;){if(r=r.concat(i.segments),0===i.numberOfChildren)return jt(r);if(i.numberOfChildren>1||!i.children[on])return jf(new ze(4e3,!1));i=i.children[on]}}applyRedirectCommands(t,e,r){return this.applyRedirectCreateUrlTree(e,this.urlSerializer.parse(e),t,r)}applyRedirectCreateUrlTree(t,e,r,i){const o=this.createSegmentGroup(t,e.root,r,i);return new ch(o,this.createQueryParams(e.queryParams,this.urlTree.queryParams),e.fragment)}createQueryParams(t,e){const r={};return Object.entries(t).forEach(([i,o])=>{if("string"==typeof o&&o.startsWith(":")){const a=o.substring(1);r[i]=e[a]}else r[i]=o}),r}createSegmentGroup(t,e,r,i){const o=this.createSegments(t,e.segments,r,i);let s={};return Object.entries(e.children).forEach(([a,c])=>{s[a]=this.createSegmentGroup(t,c,r,i)}),new zn(o,s)}createSegments(t,e,r,i){return e.map(o=>o.path.startsWith(":")?this.findPosParam(t,o,i):this.findOrReturn(o,r))}findPosParam(t,e,r){const i=r[e.path.substring(1)];if(!i)throw new ze(4001,!1);return i}findOrReturn(t,e){let r=0;for(const i of e){if(i.path===t.path)return e.splice(r),i;r++}return t}}const eC={matched:!1,consumedSegments:[],remainingSegments:[],parameters:{},positionalParamSegments:{}};function lne(n,t,e,r,i){const o=tC(n,t,e);return o.matched?(r=function Nte(n,t){return n.providers&&!n._injector&&(n._injector=A1(n.providers,t,`Route: ${n.path}`)),n._injector??t}(t,r),function ine(n,t,e,r){const i=t.canMatch;return i&&0!==i.length?jt(i.map(s=>{const a=hh(s,n);return ic(function qte(n){return n&&im(n.canMatch)}(a)?a.canMatch(t,e):n.runInContext(()=>a(t,e)))})).pipe(ph(),TL()):jt(!0)}(r,t,e).pipe(ct(s=>!0===s?o:{...eC}))):jt(o)}function tC(n,t,e){if(""===t.path)return"full"===t.pathMatch&&(n.hasChildren()||e.length>0)?{...eC}:{matched:!0,consumedSegments:[],remainingSegments:e,parameters:{},positionalParamSegments:{}};const i=(t.matcher||Vee)(e,n,t);if(!i)return{...eC};const o={};Object.entries(i.posParams??{}).forEach(([a,c])=>{o[a]=c.path});const s=i.consumed.length>0?{...o,...i.consumed[i.consumed.length-1].parameters}:o;return{matched:!0,consumedSegments:i.consumed,remainingSegments:e.slice(i.consumed.length),parameters:s,positionalParamSegments:i.posParams??{}}}function IL(n,t,e,r){return e.length>0&&function dne(n,t,e){return e.some(r=>k_(n,t,r)&&oa(r)!==on)}(n,e,r)?{segmentGroup:new zn(t,une(r,new zn(e,n.children))),slicedSegments:[]}:0===e.length&&function hne(n,t,e){return e.some(r=>k_(n,t,r))}(n,e,r)?{segmentGroup:new zn(n.segments,cne(n,0,e,r,n.children)),slicedSegments:e}:{segmentGroup:new zn(n.segments,n.children),slicedSegments:e}}function cne(n,t,e,r,i){const o={};for(const s of r)if(k_(n,e,s)&&!i[oa(s)]){const a=new zn([],{});o[oa(s)]=a}return{...i,...o}}function une(n,t){const e={};e[on]=t;for(const r of n)if(""===r.path&&oa(r)!==on){const i=new zn([],{});e[oa(r)]=i}return e}function k_(n,t,e){return(!(n.hasChildren()||t.length>0)||"full"!==e.pathMatch)&&""===e.path}class gne{constructor(t,e,r,i,o,s,a){this.injector=t,this.configLoader=e,this.rootComponentType=r,this.config=i,this.urlTree=o,this.paramsInheritanceStrategy=s,this.urlSerializer=a,this.allowRedirects=!0,this.applyRedirects=new ane(this.urlSerializer,this.urlTree)}noMatchError(t){return new ze(4002,!1)}recognize(){const t=IL(this.urlTree.root,[],[],this.config).segmentGroup;return this.processSegmentGroup(this.injector,this.config,t,on).pipe(xu(e=>{if(e instanceof SL)return this.allowRedirects=!1,this.urlTree=e.urlTree,this.match(e.urlTree);throw e instanceof D_?this.noMatchError(e):e}),ct(e=>{const r=new S_([],Object.freeze({}),Object.freeze({...this.urlTree.queryParams}),this.urlTree.fragment,{},on,this.rootComponentType,null,{}),i=new bl(r,e),o=new hL("",i),s=function ste(n,t,e=null,r=null){return tL(eL(n),t,e,r)}(r,[],this.urlTree.queryParams,this.urlTree.fragment);return s.queryParams=this.urlTree.queryParams,o.url=this.urlSerializer.serialize(s),this.inheritParamsAndData(o._root),{state:o,tree:s}}))}match(t){return this.processSegmentGroup(this.injector,this.config,t.root,on).pipe(xu(r=>{throw r instanceof D_?this.noMatchError(r):r}))}inheritParamsAndData(t){const e=t.value,r=dL(e,this.paramsInheritanceStrategy);e.params=Object.freeze(r.params),e.data=Object.freeze(r.data),t.children.forEach(i=>this.inheritParamsAndData(i))}processSegmentGroup(t,e,r,i){return 0===r.segments.length&&r.hasChildren()?this.processChildren(t,e,r):this.processSegment(t,e,r,r.segments,i,!0)}processChildren(t,e,r){const i=[];for(const o of Object.keys(r.children))"primary"===o?i.unshift(o):i.push(o);return tt(i).pipe(Gf(o=>{const s=r.children[o],a=function Fte(n,t){const e=n.filter(r=>oa(r)===t);return e.push(...n.filter(r=>oa(r)!==t)),e}(e,o);return this.processSegmentGroup(t,a,s,o)}),function Pee(n,t){return Rn(function Fee(n,t,e,r,i){return(o,s)=>{let a=e,c=t,u=0;o.subscribe(Bn(s,p=>{const m=u++;c=a?n(c,p,m):(a=!0,p),r&&s.next(c)},i&&(()=>{a&&s.next(c),s.complete()})))}}(n,t,arguments.length>=2,!0))}((o,s)=>(o.push(...s),o)),g_(null),function $ee(n,t){const e=arguments.length>=2;return r=>r.pipe(n?zi((i,o)=>n(i,o,r)):Hr,LS(1),e?g_(t):z$(()=>new p_))}(),yr(o=>{if(null===o)return fh(r);const s=EL(o);return function bne(n){n.sort((t,e)=>t.value.outlet===on?-1:e.value.outlet===on?1:t.value.outlet.localeCompare(e.value.outlet))}(s),jt(s)}))}processSegment(t,e,r,i,o,s){return tt(e).pipe(Gf(a=>this.processSegmentAgainstRoute(a._injector??t,e,a,r,i,o,s).pipe(xu(c=>{if(c instanceof D_)return jt(null);throw c}))),vu(a=>!!a),xu(a=>{if(wL(a))return function fne(n,t,e){return 0===t.length&&!n.children[e]}(r,i,o)?jt([]):fh(r);throw a}))}processSegmentAgainstRoute(t,e,r,i,o,s,a){return function pne(n,t,e,r){return!!(oa(n)===r||r!==on&&k_(t,e,n))&&("**"===n.path||tC(t,n,e).matched)}(r,i,o,s)?void 0===r.redirectTo?this.matchSegmentAgainstRoute(t,i,r,o,s,a):a&&this.allowRedirects?this.expandSegmentAgainstRouteUsingRedirect(t,i,e,r,o,s):fh(i):fh(i)}expandSegmentAgainstRouteUsingRedirect(t,e,r,i,o,s){return"**"===i.path?this.expandWildCardWithParamsAgainstRouteUsingRedirect(t,r,i,s):this.expandRegularSegmentAgainstRouteUsingRedirect(t,e,r,i,o,s)}expandWildCardWithParamsAgainstRouteUsingRedirect(t,e,r,i){const o=this.applyRedirects.applyRedirectCommands([],r.redirectTo,{});return r.redirectTo.startsWith("/")?CL(o):this.applyRedirects.lineralizeSegments(r,o).pipe(yr(s=>{const a=new zn(s,{});return this.processSegment(t,e,a,s,i,!1)}))}expandRegularSegmentAgainstRouteUsingRedirect(t,e,r,i,o,s){const{matched:a,consumedSegments:c,remainingSegments:u,positionalParamSegments:p}=tC(e,i,o);if(!a)return fh(e);const m=this.applyRedirects.applyRedirectCommands(c,i.redirectTo,p);return i.redirectTo.startsWith("/")?CL(m):this.applyRedirects.lineralizeSegments(i,m).pipe(yr(g=>this.processSegment(t,r,e,g.concat(u),s,!1)))}matchSegmentAgainstRoute(t,e,r,i,o,s){let a;if("**"===r.path){const c=i.length>0?j$(i).parameters:{};a=jt({snapshot:new S_(i,c,Object.freeze({...this.urlTree.queryParams}),this.urlTree.fragment,DL(r),oa(r),r.component??r._loadedComponent??null,r,kL(r)),consumedSegments:[],remainingSegments:[]}),e.children={}}else a=lne(e,r,i,t).pipe(ct(({matched:c,consumedSegments:u,remainingSegments:p,parameters:m})=>c?{snapshot:new S_(u,m,Object.freeze({...this.urlTree.queryParams}),this.urlTree.fragment,DL(r),oa(r),r.component??r._loadedComponent??null,r,kL(r)),consumedSegments:u,remainingSegments:p}:null));return a.pipe(Aa(c=>null===c?fh(e):this.getChildConfig(t=r._injector??t,r,i).pipe(Aa(({routes:u})=>{const p=r._loadedInjector??t,{snapshot:m,consumedSegments:g,remainingSegments:_}=c,{segmentGroup:x,slicedSegments:T}=IL(e,g,_,u);if(0===T.length&&x.hasChildren())return this.processChildren(p,u,x).pipe(ct(N=>null===N?null:[new bl(m,N)]));if(0===u.length&&0===T.length)return jt([new bl(m,[])]);const I=oa(r)===o;return this.processSegment(p,u,x,T,I?on:o,!0).pipe(ct(N=>[new bl(m,N)]))}))))}getChildConfig(t,e,r){return e.children?jt({routes:e.children,injector:t}):e.loadChildren?void 0!==e._loadedRoutes?jt({routes:e._loadedRoutes,injector:e._loadedInjector}):function rne(n,t,e,r){const i=t.canLoad;return void 0===i||0===i.length?jt(!0):jt(i.map(s=>{const a=hh(s,n);return ic(function jte(n){return n&&im(n.canLoad)}(a)?a.canLoad(t,e):n.runInContext(()=>a(t,e)))})).pipe(ph(),TL())}(t,e,r).pipe(yr(i=>i?this.configLoader.loadChildren(t,e).pipe(to(o=>{e._loadedRoutes=o.routes,e._loadedInjector=o.injector})):function sne(n){return jf(bL(!1,3))}())):jt({routes:[],injector:t})}}function yne(n){const t=n.value.routeConfig;return t&&""===t.path}function EL(n){const t=[],e=new Set;for(const r of n){if(!yne(r)){t.push(r);continue}const i=t.find(o=>r.value.routeConfig===o.value.routeConfig);void 0!==i?(i.children.push(...r.children),e.add(i)):t.push(r)}for(const r of e){const i=EL(r.children);t.push(new bl(r.value,i))}return t.filter(r=>!e.has(r))}function DL(n){return n.data||{}}function kL(n){return n.resolve||{}}function AL(n){return"string"==typeof n.title||null===n.title}function nC(n){return Aa(t=>{const e=n(t);return e?tt(e).pipe(ct(()=>t)):jt(t)})}const mh=new Qe("ROUTES");let rC=(()=>{class n{constructor(){this.componentLoaders=new WeakMap,this.childrenLoaders=new WeakMap,this.compiler=It(cP)}loadComponent(e){if(this.componentLoaders.get(e))return this.componentLoaders.get(e);if(e._loadedComponent)return jt(e._loadedComponent);this.onLoadStartListener&&this.onLoadStartListener(e);const r=ic(e.loadComponent()).pipe(ct(NL),to(o=>{this.onLoadEndListener&&this.onLoadEndListener(e),e._loadedComponent=o}),BS(()=>{this.componentLoaders.delete(e)})),i=new V$(r,()=>new Kt).pipe($S());return this.componentLoaders.set(e,i),i}loadChildren(e,r){if(this.childrenLoaders.get(r))return this.childrenLoaders.get(r);if(r._loadedRoutes)return jt({routes:r._loadedRoutes,injector:r._loadedInjector});this.onLoadStartListener&&this.onLoadStartListener(r);const o=this.loadModuleFactoryOrRoutes(r.loadChildren).pipe(ct(a=>{this.onLoadEndListener&&this.onLoadEndListener(r);let c,u;return Array.isArray(a)?u=a:(c=a.create(e).injector,u=c.get(mh,[],Bt.Self|Bt.Optional).flat()),{routes:u.map(JS),injector:c}}),BS(()=>{this.childrenLoaders.delete(r)})),s=new V$(o,()=>new Kt).pipe($S());return this.childrenLoaders.set(r,s),s}loadModuleFactoryOrRoutes(e){return ic(e()).pipe(ct(NL),yr(r=>r instanceof gF||Array.isArray(r)?jt(r):tt(this.compiler.compileModuleAsync(r))))}}return n.\u0275fac=function(e){return new(e||n)},n.\u0275prov=at({token:n,factory:n.\u0275fac,providedIn:"root"}),n})();function NL(n){return function Cne(n){return n&&"object"==typeof n&&"default"in n}(n)?n.default:n}let A_=(()=>{class n{get hasRequestedNavigation(){return 0!==this.navigationId}constructor(){this.currentNavigation=null,this.lastSuccessfulNavigation=null,this.events=new Kt,this.configLoader=It(rC),this.environmentInjector=It(ul),this.urlSerializer=It(qf),this.rootContexts=It(Jf),this.inputBindingEnabled=null!==It(C_,{optional:!0}),this.navigationId=0,this.afterPreactivation=()=>jt(void 0),this.rootComponentType=null,this.configLoader.onLoadEndListener=i=>this.events.next(new _te(i)),this.configLoader.onLoadStartListener=i=>this.events.next(new yte(i))}complete(){this.transitions?.complete()}handleNavigationRequest(e){const r=++this.navigationId;this.transitions?.next({...this.transitions.value,...e,id:r})}setupNavigations(e){return this.transitions=new Ds({id:0,currentUrlTree:e.currentUrlTree,currentRawUrl:e.currentUrlTree,extractedUrl:e.urlHandlingStrategy.extract(e.currentUrlTree),urlAfterRedirects:e.urlHandlingStrategy.extract(e.currentUrlTree),rawUrl:e.currentUrlTree,extras:{},resolve:null,reject:null,promise:Promise.resolve(!0),source:Zf,restoredState:null,currentSnapshot:e.routerState.snapshot,targetSnapshot:null,currentRouterState:e.routerState,targetRouterState:null,guards:{canActivateChecks:[],canDeactivateChecks:[]},guardsResult:null}),this.transitions.pipe(zi(r=>0!==r.id),ct(r=>({...r,extractedUrl:e.urlHandlingStrategy.extract(r.rawUrl)})),Aa(r=>{let i=!1,o=!1;return jt(r).pipe(to(s=>{this.currentNavigation={id:s.id,initialUrl:s.rawUrl,extractedUrl:s.extractedUrl,trigger:s.source,extras:s.extras,previousNavigation:this.lastSuccessfulNavigation?{...this.lastSuccessfulNavigation,previousNavigation:null}:null}}),Aa(s=>{const a=e.browserUrlTree.toString(),c=!e.navigated||s.extractedUrl.toString()!==a||a!==e.currentUrlTree.toString();if(!c&&"reload"!==(s.extras.onSameUrlNavigation??e.onSameUrlNavigation)){const p="";return this.events.next(new Qf(s.id,e.serializeUrl(r.rawUrl),p,0)),e.rawUrlTree=s.rawUrl,s.resolve(null),ho}if(e.urlHandlingStrategy.shouldProcessUrl(s.rawUrl))return OL(s.source)&&(e.browserUrlTree=s.extractedUrl),jt(s).pipe(Aa(p=>{const m=this.transitions?.getValue();return this.events.next(new HS(p.id,this.urlSerializer.serialize(p.extractedUrl),p.source,p.restoredState)),m!==this.transitions?.getValue()?ho:Promise.resolve(p)}),function _ne(n,t,e,r,i,o){return yr(s=>function mne(n,t,e,r,i,o,s="emptyOnly"){return new gne(n,t,e,r,i,s,o).recognize()}(n,t,e,r,s.extractedUrl,i,o).pipe(ct(({state:a,tree:c})=>({...s,targetSnapshot:a,urlAfterRedirects:c}))))}(this.environmentInjector,this.configLoader,this.rootComponentType,e.config,this.urlSerializer,e.paramsInheritanceStrategy),to(p=>{if(r.targetSnapshot=p.targetSnapshot,r.urlAfterRedirects=p.urlAfterRedirects,this.currentNavigation={...this.currentNavigation,finalUrl:p.urlAfterRedirects},"eager"===e.urlUpdateStrategy){if(!p.extras.skipLocationChange){const g=e.urlHandlingStrategy.merge(p.urlAfterRedirects,p.rawUrl);e.setBrowserUrl(g,p)}e.browserUrlTree=p.urlAfterRedirects}const m=new pte(p.id,this.urlSerializer.serialize(p.extractedUrl),this.urlSerializer.serialize(p.urlAfterRedirects),p.targetSnapshot);this.events.next(m)}));if(c&&e.urlHandlingStrategy.shouldProcessUrl(e.rawUrlTree)){const{id:p,extractedUrl:m,source:g,restoredState:_,extras:x}=s,T=new HS(p,this.urlSerializer.serialize(m),g,_);this.events.next(T);const I=uL(0,this.rootComponentType).snapshot;return jt(r={...s,targetSnapshot:I,urlAfterRedirects:m,extras:{...x,skipLocationChange:!1,replaceUrl:!1}})}{const p="";return this.events.next(new Qf(s.id,e.serializeUrl(r.extractedUrl),p,1)),e.rawUrlTree=s.rawUrl,s.resolve(null),ho}}),to(s=>{const a=new fte(s.id,this.urlSerializer.serialize(s.extractedUrl),this.urlSerializer.serialize(s.urlAfterRedirects),s.targetSnapshot);this.events.next(a)}),ct(s=>r={...s,guards:Lte(s.targetSnapshot,s.currentSnapshot,this.rootContexts)}),function Xte(n,t){return yr(e=>{const{targetSnapshot:r,currentSnapshot:i,guards:{canActivateChecks:o,canDeactivateChecks:s}}=e;return 0===s.length&&0===o.length?jt({...e,guardsResult:!0}):function Yte(n,t,e,r){return tt(n).pipe(yr(i=>function nne(n,t,e,r,i){const o=t&&t.routeConfig?t.routeConfig.canDeactivate:null;return o&&0!==o.length?jt(o.map(a=>{const c=tm(t)??i,u=hh(a,c);return ic(function Wte(n){return n&&im(n.canDeactivate)}(u)?u.canDeactivate(n,t,e,r):c.runInContext(()=>u(n,t,e,r))).pipe(vu())})).pipe(ph()):jt(!0)}(i.component,i.route,e,t,r)),vu(i=>!0!==i,!0))}(s,r,i,n).pipe(yr(a=>a&&function Ute(n){return"boolean"==typeof n}(a)?function Zte(n,t,e,r){return tt(t).pipe(Gf(i=>f_(function Jte(n,t){return null!==n&&t&&t(new vte(n)),jt(!0)}(i.route.parent,r),function Qte(n,t){return null!==n&&t&&t(new wte(n)),jt(!0)}(i.route,r),function tne(n,t,e){const r=t[t.length-1],o=t.slice(0,t.length-1).reverse().map(s=>function Bte(n){const t=n.routeConfig?n.routeConfig.canActivateChild:null;return t&&0!==t.length?{node:n,guards:t}:null}(s)).filter(s=>null!==s).map(s=>m_(()=>jt(s.guards.map(c=>{const u=tm(s.node)??e,p=hh(c,u);return ic(function Hte(n){return n&&im(n.canActivateChild)}(p)?p.canActivateChild(r,n):u.runInContext(()=>p(r,n))).pipe(vu())})).pipe(ph())));return jt(o).pipe(ph())}(n,i.path,e),function ene(n,t,e){const r=t.routeConfig?t.routeConfig.canActivate:null;if(!r||0===r.length)return jt(!0);const i=r.map(o=>m_(()=>{const s=tm(t)??e,a=hh(o,s);return ic(function Gte(n){return n&&im(n.canActivate)}(a)?a.canActivate(t,n):s.runInContext(()=>a(t,n))).pipe(vu())}));return jt(i).pipe(ph())}(n,i.route,e))),vu(i=>!0!==i,!0))}(r,o,n,t):jt(a)),ct(a=>({...e,guardsResult:a})))})}(this.environmentInjector,s=>this.events.next(s)),to(s=>{if(r.guardsResult=s.guardsResult,Tu(s.guardsResult))throw gL(0,s.guardsResult);const a=new mte(s.id,this.urlSerializer.serialize(s.extractedUrl),this.urlSerializer.serialize(s.urlAfterRedirects),s.targetSnapshot,!!s.guardsResult);this.events.next(a)}),zi(s=>!!s.guardsResult||(e.restoreHistory(s),this.cancelNavigationTransition(s,"",3),!1)),nC(s=>{if(s.guards.canActivateChecks.length)return jt(s).pipe(to(a=>{const c=new gte(a.id,this.urlSerializer.serialize(a.extractedUrl),this.urlSerializer.serialize(a.urlAfterRedirects),a.targetSnapshot);this.events.next(c)}),Aa(a=>{let c=!1;return jt(a).pipe(function vne(n,t){return yr(e=>{const{targetSnapshot:r,guards:{canActivateChecks:i}}=e;if(!i.length)return jt(e);let o=0;return tt(i).pipe(Gf(s=>function xne(n,t,e,r){const i=n.routeConfig,o=n._resolve;return void 0!==i?.title&&!AL(i)&&(o[Hf]=i.title),function wne(n,t,e,r){const i=function Tne(n){return[...Object.keys(n),...Object.getOwnPropertySymbols(n)]}(n);if(0===i.length)return jt({});const o={};return tt(i).pipe(yr(s=>function Sne(n,t,e,r){const i=tm(t)??r,o=hh(n,i);return ic(o.resolve?o.resolve(t,e):i.runInContext(()=>o(t,e)))}(n[s],t,e,r).pipe(vu(),to(a=>{o[s]=a}))),LS(1),function Lee(n){return ct(()=>n)}(o),xu(s=>wL(s)?ho:jf(s)))}(o,n,t,r).pipe(ct(s=>(n._resolvedData=s,n.data=dL(n,e).resolve,i&&AL(i)&&(n.data[Hf]=i.title),null)))}(s.route,r,n,t)),to(()=>o++),LS(1),yr(s=>o===i.length?jt(e):ho))})}(e.paramsInheritanceStrategy,this.environmentInjector),to({next:()=>c=!0,complete:()=>{c||(e.restoreHistory(a),this.cancelNavigationTransition(a,"",2))}}))}),to(a=>{const c=new bte(a.id,this.urlSerializer.serialize(a.extractedUrl),this.urlSerializer.serialize(a.urlAfterRedirects),a.targetSnapshot);this.events.next(c)}))}),nC(s=>{const a=c=>{const u=[];c.routeConfig?.loadComponent&&!c.routeConfig._loadedComponent&&u.push(this.configLoader.loadComponent(c.routeConfig).pipe(to(p=>{c.component=p}),ct(()=>{})));for(const p of c.children)u.push(...a(p));return u};return h_(a(s.targetSnapshot.root)).pipe(g_(),is(1))}),nC(()=>this.afterPreactivation()),ct(s=>{const a=function Dte(n,t,e){const r=em(n,t._root,e?e._root:void 0);return new cL(r,t)}(e.routeReuseStrategy,s.targetSnapshot,s.currentRouterState);return r={...s,targetRouterState:a}}),to(s=>{e.currentUrlTree=s.urlAfterRedirects,e.rawUrlTree=e.urlHandlingStrategy.merge(s.urlAfterRedirects,s.rawUrl),e.routerState=s.targetRouterState,"deferred"===e.urlUpdateStrategy&&(s.extras.skipLocationChange||e.setBrowserUrl(e.rawUrlTree,s),e.browserUrlTree=s.urlAfterRedirects)}),((n,t,e,r)=>ct(i=>(new $te(t,i.targetRouterState,i.currentRouterState,e,r).activate(n),i)))(this.rootContexts,e.routeReuseStrategy,s=>this.events.next(s),this.inputBindingEnabled),is(1),to({next:s=>{i=!0,this.lastSuccessfulNavigation=this.currentNavigation,e.navigated=!0,this.events.next(new Su(s.id,this.urlSerializer.serialize(s.extractedUrl),this.urlSerializer.serialize(e.currentUrlTree))),e.titleStrategy?.updateTitle(s.targetRouterState.snapshot),s.resolve(!0)},complete:()=>{i=!0}}),BS(()=>{i||o||this.cancelNavigationTransition(r,"",1),this.currentNavigation?.id===r.id&&(this.currentNavigation=null)}),xu(s=>{if(o=!0,_L(s)){yL(s)||(e.navigated=!0,e.restoreHistory(r,!0));const a=new T_(r.id,this.urlSerializer.serialize(r.extractedUrl),s.message,s.cancellationCode);if(this.events.next(a),yL(s)){const c=e.urlHandlingStrategy.merge(s.url,e.rawUrlTree),u={skipLocationChange:r.extras.skipLocationChange,replaceUrl:"eager"===e.urlUpdateStrategy||OL(r.source)};e.scheduleNavigation(c,Zf,null,u,{resolve:r.resolve,reject:r.reject,promise:r.promise})}else r.resolve(!1)}else{e.restoreHistory(r,!0);const a=new WS(r.id,this.urlSerializer.serialize(r.extractedUrl),s,r.targetSnapshot??void 0);this.events.next(a);try{r.resolve(e.errorHandler(s))}catch(c){r.reject(c)}}return ho}))}))}cancelNavigationTransition(e,r,i){const o=new T_(e.id,this.urlSerializer.serialize(e.extractedUrl),r,i);this.events.next(o),e.resolve(!1)}}return n.\u0275fac=function(e){return new(e||n)},n.\u0275prov=at({token:n,factory:n.\u0275fac,providedIn:"root"}),n})();function OL(n){return n!==Zf}let RL=(()=>{class n{buildTitle(e){let r,i=e.root;for(;void 0!==i;)r=this.getResolvedTitleForRoute(i)??r,i=i.children.find(o=>o.outlet===on);return r}getResolvedTitleForRoute(e){return e.data[Hf]}}return n.\u0275fac=function(e){return new(e||n)},n.\u0275prov=at({token:n,factory:function(){return It(Ine)},providedIn:"root"}),n})(),Ine=(()=>{class n extends RL{constructor(e){super(),this.title=e}updateTitle(e){const r=this.buildTitle(e);void 0!==r&&this.title.setTitle(r)}}return n.\u0275fac=function(e){return new(e||n)(Fe(R$))},n.\u0275prov=at({token:n,factory:n.\u0275fac,providedIn:"root"}),n})(),Ene=(()=>{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275prov=at({token:n,factory:function(){return It(kne)},providedIn:"root"}),n})();class Dne{shouldDetach(t){return!1}store(t,e){}shouldAttach(t){return!1}retrieve(t){return null}shouldReuseRoute(t,e){return t.routeConfig===e.routeConfig}}let kne=(()=>{class n extends Dne{}return n.\u0275fac=function(){let t;return function(r){return(t||(t=qr(n)))(r||n)}}(),n.\u0275prov=at({token:n,factory:n.\u0275fac,providedIn:"root"}),n})();const N_=new Qe("",{providedIn:"root",factory:()=>({})});let Ane=(()=>{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275prov=at({token:n,factory:function(){return It(Nne)},providedIn:"root"}),n})(),Nne=(()=>{class n{shouldProcessUrl(e){return!0}extract(e){return e}merge(e,r){return e}}return n.\u0275fac=function(e){return new(e||n)},n.\u0275prov=at({token:n,factory:n.\u0275fac,providedIn:"root"}),n})();var os=(()=>((os=os||{})[os.COMPLETE=0]="COMPLETE",os[os.FAILED=1]="FAILED",os[os.REDIRECTING=2]="REDIRECTING",os))();function ML(n,t){n.events.pipe(zi(e=>e instanceof Su||e instanceof T_||e instanceof WS||e instanceof Qf),ct(e=>e instanceof Su||e instanceof Qf?os.COMPLETE:e instanceof T_&&(0===e.code||1===e.code)?os.REDIRECTING:os.FAILED),zi(e=>e!==os.REDIRECTING),is(1)).subscribe(()=>{t()})}function One(n){throw n}function Rne(n,t,e){return t.parse("/")}const Mne={paths:"exact",fragment:"ignored",matrixParams:"ignored",queryParams:"exact"},Fne={paths:"subset",fragment:"ignored",matrixParams:"ignored",queryParams:"subset"};let ks=(()=>{class n{get navigationId(){return this.navigationTransitions.navigationId}get browserPageId(){if("computed"===this.canceledNavigationResolution)return this.location.getState()?.\u0275routerPageId}get events(){return this.navigationTransitions.events}constructor(){this.disposed=!1,this.currentPageId=0,this.console=It(lP),this.isNgZoneEnabled=!1,this.options=It(N_,{optional:!0})||{},this.pendingTasks=It(HP),this.errorHandler=this.options.errorHandler||One,this.malformedUriErrorHandler=this.options.malformedUriErrorHandler||Rne,this.navigated=!1,this.lastSuccessfulId=-1,this.urlHandlingStrategy=It(Ane),this.routeReuseStrategy=It(Ene),this.titleStrategy=It(RL),this.onSameUrlNavigation=this.options.onSameUrlNavigation||"ignore",this.paramsInheritanceStrategy=this.options.paramsInheritanceStrategy||"emptyOnly",this.urlUpdateStrategy=this.options.urlUpdateStrategy||"deferred",this.canceledNavigationResolution=this.options.canceledNavigationResolution||"replace",this.config=It(mh,{optional:!0})?.flat()??[],this.navigationTransitions=It(A_),this.urlSerializer=It(qf),this.location=It($f),this.componentInputBindingEnabled=!!It(C_,{optional:!0}),this.isNgZoneEnabled=It(Vt)instanceof Vt&&Vt.isInAngularZone(),this.resetConfig(this.config),this.currentUrlTree=new ch,this.rawUrlTree=this.currentUrlTree,this.browserUrlTree=this.currentUrlTree,this.routerState=uL(0,null),this.navigationTransitions.setupNavigations(this).subscribe(e=>{this.lastSuccessfulId=e.id,this.currentPageId=this.browserPageId??0},e=>{this.console.warn(`Unhandled Navigation Error: ${e}`)})}resetRootComponentType(e){this.routerState.root.component=e,this.navigationTransitions.rootComponentType=e}initialNavigation(){if(this.setUpLocationChangeListener(),!this.navigationTransitions.hasRequestedNavigation){const e=this.location.getState();this.navigateToSyncWithBrowser(this.location.path(!0),Zf,e)}}setUpLocationChangeListener(){this.locationSubscription||(this.locationSubscription=this.location.subscribe(e=>{const r="popstate"===e.type?"popstate":"hashchange";"popstate"===r&&setTimeout(()=>{this.navigateToSyncWithBrowser(e.url,r,e.state)},0)}))}navigateToSyncWithBrowser(e,r,i){const o={replaceUrl:!0},s=i?.navigationId?i:null;if(i){const c={...i};delete c.navigationId,delete c.\u0275routerPageId,0!==Object.keys(c).length&&(o.state=c)}const a=this.parseUrl(e);this.scheduleNavigation(a,r,s,o)}get url(){return this.serializeUrl(this.currentUrlTree)}getCurrentNavigation(){return this.navigationTransitions.currentNavigation}get lastSuccessfulNavigation(){return this.navigationTransitions.lastSuccessfulNavigation}resetConfig(e){this.config=e.map(JS),this.navigated=!1,this.lastSuccessfulId=-1}ngOnDestroy(){this.dispose()}dispose(){this.navigationTransitions.complete(),this.locationSubscription&&(this.locationSubscription.unsubscribe(),this.locationSubscription=void 0),this.disposed=!0}createUrlTree(e,r={}){const{relativeTo:i,queryParams:o,fragment:s,queryParamsHandling:a,preserveFragment:c}=r,u=c?this.currentUrlTree.fragment:s;let m,p=null;switch(a){case"merge":p={...this.currentUrlTree.queryParams,...o};break;case"preserve":p=this.currentUrlTree.queryParams;break;default:p=o||null}null!==p&&(p=this.removeEmptyProps(p));try{m=eL(i?i.snapshot:this.routerState.snapshot.root)}catch{("string"!=typeof e[0]||!e[0].startsWith("/"))&&(e=[]),m=this.currentUrlTree.root}return tL(m,e,p,u??null)}navigateByUrl(e,r={skipLocationChange:!1}){const i=Tu(e)?e:this.parseUrl(e),o=this.urlHandlingStrategy.merge(i,this.rawUrlTree);return this.scheduleNavigation(o,Zf,null,r)}navigate(e,r={skipLocationChange:!1}){return function Pne(n){for(let t=0;t<n.length;t++)if(null==n[t])throw new ze(4008,!1)}(e),this.navigateByUrl(this.createUrlTree(e,r),r)}serializeUrl(e){return this.urlSerializer.serialize(e)}parseUrl(e){let r;try{r=this.urlSerializer.parse(e)}catch(i){r=this.malformedUriErrorHandler(i,this.urlSerializer,e)}return r}isActive(e,r){let i;if(i=!0===r?{...Mne}:!1===r?{...Fne}:r,Tu(e))return H$(this.currentUrlTree,e,i);const o=this.parseUrl(e);return H$(this.currentUrlTree,o,i)}removeEmptyProps(e){return Object.keys(e).reduce((r,i)=>{const o=e[i];return null!=o&&(r[i]=o),r},{})}scheduleNavigation(e,r,i,o,s){if(this.disposed)return Promise.resolve(!1);let a,c,u;s?(a=s.resolve,c=s.reject,u=s.promise):u=new Promise((m,g)=>{a=m,c=g});const p=this.pendingTasks.add();return ML(this,()=>{Promise.resolve().then(()=>this.pendingTasks.remove(p))}),this.navigationTransitions.handleNavigationRequest({source:r,restoredState:i,currentUrlTree:this.currentUrlTree,currentRawUrl:this.currentUrlTree,rawUrl:e,extras:o,resolve:a,reject:c,promise:u,currentSnapshot:this.routerState.snapshot,currentRouterState:this.routerState}),u.catch(m=>Promise.reject(m))}setBrowserUrl(e,r){const i=this.urlSerializer.serialize(e);if(this.location.isCurrentPathEqualTo(i)||r.extras.replaceUrl){const s={...r.extras.state,...this.generateNgRouterState(r.id,this.browserPageId)};this.location.replaceState(i,"",s)}else{const o={...r.extras.state,...this.generateNgRouterState(r.id,(this.browserPageId??0)+1)};this.location.go(i,"",o)}}restoreHistory(e,r=!1){if("computed"===this.canceledNavigationResolution){const o=this.currentPageId-(this.browserPageId??this.currentPageId);0!==o?this.location.historyGo(o):this.currentUrlTree===this.getCurrentNavigation()?.finalUrl&&0===o&&(this.resetState(e),this.browserUrlTree=e.currentUrlTree,this.resetUrlToCurrentUrlTree())}else"replace"===this.canceledNavigationResolution&&(r&&this.resetState(e),this.resetUrlToCurrentUrlTree())}resetState(e){this.routerState=e.currentRouterState,this.currentUrlTree=e.currentUrlTree,this.rawUrlTree=this.urlHandlingStrategy.merge(this.currentUrlTree,e.rawUrl)}resetUrlToCurrentUrlTree(){this.location.replaceState(this.urlSerializer.serialize(this.rawUrlTree),"",this.generateNgRouterState(this.lastSuccessfulId,this.currentPageId))}generateNgRouterState(e,r){return"computed"===this.canceledNavigationResolution?{navigationId:e,\u0275routerPageId:r}:{navigationId:e}}}return n.\u0275fac=function(e){return new(e||n)},n.\u0275prov=at({token:n,factory:n.\u0275fac,providedIn:"root"}),n})();class FL{}let Bne=(()=>{class n{constructor(e,r,i,o,s){this.router=e,this.injector=i,this.preloadingStrategy=o,this.loader=s}setUpPreloading(){this.subscription=this.router.events.pipe(zi(e=>e instanceof Su),Gf(()=>this.preload())).subscribe(()=>{})}preload(){return this.processRoutes(this.injector,this.router.config)}ngOnDestroy(){this.subscription&&this.subscription.unsubscribe()}processRoutes(e,r){const i=[];for(const o of r){o.providers&&!o._injector&&(o._injector=A1(o.providers,e,`Route: ${o.path}`));const s=o._injector??e,a=o._loadedInjector??s;(o.loadChildren&&!o._loadedRoutes&&void 0===o.canLoad||o.loadComponent&&!o._loadedComponent)&&i.push(this.preloadConfig(s,o)),(o.children||o._loadedRoutes)&&i.push(this.processRoutes(a,o.children??o._loadedRoutes))}return tt(i).pipe(el())}preloadConfig(e,r){return this.preloadingStrategy.preload(r,()=>{let i;i=r.loadChildren&&void 0===r.canLoad?this.loader.loadChildren(e,r):jt(null);const o=i.pipe(yr(s=>null===s?jt(void 0):(r._loadedRoutes=s.routes,r._loadedInjector=s.injector,this.processRoutes(s.injector??e,s.routes))));return r.loadComponent&&!r._loadedComponent?tt([o,this.loader.loadComponent(r)]).pipe(el()):o})}}return n.\u0275fac=function(e){return new(e||n)(Fe(ks),Fe(cP),Fe(ul),Fe(FL),Fe(rC))},n.\u0275prov=at({token:n,factory:n.\u0275fac,providedIn:"root"}),n})();const oC=new Qe("");let PL=(()=>{class n{constructor(e,r,i,o,s={}){this.urlSerializer=e,this.transitions=r,this.viewportScroller=i,this.zone=o,this.options=s,this.lastId=0,this.lastSource="imperative",this.restoredId=0,this.store={},s.scrollPositionRestoration=s.scrollPositionRestoration||"disabled",s.anchorScrolling=s.anchorScrolling||"disabled"}init(){"disabled"!==this.options.scrollPositionRestoration&&this.viewportScroller.setHistoryScrollRestoration("manual"),this.routerEventsSubscription=this.createScrollEvents(),this.scrollEventsSubscription=this.consumeScrollEvents()}createScrollEvents(){return this.transitions.events.subscribe(e=>{e instanceof HS?(this.store[this.lastId]=this.viewportScroller.getScrollPosition(),this.lastSource=e.navigationTrigger,this.restoredId=e.restoredState?e.restoredState.navigationId:0):e instanceof Su?(this.lastId=e.id,this.scheduleScrollEvent(e,this.urlSerializer.parse(e.urlAfterRedirects).fragment)):e instanceof Qf&&0===e.code&&(this.lastSource=void 0,this.restoredId=0,this.scheduleScrollEvent(e,this.urlSerializer.parse(e.url).fragment))})}consumeScrollEvents(){return this.transitions.events.subscribe(e=>{e instanceof aL&&(e.position?"top"===this.options.scrollPositionRestoration?this.viewportScroller.scrollToPosition([0,0]):"enabled"===this.options.scrollPositionRestoration&&this.viewportScroller.scrollToPosition(e.position):e.anchor&&"enabled"===this.options.anchorScrolling?this.viewportScroller.scrollToAnchor(e.anchor):"disabled"!==this.options.scrollPositionRestoration&&this.viewportScroller.scrollToPosition([0,0]))})}scheduleScrollEvent(e,r){this.zone.runOutsideAngular(()=>{setTimeout(()=>{this.zone.run(()=>{this.transitions.events.next(new aL(e,"popstate"===this.lastSource?this.store[this.restoredId]:null,r))})},0)})}ngOnDestroy(){this.routerEventsSubscription?.unsubscribe(),this.scrollEventsSubscription?.unsubscribe()}}return n.\u0275fac=function(e){wy()},n.\u0275prov=at({token:n,factory:n.\u0275fac}),n})();function yl(n,t){return{\u0275kind:n,\u0275providers:t}}function LL(){const n=It(Qi);return t=>{const e=n.get(ec);if(t!==e.components[0])return;const r=n.get(ks),i=n.get(BL);1===n.get(sC)&&r.initialNavigation(),n.get(VL,null,Bt.Optional)?.setUpPreloading(),n.get(oC,null,Bt.Optional)?.init(),r.resetRootComponentType(e.componentTypes[0]),i.closed||(i.next(),i.complete(),i.unsubscribe())}}const BL=new Qe("",{factory:()=>new Kt}),sC=new Qe("",{providedIn:"root",factory:()=>1}),VL=new Qe("");function jne(n){return yl(0,[{provide:VL,useExisting:Bne},{provide:FL,useExisting:n}])}const zL=new Qe("ROUTER_FORROOT_GUARD"),Hne=[$f,{provide:qf,useClass:VS},ks,Jf,{provide:dh,useFactory:function $L(n){return n.routerState.root},deps:[ks]},rC,[]];function Wne(){return new vP("Router",ks)}let UL=(()=>{class n{constructor(e){}static forRoot(e,r){return{ngModule:n,providers:[Hne,[],{provide:mh,multi:!0,useValue:e},{provide:zL,useFactory:Yne,deps:[[ks,new ey,new ty]]},{provide:N_,useValue:r||{}},r?.useHash?{provide:yu,useClass:rQ}:{provide:yu,useClass:ZP},{provide:oC,useFactory:()=>{const n=It(vJ),t=It(Vt),e=It(N_),r=It(A_),i=It(qf);return e.scrollOffset&&n.setOffset(e.scrollOffset),new PL(i,r,n,t,e)}},r?.preloadingStrategy?jne(r.preloadingStrategy).\u0275providers:[],{provide:vP,multi:!0,useFactory:Wne},r?.initialNavigation?Zne(r):[],r?.bindToComponentInputs?yl(8,[mL,{provide:C_,useExisting:mL}]).\u0275providers:[],[{provide:jL,useFactory:LL},{provide:eS,multi:!0,useExisting:jL}]]}}static forChild(e){return{ngModule:n,providers:[{provide:mh,multi:!0,useValue:e}]}}}return n.\u0275fac=function(e){return new(e||n)(Fe(zL,8))},n.\u0275mod=Vn({type:n}),n.\u0275inj=Pn({}),n})();function Yne(n){return"guarded"}function Zne(n){return["disabled"===n.initialNavigation?yl(3,[{provide:H1,multi:!0,useFactory:()=>{const t=It(ks);return()=>{t.setUpLocationChangeListener()}}},{provide:sC,useValue:2}]).\u0275providers:[],"enabledBlocking"===n.initialNavigation?yl(2,[{provide:sC,useValue:0},{provide:H1,multi:!0,deps:[Qi],useFactory:t=>{const e=t.get(tQ,Promise.resolve());return()=>e.then(()=>new Promise(r=>{const i=t.get(ks),o=t.get(BL);ML(i,()=>{r(!0)}),t.get(A_).afterPreactivation=()=>(r(!0),o.closed?jt(void 0):o),i.initialNavigation()}))}}]).\u0275providers:[]]}const jL=new Qe(""),Jne=[];let ere=(()=>{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275mod=Vn({type:n}),n.\u0275inj=Pn({imports:[UL.forRoot(Jne),UL]}),n})();function GL(n,t,e,r,i,o,s){try{var a=n[o](s),c=a.value}catch(u){return void e(u)}a.done?t(c):Promise.resolve(c).then(r,i)}function $e(n){return function(){var t=this,e=arguments;return new Promise(function(r,i){var o=n.apply(t,e);function s(c){GL(o,r,i,s,a,"next",c)}function a(c){GL(o,r,i,s,a,"throw",c)}s(void 0)})}}class HL{constructor(t,e){this.backend=t,this.dataMover=e,this.data=new WeakMap,this.dataIdsCount=0}get(t){return this.data.has(t)||this.dataMover.moveData(this.backend,t),this.data.get(t)}set(t,e){this.dataIdsCount++,this.data.set(t,e)}has(t){return this.data.has(t)}delete(t){return this.dataIdsCount--,this.data.delete(t)}numDataIds(){return this.dataIdsCount}}class aC{refCount(t){return Bo("refCount")}incRef(t){return Bo("incRef")}timerAvailable(){return!0}time(t){return Bo("time")}read(t){return Bo("read")}readSync(t){return Bo("readSync")}readToGPU(t,e){return Bo("readToGPU")}numDataIds(){return Bo("numDataIds")}disposeData(t,e){return Bo("disposeData")}write(t,e,r){return Bo("write")}move(t,e,r,i,o){return Bo("move")}createTensorFromGPUData(t,e,r){return Bo("createTensorFromGPUData")}memory(){return Bo("memory")}floatPrecision(){return Bo("floatPrecision")}epsilon(){return 32===this.floatPrecision()?1e-7:1e-4}dispose(){return Bo("dispose")}}function Bo(n){throw new Error(`'${n}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`)}function WL(n){let t=n.length,e=0;for(;t>0;)e=Math.random()*t|0,t--,oc(n,t,e)}function Cu(n,t,e){return Math.max(n,Math.min(t,e))}function lC(n){return n%2==0?n:n+1}function oc(n,t,e){const r=n[t];n[t]=n[e],n[e]=r}function Z(n,t){if(!n)throw new Error("string"==typeof t?t:t())}function Vo(n,t,e=""){Z(mn(n,t),()=>e+` Shapes ${n} and ${t} must match`)}function gh(n){Z(null!=n,()=>"The input to the tensor constructor must be a non-null value.")}function Me(n){if(0===n.length)return 1;let t=n[0];for(let e=1;e<n.length;e++)t*=n[e];return t}function mn(n,t){if(n===t)return!0;if(null==n||null==t||n.length!==t.length)return!1;for(let e=0;e<n.length;e++)if(n[e]!==t[e])return!1;return!0}function bh(n){return n%1==0}function cC(n){const t=Math.ceil(Math.sqrt(n));return[t,Math.ceil(n/t)]}function yh(n,t){return t<=n.length?n:n+" ".repeat(t-n.length)}function qL(n,t=(i=>0),e,r){return new Promise((i,o)=>{let s=0;const a=()=>{if(n())return void i();s++;const c=t(s);null!=e&&s>=e?o():null!=r?r(a,c):setTimeout(a,c)};a()})}function KL(n,t){let e=1,r=-1;for(let o=0;o<n.length;++o)if(n[o]>=0)e*=n[o];else if(-1===n[o]){if(-1!==r)throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${r} and dim ${o}`);r=o}else if(n[o]<0)throw Error(`Shapes can not be < 0. Found ${n[o]} at dim ${o}`);if(-1===r){if(t>0&&t!==e)throw Error(`Size(${t}) must match the product of shape ${n}`);return n}if(0===e)throw Error(`Cannot infer the missing size in [${n}] when there are 0 elements`);if(t%e!=0)throw Error(`The implicit shape can't be a fractional number. Got ${t} / ${e}`);const i=n.slice();return i[r]=t/e,i}function cn(n,t){const e=t.length;return Z((n=null==n?t.map((r,i)=>i):[].concat(n)).every(r=>r>=-e&&r<e),()=>`All values in axis param must be in range [-${e}, ${e}) but got axis ${n}`),Z(n.every(r=>bh(r)),()=>`All values in axis param must be integers but got axis ${n}`),n.map(r=>r<0?e+r:r)}function sc(n,t){const e=[],r=[],i=null!=t&&Array.isArray(t)&&0===t.length,o=null==t||i?null:cn(t,n).sort();let s=0;for(let a=0;a<n.length;++a){if(null!=o){if(o[s]===a&&1!==n[a])throw new Error(`Can't squeeze axis ${a} since its dim '${n[a]}' is not 1`);(null==o[s]||o[s]>a)&&1===n[a]&&(e.push(n[a]),r.push(a)),o[s]<=a&&s++}1!==n[a]&&(e.push(n[a]),r.push(a))}return{newShape:e,keptDims:r}}function Ei(n,t){return Or(n,t)}function Or(n,t){let e=null;if(null==n||"float32"===n)e=new Float32Array(t);else if("int32"===n)e=new Int32Array(t);else if("bool"===n)e=new Uint8Array(t);else{if("string"!==n)throw new Error(`Unknown data type ${n}`);e=new Array(t)}return e}function XL(n,t){return!("complex64"===t||"float32"===t&&"complex64"!==n||"int32"===t&&"float32"!==n&&"complex64"!==n||"bool"===t&&"bool"===n)}function O_(n){if("float32"===n||"int32"===n)return 4;if("complex64"===n)return 8;if("bool"===n)return 1;throw new Error(`Unknown dtype ${n}`)}function om(n){return"string"==typeof n||n instanceof String}function uC(n){return"number"==typeof n}function _h(n){return Array.isArray(n)?_h(n[0]):n instanceof Float32Array?"float32":n instanceof Int32Array||n instanceof Uint8Array||n instanceof Uint8ClampedArray?"int32":uC(n)?"float32":om(n)?"string":function lre(n){return"boolean"==typeof n}(n)?"bool":"float32"}function dC(n){return!!(n&&n.constructor&&n.call&&n.apply)}function hC(n,t){for(let e=t;e<n;++e)if(n%e==0)return e;return n}function Rt(n){const t=n.length;if(t<2)return[];const e=new Array(t-1);e[t-2]=n[t-1];for(let r=t-3;r>=0;--r)e[r]=e[r+1]*n[r+1];return e}function YL(n,t,e,r=!1){const i=new Array;if(1===t.length){const o=t[0]*(r?2:1);for(let s=0;s<o;s++)i[s]=e[n+s]}else{const o=t[0],s=t.slice(1),a=s.reduce((c,u)=>c*u)*(r?2:1);for(let c=0;c<o;c++)i[c]=YL(n+c*a,s,e,r)}return i}function As(n,t,e=!1){if(0===n.length)return t[0];const r=n.reduce((i,o)=>i*o)*(e?2:1);if(0===r)return[];if(r!==t.length)throw new Error(`[${n}] does not match the input size ${t.length}${e?" for a complex tensor":""}.`);return YL(0,n,t,e)}function pC(n,t){const e=Ui(n,t);for(let r=0;r<e.length;r++)e[r]=1;return e}function Ui(n,t){if(null==t||"float32"===t||"complex64"===t)return new Float32Array(n);if("int32"===t)return new Int32Array(n);if("bool"===t)return new Uint8Array(n);throw new Error(`Unknown data type ${t}`)}function ZL(n,t){const e=n.reduce((r,i)=>r*i,1);if(null==t||"float32"===t)return As(n,new Float32Array(e));if("int32"===t)return As(n,new Int32Array(e));if("bool"===t)return As(n,new Uint8Array(e));throw new Error(`Unknown data type ${t}`)}function ss(n){n.forEach(t=>{Z(Number.isInteger(t)&&t>=0,()=>`Tensor must have a shape comprised of positive integers but got shape [${n}].`)})}function Ra(n,t,e){if(0===t)return 0;if(1===t)return n[0];let r=n[n.length-1];for(let i=0;i<n.length-1;++i)r+=e[i]*n[i];return r}function vh(n,t,e){if(0===t)return[];if(1===t)return[n];const r=new Array(t);for(let i=0;i<r.length-1;++i)r[i]=Math.floor(n/e[i]),n-=r[i]*e[i];return r[r.length-1]=n,r}function Iu(n){return n&&n.then&&"function"==typeof n.then}const QL="tfjsflags";class ure{constructor(t){this.global=t,this.flags={},this.flagRegistry={},this.urlFlags={},this.getQueryParams=dre,this.populateURLFlags()}setPlatform(t,e){null!=this.platform&&(Ie().getBool("IS_TEST")||Ie().getBool("PROD")||console.warn(`Platform ${this.platformName} has already been set. Overwriting the platform with ${t}.`)),this.platformName=t,this.platform=e}registerFlag(t,e,r){if(this.flagRegistry[t]={evaluationFn:e,setHook:r},null!=this.urlFlags[t]){const i=this.urlFlags[t];Ie().getBool("IS_TEST")||Ie().getBool("PROD")||console.warn(`Setting feature override from URL ${t}: ${i}.`),this.set(t,i)}}getAsync(t){var e=this;return $e(function*(){return t in e.flags||(e.flags[t]=yield e.evaluateFlag(t)),e.flags[t]})()}get(t){if(t in this.flags)return this.flags[t];const e=this.evaluateFlag(t);if(Iu(e))throw new Error(`Flag ${t} cannot be synchronously evaluated. Please use getAsync() instead.`);return this.flags[t]=e,this.flags[t]}getNumber(t){return this.get(t)}getBool(t){return this.get(t)}getString(t){return this.get(t)}getFlags(){return this.flags}get features(){return this.flags}set(t,e){if(null==this.flagRegistry[t])throw new Error(`Cannot set flag ${t} as it has not been registered.`);this.flags[t]=e,null!=this.flagRegistry[t].setHook&&this.flagRegistry[t].setHook(e)}evaluateFlag(t){if(null==this.flagRegistry[t])throw new Error(`Cannot evaluate flag '${t}': no evaluation function found.`);return this.flagRegistry[t].evaluationFn()}setFlags(t){this.flags=Object.assign({},t)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if(typeof this.global>"u"||typeof this.global.location>"u"||typeof this.global.location.search>"u")return;const t=this.getQueryParams(this.global.location.search);QL in t&&t[QL].split(",").forEach(r=>{const[i,o]=r.split(":");this.urlFlags[i]=function pre(n,t){const e=t.toLowerCase();return"true"===e||"false"===e?"true"===e:""+ +e===e?+e:t}(0,o)})}}function dre(n){const t={};return n.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,(e,...r)=>(function hre(n,t,e){n[decodeURIComponent(t)]=decodeURIComponent(e||"")}(t,r[0],r[1]),r.join("="))),t}function Ie(){return JL}let fC,JL=null;function e3(){if(null==fC){let n;if(typeof window<"u")n=window;else if(typeof global<"u")n=global;else if(typeof process<"u")n=process;else{if(!(typeof self<"u"))throw new Error("Could not find a global object");n=self}fC=n}return fC}function mC(n,t){const e=function mre(){const n=e3();return null==n._tfGlobals&&(n._tfGlobals=new Map),n._tfGlobals}();if(e.has(n))return e.get(n);{const r=t();return e.set(n,r),e.get(n)}}const R_="Abs",sm="Acos",am="Acosh",xh="Add",M_="AddN",F_="ArgMax",P_="ArgMin",lm="Asin",cm="Asinh",um="Atan",dm="Atanh",hm="Atan2",$_="AvgPool",yC="AvgPoolGrad",L_="AvgPool3D",_C="AvgPool3DGrad",B_="BatchMatMul",V_="BatchToSpaceND",vC="Bincount",xC="BitwiseAnd",wC="BroadcastArgs",pm="Cast",fm="Ceil",mm="ClipByValue",TC="Complex",z_="ComplexAbs",U_="Concat",j_="Conv2D",SC="Conv2DBackpropFilter",G_="Conv2DBackpropInput",H_="Conv3D",CC="Conv3DBackpropFilterV2",IC="Conv3DBackpropInputV2",gm="Cos",bm="Cosh",EC="Cumprod",W_="Cumsum",DC="CropAndResize",kC="DenseBincount",AC="DepthToSpace",q_="DepthwiseConv2dNative",NC="DepthwiseConv2dNativeBackpropFilter",OC="DepthwiseConv2dNativeBackpropInput",RC="Diag",K_="Dilation2D",MC="Dilation2DBackpropInput",FC="Dilation2DBackpropFilter",ym="RealDiv",PC="Einsum",_m="Elu",$C="EluGrad",vm="Erf",X_="Equal",xm="Exp",Y_="ExpandDims",wm="Expm1",BC="Fill",VC="FlipLeftRight",Tm="Floor",Sm="FloorDiv",Z_="FusedBatchNorm",Q_="GatherV2",zC="GatherNd",J_="Greater",Cm="GreaterEqual",Im="Identity",UC="IFFT",jC="Imag",Em="IsFinite",Dm="IsInf",km="IsNan",e0="LeakyRelu",t0="Less",n0="LessEqual",GC="LinSpace",Am="Log",Nm="Log1p",r0="LogicalAnd",o0="LogicalNot",s0="LogicalOr",a0="LRN",HC="LRNGrad",l0="Max",Om="Maximum",c0="MaxPool",WC="MaxPoolGrad",u0="MaxPool3D",qC="MaxPool3DGrad",KC="MaxPoolWithArgmax",d0="Mean",h0="Min",Rm="Minimum",p0="MirrorPad",Mm="Mod",XC="Multinomial",Fm="Multiply",f0="Neg",m0="NotEqual",YC="NonMaxSuppressionV3",ZC="NonMaxSuppressionV4",QC="NonMaxSuppressionV5",g0="OnesLike",b0="OneHot",y0="Pack",_0="PadV2",Pm="Pow",v0="Prelu",x0="Prod",JC="RaggedGather",eI="RaggedRange",tI="RaggedTensorToTensor",nI="Range",rI="Real",$m="Reciprocal",Lm="Relu",w0="Reshape",T0="ResizeNearestNeighbor",iI="ResizeNearestNeighborGrad",S0="ResizeBilinear",oI="ResizeBilinearGrad",Bm="Relu6",C0="Reverse",Vm="Round",zm="Rsqrt",sI="ScatterNd",aI="TensorScatterUpdate",lI="SearchSorted",I0="Select",Um="Selu",E0="Slice",jm="Sin",Gm="Sinh",Hm="Sign",Wm="Sigmoid",qm="Softplus",Km="Sqrt",D0="Sum",k0="SpaceToBatchND",A0="SplitV",N0="Softmax",cI="SparseFillEmptyRows",uI="SparseReshape",dI="SparseSegmentMean",hI="SparseSegmentSum",pI="SparseToDense",Xm="SquaredDifference",fI="Square",O0="StaticRegexReplace",mI="StridedSlice",gI="StringNGrams",bI="StringSplit",yI="StringToHashBucketFast",Ym="Sub",Zm="Tan",Qm="Tanh",Jm="Tile",_I="TopK",vI="Transform",wh="Transpose",xI="Unique",R0="Unpack",M0="UnsortedSegmentSum",F0="ZerosLike",eg="Step",wI="RotateWithOffset",P0="_FusedMatMul",$0="FusedConv2D",L0="FusedDepthwiseConv2D";function as(...n){Ie().getBool("IS_TEST")||Ie().getBool("PROD")||console.warn(...n)}function _re(...n){Ie().getBool("IS_TEST")||Ie().getBool("PROD")||console.log(...n)}const Th=mC("kernelRegistry",()=>new Map),tg=mC("gradRegistry",()=>new Map);function t3(n,t){const e=CI(n,t);return Th.get(e)}function n3(n){return tg.get(n)}function TI(n){const t=Th.entries(),e=[];for(;;){const{done:r,value:i}=t.next();if(r)break;const[o,s]=i,[a]=o.split("_");a===n&&e.push(s)}return e}function SI(n){const{kernelName:t,backendName:e}=n,r=CI(t,e);Th.has(r)&&as(`The kernel '${t}' for backend '${e}' is already registered`),Th.set(r,n)}function vre(n){const{kernelName:t}=n;tg.has(t)&&Ie().getBool("DEBUG")&&as(`Overriding the gradient for '${t}'`),tg.set(t,n)}function CI(n,t){return`${t}_${n}`}function r3(n){return n instanceof Float32Array||n instanceof Int32Array||n instanceof Uint8Array||n instanceof Uint8ClampedArray}var o3=P(658);const Eu=P.n(o3)()||o3;function B0(n){return Eu.fromString(n,!0,16)}const s3=B0("c3a5c85c97cb3127"),Du=B0("b492b66fbe98f273"),no=B0("9ae16a3b2f90404f");function II(n){return n.xor(n.shru(47))}function a3(n,t,e){const r=n.slice(t,t+e);return Eu.fromBytes(Array.from(r),!0,!0)}function Kn(n,t){return a3(n,t,8)}function l3(n,t){return a3(n,t,4)}function pi(n,t){return 0===t?n:n.shru(t).or(n.shl(64-t))}function ac(n,t,e=B0("9ddfea08eb382d69")){let r=n.xor(t).mul(e);r=r.xor(r.shru(47));let i=t.xor(r).mul(e);return i=i.xor(i.shru(47)),i=i.mul(e),i}function V0(n,t,e,r){return function wre(n,t,e,r,i,o){i=i.add(n),o=pi(o.add(i).add(r),21);const s=i;return i=(i=i.add(t)).add(e),o=o.add(pi(i,44)),[i.add(r),o.add(s)]}(Kn(n,t),Kn(n,t+8),Kn(n,t+16),Kn(n,t+24),e,r)}function Ire(n,t=n.length){const e=Eu.fromNumber(81,!0);if(t<=32)return t<=16?function Tre(n,t=n.length){if(t>=8){const e=no.add(2*t),r=Kn(n,0).add(no),i=Kn(n,t-8);return ac(pi(i,37).mul(e).add(r),pi(r,25).add(i).mul(e),e)}if(t>=4){const e=no.add(2*t);return ac(l3(n,0).shl(3).add(t),l3(n,t-4),e)}if(t>0){const s=t+(n[t-1]<<2);return II(no.mul(n[0]+(n[t>>1]<<8)).xor(s3.mul(s))).mul(no)}return no}(n,t):function Sre(n,t=n.length){const e=no.add(2*t),r=Kn(n,0).mul(Du),i=Kn(n,8),o=Kn(n,t-8).mul(e),s=Kn(n,t-16).mul(no);return ac(pi(r.add(i),43).add(pi(o,30)).add(s),r.add(pi(i.add(no),18)).add(o),e)}(n,t);if(t<=64)return function Cre(n,t=n.length){const e=no.add(2*t),r=Kn(n,0).mul(no),i=Kn(n,8),o=Kn(n,t-8).mul(e),s=Kn(n,t-16).mul(no),a=pi(r.add(i),43).add(pi(o,30)).add(s),c=ac(a,r.add(pi(i.add(no),18)).add(o),e),u=Kn(n,16).mul(e),p=Kn(n,24),m=a.add(Kn(n,t-32)).mul(e),g=c.add(Kn(n,t-24)).mul(e);return ac(pi(u.add(p),43).add(pi(m,30)).add(g),u.add(pi(p.add(r),18)).add(m),e)}(n,t);let r=e,i=e.mul(Du).add(113),o=II(i.mul(no).add(113)).mul(no),s=[Eu.UZERO,Eu.UZERO],a=[Eu.UZERO,Eu.UZERO];r=r.mul(no).add(Kn(n,0));let c=0;const u=64*(t-1>>6),p=u+(t-1&63)-63;do{r=pi(r.add(i).add(s[0]).add(Kn(n,c+8)),37).mul(Du),i=pi(i.add(s[1]).add(Kn(n,c+48)),42).mul(Du),r=r.xor(a[1]),i=i.add(s[0]).add(Kn(n,c+40)),o=pi(o.add(a[0]),33).mul(Du),s=V0(n,c,s[1].mul(Du),r.add(a[0])),a=V0(n,c+32,o.add(a[1]),i.add(Kn(n,c+16))),[o,r]=[r,o],c+=64}while(c!==u);const m=Du.add(o.and(255).shl(1));return c=p,a[0]=a[0].add(t-1&63),s[0]=s[0].add(a[0]),a[0]=a[0].add(s[0]),r=pi(r.add(i).add(s[0]).add(Kn(n,c+8)),37).mul(m),i=pi(i.add(s[1]).add(Kn(n,c+48)),42).mul(m),r=r.xor(a[1].mul(9)),i=i.add(s[0].mul(9).add(Kn(n,c+40))),o=pi(o.add(a[0]),33).mul(m),s=V0(n,c,s[1].mul(m),r.add(a[0])),a=V0(n,c+32,o.add(a[1]),i.add(Kn(n,c+16))),[o,r]=[r,o],ac(ac(s[0],a[0],m).add(II(i).mul(s3)).add(o),ac(s[1],a[1],m).add(r),m)}function lc(n,t){return"string"===t?cc(n):ku([n],t)}function ku(n,t){if("string"===t)throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(n)&&(n=Au(n)),Ie().getBool("DEBUG")&&function ore(n,t){for(let e=0;e<n.length;e++){const r=n[e];if(isNaN(r)||!isFinite(r))throw Error(`A tensor of type ${t} being uploaded contains ${r}.`)}}(n,t),function Ere(n,t){return n instanceof Float32Array&&"float32"===t||n instanceof Int32Array&&"int32"===t||n instanceof Uint8Array&&"bool"===t}(n,t))return n;if(null==t||"float32"===t||"complex64"===t)return new Float32Array(n);if("int32"===t)return new Int32Array(n);if("bool"===t){const e=new Uint8Array(n.length);for(let r=0;r<e.length;++r)0!==Math.round(n[r])&&(e[r]=1);return e}throw new Error(`Unknown data type ${t}`)}function xo(){return Ie().platform.now()}function cc(n,t="utf-8"){return t=t||"utf-8",Ie().platform.encode(n,t)}function uc(n,t="utf-8"){return t=t||"utf-8",Ie().platform.decode(n,t)}function Ns(n){return null!=Ie().platform.isTypedArray?Ie().platform.isTypedArray(n):r3(n)}function Au(n,t=[],e=!1){if(null==t&&(t=[]),"boolean"==typeof n||"number"==typeof n||"string"==typeof n||Iu(n)||null==n||Ns(n)&&e)t.push(n);else if(Array.isArray(n)||Ns(n))for(let r=0;r<n.length;++r)Au(n[r],t,e);else{let r=-1;for(const i of Object.keys(n))/^([1-9]+[0-9]*|0)$/.test(i)&&(r=Math.max(r,Number(i)));for(let i=0;i<=r;i++)Au(n[i],t,e)}return t}class Dre{constructor(t,e){this.backendTimer=t,this.logger=e,null==e&&(this.logger=new Are)}profileKernel(t,e,r){let i;const o=()=>{i=r()};let s;const a=xo();if(this.backendTimer.timerAvailable())s=this.backendTimer.time(o);else{o();for(const u of i)u.dataSync();s=Promise.resolve({kernelMs:xo()-a})}if(Ie().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let u=0;u<i.length;u++){const p=i[u];p.data().then(m=>{kre(m,p.dtype,t)})}return{kernelName:t,outputs:i,inputs:e,timeMs:s.then(u=>u.kernelMs),extraInfo:s.then(u=>null!=u.getExtraProfileInfo?u.getExtraProfileInfo():"")}}logKernelProfile(t){const{kernelName:e,outputs:r,timeMs:i,inputs:o,extraInfo:s}=t;r.forEach(a=>{Promise.all([a.data(),i,s]).then(c=>{this.logger.logKernelProfile(e,a,c[0],c[1],o,c[2])})})}}function kre(n,t,e){if("float32"!==t)return!1;for(let r=0;r<n.length;r++){const i=n[r];if(isNaN(i)||!isFinite(i))return console.warn(`Found ${i} in the result of '${e}'`),!0}return!1}class Are{logKernelProfile(t,e,r,i,o,s){const a="number"==typeof i?yh(`${i}ms`,9):i.error,c=yh(t,25),u=e.rank,p=e.size,m=yh(e.shape.toString(),14);let g="";for(const _ in o){const x=o[_];if(null!=x){const T=x.shape||e.shape,I=T.length;g+=`${_}: ${I}D ${I>0?T:""} `}}console.log(`%c${c}\t%c${a}\t%c${u}D ${m}\t%c${p}\t%c${g}\t%c${s}`,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}}const c3=20,ng=3,EI=7;function Rre(n,t,e,r){const i=Rt(t),o=function Mre(n,t,e,r){const i=Me(t),o=r[r.length-1],s=new Array(o).fill(0),a=t.length,c="complex64"===e?ig(n):n;if(a>1)for(let u=0;u<i/o;u++){const p=u*o;for(let m=0;m<o;m++)s[m]=Math.max(s[m],rg(c[p+m],0,e).length)}return s}(n,t,e,i),s=t.length,a=z0(n,t,e,i,o),c=["Tensor"];return r&&(c.push(`  dtype: ${e}`),c.push(`  rank: ${s}`),c.push(`  shape: [${t}]`),c.push("  values:")),c.push(a.map(u=>"    "+u).join("\n")),c.join("\n")}function rg(n,t,e){let r;return r=Array.isArray(n)?`${parseFloat(n[0].toFixed(EI))} + ${parseFloat(n[1].toFixed(EI))}j`:om(n)?`'${n}'`:"bool"===e?u3(n):parseFloat(n.toFixed(EI)).toString(),yh(r,t)}function u3(n){return 0===n?"false":"true"}function z0(n,t,e,r,i,o=!0){const s="complex64"===e?2:1,a=t[0],c=t.length;if(0===c)return"complex64"===e?[rg(ig(n)[0],0,e)]:"bool"===e?[u3(n[0])]:[n[0].toString()];if(1===c){if(a>c3){let N=Array.from(n.slice(0,ng*s)),R=Array.from(n.slice((a-ng)*s,a*s));return"complex64"===e&&(N=ig(N),R=ig(R)),["["+N.map((L,V)=>rg(L,i[V],e)).join(", ")+", ..., "+R.map((L,V)=>rg(L,i[a-ng+V],e)).join(", ")+"]"]}return["["+("complex64"===e?ig(n):Array.from(n)).map((I,N)=>rg(I,i[N],e)).join(", ")+"]"]}const u=t.slice(1),p=r.slice(1),m=r[0]*s,g=[];if(a>c3){for(let T=0;T<ng;T++){const I=T*m;g.push(...z0(n.slice(I,I+m),u,e,p,i,!1))}g.push("...");for(let T=a-ng;T<a;T++){const I=T*m;g.push(...z0(n.slice(I,I+m),u,e,p,i,T===a-1))}}else for(let T=0;T<a;T++){const I=T*m;g.push(...z0(n.slice(I,I+m),u,e,p,i,T===a-1))}const _=2===c?",":"";g[0]="["+(a>0?g[0]+_:"");for(let T=1;T<g.length-1;T++)g[T]=" "+g[T]+_;let x=",\n";for(let T=2;T<c;T++)x+="\n";return g[g.length-1]=" "+g[g.length-1]+"]"+(o?"":x),g}function ig(n){const t=[];for(let e=0;e<n.length;e+=2)t.push([n[e],n[e+1]]);return t}class Jr{constructor(t,e,r){if(this.dtype=e,this.shape=t.slice(),this.size=Me(t),null!=r){const i=r.length;Z(i===this.size,()=>`Length of values '${i}' does not match the size inferred by the shape '${this.size}'.`)}if("complex64"===e)throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=r||Or(e,this.size),this.strides=Rt(t)}set(t,...e){0===e.length&&(e=[0]),Z(e.length===this.rank,()=>`The number of provided coordinates (${e.length}) must match the rank (${this.rank})`);const r=this.locToIndex(e);this.values[r]=t}get(...t){0===t.length&&(t=[0]);let e=0;for(const i of t){if(i<0||i>=this.shape[e])throw new Error(`Requested out of range element at ${t}.   Buffer shape=${this.shape}`);e++}let r=t[t.length-1];for(let i=0;i<t.length-1;++i)r+=this.strides[i]*t[i];return this.values[r]}locToIndex(t){if(0===this.rank)return 0;if(1===this.rank)return t[0];let e=t[t.length-1];for(let r=0;r<t.length-1;++r)e+=this.strides[r]*t[r];return e}indexToLoc(t){if(0===this.rank)return[];if(1===this.rank)return[t];const e=new Array(this.shape.length);for(let r=0;r<e.length-1;++r)e[r]=Math.floor(t/this.strides[r]),t-=e[r]*this.strides[r];return e[e.length-1]=t,e}get rank(){return this.shape.length}toTensor(){return sa().makeTensor(this.values,this.shape,this.dtype)}}let sa=null,Sh=null,d3=null;class sr{constructor(t,e,r,i){this.kept=!1,this.isDisposedInternal=!1,this.shape=t.slice(),this.dtype=e||"float32",this.size=Me(t),this.strides=Rt(t),this.dataId=r,this.id=i,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}buffer(){var t=this;return $e(function*(){const e=yield t.data();return Sh.buffer(t.shape,t.dtype,e)})()}bufferSync(){return Sh.buffer(this.shape,this.dtype,this.dataSync())}array(){var t=this;return $e(function*(){const e=yield t.data();return As(t.shape,e,"complex64"===t.dtype)})()}arraySync(){return As(this.shape,this.dataSync(),"complex64"===this.dtype)}data(){var t=this;return $e(function*(){t.throwIfDisposed();const e=sa().read(t.dataId);if("string"===t.dtype){const r=yield e;try{return r.map(i=>uc(i))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return e})()}dataToGPU(t){return this.throwIfDisposed(),sa().readToGPU(this.dataId,t)}dataSync(){this.throwIfDisposed();const t=sa().readSync(this.dataId);if("string"===this.dtype)try{return t.map(e=>uc(e))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return t}bytes(){var t=this;return $e(function*(){t.throwIfDisposed();const e=yield sa().read(t.dataId);return"string"===t.dtype?e:new Uint8Array(e.buffer)})()}dispose(){this.isDisposed||(sa().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(t=!1){return Sh.print(this,t)}clone(){return this.throwIfDisposed(),Sh.clone(this)}toString(t=!1){return Rre(this.dataSync(),this.shape,this.dtype,t)}cast(t){return this.throwIfDisposed(),Sh.cast(this,t)}variable(t=!0,e,r){return this.throwIfDisposed(),sa().makeVariable(this,t,e,r)}}function Pe(){return mC("Tensor",()=>sr)}Object.defineProperty(sr,Symbol.hasInstance,{value:n=>!!n&&null!=n.data&&null!=n.dataSync&&null!=n.throwIfDisposed}),Pe();class U0 extends sr{constructor(t,e,r,i){super(t.shape,t.dtype,t.dataId,i),this.trainable=e,this.name=r}assign(t){if(t.dtype!==this.dtype)throw new Error(`dtype of the new value (${t.dtype}) and previous value (${this.dtype}) must match`);if(!mn(t.shape,this.shape))throw new Error(`shape of the new value (${t.shape}) and previous value (${this.shape}) must match`);sa().disposeTensor(this),this.dataId=t.dataId,sa().incRef(this,null)}dispose(){sa().disposeVariable(this),this.isDisposedInternal=!0}}Object.defineProperty(U0,Symbol.hasInstance,{value:n=>n instanceof sr&&null!=n.assign&&n.assign instanceof Function});var dc=(()=>((dc=dc||{}).float32="float32",dc.int32="int32",dc.bool="int32",dc.complex64="complex64",dc))(),hc=(()=>((hc=hc||{}).float32="float32",hc.int32="int32",hc.bool="bool",hc.complex64="complex64",hc))(),pc=(()=>((pc=pc||{}).float32="float32",pc.int32="float32",pc.bool="float32",pc.complex64="complex64",pc))(),fc=(()=>((fc=fc||{}).float32="complex64",fc.int32="complex64",fc.bool="complex64",fc.complex64="complex64",fc))();const Lre={float32:pc,int32:dc,bool:hc,complex64:fc};function zo(n,t){if("string"===n||"string"===t){if("string"===n&&"string"===t)return"string";throw new Error(`Can not upcast ${n} with ${t}`)}return Lre[n][t]}function DI(n){return zo(n,"int32")}function h3(n){return null!=n&&"object"==typeof n&&"texture"in n&&n.texture instanceof WebGLTexture}function p3(n){return typeof GPUBuffer<"u"&&null!=n&&"object"==typeof n&&"buffer"in n&&n.buffer instanceof GPUBuffer}function Tr(n,t){if(n.dtype===t.dtype)return[n,t];const e=zo(n.dtype,t.dtype);return[n.cast(e),t.cast(e)]}function f3(n){const t=[];return m3(n,t,new Set),t}function m3(n,t,e){if(null==n)return;if(n instanceof sr)return void t.push(n);if(!function Vre(n){return Array.isArray(n)||"object"==typeof n}(n))return;const r=n;for(const i in r){const o=r[i];e.has(o)||(e.add(o),m3(o,t,e))}}function kI(n){return null!=n.kernelName}class g3{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map(t=>t.name)))}}}dispose(){for(const t in this.registeredVariables)this.registeredVariables[t].dispose()}}let zre=(()=>{class n{constructor(e){this.ENV=e,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new g3}ready(){var e=this;return $e(function*(){if(null!=e.pendingBackendInit)return e.pendingBackendInit.then(()=>{});if(null!=e.backendInstance)return;const r=e.getSortedBackends();for(let i=0;i<r.length;i++){const o=r[i];if(yield e.initializeBackend(o).success)return void(yield e.setBackend(o))}throw new Error("Could not initialize any backends, all backend initializations failed.")})()}get backend(){if(null!=this.pendingBackendInit)throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);if(null==this.backendInstance){const{name:e,asyncInit:r}=this.initializeBackendsAndReturnBest();if(r)throw new Error(`The highest priority backend '${e}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);this.setBackend(e)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(e){if(!(e in this.registry)){if(!(e in this.registryFactory))return null;{const{asyncInit:r}=this.initializeBackend(e);if(r)return null}}return this.registry[e]}findBackendFactory(e){return e in this.registryFactory?this.registryFactory[e].factory:null}registerBackend(e,r,i=1){return e in this.registryFactory?(as(`${e} backend was already registered. Reusing existing backend factory.`),!1):(this.registryFactory[e]={factory:r,priority:i},!0)}setBackend(e){var r=this;return $e(function*(){if(null==r.registryFactory[e])throw new Error(`Backend name '${e}' not found in registry`);if(r.backendName=e,null==r.registry[e]){r.backendInstance=null;const{success:i,asyncInit:o}=r.initializeBackend(e);if(!(o?yield i:i))return!1}return r.backendInstance=r.registry[e],r.setupRegisteredKernels(),r.profiler=new Dre(r.backendInstance),!0})()}setupRegisteredKernels(){TI(this.backendName).forEach(r=>{null!=r.setupFunc&&r.setupFunc(this.backendInstance)})}disposeRegisteredKernels(e){TI(e).forEach(i=>{null!=i.disposeFunc&&i.disposeFunc(this.registry[e])})}initializeBackend(e){const r=this.registryFactory[e];if(null==r)throw new Error(`Cannot initialize backend ${e}, no registration found.`);try{const i=r.factory();if(!i||i instanceof aC||"function"!=typeof i.then)return this.registry[e]=i,{success:!0,asyncInit:!1};{const o=++this.pendingBackendInitId,s=i.then(a=>!(o<this.pendingBackendInitId||(this.registry[e]=a,this.pendingBackendInit=null,0))).catch(a=>(o<this.pendingBackendInitId||(this.pendingBackendInit=null,as(`Initialization of backend ${e} failed`),as(a.stack||a.message)),!1));return this.pendingBackendInit=s,{success:s,asyncInit:!0}}}catch(i){return as(`Initialization of backend ${e} failed`),as(i.stack||i.message),{success:!1,asyncInit:!1}}}removeBackend(e){if(!(e in this.registryFactory))throw new Error(`${e} backend not found in registry`);this.backendName===e&&null!=this.pendingBackendInit&&this.pendingBackendInitId++,e in this.registry&&(this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e]),delete this.registryFactory[e],this.backendName===e&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(0===Object.keys(this.registryFactory).length)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort((e,r)=>this.registryFactory[r].priority-this.registryFactory[e].priority)}initializeBackendsAndReturnBest(){const e=this.getSortedBackends();for(let r=0;r<e.length;r++){const i=e[r],{success:o,asyncInit:s}=this.initializeBackend(i);if(s||o)return{name:i,asyncInit:s}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(e,r){const i=this.state.tensorInfo.get(r),o=i.backend,s=this.readSync(r),a=o.refCount(r);o.disposeData(r,!0),i.backend=e,e.move(r,s,i.shape,i.dtype,a),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(e,r){let o,i=null;if(null==r){if("function"!=typeof e)throw new Error("Please provide a function to tidy()");r=e}else{if("string"!=typeof e&&!(e instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if("function"!=typeof r)throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");i=e}return this.scopedRun(()=>this.startScope(i),()=>this.endScope(o),()=>(o=r(),o instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),o))}scopedRun(e,r,i){e();try{const o=i();return r(),o}catch(o){throw r(),o}}nextTensorId(){return n.nextTensorId++}nextVariableId(){return n.nextVariableId++}clone(e){const r=pe.runKernel(Im,{x:e});return this.addTapeNode(this.state.activeScope.name,{x:e},[r],a=>({x:()=>pe.runKernel(pm,{x:a},{dtype:"float32"})}),[],{}),r}runKernel(e,r,i){if(null==t3(e,this.backendName))throw new Error(`Kernel '${e}' not registered for backend '${this.backendName}'`);return this.runKernelFunc({kernelName:e,inputs:r,attrs:i})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(e,r,i){const o=this.backend.numDataIds();let s=0;i.forEach(u=>{s+="complex64"===u.dtype?3:1});const c=o-r-s-this.state.numDataMovesStack[this.state.numDataMovesStack.length-1];if(c>0)throw new Error(`Backend '${this.backendName}' has an internal memory leak (${c} data ids) after running '${e}'`)}runKernelFunc(e){let r,i=[];const o=this.isTapeOn(),s=this.state.numBytes,a=this.state.numTensors;let c,u;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0);const p=kI(e)?e.kernelName:null!=this.state.activeScope?this.state.activeScope.name:"";if(kI(e)){const{kernelName:T,inputs:I,attrs:N}=e,R=t3(T,this.backendName);Z(null!=R,()=>`Cannot find registered kernel '${T}' for backend '${this.backendName}'`),c=()=>{const L=this.backend.numDataIds();u=R.kernelFunc({inputs:I,attrs:N,backend:this.backend});const V=Array.isArray(u)?u:[u];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(T,L,V);const j=V.map(Y=>null!=Y.rank?Y:this.makeTensorFromTensorInfo(Y));if(o){const Y=this.getTensorsForGradient(T,I,j);i=this.saveTensorsForBackwardMode(Y)}return j}}else{const{forwardFunc:T}=e,I=N=>{o&&(i=N.map(R=>this.keep(this.clone(R))))};c=()=>{const N=this.backend.numDataIds();u=this.tidy(()=>T(this.backend,I));const R=Array.isArray(u)?u:[u];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(p,N,R),R}}const{inputs:m,attrs:g}=e,_=kI(e)?null:e.backwardsFunc;let x;return this.scopedRun(()=>this.state.kernelDepth++,()=>this.state.kernelDepth--,()=>{this.ENV.getBool("DEBUG")||this.state.profiling?(x=this.profiler.profileKernel(p,m,()=>c()),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(x),r=x.outputs):r=c()}),o&&this.addTapeNode(p,m,r,_,i,g),this.state.profiling&&this.state.activeProfile.kernels.push({name:p,bytesAdded:this.state.numBytes-s,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-a,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(m).map(T=>null!=m[T]?m[T].shape:null),outputShapes:r.map(T=>T.shape),kernelTimeMs:x.timeMs,extraInfo:x.extraInfo}),Array.isArray(u)?r:r[0]}saveTensorsForBackwardMode(e){return e.map(i=>this.keep(this.clone(i)))}getTensorsForGradient(e,r,i){const o=n3(e);if(null!=o){const s=o.inputsToSave||[],a=o.outputsToSave||[];let c;o.saveAllInputs?(Z(Array.isArray(r),()=>"saveAllInputs is true, expected inputs to be an array."),c=Object.keys(r).map(p=>r[p])):c=s.map(p=>r[p]);const u=i.filter((p,m)=>a[m]);return c.concat(u)}return[]}makeTensor(e,r,i,o){if(null==e)throw new Error("Values passed to engine.makeTensor() are null");o=o||this.backend;let s=e;"string"===(i=i||"float32")&&om(e[0])&&(s=e.map(u=>cc(u)));const a=o.write(s,r,i),c=new sr(r,i,a,this.nextTensorId());if(this.trackTensor(c,o),"string"===i){const u=this.state.tensorInfo.get(a),p=function are(n){if(null==n)return 0;let t=0;return n.forEach(e=>t+=e.length),t}(s);this.state.numBytes+=p-u.bytes,u.bytes=p}return c}makeTensorFromDataId(e,r,i,o){return this.makeTensorFromTensorInfo({dataId:e,shape:r,dtype:i=i||"float32"},o)}makeTensorFromTensorInfo(e,r){const{dataId:i,shape:o,dtype:s}=e,a=new sr(o,s,i,this.nextTensorId());return this.trackTensor(a,r),a}makeVariable(e,r=!0,i,o){i=i||this.nextVariableId().toString(),null!=o&&o!==e.dtype&&(e=e.cast(o));const s=new U0(e,r,i,this.nextTensorId());if(null!=this.state.registeredVariables[s.name])throw new Error(`Variable with name ${s.name} was already registered`);return this.state.registeredVariables[s.name]=s,this.incRef(s,this.backend),s}trackTensor(e,r){this.state.numTensors++,"string"===e.dtype&&this.state.numStringTensors++;let i=0;"complex64"!==e.dtype&&"string"!==e.dtype&&(i=e.size*O_(e.dtype)),this.state.numBytes+=i,this.state.tensorInfo.has(e.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(e.dataId,{backend:r||this.backend,dtype:e.dtype,shape:e.shape,bytes:i})),e instanceof U0||this.track(e)}incRef(e,r){this.trackTensor(e,r),this.backend.incRef(e.dataId)}removeDataId(e,r){this.state.tensorInfo.has(e)&&this.state.tensorInfo.get(e).backend===r&&(this.state.tensorInfo.delete(e),this.state.numDataBuffers--)}disposeTensor(e){if(!this.state.tensorInfo.has(e.dataId))return;const r=this.state.tensorInfo.get(e.dataId);if(this.state.numTensors--,"string"===e.dtype&&(this.state.numStringTensors--,this.state.numBytes-=r.bytes),"complex64"!==e.dtype&&"string"!==e.dtype){const i=e.size*O_(e.dtype);this.state.numBytes-=i}r.backend.disposeData(e.dataId)&&this.removeDataId(e.dataId,r.backend)}disposeVariables(){for(const e in this.state.registeredVariables)this.disposeVariable(this.state.registeredVariables[e])}disposeVariable(e){this.disposeTensor(e),null!=this.state.registeredVariables[e.name]&&delete this.state.registeredVariables[e.name]}memory(){const e=this.backend.memory();return e.numTensors=this.state.numTensors,e.numDataBuffers=this.state.numDataBuffers,e.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(e.unreliable=!0,null==e.reasons&&(e.reasons=[]),e.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),e}profile(e){var r=this;return $e(function*(){r.state.profiling=!0;const i=r.state.numBytes,o=r.state.numTensors;r.state.activeProfile.kernels=[],r.state.activeProfile.result=yield e(),r.state.profiling=!1,r.state.activeProfile.peakBytes=Math.max(...r.state.activeProfile.kernels.map(s=>s.totalBytesSnapshot)),r.state.activeProfile.newBytes=r.state.numBytes-i,r.state.activeProfile.newTensors=r.state.numTensors-o;for(const s of r.state.activeProfile.kernels)s.kernelTimeMs=yield s.kernelTimeMs,s.extraInfo=yield s.extraInfo;return r.state.activeProfile})()}isTapeOn(){return this.state.gradientDepth>0&&0===this.state.kernelDepth}addTapeNode(e,r,i,o,s,a){const c={id:this.state.nextTapeNodeId++,kernelName:e,inputs:r,outputs:i,saved:s},u=n3(e);null!=u&&(o=u.gradFunc),null!=o&&(c.gradient=p=>(p=p.map((m,g)=>{if(null==m){const _=i[g],x=Ui(_.size,_.dtype);return this.makeTensor(x,_.shape,_.dtype)}return m}),o(p.length>1?p:p[0],s,a))),this.state.activeTape.push(c)}keep(e){return e.kept=!0,e}startTape(){0===this.state.gradientDepth&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(e){const r={track:[],name:"unnamed scope",id:this.state.nextScopeId++};e&&(r.name=e),this.state.scopeStack.push(r),this.state.activeScope=r}endScope(e){const r=f3(e),i=new Set(r.map(s=>s.id));for(let s=0;s<this.state.activeScope.track.length;s++){const a=this.state.activeScope.track[s];!a.kept&&!i.has(a.id)&&a.dispose()}const o=this.state.scopeStack.pop();this.state.activeScope=0===this.state.scopeStack.length?null:this.state.scopeStack[this.state.scopeStack.length-1],r.forEach(s=>{!s.kept&&s.scopeId===o.id&&this.track(s)})}gradients(e,r,i,o=!1){if(Z(r.length>0,()=>"gradients() received an empty list of xs."),null!=i&&"float32"!==i.dtype)throw new Error(`dy must have 'float32' dtype, but has '${i.dtype}'`);const s=this.scopedRun(()=>this.startTape(),()=>this.endTape(),()=>this.tidy("forward",e));Z(s instanceof sr,()=>"The result y returned by f() must be a tensor.");const a=function Nre(n,t,e){const r={},i={};for(let c=0;c<t.length;c++)r[t[c].id]=!0;for(let c=0;c<n.length;c++){const u=n[c],p=u.inputs;for(const m in p){const g=p[m];let _=!1;for(let x=0;x<t.length;x++)if(r[g.id]){u.outputs.forEach(T=>r[T.id]=!0),_=!0,i[u.id]=!0;break}if(_)break}}const o={};o[e.id]=!0;const s={};for(let c=n.length-1;c>=0;c--){const u=n[c],p=u.inputs;for(let m=0;m<u.outputs.length;m++)if(o[u.outputs[m].id]){for(const g in p)o[p[g].id]=!0,s[u.id]=!0;break}}const a=[];for(let c=0;c<n.length;c++){const u=n[c];if(i[u.id]&&s[u.id]){const p={};for(const g in u.inputs){const _=u.inputs[g];r[_.id]&&(p[g]=_)}const m=Object.assign({},u);m.inputs=p,m.outputs=u.outputs,a.push(m)}}return a}(this.state.activeTape,r,s);if(!o&&0===a.length&&r.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",()=>{const c={};c[s.id]=i??function Ure(n){const t=pC(Me(n),"float32");return pe.makeTensor(t,n,"float32")}(s.shape),function Ore(n,t,e,r){for(let i=t.length-1;i>=0;i--){const o=t[i],s=[];if(o.outputs.forEach(c=>{const u=n[c.id];s.push(null!=u?u:null)}),null==o.gradient)throw new Error(`Cannot compute gradient: gradient function not found for ${o.kernelName}.`);const a=o.gradient(s);for(const c in o.inputs){if(!(c in a))throw new Error(`Cannot backprop through input ${c}. Available gradients found: ${Object.keys(a)}.`);const u=e(()=>a[c]());if("float32"!==u.dtype)throw new Error(`Error in gradient for op ${o.kernelName}. The gradient of input ${c} must have 'float32' dtype, but has '${u.dtype}'`);const p=o.inputs[c];if(!mn(u.shape,p.shape))throw new Error(`Error in gradient for op ${o.kernelName}. The gradient of input '${c}' has shape '${u.shape}', which does not match the shape of the input '${p.shape}'`);if(null==n[p.id])n[p.id]=u;else{const m=n[p.id];n[p.id]=r(m,u),m.dispose()}}}}(c,a,p=>this.tidy(p),jre);const u=r.map(p=>c[p.id]);return 0===this.state.gradientDepth&&(this.state.activeTape.forEach(p=>{for(const m of p.saved)m.dispose()}),this.state.activeTape=null),{value:s,grads:u}})}customGrad(e){return Z(dC(e),()=>"The f passed in customGrad(f) must be a function."),(...r)=>{let i;Z(r.every(c=>c instanceof sr),()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors");const o={};return r.forEach((c,u)=>{o[u]=c}),this.runKernelFunc({forwardFunc:(c,u)=>(i=e(...r,u),Z(i.value instanceof sr,()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor"),Z(dC(i.gradFunc),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function."),i.value),backwardsFunc:(c,u)=>{const p=i.gradFunc(c,u),m=Array.isArray(p)?p:[p];Z(m.length===r.length,()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...)."),Z(m.every(_=>_ instanceof sr),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.");const g={};return m.forEach((_,x)=>{g[x]=()=>_}),g},inputs:o})}}readSync(e){return this.state.tensorInfo.get(e).backend.readSync(e)}read(e){return this.state.tensorInfo.get(e).backend.read(e)}readToGPU(e,r){return this.state.tensorInfo.get(e).backend.readToGPU(e,r)}time(e){var r=this;return $e(function*(){const i=xo(),o=yield r.backend.time(e);return o.wallMs=xo()-i,o})()}track(e){return null!=this.state.activeScope&&(e.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(e)),e}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new g3;for(const e in this.registry)this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}}return n.nextTensorId=0,n.nextVariableId=0,n})();function b3(){const n=e3();if(null==n._tfengine){const t=new ure(n);n._tfengine=new zre(t)}return function fre(n){JL=n}(n._tfengine.ENV),function Fre(n){sa=n}(()=>n._tfengine),n._tfengine}const pe=b3();function jre(n,t){return pe.runKernel(xh,{a:n,b:t})}function y3(n){if(n||function Gre(){return typeof navigator<"u"&&null!=navigator}()){if(n||(n=navigator),"ReactNative"===n.product)return!0;const t=n.userAgent||n.vendor||(typeof window<"u"?window.opera:"");return t?/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(t)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(t.substr(0,4)):n.userAgentData&&n.userAgentData.mobile}return!1}function _3(){return typeof window<"u"&&null!=window.document||typeof WorkerGlobalScope<"u"}const wo=Ie();function mc(n,t){let e=n;if(Ns(n))return"string"===t?[]:[n.length];if(h3(n))return[n.height,n.width*(n.channels||"RGBA").length];if(p3(n))return[n.buffer.size/(null==t?4:O_(t))];if(!Array.isArray(n))return[];const r=[];for(;Array.isArray(e)||Ns(e)&&"string"!==t;)r.push(e.length),e=e[0];return Array.isArray(n)&&Ie().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&v3(n,r,[]),r}function v3(n,t,e){if(e=e||[],!Array.isArray(n)&&!Ns(n))return void Z(0===t.length,()=>`Element arr[${e.join("][")}] is a primitive, but should be an array/TypedArray of ${t[0]} elements`);Z(t.length>0,()=>`Element arr[${e.join("][")}] should be a primitive, but is an array of ${n.length} elements`),Z(n.length===t[0],()=>`Element arr[${e.join("][")}] should have ${t[0]} elements, but has ${n.length} elements`);const r=t.slice(1);for(let i=0;i<n.length;++i)v3(n[i],r,e.concat(i))}function x3(n,t,e,r){if("string_or_numeric"!==n){if(null==n)throw new Error("Expected dtype cannot be null.");if("numeric"!==n&&n!==t||"numeric"===n&&"string"===t)throw new Error(`Argument '${e}' passed to '${r}' must be ${n} tensor, but got ${t} tensor`)}}function Q(n,t,e,r="numeric"){if(n instanceof sr)return x3(r,n.dtype,t,e),n;let i=_h(n);if("string"!==i&&["bool","int32","float32"].indexOf(r)>=0&&(i=r),x3(r,i,t,e),null==n||!Ns(n)&&!Array.isArray(n)&&"number"!=typeof n&&"boolean"!=typeof n&&"string"!=typeof n)throw new Error(`Argument '${t}' passed to '${e}' must be a Tensor or TensorLike, but got '${null==n?"null":n.constructor.name}'`);const o=mc(n,i);!Ns(n)&&!Array.isArray(n)&&(n=[n]);const a="string"!==i?ku(n,i):Au(n,[],!0);return pe.makeTensor(a,o,i)}function j0(n,t,e,r="numeric"){if(!Array.isArray(n))throw new Error(`Argument ${t} passed to ${e} must be a \`Tensor[]\` or \`TensorLike[]\``);return n.map((o,s)=>Q(o,`${t}[${s}]`,e,r))}wo.registerFlag("DEBUG",()=>!1,n=>{n&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")}),wo.registerFlag("IS_BROWSER",()=>_3()),wo.registerFlag("IS_NODE",()=>typeof process<"u"&&typeof process.versions<"u"&&typeof process.versions.node<"u"),wo.registerFlag("IS_CHROME",()=>typeof navigator<"u"&&null!=navigator&&null!=navigator.userAgent&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor)),wo.registerFlag("IS_SAFARI",()=>typeof navigator<"u"&&null!=navigator&&null!=navigator.userAgent&&/Safari/.test(navigator.userAgent)&&/Apple/.test(navigator.vendor)),wo.registerFlag("PROD",()=>!1),wo.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",()=>wo.getBool("DEBUG")),wo.registerFlag("DEPRECATION_WARNINGS_ENABLED",()=>!0),wo.registerFlag("IS_TEST",()=>!1),wo.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",()=>wo.getBool("DEBUG")),wo.registerFlag("WRAP_TO_IMAGEBITMAP",()=>!1),wo.registerFlag("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU",()=>!1),wo.registerFlag("USE_SETTIMEOUTCUSTOM",()=>!1);const w3="__op";function ue(n){const t=Object.keys(n);if(1!==t.length)throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${t.length} keys.`);let e=t[0];const r=n[e];e.endsWith("_")&&(e=e.substring(0,e.length-1)),e+=w3;const i=(...o)=>{pe.startScope(e);try{const s=r(...o);return Iu(s)&&console.error("Cannot return a Promise inside of tidy."),pe.endScope(s),s}catch(s){throw pe.endScope(null),s}};return Object.defineProperty(i,"name",{value:e,configurable:!0}),i}const gc=ue({complex_:function Hre(n,t){const e=Q(n,"real","complex"),r=Q(t,"imag","complex");return Vo(e.shape,r.shape,`real and imag shapes, ${e.shape} and ${r.shape}, must match in call to tf.complex().`),pe.runKernel(TC,{real:e,imag:r})}});function bc(n,t,e,r){if(null==r)r=_h(n);else if("complex64"===r)throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(p3(n)||h3(n)){if("float32"!==r&&"int32"!==r)throw new Error(`Creating tensor from GPU data only supports 'float32'|'int32' dtype, while the dtype is ${r}.`);return pe.backend.createTensorFromGPUData(n,t||e,r)}if(!Ns(n)&&!Array.isArray(n)&&"number"!=typeof n&&"boolean"!=typeof n&&"string"!=typeof n)throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(null!=t){ss(t);const i=Me(t),o=Me(e);Z(i===o,()=>`Based on the provided shape, [${t}], the tensor should have ${i} values but has ${o}`);for(let s=0;s<e.length;++s){const c=s!==e.length-1||e[s]!==Me(t.slice(s));Z(e[s]===t[s]||!c,()=>`Error creating a new Tensor. Inferred shape (${e}) does not match the provided shape (${t}). `)}}return!Ns(n)&&!Array.isArray(n)&&(n=[n]),t=t||e,n="string"!==r?ku(n,r):Au(n,[],!0),pe.makeTensor(n,t,r)}function aa(n,t,e){return bc(n,t,mc(n,e),e)}const NI={float32:4,float16:2,int32:4,uint16:2,uint8:1,bool:1,complex64:8},G0=4;function OI(n,t){return RI.apply(this,arguments)}function RI(){return RI=$e(function*(n,t){const e=[],r=[],i=Array.isArray(n)?n.map(s=>s.name):Object.keys(n);for(let s=0;s<i.length;++s){const a=i[s],c=Array.isArray(n)?n[s].tensor:n[a];if("float32"!==c.dtype&&"int32"!==c.dtype&&"bool"!==c.dtype&&"string"!==c.dtype&&"complex64"!==c.dtype)throw new Error(`Unsupported dtype in weight '${a}': ${c.dtype}`);const u={name:a,shape:c.shape,dtype:c.dtype};if("string"===c.dtype){const p=new Promise(function(){var m=$e(function*(g){const _=yield c.bytes(),x=_.reduce((N,R)=>N+R.length,0)+G0*_.length,T=new Uint8Array(x);let I=0;for(let N=0;N<_.length;N++){const R=_[N],L=new Uint8Array(new Uint32Array([R.length]).buffer);T.set(L,I),I+=G0,T.set(R,I),I+=R.length}g(T)});return function(g){return m.apply(this,arguments)}}());r.push(p)}else r.push(c.data());null!=t&&(u.group=t),e.push(u)}return{data:Wre(yield Promise.all(r)),specs:e}}),RI.apply(this,arguments)}function T3(n,t){const e={};let r,i=0;for(const o of t){const s=o.name,a=o.dtype,c=o.shape,u=Me(c);let p;if("quantization"in o){const m=o.quantization;if("uint8"===m.dtype||"uint16"===m.dtype){if(!("min"in m)||!("scale"in m))throw new Error(`Weight ${o.name} with quantization ${m.dtype} doesn't have corresponding metadata min and scale.`)}else{if("float16"!==m.dtype)throw new Error(`Weight ${o.name} has unknown quantization dtype ${m.dtype}. Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'.`);if("float32"!==a)throw new Error(`Weight ${o.name} is quantized with ${m.dtype} which only supports weights of type float32 not ${a}.`)}const g=NI[m.dtype],_=n.slice(i,i+u*g),x="uint8"===m.dtype?new Uint8Array(_):new Uint16Array(_);if("float32"===a)if("uint8"===m.dtype||"uint16"===m.dtype){p=new Float32Array(x.length);for(let T=0;T<x.length;T++)p[T]=x[T]*m.scale+m.min}else{if("float16"!==m.dtype)throw new Error(`Unsupported quantization type ${m.dtype} for weight type float32.`);void 0===r&&(r=Qre()),p=r(x)}else{if("int32"!==a)throw new Error(`Unsupported dtype in weight '${s}': ${a}`);if("uint8"!==m.dtype&&"uint16"!==m.dtype)throw new Error(`Unsupported quantization type ${m.dtype} for weight type int32.`);p=new Int32Array(x.length);for(let T=0;T<x.length;T++)p[T]=Math.round(x[T]*m.scale+m.min)}i+=u*g}else if("string"===a){const m=Me(o.shape);p=[];for(let g=0;g<m;g++){const _=new Uint32Array(n.slice(i,i+G0))[0];i+=G0;const x=new Uint8Array(n.slice(i,i+_));p.push(x),i+=_}}else{const m=NI[a],g=n.slice(i,i+u*m);if("float32"===a)p=new Float32Array(g);else if("int32"===a)p=new Int32Array(g);else if("bool"===a)p=new Uint8Array(g);else{if("complex64"!==a)throw new Error(`Unsupported dtype in weight '${s}': ${a}`);{p=new Float32Array(g);const _=new Float32Array(p.length/2),x=new Float32Array(p.length/2);for(let N=0;N<_.length;N++)_[N]=p[2*N],x[N]=p[2*N+1];const T=aa(_,c,"float32"),I=aa(x,c,"float32");e[s]=gc(T,I),T.dispose(),I.dispose()}}i+=u*m}"complex64"!==a&&(e[s]=aa(p,c,a))}return e}function Wre(n){if(null===n)throw new Error(`Invalid input value: ${JSON.stringify(n)}`);let t=0;const e=[];n.forEach(o=>{if(t+=o.byteLength,e.push(o.byteLength===o.buffer.byteLength?o:new o.constructor(o)),!(o instanceof Float32Array||o instanceof Int32Array||o instanceof Uint8Array))throw new Error(`Unsupported TypedArray subtype: ${o.constructor.name}`)});const r=new Uint8Array(t);let i=0;return e.forEach(o=>{r.set(new Uint8Array(o.buffer),i),i+=o.byteLength}),r.buffer}const MI=typeof Buffer<"u"&&(typeof Blob>"u"||typeof atob>"u"||typeof btoa>"u");function S3(n){return MI?Buffer.byteLength(n):new Blob([n]).size}function H0(n){if(1===n.length)return n[0];let t=0;n.forEach(i=>{t+=i.byteLength});const e=new Uint8Array(t);let r=0;return n.forEach(i=>{e.set(new Uint8Array(i),r),r+=i.byteLength}),e.buffer}function C3(n){for(n=n.trim();n.endsWith("/");)n=n.slice(0,n.length-1);const e=n.split("/");return e[e.length-1]}function I3(n,t){const e={modelTopology:n.modelTopology,format:n.format,generatedBy:n.generatedBy,convertedBy:n.convertedBy,weightsManifest:t};return null!=n.signature&&(e.signature=n.signature),null!=n.userDefinedMetadata&&(e.userDefinedMetadata=n.userDefinedMetadata),null!=n.modelInitializer&&(e.modelInitializer=n.modelInitializer),null!=n.initializerSignature&&(e.initializerSignature=n.initializerSignature),null!=n.trainingConfig&&(e.trainingConfig=n.trainingConfig),e}function E3(n,t,e){const r={modelTopology:n.modelTopology,format:n.format,generatedBy:n.generatedBy,convertedBy:n.convertedBy};if(null!=n.trainingConfig&&(r.trainingConfig=n.trainingConfig),null!=n.weightsManifest){if(!t)throw new Error("modelJSON has weightsManifest but weightSpecs is null");if(!e)throw new Error("modelJSON has weightsManifest but weightData is null");r.weightSpecs=t,r.weightData=e}return null!=n.signature&&(r.signature=n.signature),null!=n.userDefinedMetadata&&(r.userDefinedMetadata=n.userDefinedMetadata),null!=n.modelInitializer&&(r.modelInitializer=n.modelInitializer),null!=n.initializerSignature&&(r.initializerSignature=n.initializerSignature),r}function FI(n,t){return PI.apply(this,arguments)}function PI(){return(PI=$e(function*(n,t){let e,r;return null!=n.weightsManifest&&([e,r]=yield t(n.weightsManifest)),E3(n,e,r)})).apply(this,arguments)}function og(n){if(n.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:null==n.modelTopology?0:S3(JSON.stringify(n.modelTopology)),weightSpecsBytes:null==n.weightSpecs?0:S3(JSON.stringify(n.weightSpecs)),weightDataBytes:null==n.weightData?0:n.weightData.byteLength}}function D3(n){const t=[];for(const e of n)t.push(...e.weights);return t}function Qre(){const n=function Xre(){const n=e=>{let r=e<<13,i=0;for(;!(8388608&r);)i-=8388608,r<<=1;return r&=-8388609,i+=947912704,r|i},t=new Uint32Array(2048);t[0]=0;for(let e=1;e<1024;e++)t[e]=n(e);for(let e=1024;e<2048;e++)t[e]=939524096+(e-1024<<13);return t}(),t=function Yre(){const n=new Uint32Array(64);n[0]=0,n[31]=1199570944,n[32]=2147483648,n[63]=3347054592;for(let t=1;t<31;t++)n[t]=t<<23;for(let t=33;t<63;t++)n[t]=2147483648+(t-32<<23);return n}(),e=function Zre(){const n=new Uint32Array(64);for(let t=0;t<64;t++)n[t]=1024;return n[0]=n[32]=0,n}();return r=>{const i=new ArrayBuffer(4*r.length),o=new Uint32Array(i);for(let s=0;s<r.length;s++){const a=r[s];o[s]=n[e[a>>10]+(1023&a)]+t[a>>10]}return new Float32Array(i)}}class dr{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return null==dr.instance&&(dr.instance=new dr),dr.instance}static registerSaveRouter(t){dr.getInstance().saveRouters.push(t)}static registerLoadRouter(t){dr.getInstance().loadRouters.push(t)}static getSaveHandlers(t){return dr.getHandlers(t,"save")}static getLoadHandlers(t,e){return dr.getHandlers(t,"load",e)}static getHandlers(t,e,r){const i=[];return("load"===e?dr.getInstance().loadRouters:dr.getInstance().saveRouters).forEach(s=>{const a=s(t,r);null!==a&&i.push(a)}),i}}const Jre=n=>dr.registerSaveRouter(n),eie=n=>dr.registerLoadRouter(n),k3=n=>dr.getSaveHandlers(n),tie=(n,t)=>dr.getLoadHandlers(n,t),W0="tensorflowjs",Nu="models_store",yc="model_info_store";function BI(){if(!Ie().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");const n=typeof window>"u"?self:window,t=n.indexedDB||n.mozIndexedDB||n.webkitIndexedDB||n.msIndexedDB||n.shimIndexedDB;if(null==t)throw new Error("The current browser does not appear to support IndexedDB.");return t}function VI(n){const t=n.result;t.createObjectStore(Nu,{keyPath:"modelPath"}),t.createObjectStore(yc,{keyPath:"modelPath"})}let Ch=(()=>{class n{constructor(e){if(this.indexedDB=BI(),null==e||!e)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=e}save(e){var r=this;return $e(function*(){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return r.databaseAction(r.modelPath,e)})()}load(){var e=this;return $e(function*(){return e.databaseAction(e.modelPath)})()}databaseAction(e,r){return new Promise((i,o)=>{const s=this.indexedDB.open(W0,1);s.onupgradeneeded=()=>VI(s),s.onsuccess=()=>{const a=s.result;if(null==r){const c=a.transaction(Nu,"readonly"),p=c.objectStore(Nu).get(this.modelPath);p.onsuccess=()=>{if(null==p.result)return a.close(),o(new Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));i(p.result.modelArtifacts)},p.onerror=m=>(a.close(),o(p.error)),c.oncomplete=()=>a.close()}else{const c=og(r),u=a.transaction(yc,"readwrite");let m,g,p=u.objectStore(yc);try{m=p.put({modelPath:this.modelPath,modelArtifactsInfo:c})}catch(_){return o(_)}m.onsuccess=()=>{g=a.transaction(Nu,"readwrite");const _=g.objectStore(Nu);let x;try{x=_.put({modelPath:this.modelPath,modelArtifacts:r,modelArtifactsInfo:c})}catch(T){return o(T)}x.onsuccess=()=>i({modelArtifactsInfo:c}),x.onerror=T=>{p=u.objectStore(yc);const I=p.delete(this.modelPath);I.onsuccess=()=>(a.close(),o(x.error)),I.onerror=N=>(a.close(),o(x.error))}},m.onerror=_=>(a.close(),o(m.error)),u.oncomplete=()=>{null==g?a.close():g.oncomplete=()=>a.close()}}},s.onerror=a=>o(s.error)})}}return n.URL_SCHEME="indexeddb://",n})();const A3=n=>Ie().getBool("IS_BROWSER")&&!Array.isArray(n)&&n.startsWith(Ch.URL_SCHEME)?function nie(n){return new Ch(n)}(n.slice(Ch.URL_SCHEME.length)):null;dr.registerSaveRouter(A3),dr.registerLoadRouter(A3);class iie{constructor(){this.indexedDB=BI()}listModels(){var t=this;return $e(function*(){return new Promise((e,r)=>{const i=t.indexedDB.open(W0,1);i.onupgradeneeded=()=>VI(i),i.onsuccess=()=>{const o=i.result,s=o.transaction(yc,"readonly"),c=s.objectStore(yc).getAll();c.onsuccess=()=>{const u={};for(const p of c.result)u[p.modelPath]=p.modelArtifactsInfo;e(u)},c.onerror=u=>(o.close(),r(c.error)),s.oncomplete=()=>o.close()},i.onerror=o=>r(i.error)})})()}removeModel(t){var e=this;return $e(function*(){return t=function rie(n){return n.startsWith(Ch.URL_SCHEME)?n.slice(Ch.URL_SCHEME.length):n}(t),new Promise((r,i)=>{const o=e.indexedDB.open(W0,1);o.onupgradeneeded=()=>VI(o),o.onsuccess=()=>{const s=o.result,a=s.transaction(yc,"readwrite"),c=a.objectStore(yc),u=c.get(t);let p;u.onsuccess=()=>{if(null==u.result)return s.close(),i(new Error(`Cannot find model with path '${t}' in IndexedDB.`));{const m=c.delete(t),g=()=>{p=s.transaction(Nu,"readwrite");const x=p.objectStore(Nu).delete(t);x.onsuccess=()=>r(u.result.modelArtifactsInfo),x.onerror=T=>i(u.error)};m.onsuccess=g,m.onerror=_=>(g(),s.close(),i(u.error))}},u.onerror=m=>(s.close(),i(u.error)),a.oncomplete=()=>{null==p?s.close():p.oncomplete=()=>s.close()}},o.onerror=s=>i(o.error)})})()}}const Ma="/",Ou="tensorflowjs_models",N3="info",oie="model_topology",sie="weight_specs",aie="weight_data",lie="model_metadata";function O3(n){return{info:[Ou,n,N3].join(Ma),topology:[Ou,n,oie].join(Ma),weightSpecs:[Ou,n,sie].join(Ma),weightData:[Ou,n,aie].join(Ma),modelMetadata:[Ou,n,lie].join(Ma)}}function R3(n){for(const t of Object.values(n))window.localStorage.removeItem(t)}function M3(n){const t=n.split(Ma);if(t.length<3)throw new Error(`Invalid key format: ${n}`);return t.slice(1,t.length-1).join(Ma)}let Ih=(()=>{class n{constructor(e){if(!Ie().getBool("IS_BROWSER")||typeof window>"u"||typeof window.localStorage>"u")throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,null==e||!e)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=e,this.keys=O3(this.modelPath)}save(e){var r=this;return $e(function*(){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{const i=JSON.stringify(e.modelTopology),o=JSON.stringify(e.weightSpecs),s=og(e);try{return r.LS.setItem(r.keys.info,JSON.stringify(s)),r.LS.setItem(r.keys.topology,i),r.LS.setItem(r.keys.weightSpecs,o),r.LS.setItem(r.keys.weightData,function qre(n){if(MI)return Buffer.from(n).toString("base64");const t=new Uint8Array(n);let e="";for(let r=0,i=t.length;r<i;r++)e+=String.fromCharCode(t[r]);return btoa(e)}(e.weightData)),r.LS.setItem(r.keys.modelMetadata,JSON.stringify({format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,signature:null!=e.signature?e.signature:void 0,userDefinedMetadata:null!=e.userDefinedMetadata?e.userDefinedMetadata:void 0,modelInitializer:null!=e.modelInitializer?e.modelInitializer:void 0,initializerSignature:null!=e.initializerSignature?e.initializerSignature:void 0,trainingConfig:null!=e.trainingConfig?e.trainingConfig:void 0})),{modelArtifactsInfo:s}}catch{throw R3(r.keys),new Error(`Failed to save model '${r.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${s.modelTopologyBytes}, weightSpecsBytes=${s.weightSpecsBytes}, weightDataBytes=${s.weightDataBytes}.`)}}})()}load(){var e=this;return $e(function*(){const r=JSON.parse(e.LS.getItem(e.keys.info));if(null==r)throw new Error(`In local storage, there is no model with name '${e.modelPath}'`);if("JSON"!==r.modelTopologyType)throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");const i={},o=JSON.parse(e.LS.getItem(e.keys.topology));if(null==o)throw new Error(`In local storage, the topology of model '${e.modelPath}' is missing.`);i.modelTopology=o;const s=JSON.parse(e.LS.getItem(e.keys.weightSpecs));if(null==s)throw new Error(`In local storage, the weight specs of model '${e.modelPath}' are missing.`);i.weightSpecs=s;const a=e.LS.getItem(e.keys.modelMetadata);if(null!=a){const u=JSON.parse(a);i.format=u.format,i.generatedBy=u.generatedBy,i.convertedBy=u.convertedBy,null!=u.signature&&(i.signature=u.signature),null!=u.userDefinedMetadata&&(i.userDefinedMetadata=u.userDefinedMetadata),null!=u.modelInitializer&&(i.modelInitializer=u.modelInitializer),null!=u.initializerSignature&&(i.initializerSignature=u.initializerSignature),null!=u.trainingConfig&&(i.trainingConfig=u.trainingConfig)}const c=e.LS.getItem(e.keys.weightData);if(null==c)throw new Error(`In local storage, the binary weight values of model '${e.modelPath}' are missing.`);return i.weightData=function Kre(n){if(MI){const r=Buffer.from(n,"base64");return r.buffer.slice(r.byteOffset,r.byteOffset+r.byteLength)}const t=atob(n),e=new Uint8Array(t.length);for(let r=0;r<t.length;++r)e.set([t.charCodeAt(r)],r);return e.buffer}(c),i})()}}return n.URL_SCHEME="localstorage://",n})();const F3=n=>Ie().getBool("IS_BROWSER")&&!Array.isArray(n)&&n.startsWith(Ih.URL_SCHEME)?function uie(n){return new Ih(n)}(n.slice(Ih.URL_SCHEME.length)):null;dr.registerSaveRouter(F3),dr.registerLoadRouter(F3);class die{constructor(){Z(Ie().getBool("IS_BROWSER"),()=>"Current environment is not a web browser"),Z(typeof window>"u"||typeof window.localStorage<"u",()=>"Current browser does not appear to support localStorage"),this.LS=window.localStorage}listModels(){var t=this;return $e(function*(){const e={},r=Ou+Ma,i=Ma+N3;for(let o=0;o<t.LS.length;++o){const s=t.LS.key(o);s.startsWith(r)&&s.endsWith(i)&&(e[M3(s)]=JSON.parse(t.LS.getItem(s)))}return e})()}removeModel(t){var e=this;return $e(function*(){const r=O3(t=function cie(n){return n.startsWith(Ih.URL_SCHEME)?n.slice(Ih.URL_SCHEME.length):n}(t));if(null==e.LS.getItem(r.info))throw new Error(`Cannot find model at path '${t}'`);const i=JSON.parse(e.LS.getItem(r.info));return R3(r),i})()}}const Eh="://";class ro{constructor(){this.managers={}}static getInstance(){return null==ro.instance&&(ro.instance=new ro),ro.instance}static registerManager(t,e){Z(null!=t,()=>"scheme must not be undefined or null."),t.endsWith(Eh)&&(t=t.slice(0,t.indexOf(Eh))),Z(t.length>0,()=>"scheme must not be an empty string.");const r=ro.getInstance();Z(null==r.managers[t],()=>`A model store manager is already registered for scheme '${t}'.`),r.managers[t]=e}static getManager(t){const e=ro.getInstance().managers[t];if(null==e)throw new Error(`Cannot find model manager for scheme '${t}'`);return e}static getSchemes(){return Object.keys(ro.getInstance().managers)}}function q0(n){if(-1===n.indexOf(Eh))throw new Error(`The url string provided does not contain a scheme. Supported schemes are: ${ro.getSchemes().join(",")}`);return{scheme:n.split(Eh)[0],path:n.split(Eh)[1]}}function P3(n,t){return zI.apply(this,arguments)}function zI(){return(zI=$e(function*(n,t,e=!1){Z(n!==t,()=>`Old path and new path are the same: '${n}'`);const r=dr.getLoadHandlers(n);Z(r.length>0,()=>`Copying failed because no load handler is found for source URL ${n}.`),Z(r.length<2,()=>`Copying failed because more than one (${r.length}) load handlers for source URL ${n}.`);const i=r[0],o=dr.getSaveHandlers(t);Z(o.length>0,()=>`Copying failed because no save handler is found for destination URL ${t}.`),Z(o.length<2,()=>`Copying failed because more than one (${r.length}) save handlers for destination URL ${t}.`);const s=o[0],a=q0(n).scheme,c=q0(n).path,u=a===q0(n).scheme,p=yield i.load();e&&u&&(yield ro.getManager(a).removeModel(c));const m=yield s.save(p);return e&&!u&&(yield ro.getManager(a).removeModel(c)),m.modelArtifactsInfo})).apply(this,arguments)}function hie(){return UI.apply(this,arguments)}function UI(){return(UI=$e(function*(){const n=ro.getSchemes(),t={};for(const e of n){const r=yield ro.getManager(e).listModels();for(const i in r)t[e+Eh+i]=r[i]}return t})).apply(this,arguments)}function pie(n){return jI.apply(this,arguments)}function jI(){return(jI=$e(function*(n){const t=q0(n);return ro.getManager(t.scheme).removeModel(t.path)})).apply(this,arguments)}function fie(n,t){return GI.apply(this,arguments)}function GI(){return(GI=$e(function*(n,t){return P3(n,t,!1)})).apply(this,arguments)}function mie(n,t){return HI.apply(this,arguments)}function HI(){return(HI=$e(function*(n,t){return P3(n,t,!0)})).apply(this,arguments)}class gie{constructor(){this.messageName="setTimeoutCustom",this.functionRefs=[],this.handledMessageCount=0,this.hasEventListener=!1}fetch(t,e){return fetch(t,e)}now(){return performance.now()}encode(t,e){if("utf-8"!==e&&"utf8"!==e)throw new Error(`Browser's encoder only supports utf-8, but got ${e}`);return null==this.textEncoder&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(t)}decode(t,e){return new TextDecoder(e).decode(t)}setTimeoutCustom(t,e){typeof window>"u"||!Ie().getBool("USE_SETTIMEOUTCUSTOM")?setTimeout(t,e):(this.functionRefs.push(t),setTimeout(()=>{window.postMessage({name:this.messageName,index:this.functionRefs.length-1},"*")},e),this.hasEventListener||(this.hasEventListener=!0,window.addEventListener("message",r=>{r.source===window&&r.data.name===this.messageName&&(r.stopPropagation(),(0,this.functionRefs[r.data.index])(),this.handledMessageCount++,this.handledMessageCount===this.functionRefs.length&&(this.functionRefs=[],this.handledMessageCount=0))},!0)))}isTypedArray(t){return r3(t)}}if(Ie().get("IS_BROWSER")){Ie().setPlatform("browser",new gie);try{ro.registerManager(Ih.URL_SCHEME,new die)}catch{}try{ro.registerManager(Ch.URL_SCHEME,new iie)}catch{}}let Dh;function sn(n,t="float32",e){return t=t||"float32",ss(n),new Jr(n,t,e)}Ie().get("IS_NODE")&&!Ie().get("IS_BROWSER")&&Ie().setPlatform("node",new class yie{constructor(){this.util=P(628),this.textEncoder=new this.util.TextEncoder}fetch(t,e){return null!=Ie().global.fetch?Ie().global.fetch(t,e):(null==Dh&&(Dh=P(410)),Dh(t,e))}now(){const t=process.hrtime();return 1e3*t[0]+t[1]/1e6}encode(t,e){if("utf-8"!==e&&"utf8"!==e)throw new Error(`Node built-in encoder only supports utf-8, but got ${e}`);return this.textEncoder.encode(t)}decode(t,e){return 0===t.length?"":new this.util.TextDecoder(e).decode(t)}isTypedArray(t){return this.util.types.isFloat32Array(t)||this.util.types.isInt32Array(t)||this.util.types.isUint8Array(t)||this.util.types.isUint8ClampedArray(t)}});const ht=ue({cast_:function _ie(n,t){const e=Q(n,"x","cast");if(!function sre(n){return"bool"===n||"complex64"===n||"float32"===n||"int32"===n||"string"===n}(t))throw new Error(`Failed to cast to unknown dtype ${t}`);if("string"===t&&"string"!==e.dtype||"string"!==t&&"string"===e.dtype)throw new Error("Only strings can be casted to strings");return pe.runKernel(pm,{x:e},{dtype:t})}}),_l=ue({clone_:function vie(n){const e={x:Q(n,"x","clone","string_or_numeric")};return pe.runKernel(Im,e)}});function $3(n,t=!1){console.log(n.toString(t))}function Fa(){return pe}function WI(){return pe.memory()}function Se(n,t){return pe.tidy(n,t)}function un(n){f3(n).forEach(e=>e.dispose())}function fi(n){return pe.keep(n)}function L3(n,t,e=1){return pe.registerBackend(n,t,e)}b3(),function Pre(n){Sh=n}({buffer:sn,cast:ht,clone:_l,print:$3}),function $re(n){d3=n}(function xie(n){Ie().getBool("DEPRECATION_WARNINGS_ENABLED")&&console.warn(n+" You can disable deprecation warnings with tf.disableDeprecationWarnings().")});const Xe=ue({add_:function Tie(n,t){let e=Q(n,"a","add"),r=Q(t,"b","add");return[e,r]=Tr(e,r),pe.runKernel(xh,{a:e,b:r})}}),qI=ue({floorDiv_:function Sie(n,t){let e=Q(n,"a","floorDiv"),r=Q(t,"b","floorDiv");return[e,r]=Tr(e,r),pe.runKernel(Sm,{a:e,b:r})}}),Nt=ue({div_:function Cie(n,t){let e=Q(n,"a","div"),r=Q(t,"b","div");return[e,r]=Tr(e,r),"int32"===e.dtype&&"int32"===r.dtype?qI(e,r):pe.runKernel(ym,{a:e,b:r},{})}}),fe=ue({mul_:function Iie(n,t){let e=Q(n,"a","mul"),r=Q(t,"b","mul");return[e,r]=Tr(e,r),pe.runKernel(Fm,{a:e,b:r})}}),ji=ue({sqrt_:function Eie(n){const e={x:Q(n,"x","sqrt","float32")};return pe.runKernel(Km,e)}}),Hn=ue({square_:function Die(n){const t=Q(n,"x","square");return pe.runKernel("Square",{x:t},{})}}),vn=ue({zerosLike_:function kie(n){const e={x:Q(n,"x","zerosLike")};return pe.runKernel(F0,e)}});function vl(n){return pe.customGrad(n)}function Ft(n,t){if((Ns(n)&&"string"!==t||Array.isArray(n))&&"complex64"!==t)throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if("string"===t&&Ns(n)&&!(n instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return bc(n,[],[],t)}class kh{getClassName(){return this.constructor.className}static fromConfig(t,e){return new t(e)}}class Os{constructor(){this.classNameMap={}}static getMap(){return null==Os.instance&&(Os.instance=new Os),Os.instance}static register(t){Os.getMap().classNameMap[t.className]=[t,t.fromConfig]}}function Ye(n){Z(null!=n.className,()=>"Class being registered does not have the static className property defined."),Z("string"==typeof n.className,()=>"className is required to be a string, but got type "+typeof n.className),Z(n.className.length>0,()=>"Class being registered has an empty-string as its className, which is disallowed."),Os.register(n)}class _c extends kh{minimize(t,e=!1,r){const{value:i,grads:o}=this.computeGradients(t,r);if(null!=r){const s=r.map(a=>({name:a.name,tensor:o[a.name]}));this.applyGradients(s)}else this.applyGradients(o);return un(o),e?i:(i.dispose(),null)}get iterations(){return null==this.iterations_&&(this.iterations_=0),this.iterations_}incrementIterations(){this.iterations_=this.iterations+1}computeGradients(t,e){return function Aie(n,t){Z(dC(n),()=>"The f passed in variableGrads(f) must be a function"),Z(null==t||Array.isArray(t)&&t.every(u=>u instanceof U0),()=>"The varList passed in variableGrads(f, varList) must be an array of variables");const e=null!=t;if(!e){t=[];for(const u in pe.registeredVariables)t.push(pe.registeredVariables[u])}const r=e?t.filter(u=>!u.trainable):null,i=t.length;Z((t=t.filter(u=>u.trainable)).length>0,()=>`variableGrads() expects at least one of the input variables to be trainable, but none of the ${i} variables is trainable.`);const{value:s,grads:a}=pe.gradients(n,t,null,!0);Z(a.some(u=>null!=u),()=>"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize()."),Z(0===s.rank,()=>`The f passed in variableGrads(f) must return a scalar, but it returned a rank-${s.rank} tensor`);const c={};return t.forEach((u,p)=>{null!=a[p]&&(c[u.name]=a[p])}),r?.forEach(u=>c[u.name]=null),{value:s,grads:c}}(t,e)}dispose(){null!=this.iterations_&&un(this.iterations_)}saveIterations(){var t=this;return $e(function*(){return null==t.iterations_&&(t.iterations_=0),{name:"iter",tensor:Ft(t.iterations_,"int32")}})()}getWeights(){return $e(function*(){throw new Error("getWeights() is not implemented for this optimizer yet.")})()}setWeights(t){var e=this;return $e(function*(){throw new Error(`setWeights() is not implemented for this optimizer class ${e.getClassName()}`)})()}extractIterations(t){var e=this;return $e(function*(){return e.iterations_=(yield t[0].tensor.data())[0],t.slice(1)})()}}Object.defineProperty(_c,Symbol.hasInstance,{value:n=>null!=n.minimize&&null!=n.computeGradients&&null!=n.applyGradients});class B3 extends _c{static get className(){return"Adadelta"}constructor(t,e,r=null){super(),this.learningRate=t,this.rho=e,this.epsilon=r,this.accumulatedGrads=[],this.accumulatedUpdates=[],null==r&&(this.epsilon=pe.backend.epsilon())}applyGradients(t){(Array.isArray(t)?t.map(r=>r.name):Object.keys(t)).forEach((r,i)=>{const o=pe.registeredVariables[r];null==this.accumulatedGrads[i]&&(this.accumulatedGrads[i]={originalName:`${r}/accum_grad`,variable:Se(()=>vn(o).variable(!1))}),null==this.accumulatedUpdates[i]&&(this.accumulatedUpdates[i]={originalName:`${r}/accum_var`,variable:Se(()=>vn(o).variable(!1))});const a=Array.isArray(t)?t[i].tensor:t[r];if(null==a)return;const c=this.accumulatedGrads[i].variable,u=this.accumulatedUpdates[i].variable;Se(()=>{const p=Xe(fe(c,this.rho),fe(Hn(a),1-this.rho)),m=fe(Nt(ji(Xe(u,this.epsilon)),ji(Xe(c,this.epsilon))),a),g=Xe(fe(u,this.rho),fe(Hn(m),1-this.rho));c.assign(p),u.assign(g);const _=Xe(fe(m,-this.learningRate),o);o.assign(_)})}),this.incrementIterations()}dispose(){null!=this.accumulatedUpdates&&(un(this.accumulatedGrads.map(t=>t.variable)),un(this.accumulatedUpdates.map(t=>t.variable)))}getWeights(){var t=this;return $e(function*(){const e=[...t.accumulatedGrads,...t.accumulatedUpdates];return[yield t.saveIterations()].concat(e.map(r=>({name:r.originalName,tensor:r.variable})))})()}setWeights(t){var e=this;return $e(function*(){const r=(t=yield e.extractIterations(t)).length/2;e.accumulatedGrads=t.slice(0,r).map(o=>({originalName:o.name,variable:o.tensor.variable(!1)})),e.accumulatedUpdates=t.slice(r,2*r).map(o=>({originalName:o.name,variable:o.tensor.variable(!1)}))})()}getConfig(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}}static fromConfig(t,e){return new t(e.learningRate,e.rho,e.epsilon)}}function Ah(n,t,e){return ss(n),e=e||_h(t),pe.runKernel(BC,{},{shape:n,value:t,dtype:e})}class V3 extends _c{static get className(){return"Adagrad"}constructor(t,e=.1){super(),this.learningRate=t,this.initialAccumulatorValue=e,this.accumulatedGrads=[]}applyGradients(t){(Array.isArray(t)?t.map(r=>r.name):Object.keys(t)).forEach((r,i)=>{const o=pe.registeredVariables[r];null==this.accumulatedGrads[i]&&(this.accumulatedGrads[i]={originalName:`${r}/accumulator`,variable:Se(()=>Ah(o.shape,this.initialAccumulatorValue).variable(!1))});const s=Array.isArray(t)?t[i].tensor:t[r];if(null==s)return;const a=this.accumulatedGrads[i].variable;Se(()=>{const c=Xe(a,Hn(s));a.assign(c);const u=Xe(fe(Nt(s,ji(Xe(c,pe.backend.epsilon()))),-this.learningRate),o);o.assign(u)})}),this.incrementIterations()}dispose(){null!=this.accumulatedGrads&&un(this.accumulatedGrads.map(t=>t.variable))}getWeights(){var t=this;return $e(function*(){return[yield t.saveIterations()].concat(t.accumulatedGrads.map(e=>({name:e.originalName,tensor:e.variable})))})()}setWeights(t){var e=this;return $e(function*(){t=yield e.extractIterations(t),e.accumulatedGrads=t.map(i=>({originalName:i.name,variable:i.tensor.variable(!1)}))})()}getConfig(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}}static fromConfig(t,e){return new t(e.learningRate,e.initialAccumulatorValue)}}const vc=ue({pow_:function Nie(n,t){let e=Q(n,"base","pow"),r=Q(t,"exp","pow");return[e,r]=Tr(e,r),pe.runKernel(Pm,{a:e,b:r})}}),xt=ue({sub_:function Oie(n,t){let e=Q(n,"a","sub"),r=Q(t,"b","sub");return[e,r]=Tr(e,r),pe.runKernel(Ym,{a:e,b:r})}});class z3 extends _c{static get className(){return"Adam"}constructor(t,e,r,i=null){super(),this.learningRate=t,this.beta1=e,this.beta2=r,this.epsilon=i,this.accumulatedFirstMoment=[],this.accumulatedSecondMoment=[],Se(()=>{this.accBeta1=Ft(e).variable(),this.accBeta2=Ft(r).variable()}),null==i&&(this.epsilon=pe.backend.epsilon())}applyGradients(t){const e=Array.isArray(t)?t.map(r=>r.name):Object.keys(t);Se(()=>{const r=xt(1,this.accBeta1),i=xt(1,this.accBeta2);e.forEach((o,s)=>{const a=pe.registeredVariables[o];null==this.accumulatedFirstMoment[s]&&(this.accumulatedFirstMoment[s]={originalName:`${o}/m`,variable:Se(()=>vn(a).variable(!1))}),null==this.accumulatedSecondMoment[s]&&(this.accumulatedSecondMoment[s]={originalName:`${o}/v`,variable:Se(()=>vn(a).variable(!1))});const u=Array.isArray(t)?t[s].tensor:t[o];if(null==u)return;const p=this.accumulatedFirstMoment[s].variable,m=this.accumulatedSecondMoment[s].variable,g=Xe(fe(p,this.beta1),fe(u,1-this.beta1)),_=Xe(fe(m,this.beta2),fe(Hn(u),1-this.beta2)),x=Nt(g,r),T=Nt(_,i);p.assign(g),m.assign(_);const I=Xe(fe(Nt(x,Xe(ji(T),this.epsilon)),-this.learningRate),a);a.assign(I)}),this.accBeta1.assign(fe(this.accBeta1,this.beta1)),this.accBeta2.assign(fe(this.accBeta2,this.beta2))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.accBeta2.dispose(),null!=this.accumulatedFirstMoment&&un(this.accumulatedFirstMoment.map(t=>t.variable)),null!=this.accumulatedSecondMoment&&un(this.accumulatedSecondMoment.map(t=>t.variable))}getWeights(){var t=this;return $e(function*(){const e=[...t.accumulatedFirstMoment,...t.accumulatedSecondMoment];return[yield t.saveIterations()].concat(e.map(r=>({name:r.originalName,tensor:r.variable})))})()}setWeights(t){var e=this;return $e(function*(){t=yield e.extractIterations(t),Se(()=>{e.accBeta1.assign(vc(e.beta1,e.iterations_+1)),e.accBeta2.assign(vc(e.beta2,e.iterations_+1))});const r=t.length/2;e.accumulatedFirstMoment=t.slice(0,r).map(o=>({originalName:o.name,variable:o.tensor.variable(!1)})),e.accumulatedSecondMoment=t.slice(r,2*r).map(o=>({originalName:o.name,variable:o.tensor.variable(!1)}))})()}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}}static fromConfig(t,e){return new t(e.learningRate,e.beta1,e.beta2,e.epsilon)}}const ei=ue({abs_:function Rie(n){const t=Q(n,"x","abs");return pe.runKernel("complex64"===t.dtype?z_:R_,{x:t})}});function Nh(n,t){const e=n.length,r=[];for(let i=0;i<e;i++){const o=e-1-i;(t[t.length-1-i]||1)>1&&1===(n[o]||1)&&r.unshift(o)}return r}function ti(n,t){const e=[];for(let r=0;r<t.length;r++){const i=n[n.length-r-1],o=t.length-r-1;(null==i||1===i&&t[o]>1)&&e.unshift(o)}return e}function Yt(n,t){const e=Math.max(n.length,t.length),r=new Array(e);for(let i=0;i<e;i++){let o=n[n.length-i-1];null==o&&(o=1);let s=t[t.length-i-1];if(null==s&&(s=1),1===o)r[e-i-1]=s;else if(1===s)r[e-i-1]=o;else{if(o!==s)throw Error(`Operands could not be broadcast together with shapes ${n} and ${t}.`);r[e-i-1]=o}}return r}const xl=ue({maximum_:function Mie(n,t){let e=Q(n,"a","maximum"),r=Q(t,"b","maximum");return[e,r]=Tr(e,r),"bool"===e.dtype&&(e=ht(e,"int32"),r=ht(r,"int32")),Yt(e.shape,r.shape),pe.runKernel(Om,{a:e,b:r})}});class U3 extends _c{static get className(){return"Adamax"}constructor(t,e,r,i=null,o=0){super(),this.learningRate=t,this.beta1=e,this.beta2=r,this.epsilon=i,this.decay=o,this.accumulatedFirstMoment=[],this.accumulatedWeightedInfNorm=[],Se(()=>{this.iteration=Ft(0).variable(),this.accBeta1=Ft(e).variable()}),null==i&&(this.epsilon=pe.backend.epsilon())}applyGradients(t){const e=Array.isArray(t)?t.map(r=>r.name):Object.keys(t);Se(()=>{const r=xt(1,this.accBeta1),i=Nt(-this.learningRate,Xe(fe(this.iteration,this.decay),1));e.forEach((o,s)=>{const a=pe.registeredVariables[o];null==this.accumulatedFirstMoment[s]&&(this.accumulatedFirstMoment[s]={originalName:`${o}/m`,variable:vn(a).variable(!1)}),null==this.accumulatedWeightedInfNorm[s]&&(this.accumulatedWeightedInfNorm[s]={originalName:`${o}/v`,variable:vn(a).variable(!1)});const u=Array.isArray(t)?t[s].tensor:t[o];if(null==u)return;const p=this.accumulatedFirstMoment[s].variable,m=this.accumulatedWeightedInfNorm[s].variable,g=Xe(fe(p,this.beta1),fe(u,1-this.beta1)),_=fe(m,this.beta2),x=ei(u),T=xl(_,x);p.assign(g),m.assign(T);const I=Xe(fe(Nt(i,r),Nt(g,Xe(T,this.epsilon))),a);a.assign(I)}),this.iteration.assign(Xe(this.iteration,1)),this.accBeta1.assign(fe(this.accBeta1,this.beta1))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.iteration.dispose(),null!=this.accumulatedFirstMoment&&un(this.accumulatedFirstMoment.map(t=>t.variable)),null!=this.accumulatedWeightedInfNorm&&un(this.accumulatedWeightedInfNorm.map(t=>t.variable))}getWeights(){return $e(function*(){throw new Error("getWeights() is not implemented for Adamax yet.")})()}setWeights(t){return $e(function*(){throw new Error("setWeights() is not implemented for Adamax yet.")})()}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}}static fromConfig(t,e){return new t(e.learningRate,e.beta1,e.beta2,e.epsilon,e.decay)}}class KI extends _c{static get className(){return"SGD"}constructor(t){super(),this.learningRate=t,this.setLearningRate(t)}applyGradients(t){(Array.isArray(t)?t.map(r=>r.name):Object.keys(t)).forEach((r,i)=>{const o=Array.isArray(t)?t[i].tensor:t[r];if(null==o)return;const s=pe.registeredVariables[r];Se(()=>{const a=Xe(fe(this.c,o),s);s.assign(a)})}),this.incrementIterations()}setLearningRate(t){this.learningRate=t,null!=this.c&&this.c.dispose(),this.c=fi(Ft(-t))}dispose(){this.c.dispose()}getWeights(){var t=this;return $e(function*(){return[yield t.saveIterations()]})()}setWeights(t){var e=this;return $e(function*(){if(0!==(t=yield e.extractIterations(t)).length)throw new Error("SGD optimizer does not have settable weights.")})()}getConfig(){return{learningRate:this.learningRate}}static fromConfig(t,e){return new t(e.learningRate)}}class j3 extends KI{static get className(){return"Momentum"}constructor(t,e,r=!1){super(t),this.learningRate=t,this.momentum=e,this.useNesterov=r,this.accumulations=[],this.m=Ft(this.momentum)}applyGradients(t){(Array.isArray(t)?t.map(r=>r.name):Object.keys(t)).forEach((r,i)=>{const o=pe.registeredVariables[r];null==this.accumulations[i]&&(this.accumulations[i]={originalName:`${r}/momentum`,variable:Se(()=>vn(o).variable(!1))});const s=this.accumulations[i].variable,a=Array.isArray(t)?t[i].tensor:t[r];null!=a&&Se(()=>{let c;const u=Xe(fe(this.m,s),a);c=Xe(fe(this.c,this.useNesterov?Xe(a,fe(u,this.m)):u),o),s.assign(u),o.assign(c)})}),this.incrementIterations()}dispose(){this.m.dispose(),null!=this.accumulations&&un(this.accumulations.map(t=>t.variable))}setMomentum(t){this.momentum=t}getWeights(){var t=this;return $e(function*(){return[yield t.saveIterations()].concat(t.accumulations.map(e=>({name:e.originalName,tensor:e.variable})))})()}setWeights(t){var e=this;return $e(function*(){t=yield e.extractIterations(t),e.accumulations=t.map(i=>({originalName:i.name,variable:i.tensor.variable(!1)}))})()}getConfig(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}}static fromConfig(t,e){return new t(e.learningRate,e.momentum,e.useNesterov)}}class G3 extends _c{static get className(){return"RMSProp"}constructor(t,e=.9,r=0,i=null,o=!1){if(super(),this.learningRate=t,this.decay=e,this.momentum=r,this.epsilon=i,this.accumulatedMeanSquares=[],this.accumulatedMoments=[],this.accumulatedMeanGrads=[],this.centered=o,null==i&&(this.epsilon=pe.backend.epsilon()),null==t)throw new Error("learningRate for RMSPropOptimizer must be defined.")}applyGradients(t){(Array.isArray(t)?t.map(r=>r.name):Object.keys(t)).forEach((r,i)=>{const o=pe.registeredVariables[r],s=!1;null==this.accumulatedMeanSquares[i]&&(this.accumulatedMeanSquares[i]={originalName:`${r}/rms`,variable:Se(()=>vn(o).variable(s))}),null==this.accumulatedMoments[i]&&(this.accumulatedMoments[i]={originalName:`${r}/momentum`,variable:Se(()=>vn(o).variable(s))}),null==this.accumulatedMeanGrads[i]&&this.centered&&(this.accumulatedMeanGrads[i]={originalName:`${r}/mg`,variable:Se(()=>vn(o).variable(s))});const a=Array.isArray(t)?t[i].tensor:t[r];if(null==a)return;const c=this.accumulatedMeanSquares[i].variable,u=this.accumulatedMoments[i].variable;Se(()=>{const p=Xe(fe(c,this.decay),fe(Hn(a),1-this.decay));if(this.centered){const m=this.accumulatedMeanGrads[i].variable,g=Xe(fe(m,this.decay),fe(a,1-this.decay)),_=Nt(fe(a,this.learningRate),ji(xt(p,Xe(Hn(g),this.epsilon)))),x=Xe(fe(u,this.momentum),_);c.assign(p),m.assign(g),u.assign(x);const T=xt(o,x);o.assign(T)}else{const m=Xe(fe(c,this.decay),fe(Hn(a),1-this.decay)),g=Xe(fe(u,this.momentum),Nt(fe(a,this.learningRate),ji(Xe(m,this.epsilon))));c.assign(m),u.assign(g);const _=xt(o,g);o.assign(_)}})}),this.incrementIterations()}dispose(){null!=this.accumulatedMeanSquares&&un(this.accumulatedMeanSquares.map(t=>t.variable)),null!=this.accumulatedMeanGrads&&this.centered&&un(this.accumulatedMeanGrads.map(t=>t.variable)),null!=this.accumulatedMoments&&un(this.accumulatedMoments.map(t=>t.variable))}getWeights(){var t=this;return $e(function*(){const e=[...t.accumulatedMeanSquares,...t.accumulatedMoments];return t.centered&&e.push(...t.accumulatedMeanGrads),[yield t.saveIterations()].concat(e.map(r=>({name:r.originalName,tensor:r.variable})))})()}setWeights(t){var e=this;return $e(function*(){t=yield e.extractIterations(t);const r=e.centered?t.length/3:t.length/2,i=!1;e.accumulatedMeanSquares=t.slice(0,r).map(o=>({originalName:o.name,variable:o.tensor.variable(i)})),e.accumulatedMoments=t.slice(r,2*r).map(o=>({originalName:o.name,variable:o.tensor.variable(i)})),e.centered&&(e.accumulatedMeanGrads=t.slice(2*r,3*r).map(o=>({originalName:o.name,variable:o.tensor.variable(i)})))})()}getConfig(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}}static fromConfig(t,e){return new t(e.learningRate,e.decay,e.momentum,e.epsilon,e.centered)}}const Fie=[B3,V3,z3,U3,j3,G3,KI];function H3(n){return new Promise(t=>setTimeout(t)).then(n)}let XI=(()=>{class n{constructor(e){if(!Ie().getBool("IS_BROWSER"))throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");e.startsWith(n.URL_SCHEME)&&(e=e.slice(n.URL_SCHEME.length)),(null==e||0===e.length)&&(e="model"),this.modelJsonFileName=e+".json",this.weightDataFileName=e+".weights.bin"}save(e){var r=this;return $e(function*(){if(typeof document>"u")throw new Error("Browser downloads are not supported in this environment since `document` is not present");const i=window.URL.createObjectURL(new Blob([e.weightData],{type:"application/octet-stream"}));if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");{const s=I3(e,[{paths:["./"+r.weightDataFileName],weights:e.weightSpecs}]),a=window.URL.createObjectURL(new Blob([JSON.stringify(s)],{type:"application/json"})),c=null==r.modelJsonAnchor?document.createElement("a"):r.modelJsonAnchor;if(c.download=r.modelJsonFileName,c.href=a,yield H3(()=>c.dispatchEvent(new MouseEvent("click"))),null!=e.weightData){const u=null==r.weightDataAnchor?document.createElement("a"):r.weightDataAnchor;u.download=r.weightDataFileName,u.href=i,yield H3(()=>u.dispatchEvent(new MouseEvent("click")))}return{modelArtifactsInfo:og(e)}}})()}}return n.URL_SCHEME="downloads://",n})();class Vie{constructor(t){if(null==t||t.length<1)throw new Error(`When calling browserFiles, at least 1 file is required, but received ${t}`);this.jsonFile=t[0],this.weightsFiles=t.slice(1)}load(){var t=this;return $e(function*(){return new Promise((e,r)=>{const i=new FileReader;i.onload=o=>{const s=JSON.parse(o.target.result),a=s.modelTopology;if(null==a)return void r(new Error(`modelTopology field is missing from file ${t.jsonFile.name}`));if(null==s.weightsManifest)return void r(new Error(`weightManifest field is missing from file ${t.jsonFile.name}`));if(0===t.weightsFiles.length)return void e({modelTopology:a});const u=FI(s,p=>t.loadWeights(p));e(u)},i.onerror=o=>r(`Failed to read model topology and weights manifest JSON from file '${t.jsonFile.name}'. BrowserFiles supports loading Keras-style tf.Model artifacts only.`),i.readAsText(t.jsonFile)})})()}loadWeights(t){const e=[],r=[];for(const s of t)e.push(...s.weights),r.push(...s.paths);const i=this.checkManifestAndWeightFiles(t),o=r.map(s=>this.loadWeightsFile(s,i[s]));return Promise.all(o).then(s=>[e,H0(s)])}loadWeightsFile(t,e){return new Promise((r,i)=>{const o=new FileReader;o.onload=s=>{r(s.target.result)},o.onerror=s=>i(`Failed to weights data from file of path '${t}'.`),o.readAsArrayBuffer(e)})}checkManifestAndWeightFiles(t){const e=[],r=this.weightsFiles.map(o=>C3(o.name)),i={};for(const o of t)o.paths.forEach(s=>{const a=C3(s);if(-1!==e.indexOf(a))throw new Error(`Duplicate file basename found in weights manifest: '${a}'`);if(e.push(a),-1===r.indexOf(a))throw new Error(`Weight file with basename '${a}' is not provided.`);i[s]=this.weightsFiles[r.indexOf(a)]});if(e.length!==this.weightsFiles.length)throw new Error(`Mismatch in the number of files in weights manifest (${e.length}) and the number of weight files provided (${this.weightsFiles.length}).`);return i}}function jie(n){return new Vie(n)}dr.registerSaveRouter(n=>Ie().getBool("IS_BROWSER")&&!Array.isArray(n)&&n.startsWith(XI.URL_SCHEME)?function Uie(n="model"){return new XI(n)}(n.slice(XI.URL_SCHEME.length)):null);class Gie{constructor(t){if(this.shards=[],this.previousShardIndex=0,t instanceof Array||(t=[t]),0===(t=t.map(r=>Ns(r)?r.buffer:r)).length)return;this.bufferUniformSize=t[0].byteLength;let e=0;for(let r=0;r<t.length;r++){const i=t[r];r!==t.length-1&&i.byteLength!==this.bufferUniformSize&&(this.bufferUniformSize=void 0);const o=e+i.byteLength;this.shards.push({buffer:i,start:e,end:o}),e=o}0===this.shards.length&&(this.byteLength=0),this.byteLength=this.shards[this.shards.length-1].end}slice(t=0,e=this.byteLength){if(t=isNaN(Number(t))?0:t,e=isNaN(Number(e))?0:e,t=Math.max(0,t),(e=Math.min(this.byteLength,e))<=t)return new ArrayBuffer(0);const r=this.findShardForByte(t);if(-1===r)throw new Error(`Could not find start shard for byte ${t}`);const o=new ArrayBuffer(e-t),s=new Uint8Array(o);let a=0;for(let c=r;c<this.shards.length;c++){const u=this.shards[c],m=t+a-u.start,g=a,x=Math.min(e,u.end)-u.start,T=new Uint8Array(u.buffer.slice(m,x));if(s.set(T,g),a+=T.length,e<u.end)break}return o}findShardForByte(t){if(0===this.shards.length||t<0||t>=this.byteLength)return-1;if(null!=this.bufferUniformSize)return this.previousShardIndex=Math.floor(t/this.bufferUniformSize),this.previousShardIndex;function e(i){return t<i.start?-1:t>=i.end?1:0}if(0===e(this.shards[this.previousShardIndex]))return this.previousShardIndex;const r=function Hie(n,t){let e=0,r=n.length;for(;e<=r;){const i=Math.floor((r-e)/2)+e,o=t(n[i]);if(0===o)return i;o<0?r=i:e=i+1}return-1}(this.shards,e);return-1===r?-1:(this.previousShardIndex=r,this.previousShardIndex)}}function W3(n,t,e,r){(function s(c){Z(null!=c&&Array.isArray(c)&&c.length>0,()=>"promises must be a none empty array")})(n),function a(c,u){Z(c>=0&&c<=1,()=>`Progress fraction must be in range [0, 1], but got startFraction ${c}`),Z(u>=0&&u<=1,()=>`Progress fraction must be in range [0, 1], but got endFraction ${u}`),Z(u>=c,()=>`startFraction must be no more than endFraction, but got startFraction ${c} and endFraction ${u}`)}(e=e??0,r=r??1);let i=0;return Promise.all(n.map(c=>(c.then(u=>{const p=e+ ++i/n.length*(r-e);return t(p),u}),c)))}function q3(n,t){return YI.apply(this,arguments)}function YI(){return(YI=$e(function*(n,t){null==t&&(t={});const e=null==t.fetchFunc?Ie().platform.fetch:t.fetchFunc,r=n.map(m=>e(m,t.requestInit,{isBinary:!0})),a=(null==t.onProgress?yield Promise.all(r):yield W3(r,t.onProgress,0,.5)).map(m=>m.arrayBuffer());return null==t.onProgress?yield Promise.all(a):yield W3(a,t.onProgress,.5,1)})).apply(this,arguments)}function Wie(n){return ZI.apply(this,arguments)}function ZI(){return(ZI=$e(function*(n,t="",e,r){return K3(s=>q3(s,{requestInit:r}))(n,t,e)})).apply(this,arguments)}function K3(n){return function(){var t=$e(function*(e,r="",i){const o=e.map(()=>!1),s={},a=null!=i?i.map(()=>!1):[],c=[];if(e.forEach((x,T)=>{let I=0;x.weights.forEach(N=>{const L=NI["quantization"in N?N.quantization.dtype:N.dtype]*Me(N.shape),V=()=>{o[T]=!0,null==s[T]&&(s[T]=[]),s[T].push({manifestEntry:N,groupOffset:I,sizeBytes:L})};null!=i?i.forEach((j,Y)=>{j===N.name&&(V(),a[Y]=!0)}):V(),c.push(N.name),I+=L})}),!a.every(x=>x)){const x=i.filter((T,I)=>!a[I]);throw new Error(`Could not find weights in manifest with names: ${x.join(", ")}. \nManifest JSON has weights with names: ${c.join(", ")}.`)}const u=o.reduce((x,T,I)=>(T&&x.push(I),x),[]),p=[];u.forEach(x=>{e[x].paths.forEach(T=>{const I=r+(r.endsWith("/")?"":"/")+T;p.push(I)})});const m=yield n(p),g={};let _=0;return u.forEach(x=>{const T=e[x].paths.length,I=new Gie(m.slice(_,_+T));s[x].forEach(R=>{const V=T3(I.slice(R.groupOffset,R.groupOffset+R.sizeBytes),[R.manifestEntry]);for(const j in V)g[j]=V[j]}),_+=T}),g});return function(e){return t.apply(this,arguments)}}()}let X3=(()=>{class n{constructor(e,r){if(this.DEFAULT_METHOD="POST",null==r&&(r={}),this.weightPathPrefix=r.weightPathPrefix,this.onProgress=r.onProgress,this.weightUrlConverter=r.weightUrlConverter,null!=r.fetchFunc?(Z("function"==typeof r.fetchFunc,()=>"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)"),this.fetch=r.fetchFunc):this.fetch=Ie().platform.fetch,Z(null!=e&&e.length>0,()=>"URL path for http must not be null, undefined or empty."),Array.isArray(e)&&Z(2===e.length,()=>`URL paths for http must have a length of 2, (actual length is ${e.length}).`),this.path=e,null!=r.requestInit&&null!=r.requestInit.body)throw new Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=r.requestInit||{}}save(e){var r=this;return $e(function*(){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");const i=Object.assign({method:r.DEFAULT_METHOD},r.requestInit);i.body=new FormData;const s=I3(e,[{paths:["./model.weights.bin"],weights:e.weightSpecs}]);i.body.append("model.json",new Blob([JSON.stringify(s)],{type:"application/json"}),"model.json"),null!=e.weightData&&i.body.append("model.weights.bin",new Blob([e.weightData],{type:"application/octet-stream"}),"model.weights.bin");const a=yield r.fetch(r.path,i);if(a.ok)return{modelArtifactsInfo:og(e),responses:[a]};throw new Error(`BrowserHTTPRequest.save() failed due to HTTP response status ${a.status}.`)})()}load(){var e=this;return $e(function*(){const r=yield e.fetch(e.path,e.requestInit);if(!r.ok)throw new Error(`Request to ${e.path} failed with status code ${r.status}. Please verify this URL points to the model JSON of the model to load.`);let i;try{i=yield r.json()}catch{let c=`Failed to parse model JSON of response from ${e.path}.`;throw e.path.endsWith(".pb")?c+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":c+=" Please make sure the server is serving valid JSON for this request.",new Error(c)}if(null==i.modelTopology&&null==i.weightsManifest)throw new Error(`The JSON from HTTP path ${e.path} contains neither model topology or manifest for weights.`);return FI(i,a=>e.loadWeights(a))})()}loadWeights(e){var r=this;return $e(function*(){const i=Array.isArray(r.path)?r.path[1]:r.path,[o,s]=function Xie(n){const t=n.lastIndexOf("/"),e=n.lastIndexOf("?");return[n.substring(0,t)+"/",e>t?n.substring(e):""]}(i),a=r.weightPathPrefix||o,c=D3(e),u=[],p=[];for(const g of e)for(const _ of g.paths)null!=r.weightUrlConverter?p.push(r.weightUrlConverter(_)):u.push(a+_+s);return r.weightUrlConverter&&u.push(...yield Promise.all(p)),[c,H0(yield q3(u,{requestInit:r.requestInit,fetchFunc:r.fetch,onProgress:r.onProgress}))]})()}}return n.URL_SCHEME_REGEX=/^https?:\/\//,n})();function QI(n){return null!=n.match(X3.URL_SCHEME_REGEX)}const Y3=(n,t)=>{if(typeof fetch>"u"&&(null==t||null==t.fetchFunc))return null;{let e=!0;if(e=Array.isArray(n)?n.every(r=>QI(r)):QI(n),e)return JI(n,t)}return null};function JI(n,t){return new X3(n,t)}function Yie(n,t){return JI(n,t)}dr.registerSaveRouter(Y3),dr.registerLoadRouter(Y3);class eE{constructor(t){this.modelArtifacts=t}load(){return this.modelArtifacts}}class Z3{constructor(t){this.saveHandler=t}save(t){return this.saveHandler(t)}}class Zie{constructor(t){t.load&&(this.load=()=>Promise.resolve(t.load())),t.save&&(this.save=e=>Promise.resolve(t.save(e)))}}function Qie(n,t,e,r){return new Zie(Q3(...arguments))}function Q3(n,t,e,r){return 1===arguments.length?null!=n.modelTopology||null!=n.weightSpecs?new eE(n):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new eE({modelTopology:n})):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new eE({modelTopology:n,weightSpecs:t,weightData:e,trainingConfig:r}))}function Jie(n){return new Z3(n)}function eoe(n){return new Z3(n)}const tE=-2,toe=-1;function nE(n,t,e){const r=n.shape.length;Z(r===t.length,()=>`Error in slice${r}D: Length of begin ${t} must match the rank of the array (${r}).`),Z(r===e.length,()=>`Error in slice${r}D: Length of size ${e} must match the rank of the array (${r}).`);for(let i=0;i<r;++i)Z(t[i]+e[i]<=n.shape[i],()=>`Error in slice${r}D: begin[${i}] + size[${i}] (${t[i]+e[i]}) would overflow input.shape[${i}] (${n.shape[i]})`)}function noe(n){const t=[];let e=0;for(;n>0;)1&n&&t.push(e),n/=2,e++;return t}function rE(n,t,e){const r=[];for(let i=0;i<n.length;i++)r[i]=Math.ceil((t[i]-n[i])/e[i]);return r}function J3(n,t,e,r){const i=[...n];for(let o=i.length;o<r.length;o++)i.push(1);for(let o=0;o<e;o++)0===o?i[t]=1:(i.splice(t,0,1),i.pop());return i}function eB(n,t,e){return e<=n?e:e-(t-1)}function tB(n,t){const e=[];for(let r=0;r<n;r++)e.push(t+r);return e}function roe(n,t,e,r,i,o,s,a,c){const u=n.length;let p=new Array(u),m=new Array(u),g=new Array(u);if(t.length&&e>0){const _=t[0],x=e+1;p=nB(s,_,x,r,n),m=rB(a,_,x,i,n),g=J3(o,_,x,n)}else for(let _=0;_<u;_++)p[_]=oB(s,r,o,n,_,c),m[_]=sB(a,i,o,n,_,c),g[_]=iB(o,_,c);return{begin:p,end:m,strides:g}}function nB(n,t,e,r,i){const o=[...i],s=tB(e,t);for(let a=0;a<o.length;a++)if(s.indexOf(a)>-1)o[a]=0;else{const c=eB(t,e,a);let u=r[c];n&1<<c&&(u=0),o[a]=u}return o}function rB(n,t,e,r,i){const o=[...i],s=tB(e,t);for(let a=0;a<o.length;a++)if(s.indexOf(a)>-1)o[a]=Number.MAX_SAFE_INTEGER;else{const c=eB(t,e,a);let u=r[c];n&1<<c&&(u=Number.MAX_SAFE_INTEGER),o[a]=u}for(let a=0;a<o.length;a++)o[a]<0&&(o[a]+=i[a]),o[a]=Cu(0,o[a],i[a]);return o}function iB(n,t,e){let r=n[t];return(e&1<<t||null==r)&&(r=1),r}function oB(n,t,e,r,i,o){let s=t[i];(n&1<<i||o&1<<i||null==s)&&(s=(e[i]||1)>0?Number.MIN_SAFE_INTEGER:Number.MAX_SAFE_INTEGER);const c=r[i];return s<0&&(s+=c),s=Cu(0,s,c-1),s}function sB(n,t,e,r,i,o){let s=t[i];const a=e[i]||1;(n&1<<i||o&1<<i||null==s)&&(s=a>0?Number.MAX_SAFE_INTEGER:Number.MIN_SAFE_INTEGER);const c=r[i];return s<0&&(s+=c),s=a>0?Cu(0,s,c):Cu(-1,s,c-1),s}function iE(n,t,e){let r=e.length;for(let i=0;i<e.length;i++)if(e[i]>1){r=i;break}for(let i=r+1;i<e.length;i++)if(t[i]>0||e[i]!==n[i])return!1;return!0}function oE(n,t){let e=n.length>0?n[n.length-1]:1;for(let r=0;r<n.length-1;r++)e+=n[r]*t[r];return e}function X0(n,t,e){let r;const i=n.shape.length;let o;return r="number"==typeof t?[t,...new Array(i-1).fill(0)]:t.length<i?t.concat(new Array(i-t.length).fill(0)):t.slice(),r.forEach(s=>{Z(-1!==s,()=>"slice() does not support negative begin indexing.")}),o=null==e?new Array(i).fill(-1):"number"==typeof e?[e,...new Array(i-1).fill(-1)]:e.length<i?e.concat(new Array(i-e.length).fill(-1)):e,o=o.map((s,a)=>s>=0?s:(Z(-1===s,()=>`Negative size values should be exactly -1 but got ${s} for the slice() size at index ${a}.`),n.shape[a]-r[a])),[r,o]}function sE(n,t,e,r,i,o,s,a,c){let u;if(null==r?(u=new Array(t.length),u.fill(1)):u=r,null!=s&&s&s-1)throw new Error("Multiple ellipses in slice is not allowed.");let p=!1;const m={dims:u.length,numAddAxisAfterEllipsis:0,begin:t.slice(),end:e.slice(),strides:u.slice(),beginMask:i,endMask:o,ellipsisMask:s,newAxisMask:a,shrinkAxisMask:c};for(let L=0;L<m.dims;L++)p&&1<<L&a&&m.numAddAxisAfterEllipsis++,1<<L&s&&(p=!0);p||(m.ellipsisMask|=1<<m.dims,m.dims++);const g={dims:n.length,beginMask:0,endMask:0,beginValid:!1,endValid:!1};!function ioe(n,t){t.beginMask=0,t.endMask=0,t.shrinkAxisMask=0;let e=0;t.beginValid=null!=n.begin,t.endValid=null!=n.end,t.begin=new Array(t.dims),t.end=new Array(t.dims),t.strides=new Array(t.dims),t.finalShapeGatherIndices=[],t.finalShapeGatherIndicesSparse=[],t.inputShapeGatherIndicesSparse=new Array(t.dims);for(let r=0;r<n.dims;r++)if(1<<r&n.ellipsisMask){const i=Math.min(t.dims-(n.dims-r)+1+n.numAddAxisAfterEllipsis,t.dims);for(;e<i;e++)t.begin[e]=0,t.end[e]=0,t.strides[e]=1,t.beginMask|=1<<e,t.endMask|=1<<e,t.finalShapeGatherIndices.push(e),t.finalShapeGatherIndicesSparse.push(-1),t.inputShapeGatherIndicesSparse[e]=r}else if(1<<r&n.newAxisMask)t.finalShapeGatherIndices.push(tE),t.finalShapeGatherIndicesSparse.push(-1);else{if(e===t.begin.length)throw Error(`Index out of range using input dim ${e}; input has only ${t.dims} dims, ${t.begin.length}.`);null!=n.begin&&(t.begin[e]=n.begin[r]),null!=n.end&&(t.end[e]=n.end[r]),t.strides[e]=n.strides[r],n.beginMask&1<<r&&(t.beginMask|=1<<e),n.endMask&1<<r&&(t.endMask|=1<<e),n.shrinkAxisMask&1<<r?(t.finalShapeGatherIndices.push(toe),t.finalShapeGatherIndicesSparse.push(-1),t.shrinkAxisMask|=1<<e):(t.finalShapeGatherIndices.push(e),t.finalShapeGatherIndicesSparse.push(r)),t.inputShapeGatherIndicesSparse[e]=r,e++}}(m,g);let _=!0,x=!0,T=!0;const I=[],N=[];for(let L=0;L<n.length;++L){if(0===g.strides[L])throw Error(`strides[${L}] must be non-zero`);const V=!!(g.shrinkAxisMask&1<<L),j=n[L];if(-1===j){I.push(V?1:-1);continue}const Y=[g.beginMask&1<<L,g.endMask&1<<L],ee=[g.strides[L]>0?0:-1,g.strides[L]>0?j:j-1];if(V&&g.strides[L]<=0)throw Error("only stride 1 allowed on non-range indexing.");T=T&&1===g.strides[L];const ie=!!(g.beginMask&1<<L&&g.endMask&1<<L);if(g.beginValid&&g.endValid){if(V){const Ee=g.begin[L]<0?j+g.begin[L]:g.begin[L];if(g.begin[L]=Ee,g.end[L]=g.begin[L]+1,Ee<0||Ee>=j)throw Error(`slice index ${g.begin[L]} of dimension ${L} out of bounds.`)}else g.begin[L]=aB(g.begin[L],0,g.strides[L],j,Y,ee),g.end[L]=aB(g.end[L],1,g.strides[L],j,Y,ee);const we=1===g.strides[L]&&0===g.begin[L]&&g.end[L]===j;_=_&&we,x=x&&(0===L&&1===g.strides[L]||we)}else _=_&&1===g.strides[L]&&ie,x=x&&(0===L&&1===g.strides[L]||ie);let ce,he=!1;if(g.beginValid&&g.endValid?(ce=g.end[L]-g.begin[L],he=!0):V?(ce=1,he=!0):ie&&j>=0&&(ce=g.strides[L]<0?-j:j,he=!0),he){let we;we=0===ce||ce<0!=g.strides[L]<0?0:Math.trunc(ce/g.strides[L])+(ce%g.strides[L]!=0?1:0),I.push(we)}else I.push(-1)}for(let L=0;L<g.finalShapeGatherIndices.length;++L){const V=g.finalShapeGatherIndices[L];V>=0?N.push(I[V]):V===tE&&N.push(1)}return{finalShapeSparse:N.filter((L,V)=>g.finalShapeGatherIndices[V]!==tE),finalShape:N,isIdentity:_,sliceDim0:x,isSimpleSlice:T,begin:g.begin,end:g.end,strides:g.strides}}function aB(n,t,e,r,i,o){if(i[t])return e>0?o[t]:o[t+1&1];{const s=n<0?r+n:n;return s<o[0]?o[0]:s>o[1]?o[1]:s}}const lB=ue({acos_:function soe(n){const e={x:Q(n,"x","acos")};return pe.runKernel(sm,e)}}),cB=ue({acosh_:function aoe(n){const e={x:Q(n,"x","acosh")};return pe.runKernel(am,e)}}),coe=ue({addN_:function loe(n){Z(Array.isArray(n),()=>"The argument passed to tf.addN() must be a list of tensors"),Z(n.length>=1,()=>`Must pass at least one tensor to tf.addN(), but got ${n.length}`);const t=n.map((i,o)=>Q(i,`tensors${o}`,"addN")),e=t[0];return t.forEach(i=>{if(i.dtype!==e.dtype)throw new Error("All tensors passed to tf.addN() must have the same dtype")}),t.forEach(i=>{if(!mn(i.shape,e.shape))throw new Error("All tensors passed to tf.addN() must have the same shape")}),pe.runKernel(M_,t)}}),aE=ue({all_:function uoe(n,t=null,e=!1){const i={x:Q(n,"x","all","bool")};return pe.runKernel("All",i,{axis:t,keepDims:e})}}),Y0=ue({any_:function doe(n,t=null,e=!1){const i={x:Q(n,"x","any","bool")};return pe.runKernel("Any",i,{axis:t,keepDims:e})}}),Oh=ue({argMax_:function hoe(n,t=0){const r={x:Q(n,"x","argMax")};return pe.runKernel(F_,r,{axis:t})}}),uB=ue({argMin_:function poe(n,t=0){const r={x:Q(n,"x","argMin")};return pe.runKernel(P_,r,{axis:t})}}),dB=ue({asin_:function foe(n){const e={x:Q(n,"x","asin")};return pe.runKernel(lm,e)}}),hB=ue({asinh_:function moe(n){const e={x:Q(n,"x","asinh")};return pe.runKernel(cm,e)}}),pB=ue({atan_:function goe(n){const e={x:Q(n,"x","atan")};return pe.runKernel(um,e)}}),fB=ue({atan2_:function boe(n,t){let e=Q(n,"a","atan2"),r=Q(t,"b","atan2");return[e,r]=Tr(e,r),pe.runKernel(hm,{a:e,b:r})}}),mB=ue({atanh_:function yoe(n){const e={x:Q(n,"x","atanh")};return pe.runKernel(dm,e)}});function sg(n,t,e,r,i="NHWC",o){return mi(n,[...t,n[3]],e,o,r,null,null,Tl(i))}function Rs(n,t,e,r,i,o,s="channelsLast"){const[a,c]=ag(t);let u;if("channelsLast"===s)u=[a,c,n[3],n[3]];else{if("channelsFirst"!==s)throw new Error(`Unknown dataFormat ${s}`);u=[a,c,n[1],n[1]]}return mi(n,u,e,r,i,o,!1,s)}function wl(n,t,e,r,i,o,s="NDHWC"){const[a,c,u]=cE(t);let p,m;if("NDHWC"===s)m="channelsLast",p=[a,c,u,n[4],n[4]];else{if("NCDHW"!==s)throw new Error(`Unknown dataFormat ${s}`);m="channelsFirst",p=[a,c,u,n[1],n[1]]}return xc(n,p,e,r,i,!1,m,o)}function mi(n,t,e,r,i,o,s=!1,a="channelsLast"){let[c,u,p,m]=[-1,-1,-1,-1];if("channelsLast"===a)[c,u,p,m]=n;else{if("channelsFirst"!==a)throw new Error(`Unknown dataFormat ${a}`);[c,m,u,p]=n}const[g,_,,x]=t,[T,I]=ag(e),[N,R]=ag(r),L=Rh(g,N),V=Rh(_,R),{padInfo:j,outHeight:Y,outWidth:ee}=function xoe(n,t,e,r,i,o,s,a,c){let u,p,m;if("number"==typeof n){u={top:n,bottom:n,left:n,right:n,type:0===n?"VALID":"NUMBER"};const _=function _oe(n,t,e,r,i){null==r&&(r=lE(n,t,e));const s=n[1];return[lg((n[0]-t+2*r)/e+1,i),lg((s-t+2*r)/e+1,i)]}([t,e],o,r,n,a);p=_[0],m=_[1]}else if("same"===n){p=Math.ceil(t/r),m=Math.ceil(e/i);const g=Math.max(0,(p-1)*r+o-t),_=Math.max(0,(m-1)*i+s-e),x=Math.floor(g/2),T=g-x,I=Math.floor(_/2);u={top:x,bottom:T,left:I,right:_-I,type:"SAME"}}else if("valid"===n)u={top:0,bottom:0,left:0,right:0,type:"VALID"},p=Math.ceil((t-o+1)/r),m=Math.ceil((e-s+1)/i);else{if("object"!=typeof n)throw Error(`Unknown padding parameter: ${n}`);{const g="channelsLast"===c?n[1][0]:n[2][0],_="channelsLast"===c?n[1][1]:n[2][1],x="channelsLast"===c?n[2][0]:n[3][0],T="channelsLast"===c?n[2][1]:n[3][1];u={top:g,bottom:_,left:x,right:T,type:0===g&&0===_&&0===x&&0===T?"VALID":"EXPLICIT"},p=lg((t-o+g+_)/r+1,a),m=lg((e-s+x+T)/i+1,a)}}return{padInfo:u,outHeight:p,outWidth:m}}(i,u,p,T,I,L,V,o,a),ie=s?x*m:x;let ce;return"channelsFirst"===a?ce=[c,ie,Y,ee]:"channelsLast"===a&&(ce=[c,Y,ee,ie]),{batchSize:c,dataFormat:a,inHeight:u,inWidth:p,inChannels:m,outHeight:Y,outWidth:ee,outChannels:ie,padInfo:j,strideHeight:T,strideWidth:I,filterHeight:g,filterWidth:_,effectiveFilterHeight:L,effectiveFilterWidth:V,dilationHeight:N,dilationWidth:R,inShape:n,outShape:ce,filterShape:t}}function xc(n,t,e,r,i,o=!1,s="channelsLast",a){let[c,u,p,m,g]=[-1,-1,-1,-1,-1];if("channelsLast"===s)[c,u,p,m,g]=n;else{if("channelsFirst"!==s)throw new Error(`Unknown dataFormat ${s}`);[c,g,u,p,m]=n}const[_,x,T,,I]=t,[N,R,L]=cE(e),[V,j,Y]=cE(r),ee=Rh(_,V),ie=Rh(x,j),ce=Rh(T,Y),{padInfo:he,outDepth:we,outHeight:Ee,outWidth:Ae}=function woe(n,t,e,r,i,o,s,a,c,u,p){let m,g,_,x;if("valid"===n&&(n=0),"number"==typeof n){m={top:n,bottom:n,left:n,right:n,front:n,back:n,type:0===n?"VALID":"NUMBER"};const I=function voe(n,t,e,r,i,o){null==i&&(i=lE(n,t[0],r[0]));const s=[0,0,0,e];for(let a=0;a<3;a++)n[a]+2*i>=t[a]&&(s[a]=lg((n[a]-t[a]+2*i)/r[a]+1,o));return s}([t,e,r,1],[a,c,u],1,[i,o,s],n,p);g=I[0],_=I[1],x=I[2]}else{if("same"!==n)throw Error(`Unknown padding parameter: ${n}`);{g=Math.ceil(t/i),_=Math.ceil(e/o),x=Math.ceil(r/s);const T=(g-1)*i+a-t,I=(_-1)*o+c-e,N=(x-1)*s+u-r,R=Math.floor(T/2),L=T-R,V=Math.floor(I/2),j=I-V,Y=Math.floor(N/2);m={top:V,bottom:j,left:Y,right:N-Y,front:R,back:L,type:"SAME"}}}return{padInfo:m,outDepth:g,outHeight:_,outWidth:x}}(i,u,p,m,N,R,L,ee,ie,ce,a),Oe=o?I*g:I;let Re;return"channelsFirst"===s?Re=[c,Oe,we,Ee,Ae]:"channelsLast"===s&&(Re=[c,we,Ee,Ae,Oe]),{batchSize:c,dataFormat:s,inDepth:u,inHeight:p,inWidth:m,inChannels:g,outDepth:we,outHeight:Ee,outWidth:Ae,outChannels:Oe,padInfo:he,strideDepth:N,strideHeight:R,strideWidth:L,filterDepth:_,filterHeight:x,filterWidth:T,effectiveFilterDepth:ee,effectiveFilterHeight:ie,effectiveFilterWidth:ce,dilationDepth:V,dilationHeight:j,dilationWidth:Y,inShape:n,outShape:Re,filterShape:t}}function lE(n,t,e,r=1){const i=Rh(t,r);return Math.floor((n[0]*(e-1)-e+i)/2)}function ag(n){return"number"==typeof n?[n,n,n]:2===n.length?[n[0],n[1],1]:n}function cE(n){return"number"==typeof n?[n,n,n]:n}function Rh(n,t){return t<=1?n:n+(n-1)*(t-1)}function lg(n,t){if(!t)return Math.trunc(n);switch(t){case"round":return Math.round(n);case"ceil":return Math.ceil(n);case"floor":return Math.floor(n);default:throw new Error(`Unknown roundingMode ${t}`)}}function wc(n){const[t,e,r]=ag(n);return 1===t&&1===e&&1===r}function Di(n,t){return wc(n)||wc(t)}function Ru(n){return ag(n).every(t=>t>0)}function Tl(n){if("NHWC"===n)return"channelsLast";if("NCHW"===n)return"channelsFirst";throw new Error(`Unknown dataFormat ${n}`)}function oo(n,t,e){if(null!=e){if("string"==typeof t)throw Error(`Error in ${n}: pad must be an integer when using dimRoundingMode ${e} but got pad ${t}.`);if("number"==typeof t)Z(bh(t),()=>`Error in ${n}: pad must be an integer when using dimRoundingMode ${e} but got pad ${t}.`);else{if("object"!=typeof t)throw Error(`Error in ${n}: Unknown padding parameter: ${t}`);t.forEach(r=>{r.forEach(i=>{Z(bh(i),()=>`Error in ${n}: pad must be an integer when using dimRoundingMode ${e} but got pad ${i}.`)})})}}}const be=ue({reshape_:function Toe(n,t){const r={x:Q(n,"x","reshape","string_or_numeric")};return pe.runKernel(w0,r,{shape:t})}}),Z0=ue({avgPool_:function Soe(n,t,e,r,i){const o=Q(n,"x","avgPool","float32");Z(Di(e,1),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${e} and dilations '1'`);let a=o,c=!1;3===o.rank&&(c=!0,a=be(o,[1,o.shape[0],o.shape[1],o.shape[2]])),Z(4===a.rank,()=>`Error in avgPool: x must be rank 4 but got rank ${a.rank}.`),oo("avgPool",r,i);let m=pe.runKernel($_,{x:a},{filterSize:t,strides:e,pad:r,dimRoundingMode:i});return m=ht(m,o.dtype),c?be(m,[m.shape[1],m.shape[2],m.shape[3]]):m}}),gB=ue({avgPool3d_:function Coe(n,t,e,r,i,o="NDHWC"){const s=Q(n,"x","avgPool3d","float32");let a=s,c=!1;4===s.rank&&(c=!0,a=be(s,[1,s.shape[0],s.shape[1],s.shape[2],s.shape[3]])),Z(5===a.rank,()=>`Error in avgPool3d: x must be rank 5 but got rank ${a.rank}.`),Z("NDHWC"===o,()=>`Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of ${o}`),Z("number"==typeof e&&e>0||Array.isArray(e)&&e[0]>0&&e[1]>0&&e[2]>0,()=>`Error in avgPool3d: Stride must be > 0, but got '${e}'`),oo("avgPool3d",r,i);let m=pe.runKernel(L_,{x:a},{filterSize:t,strides:e,pad:r,dimRoundingMode:i,dataFormat:o});return m=ht(m,a.dtype),c?be(m,[m.shape[1],m.shape[2],m.shape[3],m.shape[4]]):m}}),Ur=ue({concat_:function Ioe(n,t=0){Z(n.length>=1,()=>"Pass at least one tensor to concat");const e=j0(n,"tensors","concat","string_or_numeric");return"complex64"===e[0].dtype&&e.forEach(o=>{if("complex64"!==o.dtype)throw new Error(`Cannot concatenate complex64 tensors with a tensor\n          with dtype ${o.dtype}. `)}),1===e.length?_l(e[0]):pe.runKernel(U_,e,{axis:t})}}),hn=ue({matMul_:function Eoe(n,t,e=!1,r=!1){let i=Q(n,"a","matMul"),o=Q(t,"b","matMul");return[i,o]=Tr(i,o),pe.runKernel(B_,{a:i,b:o},{transposeA:e,transposeB:r})}}),Pa=ue({sigmoid_:function Doe(n){const e={x:Q(n,"x","sigmoid","float32")};return pe.runKernel(Wm,e)}}),xn=ue({slice_:function koe(n,t,e){const r=Q(n,"x","slice","string_or_numeric");if(0===r.rank)throw new Error("Slicing scalar is not possible");return pe.runKernel(E0,{x:r},{begin:t,size:e})}}),Mh=ue({tanh_:function Aoe(n){const e={x:Q(n,"x","tanh","float32")};return pe.runKernel(Qm,e)}}),Ooe=ue({basicLSTMCell_:function Noe(n,t,e,r,i,o){const s=Q(n,"forgetBias","basicLSTMCell"),a=Q(t,"lstmKernel","basicLSTMCell"),c=Q(e,"lstmBias","basicLSTMCell"),u=Q(r,"data","basicLSTMCell"),p=Q(i,"c","basicLSTMCell"),m=Q(o,"h","basicLSTMCell"),g=Ur([u,m],1),_=hn(g,a),x=Xe(_,c),I=x.shape[1]/4,N=[x.shape[0],I],R=xn(x,[0,0],N),L=xn(x,[0,I],N),V=xn(x,[0,2*I],N),j=xn(x,[0,3*I],N),Y=Xe(fe(Pa(R),Mh(L)),fe(p,Pa(Xe(s,V))));return[Y,fe(Mh(Y),Pa(j))]}}),Q0=ue({batchToSpaceND_:function Roe(n,t,e){const r=Q(n,"x","batchToSpaceND"),i=t.reduce((a,c)=>a*c);return Z(r.rank>=1+t.length,()=>`input rank is ${r.rank} but should be > than blockShape.length ${t.length}`),Z(e.length===t.length,()=>`crops.length is ${e.length} but should be equal to blockShape.length  ${t.length}`),Z(r.shape[0]%i==0,()=>`input tensor batch is ${r.shape[0]} but is not divisible by the product of the elements of blockShape ${t.join(" * ")} === ${i}`),pe.runKernel(V_,{x:r},{blockShape:t,crops:e})}});function Moe(n){let t;return t=0===n.rank||1===n.rank?be(n,[1,1,1,n.size]):2===n.rank?be(n,[1,1,n.shape[0],n.shape[1]]):3===n.rank?be(n,[1,n.shape[0],n.shape[1],n.shape[2]]):n,t}const cg=ue({batchNorm_:function Foe(n,t,e,r,i,o){null==o&&(o=.001);const s=Q(n,"x","batchNorm"),a=Q(t,"mean","batchNorm"),c=Q(e,"variance","batchNorm");let u,p;null!=i&&(u=Q(i,"scale","batchNorm")),null!=r&&(p=Q(r,"offset","batchNorm")),Z(a.rank===c.rank,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),Z(null==p||a.rank===p.rank,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),Z(null==u||a.rank===u.rank,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");const g={x:Moe(s),scale:u,offset:p,mean:a,variance:c},x=pe.runKernel(Z_,g,{varianceEpsilon:o});return be(x,s.shape)}}),bB=ue({batchNorm2d_:function Poe(n,t,e,r,i,o){const s=Q(n,"x","batchNorm"),a=Q(t,"mean","batchNorm"),c=Q(e,"variance","batchNorm");let u,p;return null!=i&&(u=Q(i,"scale","batchNorm")),null!=r&&(p=Q(r,"offset","batchNorm")),Z(2===s.rank,()=>`Error in batchNorm2D: x must be rank 2 but got rank ${s.rank}.`),Z(2===a.rank||1===a.rank,()=>`Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank ${a.rank}.`),Z(2===c.rank||1===c.rank,()=>`Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank ${c.rank}.`),null!=u&&Z(2===u.rank||1===u.rank,()=>`Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank ${u.rank}.`),null!=p&&Z(2===p.rank||1===p.rank,()=>`Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank ${p.rank}.`),cg(s,a,c,p,u,o)}}),yB=ue({batchNorm3d_:function $oe(n,t,e,r,i,o){const s=Q(n,"x","batchNorm"),a=Q(t,"mean","batchNorm"),c=Q(e,"variance","batchNorm");let u,p;return null!=i&&(u=Q(i,"scale","batchNorm")),null!=r&&(p=Q(r,"offset","batchNorm")),Z(3===s.rank,()=>`Error in batchNorm3D: x must be rank 3 but got rank ${s.rank}.`),Z(3===a.rank||1===a.rank,()=>`Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank ${a.rank}.`),Z(3===c.rank||1===c.rank,()=>`Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank ${c.rank}.`),null!=u&&Z(3===u.rank||1===u.rank,()=>`Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank ${u.rank}.`),null!=p&&Z(3===p.rank||1===p.rank,()=>`Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank ${p.rank}.`),cg(s,a,c,p,u,o)}}),_B=ue({batchNorm4d_:function Loe(n,t,e,r,i,o){const s=Q(n,"x","batchNorm"),a=Q(t,"mean","batchNorm"),c=Q(e,"variance","batchNorm");let u,p;return null!=i&&(u=Q(i,"scale","batchNorm")),null!=r&&(p=Q(r,"offset","batchNorm")),Z(4===s.rank,()=>`Error in batchNorm4D: x must be rank 4 but got rank ${s.rank}.`),Z(4===a.rank||1===a.rank,()=>`Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank ${a.rank}.`),Z(4===c.rank||1===c.rank,()=>`Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank ${c.rank}.`),null!=u&&Z(4===u.rank||1===u.rank,()=>`Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank ${u.rank}.`),null!=p&&Z(4===p.rank||1===p.rank,()=>`Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank ${p.rank}.`),cg(s,a,c,p,u,o)}}),vB=ue({bincount_:function Boe(n,t,e){const r=Q(n,"x","bincount"),i=Q(t,"weights","bincount");return Z("int32"===r.dtype,()=>`Error in bincount: input dtype must be int32, but got ${r.dtype}`),Z(e>=0,()=>`size must be non-negative, but got ${e}.`),Z(i.size===r.size||0===i.size,()=>`Error in bincount: weights must have the same size as input or0-length, but got input shape: ${r.shape}, weights shape: ${i.shape}.`),pe.runKernel(vC,{x:r,weights:i},{size:e})}}),zoe=ue({bitwiseAnd_:function Voe(n,t){const e=Q(n,"x","bitwiseAnd"),r=Q(t,"y","bitwiseAnd");if(!mn(e.shape,r.shape))throw new Error(`BitwiseAnd: Tensors must have the same shape. x: ${e.shape}, y: ${r.shape}`);if("int32"!==e.dtype||"int32"!==r.dtype)throw new Error(`BitwiseAnd: Only supports 'int32' values in tensor, found type of x: ${e.dtype} and type of y: ${r.dtype}`);return pe.runKernel(xC,{a:e,b:r})}}),joe=ue({broadcastArgs_:function Uoe(n,t){const e=Q(n,"s0","broadcastArgs","int32"),r=Q(t,"s1","broadcastArgs","int32");if(1!==e.rank)throw new Error(`broadcastArgs(): first input must be a vector (rank=1). Has rank ${e.rank}`);if(1!==r.rank)throw new Error(`broadcastArgs(): second input must be a vector (rank=1). Has rank ${r.rank}`);return pe.runKernel(wC,{s0:e,s1:r})}}),Fh=ue({broadcastTo_:function Goe(n,t){let e=Q(n,"broadcastTo","x");const r=e.shape;if(ss(t),t.length<e.rank)throw new Error(`broadcastTo(): shape.length=${t.length} < input.rank=${e.rank}.`);if(t.length>e.rank){const u=e.shape.slice();for(;u.length<t.length;)u.unshift(1);e=be(e,u)}const i=e.shape,o=Array.from(t);for(let u=t.length-1;u>=0;u--)if(i[u]===t[u])o[u]=1;else if(1!==e.shape[u])throw new Error(`broadcastTo(): [${r}] cannot be broadcast to [${t}].`);return 0===o.map((u,p)=>u>1?p:-1).filter(u=>u>=0).length?_l(e):pe.runKernel(Jm,{x:e},{reps:o})}}),xB=ue({ceil_:function Hoe(n){const e={x:Q(n,"x","ceil","float32")};return pe.runKernel(fm,e)}}),Uo=ue({clipByValue_:function Woe(n,t,e){const r=Q(n,"x","clipByValue");return Z(t<=e,()=>`Error in clip: min (${t}) must be less than or equal to max (${e}).`),t===e?Ah(r.shape,t,r.dtype):pe.runKernel(mm,{x:r},{clipValueMin:t,clipValueMax:e})}}),wB=ue({concat1d_:function qoe(n){return Ur(n,0)}}),TB=ue({concat2d_:function Koe(n,t){return Ur(n,t)}}),SB=ue({concat3d_:function Xoe(n,t){return Ur(n,t)}}),CB=ue({concat4d_:function Yoe(n,t){return Ur(n,t)}}),Tc=ue({conv2d_:function Zoe(n,t,e,r,i="NHWC",o=[1,1],s){const a=Q(n,"x","conv2d","float32"),c=Q(t,"filter","conv2d","float32");let u=a,p=!1;3===a.rank&&(p=!0,u=be(a,[1,a.shape[0],a.shape[1],a.shape[2]])),Z(4===u.rank,()=>`Error in conv2d: input must be rank 4, but got rank ${u.rank}.`),Z(4===c.rank,()=>`Error in conv2d: filter must be rank 4, but got rank ${c.rank}.`),oo("conv2d",r,s);const m="NHWC"===i?u.shape[3]:u.shape[1];Z(m===c.shape[2],()=>`Error in conv2d: depth of input (${m}) must match input depth for filter ${c.shape[2]}.`),Z(Di(e,o),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${e} and dilations '${o}'`),Z(Ru(o),()=>"Error in conv2D: Dilated rates should be larger than 0."),Z(Ru(e),()=>"Error in conv2D: Strides should be larger than 0.");const x=pe.runKernel(j_,{x:u,filter:c},{strides:e,pad:r,dataFormat:i,dilations:o,dimRoundingMode:s});return p?be(x,[x.shape[1],x.shape[2],x.shape[3]]):x}}),uE=ue({conv1d_:function Qoe(n,t,e,r,i="NWC",o=1,s){const a=Q(n,"x","conv1d"),c=Q(t,"filter","conv1d");let u=a,p=!1;2===a.rank&&(p=!0,u=be(a,[1,a.shape[0],a.shape[1]])),Z(3===u.rank,()=>`Error in conv1d: input must be rank 3, but got rank ${u.rank}.`),Z(3===c.rank,()=>`Error in conv1d: filter must be rank 3, but got rank ${c.rank}.`),oo("conv1d",r,s),Z(u.shape[2]===c.shape[1],()=>`Error in conv1d: depth of input (${u.shape[2]}) must match input depth for filter ${c.shape[1]}.`),Z(Di(e,o),()=>`Error in conv1D: Either stride or dilation must be 1. Got stride ${e} and dilation '${o}'`),Z(Ru(o),()=>"Error in conv1D: Dilated rates should be larger than 0."),Z(Ru(e),()=>"Error in conv1D: Stride should be larger than 0."),Z("NWC"===i,()=>`Error in conv1d: got dataFormat of ${i} but only NWC is currently supported.`);const m=be(c,[1,c.shape[0],c.shape[1],c.shape[2]]),g=be(u,[u.shape[0],1,u.shape[1],u.shape[2]]),I=Tc(g,m,[1,e],r,"NHWC",[1,o],s);return be(I,p?[I.shape[2],I.shape[3]]:[I.shape[0],I.shape[2],I.shape[3]])}}),dE=ue({conv2DBackpropInput_:function Joe(n,t,e,r,i,o="NHWC",s){Z(n.length===t.rank,()=>`Length of inShape (${n.length}) and rank of dy (${t.rank}) must match`);let a=n,c=t,u=!1;3===t.rank&&(u=!0,c=be(t,[1,t.shape[0],t.shape[1],t.shape[2]]),a=[1,n[0],n[1],n[2]]),Z(4===a.length,()=>`Error in conv2dDerInput: inShape must be length 4, but got length ${a.length}.`),Z(4===c.rank,()=>`Error in conv2dDerInput: dy must be rank 4, but got rank ${c.rank}`),Z(4===e.rank,()=>`Error in conv2dDerInput: filter must be rank 4, but got rank ${e.rank}`);const p="NHWC"===o?a[3]:a[1],m="NHWC"===o?c.shape[3]:c.shape[1];Z(p===e.shape[2],()=>`Error in conv2dDerInput: depth of input (${p}) must match input depth for filter ${e.shape[2]}.`),Z(m===e.shape[3],()=>`Error in conv2dDerInput: depth of output (${m}) must match output depth for filter ${e.shape[3]}.`),oo("conv2dDerInput",i,s);const x=pe.runKernel(G_,{dy:c,filter:e},{strides:r,pad:i,dataFormat:o,dimRoundingMode:s,inputShape:a});return u?be(x,[x.shape[1],x.shape[2],x.shape[3]]):x}}),hE=ue({conv2dTranspose_:function ese(n,t,e,r,i,o){const s=Q(n,"x","conv2dTranspose"),a=Q(t,"filter","conv2dTranspose");return dE(e,s,a,r,i,"NHWC",o)}}),IB=ue({conv3d_:function tse(n,t,e,r,i="NDHWC",o=[1,1,1]){const s=Q(n,"x","conv3d"),a=Q(t,"filter","conv3d");let c=s,u=!1;4===s.rank&&(u=!0,c=be(s,[1,s.shape[0],s.shape[1],s.shape[2],s.shape[3]])),Z(5===c.rank,()=>`Error in conv3d: input must be rank 5, but got rank ${c.rank}.`),Z(5===a.rank,()=>`Error in conv3d: filter must be rank 5, but got rank ${a.rank}.`),Z(c.shape[4]===a.shape[3],()=>`Error in conv3d: depth of input (${c.shape[4]}) must match input depth for filter ${a.shape[3]}.`),Z(Di(e,o),()=>`Error in conv3D: Either strides or dilations must be 1. Got strides ${e} and dilations '${o}'`),Z("NDHWC"===i,()=>`Error in conv3d: got dataFormat of ${i} but only NDHWC is currently supported.`),Z(Ru(o),()=>"Error in conv3D: Dilated rates should be larger than 0."),Z(Ru(e),()=>"Error in conv3D: Strides should be larger than 0.");const g=pe.runKernel(H_,{x:c,filter:a},{strides:e,pad:r,dataFormat:i,dilations:o});return u?be(g,[g.shape[1],g.shape[2],g.shape[3],g.shape[4]]):g}}),EB=ue({conv3DBackpropInput_:function nse(n,t,e,r,i){Z(n.length===t.rank,()=>`Length of inShape (${n.length}) and rank of dy (${t.rank}) must match`);let o=n,s=t,a=!1;4===t.rank&&(a=!0,s=be(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]]),o=[1,n[0],n[1],n[2],n[3]]);const c=o[4],u=s.shape[4];Z(5===o.length,()=>`Error in conv3dDerInput: inShape must be length 5, but got length ${o.length}.`),Z(5===s.rank,()=>`Error in conv3dDerInput: dy must be rank 5, but got rank ${s.rank}`),Z(5===e.rank,()=>`Error in conv3dDerInput: filter must be rank 5, but got rank ${e.rank}`),Z(c===e.shape[3],()=>`Error in conv3dDerInput: depth of input (${c}) must match input depth for filter ${e.shape[3]}.`),Z(u===e.shape[4],()=>`Error in conv3dDerInput: depth of output (${u}) must match output depth for filter ${e.shape[4]}.`);const g=pe.runKernel(IC,{dy:s,filter:e},{pad:i,strides:r,inputShape:o});return a?be(g,[g.shape[1],g.shape[2],g.shape[3],g.shape[4]]):g}}),DB=ue({conv3dTranspose_:function rse(n,t,e,r,i){const o=Q(n,"x","conv3dTranspose"),s=Q(t,"filter","conv3dTranspose");return EB(e,o,s,r,i)}}),J0=ue({cos_:function ise(n){const e={x:Q(n,"x","cos","float32")};return pe.runKernel(gm,e)}}),pE=ue({cosh_:function ose(n){const e={x:Q(n,"x","cosh","float32")};return pe.runKernel(bm,e)}}),ev=ue({cumprod_:function sse(n,t=0,e=!1,r=!1){const o={x:Q(n,"x","cumprod")};return pe.runKernel(EC,o,{axis:t,exclusive:e,reverse:r})}}),fE=ue({cumsum_:function ase(n,t=0,e=!1,r=!1){const o={x:Q(n,"x","cumsum")};return pe.runKernel(W_,o,{axis:t,exclusive:e,reverse:r})}}),mE=ue({denseBincount_:function lse(n,t,e,r=!1){const i=Q(n,"x","denseBincount"),o=Q(t,"weights","denseBincount");return Z("int32"===i.dtype,()=>`Error in denseBincount: input dtype must be int32, but got ${i.dtype}`),Z(i.rank<=2,()=>`Error in denseBincount: input must be at most rank 2, but got rank ${i.rank}.`),Z(e>=0,()=>`size must be non-negative, but got ${e}.`),Z(o.size===i.size||0===o.size,()=>`Error in denseBincount: weights must have the same shape as x or 0-length, but got x shape: ${i.shape}, weights shape: ${o.shape}.`),pe.runKernel(kC,{x:i,weights:o},{size:e,binaryOutput:r})}}),kB=ue({depthToSpace_:function cse(n,t,e="NHWC"){const r=Q(n,"x","depthToSpace","float32"),i="NHWC"===e?r.shape[1]:r.shape[2],o="NHWC"===e?r.shape[2]:r.shape[3],s="NHWC"===e?r.shape[3]:r.shape[1];return Z(t>1,()=>`blockSize should be > 1 for depthToSpace, but was: ${t}`),Z(i*t>=0,()=>`Negative dimension size caused by overflow when multiplying\n    ${i} and ${t}  for depthToSpace with input shape\n    ${r.shape}`),Z(o*t>=0,()=>`Negative dimension size caused by overflow when multiplying\n    ${o} and ${t} for depthToSpace with input shape\n        ${r.shape}`),Z(s%(t*t)==0,()=>`Dimension size must be evenly divisible by ${t*t} but is ${s} for depthToSpace with input shape ${r.shape}`),pe.runKernel(AC,{x:r},{blockSize:t,dataFormat:e})}}),ug=ue({depthwiseConv2d_:function use(n,t,e,r,i="NHWC",o=[1,1],s){const a=Q(n,"x","depthwiseConv2d","float32"),c=Q(t,"filter","depthwiseConv2d","float32");let u=a,p=!1;3===a.rank&&(p=!0,u=be(a,[1,a.shape[0],a.shape[1],a.shape[2]])),Z(4===u.rank,()=>`Error in depthwiseConv2d: input must be rank 4, but got rank ${u.rank}.`),Z(4===c.rank,()=>`Error in depthwiseConv2d: filter must be rank 4, but got rank ${c.rank}.`);const m="NHWC"===i?u.shape[3]:u.shape[1];Z(m===c.shape[2],()=>`Error in depthwiseConv2d: number of input channels (${m}) must match the inChannels dimension in filter ${c.shape[2]}.`),oo("depthwiseConv2d",r,s);const x=pe.runKernel(q_,{x:u,filter:c},{strides:e,pad:r,dataFormat:i,dilations:o,dimRoundingMode:s});return p?be(x,[x.shape[1],x.shape[2],x.shape[3]]):x}}),hse=ue({diag_:function dse(n){const e={x:Q(n,"x","diag")};return pe.runKernel(RC,e)}}),AB=ue({dilation2d_:function pse(n,t,e,r,i=[1,1],o="NHWC"){const s=Q(n,"x","dilation2d"),a=Q(t,"filter","dilation2d");Z(3===s.rank||4===s.rank,()=>`Error in dilation2d: input must be rank 3 or 4, but got rank ${s.rank}.`),Z(3===a.rank,()=>`Error in dilation2d: filter must be rank 3, but got rank ${a.rank}.`),Z("NHWC"===o,()=>`Error in dilation2d: Only NHWC is currently supported, but got dataFormat of ${o}`);let c=s,u=!1;3===s.rank&&(c=be(s,[1,s.shape[0],s.shape[1],s.shape[2]]),u=!0),Z(c.shape[3]===a.shape[2],()=>`Error in dilation2d:  input and filter must have the same depth: ${c.shape[3]} vs ${a.shape[2]}`);const g=pe.runKernel(K_,{x:c,filter:a},{strides:e,pad:r,dilations:i});return u?be(g,[g.shape[1],g.shape[2],g.shape[3]]):g}}),la=ue({equal_:function fse(n,t){let e=Q(n,"a","equal","string_or_numeric"),r=Q(t,"b","equal","string_or_numeric");return[e,r]=Tr(e,r),Yt(e.shape,r.shape),pe.runKernel(X_,{a:e,b:r})}}),Gi=ue({where_:function mse(n,t,e){const r=Q(t,"a","where"),i=Q(e,"b","where"),o=Q(n,"condition","where","bool"),s=Yt(Yt(o.shape,r.shape),i.shape),a=Fh(o,s),c=Fh(r,s),u=Fh(i,s);return pe.runKernel(I0,{condition:a,t:c,e:u})}}),NB=ue({divNoNan_:function gse(n,t){let e=Q(n,"a","div"),r=Q(t,"b","div");[e,r]=Tr(e,r);const i=Nt(e,r),o=vn(i),s=la(r,o);return Gi(s,o,i)}}),OB=ue({dot_:function bse(n,t){const e=Q(n,"t1","dot"),r=Q(t,"t2","dot");Z(!(1!==e.rank&&2!==e.rank||1!==r.rank&&2!==r.rank),()=>`Error in dot: inputs must all be rank 1 or 2, but got ranks ${e.rank} and ${r.rank}.`);const i=1===e.rank?e.size:e.shape[1],o=1===r.rank?r.size:r.shape[0];if(Z(i===o,()=>`Error in dot: inner dimensions of inputs must match, but got ${i} and ${o}.`),1===e.rank&&1===r.rank){const s=be(e,[1,-1]),a=be(r,[-1,1]),c=hn(s,a);return be(c,[])}if(1===e.rank&&2===r.rank){const s=be(e,[1,-1]),a=be(r,[r.shape[0],r.shape[1]]),c=hn(s,a);return be(c,[c.size])}if(2===e.rank&&1===r.rank){const s=be(r,[-1,1]),a=hn(e,s);return be(a,[a.size])}{const s=be(r,[r.shape[0],r.shape[1]]);return hn(e,s)}}}),_se=ue({einsum_:function yse(n,...t){const e=t.map((i,o)=>Q(i,`tensors${o}`,"einsum"));return pe.runKernel(PC,e,{equation:n})}}),dg=ue({elu_:function vse(n){const e={x:Q(n,"x","elu","float32")};return pe.runKernel(_m,e)}}),wse=ue({ensureShape_:function xse(n,t){const e=Q(n,"x","ensureShape","string_or_numeric");if(!function ire(n,t){if(n===t)return!0;if(null==n||null==t||n.length!==t.length)return!1;for(let e=0;e<n.length;e++)if(null!==n[e]&&null!==t[e]&&n[e]!==t[e])return!1;return!0}(e.shape,t))throw new Error(`EnsureShape: Shape of tensor ${e.shape} is not compatible with expected shape ${t}`);return n}}),RB=ue({erf_:function Tse(n){let t=Q(n,"x","erf");return Z("int32"===t.dtype||"float32"===t.dtype,()=>"Input dtype must be `int32` or `float32`."),"int32"===t.dtype&&(t=ht(t,"float32")),pe.runKernel(vm,{x:t})}});function gE(n,t){for(let e=0;e<n.length;++e)if(n[n.length-e-1]!==t-1-e)return!1;return!0}function MB(n,t,e){const r=n.length+t.length,i=[];let o=0,s=0;for(let a=0;a<r;a++)-1===e.indexOf(a)?i.push(n[o++]):i.push(t[s++]);return i}function gi(n,t){const e=[],r=n.length;for(let o=0;o<r;o++)-1===t.indexOf(o)&&e.push(n[o]);return[e,t.map(o=>n[o])]}function Rr(n,t){return MB(n,t.map(r=>1),t)}function ki(n,t,e){Z(gE(t,e),()=>`${n} supports only inner-most axes for now. Got axes ${t} and rank-${e} input.`)}function hr(n,t){if(gE(n,t))return null;const e=[];for(let r=0;r<t;++r)-1===n.indexOf(r)&&e.push(r);return n.forEach(r=>e.push(r)),e}function Sc(n){return n.map((t,e)=>[e,t]).sort((t,e)=>t[1]-e[1]).map(t=>t[0])}function Mr(n,t){const e=[];for(let r=t-n;r<t;++r)e.push(r);return e}const Ms=ue({max_:function Sse(n,t=null,e=!1){const i={x:Q(n,"x","max")};return pe.runKernel(l0,i,{reductionIndices:t,keepDims:e})}}),hg=ue({min_:function Cse(n,t=null,e=!1){const i={x:Q(n,"x","min")};return pe.runKernel(h0,i,{axis:t,keepDims:e})}}),St=ue({sum_:function Ise(n,t=null,e=!1){let r=Q(n,"x","sum");return"bool"===r.dtype&&(r=ht(r,"int32")),pe.runKernel(D0,{x:r},{axis:t,keepDims:e})}});function FB(n,t,e=null){if(0===n.rank)return ei(n);if(1!==n.rank&&null===e)return FB(be(n,[-1]),t,e);if(1===n.rank||"number"==typeof e||Array.isArray(e)&&1===e.length){if(1===t)return St(ei(n),e);if(t===1/0)return Ms(ei(n),e);if(t===-1/0)return hg(ei(n),e);if("euclidean"===t||2===t)return ji(St(vc(ei(n),Ft(2,"int32")),e));throw new Error(`Error in norm: invalid ord value: ${t}`)}if(Array.isArray(e)&&2===e.length){if(1===t)return Ms(St(ei(n),e[0]),e[1]-1);if(t===1/0)return Ms(St(ei(n),e[1]),e[0]);if(t===-1/0)return hg(St(ei(n),e[1]),e[0]);if("fro"===t||"euclidean"===t)return ji(St(Hn(n),e));throw new Error(`Error in norm: invalid ord value: ${t}`)}throw new Error(`Error in norm: invalid axis: ${e}`)}const pg=ue({norm_:function Ese(n,t="euclidean",e=null,r=!1){const i=FB(n=Q(n,"x","norm"),t,e);let o=i.shape;if(r){const s=cn(e,n.shape);o=Rr(i.shape,s)}return be(i,o)}}),PB=ue({euclideanNorm_:function Dse(n,t=null,e=!1){return pg(n,"euclidean",t,e)}}),ls=ue({exp_:function kse(n){const e={x:Q(n,"x","exp")};return pe.runKernel(xm,e)}}),To=ue({expandDims_:function Ase(n,t=0){const e=Q(n,"x","expandDims","string_or_numeric");return Z(t<=e.rank,()=>"Axis must be <= rank of the tensor"),pe.runKernel(Y_,{input:e},{dim:t})}}),$B=ue({expm1_:function Nse(n){const e={x:Q(n,"x","expm1")};return pe.runKernel(wm,e)}}),Fs=ue({tile_:function Ose(n,t){const e=Q(n,"x","tile","string_or_numeric");return Z(e.rank===t.length,()=>`Error in transpose: rank of input ${e.rank} must match length of reps ${t}.`),pe.runKernel(Jm,{x:e},{reps:t})}}),bE=ue({eye_:function Rse(n,t,e,r="float32"){null==t&&(t=n);const i=sn([n,t],r),o=n<=t?n:t;for(let a=0;a<o;++a)i.set(1,a,a);const s=be(i.toTensor(),[n,t]);if(null==e)return s;if(1===e.length)return Fs(To(s,0),[e[0],1,1]);if(2===e.length)return Fs(To(To(s,0),0),[e[0],e[1],1,1]);if(3===e.length)return Fs(To(To(To(s,0),0),0),[e[0],e[1],e[2],1,1]);throw new Error(`eye() currently supports only 1D and 2D batchShapes, but received ${e.length}D.`)}}),fg=ue({floor_:function Mse(n){const e={x:Q(n,"x","floor","float32")};return pe.runKernel(Tm,e)}}),mg=ue({gather_:function Fse(n,t,e=0,r=0){const i=Q(n,"x","gather"),o=Q(t,"indices","gather","int32");return pe.runKernel(Q_,{x:i,indices:o},{axis:e,batchDims:r})}}),jo=ue({greater_:function Pse(n,t){let e=Q(n,"a","greater","string_or_numeric"),r=Q(t,"b","greater","string_or_numeric");return[e,r]=Tr(e,r),Yt(e.shape,r.shape),pe.runKernel(J_,{a:e,b:r})}}),Cc=ue({greaterEqual_:function $se(n,t){let e=Q(n,"a","greaterEqual","string_or_numeric"),r=Q(t,"b","greaterEqual","string_or_numeric");return[e,r]=Tr(e,r),Yt(e.shape,r.shape),pe.runKernel(Cm,{a:e,b:r})}}),tv=ue({imag_:function Lse(n){const e={input:Q(n,"input","imag")};return pe.runKernel(jC,e)}}),LB=ue({isFinite_:function Bse(n){const e={x:Q(n,"x","isFinite")};return pe.runKernel(Em,e)}}),BB=ue({isInf_:function Vse(n){const e={x:Q(n,"x","isInf")};return pe.runKernel(Dm,e)}}),VB=ue({isNaN_:function zse(n){const e={x:Q(n,"x","isNaN")};return pe.runKernel(km,e)}}),nv=ue({leakyRelu_:function Use(n,t=.2){const r={x:Q(n,"x","leakyRelu")};return pe.runKernel(e0,r,{alpha:t})}}),gg=ue({less_:function jse(n,t){let e=Q(n,"a","less","string_or_numeric"),r=Q(t,"b","less","string_or_numeric");return[e,r]=Tr(e,r),Yt(e.shape,r.shape),pe.runKernel(t0,{a:e,b:r})}}),Mu=ue({lessEqual_:function Gse(n,t){let e=Q(n,"a","lessEqual","string_or_numeric"),r=Q(t,"b","lessEqual","string_or_numeric");return[e,r]=Tr(e,r),Yt(e.shape,r.shape),pe.runKernel(n0,{a:e,b:r})}});function Hse(n,t,e){if(e<=0)throw new Error("The number of values should be positive.");return pe.runKernel(GC,{},{start:n,stop:t,num:e})}const zB=ue({localResponseNormalization_:function Wse(n,t=5,e=1,r=1,i=.5){const o=Q(n,"x","localResponseNormalization");Z(4===o.rank||3===o.rank,()=>`Error in localResponseNormalization: x must be rank 3 or 4 but got\n               rank ${o.rank}.`),Z(bh(t),()=>`Error in localResponseNormalization: depthRadius must be an integer but got depthRadius ${t}.`);let s=o,a=!1;3===o.rank&&(a=!0,s=be(o,[1,o.shape[0],o.shape[1],o.shape[2]]));const p=pe.runKernel(a0,{x:s},{depthRadius:t,bias:e,alpha:r,beta:i});return a?be(p,[p.shape[1],p.shape[2],p.shape[3]]):p}}),cs=ue({log_:function qse(n){const e={x:Q(n,"x","log","float32")};return pe.runKernel(Am,e)}}),rv=ue({log1p_:function Kse(n){const e={x:Q(n,"x","log1p")};return pe.runKernel(Nm,e)}}),tr=ue({neg_:function Xse(n){const e={x:Q(n,"x","neg")};return pe.runKernel(f0,e)}}),Ph=ue({softplus_:function Yse(n){const e={x:Q(n,"x","softplus")};return pe.runKernel(qm,e)}}),UB=ue({logSigmoid_:function Zse(n){const t=Q(n,"x","logSigmoid");return vl(r=>({value:tr(Ph(tr(r))),gradFunc:s=>fe(s,Pa(tr(r)))}))(t)}}),yE=ue({logSoftmax_:function Qse(n,t=-1){const e=Q(n,"logits","logSoftmax");if(-1===t&&(t=e.rank-1),t!==e.rank-1)throw Error(`Log Softmax along a non-last dimension is not yet supported. Logits was rank ${e.rank} and axis was ${t}`);return vl((i,o)=>{const a=Ms(i,t,!0),c=xt(i,a),u=xt(ht(c,"float32"),cs(St(ls(c),t,!0)));return o([u]),{value:u,gradFunc:(m,g)=>{const[_]=g,T=ls(_);return xt(m,fe(St(m,t,!0),T))}}})(e)}}),_E=ue({logSumExp_:function Jse(n,t=null,e=!1){const r=Q(n,"x","logSumExp"),i=cn(t,r.shape),o=Ms(r,i,!0),s=xt(r,o),a=ls(s),c=St(a,i),u=cs(c),p=Xe(be(o,u.shape),u);if(e){const m=Rr(p.shape,i);return be(p,m)}return p}}),$a=ue({logicalAnd_:function eae(n,t){const e=Q(n,"a","logicalAnd","bool"),r=Q(t,"b","logicalAnd","bool");return Yt(e.shape,r.shape),pe.runKernel(r0,{a:e,b:r})}}),iv=ue({logicalNot_:function tae(n){const e={x:Q(n,"x","logicalNot","bool")};return pe.runKernel(o0,e)}}),vE=ue({logicalOr_:function nae(n,t){const e=Q(n,"a","logicalOr","bool"),r=Q(t,"b","logicalOr","bool");return Yt(e.shape,r.shape),pe.runKernel(s0,{a:e,b:r})}}),jB=ue({logicalXor_:function rae(n,t){const e=Q(n,"a","logicalXor","bool"),r=Q(t,"b","logicalXor","bool");return Yt(e.shape,r.shape),$a(vE(n,t),iv($a(n,t)))}}),ov=2147483648,xE=ue({searchSorted_:function iae(n,t,e="left"){const r=Q(n,"sortedSequence","searchSorted"),i=Q(t,"values","searchSorted"),s=i.shape[i.shape.length-1],a=be(r,[-1,r.shape[r.shape.length-1]]),c=be(i,[-1,s]);if(a.rank<2)throw new Error("Sorted input argument must be at least 2-dimensional");if(a.shape[0]!==c.shape[0])throw new Error("Leading dimension of 'sortedSequence' and 'values' must match.");if(Me(c.shape)>=ov)throw new Error(`values tensor size must less than ${ov}`);if(a.shape[1]>=ov)throw new Error(`trailing dim_size must less than ${ov} for int32 output type, was ${a.shape[1]}`);return pe.runKernel(lI,{sortedSequence:a,values:c},{side:e})}});function oae(n,t){return xE(n,t,"left")}const sv=ue({maxPool_:function sae(n,t,e,r,i){const o=Q(n,"x","maxPool");let a=o,c=!1;3===o.rank&&(c=!0,a=be(o,[1,o.shape[0],o.shape[1],o.shape[2]])),Z(4===a.rank,()=>`Error in maxPool: input must be rank 4 but got rank ${a.rank}.`),Z(Di(e,1),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${e} and dilations '1'`),oo("maxPool",r,i);const m=pe.runKernel(c0,{x:a},{filterSize:t,strides:e,pad:r,dimRoundingMode:i});return c?be(m,[m.shape[1],m.shape[2],m.shape[3]]):m}}),GB=ue({maxPool3d_:function aae(n,t=[1,1,1],e,r,i,o="NDHWC"){const s=Q(n,"x","maxPool3d");let a=s,c=!1;4===s.rank&&(c=!0,a=be(s,[1,s.shape[0],s.shape[1],s.shape[2],s.shape[3]])),Z(5===a.rank,()=>`Error in maxPool3d: x must be rank 5 but got rank ${a.rank}.`),Z("NDHWC"===o,()=>`Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of ${o}`),oo("maxPool3d",r,i);const m=pe.runKernel(u0,{x:a},{filterSize:t,strides:e,pad:r,dimRoundingMode:i,dataFormat:o});return c?be(m,[m.shape[1],m.shape[2],m.shape[3],m.shape[4]]):m}}),cae=ue({maxPoolWithArgmax_:function lae(n,t,e,r,i=!1){const s={x:Q(n,"x","maxPoolWithArgmax")},c=pe.runKernel(KC,s,{filterSize:t,strides:e,pad:r,includeBatchInIndex:i});return{result:c[0],indexes:c[1]}}}),Sr=ue({mean_:function uae(n,t=null,e=!1){const i={x:Q(n,"x","mean")};return pe.runKernel(d0,i,{axis:t,keepDims:e})}});function ni(n,t="float32"){if(ss(n),"complex64"===t){const r=ni(n,"float32"),i=ni(n,"float32");return gc(r,i)}const e=Ui(Me(n),t);return pe.makeTensor(e,n,t)}function us(n,t="float32"){if(ss(n),"complex64"===t){const r=us(n,"float32"),i=ni(n,"float32");return gc(r,i)}const e=pC(Me(n),t);return pe.makeTensor(e,n,t)}function dae(n,t,{indexing:e="xy"}={}){if("xy"!==e&&"ij"!==e)throw new TypeError(`${e} is not a valid third argument to meshgrid`);if(void 0===n)return[];let r=Q(n,"x","meshgrid",n instanceof sr?n.dtype:"float32");if(void 0===t)return[r];let i=Q(t,"y","meshgrid",t instanceof sr?t.dtype:"float32");const o=Me(r.shape),s=Me(i.shape);return"xy"===e?(r=be(r,[1,-1]),i=be(i,[-1,1]),[hn(us([s,1],r.dtype),r),hn(i,us([1,o],i.dtype))]):(r=be(r,[-1,1]),i=be(i,[1,-1]),[hn(r,us([1,s],r.dtype)),hn(us([o,1],i.dtype),i)])}const Fu=ue({minimum_:function hae(n,t){let e=Q(n,"a","minimum"),r=Q(t,"b","minimum");return[e,r]=Tr(e,r),"bool"===e.dtype&&(e=ht(e,"int32"),r=ht(r,"int32")),Yt(e.shape,r.shape),pe.runKernel(Rm,{a:e,b:r})}}),HB=ue({mirrorPad_:function pae(n,t,e){Z("reflect"===e||"symmetric"===e,()=>`Invalid mode. Mode must be either reflect or symmetric. Got ${e}.`);const r=Q(n,"x","mirrorPad");if(0===r.rank)throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");Z(t.length===r.rank,()=>`Padding doesn't match input. Must be ${r.rank}. Got ${t.length}.`);const i="reflect"===e?1:0;for(let a=0;a<r.rank;a++)Z(2===t[a].length,()=>"Invalid number of paddings. Must be length of 2 each."),Z(t[a][0]>=0&&t[a][0]<=r.shape[a]-i&&t[a][1]>=0&&t[a][1]<=r.shape[a]-i,()=>`Padding in dimension ${a} cannot be greater than or equal to ${r.shape[a]-i} or less than 0 for input of shape ${r.shape}`);return pe.runKernel(p0,{x:r},{paddings:t,mode:e})}}),WB=ue({mod_:function fae(n,t){let e=Q(n,"a","mod"),r=Q(t,"b","mod");return[e,r]=Tr(e,r),pe.runKernel(Mm,{a:e,b:r})}}),av=ue({moments_:function mae(n,t=null,e=!1){const r=cn(t,(n=Q(n,"x","moments")).shape),i=Sr(n,r,e);let o=i.shape;e||(o=Rr(i.shape,r));const s=Hn(xt(ht(n,"float32"),be(i,o)));return{mean:i,variance:Sr(s,r,e)}}}),bae=ue({multiRNNCell_:function gae(n,t,e,r){const i=Q(t,"data","multiRNNCell"),o=j0(e,"c","multiRNNCell"),s=j0(r,"h","multiRNNCell");let a=i;const c=[];for(let m=0;m<n.length;m++){const g=n[m](a,o[m],s[m]);c.push(g[0]),c.push(g[1]),a=g[1]}const u=[],p=[];for(let m=0;m<c.length;m+=2)u.push(c[m]),p.push(c[m+1]);return[u,p]}}),_ae=ue({multinomial_:function yae(n,t,e,r=!1){const i=Q(n,"logits","multinomial"),o=i.size,s=i.rank;if(o<2)throw new Error(`Error in multinomial: you need at least 2 outcomes, but got ${o}.`);if(s>2)throw new Error(`Rank of probabilities must be 1 or 2, but is ${s}`);e=e||Math.random();const c={logits:1===s?be(i,[1,-1]):i},p=pe.runKernel(XC,c,{numSamples:t,seed:e,normalized:r});return 1===s?be(p,[p.size]):p}}),$h=ue({notEqual_:function vae(n,t){let e=Q(n,"a","notEqual","string_or_numeric"),r=Q(t,"b","notEqual","string_or_numeric");return[e,r]=Tr(e,r),Yt(e.shape,r.shape),pe.runKernel(m0,{a:e,b:r})}}),wE=ue({oneHot_:function xae(n,t,e=1,r=0,i="int32"){if(t<2)throw new Error(`Error in oneHot: depth must be >=2, but it is ${t}`);const s={indices:Q(n,"indices","oneHot","int32")};return pe.runKernel(b0,s,{dtype:i,depth:t,onValue:e,offValue:r})}}),ds=ue({onesLike_:function wae(n){const e={x:Q(n,"x","onesLike")};return pe.runKernel(g0,e)}}),Sae=ue({outerProduct_:function Tae(n,t){const e=Q(n,"v1","outerProduct"),r=Q(t,"v2","outerProduct");Z(1===e.rank&&1===r.rank,()=>`Error in outerProduct: inputs must be rank 1, but got ranks ${e.rank} and ${r.rank}.`);const i=be(e,[-1,1]),o=be(r,[1,-1]);return hn(i,o)}}),Ic=ue({pad_:function Cae(n,t,e=0){const r=Q(n,"x","pad");if(0===r.rank)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");return pe.runKernel(_0,{x:r},{paddings:t,constantValue:e})}}),Eae=ue({pad1d_:function Iae(n,t,e=0){return Z(2===t.length,()=>"Invalid number of paddings. Must be length of 2."),Ic(n,[t],e)}}),kae=ue({pad2d_:function Dae(n,t,e=0){return Z(2===t.length&&2===t[0].length&&2===t[1].length,()=>"Invalid number of paddings. Must be length of 2 each."),Ic(n,t,e)}}),Nae=ue({pad3d_:function Aae(n,t,e=0){return Z(3===t.length&&2===t[0].length&&2===t[1].length&&2===t[2].length,()=>"Invalid number of paddings. Must be length of 2 each."),Ic(n,t,e)}}),Rae=ue({pad4d_:function Oae(n,t,e=0){return Z(4===t.length&&2===t[0].length&&2===t[1].length&&2===t[2].length&&2===t[3].length,()=>"Invalid number of paddings. Must be length of 2 each."),Ic(n,t,e)}}),lv=ue({spaceToBatchND_:function Mae(n,t,e){const r=Q(n,"x","spaceToBatchND");return Z(r.rank>=1+t.length,()=>`input rank ${r.rank} should be > than [blockShape] ${t.length}`),Z(e.length===t.length,()=>`paddings.shape[0] ${e.length} must be equal to [blockShape] ${t.length}`),Z(r.shape.reduce((s,a,c)=>c>0&&c<=t.length?s&&(a+e[c-1][0]+e[c-1][1])%t[c-1]==0:s,!0),()=>`input spatial dimensions ${r.shape.slice(1)} with paddings ${e.toString()} must be divisible by blockShapes ${t.toString()}`),pe.runKernel(k0,{x:r},{blockShape:t,paddings:e})}}),qB=ue({pool_:function Fae(n,t,e,r,i,o,s){null==i&&(i=[1,1]),null==o&&(o=1),0===r&&(r="valid");const a=Q(n,"x","maxPool");let c=a,u=!1;3===a.rank&&(u=!0,c=be(a,[1,a.shape[0],a.shape[1],a.shape[2]])),Z(Di(o,i),()=>`Error in pool: Either strides or dilations must be 1. Got strides ${o} and dilations '${i}'`);const p=Rs(c.shape,t,o,i,r),m=[p.dilationHeight,p.dilationWidth];let g;g="same"===r?function $ae(n,t){const r=n.map((s,a)=>s+(s-1)*(t[a]-1)).map(s=>s-1),i=r.map(s=>Math.floor(s/2)),o=r.map((s,a)=>s-i[a]);return r.map((s,a)=>[i[a],o[a]])}([p.filterHeight,p.filterWidth],m):[[0,0],[0,0]];const _=1===m[0]&&1===m[1],[x,T]=function Pae(n,t,e){const r=e.map(p=>p[0]),i=e.map(p=>p[1]),o=n.concat(r,i),s=t.map((p,m)=>(p-o[m]%p)%p),a=i.map((p,m)=>p+s[m]),c=t.map((p,m)=>[r[m],a[m]]),u=t.map((p,m)=>[0,s[m]]);return[c,u]}([p.inHeight,p.inWidth],m,g),I=_?r:"valid",N=_?c:lv(c,m,x),L=("avg"===e?()=>Z0(N,t,o,I,s):()=>sv(N,t,o,I,s))(),V=_?L:Q0(L,m,T);return u?be(V,[V.shape[1],V.shape[2],V.shape[3]]):V}}),cv=ue({prelu_:function Lae(n,t){const e=Q(n,"x","prelu"),r=Q(t,"alpha","prelu");return pe.runKernel(v0,{x:e,alpha:r})}}),KB=ue({prod_:function Bae(n,t=null,e=!1){let r=Q(n,"x","prod");return"bool"===r.dtype&&(r=ht(r,"int32")),pe.runKernel(x0,{x:r},{axis:t,keepDims:e})}}),zae=ue({raggedGather_:function Vae(n,t,e,r){const i=n.map((p,m)=>Q(p,`tensors${m}`,"raggedGather","int32")),o=Q(t,"paramsDenseValues","raggedGather"),s=Q(e,"indices","raggedGather","int32"),u=pe.runKernel(JC,{paramsNestedSplits:i,paramsDenseValues:o,indices:s},{outputRaggedRank:r});return{outputNestedSplits:u.slice(0,u.length-1),outputDenseValues:u[u.length-1]}}}),jae=ue({raggedRange_:function Uae(n,t,e){const r=Q(n,"starts","raggedRange"),i=Q(t,"limits","raggedRange",r.dtype),o=Q(e,"deltas","raggedRange",r.dtype),a=pe.runKernel(eI,{starts:r,limits:i,deltas:o});return{rtNestedSplits:a[0],rtDenseValues:a[1]}}}),Hae=ue({raggedTensorToTensor_:function Gae(n,t,e,r,i){const o=Q(n,"shape","raggedTensorToTensor","int32"),s=Q(t,"values","raggedTensorToTensor"),a=Q(e,"defaultValue","raggedTensorToTensor",s.dtype),c=r.map((m,g)=>Q(m,`tensors${g}`,"raggedTensorToTensor","int32"));return pe.runKernel(tI,{shape:o,values:s,defaultValue:a,rowPartitionTensors:c},{rowPartitionTypes:i})}}),qae=ue({rand_:function Wae(n,t,e){ss(n);const r=Me(n);let i=null;if(null==e||"float32"===e)i=new Float32Array(r);else if("int32"===e)i=new Int32Array(r);else{if("bool"!==e)throw new Error(`Unknown data type ${e}`);i=new Uint8Array(r)}for(let o=0;o<r;o++)i[o]=t();return pe.makeTensor(i,n,e)}});var uv=P(340);class TE{constructor(t,e,r,i,o){this.mean=t,this.stdDev=e,this.dtype=r,this.nextVal=NaN,this.truncated=i,this.truncated&&(this.upper=this.mean+2*this.stdDev,this.lower=this.mean-2*this.stdDev);const s=o||Math.random();this.random=uv.alea(s.toString())}nextValue(){if(!isNaN(this.nextVal)){const i=this.nextVal;return this.nextVal=NaN,i}let t,e,r=!1;for(;!r;){let i,o,s;do{i=2*this.random()-1,o=2*this.random()-1,s=i*i+o*o}while(s>=1||0===s);const a=Math.sqrt(-2*Math.log(s)/s);t=this.mean+this.stdDev*i*a,e=this.mean+this.stdDev*o*a,(!this.truncated||this.isValidTruncated(t))&&(r=!0)}return(!this.truncated||this.isValidTruncated(e))&&(this.nextVal=this.convertValue(e)),this.convertValue(t)}convertValue(t){return null==this.dtype||"float32"===this.dtype?t:Math.round(t)}isValidTruncated(t){return t<=this.upper&&t>=this.lower}}class Kae{constructor(t,e,r,i){this.alpha=t,this.beta=1/e,this.dtype=r;const o=i||Math.random();this.randu=uv.alea(o.toString()),this.randn=new TE(0,1,r,!1,this.randu()),this.d=t<1?t+2/3:t-1/3,this.c=1/Math.sqrt(9*this.d)}nextValue(){let t,e,r,i,o,s;for(;;){do{i=this.randn.nextValue(),s=1+this.c*i}while(s<=0);if(s*=s*s,t=i*i,e=1-.331*t*t,r=.5*t+this.d*(1-s+Math.log(s)),o=this.randu(),o<e||Math.log(o)<r)break}return s*=1/this.beta*this.d,this.alpha<1&&(s*=Math.pow(this.randu(),1/this.alpha)),this.convertValue(s)}convertValue(t){return"float32"===this.dtype?t:Math.round(t)}}class Xae{constructor(t=0,e=1,r,i){if(this.canReturnFloat=()=>null==this.dtype||"float32"===this.dtype,this.min=t,this.range=e-t,this.dtype=r,null==i&&(i=Math.random()),"number"==typeof i&&(i=i.toString()),!this.canReturnFloat()&&this.range<=1)throw new Error(`The difference between ${t} - ${e} <= 1 and dtype is not float`);this.random=uv.alea(i)}convertValue(t){return this.canReturnFloat()?t:Math.round(t)}nextValue(){return this.convertValue(this.min+this.range*this.random())}}const ele=ue({randomGamma_:function Jae(n,t,e=1,r="float32",i){if(ss(n),null==e&&(e=1),null==r&&(r="float32"),"float32"!==r&&"int32"!==r)throw new Error(`Unsupported data type ${r}`);const o=new Kae(t,e,r,i),s=sn(n,r);for(let a=0;a<s.values.length;a++)s.values[a]=o.nextValue();return s.toTensor()}}),CE=ue({randomNormal_:function tle(n,t=0,e=1,r,i){if(ss(n),null!=r&&"bool"===r)throw new Error(`Unsupported data type ${r}`);const o=new TE(t,e,r,!1,i),s=sn(n,r);for(let a=0;a<s.values.length;a++)s.values[a]=o.nextValue();return s.toTensor()}}),rle=ue({randomStandardNormal_:function nle(n,t,e){if(null!=t&&"bool"===t)throw new Error(`Unsupported data type ${t}`);return CE(n,0,1,t,e)}}),Pu=ue({randomUniform_:function ile(n,t=0,e=1,r="float32",i){ss(n);const o=sn(n,r),s=new Xae(t,e,null,i);for(let a=0;a<o.values.length;a++)o.values[a]=s.nextValue();return o.toTensor()}}),sle=ue({randomUniformInt_:function ole(n,t,e,r){return Pu(n,t,e,"int32",r)}});function Lh(n,t,e=1,r="float32"){if(0===e)throw new Error("Cannot have a step of zero");return pe.runKernel(nI,{},{start:n,stop:t,step:e,dtype:r})}const bg=ue({real_:function ale(n){const e={input:Q(n,"input","real")};return pe.runKernel(rI,e)}}),XB=ue({reciprocal_:function lle(n){const e={x:Q(n,"x","reciprocal")};return pe.runKernel($m,e)}}),La=ue({relu_:function cle(n){const e={x:Q(n,"x","relu")};return pe.runKernel(Lm,e)}}),IE=ue({relu6_:function ule(n){const e={x:Q(n,"x","relu6")};return pe.runKernel(Bm,e)}}),Ps=ue({reverse_:function dle(n,t){const r={x:Q(n,"x","reverse")};return pe.runKernel(C0,r,{dims:t})}}),ple=ue({reverse1d_:function hle(n){const t=Q(n,"x","reverse");return Z(1===t.rank,()=>`Error in reverse1D: x must be rank 1 but got rank ${t.rank}.`),Ps(t,0)}}),mle=ue({reverse2d_:function fle(n,t){const e=Q(n,"x","reverse");return Z(2===e.rank,()=>`Error in reverse2D: x must be rank 2 but got rank ${e.rank}.`),Ps(e,t)}}),ble=ue({reverse3d_:function gle(n,t){const e=Q(n,"x","reverse");return Z(3===e.rank,()=>`Error in reverse3D: x must be rank 3 but got rank ${e.rank}.`),Ps(e,t)}}),_le=ue({reverse4d_:function yle(n,t){const e=Q(n,"x","reverse");return Z(4===e.rank,()=>`Error in reverse4D: x must be rank 4 but got rank ${e.rank}.`),Ps(e,t)}}),EE=ue({round_:function vle(n){const e={x:Q(n,"x","round")};return pe.runKernel(Vm,e)}}),DE=ue({rsqrt_:function xle(n){const e={x:Q(n,"x","rsqrt","float32")};return pe.runKernel(zm,e)}}),kE=ue({selu_:function wle(n){const e={x:Q(n,"x","selu")};return pe.runKernel(Um,e)}}),AE=ue({separableConv2d_:function Tle(n,t,e,r,i,o=[1,1],s="NHWC"){const a=Q(n,"x","separableConv2d"),c=Q(t,"depthwiseFilter","separableConv2d"),u=Q(e,"pointwiseFilter","separableConv2d");let p=a,m=!1;if(3===a.rank&&(m=!0,p=be(a,[1,a.shape[0],a.shape[1],a.shape[2]])),"NCHW"===s)throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");Z(4===p.rank,()=>`Error in separableConv2d: input must be rank 4, but got rank ${p.rank}.`),Z(4===c.rank,()=>`Error in separableConv2d: depthwise filter must be rank 4, but got rank ${c.rank}.`),Z(4===u.rank,()=>`Error in separableConv2d: pointwise filter must be rank 4, but got rank ${c.rank}.`),Z(1===u.shape[0],()=>`Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got ${u.shape[0]}.`),Z(1===u.shape[1],()=>`Error in separableConv2d: the second dimension of pointwise filter must be 1, but got ${u.shape[1]}.`);const g=c.shape[2],_=c.shape[3];Z(u.shape[2]===g*_,()=>`Error in separableConv2d: the third dimension of pointwise filter must be ${g*_}, but got ${u.shape[2]}.`);const x=ug(p,c,r,i,s,o),I=Tc(x,u,1,"valid",s);return m?be(I,[I.shape[1],I.shape[2],I.shape[3]]):I}});function NE(){return(NE=$e(function*(n,t){const e=Q(n,"x","setdiff1d"),r=Q(t,"y","setdiff1d");Z(e.dtype===r.dtype,()=>`x and y should have the same dtype, but got x (${e.dtype}) and y (${r.dtype}).`),Z(1===e.rank,()=>`x should be 1D tensor, but got x (${e.shape}).`),Z(1===r.rank,()=>`y should be 1D tensor, but got y (${r.shape}).`);const i=yield e.data(),o=yield r.data(),s=new Set(o);let a=0;for(let p=0;p<i.length;p++)s.has(i[p])||a++;const c=new Jr([a],e.dtype),u=new Jr([a],"int32");for(let p=0,m=0;p<i.length;p++)s.has(i[p])||(c.values[m]=i[p],u.values[m]=p,m++);return[c.toTensor(),u.toTensor()]})).apply(this,arguments)}const Cle=function Sle(n,t){return NE.apply(this,arguments)},YB=ue({sign_:function Ile(n){const e={x:Q(n,"x","sign")};return pe.runKernel(Hm,e)}}),OE=ue({sin_:function Ele(n){const e={x:Q(n,"x","sin","float32")};return pe.runKernel(jm,e)}}),RE=ue({sinh_:function Dle(n){const e={x:Q(n,"x","sinh")};return pe.runKernel(Gm,e)}}),dv=ue({slice1d_:function kle(n,t,e){const r=Q(n,"x","slice1d");return Z(1===r.rank,()=>`slice1d expects a rank-1 tensor, but got a rank-${r.rank} tensor`),xn(r,[t],[e])}}),ME=ue({slice2d_:function Ale(n,t,e){const r=Q(n,"x","slice2d");return Z(2===r.rank,()=>`slice2d expects a rank-2 tensor, but got a rank-${r.rank} tensor`),xn(r,t,e)}}),hv=ue({slice3d_:function Nle(n,t,e){const r=Q(n,"x","slice3d");return Z(3===r.rank,()=>`slice3d expects a rank-3 tensor, but got a rank-${r.rank} tensor`),xn(r,t,e)}}),yg=ue({slice4d_:function Ole(n,t,e){const r=Q(n,"x","slice4d");return Z(4===r.rank,()=>`slice4d expects a rank-4 tensor, but got a rank-${r.rank} tensor`),xn(r,t,e)}}),pv=ue({softmax_:function Rle(n,t=-1){const e=Q(n,"logits","softmax","float32");if(-1===t&&(t=e.rank-1),t!==e.rank-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${e.rank} and dim was ${t}`);return pe.runKernel(N0,{logits:e},{dim:t})}}),fv=ue({fft_:function Mle(n){return Z("complex64"===n.dtype,()=>`The dtype for tf.spectral.fft() must be complex64 but got ${n.dtype}.`),pe.runKernel("FFT",{input:n})}}),_g=ue({ifft_:function Fle(n){return Z("complex64"===n.dtype,()=>`The dtype for tf.spectral.ifft() must be complex64 but got ${n.dtype}.`),pe.runKernel(UC,{input:n})}}),FE=ue({irfft_:function Ple(n){const t=n.shape[n.shape.length-1],e=n.size/t;let r;if(t<=2){const i=be(n,[e,t]);r=_g(i)}else{const i=[e,2*(t-1)],o=be(bg(n),[e,t]),s=be(tv(n),[e,t]),a=Ps(xn(o,[0,1],[e,t-2]),1),c=fe(Ps(xn(s,[0,1],[e,t-2]),1),Ft(-1)),u=Ur([o,a],1),p=Ur([s,c],1),m=be(gc(u,p),[i[0],i[1]]);r=_g(m)}if(r=bg(r),3===n.rank&&0!==n.shape[0]){const i=r,o=n.shape[0];r=be(r,[o,r.shape[0]/o,r.shape[1]]),i.dispose()}return r}}),Go=ue({split_:function $le(n,t,e=0){const i={x:Q(n,"x","split")};return pe.runKernel(A0,i,{numOrSizeSplits:t,axis:e})}}),mv=ue({rfft_:function Lle(n,t){Z("float32"===n.dtype,()=>`The dtype for rfft() must be real value but got ${n.dtype}`);let e=n.shape[n.shape.length-1];const r=n.size/e;let i;if(null!=t&&t<e){const x=n.shape.map(I=>0),T=n.shape.map(I=>I);T[n.shape.length-1]=t,i=xn(n,x,T),e=t}else if(null!=t&&t>e){const x=n.shape.map(T=>T);x[n.shape.length-1]=t-e,i=Ur([n,ni(x)],n.shape.length-1),e=t}else i=n;const o=vn(i),s=be(gc(i,o),[r,e]),a=fv(s),c=Math.floor(e/2)+1,u=bg(a),p=tv(a),m=Go(u,[c,e-c],u.shape.length-1),g=Go(p,[c,e-c],p.shape.length-1),_=i.shape.slice();return _[i.shape.length-1]=c,be(gc(m[0],g[0]),_)}}),PE=ue({squaredDifference_:function Ble(n,t){let e=Q(n,"a","squaredDifference"),r=Q(t,"b","squaredDifference");return[e,r]=Tr(e,r),Yt(e.shape,r.shape),pe.runKernel(Xm,{a:e,b:r},{})}}),$u=ue({squeeze_:function Vle(n,t){const e=Q(n,"x","squeeze","string_or_numeric");return be(e,sc(e.shape,t).newShape)}}),hs=ue({stack_:function zle(n,t=0){const e=j0(n,"tensors","stack","string_or_numeric");return Z(e.length>=1,()=>"Pass at least one tensor to tf.stack"),e.length>0&&Z(t<=e[0].rank,()=>"Axis must be <= rank of the tensor"),pe.runKernel(y0,e,{axis:t})}}),Bh=ue({step_:function Ule(n,t=0){const r={x:Q(n,"x","step")};return pe.runKernel(eg,r,{alpha:t})}}),ZB=ue({stridedSlice_:function jle(n,t,e,r,i=0,o=0,s=0,a=0,c=0){const p={x:Q(n,"x","stridedSlice","string_or_numeric")};return pe.runKernel(mI,p,{begin:t,end:e,strides:r,beginMask:i,endMask:o,ellipsisMask:s,newAxisMask:a,shrinkAxisMask:c})}}),QB=ue({tan_:function Gle(n){const e={x:Q(n,"x","tan","float32")};return pe.runKernel(Zm,e)}});function So(n,t){gh(n);const e=mc(n,t);if(1!==e.length)throw new Error("tensor1d() requires values to be a flat/TypedArray");return bc(n,null,e,t)}function Vh(n,t,e){if(gh(n),null!=t&&2!==t.length)throw new Error("tensor2d() requires shape to have two numbers");const r=mc(n,e);if(2!==r.length&&1!==r.length)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(1===r.length&&null==t)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return bc(n,t,r,e)}function Hle(n,t,e){if(gh(n),null!=t&&3!==t.length)throw new Error("tensor3d() requires shape to have three numbers");const r=mc(n,e);if(3!==r.length&&1!==r.length)throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");if(1===r.length&&null==t)throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");return bc(n,t,r,e)}function Wle(n,t,e){if(gh(n),null!=t&&4!==t.length)throw new Error("tensor4d() requires shape to have four numbers");const r=mc(n,e);if(4!==r.length&&1!==r.length)throw new Error("tensor4d() requires values to be number[][][][] or flat/TypedArray");if(1===r.length&&null==t)throw new Error("tensor4d() requires shape to be provided when `values` are a flat array");return bc(n,t,r,e)}function qle(n,t,e){if(gh(n),null!=t&&5!==t.length)throw new Error("tensor5d() requires shape to have five numbers");const r=mc(n,e);if(5!==r.length&&1!==r.length)throw new Error("tensor5d() requires values to be number[][][][][] or flat/TypedArray");if(1===r.length&&null==t)throw new Error("tensor5d() requires shape to be provided when `values` are a flat array");return bc(n,t,r,e)}function Kle(n,t,e){if(gh(n),null!=t&&6!==t.length)throw new Error("tensor6d() requires shape to have six numbers");const r=mc(n,e);if(6!==r.length&&1!==r.length)throw new Error("tensor6d() requires values to be number[][][][][][] or flat/TypedArray");if(1===r.length&&null==t)throw new Error("tensor6d() requires shape to be provided when `values` are a flat array");return bc(n,t=t||r,r,e)}function JB(n,t,e){const r=t.rank>1?t.shape[t.rank-1]:1,i=t.rank>1?t.rank-1:1,o=`Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${e.shape}, indices.shape: ${t.shape}, shape: ${n}, sliceDim: ${r}, and batchDim: ${i}.`;if(e.rank<i)throw new Error(o+` update.rank < ${i}. `);if(n.length<r+(e.rank-i))throw new Error(o+` Output shape length < ${r+(e.rank-i)}`);if(e.rank!==i+n.length-r)throw new Error(o+" update.rank != "+(i+n.length-r));for(let s=0;s<i;++s)if(e.shape[s]!==t.shape[s])throw new Error(o+` updates.shape[${s}] (${e.shape[s]}) != indices.shape[${s}] (${t.shape[s]}).`);for(let s=0;s<e.rank-i;++s)if(e.shape[s+i]!==n[s+r])throw new Error(o+` updates.shape[${s+i}] (${e.shape[s+i]}) != shape[${s+i}] (${n[s+i]})`)}function $E(n,t,e){if(t.rank<1)throw new Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${t.rank}.`);if(n.rank<1)throw new Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${n.rank}.`);if("int32"!==t.dtype)throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${t.dtype}`);if(e.length<1)throw new Error(`Output rank must be greater or equal to 1, but got shape: ${e}`);if(0===e.length){if(0===t.size)throw new Error(`Indices specified for empty output. indices shape: ${t.shape}`);if(0===n.size)throw new Error(`Updates specified for empty output. updates shape: ${n.shape}`)}JB(e,t,n)}function Lu(n,t,e){const r=t.shape.length,i=r>1?t.shape[r-1]:1,o=e.length;let s=1;for(let m=i;m<o;++m)s*=e[m];const a=i<1?1:i;return{sliceRank:i,numUpdates:Me(t.shape)/a,sliceSize:s,strides:[...Rt(e.slice(0,i)),1],outputSize:Me(e)}}const Yle=ue({tensorScatterUpdate_:function Xle(n,t,e){const r=Q(n,"tensor","tensorScatterupdate"),i=Q(t,"indices","tensorScatterupdate","int32"),o=Q(e,"updates","tensorScatterupdate");if($E(o,i,r.shape),r.dtype!==o.dtype)throw new Error(`tensor and updates must have the same dtype, instead they are ${r.dtype} and ${o.dtype}.`);return pe.runKernel(aI,{tensor:r,indices:i,updates:o},{})}}),eV=ue({topk_:function Zle(n,t=1,e=!0){const r=Q(n,"x","topk");if(0===r.rank)throw new Error("topk() expects the input to be of rank 1 or higher");const i=r.shape[r.shape.length-1];if(t<0)throw new Error(`'k' passed to topk() must be >= 0 but got ${t}`);if(t>i)throw new Error(`'k' passed to topk() must be <= the last dimension (${i}) but got ${t}`);const o={x:r},s={k:t,sorted:e},[a,c]=pe.runKernel(_I,o,s);return{values:a,indices:c}}}),LE=ue({truncatedNormal_:function Qle(n,t=0,e=1,r,i){if(ss(n),null!=r&&"bool"===r)throw new Error("Unsupported data type $ { dtype }");const o=new TE(t,e,r,!0,i),s=sn(n,r);for(let a=0;a<s.values.length;a++)s.values[a]=o.nextValue();return s.toTensor()}}),tV=ue({unique_:function Jle(n,t=0){const e=Q(n,"x","unique","string_or_numeric");Z(e.rank>0,()=>"The input tensor must be at least 1D");const r={x:e},i={axis:t},[o,s]=pe.runKernel(xI,r,i);return{values:o,indices:s}}}),BE=ue({unsortedSegmentSum_:function ece(n,t,e){const r=Q(n,"x","unsortedSegmentSum"),i=Q(t,"segmentIds","unsortedSegmentSum","int32");return Z(bh(e),()=>"numSegments must be of dtype int"),pe.runKernel(M0,{x:r,segmentIds:i},{numSegments:e})}}),$s=ue({unstack_:function tce(n,t=0){const e=Q(n,"x","unstack","string_or_numeric");return Z(t>=-e.shape.length&&t<e.shape.length,()=>`Axis = ${t} is not in [-${e.shape.length}, ${e.shape.length})`),pe.runKernel(R0,{value:e},{axis:t})}});function nce(n,t){return xE(n,t,"right")}function nV(n,t=!0,e,r){return pe.makeVariable(n,t,e,r)}function VE(n,t){const e=[];for(let o=0;o<t.length;o++)t[o]&&e.push(o);const r=sn(n,"int32"),i=sn([e.length,n.length],"int32");for(let o=0;o<e.length;o++){const s=r.indexToLoc(e[o]);i.values.set(s,o*n.length)}return i.toTensor()}function zE(){return(zE=$e(function*(n){const t=Q(n,"condition","whereAsync","bool"),e=yield t.data(),r=VE(t.shape,e);return n!==t&&t.dispose(),r})).apply(this,arguments)}const rV=function rce(n){return zE.apply(this,arguments)};function UE(){return(UE=$e(function*(n,t,e){const r=Q(n,"tensor","boolMask"),i=Q(t,"mask","boolMask","bool"),o=e??0,s=i.rank,a=r.shape;Z(s>0,()=>"mask cannot be scalar"),Vo(a.slice(o,o+s),i.shape,"mask's shape must match the first K dimensions of tensor's shape,");let c=1;for(let T=o;T<o+s;T++)c*=a[T];const u=a.slice(0,o).concat([c],a.slice(o+s)),p=be(r,u),m=be(i,[-1]),g=yield rV(m),_=$u(g,[1]),x=mg(p,_,o);return n!==r&&r.dispose(),t!==i&&i.dispose(),_.dispose(),p.dispose(),m.dispose(),g.dispose(),x})).apply(this,arguments)}const oce=function ice(n,t,e){return UE.apply(this,arguments)},wn=ue({transpose_:function sce(n,t,e){const r=Q(n,"x","transpose");if(null==t&&(t=r.shape.map((s,a)=>a).reverse()),Z(r.rank===t.length,()=>`Error in transpose: rank of input ${r.rank} must match length of perm ${t}.`),t.forEach(s=>{Z(s>=0&&s<r.rank,()=>`All entries in 'perm' must be between 0 and ${r.rank-1} but got ${t}`)}),r.rank<=1)return r.clone();const i={x:r},o={perm:t};return"complex64"===r.dtype?Se(()=>{let s=bg(r),a=tv(r);return s=pe.runKernel(wh,{x:s},o),a=pe.runKernel(wh,{x:a},o),e&&(a=tr(a)),gc(s,a)}):pe.runKernel(wh,i,o)}}),lce=ue({movingAverage_:function ace(n,t,e,r,i=!0){const o=Q(n,"v","movingAverage"),s=Q(t,"x","movingAverage"),a=Q(e,"decay","movingAverage");(function Bre(n,t){Z(n.dtype===t.dtype,()=>`The dtypes of the first(${n.dtype}) and second(${t.dtype}) input must match`)})(o,s),Z(mn(o.shape,s.shape),()=>"Shape mismatch in v and x");const c=Ft(1),u=xt(c,a);let p=fe(xt(s,o),u);if(i){Z(null!=r,()=>"When using zeroDebias: true, step is required.");const m=Q(r,"step","movingAverage");p=Nt(p,xt(c,vc(a,m)))}return Xe(o,p)}}),uce=ue({scatterND_:function cce(n,t,e){ss(e);const r=Q(n,"indices","scatterND","int32"),i=Q(t,"updates","scatterND");return $E(i,r,e),pe.runKernel(sI,{indices:r,updates:i},{shape:e})}}),pce=ue({sparseToDense_:function hce(n,t,e,r=0){ss(e);const i=Q(n,"sparseIndices","sparseToDense","int32"),o=Q(t,"sparseValues","sparseToDense","string_or_numeric"),s=Q(r,"defaultValue","sparseToDense",o.dtype);return function dce(n,t,e,r){if("int32"!==n.dtype)throw new Error(`tf.sparseToDense() expects the indices to be int32 type, but the dtype was ${n.dtype}.`);if(n.rank>2)throw new Error(`sparseIndices should be a scalar, vector, or matrix, but got shape ${n.shape}.`);const i=n.rank>0?n.shape[0]:1,o=n.rank>1?n.shape[1]:1;if(e.length!==o)throw new Error(`outputShape has incorrect number of elements:, ${e.length}, should be: ${o}.`);if(0!==t.rank&&(1!==t.rank||t.size!==i))throw new Error(`sparseValues has incorrect shape ${t.shape}, should be [] or [${i}]`);if(t.dtype!==r.dtype)throw new Error("sparseValues.dtype must match defaultValues.dtype")}(i,o,e,s),pe.runKernel(pI,{sparseIndices:i,sparseValues:o,defaultValue:s},{outputShape:e})}}),mce=ue({gatherND_:function fce(n,t){const e=Q(t,"indices","gatherND","int32"),i={params:Q(n,"x","gatherND","string_or_numeric"),indices:e};return pe.runKernel(zC,i)}}),iV=ue({dropout_:function bce(n,t,e,r){const i=Q(n,"x","dropout");if(Z("float32"===i.dtype,()=>`x has to be a floating point tensor since it's going to be scaled, but got a ${i.dtype} tensor instead.`),Z(t>=0&&t<1,()=>`rate must be a float in the range [0, 1), but got ${t}.`),0===t)return n instanceof sr?i.clone():i;const o=function gce(n,t){if(null==t)return n.shape.slice();if(mn(n.shape,t))return t;if(n.shape.length===t.length){const e=[];for(let r=0;r<n.shape.length;r++)e.push(null==t[r]&&null!=n.shape[r]?n.shape[r]:t[r]);return e}return t}(i,e),s=1-t,a=Nt(fg(Xe(Pu(o,0,1,"float32",r),s)),s);return fe(i,a)}});function oV(n){return Math.floor(Math.pow(2,Math.ceil(Math.log(n)/Math.log(2))))}function jE(n,t,e){const r=1-n%2,i=new Float32Array(n);for(let o=0;o<n;++o){const s=2*Math.PI*o/(n+r-1);i[o]=t-e*Math.cos(s)}return So(i,"float32")}function GE(){return(GE=$e(function*(n,t,e=1){const r=Q(n,"predictions","inTopK"),i=Q(t,"targets","inTopK");Z(r.rank>1,()=>`inTopK() expects the predictions to be of rank 2 or higher, but got ${r.rank}`),Z(r.rank-1===i.rank,()=>`predictions rank should be 1 larger than targets rank, but got predictions rank ${r.rank} and targets rank ${i.rank}`),Vo(r.shape.slice(0,r.shape.length-1),i.shape,"predictions's shape should be align with the targets' shape, except the last dimension.");const o=r.shape[r.shape.length-1];Z(e>0&&e<=o,()=>`'k' passed to inTopK() must be > 0 && <= the predictions last dimension (${o}), but got ${e}`);const s=yield r.data(),a=yield i.data(),[c,u]=[s.length/o,o],p=Ei("bool",c);for(let m=0;m<c;m++){const g=m*u,_=s.subarray(g,g+u),x=[];for(let T=0;T<_.length;T++)x.push({value:_[T],index:T});x.sort((T,I)=>I.value-T.value),p[m]=0;for(let T=0;T<e;T++)if(x[T].index===a[m]){p[m]=1;break}}return n!==r&&r.dispose(),t!==i&&i.dispose(),aa(p,i.shape,"bool")})).apply(this,arguments)}const _ce=function yce(n,t){return GE.apply(this,arguments)},HE=ue({conv2DBackpropFilter_:function vce(n,t,e,r,i,o="NHWC",s){let a=n;3===n.rank&&(a=be(n,[1,n.shape[0],n.shape[1],n.shape[2]]));let c=t;3===c.rank&&(c=be(t,[1,t.shape[0],t.shape[1],t.shape[2]])),Z(4===a.rank,()=>`Error in conv2dDerFilter: input must be rank 4, but got shape ${a.shape}.`),Z(4===c.rank,()=>`Error in conv2dDerFilter: dy must be rank 4, but got shape ${c.shape}.`),Z(4===e.length,()=>`Error in conv2dDerFilter: filterShape must be length 4, but got ${e}.`);const u="NHWC"===o?a.shape[3]:a.shape[1],p="NHWC"===o?c.shape[3]:c.shape[1];return Z(u===e[2],()=>`Error in conv2dDerFilter: depth of input ${u}) must match input depth in filter (${e[2]}.`),Z(p===e[3],()=>`Error in conv2dDerFilter: depth of dy (${p}) must match output depth for filter (${e[3]}).`),oo("conv2dDerFilter",i,s),pe.runKernel(SC,{x:a,dy:c},{strides:r,pad:i,dataFormat:o,dimRoundingMode:s,filterShape:e})}});function gv(n,t,e){if(null==e||"linear"===e)return n;if("relu"===e)return fe(n,Bh(t));throw new Error(`Cannot compute gradient for fused activation ${e}.`)}function bv(n,t){let e=t;const r=ti(n.shape,t.shape);return r.length>0&&(e=St(e,r)),be(e,n.shape)}function yv(n,t,e,r){if("linear"===t)return n;if("relu"===t)return La(n);if("elu"===t)return dg(n);if("relu6"===t)return IE(n);if("prelu"===t)return cv(n,e);if("leakyrelu"===t)return nv(n,r);if("sigmoid"===t)return Pa(n);throw new Error(`Unknown fused activation ${t}.`)}const _v=(n,t)=>!(n>0)||"linear"===t,sV=ue({fusedConv2d_:function xce({x:n,filter:t,strides:e,pad:r,dataFormat:i="NHWC",dilations:o=[1,1],dimRoundingMode:s,bias:a,activation:c="linear",preluActivationWeights:u,leakyreluAlpha:p}){if(!1===_v(pe.state.gradientDepth,c=c||"linear")){Z("NHWC"===i,()=>`Error in fused conv2d: got dataFormat of ${i} but only NHWC is currently supported for the case of gradient depth is 0 and the activation is not linear.`);let Y=Tc(n,t,e,r,i,o,s);return null!=a&&(Y=Xe(Y,a)),yv(Y,c,u,p)}const m=Q(n,"x","conv2d","float32"),g=Q(t,"filter","conv2d","float32");let _=m,x=!1;3===m.rank&&(x=!0,_=be(m,[1,m.shape[0],m.shape[1],m.shape[2]])),Z(4===_.rank,()=>`Error in fused conv2d: input must be rank 4, but got rank ${_.rank}.`),Z(4===g.rank,()=>`Error in fused conv2d: filter must be rank 4, but got rank ${g.rank}.`),oo("fused conv2d",r,s);const T="NHWC"===i?_.shape[3]:_.shape[1];Z(g.shape[2]===T,()=>`Error in conv2d: depth of input (${T}) must match input depth for filter ${g.shape[2]}.`),Z(Di(e,o),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${e} and dilations '${o}'`);const I=mi(_.shape,g.shape,e,o,r,s);let N,R;if(null!=a&&(N=Q(a,"bias","fused conv2d"),[N]=Tr(N,m),"NHWC"===i?Yt(I.outShape,N.shape):(Z(N.shape.length<=1,()=>`Error in fused conv2d: only supports scalar or 1-D Tensor bias for NCHW format but got the bias of rank-${N.shape.length}.`),Z(0===N.shape.length||N.shape[0]===I.outChannels||1===N.shape[0],()=>`Error in fused conv2d: bias shape (${N.shape}) is not compatible with the number of output channels (${I.outChannels})`))),null!=u){const Y=u.shape;if(Z(Y.length<=1||3===Y.length,()=>`Error in fused conv2d: only supports scalar, 1-D Tensor or 3-D Tensor PReLU activation weights but got a tensor of rank-${Y.length}.`),1===Y.length)Z(1===Y[0]||Y[0]===I.outChannels,()=>`Error in fused conv2d: PReLU activation weights (${Y}) is not compatible with the number of output channels (${I.outChannels}).`);else if(3===Y.length)try{Yt(Y,I.outShape)}catch{throw Error(`Error in fused conv2d: PReLU activation weights (${Y}) is not compatible with the output shape of the conv2d (${I.outShape}).`)}R=Q(u,"prelu weights","fused conv2d")}const L=(Y,ee)=>{Z("NHWC"===i,()=>`Error in gradient of fused conv2D: got dataFormat of ${i} but only NHWC is currently supported.`);const[ie,ce,he,we]=ee,Ee=gv(Y,he,c);Z(wc(o),()=>`Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${o}'`);const Re=[dE(ce.shape,Ee,ie,e,r),HE(ce,Ee,ie.shape,e,r)];if(null!=we){const _e=bv(we,Ee);Re.push(_e)}return Re},V={x:_,filter:g,bias:N,preluActivationWeights:R},j={strides:e,pad:r,dataFormat:i,dilations:o,dimRoundingMode:s,activation:c,leakyreluAlpha:p};return null==a?vl((ee,ie,ce)=>{let he=pe.runKernel($0,V,j);return ce([ie,ee,he]),x&&(he=be(he,[he.shape[1],he.shape[2],he.shape[3]])),{value:he,gradFunc:L}})(_,g):vl((ee,ie,ce,he)=>{let we=pe.runKernel($0,V,j);return he([ie,ee,we,ce]),x&&(we=be(we,[we.shape[1],we.shape[2],we.shape[3]])),{value:we,gradFunc:L}})(_,g,N)}}),aV=ue({depthwiseConv2dNativeBackpropFilter_:function wce(n,t,e,r,i,o=[1,1],s){let a=n;3===n.rank&&(a=be(n,[1,n.shape[0],n.shape[1],n.shape[2]]));let c=t;return 3===c.rank&&(c=be(t,[1,t.shape[0],t.shape[1],t.shape[2]])),pe.runKernel(NC,{x:a,dy:c},{strides:r,pad:i,dimRoundingMode:s,dilations:o,filterShape:e})}}),lV=ue({depthwiseConv2dNativeBackpropInput_:function Tce(n,t,e,r,i,o=[1,1],s){let a=t,c=!1;3===t.rank&&(c=!0,a=be(t,[1,t.shape[0],t.shape[1],t.shape[2]]));const m=pe.runKernel(OC,{dy:a,filter:e},{strides:r,pad:i,dimRoundingMode:s,dilations:o,inputShape:n});return c?be(m,[m.shape[1],m.shape[2],m.shape[3]]):m}}),Cce=ue({fusedDepthwiseConv2d_:function Sce({x:n,filter:t,strides:e,pad:r,dataFormat:i="NHWC",dilations:o=[1,1],dimRoundingMode:s,bias:a,activation:c="linear",preluActivationWeights:u,leakyreluAlpha:p}){if(!1===_v(pe.state.gradientDepth,c)){let j=ug(n,t,e,r,i,o,s);return null!=a&&(j=Xe(j,a)),yv(j,c,u,p)}const m=Q(n,"x","depthwiseConv2d","float32"),g=Q(t,"filter","depthwiseConv2d","float32");let _=m,x=!1;3===m.rank&&(x=!0,_=be(m,[1,m.shape[0],m.shape[1],m.shape[2]])),Z(4===_.rank,()=>`Error in fused depthwiseConv2d: input must be rank 4, but got rank ${_.rank}.`),Z(4===g.rank,()=>`Error in fused depthwiseConv2d: filter must be rank 4, but got rank ${g.rank}.`),Z(_.shape[3]===g.shape[2],()=>`Error in fused depthwiseConv2d: number of input channels (${_.shape[3]}) must match the inChannels dimension in filter ${g.shape[2]}.`),null==o&&(o=[1,1]),Z(Di(e,o),()=>`Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides ${e} and dilations '${o}'`),oo("fused depthwiseConv2d",r,s);const T=mi(_.shape,g.shape,e,o,r,s,!0);let I,N;null!=a&&(I=Q(a,"bias","fused conv2d"),[I]=Tr(I,m),Yt(T.outShape,I.shape)),null!=u&&(N=Q(u,"prelu weights","fused depthwiseConv2d"));const R=(j,Y)=>{Z(wc(o),()=>`Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '${o}'`);const[ee,ie,ce,he]=Y,we=gv(j,ce,c),Ee=lV(ie.shape,we,ee,e,r,o,s),Ae=aV(ie,we,ee.shape,e,r,o,s);return null!=he?[Ee,Ae,bv(I,we)]:[Ee,Ae]},L={x:_,filter:g,bias:I,preluActivationWeights:N},V={strides:e,pad:r,dataFormat:i,dilations:o,dimRoundingMode:s,activation:c,leakyreluAlpha:p};return null==a?vl((Y,ee,ie)=>{let ce=pe.runKernel(L0,L,V);return ie([ee,Y,ce]),x&&(ce=be(ce,[ce.shape[1],ce.shape[2],ce.shape[3]])),{value:ce,gradFunc:R}})(_,g):vl((Y,ee,ie,ce)=>{let he=pe.runKernel(L0,L,V);return ce([ee,Y,he,ie]),x&&(he=be(he,[he.shape[1],he.shape[2],he.shape[3]])),{value:he,gradFunc:R}})(_,g,I)}}),WE=ue({fusedMatMul_:function Ice({a:n,b:t,transposeA:e=!1,transposeB:r=!1,bias:i,activation:o="linear",preluActivationWeights:s,leakyreluAlpha:a=.2}){if(!1===_v(pe.state.gradientDepth,o)){let we=hn(n,t,e,r);return null!=i&&(we=Xe(we,i)),yv(we,o,s,a)}let c=Q(n,"a","fused matMul"),u=Q(t,"b","fused matMul");[c,u]=Tr(c,u);const p=e?c.shape[c.rank-2]:c.shape[c.rank-1],m=r?u.shape[u.rank-1]:u.shape[u.rank-2],g=e?c.shape[c.rank-1]:c.shape[c.rank-2],_=r?u.shape[u.rank-2]:u.shape[u.rank-1],x=c.shape.slice(0,-2),T=u.shape.slice(0,-2),I=Me(x),N=Me(T);Z(p===m,()=>`Error in fused matMul: inner shapes (${p}) and (${m}) of Tensors with shapes ${c.shape} and ${u.shape} and transposeA=${e} and transposeB=${r} must match.`);const L=Yt(c.shape.slice(0,-2),u.shape.slice(0,-2)).concat([g,_]),V=be(c,e?[I,p,g]:[I,g,p]),j=be(u,r?[N,_,m]:[N,m,_]);let Y,ee;null!=i&&(Y=Q(i,"bias","fused matMul"),[Y]=Tr(Y,c),Yt(L,Y.shape)),null!=s&&(ee=Q(s,"prelu weights","fused matMul"));const ie=(we,Ee)=>{const[Ae,Oe,Re,_e]=Ee,Te=gv(be(we,Re.shape),Re,o);let xe,De;return e||r?!e&&r?(xe=hn(Te,Oe,!1,!1),De=hn(Te,Ae,!0,!1)):e&&!r?(xe=hn(Oe,Te,!1,!0),De=hn(Ae,Te,!1,!1)):(xe=hn(Oe,Te,!0,!0),De=hn(Te,Ae,!0,!0)):(xe=hn(Te,Oe,!1,!0),De=hn(Ae,Te,!0,!1)),null!=i?[xe,De,bv(_e,Te)]:[xe,De]},ce={a:V,b:j,bias:Y,preluActivationWeights:ee},he={transposeA:e,transposeB:r,activation:o,leakyreluAlpha:a};return null==i?vl((Ee,Ae,Oe)=>{const Re=pe.runKernel(P0,ce,he);return Oe([Ee,Ae,Re]),{value:be(Re,L),gradFunc:ie}})(V,j):vl((Ee,Ae,Oe,Re)=>{const _e=pe.runKernel(P0,ce,he);return Re([Ee,Ae,_e,Oe]),{value:be(_e,L),gradFunc:ie}})(V,j,Y)}}),Dce=ue({hammingWindow_:function Ece(n){return jE(n,.54,.46)}}),cV=ue({hannWindow_:function kce(n){return jE(n,.5,.5)}}),uV=ue({frame_:function Ace(n,t,e,r=!1,i=0){let o=0;const s=[];for(;o+t<=n.size;)s.push(xn(n,o,t)),o+=e;if(r)for(;o<n.size;){const a=o+t-n.size,c=Ur([xn(n,o,t-a),Ah([a],i)]);s.push(c),o+=e}return 0===s.length?Vh([],[0,t]):be(Ur(s),[s.length,t])}}),Oce=ue({stft_:function Nce(n,t,e,r,i=cV){null==r&&(r=oV(t));const o=uV(n,t,e),s=fe(o,i(t));return mv(s,r)}}),Mce=ue({cropAndResize_:function Rce(n,t,e,r,i="bilinear",o=0){const s=Q(n,"image","cropAndResize"),a=Q(t,"boxes","cropAndResize","float32"),c=Q(e,"boxInd","cropAndResize","int32"),u=a.shape[0];return Z(4===s.rank,()=>`Error in cropAndResize: image must be rank 4,but got rank ${s.rank}.`),Z(2===a.rank&&4===a.shape[1],()=>`Error in cropAndResize: boxes must be have size [${u},4] but had shape ${a.shape}.`),Z(1===c.rank&&c.shape[0]===u,()=>`Error in cropAndResize: boxInd must be have size [${u}] but had shape ${a.shape}.`),Z(2===r.length,()=>`Error in cropAndResize: cropSize must be of length 2, but got length ${r.length}.`),Z(r[0]>=1&&r[1]>=1,()=>`cropSize must be atleast [1,1], but was ${r}`),Z("bilinear"===i||"nearest"===i,()=>`method must be bilinear or nearest, but was ${i}`),pe.runKernel(DC,{image:s,boxes:a,boxInd:c},{method:i,extrapolationValue:o,cropSize:r})}}),Pce=ue({flipLeftRight_:function Fce(n){const t=Q(n,"image","flipLeftRight","float32");return Z(4===t.rank,()=>`Error in flipLeftRight: image must be rank 4,but got rank ${t.rank}.`),pe.runKernel(VC,{image:t},{})}}),Lce=ue({grayscaleToRGB_:function $ce(n){const t=Q(n,"image","grayscaleToRGB"),e=t.rank-1,r=t.shape[e];Z(t.rank>=2,()=>`Error in grayscaleToRGB: images must be at least rank 2, but got rank ${t.rank}.`),Z(1===r,()=>`Error in grayscaleToRGB: last dimension of a grayscale image should be size 1, but got size ${r}.`);const i=new Array(t.rank);return i.fill(1,0,e),i[e]=3,Fs(t,i)}}),Vce=ue({rotateWithOffset_:function Bce(n,t,e=0,r=.5){const i=Q(n,"image","rotateWithOffset","float32");return Z(4===i.rank,()=>`Error in rotateWithOffset: image must be rank 4,but got rank ${i.rank}.`),pe.runKernel(wI,{image:i},{radians:t,fillValue:e,center:r})}});function zh(n,t,e,r,i,o){null==r&&(r=.5),null==i&&(i=Number.NEGATIVE_INFINITY),null==o&&(o=0);const s=n.shape[0];return e=Math.min(e,s),Z(0<=r&&r<=1,()=>`iouThreshold must be in [0, 1], but was '${r}'`),Z(2===n.rank,()=>`boxes must be a 2D tensor, but was of rank '${n.rank}'`),Z(4===n.shape[1],()=>`boxes must have 4 columns, but 2nd dimension was ${n.shape[1]}`),Z(1===t.rank,()=>"scores must be a 1D tensor"),Z(t.shape[0]===s,()=>`scores has incompatible shape with boxes. Expected ${s}, but was ${t.shape[0]}`),Z(0<=o&&o<=1,()=>`softNmsSigma must be in [0, 1], but was '${o}'`),{maxOutputSize:e,iouThreshold:r,scoreThreshold:i,softNmsSigma:o}}const Uce=ue({nonMaxSuppression_:function zce(n,t,e,r=.5,i=Number.NEGATIVE_INFINITY){const o=Q(n,"boxes","nonMaxSuppression","float32"),s=Q(t,"scores","nonMaxSuppression","float32"),a=zh(o,s,e,r,i);return pe.runKernel(YC,{boxes:o,scores:s},{maxOutputSize:e=a.maxOutputSize,iouThreshold:r=a.iouThreshold,scoreThreshold:i=a.scoreThreshold})}});function jce(n,t,e){const r=function Gce(n,t,e){return function Wce(n,t,e){let r=0,i=n.length,o=0,s=!1;for(;r<i;){o=r+(i-r>>>1);const a=e(t,n[o]);a>0?r=o+1:(i=o,s=!a)}return s?r:-r-1}(n,t,e||Hce)}(n,t,e);n.splice(r<0?-(r+1):r,0,t)}function Hce(n,t){return n>t?1:n<t?-1:0}function qE(n,t,e,r,i){return YE(n,t,e,r,i,0)}function KE(n,t,e,r,i,o){return YE(n,t,e,r,i,0,!1,o,!0)}function XE(n,t,e,r,i,o){return YE(n,t,e,r,i,o,!0)}function YE(n,t,e,r,i,o,s=!1,a=!1,c=!1){const u=[];for(let I=0;I<t.length;I++)t[I]>i&&u.push({score:t[I],boxIndex:I,suppressBeginIndex:0});u.sort(dV);const p=o>0?-.5/o:0,m=[],g=[];for(;m.length<e&&u.length>0;){const I=u.pop(),{score:N,boxIndex:R,suppressBeginIndex:L}=I;if(N<i)break;let V=!1;for(let j=m.length-1;j>=L;--j){const Y=qce(n,R,m[j]);if(Y>=r){V=!0;break}if(I.score=I.score*Kce(r,p,Y),I.score<=i)break}I.suppressBeginIndex=m.length,V||(I.score===N?(m.push(R),g.push(I.score)):I.score>i&&jce(u,I,dV))}const _=m.length,x=e-_;a&&x>0&&(m.push(...new Array(x).fill(0)),g.push(...new Array(x).fill(0)));const T={selectedIndices:m};return s&&(T.selectedScores=g),c&&(T.validOutputs=_),T}function qce(n,t,e){const r=n.subarray(4*t,4*t+4),i=n.subarray(4*e,4*e+4),o=Math.min(r[0],r[2]),s=Math.min(r[1],r[3]),a=Math.max(r[0],r[2]),c=Math.max(r[1],r[3]),u=Math.min(i[0],i[2]),p=Math.min(i[1],i[3]),m=Math.max(i[0],i[2]),g=Math.max(i[1],i[3]),_=(a-o)*(c-s),x=(m-u)*(g-p);if(_<=0||x<=0)return 0;const T=Math.max(o,u),I=Math.max(s,p),N=Math.min(a,m),R=Math.min(c,g),L=Math.max(N-T,0)*Math.max(R-I,0);return L/(_+x-L)}function Kce(n,t,e){const r=Math.exp(t*e*e);return e<=n?r:0}function dV(n,t){return n.score-t.score||n.score===t.score&&t.boxIndex-n.boxIndex}function ZE(){return(ZE=$e(function*(n,t,e,r=.5,i=Number.NEGATIVE_INFINITY){const o=Q(n,"boxes","nonMaxSuppressionAsync"),s=Q(t,"scores","nonMaxSuppressionAsync"),a=zh(o,s,e,r,i);e=a.maxOutputSize,r=a.iouThreshold,i=a.scoreThreshold;const c=yield Promise.all([o.data(),s.data()]),u=c[0],p=c[1],{selectedIndices:m}=qE(u,p,e,r,i);return o!==n&&o.dispose(),s!==t&&s.dispose(),So(m,"int32")})).apply(this,arguments)}const Qce=ue({nonMaxSuppressionWithScore_:function Zce(n,t,e,r=.5,i=Number.NEGATIVE_INFINITY,o=0){const s=Q(n,"boxes","nonMaxSuppression"),a=Q(t,"scores","nonMaxSuppression"),c=zh(s,a,e,r,i,o),m=pe.runKernel(QC,{boxes:s,scores:a},{maxOutputSize:e=c.maxOutputSize,iouThreshold:r=c.iouThreshold,scoreThreshold:i=c.scoreThreshold,softNmsSigma:o=c.softNmsSigma});return{selectedIndices:m[0],selectedScores:m[1]}}});function QE(){return(QE=$e(function*(n,t,e,r=.5,i=Number.NEGATIVE_INFINITY,o=0){const s=Q(n,"boxes","nonMaxSuppressionAsync"),a=Q(t,"scores","nonMaxSuppressionAsync"),c=zh(s,a,e,r,i,o);e=c.maxOutputSize,r=c.iouThreshold,i=c.scoreThreshold,o=c.softNmsSigma;const u=yield Promise.all([s.data(),a.data()]),p=u[0],m=u[1],{selectedIndices:g,selectedScores:_}=XE(p,m,e,r,i,o);return s!==n&&s.dispose(),a!==t&&a.dispose(),{selectedIndices:So(g,"int32"),selectedScores:So(_)}})).apply(this,arguments)}const nue=ue({nonMaxSuppressionPadded_:function tue(n,t,e,r=.5,i=Number.NEGATIVE_INFINITY,o=!1){const s=Q(n,"boxes","nonMaxSuppression"),a=Q(t,"scores","nonMaxSuppression"),c=zh(s,a,e,r,i,null),x=pe.runKernel(ZC,{boxes:s,scores:a},{maxOutputSize:c.maxOutputSize,iouThreshold:c.iouThreshold,scoreThreshold:c.scoreThreshold,padToMaxOutputSize:o});return{selectedIndices:x[0],validOutputs:x[1]}}});function JE(){return(JE=$e(function*(n,t,e,r=.5,i=Number.NEGATIVE_INFINITY,o=!1){const s=Q(n,"boxes","nonMaxSuppressionAsync"),a=Q(t,"scores","nonMaxSuppressionAsync"),c=zh(s,a,e,r,i,null),u=c.maxOutputSize,p=c.iouThreshold,m=c.scoreThreshold,[g,_]=yield Promise.all([s.data(),a.data()]),{selectedIndices:x,validOutputs:T}=KE(g,_,u,p,m,o);return s!==n&&s.dispose(),a!==t&&a.dispose(),{selectedIndices:So(x,"int32"),validOutputs:Ft(T,"int32")}})).apply(this,arguments)}const hV=ue({resizeBilinear_:function oue(n,t,e=!1,r=!1){const i=Q(n,"images","resizeBilinear");Z(3===i.rank||4===i.rank,()=>`Error in resizeBilinear: x must be rank 3 or 4, but got rank ${i.rank}.`),Z(2===t.length,()=>`Error in resizeBilinear: new shape must 2D, but got shape ${t}.`),Z(!1===r||!1===e,()=>"Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false.");let o=i,s=!1;3===i.rank&&(s=!0,o=be(i,[1,i.shape[0],i.shape[1],i.shape[2]]));const[]=t,u=pe.runKernel(S0,{images:o},{alignCorners:e,halfPixelCenters:r,size:t});return s?be(u,[u.shape[1],u.shape[2],u.shape[3]]):u}}),pV=ue({resizeNearestNeighbor_:function sue(n,t,e=!1,r=!1){const i=Q(n,"images","resizeNearestNeighbor");Z(3===i.rank||4===i.rank,()=>`Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ${i.rank}.`),Z(2===t.length,()=>`Error in resizeNearestNeighbor: new shape must 2D, but got shape ${t}.`),Z("float32"===i.dtype||"int32"===i.dtype,()=>"`images` must have `int32` or `float32` as dtype"),Z(!1===r||!1===e,()=>"Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false.");let o=i,s=!1;3===i.rank&&(s=!0,o=be(i,[1,i.shape[0],i.shape[1],i.shape[2]]));const[]=t,u=pe.runKernel(T0,{images:o},{alignCorners:e,halfPixelCenters:r,size:t});return s?be(u,[u.shape[1],u.shape[2],u.shape[3]]):u}}),cue=ue({threshold_:function aue(n,t="binary",e=!1,r=.5){const i=Q(n,"image","threshold"),c=i.shape[0]*i.shape[1];let p,m,g,_,u=fe(So([r]),255);if(Z(3===i.rank,()=>`Error in threshold: image must be rank 3,but got rank ${i.rank}.`),Z(3===i.shape[2]||1===i.shape[2],()=>`Error in threshold: image color channel must be equal to 3 or 1but got ${i.shape[2]}.`),Z("int32"===i.dtype||"float32"===i.dtype,()=>`Error in dtype: image dtype must be int32 or float32,but got dtype ${i.dtype}.`),Z("otsu"===t||"binary"===t,()=>`Method must be binary or otsu, but was ${t}`),3===i.shape[2]){[p,m,g]=Go(i,[1,1,1],-1);const I=fe(p,.2989),N=fe(m,.587),R=fe(g,.114);_=Xe(Xe(I,N),R)}else _=n;"otsu"===t&&(u=function lue(n,t){let o,s,a,c,u,p,e=So([-1]),r=So([0]),i=So([0]);for(let m=0;m<n.size-1;m++){o=xn(n,0,m+1),s=xn(n,m+1),u=Nt(St(o),t),p=Nt(St(s),t);const g=St(fe(o,Lh(0,o.size)));a=Nt(g,St(o));const _=Ah(s.shape,o.size),x=Xe(Lh(0,s.size),_),T=fe(s,x);c=Nt(St(T),St(s));const I=xt(a,c),N=xt(a,c),R=fe(u,p);i=fe(fe(R,I),N);const L=jo(i,r);r=Gi(L,i,r),e=Gi(L,So([m]),e)}return e}(vB(ht(EE(_),"int32"),aa([]),256),c));const x=e?Mu(_,u):jo(_,u);return ht(fe(x,255),"int32")}}),due=ue({transform_:function uue(n,t,e="nearest",r="constant",i=0,o){const s=Q(n,"image","transform","float32"),a=Q(t,"transforms","transform","float32");return Z(4===s.rank,()=>`Error in transform: image must be rank 4,but got rank ${s.rank}.`),Z(2===a.rank&&(a.shape[0]===s.shape[0]||1===a.shape[0])&&8===a.shape[1],()=>"Error in transform: Input transform should be batch x 8 or 1 x 8"),Z(null==o||2===o.length,()=>`Error in transform: outputShape must be [height, width] or null, but got ${o}.`),pe.runKernel(vI,{image:s,transforms:a},{interpolation:e,fillMode:r,fillValue:i,outputShape:o})}}),pue=ue({bandPart_:function hue(n,t,e){const r=Q(n,"a","bandPart");Z(r.rank>=2,()=>`bandPart(): Rank must be at least 2, got ${r.rank}.`);const i=r.shape,[o,s]=r.shape.slice(-2);let a,c;"number"==typeof t?(Z(t%1==0,()=>`bandPart(): numLower must be an integer, got ${t}.`),Z(t<=o,()=>`bandPart(): numLower (${t}) must not be greater than the number of rows (${o}).`),a=Q(t<0?o:t,"numLower","bandPart")):(Z("int32"===t.dtype,()=>"bandPart(): numLower's dtype must be an int32."),a=Gi(gg(t,0),o,Fu(t,o))),"number"==typeof e?(Z(e%1==0,()=>`bandPart(): numUpper must be an integer, got ${e}.`),Z(e<=s,()=>`bandPart(): numUpper (${e}) must not be greater than the number of columns (${s}).`),c=Q(e<0?s:e,"numUpper","bandPart")):(Z("int32"===e.dtype,()=>"bandPart(): numUpper's dtype must be an int32."),c=Gi(gg(e,0),s,Fu(e,s)));const u=be(Lh(0,o,1,"int32"),[-1,1]),p=Lh(0,s,1,"int32"),m=xt(u,p),g=$a(Mu(m,a),Cc(m,tr(c))),_=ni([o,s],r.dtype);return be(hs($s(be(r,[-1,o,s])).map(x=>Gi(g,x,_))),i)}}),mue=ue({gramSchmidt_:function fue(n){let t;if(Array.isArray(n)){t=!1,Z(null!=n&&n.length>0,()=>"Gram-Schmidt process: input must not be null, undefined, or empty");const i=n[0].shape[0];for(let o=1;o<n.length;++o)Z(n[o].shape[0]===i,()=>`Gram-Schmidt: Non-unique lengths found in the input vectors: (${n[o].shape[0]} vs. ${i})`)}else t=!0,n=Go(n,n.shape[0],0).map(i=>$u(i,[0]));Z(n.length<=n[0].shape[0],()=>`Gram-Schmidt: Number of vectors (${n.length}) exceeds number of dimensions (${n[0].shape[0]}).`);const e=[],r=n;for(let i=0;i<n.length;++i)e.push(pe.tidy(()=>{let o=r[i];if(i>0)for(let s=0;s<i;++s){const a=fe(St(fe(e[s],o)),e[s]);o=xt(o,a)}return Nt(o,pg(o,"euclidean"))}));return t?hs(e,0):e}});function fV(n,t=!1){return pe.tidy(()=>{Z(2===n.shape.length,()=>`qr2d() requires a 2D Tensor, but got a ${n.shape.length}D Tensor.`);const e=n.shape[0],r=n.shape[1];let i=bE(e),o=_l(n);const s=Vh([[1]],[1,1]);let a=_l(s);const c=e>=r?r:e;for(let u=0;u<c;++u){const p=o,m=a,g=i;[a,o,i]=pe.tidy(()=>{const _=xn(o,[u,u],[e-u,1]),x=pg(_),T=xn(o,[u,u],[1,1]),I=Gi(jo(T,0),Vh([[-1]]),Vh([[1]])),N=xt(T,fe(I,x)),R=Nt(_,N);a=1===R.shape[0]?_l(s):Ur([s,xn(R,[1,0],[R.shape[0]-1,R.shape[1]])],0);const L=tr(Nt(hn(I,N),x)),V=xn(o,[u,0],[e-u,r]),j=fe(L,a),Y=wn(a);if(0===u)o=xt(V,hn(j,hn(Y,V)));else{const ce=xt(V,hn(j,hn(Y,V)));o=Ur([xn(o,[0,0],[u,r]),ce],0)}const ee=wn(j),ie=xn(i,[0,u],[e,i.shape[1]-u]);if(0===u)i=xt(ie,hn(hn(ie,a),ee));else{const ce=xt(ie,hn(hn(ie,a),ee));i=Ur([xn(i,[0,0],[e,u]),ce],1)}return[a,o,i]}),un([p,m,g])}return!t&&e>r&&(i=xn(i,[0,0],[e,r]),o=xn(o,[0,0],[r,r])),[i,o]})}const bue=ue({qr_:function gue(n,t=!1){if(Z(n.rank>=2,()=>`qr() requires input tensor to have a rank >= 2, but got rank ${n.rank}`),2===n.rank)return fV(n,t);{const e=n.shape.slice(0,n.shape.length-2).reduce((c,u)=>c*u),r=$s(be(n,[e,n.shape[n.shape.length-2],n.shape[n.shape.length-1]]),0),i=[],o=[];return r.forEach(c=>{const[u,p]=fV(c,t);i.push(u),o.push(p)}),[be(hs(i,0),n.shape),be(hs(o,0),n.shape)]}}});var pr=(()=>((pr=pr||{})[pr.NONE=0]="NONE",pr[pr.MEAN=1]="MEAN",pr[pr.SUM=2]="SUM",pr[pr.SUM_BY_NONZERO_WEIGHTS=3]="SUM_BY_NONZERO_WEIGHTS",pr))();const Sl=ue({computeWeightedLoss_:function yue(n,t,e=pr.SUM_BY_NONZERO_WEIGHTS){const r=Q(n,"losses","computeWeightedLoss");let i=null;null!=t&&(i=Q(t,"weights","computeWeightedLoss"));const o=null==i?r:fe(r,i);if(e===pr.NONE)return o;if(e===pr.SUM)return St(o);if(e===pr.MEAN){if(null==i)return Sr(o);{const s=r.size/i.size,a=Nt(St(o),St(i));return s>1?Nt(a,Ft(s)):a}}if(e===pr.SUM_BY_NONZERO_WEIGHTS){if(null==i)return Nt(St(o),Ft(r.size));{const s=fe(i,us(r.shape)),a=ht(St($h(s,Ft(0))),"float32");return Nt(St(o),a)}}throw Error(`Unknown reduction: ${e}`)}}),vue=ue({absoluteDifference_:function _ue(n,t,e,r=pr.SUM_BY_NONZERO_WEIGHTS){const i=Q(n,"labels","absoluteDifference"),o=Q(t,"predictions","absoluteDifference");let s=null;null!=e&&(s=Q(e,"weights","absoluteDifference")),Vo(i.shape,o.shape,"Error in absoluteDifference: ");const a=ei(xt(i,o));return Sl(a,s,r)}}),wue=ue({cosineDistance_:function xue(n,t,e,r,i=pr.SUM_BY_NONZERO_WEIGHTS){const o=Q(n,"labels","cosineDistance"),s=Q(t,"predictions","cosineDistance");let a=null;null!=r&&(a=Q(r,"weights","cosineDistance")),Vo(o.shape,s.shape,"Error in cosineDistance: ");const c=Ft(1),u=xt(c,St(fe(o,s),e,!0));return Sl(u,a,i)}}),Sue=ue({hingeLoss_:function Tue(n,t,e,r=pr.SUM_BY_NONZERO_WEIGHTS){let i=Q(n,"labels","hingeLoss");const o=Q(t,"predictions","hingeLoss");let s=null;null!=e&&(s=Q(e,"weights","hingeLoss")),Vo(i.shape,o.shape,"Error in hingeLoss: ");const a=Ft(1);i=xt(fe(Ft(2),i),a);const c=La(xt(a,fe(i,o)));return Sl(c,s,r)}}),Iue=ue({huberLoss_:function Cue(n,t,e,r=1,i=pr.SUM_BY_NONZERO_WEIGHTS){const o=Q(n,"labels","huberLoss"),s=Q(t,"predictions","huberLoss");let a=null;null!=e&&(a=Q(e,"weights","huberLoss")),Vo(o.shape,s.shape,"Error in huberLoss: ");const c=Ft(r),u=ei(xt(s,o)),p=Fu(u,c),m=xt(u,p),g=Xe(fe(Ft(.5),Hn(p)),fe(c,m));return Sl(g,a,i)}}),Due=ue({logLoss_:function Eue(n,t,e,r=1e-7,i=pr.SUM_BY_NONZERO_WEIGHTS){const o=Q(n,"labels","logLoss"),s=Q(t,"predictions","logLoss");let a=null;null!=e&&(a=Q(e,"weights","logLoss")),Vo(o.shape,s.shape,"Error in logLoss: ");const c=Ft(1),u=Ft(r),p=tr(fe(o,cs(Xe(s,u)))),m=fe(xt(c,o),cs(Xe(xt(c,s),u))),g=xt(p,m);return Sl(g,a,i)}}),Aue=ue({meanSquaredError_:function kue(n,t,e,r=pr.SUM_BY_NONZERO_WEIGHTS){const i=Q(n,"labels","meanSquaredError"),o=Q(t,"predictions","meanSquaredError");let s=null;null!=e&&(s=Q(e,"weights","meanSquaredError")),Vo(i.shape,o.shape,"Error in meanSquaredError: ");const a=PE(i,o);return Sl(a,s,r)}}),Rue=ue({sigmoidCrossEntropy_:function Oue(n,t,e,r=0,i=pr.SUM_BY_NONZERO_WEIGHTS){let o=Q(n,"multiClassLabels","sigmoidCrossEntropy");const s=Q(t,"logits","sigmoidCrossEntropy");let a=null;if(null!=e&&(a=Q(e,"weights","sigmoidCrossEntropy")),Vo(o.shape,s.shape,"Error in sigmoidCrossEntropy: "),r>0){const u=Ft(r),p=Ft(1),m=Ft(.5);o=Xe(fe(o,xt(p,u)),fe(m,u))}const c=function Nue(n,t){const e=Q(n,"labels","sigmoidCrossEntropyWithLogits"),r=Q(t,"logits","sigmoidCrossEntropyWithLogits");Vo(e.shape,r.shape,"Error in sigmoidCrossEntropyWithLogits: ");const i=La(r),o=fe(r,e),s=rv(ls(tr(ei(r))));return Xe(xt(i,o),s)}(o,s);return Sl(c,a,i)}}),Pue=ue({softmaxCrossEntropy_:function Fue(n,t,e,r=0,i=pr.SUM_BY_NONZERO_WEIGHTS){let o=Q(n,"onehotLabels","softmaxCrossEntropy");const s=Q(t,"logits","softmaxCrossEntropy");let a=null;if(null!=e&&(a=Q(e,"weights","softmaxCrossEntropy")),Vo(o.shape,s.shape,"Error in softmaxCrossEntropy: "),r>0){const u=Ft(r),p=Ft(1),m=Ft(o.shape[1]);o=Xe(fe(o,xt(p,u)),Nt(u,m))}const c=function Mue(n,t,e=-1){if(-1===e&&(e=t.rank-1),e!==t.rank-1)throw Error(`Softmax cross entropy along a non-last dimension is not yet supported. Labels / logits was rank ${t.rank} and dim was ${e}`);return vl((i,o,s)=>{const c=_E(o,[e],!0),u=xt(ht(o,"float32"),c);s([i,u]);const p=tr(fe(u,i));return{value:St(p,[e]),gradFunc:(_,x)=>{const[T,I]=x,N=Rr(_.shape,[e]);return[fe(be(_,N),xt(ht(T,"float32"),ls(I))),fe(be(_,N),xt(ls(I),ht(T,"float32")))]}}})(n,t)}(o,s);return Sl(c,a,i)}}),Jue={fft:fv,ifft:_g,rfft:mv,irfft:FE},ede={hammingWindow:Dce,hannWindow:cV,frame:uV,stft:Oce},Ba={flipLeftRight:Pce,grayscaleToRGB:Lce,resizeNearestNeighbor:pV,resizeBilinear:hV,rotateWithOffset:Vce,cropAndResize:Mce,nonMaxSuppression:Uce,nonMaxSuppressionAsync:function Xce(n,t,e){return ZE.apply(this,arguments)},nonMaxSuppressionWithScore:Qce,nonMaxSuppressionWithScoreAsync:function Jce(n,t,e){return QE.apply(this,arguments)},nonMaxSuppressionPadded:nue,nonMaxSuppressionPaddedAsync:function rue(n,t,e){return JE.apply(this,arguments)},threshold:cue,transform:due},mV={bandPart:pue,gramSchmidt:mue,qr:bue},tde={absoluteDifference:vue,computeWeightedLoss:Sl,cosineDistance:wue,hingeLoss:Sue,huberLoss:Iue,logLoss:Due,meanSquaredError:Aue,sigmoidCrossEntropy:Rue,softmaxCrossEntropy:Pue},nde={sparseFillEmptyRows:ue({sparseFillEmptyRows_:function $ue(n,t,e,r){const i=Q(n,"indices","sparseFillEmptyRows","int32"),o=Q(t,"values","sparseFillEmptyRows"),s=Q(e,"denseShape","sparseFillEmptyRows","int32"),a=Q(r,"defaultValue","sparseFillEmptyRows",o.dtype);if(2!==i.rank)throw new Error(`Indices should be Tensor2D but received shape\n        ${i.shape}`);if(1!==o.rank)throw new Error(`Values should be Tensor1D but received shape ${o.shape}`);if(1!==s.rank)throw new Error(`Dense shape should be Tensor1D but received shape ${s.shape}`);if(0!==a.rank)throw new Error(`Default value should be a scalar but received shape ${a.shape}`);const u=pe.runKernel(cI,{indices:i,values:o,denseShape:s,defaultValue:a});return{outputIndices:u[0],outputValues:u[1],emptyRowIndicator:u[2],reverseIndexMap:u[3]}}}),sparseReshape:ue({sparseReshape_:function Bue(n,t,e){const r=Q(n,"inputIndices","sparseReshape","int32"),i=Q(t,"inputShape","sparseReshape","int32"),o=Q(e,"newShape","sparseReshape","int32");if(2!==r.rank)throw new Error(`Input indices should be Tensor2D but received shape\n        ${r.shape}`);if(1!==i.rank)throw new Error(`Input shape should be Tensor1D but received shape ${i.shape}`);if(1!==o.rank)throw new Error(`New shape should be Tensor1D but received shape ${o.shape}`);const a=pe.runKernel(uI,{inputIndices:r,inputShape:i,newShape:o});return{outputIndices:a[0],outputShape:a[1]}}}),sparseSegmentMean:ue({sparseSegmentMean_:function zue(n,t,e){const r=Q(n,"data","sparseSegmentMean"),i=Q(t,"indices","sparseSegmentMean","int32"),o=Q(e,"segmentIds","sparseSegmentMean","int32");if(r.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==i.rank)throw new Error(`Indices should be Tensor1D but received shape\n          ${i.shape}`);if(1!==o.rank)throw new Error(`Segment ids should be Tensor1D but received shape\n          ${o.shape}`);return pe.runKernel(dI,{data:r,indices:i,segmentIds:o})}}),sparseSegmentSum:ue({sparseSegmentSum_:function jue(n,t,e){const r=Q(n,"data","sparseSegmentSum"),i=Q(t,"indices","sparseSegmentSum","int32"),o=Q(e,"segmentIds","sparseSegmentSum","int32");if(r.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==i.rank)throw new Error(`Indices should be Tensor1D but received shape\n         ${i.shape}`);if(1!==o.rank)throw new Error(`Segment ids should be Tensor1D but received shape\n         ${o.shape}`);return pe.runKernel(hI,{data:r,indices:i,segmentIds:o})}})},rde={stringNGrams:ue({stringNGrams_:function Hue(n,t,e,r,i,o,s,a){const c=Q(n,"data","stringNGrams","string");if("string"!==c.dtype)throw new Error("Data must be of datatype string");if(1!==c.shape.length)throw new Error(`Data must be a vector, saw: ${c.shape}`);const u=Q(t,"dataSplits","stringNGrams");if("int32"!==u.dtype)throw new Error("Data splits must be of datatype int32");const g=pe.runKernel(gI,{data:c,dataSplits:u},{separator:e,nGramWidths:r,leftPad:i,rightPad:o,padWidth:s,preserveShortSequences:a});return{nGrams:g[0],nGramsSplits:g[1]}}}),stringSplit:ue({stringSplit_:function que(n,t,e=!0){const r=Q(n,"input","stringSplit","string"),i=Q(t,"delimiter","stringSplit","string");if(1!==r.rank)throw new Error(`Input should be Tensor1D but received shape ${r.shape}`);if(0!==i.rank)throw new Error(`Delimiter should be a scalar but received shape ${i.shape}`);const a=pe.runKernel(bI,{input:r,delimiter:i},{skipEmpty:e});return{indices:a[0],values:a[1],shape:a[2]}}}),stringToHashBucketFast:ue({stringToHashBucketFast_:function Xue(n,t){const e=Q(n,"input","stringToHashBucketFast","string"),r={numBuckets:t};if(t<=0)throw new Error("Number of buckets must be at least 1");return pe.runKernel(yI,{input:e},r)}}),staticRegexReplace:ue({staticRegexReplace_:function Zue(n,t,e,r=!0){const i=Q(n,"input","staticRegexReplace","string");return pe.runKernel(O0,{x:i},{pattern:t,rewrite:e,replaceGlobal:r})}})},Uh=class ide{static sgd(t){return new KI(t)}static momentum(t,e,r=!1){return new j3(t,e,r)}static rmsprop(t,e=.9,r=0,i=null,o=!1){return new G3(t,e,r,i,o)}static adam(t=.001,e=.9,r=.999,i=null){return new z3(t,e,r,i)}static adadelta(t=.001,e=.95,r=null){return new B3(t,e,r)}static adamax(t=.002,e=.9,r=.999,i=null,o=0){return new U3(t,e,r,i,o)}static adagrad(t,e=.1){return new V3(t,e)}},ode=typeof requestAnimationFrame<"u"?requestAnimationFrame:typeof setImmediate<"u"?setImmediate:n=>n();function gV(){return new Promise(n=>ode(()=>n()))}function eD(n,t){const e=n[0].length;n.forEach((i,o)=>{Z(i.length===e,()=>`Error in concat${e}D: rank of tensors[${o}] must be the same as the rank of the rest (${e})`)}),Z(t>=0&&t<e,()=>`Error in concat${e}D: axis must be between 0 and ${e-1}.`);const r=n[0];n.forEach((i,o)=>{for(let s=0;s<e;s++)Z(s===t||i[s]===r[s],()=>`Error in concat${e}D: Shape of tensors[${o}] (${i}) does not match the shape of the rest (${r}) along the non-concatenated axis ${o}.`)})}function Va(n,t){const e=n[0].slice();for(let r=1;r<n.length;r++)e[t]+=n[r][t];return e}var fr=(()=>((fr=fr||{})[fr.FIRST_DIM_SIZE=0]="FIRST_DIM_SIZE",fr[fr.VALUE_ROWIDS=1]="VALUE_ROWIDS",fr[fr.ROW_LENGTHS=2]="ROW_LENGTHS",fr[fr.ROW_SPLITS=3]="ROW_SPLITS",fr[fr.ROW_LIMITS=4]="ROW_LIMITS",fr[fr.ROW_STARTS=5]="ROW_STARTS",fr))();function bV(n,t,e){let r=new Array;if(null==e&&null==t)return r;if(null==t)for(;r.length<n+e.length;)r.push(-1);else r=t.slice();if(null==e)return r;if(n+e.length!==r.length)throw new Error(`rt input.shape and shape=${t} are incompatible: rt input.rank = ${n+e.length}, but shape.rank = ${r.length}`);for(let i=1;i<e.length;++i){const o=e[i],s=r[r.length-e.length+i],a=r[s];if(o>=0)if(a>=0){if(a!==o)throw new Error(`rt input.shape and shape=${t} are incompatible: rt input.shape[${i+n}] = ${o} but shape[${i+n}] = ${a}`)}else r[s]=o}return r}function yV(n){const t={FIRST_DIM_SIZE:fr.FIRST_DIM_SIZE,VALUE_ROWIDS:fr.VALUE_ROWIDS,ROW_LENGTHS:fr.ROW_LENGTHS,ROW_SPLITS:fr.ROW_SPLITS,ROW_LIMITS:fr.ROW_LIMITS,ROW_STARTS:fr.ROW_STARTS},e=[];for(const r of n){if(!(r in t))break;e.push(t[r])}return e}function _V(n){return 0===n.length?0:n[0]===fr.FIRST_DIM_SIZE?n.length-1:n.length}function vV(n,t){if(null==n||null==t)return;const e=n.length,r=t.length;if(e>=r)throw new Error(`defaultValue.shape=${n} and ragged tensor flatValues.shape=${t}, are incompatible: defaultValue.rank = ${e} must be less than ragged tensor input flatValues.rank = ${r})`);for(let i=0;i<Math.min(e,r-1);++i){const o=n[i],s=t[i+1];if(o>=0&&s>=0&&1!==o&&o!==s)throw new Error(`defaultValue.shape=${n}, and ragged tensor input flatValues.shape=${t} are incompatible: defaultValue.shape[${i-n.length}] = ${o} but ragged tensor input.flatValues.shape[${i-n.length}] = ${s}`)}}const tD=30;function vv(n){return n<=tD?n:hC(n,Math.floor(Math.sqrt(n)))}function nD(n,t,e){return[e*("number"==typeof n?n:n[0]),t*("number"==typeof n?n:n[1])]}function vg(n,t,e,r=!0){let i=[];if(r)i=i.concat(t.slice(0)),i.push(n[0]/e),i=i.concat(n.slice(1));else{i=i.concat(n[0]);const o=t.length;for(let s=0;s<o;++s)i=i.concat([n[s+1]/t[s],t[s]]);i=i.concat(n.slice(o+1))}return i}function xg(n,t,e=!0){const r=[];if(e){r.push(t);for(let i=t+1;i<n;++i)i<=2*t?(r.push(i),r.push(i-(t+1))):r.push(i)}else{const i=[],o=[];for(let s=1;s<n;++s)s>=2*t+1||s%2==1?o.push(s):i.push(s);r.push(...i),r.push(0),r.push(...o)}return r}function wg(n,t,e,r=!0){const i=[];i.push(r?n[0]/e:n[0]*e);for(let o=1;o<n.length;++o)i.push(o<=t.length?r?t[o-1]*n[o]:n[o]/t[o-1]:n[o]);return i}function rD(n,t){const e=[0];for(let r=0;r<t;++r)e.push(n[r][0]);return e}function iD(n,t,e){const r=n.slice(0,1);for(let i=0;i<e;++i)r.push(n[i+1]-t[i][0]-t[i][1]);return r}function oD(n,t){const e=n.shape.length,r=t.shape.length;if(e<1)throw new Error(`tf.gatherND() expects the input to be rank 1 or higher, but the rank was ${e}.`);if(r<1)throw new Error(`tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ${r}.`);if("int32"!==t.dtype)throw new Error(`tf.gatherND() expects the indices to be int32 type, but the dtype was ${t.dtype}.`);if(t.shape[r-1]>e)throw new Error(`index innermost dimension length must be <= tensor rank; saw: ${t.shape[r-1]} vs. ${e}`);if(0===Me(n.shape))throw new Error(`Requested more than 0 entries, but input is empty. Input shape: ${n.shape}.`);const i=t.shape,o=i[i.length-1];let s=1;for(let m=0;m<i.length-1;++m)s*=i[m];const a=n.shape,c=i.slice();c.pop();let u=1;for(let m=o;m<e;++m)u*=a[m],c.push(a[m]);const p=[...Rt(n.shape).map(m=>m/u),1].slice(0,o);return[c,s,u,p]}const xv=1.7580993408473768,wv=1.0507009873554805,sD=.3275911,aD=.254829592,lD=-.284496736,cD=1.421413741,uD=-1.453152027,dD=1.061405429;function Cl(n,t){if(n.length!==t.length)throw new Error(`Cannot merge real and imag arrays of different lengths. real:${n.length}, imag: ${t.length}.`);const e=new Float32Array(2*n.length);for(let r=0;r<e.length;r+=2)e[r]=n[r/2],e[r+1]=t[r/2];return e}function xV(n){const t=new Float32Array(n.length/2),e=new Float32Array(n.length/2);for(let r=0;r<n.length;r+=2)t[r/2]=n[r],e[r/2]=n[r+1];return{real:t,imag:e}}function wV(n){const t=Math.ceil(n.length/4),e=new Float32Array(t),r=new Float32Array(t);for(let i=0;i<n.length;i+=4)e[Math.floor(i/4)]=n[i],r[Math.floor(i/4)]=n[i+1];return{real:e,imag:r}}function TV(n){const t=Math.floor(n.length/4),e=new Float32Array(t),r=new Float32Array(t);for(let i=2;i<n.length;i+=4)e[Math.floor(i/4)]=n[i],r[Math.floor(i/4)]=n[i+1];return{real:e,imag:r}}function hD(n,t){return{real:n[2*t],imag:n[2*t+1]}}function SV(n,t,e,r){n[2*r]=t,n[2*r+1]=e}function CV(n,t){const e=new Float32Array(n/2),r=new Float32Array(n/2);for(let i=0;i<Math.ceil(n/2);i++){const o=(t?2:-2)*Math.PI*(i/n);e[i]=Math.cos(o),r[i]=Math.sin(o)}return{real:e,imag:r}}function IV(n,t,e){const r=(e?2:-2)*Math.PI*(n/t);return{real:Math.cos(r),imag:Math.sin(r)}}const pD="->",sde=/->/g,EV=",",DV="...";function fD(n,t){const e=((n=n.replace(/\s/g,"")).length-n.replace(sde,"").length)/pD.length;if(e<1)throw new Error("Equations without an arrow are not supported.");if(e>1)throw new Error(`Equation must contain exactly one arrow ("${pD}").`);const[r,i]=n.split(pD);Z(-1===r.indexOf(DV),()=>`The ellipsis notation ("${DV}") is not supported yet.`);const o=r.split(EV),s=o.length;if(t!==s)throw new Error(`Expected ${s} input tensors, received ${t}`);if(s>2)throw new Error("Support for more than 2 input tensors is not implemented yet.");const a=[];for(let g=0;g<i.length;++g){const _=i[g];if(!o.some(x=>-1!==x.indexOf(_)))throw new Error(`Output subscripts contain the label ${_} not present in the input subscripts.`);-1===a.indexOf(_)&&a.push(_)}for(let g=0;g<r.length;++g){const _=r[g];-1===a.indexOf(_)&&_!==EV&&a.push(_)}const c=new Array(o.length);for(let g=0;g<s;++g){if(new Set(o[g].split("")).size!==o[g].length)throw new Error(`Found duplicate axes in input component ${o[g]}. Support for duplicate axes in input is not implemented yet.`);c[g]=[];for(let _=0;_<o[g].length;++_)c[g].push(a.indexOf(o[g][_]))}const u=a.length,m=[];for(let g=i.length;g<u;++g)m.push(g);return{allDims:a,summedDims:m,idDims:c}}function mD(n,t){let e=new Array(n);e.fill(-1);for(let i=0;i<t.length;++i)e[t[i]]=i;const r=[];for(let i=0;i<n;++i)-1===e[i]&&r.push(i);return e=e.filter(i=>-1!==i),{permutationIndices:e,expandDims:r}}function gD(n,t,e){const r=new Array(n);for(let i=0;i<e.length;++i){const o=e[i].shape;for(let s=0;s<t[i].length;++s)void 0===r[t[i][s]]?r[t[i][s]]=o[s]:Z(r[t[i][s]]===o[s],()=>`Expected dimension ${r[t[i][s]]} at axis ${s} of input shaped ${JSON.stringify(o)}, but got dimension ${o[s]}`)}}function bD(n,t){const e=n,r=[];let i=0;0===n.length&&e.push(-1),i=n.length+1;for(let s=0;s<i;++s)r.push([]);const o=[];for(let s=0;s<e.length;++s){const c=ade(t,e[s]);for(const u of c)-1===o.indexOf(u)&&(r[s].push(u),o.push(u))}return{path:e,steps:r}}function yD(n){return n.every((t,e)=>t===e)}function ade(n,t){const e=[];for(let r=0;r<n.length;++r)(0===n[r].length||-1!==n[r].indexOf(t)||-1===t)&&e.push(r);return e}function _D(n,t,e=0){let r=[];if("number"==typeof t)Z(n.shape[e]%t==0,()=>"Number of splits must evenly divide the axis."),r=new Array(t).fill(n.shape[e]/t);else{Z(t.reduce((s,a)=>(-1===a&&(s+=1),s),0)<=1,()=>"There should be only one negative value in split array.");const o=t.indexOf(-1);if(-1!==o){const s=t.reduce((a,c)=>c>0?a+c:a);t[o]=n.shape[e]-s}Z(n.shape[e]===t.reduce((s,a)=>s+a),()=>"The sum of sizes must match the size of the axis dimension."),r=t}return r}function kV(n){return`Received SparseTensor with denseShape[0] = 0 but\n  indices.shape[0] = ${n}`}function AV(n,t){return`indices(${n}, 0) is invalid: ${t} < 0`}function NV(n,t,e){return`indices(${n}, 0) is invalid: ${t} >= ${e}`}function OV(n,t){return`only one output dimension may be -1, not both ${n} and ${t}`}function RV(n,t){return`size ${n} must be non-negative, not ${t}`}function MV(){return"reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero"}function FV(n,t){return`Input to reshape is a SparseTensor with ${Me(n)}\n  dense values, but the requested shape requires a multiple of ${Me(t)}. inputShape=${n} outputShape= ${t}`}function PV(n,t){return`Input to reshape is a tensor with ${Me(n)} dense values, but the requested shape has ${Me(t)}. inputShape=${n} outputShape=${t}`}function vD(){return"segment ids must be >= 0"}function $V(){return"segment ids are not increasing"}function LV(n,t){return`Segment id ${n} out of range [0, ${t}), possibly because segmentIds input is not sorted.`}function BV(n,t,e){return`Bad: indices[${n}] == ${t} out of range [0, ${e})`}function VV(n,t){let r,e=!1;for(n<=tD?(r=n,e=!0):r=hC(n,Math.floor(Math.sqrt(n)));!e;)r>t||r===n?e=!0:r=hC(n,r+1);return r}function zV(n,t,e){const r=[],i=n.length;for(let o=0;o<i;o++)r.push(o!==t?n[o]:e);return r}function xD(n,t,e,r){const i=t.shape.length,o=n.shape.length;if(0!==r&&(r<-i||r>i))throw new Error(`Expect batchDims in the range of [-${i}, ${i}], but got ${r}`);if(r<0&&(r+=i),r>o)throw new Error(`batchDims (${r}) must be less than rank(x) (\n    ${o}).`);if(e<r)throw new Error(`batchDims (${r}) must be less than or equal to axis (${e}).`);for(let m=0;m<r;++m)if(n.shape[m]!==t.shape[m])throw new Error(`x.shape[${m}]: ${n.shape[m]} should be equal to indices.shape[${m}]: ${t.shape[m]}.`);const s=n.shape[e],a=[];let c=1,u=1,p=1;for(let m=0;m<r;++m)a.push(n.shape[m]),c*=n.shape[m];for(let m=r;m<e;m++)a.push(n.shape[m]),u*=n.shape[m];for(let m=r;m<i;m++)a.push(t.shape[m]);for(let m=e+1;m<o;m++)a.push(n.shape[m]),p*=n.shape[m];return{batchSize:c,sliceSize:p,outerSize:u,dimSize:s,outputShape:a}}function Il(n){try{return n.map(t=>uc(t))}catch(t){throw new Error(`Failed to decode encoded string bytes into utf-8, error: ${t}`)}}function UV(n){return n.map(t=>cc(t))}!function Pie(){for(const n of Fie)Ye(n)}();const jV={kernelName:R_,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>fe(n,Bh(ht(e,"float32"),-1))}}},lde={kernelName:sm,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>{const r=Hn(ht(e,"float32")),i=ji(xt(Ft(1),r));return tr(Nt(n,i))}}}},cde={kernelName:am,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>{const r=ji(xt(Hn(ht(e,"float32")),1));return Nt(n,r)}}}},ude={kernelName:xh,inputsToSave:["a","b"],gradFunc:(n,t)=>{const[e,r]=t,i=Yt(e.shape,r.shape);return{a:()=>{let a=n;const c=ti(e.shape,i);return c.length>0&&(a=St(a,c)),be(a,e.shape)},b:()=>{let a=n;const c=ti(r.shape,i);return c.length>0&&(a=St(a,c)),be(a,r.shape)}}}},dde={kernelName:M_,saveAllInputs:!0,gradFunc:(n,t)=>{const e={};return t.forEach((r,i)=>{e[i]=()=>n.clone()}),e}},hde={kernelName:F_,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>vn(e)}}},pde={kernelName:P_,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>vn(e)}}},fde={kernelName:lm,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>Nt(n,ji(xt(Ft(1),Hn(ht(e,"float32")))))}}},mde={kernelName:cm,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>{const r=ji(Xe(Ft(1),Hn(ht(e,"float32"))));return Nt(n,r)}}}},gde={kernelName:hm,inputsToSave:["a","b"],gradFunc:(n,t)=>{const[e,r]=t,i=Yt(e.shape,r.shape);return{a:()=>{const a=Xe(Hn(e),Hn(r));let c=fe(n,Nt(r,a));const u=ti(e.shape,i);return u.length>0&&(c=St(c,u)),be(c,e.shape)},b:()=>{const a=Xe(Hn(e),Hn(r));let c=tr(fe(n,Nt(e,a)));const u=ti(r.shape,i);return u.length>0&&(c=St(c,u)),be(c,r.shape)}}}},bde={kernelName:um,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>Nt(n,Xe(Hn(ht(e,"float32")),1))}}},yde={kernelName:dm,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>Nt(n,xt(Ft(1),Hn(ht(e,"float32"))))}}},vde=ue({avgPool3dGrad_:function _de(n,t,e,r,i,o){const s=Q(n,"dy","avgPool3dGrad"),a=Q(t,"input","avgPool3dGrad");let c=s,u=a,p=!1;4===a.rank&&(p=!0,c=be(s,[1,s.shape[0],s.shape[1],s.shape[2],s.shape[3]]),u=be(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]])),Z(5===c.rank,()=>`Error in avgPool3dGrad: dy must be rank 5 but got rank ${c.rank}.`),Z(5===u.rank,()=>`Error in avgPool3dGrad: input must be rank 5 but got rank ${u.rank}.`),oo("avgPool3dGrad",i,o);const _=pe.runKernel(_C,{dy:c,input:u},{filterSize:e,strides:r,pad:i,dimRoundingMode:o});return p?be(_,[_.shape[1],_.shape[2],_.shape[3],_.shape[4]]):_}}),xde={kernelName:L_,inputsToSave:["x"],gradFunc:(n,t,e)=>{const[r]=t,{filterSize:i,strides:o,pad:s,dimRoundingMode:a}=e;return{x:()=>vde(n,r,i,o,s,a)}}},Tde=ue({avgPoolGrad_:function wde(n,t,e,r,i){const o=Q(n,"dy","avgPoolGrad"),s=Q(t,"input","avgPoolGrad");Z(s.rank===o.rank,()=>`Rank of input (${s.rank}) does not match rank of dy (${o.rank})`);let a=s,c=o,u=!1;3===s.rank&&(u=!0,a=be(s,[1,s.shape[0],s.shape[1],s.shape[2]]),c=be(o,[1,o.shape[0],o.shape[1],o.shape[2]])),Z(4===c.rank,()=>`Error in avgPoolGrad: dy must be rank 4 but got rank ${c.rank}.`),Z(4===a.rank,()=>`Error in avgPoolGrad: input must be rank 4 but got rank ${a.rank}.`);const g=pe.runKernel(yC,{dy:c,input:a},{filterSize:e,strides:r,pad:i});return u?be(g,[g.shape[1],g.shape[2],g.shape[3]]):g}}),Sde={kernelName:$_,inputsToSave:["x"],gradFunc:(n,t,e)=>{const[r]=t,{filterSize:i,strides:o,pad:s}=e;return{x:()=>Tde(n,r,i,o,s)}}},Cde={kernelName:B_,inputsToSave:["a","b"],gradFunc:(n,t,e)=>{const[r,i]=t,{transposeA:o,transposeB:s}=e;return o||s?!o&&s?{a:()=>hn(n,i,!1,!1),b:()=>hn(n,r,!0,!1)}:o&&!s?{a:()=>hn(i,n,!1,!0),b:()=>hn(r,n,!1,!1)}:{a:()=>hn(i,n,!0,!0),b:()=>hn(n,r,!0,!0)}:{a:()=>hn(n,i,!1,!0),b:()=>hn(r,n,!0,!1)}}},Ide={kernelName:V_,gradFunc:(n,t,e)=>{const{blockShape:r,crops:i}=e;return{x:()=>lv(n,r,i)}}},Ede={kernelName:"BroadcastTo",gradFunc:(n,t,e)=>{const i=e.inputShape,o=e.shape,s=Array.from(o);for(let c=i.length-1;c>=0;c--)if(i[c]===o[c])s[c]=1;else if(1!==i[c])throw new Error(`broadcastTo(): [${i}] cannot be broadcast to [${o}].`);const a=[];for(let c=0;c<s.length;c++)s[c]>1&&a.push(c);return{x:()=>St(n,a,!0)}}},Dde={kernelName:pm,gradFunc:n=>({x:()=>n.clone()})},kde={kernelName:fm,gradFunc:n=>({x:()=>vn(n)})},Ade={kernelName:mm,inputsToSave:["x"],gradFunc:(n,t,e)=>{const[r]=t,{clipValueMin:i,clipValueMax:o}=e;return{x:()=>Gi($a(Cc(r,i),Mu(r,o)),n,vn(n))}}},Nde={kernelName:z_,inputsToSave:["x"],gradFunc:jV.gradFunc},Ode={kernelName:U_,saveAllInputs:!0,gradFunc:(n,t,e)=>{const r=t.map(c=>c.shape),{axis:i}=e,o=cn(i,t[0].shape)[0],s=r.map(c=>c[o]);return Go(n,s,o).map(c=>()=>c)}},Rde={kernelName:j_,inputsToSave:["x","filter"],gradFunc:(n,t,e)=>{const[r,i]=t,{dilations:o,strides:s,pad:a,dataFormat:c}=e;return Z(wc(o),()=>`Error in gradient of conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${o}'`),{x:()=>dE(r.shape,n,i,s,a,c),filter:()=>HE(r,n,i.shape,s,a,c)}}},Mde={kernelName:G_,inputsToSave:["dy","filter"],gradFunc:(n,t,e)=>{const[r,i]=t,{strides:o,pad:s,dataFormat:a,dimRoundingMode:c}=e;return{dy:()=>Tc(n,i,o,s,a,1,c),filter:()=>HE(n,r,i.shape,o,s,a,c)}}},Pde=ue({conv3DBackpropFilter_:function Fde(n,t,e,r,i){let o=n;4===n.rank&&(o=be(n,[1,n.shape[0],n.shape[1],n.shape[2],n.shape[3]]));let s=t;return 4===s.rank&&(s=be(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]])),Z(5===o.rank,()=>`Error in conv3dDerFilter: input must be rank 5, but got shape ${o.shape}.`),Z(5===s.rank,()=>`Error in conv3dDerFilter: dy must be rank 5, but got shape ${s.shape}.`),Z(5===e.length,()=>`Error in conv3dDerFilter: filterShape must be length 5, but got ${e}.`),Z(o.shape[4]===e[3],()=>`Error in conv3dDerFilter: depth of input ${o.shape[4]}) must match input depth in filter (${e[3]}.`),Z(s.shape[4]===e[4],()=>`Error in conv3dDerFilter: depth of dy (${s.shape[4]}) must match output depth for filter (${e[4]}).`),pe.runKernel(CC,{x:o,dy:s},{strides:r,pad:i,filterShape:e})}}),$de={kernelName:H_,inputsToSave:["x","filter"],gradFunc:(n,t,e)=>{const{dilations:r,strides:i,pad:o}=e;Z(wc(r),()=>`Error in gradient of conv3D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${r}'`);const[s,a]=t;return{x:()=>EB(s.shape,n,a,i,o),filter:()=>Pde(s,n,a.shape,i,o)}}},Lde={kernelName:gm,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>fe(tr(OE(ht(e,"float32"))),n)}}},Bde={kernelName:bm,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>fe(RE(ht(e,"float32")),n)}}},Vde={kernelName:W_,inputsToSave:["x"],gradFunc:(n,t,e)=>{const[r]=t,{axis:i,exclusive:o,reverse:s}=e;return{x:()=>{const a=hr([i],r.rank);let c=fE(n,i,o,!s);return null!=a&&(c=wn(c,a)),c}}}},zde={kernelName:q_,inputsToSave:["x","filter"],gradFunc:(n,t,e)=>{const{dilations:r,strides:i,pad:o,dimRoundingMode:s}=e,a=r??[1,1];Z(wc(a),()=>`Error in gradient of depthwiseConv2dNative: dilation rates greater than 1 are not yet supported. Got dilations '${a}'`);const[c,u]=t;return Z(4===c.rank,()=>`Error in gradient of depthwiseConv2dNative: input must be rank 4, but got rank ${c.rank}.`),Z(4===u.rank,()=>`Error in gradient of depthwiseConv2dNative: filter must be rank 4, but got rank ${u.rank}.`),Z(c.shape[3]===u.shape[2],()=>`Error in gradient of depthwiseConv2d: number of input channels (${c.shape[3]}) must match the inChannels dimension in filter ${u.shape[2]}.`),Z(Di(i,a),()=>`Error in gradient of depthwiseConv2d: Either strides or dilations must be  1. Got strides ${i} and dilations '${a}'.`),oo("depthwiseConv2d",o,s),{x:()=>lV(c.shape,n,u,i,o,a,s),filter:()=>aV(c,n,u.shape,i,o,a,s)}}},Ude={kernelName:K_,inputsToSave:["x","filter"],gradFunc:(n,t,e)=>{const[r,i]=t,o={x:r,filter:i,dy:n},s={x:r,filter:i,dy:n};return{x:()=>pe.runKernel(MC,o,e),filter:()=>pe.runKernel(FC,s,e)}}},jde={kernelName:_m,outputsToSave:[!0],gradFunc:(n,t)=>{const[e]=t,r={dy:n,y:e};return{x:()=>pe.runKernel($C,r)}}},Gde={kernelName:vm,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t,r=fe(ls(tr(Hn(e))),2/Math.sqrt(Math.PI));return{x:()=>fe(n,r)}}},Hde={kernelName:xm,outputsToSave:[!0],gradFunc:(n,t)=>{const[e]=t;return{x:()=>fe(n,e)}}},Wde={kernelName:Y_,inputsToSave:["input"],gradFunc:(n,t)=>{const[e]=t;return{input:()=>be(n,e.shape)}}},qde={kernelName:wm,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>fe(n,ls(e))}}},Kde={kernelName:Tm,gradFunc:n=>({x:()=>vn(n)})},Xde={kernelName:Sm,inputsToSave:["a","b"],gradFunc:(n,t)=>{const[e,r]=t,i=Yt(e.shape,r.shape);return{a:()=>{const a=Nt(n,ht(r,"float32")),c=ti(e.shape,i);return c.length>0?be(St(a,c),e.shape):a},b:()=>{let a=fe(n,ht(e,"float32"));const c=ti(r.shape,i);c.length>0&&(a=be(St(a,c),r.shape));const u=Hn(r);return tr(Nt(a,ht(u,"float32")))}}}},Yde={kernelName:Z_,inputsToSave:["x","mean","variance","scale"],gradFunc:(n,t,e)=>{const{varianceEpsilon:r}=e,[i,o,s,a]=t,c=a??Ft(1),u=ti(o.shape,i.shape),p=[];if(1===o.rank){for(let V=0;V<i.shape.length-1;++V)p.push(i.shape[V]);p.push(1)}const m=xt(i,o),g=fe(n,c),_=DE(Xe(s,Ft(r))),x=fe(fe(fe(_,_),_),Ft(-.5));return{x:()=>be(fe(fe(n,1===o.rank?Fs(be(_,[1,1,1,o.shape[0]]),p):_),c),i.shape),mean:()=>{let V=fe(fe(_,Ft(-1)),g);return 1===o.rank&&(V=St(V,u)),be(V,o.shape)},variance:()=>{let V=fe(fe(x,m),g);return 1===o.rank&&(V=St(V,u)),be(V,o.shape)},scale:()=>{const V=fe(m,_);let j=fe(n,V);return 1===o.rank&&(j=St(j,u)),be(j,o.shape)},offset:()=>{let V=n;return 1===o.rank&&(V=St(V,u)),be(V,o.shape)}}}},Zde={kernelName:Q_,inputsToSave:["x","indices"],gradFunc:(n,t,e)=>{const[r,i]=t,{axis:o}=e,s=cn(o,r.shape)[0];return{x:()=>{const c=r.shape,u=i.size,p=c.slice(0,s),m=p.length,g=c.slice(o,c.length).slice(1),_=g.length,x=GV(0,m),T=GV(m+1,m+1+_),I=HV([p,[u],g]),N=be(n,I),R=be(i,[u]),L=HV([[m],x,T]),V=wn(N,L);let j=BE(V,R,r.shape[s]);const Y=Sc(L);return j=wn(j,Y),j},indices:()=>i}}};function GV(n,t){const e=[];for(let r=n;r<t;++r)e.push(r);return e}function HV(n){const t=[];for(let e=0;e<n.length;++e)for(let r=0;r<n[e].length;++r)t.push(n[e][r]);return t}const Qde={kernelName:Cm,inputsToSave:["a","b"],gradFunc:(n,t)=>{const[e,r]=t;return{a:()=>vn(e),b:()=>vn(r)}}},Jde={kernelName:Im,gradFunc:n=>({x:()=>ht(n,"float32")})},ehe={kernelName:Em,gradFunc:n=>({x:()=>vn(n)})},the={kernelName:Dm,gradFunc:n=>({x:()=>vn(n)})},nhe={kernelName:km,gradFunc:n=>({x:()=>vn(n)})},rhe={kernelName:e0,inputsToSave:["x"],gradFunc:(n,t,e)=>{const[r]=t,{alpha:i}=e,o=jo(r,0);return{x:()=>Gi(o,n,fe(n,i))}}},ihe={kernelName:Nm,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>Nt(n,Xe(e,1))}}},ohe={kernelName:Am,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>Nt(n,ht(e,"float32"))}}},she={kernelName:"LogSoftmax",inputsToSave:[],outputsToSave:[!0],gradFunc:(n,t,e)=>{const[r]=t,{axis:i}=e;return{logits:()=>{const s=ls(r);return xt(n,fe(St(n,i,!0),s))}}}},lhe=ue({localResponseNormalizationBackprop_:function ahe(n,t,e,r=5,i=1,o=1,s=.5){return pe.runKernel(HC,{x:n,y:t,dy:e},{depthRadius:r,bias:i,alpha:o,beta:s})}}),che={kernelName:a0,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,t,e)=>{const[r,i]=t,{depthRadius:o,bias:s,alpha:a,beta:c}=e;return{x:()=>lhe(r,i,n,o,s,a,c)}}};function WV(n,t,e,r){return t.rank<e.rank&&(t=be(t,Rr(t.shape,r))),n.rank<e.rank&&(n=be(n,Rr(n.shape,r))),{x:()=>fe(n,ht(la(e,t),n.dtype))}}const qV={kernelName:l0,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,t,e)=>{const r=e,{reductionIndices:i}=r,o=t[0],c=WV(n,t[1],o,cn(i,o.shape));return{x:()=>c.x()}}},uhe={kernelName:Om,inputsToSave:["a","b"],gradFunc:(n,t)=>{const[e,r]=t;return{a:()=>fe(n,ht(Cc(e,r),"float32")),b:()=>fe(n,ht(gg(e,r),"float32"))}}},hhe=ue({maxPool3dGrad_:function dhe(n,t,e,r,i,o,s){const a=Q(n,"dy","maxPool3dGrad"),c=Q(t,"input","maxPool3dGrad"),u=Q(e,"output","maxPool3dGrad");let p=a,m=c,g=u,_=!1;4===c.rank&&(_=!0,p=be(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]]),m=be(c,[1,c.shape[0],c.shape[1],c.shape[2],c.shape[3]]),g=be(u,[1,u.shape[0],u.shape[1],u.shape[2],u.shape[3]])),Z(5===p.rank,()=>`Error in maxPool3dGrad: dy must be rank 5 but got rank ${p.rank}.`),Z(5===m.rank,()=>`Error in maxPool3dGrad: input must be rank 5 but got rank ${m.rank}.`),Z(5===g.rank,()=>`Error in maxPool3dGrad: output must be rank 5 but got rank ${g.rank}.`),oo("maxPool3dGrad",o,s);const I=pe.runKernel(qC,{dy:p,input:m,output:g},{filterSize:r,strides:i,pad:o,dimRoundingMode:s});return _?be(I,[I.shape[1],I.shape[2],I.shape[3],I.shape[4]]):I}}),phe={kernelName:u0,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,t,e)=>{const[r,i]=t,{filterSize:o,strides:s,pad:a,dimRoundingMode:c}=e;return{x:()=>hhe(n,r,i,o,s,a,c)}}},mhe=ue({maxPoolGrad_:function fhe(n,t,e,r,i,o,s){const a=Q(n,"dy","maxPoolGrad"),c=Q(t,"input","maxPoolGrad"),u=Q(e,"output","maxPoolGrad");return Z(c.rank===a.rank,()=>`Rank of input (${c.rank}) does not match rank of dy (${a.rank})`),Z(4===a.rank,()=>`Error in maxPoolGrad: dy must be rank 4 but got rank ${a.rank}.`),Z(4===c.rank,()=>`Error in maxPoolGrad: input must be rank 4 but got rank ${c.rank}.`),oo("maxPoolGrad",o,s),pe.runKernel(WC,{dy:a,input:c,output:u},{filterSize:r,strides:i,pad:o,dimRoundingMode:s})}}),KV={kernelName:_0,inputsToSave:["x"],gradFunc:(n,t,e)=>{const r=t[0],{paddings:i}=e,o=i.map(s=>s[0]);return{x:()=>xn(n,o,r.shape)}}};const XV={kernelName:k0,gradFunc:(n,t,e)=>{const{blockShape:r,paddings:i}=e;return{x:()=>Q0(n,r,i)}}},YV={kernelName:A0,gradFunc:(n,t,e)=>{const{axis:r}=e;return{x:()=>Ur(n,r)}}},dpe=[jV,lde,cde,ude,dde,hde,pde,fde,mde,gde,bde,yde,xde,Sde,Cde,Ide,Ede,Dde,kde,Ade,Nde,Ode,Mde,Rde,$de,Lde,Bde,Vde,zde,Ude,{kernelName:ym,inputsToSave:["a","b"],gradFunc:(n,t)=>{const[e,r]=t,i=Yt(e.shape,r.shape);return{a:()=>{const a=Nt(n,ht(r,"float32")),c=ti(e.shape,i);return c.length>0?be(St(a,c),e.shape):a},b:()=>{let a=fe(n,ht(e,"float32"));const c=ti(r.shape,i);c.length>0&&(a=be(St(a,c),r.shape));const u=Hn(r);return tr(Nt(a,ht(u,"float32")))}}}},jde,Gde,Hde,Wde,qde,Xde,Kde,Yde,Zde,Qde,Jde,ehe,the,nhe,rhe,ihe,ohe,she,che,qV,qV,uhe,phe,{kernelName:c0,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,t,e)=>{const[r,i]=t,{filterSize:o,strides:s,pad:a}=e;return{x:()=>mhe(n,r,i,o,s,a)}}},{kernelName:d0,inputsToSave:["x"],gradFunc:(n,t,e)=>{const[r]=t,{axis:i}=e,o=cn(i,r.shape),c=Me(gi(r.shape,o)[1]);return{x:()=>{const p=r.shape.slice();o.forEach(_=>{p[_]=1});const m=be(n,p);return Nt(fe(m,us(r.shape,"float32")),c)}}}},{kernelName:h0,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,t,e)=>{const r=e,{axis:i}=r,[o,s]=t,c=WV(n,s,o,cn(i,o.shape));return{x:()=>c.x()}}},{kernelName:Rm,inputsToSave:["a","b"],gradFunc:(n,t)=>{const[e,r]=t;return{a:()=>fe(n,ht(Mu(e,r),"float32")),b:()=>fe(n,ht(jo(e,r),"float32"))}}},{kernelName:p0,inputsToSave:["x"],gradFunc:(n,t,e)=>{const r=t[0],{paddings:i}=e,o=i.map(s=>s[0]);return{x:()=>xn(n,o,r.shape)}}},{kernelName:Mm,inputsToSave:["a","b"],gradFunc:(n,t)=>{const[e,r]=t,i=Yt(e.shape,r.shape);return{a:()=>{const a=ti(e.shape,i);return a.length>0?be(St(n,a),e.shape):n},b:()=>{const a=fe(n,tr(fg(Nt(e,r)))),c=ti(r.shape,i);return c.length>0?be(St(a,c),r.shape):a}}}},{kernelName:Fm,inputsToSave:["a","b"],gradFunc:(n,t)=>{const[e,r]=t,i=Yt(e.shape,r.shape);return{a:()=>{const a=fe(n,ht(r,"float32")),c=ti(e.shape,i);return c.length>0?be(St(a,c),e.shape):a},b:()=>{const a=fe(n,ht(e,"float32")),c=ti(r.shape,i);return c.length>0?be(St(a,c),r.shape):a}}}},{kernelName:f0,gradFunc:n=>({x:()=>tr(n)})},{kernelName:b0,inputsToSave:["indices"],gradFunc:(n,t)=>{const e=t[0];return{indices:()=>ni(e.shape,"float32")}}},{kernelName:g0,gradFunc:n=>({x:()=>vn(n)})},{kernelName:y0,saveAllInputs:!0,gradFunc:(n,t,e)=>{const{axis:r}=e;return $s(n,r).map(o=>()=>o)}},KV,KV,{kernelName:Pm,inputsToSave:["a","b"],outputsToSave:[!0],gradFunc:(n,t)=>{const[e,r,i]=t,o=e,s=r,a=Yt(o.shape,s.shape);return{a:()=>{const p=ht(s,"float32");let m=fe(n,fe(p,vc(o,xt(p,Ft(1)))));const g=ti(o.shape,a);return g.length>0&&(m=St(m,g)),be(m,o.shape)},b:()=>{const p=jo(o,0),m=Gi(p,cs(o),vn(o));let g=fe(n,fe(i,m));const _=ti(s.shape,a);return _.length>0&&(g=St(g,_)),be(g,s.shape)}}}},{kernelName:v0,inputsToSave:["x","alpha"],gradFunc:(n,t)=>{const[e,r]=t,i=jo(e,0);return{x:()=>Gi(i,n,fe(n,r)),alpha:()=>{let o=Gi(i,vn(n),fe(n,e));const s=ti(r.shape,n.shape);return s.length>0&&(o=St(o,s)),be(o,r.shape)}}}},{kernelName:x0,inputsToSave:["x"],gradFunc:(n,t,e)=>{const[r]=t,{axis:i}=e;let o=[];return o=null==i?r.shape.map((s,a)=>a):"number"==typeof i?[i]:i,{x:()=>function Ahe(n,t,e){const r=n.shape.length,i=r-e.length,o=hr(e,r);let s=n;null!=o&&(s=wn(n,o));const a=s.shape.slice(),u=a.splice(r-e.length,e.length).reduce((g,_)=>g*_,1);a.push(u);let m=function khe(n,t,e){const r=n.shape.slice();r[e]=1;const i=be(t,r),o=ev(n,e,!0,!1),s=ev(n,e,!0,!0),a=fe(o,s);return fe(i,a)}(s.reshape(a),t,i);if(m=m.reshape(s.shape),null!=o){const g=Sc(o);m=wn(m,g)}return m}(r,n,o)}}},{kernelName:$m,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>Nt(n,tr(Hn(e)))}}},{kernelName:Bm,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t,r=fe(Mu(e,6),Bh(e));return{x:()=>fe(n,ht(r,"float32"))}}},{kernelName:Lm,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>fe(n,ht(Bh(e),"float32"))}}},{kernelName:w0,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>be(n,e.shape)}}},{kernelName:S0,inputsToSave:["images"],gradFunc:(n,t,e)=>{const[r]=t,i={dy:n,images:r};return{images:()=>pe.runKernel(oI,i,e)}}},{kernelName:T0,inputsToSave:["images"],gradFunc:(n,t,e)=>{const[r]=t,i={dy:n,images:r};return{images:()=>pe.runKernel(iI,i,e)}}},{kernelName:C0,gradFunc:(n,t,e)=>{const{dims:r}=e,i=cn(r,n.shape);return{x:()=>Ps(n,i)}}},{kernelName:Vm,gradFunc:n=>({x:()=>vn(n)})},{kernelName:zm,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>tr(Nt(n,fe(vc(e,1.5),2)))}}},{kernelName:I0,inputsToSave:["condition"],gradFunc:(n,t)=>{const[e]=t;return{condition:()=>ht(vn(e),"float32"),t:()=>fe(n,ht(e,n.dtype)),e:()=>fe(n,ht(iv(e),n.dtype))}}},{kernelName:Um,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>{const r=jo(e,Ft(0)),i=Ft(xv),o=Ft(wv),s=fe(n,o),a=fe(fe(n,i),ls(ht(e,"float32")));return Gi(r,s,a)}}}},{kernelName:Wm,outputsToSave:[!0],gradFunc:(n,t)=>{const[e]=t;return{x:()=>fe(n,fe(e,xt(Ft(1),e)))}}},{kernelName:Hm,gradFunc:n=>({x:()=>vn(n)})},{kernelName:jm,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>fe(J0(ht(e,"float32")),n)}}},{kernelName:Gm,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>fe(pE(ht(e,"float32")),n)}}},{kernelName:E0,inputsToSave:["x"],gradFunc:(n,t,e)=>{const[r]=t,{begin:i,size:o}=e,s=r.shape,[a,c]=X0(r,i,o),u=[];for(let p=0;p<n.rank;p++)u.push([a[p],s[p]-a[p]-c[p]]);return{x:()=>Ic(n,u)}}},{kernelName:N0,outputsToSave:[!0],gradFunc:(n,t,e)=>{const[r]=t,{dim:i}=e,s=fe(n,r);return{logits:()=>xt(s,fe(St(s,[i],!0),r))}}},{kernelName:qm,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>fe(n,Pa(e))}}},XV,XV,YV,YV,{kernelName:Km,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>Nt(n,fe(ji(ht(e,"float32")),2))}}},{kernelName:Xm,inputsToSave:["a","b"],gradFunc:(n,t)=>{const[e,r]=t,i=Ft(2);return{a:()=>fe(n,fe(i,xt(e,r))),b:()=>fe(n,fe(i,xt(r,e)))}}},{kernelName:fI,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>fe(n,fe(ht(e,"float32"),2))}}},{kernelName:eg,gradFunc:n=>({x:()=>vn(n)})},{kernelName:Ym,inputsToSave:["a","b"],gradFunc:(n,t)=>{const[e,r]=t,i=Yt(e.shape,r.shape);return{a:()=>{let a=n;const c=ti(e.shape,i);return c.length>0&&(a=St(a,c)),be(a,e.shape)},b:()=>{let a=n;const c=ti(r.shape,i);return c.length>0&&(a=St(a,c)),be(tr(a),r.shape)}}}},{kernelName:D0,inputsToSave:["x"],gradFunc:(n,t,e)=>{const[r]=t,i=r.shape.slice(),{axis:o}=e;cn(o,r.shape).forEach(u=>{i[u]=1});const a=be(n,i),c=fe(a,us(r.shape,"float32"));return{x:()=>c}}},{kernelName:Zm,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>Nt(n,Hn(J0(e)))}}},{kernelName:Qm,outputsToSave:[!0],gradFunc:(n,t)=>{const[e]=t;return{x:()=>fe(xt(Ft(1),Hn(e)),n)}}},{kernelName:Jm,inputsToSave:["x"],gradFunc:(n,t,e)=>{const[r]=t,{reps:i}=e;return{x:()=>{let s=vn(r);if(1===r.rank)for(let a=0;a<i[0];++a)s=Xe(s,xn(n,[a*r.shape[0]],[r.shape[0]]));else if(2===r.rank)for(let a=0;a<i[0];++a)for(let c=0;c<i[1];++c)s=Xe(s,xn(n,[a*r.shape[0],c*r.shape[1]],[r.shape[0],r.shape[1]]));else if(3===r.rank)for(let a=0;a<i[0];++a)for(let c=0;c<i[1];++c)for(let u=0;u<i[2];++u)s=Xe(s,xn(n,[a*r.shape[0],c*r.shape[1],u*r.shape[2]],[r.shape[0],r.shape[1],r.shape[2]]));else{if(4!==r.rank)throw new Error(`Gradient for tile operation is not implemented for rank-${r.rank} tensors yet.`);for(let a=0;a<i[0];++a)for(let c=0;c<i[1];++c)for(let u=0;u<i[2];++u)for(let p=0;p<i[3];++p)s=Xe(s,xn(n,[a*r.shape[0],c*r.shape[1],u*r.shape[2],p*r.shape[3]],[r.shape[0],r.shape[1],r.shape[2],r.shape[3]]))}return s}}}},{kernelName:wh,gradFunc:(n,t,e)=>{const r=e,{perm:i}=r,o=Sc(i);return{x:()=>wn(n,o)}}},{kernelName:R0,gradFunc:(n,t,e)=>{const r=e,{axis:i}=r;return{value:()=>hs(n,i)}}},{kernelName:M0,inputsToSave:["segmentIds"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>function cpe(n,t){const e=xl(t,vn(t)),r=mg(n,e);let i=Cc(t,Ft(0,"int32"));const o=r.rank-i.rank;for(let a=0;a<o;++a)i=To(i,a+1);i=$a(i,us(r.shape,"bool"));const s=vn(r);return Gi(i,r,s)}(n,e)}}},{kernelName:F0,gradFunc:n=>({x:()=>vn(n)})}];for(const n of dpe)vre(n);Pe().prototype.abs=function(){return this.throwIfDisposed(),ei(this)},Pe().prototype.acos=function(){return this.throwIfDisposed(),lB(this)},Pe().prototype.acosh=function(){return this.throwIfDisposed(),cB(this)},Pe().prototype.add=function(n){return this.throwIfDisposed(),Xe(this,n)},Pe().prototype.all=function(n,t){return this.throwIfDisposed(),aE(this,n,t)},Pe().prototype.any=function(n,t){return this.throwIfDisposed(),Y0(this,n,t)},Pe().prototype.argMax=function(n){return this.throwIfDisposed(),Oh(this,n)},Pe().prototype.argMin=function(n){return this.throwIfDisposed(),uB(this,n)},Pe().prototype.asScalar=function(){return this.throwIfDisposed(),Z(1===this.size,()=>"The array must have only 1 element."),be(this,[])},Pe().prototype.asType=function(n){return this.throwIfDisposed(),ht(this,n)},Pe().prototype.as1D=function(){return this.throwIfDisposed(),be(this,[this.size])},Pe().prototype.as2D=function(n,t){return this.throwIfDisposed(),be(this,[n,t])},Pe().prototype.as3D=function(n,t,e){return this.throwIfDisposed(),be(this,[n,t,e])},Pe().prototype.as4D=function(n,t,e,r){return this.throwIfDisposed(),be(this,[n,t,e,r])},Pe().prototype.as5D=function(n,t,e,r,i){return this.throwIfDisposed(),be(this,[n,t,e,r,i])},Pe().prototype.asin=function(){return this.throwIfDisposed(),dB(this)},Pe().prototype.asinh=function(){return this.throwIfDisposed(),hB(this)},Pe().prototype.atan=function(){return this.throwIfDisposed(),pB(this)},Pe().prototype.atan2=function(n){return this.throwIfDisposed(),fB(this,n)},Pe().prototype.atanh=function(){return this.throwIfDisposed(),mB(this)},Pe().prototype.avgPool=function(n,t,e,r){return this.throwIfDisposed(),Z0(this,n,t,e,r)},Pe().prototype.batchToSpaceND=function(n,t){return this.throwIfDisposed(),Q0(this,n,t)},Pe().prototype.batchNorm=function(n,t,e,r,i){return this.throwIfDisposed(),cg(this,n,t,e,r,i)},Pe().prototype.broadcastTo=function(n){return this.throwIfDisposed(),Fh(this,n)},Pe().prototype.cast=function(n){return this.throwIfDisposed(),ht(this,n)},Pe().prototype.ceil=function(){return this.throwIfDisposed(),xB(this)},Pe().prototype.clipByValue=function(n,t){return this.throwIfDisposed(),Uo(this,n,t)},Pe().prototype.concat=function(n,t){return this.throwIfDisposed(),n instanceof sr&&(n=[n]),Ur([this,...n],t)},Pe().prototype.conv1d=function(n,t,e,r,i,o){return this.throwIfDisposed(),uE(this,n,t,e,r,i,o)},Pe().prototype.conv2dTranspose=function(n,t,e,r,i){return this.throwIfDisposed(),hE(this,n,t,e,r,i)},Pe().prototype.conv2d=function(n,t,e,r,i,o){return this.throwIfDisposed(),Tc(this,n,t,e,r,i,o)},Pe().prototype.cos=function(){return this.throwIfDisposed(),J0(this)},Pe().prototype.cosh=function(){return this.throwIfDisposed(),pE(this)},Pe().prototype.cumprod=function(n,t,e){return this.throwIfDisposed(),ev(this,n,t,e)},Pe().prototype.cumsum=function(n,t,e){return this.throwIfDisposed(),fE(this,n,t,e)},Pe().prototype.depthToSpace=function(n,t){return this.throwIfDisposed(),kB(this,n,t)},Pe().prototype.depthwiseConv2d=function(n,t,e,r,i,o){return this.throwIfDisposed(),ug(this,n,t,e,r,i,o)},Pe().prototype.dilation2d=function(n,t,e,r,i){return this.throwIfDisposed(),AB(this,n,t,e,r,i)},Pe().prototype.divNoNan=function(n){return this.throwIfDisposed(),NB(this,n)},Pe().prototype.div=function(n){return this.throwIfDisposed(),Nt(this,n)},Pe().prototype.dot=function(n){return this.throwIfDisposed(),OB(this,n)},Pe().prototype.elu=function(){return this.throwIfDisposed(),dg(this)},Pe().prototype.equal=function(n){return this.throwIfDisposed(),la(this,n)},Pe().prototype.erf=function(){return this.throwIfDisposed(),RB(this)},Pe().prototype.euclideanNorm=function(n,t){return this.throwIfDisposed(),PB(this,n,t)},Pe().prototype.exp=function(){return this.throwIfDisposed(),ls(this)},Pe().prototype.expandDims=function(n){return this.throwIfDisposed(),To(this,n)},Pe().prototype.expm1=function(){return this.throwIfDisposed(),$B(this)},Pe().prototype.fft=function(){return this.throwIfDisposed(),fv(this)},Pe().prototype.flatten=function(){return this.throwIfDisposed(),be(this,[this.size])},Pe().prototype.floor=function(){return this.throwIfDisposed(),fg(this)},Pe().prototype.floorDiv=function(n){return this.throwIfDisposed(),qI(this,n)},Pe().prototype.gather=function(n,t,e){return this.throwIfDisposed(),mg(this,n,t,e)},Pe().prototype.greaterEqual=function(n){return this.throwIfDisposed(),Cc(this,n)},Pe().prototype.greater=function(n){return this.throwIfDisposed(),jo(this,n)},Pe().prototype.ifft=function(){return this.throwIfDisposed(),_g(this)},Pe().prototype.irfft=function(){return this.throwIfDisposed(),FE(this)},Pe().prototype.isFinite=function(){return this.throwIfDisposed(),LB(this)},Pe().prototype.isInf=function(){return this.throwIfDisposed(),BB(this)},Pe().prototype.isNaN=function(){return this.throwIfDisposed(),VB(this)},Pe().prototype.leakyRelu=function(n){return this.throwIfDisposed(),nv(this,n)},Pe().prototype.lessEqual=function(n){return this.throwIfDisposed(),Mu(this,n)},Pe().prototype.less=function(n){return this.throwIfDisposed(),gg(this,n)},Pe().prototype.localResponseNormalization=function(n,t,e,r){return this.throwIfDisposed(),zB(this,n,t,e,r)},Pe().prototype.logSigmoid=function(){return this.throwIfDisposed(),UB(this)},Pe().prototype.logSoftmax=function(n){return this.throwIfDisposed(),yE(this,n)},Pe().prototype.logSumExp=function(n,t){return this.throwIfDisposed(),_E(this,n,t)},Pe().prototype.log=function(){return this.throwIfDisposed(),cs(this)},Pe().prototype.log1p=function(){return this.throwIfDisposed(),rv(this)},Pe().prototype.logicalAnd=function(n){return this.throwIfDisposed(),$a(this,n)},Pe().prototype.logicalNot=function(){return this.throwIfDisposed(),iv(this)},Pe().prototype.logicalOr=function(n){return this.throwIfDisposed(),vE(this,n)},Pe().prototype.logicalXor=function(n){return this.throwIfDisposed(),jB(this,n)},Pe().prototype.matMul=function(n,t,e){return this.throwIfDisposed(),hn(this,n,t,e)},Pe().prototype.maxPool=function(n,t,e,r){return this.throwIfDisposed(),sv(this,n,t,e,r)},Pe().prototype.max=function(n,t){return this.throwIfDisposed(),Ms(this,n,t)},Pe().prototype.maximum=function(n){return this.throwIfDisposed(),xl(this,n)},Pe().prototype.mean=function(n,t){return this.throwIfDisposed(),Sr(this,n,t)},Pe().prototype.min=function(n,t){return this.throwIfDisposed(),hg(this,n,t)},Pe().prototype.minimum=function(n){return this.throwIfDisposed(),Fu(this,n)},Pe().prototype.mirrorPad=function(n,t){return this.throwIfDisposed(),HB(this,n,t)},Pe().prototype.mod=function(n){return this.throwIfDisposed(),WB(this,n)},Pe().prototype.mul=function(n){return this.throwIfDisposed(),fe(this,n)},Pe().prototype.neg=function(){return this.throwIfDisposed(),tr(this)},Pe().prototype.norm=function(n,t,e){return this.throwIfDisposed(),pg(this,n,t,e)},Pe().prototype.notEqual=function(n){return this.throwIfDisposed(),$h(this,n)},Pe().prototype.oneHot=function(n,t=1,e=0){return this.throwIfDisposed(),wE(this,n,t,e)},Pe().prototype.onesLike=function(){return this.throwIfDisposed(),ds(this)},Pe().prototype.pad=function(n,t){return this.throwIfDisposed(),Ic(this,n,t)},Pe().prototype.pool=function(n,t,e,r,i,o){return this.throwIfDisposed(),qB(this,n,t,e,r,i,o)},Pe().prototype.pow=function(n){return this.throwIfDisposed(),vc(this,n)},Pe().prototype.prelu=function(n){return this.throwIfDisposed(),cv(this,n)},Pe().prototype.prod=function(n,t){return this.throwIfDisposed(),KB(this,n,t)},Pe().prototype.reciprocal=function(){return this.throwIfDisposed(),XB(this)},Pe().prototype.relu=function(){return this.throwIfDisposed(),La(this)},Pe().prototype.relu6=function(){return this.throwIfDisposed(),IE(this)},Pe().prototype.reshapeAs=function(n){return this.throwIfDisposed(),be(this,n.shape)},Pe().prototype.reshape=function(n){return this.throwIfDisposed(),be(this,n)},Pe().prototype.resizeBilinear=function(n,t,e){return this.throwIfDisposed(),hV(this,n,t,e)},Pe().prototype.resizeNearestNeighbor=function(n,t,e){return this.throwIfDisposed(),pV(this,n,t,e)},Pe().prototype.reverse=function(n){return this.throwIfDisposed(),Ps(this,n)},Pe().prototype.rfft=function(){return this.throwIfDisposed(),mv(this)},Pe().prototype.round=function(){return this.throwIfDisposed(),EE(this)},Pe().prototype.rsqrt=function(){return this.throwIfDisposed(),DE(this)},Pe().prototype.selu=function(){return this.throwIfDisposed(),kE(this)},Pe().prototype.separableConv2d=function(n,t,e,r,i,o){return this.throwIfDisposed(),AE(this,n,t,e,r,i,o)},Pe().prototype.sigmoid=function(){return this.throwIfDisposed(),Pa(this)},Pe().prototype.sign=function(){return this.throwIfDisposed(),YB(this)},Pe().prototype.sin=function(){return this.throwIfDisposed(),OE(this)},Pe().prototype.sinh=function(){return this.throwIfDisposed(),RE(this)},Pe().prototype.slice=function(n,t){return this.throwIfDisposed(),xn(this,n,t)},Pe().prototype.softmax=function(n){return this.throwIfDisposed(),pv(this,n)},Pe().prototype.softplus=function(){return this.throwIfDisposed(),Ph(this)},Pe().prototype.spaceToBatchND=function(n,t){return this.throwIfDisposed(),lv(this,n,t)},Pe().prototype.split=function(n,t){return this.throwIfDisposed(),Go(this,n,t)},Pe().prototype.sqrt=function(){return this.throwIfDisposed(),ji(this)},Pe().prototype.square=function(){return this.throwIfDisposed(),Hn(this)},Pe().prototype.squaredDifference=function(n){return this.throwIfDisposed(),PE(this,n)},Pe().prototype.squeeze=function(n){return this.throwIfDisposed(),$u(this,n)},Pe().prototype.stack=function(n,t){this.throwIfDisposed();const e=n instanceof sr?[this,n]:[this,...n];return hs(e,t)},Pe().prototype.step=function(n){return this.throwIfDisposed(),Bh(this,n)},Pe().prototype.stridedSlice=function(n,t,e,r,i,o,s,a){return this.throwIfDisposed(),ZB(this,n,t,e,r,i,o,s,a)},Pe().prototype.sub=function(n){return this.throwIfDisposed(),xt(this,n)},Pe().prototype.sum=function(n,t){return this.throwIfDisposed(),St(this,n,t)},Pe().prototype.tan=function(){return this.throwIfDisposed(),QB(this)},Pe().prototype.tanh=function(){return this.throwIfDisposed(),Mh(this)},Pe().prototype.tile=function(n){return this.throwIfDisposed(),Fs(this,n)},Pe().prototype.toBool=function(){return this.throwIfDisposed(),ht(this,"bool")},Pe().prototype.toFloat=function(){return this.throwIfDisposed(),ht(this,"float32")},Pe().prototype.toInt=function(){return this.throwIfDisposed(),ht(this,"int32")},Pe().prototype.topk=function(n,t){return this.throwIfDisposed(),eV(this,n,t)},Pe().prototype.transpose=function(n){return this.throwIfDisposed(),wn(this,n)},Pe().prototype.unique=function(n){return this.throwIfDisposed(),tV(this,n)},Pe().prototype.unsortedSegmentSum=function(n,t){return this.throwIfDisposed(),BE(this,n,t)},Pe().prototype.unstack=function(n){return this.throwIfDisposed(),$s(this,n)},Pe().prototype.where=function(n,t){return this.throwIfDisposed(),Gi(n,this,t)},Pe().prototype.zerosLike=function(){return this.throwIfDisposed(),vn(this)};class za extends Error{constructor(t){super(t),Object.setPrototypeOf(this,za.prototype)}}class Ls extends Error{constructor(t){super(t),Object.setPrototypeOf(this,Ls.prototype)}}class ye extends Error{constructor(t){super(t),Object.setPrototypeOf(this,ye.prototype)}}class en extends Error{constructor(t){super(t),Object.setPrototypeOf(this,en.prototype)}}class wD extends Error{constructor(t){super(t),Object.setPrototypeOf(this,wD.prototype)}}class ZV extends Error{constructor(t){super(t),Object.setPrototypeOf(this,ZV.prototype)}}class QV{constructor(t){this.maxEntries=t||100,this.cache=new Map}get(t){let e;return this.cache.has(t)&&(e=this.cache.get(t),this.cache.delete(t),this.cache.set(t,e)),e}put(t,e){if(this.cache.has(t))this.cache.delete(t);else if(this.cache.size>=this.maxEntries){const r=this.cache.keys().next().value;this.cache.delete(r)}this.cache.set(t,e)}getMaxEntries(){return this.maxEntries}setMaxEntries(t){if(t<0)throw new Error(`The maxEntries of LRU caches must be at least 0, but got ${t}.`);if(this.maxEntries>t)for(let e=0;e<this.maxEntries-t;e++){const r=this.cache.keys().next().value;this.cache.delete(r)}this.maxEntries=t}}function Bu(n,t){if(Array.isArray(n)){let e=[];for(let r=0;r<t;r++)e=e.concat(n);return e}{const e=new Array(t);return e.fill(n),e}}function ps(n,t){if(!n)throw new wD(t)}function JV(n,t){let e=0;for(const r of n)r===t&&e++;return e}function Co(n){return 1===n.length?n[0]:n}function Xn(n){return Array.isArray(n)?n:[n]}function El(n){const e=n.replace(/(.)([A-Z][a-z0-9]+)/g,"$1_$2").replace(/([a-z])([A-Z])/g,"$1_$2").toLowerCase();return"_"!==e[0]?e:"private"+e}function Vu(n){return n.length<=1||-1===n.indexOf("_")?n:n.replace(/[_]+(\w|$)/g,(t,e)=>e.toUpperCase())}let Bs={};function TD(n){if(null==n)return null;const t={};return t.className=n.getClassName(),t.config=n.getConfig(),t}function SD(n){if(null!=n&&"object"==typeof n)if(Array.isArray(n))n.forEach(t=>SD(t));else{const t=Object.keys(n);for(const e of t){const r=n[e];null!=r&&"object"==typeof r&&(Array.isArray(r)||"ndarray"!==r.type||"number"!=typeof r.value?SD(r):n[e]=r.value)}}}function Tg(n,t={},e={},r="object",i=!1){if("string"==typeof n){let s;if(n in e)s=e[n];else if(n in Bs)s=Bs[n];else if(s=t[n],null==s)throw new ye(`Unknown ${r}: ${n}. This may be due to one of the following reasons:\n1. The ${r} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.\n2. The custom ${r} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);return s}{const o=n;if(null==o.className||null==o.config)throw new ye(`${r}: Improper config format: ${JSON.stringify(o)}.\n'className' and 'config' must set.`);const s=o.className;let a,c;if(s in e?[a,c]=e[s]:s in Bs?[a,c]=Bs.className:s in t&&([a,c]=t[s]),null==a)throw new ye(`Unknown ${r}: ${s}. This may be due to one of the following reasons:\n1. The ${r} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.\n2. The custom ${r} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);if(null!=c){const u={};for(const _ of Object.keys(Bs))u[_]=Bs[_];for(const _ of Object.keys(e))u[_]=e[_];o.config.customObjects=u;const m=Object.assign({},Bs);for(const _ of Object.keys(e))Bs[_]=e[_];SD(o.config);const g=c(a,o.config,e,i);return Bs=Object.assign({},m),g}{const u=Object.assign({},Bs);for(const m of Object.keys(e))Bs[m]=e[m];const p=new a(o.config);return Bs=Object.assign({},u),p}}}function Tv(n,t){return-1*function hpe(n,t){return n<t?-1:n>t?1:0}(n,t)}function Ec(n){if(null==n)return n;const t=[];for(const e of n)-1===t.indexOf(e)&&t.push(e);return t}function ppe(n){if(null==n)throw new ye(`Invalid value in obj: ${JSON.stringify(n)}`);for(const t in n)if(n.hasOwnProperty(t))return!1;return!0}function zu(n,t,e){if(null!=e&&n.indexOf(e)<0)throw new ye(`${e} is not a valid ${t}.  Valid values are ${n} or null/undefined.`)}function CD(n,t,e=0,r=1/0){return ps(e>=0),ps(r>=e),Array.isArray(n)&&n.length>=e&&n.length<=r&&n.every(i=>typeof i===t)}function bi(n,t){Array.isArray(n)?(Z(n.length>0,()=>`${t} is unexpectedly an empty array.`),n.forEach((e,r)=>bi(e,`element ${r+1} of ${t}`))):Z(Number.isInteger(n)&&n>0,()=>`Expected ${t} to be a positive integer, but got ${e4(n)}.`)}function e4(n){return null===n?"null":Array.isArray(n)?"["+n.map(t=>e4(t)).join(",")+"]":"string"==typeof n?`"${n}"`:`${n}`}function t4(n){return"relu"===n?"relu":"linear"===n?"linear":"elu"===n?"elu":null}let mpe=0;function n4(){return mpe++}const Sv={};function Cv(n=""){return n in Sv||(Sv[n]=0),Sv[n]+=1,n+Sv[n].toString()}const gpe=["channelsFirst","channelsLast"],bpe=["nearest","bilinear"],ype=["valid","same","causal"],_pe=["max","avg"],vpe=["sum","mul","concat","ave"],jh=new Map;function Fr(n){zu(gpe,"DataFormat",n)}function fs(n){zu(ype,"PaddingMode",n)}function r4(n){zu(_pe,"PoolMode",n)}const Sg=[];function Uu(n,t){Sg.push(n);try{const e=t();return Sg.pop(),e}catch(e){throw Sg.pop(),e}}function s4(n){if(!l4(n))throw new Error("Not a valid tensor name: '"+n+"'");return function wpe(){return 0===Sg.length?"":Sg.join("/")+"/"}()+n}function a4(n){if(!l4(n))throw new Error("Not a valid tensor name: '"+n+"'");jh.has(n)||jh.set(n,0);const t=jh.get(n);if(jh.set(n,jh.get(n)+1),t>0){const e=`${n}_${t}`;return jh.set(e,1),e}return n}const Tpe=new RegExp(/^[A-Za-z0-9][-A-Za-z0-9\._\/]*$/);function l4(n){return!!n.match(Tpe)}function Spe(n){return n===parseInt(n.toString(),10)}function Dc(n,t,e){null==t&&(t=0),null==e&&(e=n.length);let r=1;for(let i=t;i<e;++i)r*=n[i];return r}function Gh(n){if(0===n.length)return Number.NaN;let t=Number.POSITIVE_INFINITY;for(let e=0;e<n.length;e++){const r=n[e];r<t&&(t=r)}return t}function kc(n){if(0===n.length)return Number.NaN;let t=Number.NEGATIVE_INFINITY;for(let e=0;e<n.length;e++){const r=n[e];r>t&&(t=r)}return t}function ca(n,t){if(t<n)throw new ye(`end (${t}) < begin (${n}) is forbidden.`);const e=[];for(let r=n;r<t;++r)e.push(r);return e}let Iv;function ri(){return null==Iv&&(Iv=function wie(){return pe.backend}().epsilon()),Iv}function Ua(n,t){return ht(n,t)}function Cg(n,t=-1){const e=n.shape.slice();return t<0&&(t=e.length+t+1),e.splice(t,0,1),be(n,e)}function ju(n,t,e){return Se(()=>{switch(n.rank){case 1:return dv(n,t,e);case 2:return ME(n,[t,0],[e,n.shape[1]]);case 3:return hv(n,[t,0,0],[e,n.shape[1],n.shape[2]]);case 4:return yg(n,[t,0,0,0],[e,n.shape[1],n.shape[2],n.shape[3]]);case 5:return xn(n,[t,0,0,0,0],[e,n.shape[1],n.shape[2],n.shape[3],n.shape[4]]);case 6:return xn(n,[t,0,0,0,0,0],[e,n.shape[1],n.shape[2],n.shape[3],n.shape[4],n.shape[5]]);default:throw new ye(`sliceAlongFirstAxis() received an unsupported tensor rank: ${n.rank}`)}})}function ID(n,t,e){return Se(()=>{switch(n.rank){case 1:return dv(n,t,e);case 2:return ME(n,[0,t],[n.shape[0],e]);case 3:return hv(n,[0,0,t],[n.shape[0],n.shape[1],e]);case 4:return yg(n,[0,0,0,t],[n.shape[0],n.shape[1],n.shape[2],e]);default:throw new ye(`sliceAlongLastAxis() received an unsupported tensor rank: ${n.rank}`)}})}function Ev(n,t,e,r){return Se(()=>{switch(n.rank){case 1:return dv(n,t,e);case 2:switch(r){case 1:return ju(n,t,e);case 2:return ID(n,t,e);default:throw new ye(`The axis is not within the rank of the tensor ${r}`)}case 3:switch(r){case 1:return ju(n,t,e);case 2:return hv(n,[0,t,0],[n.shape[0],e,n.shape[2]]);case 3:return ID(n,t,e);default:throw new ye(`The axis is not within the rank of the tensor ${r}`)}case 4:switch(r){case 1:return ju(n,t,e);case 2:return yg(n,[0,t,0,0],[n.shape[0],e,n.shape[2],n.shape[3]]);case 3:return yg(n,[0,0,t,0],[n.shape[0],n.shape[1],e,n.shape[3]]);case 4:return ID(n,t,e);default:throw new ye(`The axis is not within the rank of the tensor ${r}`)}default:throw new ye(`sliceAlongLastAxis() received an unsupported tensor rank: ${n.rank}`)}})}function ED(n,t=-1){let e;return t<0&&(e=n[0].rank,t=0!==e?e:0),t===n[0].rank&&(t=-1),Ur(n,t)}function u4(n,t){switch(n.rank){case 1:return wB([n,t]);case 2:return TB([n,t],0);case 3:return SB([n,t],0);case 4:return CB([n,t],0);default:throw new ye(`concatAlongFirstAxis() received an unsupported tensor rank: ${n.rank}`)}}function DD(n,t){if(Array.isArray(t)||(t=[t]),n.rank!==t.length)throw new ye(`The length of input n (${t.length}) does not match the number of dimensions in input x (${n.rank})`);return Fs(n,t)}function Dv(n,t=0,e=1,r,i){return CE(n,t,e,r,i)}function ja(n,t,e,r){if(n.rank<2||t.rank<2)throw new en(`dot requires both inputs to be rank >= 2 but got x shape = ${n.shape} and y shape = ${t.shape}`);if(t.rank>=3&&n.shape.slice(-1)[0]!==t.shape.slice(-2)[0])throw new en(`If rank y >= 3, then the second last dim of y must equal the last dim of x but got x shape = ${n.shape} and  y shape = ${t.shape}`);if(2===n.rank&&2===t.rank)return WE({a:n,b:t,transposeA:!1,transposeB:!1,bias:r?kD(n.rank,r,"channelsLast"):null,activation:e});{const i=n.shape.slice(),o=i.pop();n=be(n,[-1,o]);const s=t.shape.slice(),a=s.pop(),c=s.pop(),u=[...s,a],p=Array.from({length:t.rank},(x,T)=>0===T?t.rank-2:T<=t.rank-2?T-1:T);t=be(wn(t,p),[c,-1]);const m=[...i,...u];return be(WE({a:n,b:t,transposeA:!1,transposeB:!1,bias:r?kD(n.rank,r,"channelsLast"):null,activation:e}),m)}}function d4(n,t,e){return Se(()=>(t=Array.isArray(t)?So(t,"int32"):ht(t,"int32"),mg(n,t,e)))}function Ig(n){return fe(n,n)}function kD(n,t,e){const r=t.shape;if(1!==t.rank&&t.rank!==n)throw new ye(`Unexpected bias dimensions: ${t.rank}; expected it to be 1 or ${n}`);if(5===n){if("channelsFirst"===e)return be(t,1===r.length?[1,r[0],1,1,1]:[1,r[3],r[0],r[1],r[2]]);if("channelsLast"===e)return be(t,1===r.length?[1,1,1,1,r[0]]:[1].concat(r))}else if(4===n){if("channelsFirst"===e)return be(t,1===r.length?[1,r[0],1,1]:[1,r[2],r[0],r[1]]);if("channelsLast"===e)return be(t,1===r.length?[1,1,1,r[0]]:[1].concat(r))}else if(3===n){if("channelsFirst"===e)return be(t,1===r.length?[1,r[0],1]:[1,r[1],r[0]]);if("channelsLast"===e)return be(t,1===r.length?[1,1,r[0]]:[1].concat(r))}else if(n<3)return t;throw new ye(`Unsupported input rank by biasAdd: ${t.rank}`)}function da(n,t,e){return Se(()=>(null==e&&(e="channelsLast"),Fr(e),Xe(n,kD(n.rank,t,e))))}function h4(n,t,e,r){return Se(()=>iV(n,t,e,r))}function Eg(n,t,e=!1){return e?n():t()}const Rpe=["fanIn","fanOut","fanAvg"],Mpe=["normal","uniform","truncatedNormal"];class Vs extends kh{fromConfigUsesCustomObjects(){return!1}getConfig(){return{}}}Ye((()=>{class n extends Vs{apply(e,r){return ni(e,r)}}return n.className="Zeros",n})());let p4=(()=>{class n extends Vs{apply(e,r){return us(e,r)}}return n.className="Ones",n})();Ye(p4),Ye((()=>{class n extends Vs{constructor(e){if(super(),"object"!=typeof e)throw new ye(`Expected argument of type ConstantConfig but got ${e}`);if(void 0===e.value)throw new ye(`config must have value set but got ${e}`);this.value=e.value}apply(e,r){return Se(()=>fe(Ft(this.value),us(e,r)))}getConfig(){return{value:this.value}}}return n.className="Constant",n})()),Ye((()=>{class n extends Vs{constructor(e){super(),this.DEFAULT_MINVAL=-.05,this.DEFAULT_MAXVAL=.05,this.minval=e.minval||this.DEFAULT_MINVAL,this.maxval=e.maxval||this.DEFAULT_MAXVAL,this.seed=e.seed}apply(e,r){return Pu(e,this.minval,this.maxval,r,this.seed)}getConfig(){return{minval:this.minval,maxval:this.maxval,seed:this.seed}}}return n.className="RandomUniform",n})()),Ye((()=>{class n extends Vs{constructor(e){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,r){if("float32"!==(r=r||"float32")&&"int32"!==r)throw new en(`randomNormal does not support dType ${r}.`);return Dv(e,this.mean,this.stddev,r,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}return n.className="RandomNormal",n})()),Ye((()=>{class n extends Vs{constructor(e){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,r){if("float32"!==(r=r||"float32")&&"int32"!==r)throw new en(`truncatedNormal does not support dType ${r}.`);return LE(e,this.mean,this.stddev,r,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}return n.className="TruncatedNormal",n})()),Ye((()=>{class n extends Vs{constructor(e){super(),this.gain=null!=e.gain?e.gain:1}apply(e,r){return Se(()=>{if(2!==e.length||e[0]!==e[1])throw new ye("Identity matrix initializer can only be used for 2D square matrices.");return fe(this.gain,bE(e[0]))})}getConfig(){return{gain:this.gain}}}return n.className="Identity",n})());let ms=(()=>{class n extends Vs{constructor(e){if(super(),e.scale<0)throw new ye(`scale must be a positive float. Got: ${e.scale}`);this.scale=null==e.scale?1:e.scale,this.mode=null==e.mode?"fanIn":e.mode,function Fpe(n){zu(Rpe,"FanMode",n)}(this.mode),this.distribution=null==e.distribution?"normal":e.distribution,function Ppe(n){zu(Mpe,"Distribution",n)}(this.distribution),this.seed=e.seed}apply(e,r){const i=function $pe(n,t="channelsLast"){let e,r;if(Fr(t),2===n.length)e=n[0],r=n[1];else if(-1!==[3,4,5].indexOf(n.length)){if("channelsFirst"===t){const i=Dc(n,2);e=n[1]*i,r=n[0]*i}else if("channelsLast"===t){const i=Dc(n,0,n.length-2);e=n[n.length-2]*i,r=n[n.length-1]*i}}else{const i=Dc(n);e=Math.sqrt(i),r=Math.sqrt(i)}return[e,r]}(e),o=i[0],s=i[1];let a=this.scale;if(a/="fanIn"===this.mode?Math.max(1,o):"fanOut"===this.mode?Math.max(1,s):Math.max(1,(o+s)/2),"normal"===this.distribution){const c=Math.sqrt(a);if("float32"!==(r=r||"float32")&&"int32"!==r)throw new en(`${this.getClassName()} does not support dType ${r}.`);return LE(e,0,c,r,this.seed)}{const c=Math.sqrt(3*a);return Pu(e,-c,c,r,this.seed)}}getConfig(){return{scale:this.scale,mode:this.mode,distribution:this.distribution,seed:this.seed}}}return n.className="VarianceScaling",n})();Ye(ms);let f4=(()=>{class n extends ms{constructor(e){super({scale:1,mode:"fanAvg",distribution:"uniform",seed:null==e?null:e.seed})}getClassName(){return ms.className}}return n.className="GlorotUniform",n})();Ye(f4);let m4=(()=>{class n extends ms{constructor(e){super({scale:1,mode:"fanAvg",distribution:"normal",seed:null==e?null:e.seed})}getClassName(){return ms.className}}return n.className="GlorotNormal",n})();Ye(m4);let g4=(()=>{class n extends ms{constructor(e){super({scale:2,mode:"fanIn",distribution:"normal",seed:null==e?null:e.seed})}getClassName(){return ms.className}}return n.className="HeNormal",n})();Ye(g4);let b4=(()=>{class n extends ms{constructor(e){super({scale:2,mode:"fanIn",distribution:"uniform",seed:null==e?null:e.seed})}getClassName(){return ms.className}}return n.className="HeUniform",n})();Ye(b4);let y4=(()=>{class n extends ms{constructor(e){super({scale:1,mode:"fanIn",distribution:"normal",seed:null==e?null:e.seed})}getClassName(){return ms.className}}return n.className="LeCunNormal",n})();Ye(y4);let _4=(()=>{class n extends ms{constructor(e){super({scale:1,mode:"fanIn",distribution:"uniform",seed:null==e?null:e.seed})}getClassName(){return ms.className}}return n.className="LeCunUniform",n})();Ye(_4),Ye((()=>{class n extends Vs{constructor(e){super(),this.DEFAULT_GAIN=1,this.ELEMENTS_WARN_SLOW=2e3,this.gain=null==e.gain?this.DEFAULT_GAIN:e.gain,this.seed=e.seed}apply(e,r){return Se(()=>{if(e.length<2)throw new en("Shape must be at least 2D.");if("int32"!==r&&"float32"!==r&&void 0!==r)throw new TypeError(`Unsupported data type ${r}.`);const i=Me(e.slice(0,-1)),o=e[e.length-1],s=i*o;s>this.ELEMENTS_WARN_SLOW&&console.warn(`Orthogonal initializer is being called on a matrix with more than ${this.ELEMENTS_WARN_SLOW} (${s}) elements: Slowness may result.`);const c=Dv([Math.max(o,i),Math.min(o,i)],0,1,r,this.seed),u=mV.qr(c,!1);let p=u[0];const g=u[1].flatten().stridedSlice([0],[Math.min(o,i)*Math.min(o,i)],[Math.min(o,i)+1]);return p=fe(p,g.sign()),i<o&&(p=p.transpose()),fe(Ft(this.gain),p.reshape(e))})}getConfig(){return{gain:this.gain,seed:this.seed}}}return n.className="Orthogonal",n})());const v4={constant:"Constant",glorotNormal:"GlorotNormal",glorotUniform:"GlorotUniform",heNormal:"HeNormal",heUniform:"HeUniform",identity:"Identity",leCunNormal:"LeCunNormal",leCunUniform:"LeCunUniform",ones:"Ones",orthogonal:"Orthogonal",randomNormal:"RandomNormal",randomUniform:"RandomUniform",truncatedNormal:"TruncatedNormal",varianceScaling:"VarianceScaling",zeros:"Zeros"};function x4(n,t={}){return Tg(n,Os.getMap().classNameMap,t,"initializer")}function mr(n){return TD(n)}function ar(n){if("string"==typeof n){const t=n in v4?v4[n]:n;if("GlorotNormal"===t)return new m4;if("GlorotUniform"===t)return new f4;if("HeNormal"===t)return new g4;if("HeUniform"===t)return new b4;if("LeCunNormal"===t)return new y4;if("LeCunUniform"===t)return new _4;{const e={};return e.className=t,e.config={},x4(e)}}return n instanceof Vs?n:x4(n)}function AD(n){return Array.isArray(n)&&Array.isArray(n[0])}function kv(n){return 0===n.length?[]:Array.isArray(n[0])?n:[n]}function zt(n){let t;if(Array.isArray(n)){if(1!==n.length)throw new ye(`Expected Tensor length to be 1; got ${n.length}`);t=n[0]}else t=n;return t}function Dn(n){if(Array.isArray(n)&&Array.isArray(n[0])){if(1===n.length)return n[0];throw new ye(`Expected exactly 1 Shape; got ${n.length}`)}return n}function Av(n){let t=0;for(const e of n)t+=0===e.shape.length?1:e.shape.reduce((r,i)=>r*i);return t}const w4="Variable";class Ga{constructor(t,e="float32",r=w4,i=!0,o=null){this.dtype=e??"float32",this.shape=t.shape,this.id=n4(),this.originalName=s4(r=r??w4),this.name=a4(this.originalName),this.trainable_=i,this.constraint=o,this.val=nV(t,this.trainable_,this.name,this.dtype)}read(){return this.assertNotDisposed(),this.val}write(t){return this.assertNotDisposed(),function Lpe(n,t){if(n.shape.toString()!==t.shape.toString())throw new Error("Shape mismatch: "+JSON.stringify(n.shape)+" vs. "+JSON.stringify(t.shape))}(this.val,t),this.val.id!==t.id&&(this.val.assign(t),null!=this.constraint&&this.val.assign(this.constraint.apply(this.val))),this}dispose(){this.assertNotDisposed(),this.val.dispose()}assertNotDisposed(){if(this.val.isDisposed)throw new Error(`LayersVariable ${this.name} is already disposed.`)}get trainable(){return this.trainable_}set trainable(t){this.trainable_=t,this.val.trainable=t}}function ND(n){return n.map(t=>t.read())}function OD(n){n.forEach(t=>{t[0].write(t[1])})}class ii{constructor(t){this.dtype=t.dtype,this.shape=t.shape,this.ndim=null!=t.shape?t.shape.length:t.ndim,this.maxNDim=t.maxNDim,this.minNDim=t.minNDim,this.axes=t.axes||{}}}class Ha{constructor(t,e,r,i,o,s,a){this.dtype=t,this.shape=e,this.sourceLayer=r,this.inputs=i,this.callArgs=o,this.outputTensorIndex=a,this.id=n4(),null!=s&&(this.originalName=s4(s),this.name=a4(this.originalName)),this.rank=e.length}}let Bpe=0;class Nv{constructor(t,e){this.callArgs=e,this.id=Bpe++,this.outboundLayer=t.outboundLayer,this.inboundLayers=t.inboundLayers,this.nodeIndices=t.nodeIndices,this.tensorIndices=t.tensorIndices,this.inputTensors=t.inputTensors,this.outputTensors=t.outputTensors,this.inputMasks=t.inputMasks,this.outputMasks=t.outputMasks,this.inputShapes=t.inputShapes,this.outputShapes=t.outputShapes;for(const r of t.inboundLayers)r?.outboundNodes.push(this);t.outboundLayer.inboundNodes.push(this)}getConfig(){const t=[];for(const e of this.inboundLayers)t.push(null!=e?e.name:null);return{outboundLayer:this.outboundLayer?this.outboundLayer.name:null,inboundLayers:t,nodeIndices:this.nodeIndices,tensorIndices:this.tensorIndices}}}let Vpe=0;class dn extends kh{constructor(t={}){super(),this._callHook=null,this._addedWeightNames=[],this._stateful=!1,this.id=Vpe++,this.activityRegularizer=null,this.inputSpec=null,this.supportsMasking=!1,this._trainableWeights=[],this._nonTrainableWeights=[],this._losses=[],this._updates=[],this._built=!1,this.inboundNodes=[],this.outboundNodes=[];let e=t.name;if(!e){const r=this.getClassName();e=El(r)+"_"+Cv(r)}if(this.name=e,this.trainable_=null==t.trainable||t.trainable,null!=t.inputShape||null!=t.batchInputShape){let r;if(null!=t.batchInputShape)r=t.batchInputShape;else if(null!=t.inputShape){let o=null;null!=t.batchSize&&(o=t.batchSize),r=[o].concat(t.inputShape)}this.batchInputShape=r;let i=t.dtype;null==i&&(i=t.inputDType),null==i&&(i="float32"),this.dtype=i}this.initialWeights=null!=t.weights?t.weights:null,this._refCount=null,this.fastWeightInitDuringBuild=!1}static nodeKey(t,e){return t.name+"_ib-"+e.toString()}getNodeAtIndex(t,e){if(0===this.inboundNodes.length)throw new Ls(`The layer has never been called and thus has no defined ${e}.`);if(this.inboundNodes.length<=t)throw new ye(`Asked to get ${e} at node ${t}, but the layer has only ${this.inboundNodes.length} inbound nodes.`);return this.inboundNodes[t]}getInputAt(t){return Co(this.getNodeAtIndex(t,"input").inputTensors)}getOutputAt(t){return Co(this.getNodeAtIndex(t,"output").outputTensors)}get input(){if(this.inboundNodes.length>1)throw new za(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer input" is ill-defined. Use \`getInputAt(nodeIndex)\` instead.`);if(0===this.inboundNodes.length)throw new za(`Layer ${this.name} is not connected, no input to return.`);return Co(this.getNodeAtIndex(0,"input").inputTensors)}get output(){if(0===this.inboundNodes.length)throw new za(`Layer ${this.name} has no inbound nodes.`);if(this.inboundNodes.length>1)throw new za(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer output" is ill-defined. Use \`getOutputAt(nodeIndex)\` instead.`);return Co(this.getNodeAtIndex(0,"output").outputTensors)}get losses(){return this._losses}calculateLosses(){return this.losses.map(t=>t())}get updates(){return this._updates}get built(){return this._built}set built(t){this._built=t}get trainable(){return this.trainable_}set trainable(t){this._trainableWeights.forEach(e=>e.trainable=t),this.trainable_=t}get trainableWeights(){return this.trainable_?this._trainableWeights.filter(t=>t.trainable):[]}set trainableWeights(t){this._trainableWeights=t}get nonTrainableWeights(){return this.trainable?this._trainableWeights.filter(t=>!t.trainable).concat(this._nonTrainableWeights):this._trainableWeights.concat(this._nonTrainableWeights)}set nonTrainableWeights(t){this._nonTrainableWeights=t}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}get stateful(){return this._stateful}resetStates(){if(!this.stateful)throw new Error("Cannot call the resetStates() method of a non-stateful Layer object.")}assertInputCompatibility(t){if(t=Xn(t),null==this.inputSpec||0===this.inputSpec.length)return;const e=Xn(this.inputSpec);if(t.length!==e.length)throw new ye(`Layer ${this.name} expects ${e.length} inputs, but it received ${t.length} input tensors. Input received: ${t}`);for(let r=0;r<t.length;r++){const i=t[r],o=e[r];if(null==o)continue;const s=i.rank;if(null!=o.ndim&&s!==o.ndim)throw new ye(`Input ${r} is incompatible with layer ${this.name}: expected ndim=${o.ndim}, found ndim=${s}`);if(null!=o.maxNDim&&s>o.maxNDim)throw new ye(`Input ${r} is incompatible with layer ${this.name}: expected max_ndim=${o.maxNDim}, found ndim=${s}`);if(null!=o.minNDim&&s<o.minNDim)throw new ye(`Input ${r} is incompatible with layer ${this.name}: expected min_ndim=${o.minNDim}, found ndim=${s}.`);if(null!=o.dtype&&i.dtype!==o.dtype)throw new ye(`Input ${r} is incompatible with layer ${this.name} : expected dtype=${o.dtype}, found dtype=${i.dtype}.`);if(o.axes){const a=i.shape;for(const c in o.axes){const u=Number(c),p=o.axes[c];if(null!=p&&-1===[p,null].indexOf(u>=0?a[u]:a[a.length+u]))throw new ye(`Input ${r} is incompatible with layer ${this.name}: expected axis ${u} of input shape to have value ${p} but got shape ${a}.`)}}if(null!=o.shape)for(let a=0;a<o.shape.length;++a){const c=o.shape[a],u=i.shape[a];if(null!=c&&null!=u&&c!==u)throw new ye(`Input ${r} is incompatible with layer ${this.name}: expected shape=${o.shape}, found shape=${i.shape}.`)}}}call(t,e){return t}invokeCallHook(t,e){null!=this._callHook&&this._callHook(t,e)}setCallHook(t){this._callHook=t}clearCallHook(){this._callHook=null}apply(t,e){e=e||{},this.assertNotDisposed();const r=Xn(t);let i=!0;for(const s of r)if(!(s instanceof Ha)){i=!1;break}let o=!0;for(const s of r)if(s instanceof Ha){o=!1;break}if(i===o)throw new ye("Arguments to apply() must be all SymbolicTensors or all Tensors");return Uu(this.name,()=>{if(!this.built){this.assertInputCompatibility(t);const s=[];for(const a of Xn(t))s.push(a.shape);this.build(Co(s)),this.built=!0,this.initialWeights&&this.setWeights(this.initialWeights),null===this._refCount&&o&&(this._refCount=1)}if(this.assertInputCompatibility(t),o){let s=this.call(t,e);const a=Xn(s),c=[];for(let u of a)-1!==r.indexOf(u)&&(u=u.clone()),c.push(u);if(s=Co(c),null!=this.activityRegularizer)throw new en("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return s}{const s=function zpe(n){n=Xn(n);const t=[];for(const e of n)t.push(e.shape);return Co(t)}(t),a=this.computeOutputShape(s);let c;const u="float32";if(this.warnOnIncompatibleInputShape(Array.isArray(t)?s[0]:s),c=null!=a&&a.length>0&&Array.isArray(a[0])?a.map((p,m)=>new Ha(u,p,this,Xn(t),e,this.name,m)):new Ha(u,a,this,Xn(t),e,this.name),this.addInboundNode(t,c,null,null,s,a,e),this._refCount++,null!=this.activityRegularizer)throw new en("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return c}})}warnOnIncompatibleInputShape(t){if(null!=this.batchInputShape)if(t.length!==this.batchInputShape.length)console.warn(`The rank of the input tensor provided (shape: ${JSON.stringify(t)}) does not match that of the batchInputShape (${JSON.stringify(this.batchInputShape)}) of the layer ${this.name}`);else{let e=!1;this.batchInputShape.forEach((r,i)=>{null!=r&&null!=t[i]&&t[i]!==r&&(e=!0)}),e&&console.warn(`The shape of the input tensor (${JSON.stringify(t)}) does not match the expectation of layer ${this.name}: ${JSON.stringify(this.batchInputShape)}`)}}get outputShape(){if(null==this.inboundNodes||0===this.inboundNodes.length)throw new za(`The layer ${this.name} has never been called and thus has no defined output shape.`);const t=[];for(const e of this.inboundNodes){const r=JSON.stringify(e.outputShapes);-1===t.indexOf(r)&&t.push(r)}if(1===t.length){const e=this.inboundNodes[0].outputShapes;return Array.isArray(e)&&Array.isArray(e[0])&&1===e.length?e[0]:e}throw new za(`The layer ${this.name} has multiple inbound nodes with different output shapes. Hence the notion of "output shape" is ill-defined for the layer.`)}countParams(){if(!this.built)throw new Ls(`You tried to call countParams() on ${this.name}, but the layer is not built yet. Build it first by calling build(batchInputShape).`);return Av(this.weights)}build(t){this.built=!0}getWeights(t=!1){return ND(t?this.trainableWeights:this.weights)}setWeights(t){Se(()=>{const e=this.weights;if(e.length!==t.length)throw new ye(`You called setWeights(weights) on layer "${this.name}" with a weight list of length ${t.length}, but the layer was expecting ${e.length} weights. Provided weights: ${t}...`);if(0===e.length)return;const r=[],i=ND(e);for(let o=0;o<i.length;++o){const s=i[o],a=e[o],c=t[o];if(!mn(s.shape,c.shape))throw new ye(`Layer weight shape ${s.shape} not compatible with provided weight shape ${c.shape}`);r.push([a,c])}OD(r)})}addWeight(t,e,r,i,o,s,a,c){if(-1!==this._addedWeightNames.indexOf(t))throw new ye(`Duplicate weight name ${t} for layer ${this.name}`);this._addedWeightNames.push(t),null==r&&(r="float32"),this.fastWeightInitDuringBuild&&(i=null!=c?c():ar("zeros"));const u=i.apply(e,r),p=new Ga(u,r,t,s,a);return u.dispose(),null!=o&&this.addLoss(()=>o.apply(p.read())),null==s&&(s=!0),s?this._trainableWeights.push(p):this._nonTrainableWeights.push(p),p}setFastWeightInitDuringBuild(t){this.fastWeightInitDuringBuild=t}addLoss(t){null==t||Array.isArray(t)&&0===t.length||(t=Xn(t),null!=this._losses&&this.losses.push(...t))}computeOutputShape(t){return t}computeMask(t,e){if(!this.supportsMasking){if(null!=e){if(!Array.isArray(e))throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`);e.forEach(r=>{if(null!=r)throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`)})}return null}return e}addInboundNode(t,e,r,i,o,s,a=null){const c=Xn(t);e=Xn(e),r=Xn(r),i=Xn(i),o=kv(o),s=kv(s);const u=[],p=[],m=[];for(const g of c)u.push(g.sourceLayer),p.push(g.nodeIndex),m.push(g.tensorIndex);new Nv({outboundLayer:this,inboundLayers:u,nodeIndices:p,tensorIndices:m,inputTensors:c,outputTensors:e,inputMasks:r,outputMasks:i,inputShapes:o,outputShapes:s},a);for(let g=0;g<e.length;g++)e[g].sourceLayer=this,e[g].nodeIndex=this.inboundNodes.length-1,e[g].tensorIndex=g}getConfig(){const t={name:this.name,trainable:this.trainable};return null!=this.batchInputShape&&(t.batchInputShape=this.batchInputShape),null!=this.dtype&&(t.dtype=this.dtype),t}disposeWeights(){return this.weights.forEach(t=>t.dispose()),this.weights.length}assertNotDisposed(){if(0===this._refCount)throw new Error(`Layer '${this.name}' is already disposed.`)}dispose(){if(!this.built)throw new Error(`Cannot dispose Layer ${this.name} because it has not been built yet.`);if(null===this._refCount)throw new Error(`Cannot dispose Layer ${this.name} because it has not been used yet.`);this.assertNotDisposed();let t=0;return 0==--this._refCount&&(t=this.disposeWeights()),{refCountAfterDispose:this._refCount,numDisposedVariables:t}}}function T4(n,t,e){if((null==t||null!=e&&e>0)&&(t=n.sourceLayer,e=n.nodeIndex),0===t.inboundNodes.length)return[n];{const r=t.inboundNodes[e];if(0===r.inboundLayers.length)return r.inputTensors;{const i=[];for(let o=0;o<r.inboundLayers.length;o++){const u=T4(r.inputTensors[o],r.inboundLayers[o],r.nodeIndices[o]);for(const p of u)-1===i.indexOf(p)&&i.push(p)}return i}}}let Ov=(()=>{class n extends dn{constructor(e){if(super({dtype:e.dtype,name:null!=e.name?e.name:Cv("input").toString()}),null==e.batchSize&&(e.batchSize=null),null==e.sparse&&(e.sparse=!1),this.trainable=!1,this.built=!0,this.sparse=e.sparse,null!=e.inputShape&&null!=e.batchInputShape)throw new ye("Only provide the inputShape OR batchInputShape argument to inputLayer, not both at the same time.");let r=e.batchInputShape;if(null==r){if(null==e.inputShape)throw new ye("An InputLayer should be passed either a `batchInputShape` or an `inputShape`.");r=[e.batchSize].concat(e.inputShape)}else if(null!=e.batchSize)throw new ye("Cannot specify batchSize if batchInputShape is specified when creating an InputLayer.");const i=e.dtype||"float32";this.batchInputShape=r,this.dtype=i,this.inputSpec=[{shape:r}];const o=new Ha(this.dtype,this.batchInputShape,this,[],{},this.name);o.nodeIndex=0,o.tensorIndex=0,new Nv({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:[o],outputTensors:[o],inputMasks:[null],outputMasks:[null],inputShapes:[r],outputShapes:[r]})}apply(e,r){throw new ye(`Cannot pass any input to an InputLayer's apply() method. InputLayer name: ${this.name}`)}dispose(){return{refCountAfterDispose:this._refCount,numDisposedVariables:0}}getConfig(){return{batchInputShape:this.batchInputShape,dtype:this.dtype,sparse:this.sparse,name:this.name}}}return n.className="InputLayer",n})();Ye(Ov);class Ac{constructor(t){if(this.id2Value={},this.id2Mask={},this.name2Id={},t instanceof Ac)for(const e in t.id2Value)this.id2Value[e]=t.id2Value[e],e in t.id2Mask&&(this.id2Mask[e]=t.id2Mask[e]);else{if(null==t)return;for(const e of t)this.add(e.key,e.value)}}add(t,e,r){if(null!=this.id2Value[t.id])throw new ye(`Duplicate key: name=${t.name}, id=${t.id}`);return this.id2Value[t.id]=function Gpe(n,t){if(null==n.dtype||n.dtype===t.dtype)return t;try{return ht(t,n.dtype)}catch{throw new ye(`The dtype of the feed (${t.dtype}) can not be cast to the dtype of the key '${n.name}' (${n.dtype}).`)}}(t,e),this.name2Id[t.name]=t.id,null!=r&&(this.id2Mask[t.id]=r),this}addFeed(t){this.add(t.key,t.value)}hasKey(t){return null!=this.id2Value[t.id]}names(){return Object.keys(this.name2Id)}getValue(t){if(t instanceof Ha){if(null==this.id2Value[t.id])throw new ye(`Nonexistent key: ${t.name}`);return this.id2Value[t.id]}{const e=this.name2Id[t];if(null==e)throw new ye(`Feed dict has no SymbolicTensor name: ${t}`);return this.id2Value[e]}}getMask(t){if(t instanceof Ha){if(null==this.id2Value[t.id])throw new ye(`Nonexistent key: ${t.name}`);return this.id2Mask[t.id]}{const e=this.name2Id[t];if(null==e)throw new ye(`Feed dict has no SymbolicTensor name: ${t}`);return this.id2Mask[e]}}disposeMasks(){null!=this.id2Mask&&un(this.id2Mask)}}const Rv=new QV,Mv=new QV;function Dg(n,t,e,r){const i=null!=e&&e.training,o=Array.isArray(n),s=o?n:[n],a=s.map(x=>x.name),c=[],u=t.names();for(const x of a)-1!==u.indexOf(x)?c.push(t.getValue(x)):c.push(null);null!=r&&(r.maxNumTensors=-1/0,r.minNumTensors=1/0);const p=a.join(",")+"|"+t.names().sort().join(",");let g,m=Rv.get(p);if(null==m){const x=function Wpe(n,t){Z(null!=n&&n.length>0,()=>"Expected at least one fetch, got none");let e=[],r={};if(1===n.length){const i=S4(n[0],t);e=i.sorted,r=i.recipientMap}else{const i=new Set;for(const o of n){const{sorted:s,recipientMap:a}=S4(o,t);for(const c of s)i.has(c.name)||(e.push(c),i.add(c.name));for(const c in a)null==r[c]&&(r[c]=new Set),a[c].forEach(u=>r[c].add(u))}}return{sorted:e,recipientCounts:qpe(r)}}(s,t);m=x.sorted,g=x.recipientCounts,Rv.put(p,m),Mv.put(p,g)}g={},i||Object.assign(g,Mv.get(p));const _=new Ac(t);for(let x=0;x<m.length;++x){if(null!=r){const ce=WI().numTensors;ce>r.maxNumTensors&&(r.maxNumTensors=ce),ce<r.minNumTensors&&(r.minNumTensors=ce)}const T=m[x],I=T.sourceLayer;if(I instanceof Ov)continue;const N=[],R=[],L=[];let V=!1;for(const ce of T.inputs){const he=_.getValue(ce),we=_.getMask(ce);N.push(he),R.push(we),null!=we&&(V=!0),i||(g[ce.name]--,0===g[ce.name]&&!t.hasKey(ce)&&-1===a.indexOf(ce.name)&&!he.isDisposed&&!0!==ce.sourceLayer.stateful&&L.push(he))}V&&((e=e||{}).mask=R[0]);const j=Xn(I.apply(N,e));let Y=null;I.supportsMasking&&(Y=I.computeMask(N,R));const ee=Kpe(T),ie=Array.isArray(ee)?ee:[ee];for(let ce=0;ce<ie.length;++ce){_.hasKey(ie[ce])||_.add(ie[ce],j[ce],Array.isArray(Y)?Y[0]:Y);const he=a.indexOf(ie[ce].name);-1!==he&&(c[he]=j[ce])}i||un(L)}return _.disposeMasks(),o?c:c[0]}function qpe(n){const t={};for(const e in n)t[e]=n[e].size;return t}function S4(n,t){const e=new Set,r=[],i={};for(const a of t.names())e.add(a);const o=[],s=[];for(o.push(n);o.length>0;){const a=o[o.length-1];if(e.has(a.name)){o.pop();continue}const c=s[s.length-1]===o.length-1;if(0===a.inputs.length||c)o.pop(),r.push(a),e.add(a.name),c&&s.pop();else{s.push(o.length-1);for(const u of a.inputs)null==i[u.name]&&(i[u.name]=new Set),i[u.name].add(a.name),!e.has(u.name)&&o.push(u)}}return{sorted:r,recipientMap:i}}function Kpe(n){let t;if(1===n.sourceLayer.inboundNodes.length)t=n.sourceLayer.output;else{let e=null;for(let r=0;r<n.sourceLayer.inboundNodes.length;++r)for(const i of n.sourceLayer.inboundNodes[r].outputTensors)if(i.id===n.id){e=r;break}t=n.sourceLayer.getOutputAt(e)}return t}function RD(n,t){return Se(()=>ji(St(fe(n,n),t,!0)))}Ie().registerFlag("TOPOLOGICAL_SORT_CACHE_MAX_ENTRIES",()=>100,function Hpe(n){Rv?.setMaxEntries(n),Mv?.setMaxEntries(n)});class kg extends kh{getConfig(){return{}}}Ye((()=>{class n extends kg{constructor(e){super(),this.defaultMaxValue=2,this.defaultAxis=0,this.maxValue=null!=e.maxValue?e.maxValue:this.defaultMaxValue,this.axis=null!=e.axis?e.axis:this.defaultAxis}apply(e){return Se(()=>{const r=RD(e,this.axis),i=Uo(r,0,this.maxValue);return fe(e,Nt(i,Xe(ri(),r)))})}getConfig(){return{maxValue:this.maxValue,axis:this.axis}}}return n.className="MaxNorm",n})()),Ye((()=>{class n extends kg{constructor(e){super(),this.defaultAxis=0,this.axis=null!=e.axis?e.axis:this.defaultAxis}apply(e){return Se(()=>Nt(e,Xe(ri(),RD(e,this.axis))))}getConfig(){return{axis:this.axis}}}return n.className="UnitNorm",n})()),Ye((()=>{class n extends kg{apply(e){return La(e)}}return n.className="NonNeg",n})()),Ye((()=>{class n extends kg{constructor(e){super(),this.defaultMinValue=0,this.defaultMaxValue=1,this.defaultRate=1,this.defaultAxis=0,this.minValue=null!=e.minValue?e.minValue:this.defaultMinValue,this.maxValue=null!=e.maxValue?e.maxValue:this.defaultMaxValue,this.rate=null!=e.rate?e.rate:this.defaultRate,this.axis=null!=e.axis?e.axis:this.defaultAxis}apply(e){return Se(()=>{const r=RD(e,this.axis),i=Xe(fe(this.rate,Uo(r,this.minValue,this.maxValue)),fe(1-this.rate,r));return fe(e,Nt(i,Xe(ri(),r)))})}getConfig(){return{minValue:this.minValue,maxValue:this.maxValue,rate:this.rate,axis:this.axis}}}return n.className="MinMaxNorm",n})());const C4={maxNorm:"MaxNorm",minMaxNorm:"MinMaxNorm",nonNeg:"NonNeg",unitNorm:"UnitNorm"};function oi(n){return TD(n)}function I4(n,t={}){return Tg(n,Os.getMap().classNameMap,t,"constraint")}function si(n){return null==n?null:"string"==typeof n?I4({className:n in C4?C4[n]:n,config:{}}):n instanceof kg?n:I4(n)}function Nc(n){return MD.apply(this,arguments)}function MD(){return(MD=$e(function*(n){if(null==n)return;const t=[],e=[],r=[];for(const i in n){const o=n[i];if("number"!=typeof o){const s=o;t.push(s.data()),e.push(i),r.push(s)}}if(t.length>0){const i=yield Promise.all(t);for(let o=0;o<i.length;++o)n[e[o]]=i[o][0];un(r)}})).apply(this,arguments)}function E4(n){if(null!=n)for(const t in n){const e=n[t];"number"!=typeof e&&e.dispose()}}class Hh{constructor(){this.validationData=null}setParams(t){this.params=t}onEpochBegin(t,e){return $e(function*(){})()}onEpochEnd(t,e){return $e(function*(){})()}onBatchBegin(t,e){return $e(function*(){})()}onBatchEnd(t,e){return $e(function*(){})()}onTrainBegin(t){return $e(function*(){})()}onTrainEnd(t){return $e(function*(){})()}setModel(t){}}class Ype{constructor(t,e=10){null==t&&(t=[]),this.callbacks=t,this.queueLength=e}append(t){this.callbacks.push(t)}setParams(t){for(const e of this.callbacks)e.setParams(t)}setModel(t){for(const e of this.callbacks)e.setModel(t)}onEpochBegin(t,e){var r=this;return $e(function*(){null==e&&(e={});for(const i of r.callbacks)yield i.onEpochBegin(t,e)})()}onEpochEnd(t,e){var r=this;return $e(function*(){null==e&&(e={});for(const i of r.callbacks)yield i.onEpochEnd(t,e)})()}onBatchBegin(t,e){var r=this;return $e(function*(){null==e&&(e={});for(const i of r.callbacks)yield i.onBatchBegin(t,e)})()}onBatchEnd(t,e){var r=this;return $e(function*(){null==e&&(e={});for(const i of r.callbacks)yield i.onBatchEnd(t,e)})()}onTrainBegin(t){var e=this;return $e(function*(){null==t&&(t={});for(const r of e.callbacks)yield r.onTrainBegin(t)})()}onTrainEnd(t){var e=this;return $e(function*(){null==t&&(t={});for(const r of e.callbacks)yield r.onTrainEnd(t)})()}}class Zpe extends Hh{constructor(){super()}onEpochBegin(t){var e=this;return $e(function*(){e.seen=0,e.totals={}})()}onBatchEnd(t,e){var r=this;return $e(function*(){null==e&&(e={});const i=null==e.size?0:e.size;r.seen+=i;for(const o in e){const s=e[o];if("number"==typeof s)r.totals.hasOwnProperty(o)||(r.totals[o]=0),r.totals[o]=r.totals[o]+s*i;else{let a;o in r.totals?a=r.totals[o]:r.totals[o]=0;const c=Se(()=>Xe(r.totals[o],fe(s,i)));r.totals[o]=c,a?.dispose()}}})()}onEpochEnd(t,e){var r=this;return $e(function*(){if(null!=e)for(const i of r.params.metrics)null!=r.totals[i]&&("number"==typeof r.totals[i]?e[i]=r.totals[i]/r.seen:Se(()=>{const o=fe(Nt(1,r.seen),r.totals[i]);e[i]=o,r.totals[i].dispose(),fi(e[i])}))})()}}class Qpe extends Hh{onTrainBegin(t){var e=this;return $e(function*(){e.epoch=[],e.history={}})()}onEpochEnd(t,e){var r=this;return $e(function*(){null==e&&(e={}),r.epoch.push(t);for(const i in e)null==r.history[i]&&(r.history[i]=[]),r.history[i].push(e[i])})()}syncData(){var t=this;return $e(function*(){const e=[],r=[],i=[];for(const s in t.history){const a=t.history[s];for(let c=0;c<a.length;++c)"number"!=typeof a[c]&&(e.push(a[c].data()),r.push(s),i.push(c))}const o=yield Promise.all(e);for(let s=0;s<o.length;++s)t.history[r[s]][i[s]].dispose(),t.history[r[s]][i[s]]=o[s][0]})()}}class Jpe extends Hh{constructor(t,e){if(super(),this.currentEpoch=0,this.nowFunc=t.nowFunc,this.nextFrameFunc=t.nextFrameFunc||gV,this.yieldEvery=e||"auto","auto"===this.yieldEvery&&(this.yieldEvery=125),"never"===this.yieldEvery&&null!=t.onYield)throw new Error("yieldEvery is `never` but you provided an `onYield` callback. Either change `yieldEvery` or remove the callback");uC(this.yieldEvery)&&(this.maybeWait=function fpe(n,t,e){let i,r=null!=e?e():xo();return(...s)=>{const a=null!=e?e():xo();return a-r<t||(r=a,i=n(...s)),i}}(this.maybeWait.bind(this),this.yieldEvery,this.nowFunc)),this.trainBegin=t.onTrainBegin,this.trainEnd=t.onTrainEnd,this.epochBegin=t.onEpochBegin,this.epochEnd=t.onEpochEnd,this.batchBegin=t.onBatchBegin,this.batchEnd=t.onBatchEnd,this.yield=t.onYield}maybeWait(t,e,r){var i=this;return $e(function*(){const o=[];null!=i.yield&&(yield Nc(r),o.push(i.yield(t,e,r))),o.push(i.nextFrameFunc()),yield Promise.all(o)})()}onEpochBegin(t,e){var r=this;return $e(function*(){r.currentEpoch=t,null!=r.epochBegin&&(yield Nc(e),yield r.epochBegin(t,e))})()}onEpochEnd(t,e){var r=this;return $e(function*(){const i=[];null!=r.epochEnd&&(yield Nc(e),i.push(r.epochEnd(t,e))),"epoch"===r.yieldEvery&&i.push(r.nextFrameFunc()),yield Promise.all(i)})()}onBatchBegin(t,e){var r=this;return $e(function*(){null!=r.batchBegin&&(yield Nc(e),yield r.batchBegin(t,e))})()}onBatchEnd(t,e){var r=this;return $e(function*(){const i=[];null!=r.batchEnd&&(yield Nc(e),i.push(r.batchEnd(t,e))),"batch"===r.yieldEvery?i.push(r.nextFrameFunc()):uC(r.yieldEvery)&&i.push(r.maybeWait(r.currentEpoch,t,e)),yield Promise.all(i)})()}onTrainBegin(t){var e=this;return $e(function*(){null!=e.trainBegin&&(yield Nc(t),yield e.trainBegin(t))})()}onTrainEnd(t){var e=this;return $e(function*(){null!=e.trainEnd&&(yield Nc(t),yield e.trainEnd(t))})()}}function D4(n,t){return null==n&&(n={}),n instanceof Hh?[n]:Array.isArray(n)&&n[0]instanceof Hh?n:Xn(n).map(r=>new Jpe(r,t))}let efe=(()=>{class n{constructor(){}static registerCallbackConstructor(e,r){Z(e>=0&&Number.isInteger(e),()=>`Verbosity level is expected to be an integer >= 0, but got ${e}`),n.checkForDuplicate(r),null==n.constructors[e]&&(n.constructors[e]=[]),n.constructors[e].push(r)}static checkForDuplicate(e){for(const r in n.constructors)n.constructors[+r].forEach(o=>{if(o===e)throw new ye("Duplicate callback constructor.")})}static clear(){n.constructors={}}static createCallbacks(e){const r=[];for(const i in n.constructors){const o=+i;e>=o&&r.push(...n.constructors[o])}return r.map(i=>new i)}}return n.constructors={},n})();function k4(n,t,e,r,i,o,s,a,c){const u=new Qpe,p=[new Zpe,...efe.createCallbacks(t)];null!=n&&p.push(...n),p.push(u);const m=new Ype(p);return m.setParams({epochs:e,initialEpoch:r,samples:i,steps:o,batchSize:s,verbose:t,doValidation:a,metrics:c}),{callbackList:m,history:u}}function Dl(n,t={},e=!1){return Tg(n,Os.getMap().classNameMap,t,"layer",e)}function Fv(n,t){return Se(()=>{"float32"!==n.dtype&&(n=ht(n,"float32"));const e=St(Ig(n),t,!0),r=Ah(e.shape,ri()),i=ji(xl(e,r));return Nt(n,i)})}function Pv(n,t){return Se(()=>Sr(Ig(xt(t,n)),-1))}function FD(n,t){return Se(()=>Sr(ei(xt(t,n)),-1))}function PD(n,t){return Se(()=>{const e=xt(n,t),r=Uo(ei(n),ri(),Number.MAX_VALUE),i=ei(Nt(e,r));return fe(100,Sr(i,-1))})}function Ag(n,t,e=!1){return Se(()=>{if(e)t=pv(t);else{const r=St(t,t.shape.length-1,!0);t=Nt(t,r)}return t=Uo(t,ri(),1-ri()),tr(St(fe(ht(n,"float32"),cs(t)),t.shape.length-1))})}function $v(n,t,e=!1){return Se(()=>{const r=ht(fg(function Dpe(n){const t=[Dc(n.shape)];return be(n,t)}(n)),"int32"),i=(t=Uo(t,ri(),1-ri())).shape;return Ag(be(wE(r,i[i.length-1]),i),t,e)})}function Lv(n,t){return Se(()=>{let e;return e=Uo(t,ri(),1-ri()),e=cs(Nt(e,xt(1,e))),Sr(function sfe(n,t){if(!mn(n.shape,t.shape))throw new ye(`logits and labels must have the same shape, but got shapes ${JSON.stringify(n.shape)} and ${JSON.stringify(t.shape)}`);return Se(()=>{const e=La(t),r=tr(ei(t));return Xe(xt(e,fe(t,n)),rv(ls(r)))})}(n,e),-1)})}function A4(n,t){return Se(()=>{const e=Fv(n,-1),r=Fv(t,-1),i=fe(e,r);return tr(St(i,-1))})}const Bv={meanSquaredError:Pv,meanAbsoluteError:FD,meanAbsolutePercentageError:PD,meanSquaredLogarithmicError:function tfe(n,t){return Se(()=>{const e=Uo(t,ri(),Number.MAX_VALUE),r=cs(Xe(1,e)),i=Uo(n,ri(),Number.MAX_VALUE),o=cs(Xe(1,i));return Sr(Ig(xt(r,o)),-1)})},squaredHinge:function nfe(n,t){return Se(()=>{const e=xl(0,xt(1,fe(n,t)));return Sr(Ig(e),-1)})},hinge:function rfe(n,t){return Se(()=>{const e=xl(0,xt(1,fe(n,t)));return Sr(e,-1)})},categoricalHinge:function ife(n,t){return Se(()=>{const e=St(fe(n,t),-1),r=Ms(fe(xt(1,n),t),-1);return xl(0,Xe(1,xt(r,e)))})},logcosh:function ofe(n,t){return Se(()=>{const e=Math.log(2),r=xt(t,n),i=xt(Xe(r,Ph(fe(-2,r))),e);return Sr(i,-1)})},categoricalCrossentropy:Ag,sparseCategoricalCrossentropy:$v,binaryCrossentropy:Lv,kullbackLeiblerDivergence:function afe(n,t){return Se(()=>{const e=Uo(n,ri(),1),r=Uo(t,ri(),1);return St(fe(n,cs(Nt(e,r))),-1)})},poisson:function lfe(n,t){return Se(()=>{const e=cs(Xe(ri(),t));return Sr(xt(t,fe(n,e)),-1)})},cosineProximity:A4};function $D(n){if("string"==typeof n){if(n in Bv)return Bv[n];let t=`Unknown loss ${n}`;throw n.toLowerCase().includes("softmaxcrossentropy")&&(t=`Unknown loss ${n}. Use "categoricalCrossentropy" as the string name for tf.losses.softmaxCrossEntropy`),new ye(t)}return n}function N4(n,t){return Se(()=>{const e=fe(.5,ds(t)),r=Ua(jo(t,e),n.dtype);return Sr(la(n,r),-1)})}function O4(n,t){return Se(()=>Ua(la(Oh(n,-1),Oh(t,-1)),"float32"))}function hfe(n,t){return Lv(n,t)}function pfe(n,t){return n.rank===t.rank&&(n=$u(n,[n.rank-1])),(t=Oh(t,-1)).dtype!==n.dtype&&(t=ht(t,n.dtype)),ht(la(n,t),"float32")}const M4=Ag,F4=$v,Vv={binaryAccuracy:N4,categoricalAccuracy:O4,precision:function dfe(n,t){return Se(()=>{const e=function R4(n,t){return Se(()=>ht(St($a(la(n,1),la(t,1))),"float32"))}(n,t),r=function ufe(n,t){return Se(()=>ht(St($a(la(n,0),la(t,1))),"float32"))}(n,t),i=Xe(e,r);return ht(Gi(jo(i,0),Nt(e,i),0),"float32")})},categoricalCrossentropy:M4,sparseCategoricalCrossentropy:F4,mse:Pv,MSE:Pv,mae:FD,MAE:FD,mape:PD,MAPE:PD,cosine:A4};function xfe(n){if("string"==typeof n&&n in Vv)return Vv[n];if("string"!=typeof n&&null!=n)return n;throw new ye(`Unknown metric ${n}`)}function zv(n){if(ps(null!==n,`Unknown LossOrMetricFn ${n}`),"string"==typeof n)return n;{let t;for(const e of Object.keys(Bv))if(Bv[e]===n){t=e;break}if(void 0!==t)return t;for(const e of Object.keys(Vv))if(Vv[e]===n){t=e;break}return void 0!==t?t:n.name}}function $4(n,t,e=!1){if(null==n||"object"!=typeof n||Object.getPrototypeOf(n)!==Object.prototype||!LD(n))throw new Error("User-defined metadata is expected to be a JSON object, but is not.");if(e){const r=JSON.stringify(n);r.length>1048576&&console.warn(`User-defined metadata of model "${t}" is too large in size (length=${r.length} when serialized). It is not recommended to store such large objects in user-defined metadata. Please make sure its serialized length is <= 1048576.`)}}function LD(n){if(null===n)return!0;if("object"==typeof n){if(Object.getPrototypeOf(n)===Object.prototype){const t=Object.keys(n);for(const e of t)if("string"!=typeof e||!LD(n[e]))return!1;return!0}if(Array.isArray(n)){for(const t of n)if(!LD(t))return!1;return!0}return!1}{const t=typeof n;return"string"===t||"number"===t||"boolean"===t}}function Uv(n,t,e=console.log){let r="";for(let i=0;i<n.length;++i)i>0&&(r=r.slice(0,r.length-1)+" "),r+=n[i],r=r.slice(0,t[i]),r+=" ".repeat(t[i]-r.length);e(r)}function Ife(n,t,e){let r,i;try{i=n.inboundNodes.map(c=>JSON.stringify(c.inputShapes)).join(",")}catch{i="multiple"}try{r=JSON.stringify(n.outputShape)}catch{r="multiple"}Uv([`${n.name} (${n.getClassName()})`,i,r,n.countParams().toString()],t,e)}function Efe(n,t,e,r){let i,o;try{o=n.inboundNodes.map(m=>JSON.stringify(m.inputShapes)).join(",")}catch{o="multiple"}try{i=JSON.stringify(n.outputShape)}catch{i="multiple"}const s=[];for(const m of n.inboundNodes)if(!(null!=e&&e.length>0&&-1===e.indexOf(m)))for(let g=0;g<m.inboundLayers.length;++g)s.push(`${m.inboundLayers[g].name}[${m.nodeIndices[g]}][${m.tensorIndices[g]}]`);const a=n.name,c=n.getClassName(),u=0===s.length?"":s[0];Uv([`${a} (${c})`,o,i,n.countParams().toString(),u],t,r);for(let m=1;m<s.length;++m)Uv(["","","","",s[m]],t,r)}function L4(n,t,e){return("inboundNodes"===n||"outputLayers"===n||"inputLayers"===n)&&0===t&&"string"==typeof e}function BD(n,t){if(null===n)return null;if("string"==typeof n)return Vu(n);if("number"==typeof n||"boolean"==typeof n)return n;if(n instanceof Array){const e=[],r=n.length;for(let i=0;i<r;++i){const o=n[i];L4(t,i,o)?e.push(o):e.push(BD(o,t))}return e}{const e={};for(const r of Object.keys(n)){const i=n[r];if("name"===r&&"string"==typeof i)e[r]=i;else{const o=Vu(r);e[o]=BD(i,o)}}return e}}function VD(n,t){if(null==n)return null;if("string"==typeof n)return El(n);if("number"==typeof n||"boolean"==typeof n)return n;if(n instanceof Array){const e=[],r=n.length;for(let i=0;i<r;++i){const o=n[i];L4(t,i,o)?e.push(o):e.push(VD(o,t))}return e}{const e={};for(const r of Object.keys(n)){const i=n[r];e[El(r)]="name"!==r&&"className"!==r||"string"!=typeof i?VD(i,r):i}return e}}class ha extends dn{constructor(t){if(super({}),this.containerNodes=new Set,this.name=t.name,null==this.name){const R=this.getClassName().toLowerCase();this.name=Cv(R)}if(this.supportsMasking=!1,this.trainable_=!0,this.inputs=Array.isArray(t.inputs)?t.inputs.slice():[t.inputs],this.outputs=Array.isArray(t.outputs)?t.outputs.slice():[t.outputs],Ec(this.inputs).length!==this.inputs.length)throw new ye(`The list of inputs passed to the model is redundant. All inputs should only appear once. Found: ${this.inputs.map(R=>R.name)}`);Ec(this.outputs).length!==this.outputs.length&&console.warn(`The list of outputs passed to the model is redundant. All outputs should only appear once. Found: ${this.outputs.map(R=>R.name)}`),this.inputLayers=[],this.inputLayersNodeIndices=[],this.inputLayersTensorIndices=[],this.outputLayers=[],this.outputLayersNodeIndices=[],this.outputLayersTensorIndices=[],this.layers=[],this.internalContainerRefs=[];for(const R of this.outputs){const V=R.nodeIndex,j=R.tensorIndex;this.outputLayers.push(R.sourceLayer),this.outputLayersNodeIndices.push(V),this.outputLayersTensorIndices.push(j)}for(const R of this.inputs){const L=R.sourceLayer,V=R.nodeIndex,j=R.tensorIndex;ps(0===V,"input layer has >1 nodes"),ps(0===j,"input layer has >1 tensors"),this.inputLayers.push(L),this.inputLayersNodeIndices.push(V),this.inputLayersTensorIndices.push(j)}this.inputNames=[],this.outputNames=[],this.feedInputShapes=[],this.feedInputNames=[],this.feedOutputNames=[];for(let R=0;R<this.inputLayers.length;R++){const L=this.inputLayers[R];if(!(L instanceof Ov))throw new TypeError(`Input layers to a LayersModel must be InputLayer objects. Received inputs: ${t.inputs}. Input ${R} (0-based) originates from layer type ${L.getClassName()}.`);this.inputNames.push(L.name),this.feedInputShapes.push(L.batchInputShape),this.feedInputNames.push(L.name)}for(const R of this.outputLayers)this.outputNames.push(R.name);this.internalInputShapes=this.inputs.map(R=>R.shape),this.internalOutputShapes=this.outputs.map(R=>R.shape);const e={},r={},i={},o={},s={},a=[],c=(R,L,V,j,Y,ee)=>{(null==j||null==Y||null==ee)&&(j=R.sourceLayer,Y=R.nodeIndex,ee=R.tensorIndex);const ie=j.inboundNodes[Y];if(-1!==V.indexOf(ie))throw new Ls(`The tensor ${R.name} at layer "${j.name}" is part of a cycle.`);if(-1!==L.indexOf(ie))return;this.containerNodes.add(ha.nodeKey(j,Y)),j.id in s||(s[j.id]=Object.keys(s).length),-1===V.indexOf(ie)&&V.push(ie);const ce=ie.inboundLayers.length;for(let he=0;he<ce;he++)c(ie.inputTensors[he],L,V,ie.inboundLayers[he],ie.nodeIndices[he],ie.tensorIndices[he]);for(L.push(ie);V.indexOf(ie)>=0;)V.splice(V.indexOf(ie),1);a.push(ie)},u=[],p=[];for(const R of this.outputs)c(R,u,p);const m=a.slice().reverse();for(const R of m){r[R.id]=R,R.id in e||(e[R.id]=0);let L=e[R.id];L=Math.max(L,null==i[R.outboundLayer.id]?0:i[R.outboundLayer.id]),i[R.outboundLayer.id]=L,o[R.outboundLayer.id]=R.outboundLayer,e[R.id]=L;for(let j=0;j<R.inboundLayers.length;j++){const ie=R.inboundLayers[j].inboundNodes[R.nodeIndices[j]];e[ie.id]=Math.max(L+1,null==e[ie.id]?0:e[ie.id]),r[ie.id]=ie}}const g={};for(const R in e){const L=e[R];L in g||(g[L]=[]),g[L].push(r[R])}const _={};for(const R in i){const L=i[R];L in _||(_[L]=[]),_[L].push(o[R])}let x=Object.keys(_).map(R=>parseInt(R,10)).sort(Tv);this.layers=[];for(const R of x){const L=_[R];L.sort((V,j)=>{const Y=s[V.id],ee=s[j.id];return Y<ee?-1:Y>ee?1:0});for(const V of L)V instanceof ha&&this.internalContainerRefs.push(V),this.layers.push(V)}this.layersByDepth=_,x=Object.keys(g).map(R=>parseInt(R,10)).sort(Tv);const T=this.inputs.slice(),I=[];for(const R of x)for(const L of g[R]){const V=L.outboundLayer;if(null!=V){for(const j of L.inputTensors)if(-1===T.indexOf(j))throw new Ls(`Graph disconnected: cannot obtain value for tensor ${j} at layer "${V.name}". The following previous layers were accessed without issue: ${I}`);for(const j of L.outputTensors)T.push(j);I.push(V.name)}}this.nodesByDepth=g;const N=this.layers.map(R=>R.name);for(const R of N){const L=N.filter(V=>V===R).length;if(1!==L)throw new Ls(`The name "${R}" is used ${L} times in the model. All layer names should be unique. Layer names: `+JSON.stringify(N))}this.outboundNodes=[],this.inboundNodes=[],new Nv({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:this.inputs.map(R=>null),outputMasks:this.outputs.map(R=>null),inputShapes:this.inputs.map(R=>R.shape),outputShapes:this.outputs.map(R=>R.shape)}),this.built=!0,this._refCount=1}assertNotDisposed(){if(0===this._refCount)throw new Error(`Container '${this.name}' is already disposed.`)}dispose(){this.assertNotDisposed();const t={refCountAfterDispose:null,numDisposedVariables:0};if(0==--this._refCount){for(const e of this.layers)t.numDisposedVariables+=e.dispose().numDisposedVariables;for(const e of this.internalContainerRefs)t.numDisposedVariables+=e.dispose().numDisposedVariables}return t.refCountAfterDispose=this._refCount,t}get trainable(){return this.trainable_}set trainable(t){this.layers.forEach(e=>{e._trainableWeights.forEach(r=>r.trainable=t)}),this.trainable_=t}get trainableWeights(){if(this._trainableWeights.length>0)throw new ye("Container instance unexpectedly contains _trainableWeights.The trainable weights of a Container are a union of the trainable weights of its consituent Layers. Its own _trainableWeights must remain an empty Array.");if(!this.trainable)return[];let t=[];for(const e of this.layers)t=t.concat(e.trainableWeights);return t}get nonTrainableWeights(){const t=[];for(const e of this.layers)t.push(...e.nonTrainableWeights);if(!this.trainable){const e=[];for(const r of this.layers)e.push(...r.trainableWeights);return e.concat(t)}return t}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}loadWeights(t,e=!0){const r={};let i=0;for(const s of this.layers)for(const a of s.weights){if(null!=r[a.originalName])throw new ye(`Duplicate weight name: ${a.originalName}`);r[a.originalName]=a,i++}const o=[];for(const s in t){let a=s;if(null==r[s]){const c=s.split("/");a=c.slice(0,-2).concat([c[c.length-1]]).join("/")}if(null!=r[a])o.push([r[a],t[s]]);else if(e)throw new ye(`Provided weight data has no target variable: ${s}`);delete r[a]}if(e){const s=[];for(const a in r)s.push(a);if(s.length>0)throw new ye(`${s.length} of ${i} weights are not set: ${s}`)}OD(o)}updatedConfig(){const t=this.getConfig(),e={};return e.className=this.getClassName(),e.config=t,e.kerasVersion="tfjs-layers 4.5.0",e.backend="TensorFlow.js",e}toJSON(t,e=!0){const r=VD(this.updatedConfig());return e?JSON.stringify(r):r}call(t,e){return Se(()=>{t=Xn(t);const r=new Ac;for(let i=0;i<this.inputs.length;++i)r.add(this.inputs[i],t[i]);return Dg(this.outputs,r,e)})}computeMask(t,e){return Se(()=>{let r;return t=Xn(t),r=null==e?Bu(null,t.length):Xn(e),this.runInternalGraph(t,r)[1]})}computeOutputShape(t){const e=kv(t);if(e.length!==this.inputLayers.length)throw new ye(`Invalid inputShape argument ${t}: model has ${this.inputLayers.length} tensor inputs.`);const r={};for(let a=0;a<e.length;a++)r[this.inputLayers[a].name+"_0_0"]=e[a];const i=Object.keys(this.nodesByDepth).map(a=>parseInt(a,10)).sort(Tv);if(i.length>1)for(const a of i){const c=this.nodesByDepth[a];for(const u of c){const p=u.outboundLayer;if(-1!==this.inputLayers.map(T=>T.id).indexOf(p.id))continue;const m=[];for(let T=0;T<u.inboundLayers.length;T++)m.push(r[`${u.inboundLayers[T].name}_${u.nodeIndices[T]}_${u.tensorIndices[T]}`]);const _=kv(p.computeOutputShape(Co(m))),x=p.inboundNodes.indexOf(u);for(let T=0;T<_.length;T++)r[`${p.name}_${x}_${T}`]=_[T]}}const o=[],s=[];for(let a=0;a<this.outputLayers.length;a++)s.push(`${this.outputLayers[a].name}_${this.outputLayersNodeIndices[a]}_${this.outputLayersTensorIndices[a]}`);for(let a=0;a<s.length;a++){const c=s[a];ps(c in r),o.push(r[c])}return Co(o)}runInternalGraph(t,e){null==e&&(e=Bu(null,t.length));const r={};for(let c=0;c<this.inputs.length;++c)r[this.inputs[c].id]=[t[c],e[c]];const i=Object.keys(this.nodesByDepth).map(c=>parseInt(c,10)).sort(Tv);for(const c of i){const u=this.nodesByDepth[c];for(const p of u){const m=p.outboundLayer,g=p.inputTensors,_=p.outputTensors,x=new Array;for(const T of g)T.id in r&&x.push(r[T.id]);if(x.length===g.length){let I,N,R,L,T={};if(null!=p.callArgs&&(T=p.callArgs),1===x.length){const[V,j]=x[0];null==T.mask&&(T.mask=j),R=Xn(m.call(V,T)),L=Xn(m.computeMask(V,j)),I=[V],N=[j]}else I=x.map(V=>V[0]),N=x.map(V=>V[1]),null==T.mask&&(T.mask=N),R=Xn(m.call(I,T)),L=Xn(m.computeMask(I,N));if(m.activityRegularizer)throw new en("LayersModel invocation with concrete Tensor value(s) in the presence of activity regularizer(s) is not supported yet.");for(let V=0;V<_.length;++V)r[_[V].id]=[R[V],L[V]]}}}const o=[],s=[],a=[];for(const c of this.outputs){ps(c.id in r,`Could not compute output ${c.name} : ${c.id}`);const[u,p]=r[c.id];a.push(u.shape),o.push(u),s.push(p)}return[o,s,a]}buildNodeConversionMap(t){const e={};let r;for(const i of this.layers){r=i instanceof ha?1:0;for(let o=0;o<i.inboundNodes.length;o++){const s=ha.nodeKey(i,o);this.containerNodes.has(s)&&(e[s]=r,r+=1)}}return e}getLayer(t,e){if(null!=e){if(this.layers.length<=e)throw new ye(`Was asked to retrieve layer at index ${e}, but model only has ${this.layers.length} layer(s).`);return this.layers[e]}if(null==t)throw new ye("Provide either a layer name or layer index");for(const r of this.layers)if(r.name===t)return r;throw new ye(`No such layer: ${t}`)}calculateLosses(){return Se(()=>{const t=[];for(const e of this.layers)for(let r=0;r<e.inboundNodes.length;++r){const i=ha.nodeKey(e,r);this.containerNodes.has(i)&&t.push(...e.calculateLosses())}return t})}getConfig(){const t={name:this.name},e=this.buildNodeConversionMap(this.layers),r=[];for(const s of this.layers){const a=s.getClassName(),c=s.getConfig(),u=[];for(let m=0;m<s.inboundNodes.length;m++){const g=s.inboundNodes[m],_=ha.nodeKey(s,m);let x={};if(this.containerNodes.has(_)){if(g.callArgs)try{JSON.stringify(g.callArgs),x=g.callArgs}catch{console.warn(`Layer ${s.name} was passed non-serializable keyword arguments: ${g.callArgs}. They will not be included in the serialized model (and thus will be missing at deserialization time).`),x={}}if(g.inboundLayers.length>0){const T=[];for(let I=0;I<g.inboundLayers.length;I++){const N=g.inboundLayers[I],L=g.tensorIndices[I];let j=e[ha.nodeKey(N,g.nodeIndices[I])];null==j&&(j=0),T.push([N.name,j,L,x])}u.push(T)}}}const p={};p.name=s.name,p.className=a,p.config=c,p.inboundNodes=u,r.push(p)}t.layers=r;const i=[];for(let s=0;s<this.inputLayers.length;s++){const a=this.inputLayers[s],u=ha.nodeKey(a,this.inputLayersNodeIndices[s]);if(!this.containerNodes.has(u))continue;let p=e[u];null==p&&(p=0),i.push([a.name,p,this.inputLayersTensorIndices[s]])}t.inputLayers=i;const o=[];for(let s=0;s<this.outputLayers.length;s++){const a=this.outputLayers[s],u=ha.nodeKey(a,this.outputLayersNodeIndices[s]);if(!this.containerNodes.has(u))continue;let p=e[u];null==p&&(p=0),o.push([a.name,p,this.outputLayersTensorIndices[s]])}return t.outputLayers=o,t}static fromConfig(t,e,r={},i=!1){const o={},s={};function a(I,N){I.name in s?s[I.name].push(N):s[I.name]=[N]}function c(I,N){const R=[];let L;for(const V of N){const j=V[0],Y=V[1],ee=V[2];if(L=null==V[3]?{}:V[3],!(j in o))return void a(I,N);const ie=o[j];if(ie.inboundNodes.length<=Y)return void a(I,N);R.push(ie.inboundNodes[Y].outputTensors[ee])}R.length>0&&I.apply(Co(R),L)}function u(I){const N=I.name,R=Dl(I,null!=e.customObjects?e.customObjects:{});R.setFastWeightInitDuringBuild(i),o[N]=R,I.inboundNodes.forEach(V=>{if(!(V instanceof Array))throw new ye(`Corrupted configuration, expected array for nodeData: ${V}`);a(R,V)})}const p=e.name,m=e.layers;for(const I of m)u(I);for(;!ppe(s);)for(const I of m){const N=o[I.name];if(N.name in s){const R=s[N.name];delete s[N.name];for(const L of R)c(N,L)}}const g=[],_=[],x=e.inputLayers;for(const I of x){const N=I[0],R=I[1],L=I[2];ps(N in o),g.push(o[N].inboundNodes[R].outputTensors[L])}const T=e.outputLayers;for(const I of T){const N=I[0],R=I[1],L=I[2];ps(N in o),_.push(o[N].inboundNodes[R].outputTensors[L])}return new t({inputs:g,outputs:_,name:p})}get stateful(){if(this._stateful)throw new ye("Container instance unexpectedly has _stateful = true. The statefulness of a Container is determined by the Layers it contains. Its _stateful property must remain the default false.");for(const t of this.layers)if(t.stateful)return!0;return!1}resetStates(){Se(()=>{this.layers.forEach(t=>{t.stateful&&t.resetStates()})})}}function V4(n,t){return function B4(n,t,e){const r=t.length;if(null==n||Array.isArray(n)&&0===n.length)return t.map(i=>null);if(1===r)return Array.isArray(n)&&1===n.length?n:"object"==typeof n&&t[0]in n?[n[t[0]]]:[n];if(Array.isArray(n)){if(n.length!==r)throw new Error(`Provided ${e} is an array of ${n.length} element(s), but the model has ${r} outputs. Make sure a set of weights is provided for each model output.`);return n}if("object"==typeof n&&Object.keys(n).length>0&&"object"==typeof n[Object.keys(n)[0]]){const i=[];return t.forEach(o=>{i.push(o in n?n[o]:null)}),i}throw new Error(`The model has multiple (${r}) outputs, so ${e} must be either an array with ${r} elements or an object with ${t} keys. Provided ${e} not understood: ${JSON.stringify(n)}`)}(n,t,"classWeight")}function z4(n,t,e,r){return UD.apply(this,arguments)}function UD(){return(UD=$e(function*(n,t,e,r){if(null!=t||null!=r)throw new Error("Support sampleWeight is not implemented yet");if(null!=e){const i=Se(()=>{if(1===n.shape.length)return _l(n);if(2===n.shape.length){if(n.shape[1]>1)return Oh(n,1);if(1===n.shape[1])return be(n,[n.shape[0]]);throw new Error(`Encountered unexpected last-dimension size (${n.shape[1]}) during handling of class weights. The size is expected to be >= 1.`)}throw new Error(`Unexpected rank of target (y) tensor (${n.rank}) during handling of class weights. The rank is expected to be 1 or 2.`)}),o=Array.from(yield i.data());un(i);const s=[];return o.forEach(a=>{if(null==e[a])throw new Error(`classWeight must contain all classes in the training data. The class ${a} exists in the data but not in classWeight`);s.push(e[a])}),So(s,"float32")}return null})).apply(this,arguments)}function Dfe(n,t){return fe(n,t)}function U4(n,t){let e,r;e=t.xs,r=t.ys,Z(null!=e&&null!=r,()=>`A Dataset iterator for fitDataset() is expected to generate objects of the form \`{xs: xVal, ys: yVal}\`, where the two values may be \`tf.Tensor\`, an array of Tensors, or a map of string to Tensor.  The provided Dataset instead generates ${t}`);const o=j4("input",n.inputNames,e),s=j4("output",n.outputNames,r),a=o[0].shape[0];Z(o.length===n.inputs.length,()=>`LayersModel has ${n.inputs.length} inputs, but the dataset provides ${o.length} inputs.  (Expected input keys: ${JSON.stringify(n.inputNames)})`),Z(s.length===n.outputs.length,()=>`LayersModel has ${n.outputs.length} outputs, but the dataset provides ${s.length} outputs.  (Expected output keys: ${JSON.stringify(n.outputNames)})`);for(let c=0;c<o.length;c++)Z(o[c].shape[0]===a,()=>`Batch size mismatch: input ${n.inputNames[c]} has ${o[c].shape[0]}; expected  ${a} based on input ${n.inputNames[0]}.`);for(let c=0;c<s.length;c++)Z(s[c].shape[0]===a,()=>`Batch size mismatch: output ${n.outputNames[c]} has ${s[c].shape[0]}; expected  ${a} based on input ${n.inputNames[0]}.`);return{xs:o,ys:s}}function j4(n,t,e){if(e instanceof sr)return[e];if(Array.isArray(e))return Z(e.length===t.length,()=>`Received an array of ${e.length} Tensors, but expected ${t.length} to match the ${n} keys ${t}.`),e;{const r=[];for(const i of t){if(null==e[i])throw new ye(`The feature data generated by the dataset lacks the required ${n} key '${i}'.`);r.push(e[i])}return r}}function jD(){return(jD=$e(function*(n,t,e){const r=null!=e.batchesPerEpoch;if(Z(null!=n.optimizer,()=>"You must compile a model before training/testing. Use LayersModel.compile(modelCompileConfig)."),Z(null!=e,()=>"For fitDataset(), the 2nd argument (config) is required, but it is not provided in this call."),Z(null!=e.epochs&&e.epochs>0&&Number.isInteger(e.epochs),()=>`For fitDataset(), config.epochs is expected to be a positive integer, but got ${e.epochs}`),Z(!r||e.batchesPerEpoch>0&&Number.isInteger(e.batchesPerEpoch),()=>`For fitDataset(), config.batchesPerEpoch is expected to be a positive integer if specified, but got ${e.batchesPerEpoch}`),Z(null==e.validationSplit,()=>"`validationSplit` is not supported by `fitDataset()`. Use validationData instead."),n.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");n.isTraining=!0;try{const i=null!=e.validationData;let o,s;if(i)if(G4(e.validationData))Z(null==e.validationBatches||e.validationBatches>0&&Number.isInteger(e.validationBatches),()=>`For fitDataset() with dataset-based validation, config.validationBatches is expected not to be provided, or to be a positive integer, but got ${e.validationBatches}`);else{const I=function Afe(n){if(3===n.length)throw new en("Validation with sample weights is not implemented yet.");return{xs:n[0],ys:n[1]}}(e.validationData);o=I.xs,s=I.ys}const a=n.makeTrainFunction(),c=n.getDedupedMetricsNames();let u;u=i?c.slice().concat(c.map(I=>"val_"+I)):c.slice();const p=D4(e.callbacks,e.yieldEvery),m=null==e.verbose?1:e.verbose,{callbackList:g,history:_}=k4(p,m,e.epochs,null,null,function Ofe(n,t){let e=null;return null!=t.batchesPerEpoch?e=t.batchesPerEpoch:Number.isFinite(n.size)&&(e=n.size),e}(t,e),null,i,u);g.setModel(n),n.history=_,yield g.onTrainBegin(),n.stopTraining_=!1;let x=null==e.initialEpoch?0:e.initialEpoch,T=yield t.iterator();for(;x<e.epochs;){const I={};yield g.onEpochBegin(x);let N=0,R=0;for(r||(T=yield t.iterator());!r||N<e.batchesPerEpoch;){const L=yield T.next();if(r&&L.done){console.warn(`You provided \`batchesPerEpoch\` as ${e.batchesPerEpoch}, but your dataset iterator ran out of data after ${N} batches; interrupting training. Make sure that your dataset can generate at least \`batchesPerEpoch * epochs\` batches (in this case, ${e.batchesPerEpoch*e.epochs} batches). You may need to use the repeat() function when building your dataset.`);break}if(null!=L.value){const{xs:V,ys:j}=U4(n,L.value),Y={};Y.batch=R,Y.size=V[0].shape[0],yield g.onBatchBegin(R,Y);const ee=[];if(null!=e.classWeight){const he=V4(e.classWeight,n.outputNames);for(let we=0;we<he.length;++we)ee.push(yield z4(j[we],null,he[we]))}const ie=V.concat(j).concat(ee),ce=a(ie);un(ie);for(let he=0;he<c.length;++he){const Ee=ce[he];Y[c[he]]=Ee,fi(Ee)}yield g.onBatchEnd(R,Y),E4(Y),R++,N++}if(r?N>=e.batchesPerEpoch:L.done){if(i){let V;V=G4(e.validationData)?Xn(yield n.evaluateDataset(e.validationData,{batches:e.validationBatches})):Xn(n.evaluate(o,s,{batchSize:null==e.validationBatchSize?32:e.validationBatchSize,verbose:0}));for(let j=0;j<n.metricsNames.length;++j)I[`val_${n.metricsNames[j]}`]=V[j]}break}if(n.stopTraining_)break}if(yield g.onEpochEnd(x,I),x++,n.stopTraining_)break}return yield g.onTrainEnd(),yield n.history.syncData(),n.history}finally{n.isTraining=!1}})).apply(this,arguments)}function G4(n){return"function"==typeof n.iterator}function GD(){return(GD=$e(function*(n,t,e){const r=null!=(e=e||{}).batches,i=n.testFunction;let o=[];if(e.verbose>0)throw new en("Verbose mode is not implemented yet.");Z(!r||e.batches>0&&Number.isInteger(e.batches),()=>`Test loop expects \`batches\` to be a positive integer, but received ${JSON.stringify(e.batches)}`);const s=function Rfe(n){return"function"==typeof n.next}(t)?t:yield t.iterator();let a=0,c=0;for(;!r||c<e.batches;){const u=yield s.next();if(o=Se(()=>{if(u.value){const{xs:p,ys:m}=U4(n,u.value),g=p.concat(m),_=Se(()=>i(g));if(un(g),0===c)for(let T=0;T<_.length;++T)o.push(Ft(0));const x=g[0].shape[0];for(let T=0;T<_.length;++T){const I=_[T],N=o[T];o[T]=Se(()=>Xe(o[T],fe(x,I))),c>0&&un(N)}un(_),a+=x,++c}return o}),u.done){r&&console.warn(`Your dataset iterator ran out of data during evaluateDataset(). Interrupting evalution. Make sure that your dataset can generate at least \`batches\` batches (in this case, ${e.batches} batches). You may need to use the repeat() function when building your dataset.`);break}}for(let u=0;u<o.length;++u){const p=o[u];o[u]=Nt(o[u],a),un(p)}return Co(o)})).apply(this,arguments)}function HD(n){Z(n>0&&Number.isInteger(n),()=>`batchSize is required to be a positive integer, but got ${n}`)}function Ng(n,t,e){return null==n?[null]:Array.isArray(n)?n.map(r=>ju(r,t,e-t)):ju(n,t,e-t)}function WD(n,t){return Se(()=>null==n?null:Array.isArray(n)?n.map(e=>WD(e,t)):d4(n,"int32"===t.dtype?t:ht(t,"int32")))}function qD(n,t){const e=[];let r=0,i=null;for(;r<n;)i=r+t,i>=n&&(i=n),e.push([r,i]),r=i;return e}function H4(n){const t=[];n instanceof sr&&(n=[n]);for(let e=0;e<n.length;++e){const r=n[e];if(1===r.rank)t.push(Cg(r,1));else{if(0===r.rank)throw new Error("Expected tensor to be at least 1D, but received a 0D tensor (scalar).");t.push(r)}}return t}function pa(n,t){if(null==n)return;const e=[];if(t instanceof sr)e.push(t.id);else if(Array.isArray(t))t.forEach(i=>e.push(i.id));else if(null!=t)for(const i in t)e.push(t[i].id);const r=[];if(n instanceof sr)-1===e.indexOf(n.id)&&r.push(n);else if(Array.isArray(n))n.forEach(i=>{-1===e.indexOf(i.id)&&r.push(i)});else if(null!=n)for(const i in n){const o=n[i];-1===e.indexOf(o.id)&&r.push(o)}r.forEach(i=>{i.isDisposed||i.dispose()})}function KD(n){return Array.isArray(n)}function W4(n){return!function Ffe(n){return n instanceof sr}(n)&&!KD(n)}function q4(n,t,e,r=!0,i=""){if(null==t||0===t.length){if(null!=n){let s=!1;if(KD(n)&&n.length>0)s=!0;else if(W4(n)){for(const a in n)if(n.hasOwnProperty(a)){s=!0;break}}else s=!0;if(s)throw new ye(`Error when checking model ${i} expected no data, but got ${n}`)}return[]}if(null==n)return t.map(s=>null);let o;if(W4(n)){o=[];for(const s of t){if(null==n[s])throw new ye(`No data provided for "${s}". Need data for each key in: ${t}`);o.push(n[s])}}else if(KD(n)){if(n.length!==t.length)throw new ye(`Error when checking model ${i}: the Array of Tensors that you are passing to your model is not the size the model expected. Expected to see ${t.length} Tensor(s), but instead got the following list of Tensor(s): ${n}`);o=n}else{if(t.length>1)throw new ye(`The model ${i} expects ${t.length} Tensor(s), but only received one Tensor. Found: Tensor with shape ${n.shape}`);o=[n]}if(o=H4(o),null!=e)for(let s=0;s<t.length;++s){if(null==e[s])continue;const a=o[s];if(a.shape.length!==e[s].length)throw new ye(`Error when checking ${i}: expected ${t[s]} to have ${e[s].length} dimension(s). but got array with shape ${a.shape}`);for(let c=0;c<e[s].length;++c){if(0===c&&!r)continue;const p=e[s][c];if(null!=p&&p>=0&&a.shape[c]!==p)throw new ye(`${i} expected a batch of elements where each example has shape [${e[s].slice(1,e[s].length)}] (i.e.,tensor shape [*,${e[s].slice(1,e[s].length)}]) but the ${i} received an input with ${a.shape[0]} examples, each with shape [${a.shape.slice(1,a.shape.length)}] (tensor shape [${a.shape}])`)}}return o}function K4(n,t,e,r=!0,i=""){let o;if(Array.isArray(n)){if(n.length!==t.length)throw new ye(`Error when checking model ${i}: the Array of Tensors that you are passing to your model is not the size the the model expected. Expected to see ${t.length} Tensor(s), but instead got ${n.length} Tensors(s).`);o=n}else{if(t.length>1)throw new ye(`The model expects ${t.length} ${i} Tensors, but only received one Tensor. Found: array with shape ${JSON.stringify(n.shape)}.`);o=[n]}if(null!=e)for(let s=0;s<t.length;++s){if(null==e[s])continue;const a=o[s];if(a.shape.length!==e[s].length)throw new ye(`Error when checking ${i}: expected ${t[s]} to have ${e[s].length} dimension(s), but got array with shape ${JSON.stringify(a.shape)}`);for(let c=0;c<e[s].length;++c){if(0===c&&!r)continue;const p=e[s][c];if(null!=p&&p!==a.shape[c])throw new ye(`Error when checking ${i}: expected ${t[s]} to have shape ${JSON.stringify(e[s])} but got array with shape ${JSON.stringify(a.shape)}.`)}}}let Wh=(()=>{class n extends ha{constructor(e){super(e),this.isTraining=!1}summary(e,r,i=console.log){if(!this.built)throw new ye("This model has never been called, thus its weights have not been created yet. So no summary can be displayed. Build the model first (e.g., by calling it on some test data).");!function Tfe(n,t,e,r=console.log){const i=function Cfe(n){let t=!0;const e=[],r=[];for(const i in n.nodesByDepth)e.push(n.nodesByDepth[i]);for(const i of e){if(i.length>1||1===i.length&&i[0].inboundLayers.length>1){t=!1;break}r.push(...i)}if(t)for(const i of n.layers){let o=!1;for(const s of i.inboundNodes)if(-1!==r.indexOf(s)){if(o){t=!1;break}o=!0}if(!t)break}return t}(n),o=["Layer (type)","Input Shape","Output shape","Param #"];let s;if(i?(t=t||90,e=e||[.32,.61,.89,1]):(t=t||115,e=e||[.24,.48,.7,.8,1]),e[e.length-1]<=1&&(e=e.map(p=>Math.floor(t*p))),!i){o.push("Receives inputs"),s=[];for(const p in n.nodesByDepth)s.push(...n.nodesByDepth[p])}r("_".repeat(t)),Uv(o,e,r),r("=".repeat(t));const a=n.layers;for(let p=0;p<a.length;++p)i?Ife(a[p],e,r):Efe(a[p],e,s,r),r((p===a.length-1?"=":"_").repeat(t));n.checkTrainableWeightsConsistency();const c=function Sfe(n){let t;return t=Av(null!=n.collectedTrainableWeights?n.collectedTrainableWeights:n.trainableWeights),t}(n),u=Av(n.nonTrainableWeights);r(`Total params: ${c+u}`),r(`Trainable params: ${c}`),r(`Non-trainable params: ${u}`),r("_".repeat(t))}(this,e,r,i)}compile(e){if(null==e.loss&&(e.loss=[]),this.loss=e.loss,"string"==typeof e.optimizer)this.optimizer_=function wfe(n){const t={Adagrad:()=>Uh.adagrad(.01),Adadelta:()=>Uh.adadelta(1,.95,ri()),Adam:()=>Uh.adam(.001,.9,.999,ri()),Adamax:()=>Uh.adamax(.002,.9,.999,ri(),0),RMSProp:()=>Uh.rmsprop(.001,.9,0,ri()),SGD:()=>Uh.sgd(.01)};if(t.adagrad=t.Adagrad,t.adadelta=t.Adadelta,t.adam=t.Adam,t.adamax=t.Adamax,t.rmsprop=t.RMSProp,t.sgd=t.SGD,n in t)return t[n]();throw new ye(`Unknown Optimizer ${n}`)}(e.optimizer),this.isOptimizerOwned=!0;else{if(!(e.optimizer instanceof _c))throw new ye("User-defined optimizer must be an instance of tf.Optimizer.");this.optimizer_=e.optimizer,this.isOptimizerOwned=!1}let r=[];if(Array.isArray(e.loss)||"string"==typeof e.loss||"function"==typeof e.loss)if(Array.isArray(e.loss)){if(e.loss.length!==this.outputs.length)throw new ye(`When passing an Array as loss, it should have one entry per model output. The model has ${this.outputs.length} output(s), but you passed loss=${e.loss}.`);r=e.loss.map(c=>$D(c))}else{const a=$D(e.loss);this.outputs.forEach(c=>{r.push(a)})}else{e.loss=e.loss;for(const a in e.loss)if(-1===this.outputNames.indexOf(a))throw new ye(`Unknown entry in loss dictionary: "${a}". Only expected the following keys: ${this.outputNames}`);for(const a of this.outputNames)null==e.loss[a]&&console.warn(`Output "${a}" is missing from loss dictionary. We assume this was done on purpose, and we will not be expecting data to be passed to ${a} during training`),r.push($D(e.loss[a]))}this.lossFunctions=r,this.feedOutputNames=[],this.feedOutputShapes=[],this.feedLossFns=[];for(let a=0;a<this.outputs.length;++a){const c=this.internalOutputShapes[a];this.feedOutputNames.push(this.outputNames[a]),this.feedOutputShapes.push(c),this.feedLossFns.push(this.lossFunctions[a])}const i=[];this.metrics=e.metrics,this.metricsNames=["loss"],this.metricsTensors=[],Uu("loss",()=>{for(let a=0;a<this.outputs.length;++a)-1===i.indexOf(a)&&this.outputs.length>1&&(this.metricsTensors.push([this.lossFunctions[a],a]),this.metricsNames.push(this.outputNames[a]+"_loss"))});const o=function Lfe(n,t){if(null==n||Array.isArray(n)&&0===n.length)return t.map(r=>[]);let e;if("string"==typeof n||"function"==typeof n)e=[n];else{if(!Array.isArray(n)&&"object"!=typeof n)throw new TypeError(`Type of metrics argument not understood. Expected an string,function, Array, or Object, found: ${n}`);e=n}if(Array.isArray(e))return t.map(r=>e);{const r=[];for(const i of t){let o=e.hasOwnProperty(i)?e[i]:[];Array.isArray(o)||(o=[o]),r.push(o)}return r}}(e.metrics,this.outputNames),s=(a,c,u)=>{this.outputNames.length>1&&(c=this.outputNames[a]+"_"+c),this.metricsNames.push(c),this.metricsTensors.push([u,a])};Uu("metric",()=>{for(let a=0;a<this.outputs.length;++a)-1===i.indexOf(a)&&(p=>{let g,_,x;for(const T of p){if("string"==typeof T&&-1!==["accuracy","acc","crossentropy","ce"].indexOf(T)){const N=this.internalOutputShapes[a];let R;1===N[N.length-1]||this.lossFunctions[a]===Lv?-1!==["accuracy","acc"].indexOf(T)?_=N4:-1!==["crossentropy","ce"].indexOf(T)&&(_=hfe):this.lossFunctions[a]===$v?-1!==["accuracy","acc"].indexOf(T)?_=pfe:-1!==["crossentropy","ce"].indexOf(T)&&(_=F4):-1!==["accuracy","acc"].indexOf(T)?_=O4:-1!==["crossentropy","ce"].indexOf(T)&&(_=M4),-1!==["accuracy","acc"].indexOf(T)?R="acc":-1!==["crossentropy","ce"].indexOf(T)&&(R="ce"),x=_,g=""+R}else x=xfe(T),g=""+zv(T);let I;Uu(g,()=>{I=x}),s(a,g,I)}})(o[a])}),this.collectedTrainableWeights=this.trainableWeights}checkTrainableWeightsConsistency(){null!=this.collectedTrainableWeights&&this.trainableWeights.length!==this.collectedTrainableWeights.length&&console.warn("Discrepancy between trainableweights and collected trainable weights. Did you set `model.trainable` without calling `model.compile()` afterwards?")}evaluate(e,r,i={}){const o=null==i.batchSize?32:i.batchSize;HD(o);const a=this.standardizeUserDataXY(e,r,!0,o);try{const c=a[0].concat(a[1]);return this.makeTestFunction(),Co(this.testLoop(this.testFunction,c,o,i.verbose,i.steps))}finally{pa(a[0],e),pa(a[1],r)}}evaluateDataset(e,r){var i=this;return $e(function*(){return i.makeTestFunction(),function Mfe(n,t,e){return GD.apply(this,arguments)}(i,e,r)})()}checkNumSamples(e,r,i,o="steps"){let s;if(null!=i){if(s=null,null!=r)throw new ye(`If ${o} is set, batchSize must be null or undefined.Got batchSize = ${r}`)}else{if(null==e)throw new ye(`Either the input data should have a defined shape, or ${o} shoud be specified.`);s=Array.isArray(e)?e[0].shape[0]:e.shape[0]}return s}execute(e,r){if(Array.isArray(r)&&0===r.length)throw new ye("`outputs` is an empty Array, which is not allowed.");const i=Array.isArray(r),s=this.retrieveSymbolicTensors(i?r:[r]),a=new Ac;if(e instanceof sr&&(e=[e]),Array.isArray(e)){if(e.length!==this.inputs.length)throw new ye(`The number of inputs provided (${e.length}) does not match the number of inputs of this model (${this.inputs.length}).`);for(let u=0;u<this.inputs.length;++u)a.add(this.inputs[u],e[u])}else for(const u of this.inputs){const p=e[u.name];if(null==p)throw new ye(`No value is provided for the model's input ${u.name}`);a.add(u,p)}const c=Dg(s,a);return i?c:c[0]}retrieveSymbolicTensors(e){const r=Bu(null,e.length);let i=e.length;for(const o of this.layers){const s=Array.isArray(o.output)?o.output:[o.output],a=s.map(c=>c.name);for(let c=0;c<e.length;++c){const u=a.indexOf(e[c]);if(-1!==u&&(r[c]=s[u],i--),0===i)break}if(0===i)break}if(i>0){const o=[];throw r.forEach((s,a)=>{null==s&&o.push(e[a])}),new ye(`Cannot find SymbolicTensors for output name(s): ${JSON.stringify(o)}`)}return r}predictLoop(e,r=32,i=!1){return Se(()=>{const o=this.checkNumSamples(e);if(i)throw new en("Verbose predictLoop() is not implemented yet.");const s=qD(o,r),a=this.outputs.map(c=>[]);for(let c=0;c<s.length;++c)Se(()=>{const g=Ng(e,s[c][0],s[c][1]),_=[];if(Array.isArray(g))for(let T=0;T<g.length;++T)_.push({key:this.inputs[T],value:g[T]});else _.push({key:this.inputs[0],value:g});const x=new Ac(_);return Dg(this.outputs,x)}).forEach((p,m)=>a[m].push(p));return Co(a.map(c=>Ur(c,0)))})}predict(e,r={}){const i=H4(e);K4(i,this.inputNames,this.feedInputShapes,!1);try{const o=null==r.batchSize?32:r.batchSize;return HD(o),this.predictLoop(i,o)}finally{pa(i,e)}}predictOnBatch(e){K4(e,this.inputNames,this.feedInputShapes,!0);const r=(Array.isArray(e)?e[0]:e).shape[0];return this.predictLoop(e,r)}standardizeUserDataXY(e,r,i=!0,o){if(null==this.optimizer_)throw new Ls("You must compile a model before training/testing. Use LayersModel.compile(modelCompileArgs).");const s=[];for(let a=0;a<this.feedOutputShapes.length;++a){const c=this.feedOutputShapes[a];s.push(this.feedLossFns[a]===$v?c.slice(0,c.length-1).concat([1]):c)}if(function Pfe(n,t,e){const r=Ec(n.map(o=>o.shape[0]));r.sort();const i=Ec(t.map(o=>o.shape[0]));if(i.sort(),r.length>1)throw new ye(`All input Tensors (x) should have the same number of samples. Got array shapes: ${JSON.stringify(n.map(o=>o.shape))}`);if(i.length>1)throw new ye(`All target Tensors (y) should have the same number of samples. Got array shapes: ${JSON.stringify(t.map(o=>o.shape))}`);if(r.length>0&&i.length>0&&!mn(r,i))throw new ye(`Input Tensors should have the same number of samples as target Tensors. Found ${r[0]} input sample(s) and ${i[0]} target sample(s).`)}(e=q4(e,this.feedInputNames,this.feedInputShapes,!1,"input"),r=q4(r,this.feedOutputNames,s,!1,"target")),function $fe(n,t,e){const r=[Pv,Lv,Ag];for(let i=0;i<n.length;++i){const o=n[i],s=t[i],a=e[i];if(null!=s){if(s===Ag&&1===o.shape[o.shape.length-1])throw new ye(`You are passing a target array of shape ${o.shape} while using a loss 'categorical_crossentropy'. 'categorical_crossentropy'expects targets to be binary matrices (1s and 0s) of shape [samples, classes].`);if(-1!==r.indexOf(s)){const c=o.shape.slice(1),u=a.slice(1);for(let p=0;p<c.length;++p){const g=u[p];if(null!=g&&c[p]!==g)throw new ye(`A target Tensor with shape ${o.shape} was passed for an output of shape ${a}, while using a loss function that expects targets to have the same shape as the output.`)}}}}}(r,this.feedLossFns,this.feedOutputShapes),this.stateful&&null!=o&&o>0&&e[0].shape[0]%o!=0)throw new ye(`In a stateful network, you should only pass inputs with a number of samples that is divisible by the batch size ${o}. Found: ${e[0].shape[0]} sample(s).`);return[e,r]}standardizeUserData(e,r,i,o,s=!0,a){var c=this;return $e(function*(){const[u,p]=c.standardizeUserDataXY(e,r,s,a);if(null!=i)throw new Error("sample weight is not supported yet.");let m=null;if(null!=o){const g=V4(o,c.outputNames);m=[];for(let _=0;_<g.length;++_)m.push(yield z4(p[_],null,g[_]))}return[u,p,m]})()}testLoop(e,r,i,o=0,s){return Se(()=>{const a=this.checkNumSamples(r,i,s,"steps"),c=[];if(o>0)throw new en("Verbose mode is not implemented yet.");if(null!=s)throw new en("steps mode in testLoop() is not implemented yet");{const u=qD(a,i),p=So(ca(0,a));for(let m=0;m<u.length;++m){const g=u[m][0],_=u[m][1],x=ju(p,g,_-g),T=WD(r,x),I=e(T);if(0===m)for(let N=0;N<I.length;++N)c.push(Ft(0));for(let N=0;N<I.length;++N)c[N]=Xe(c[N],fe(_-g,I[N]))}for(let m=0;m<c.length;++m)c[m]=Nt(c[m],a)}return c})}getDedupedMetricsNames(){const e=this.metricsNames,r=[];for(let i=0;i<e.length;++i){const o=e[i];let s=o;JV(e,o)>1&&(s+=`_${JV(e.slice(0,i),o)}`),r.push(s)}return r}makeTrainFunction(){return e=>{const r=[],i=e.slice(0,this.inputs.length),o=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),s=e.slice(this.inputs.length+this.outputs.length,this.inputs.length+2*this.outputs.length),a=[],u=this.collectedTrainableWeights.map(g=>g.read());return[this.optimizer_.minimize(()=>{const g=[];for(let I=0;I<this.inputs.length;++I)g.push({key:this.inputs[I],value:i[I]});const _=new Ac(g),x=Dg(this.outputs,_,{training:!0});let T;for(let I=0;I<this.lossFunctions.length;++I){let R=(0,this.lossFunctions[I])(o[I],x[I]);null!=s[I]&&(R=Dfe(R,s[I]));const L=Sr(R);r.push(L),T=0===I?R:Xe(T,R)}for(let I=0;I<this.metricsTensors.length;++I){let N;if(this.outputs.length>1&&I<this.outputs.length)N=r[I];else{const L=this.metricsTensors[I][1];N=Sr((0,this.metricsTensors[I][0])(o[L],x[L]))}fi(N),a.push(N)}return T=Sr(T),this.calculateLosses().forEach(I=>{T=Xe(T,I)}),T},!0,u)].concat(a)}}makeTestFunction(){this.testFunction=e=>Se(()=>{const r=[];let i;const o=e.slice(0,this.inputs.length),s=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),a=[];for(let p=0;p<this.inputs.length;++p)a.push({key:this.inputs[p],value:o[p]});const c=new Ac(a),u=Dg(this.outputs,c);for(let p=0;p<this.lossFunctions.length;++p){const g=Sr((0,this.lossFunctions[p])(s[p],u[p]));i=0===p?g:Xe(i,g),r.push(i)}for(let p=0;p<this.metricsTensors.length;++p){const g=this.metricsTensors[p][1],_=Sr((0,this.metricsTensors[p][0])(s[g],u[g]));r.push(_)}return r})}fit(e,r,i={}){var o=this;return $e(function*(){if(o.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");let s,a,c,u,p,m,g,_,x;o.isTraining=!0;try{const T=null==i.batchSize?32:i.batchSize;HD(T);const I=!1,N=yield o.standardizeUserData(e,r,i.sampleWeight,i.classWeight,I,T);s=N[0],a=N[1],x=N[2];let L,R=!1;if(null!=i.validationData&&i.validationData.length>0){if(R=!0,2!==i.validationData.length)throw 3===i.validationData.length?new en("validationData including sample weights is not supported yet."):new ye(`When passing validation data, it must contain 2 (valX, valY) or 3 (valX, valY, valSampleWeight) items; ${i.validationData} is invalid.`);p=i.validationData[0],m=i.validationData[1];const we=!0,Ee=yield o.standardizeUserData(p,m,null,null,we,T);g=Ee[0],_=Ee[1],L=g.concat(_)}else if(null!=i.validationSplit&&i.validationSplit>0&&i.validationSplit<1){R=!0;const we=Math.floor(s[0].shape[0]*(1-i.validationSplit)),Ee=s[0].shape[0];g=Ng(s,we,Ee),c=s,s=Ng(s,0,we),_=Ng(a,we,Ee),u=a,a=Ng(a,0,we),L=g.concat(_)}else null!=i.validationSteps&&(R=!0);const V=s.concat(a).concat(x);o.checkTrainableWeightsConsistency();const j=o.makeTrainFunction(),Y=o.getDedupedMetricsNames();let ee,ie;R?(o.makeTestFunction(),ee=o.testFunction,ie=Y.slice().concat(Y.map(we=>"val_"+we))):(ee=null,L=[],ie=Y.slice());const ce=D4(i.callbacks,i.yieldEvery);return yield o.fitLoop(j,V,Y,T,i.epochs,i.verbose,ce,ee,L,i.shuffle,ie,i.initialEpoch,null,null)}finally{o.isTraining=!1,pa(s,e),pa(a,r),pa(c,e),pa(u,r),pa(g,p),pa(_,m),null!=x&&un(x)}})()}fitLoop(e,r,i,o,s,a,c,u,p,m,g,_,x,T){var I=this;return $e(function*(){null==o&&(o=32),null==s&&(s=1),null==m&&(m=!0),null==_&&(_=0);let N=!1;if(null!=u&&null!=p&&(N=!0),null!=T&&(N=!0,null==x))throw new ye("Can only use `validationSteps` when doing step-wise training, i.e., `stepsPerEpoch` must be set.");const R=I.checkNumSamples(r,o,x,"steps_per_epoch");let L;null!=R&&(L=ca(0,R)),null==a&&(a=1);const{callbackList:V,history:j}=k4(c,a,s,_,R,x,o,N,g);V.setModel(I),I.history=j,yield V.onTrainBegin(),I.stopTraining_=!1;for(let Y=_;Y<s;++Y){yield V.onEpochBegin(Y);const ee={};if(null!=x)throw new en("stepsPerEpoch mode is not implemented yet.");{if("batch"===m)throw new en("batch shuffling is not implemneted yet");m&&WL(L);const ie=So(L),ce=qD(R,o);for(let he=0;he<ce.length;++he){const we={};if(yield V.onBatchBegin(he,we),Se(()=>{const Ee=ce[he][0],Ae=ce[he][1],Oe=ju(ie,Ee,Ae-Ee);we.batch=he,we.size=Ae-Ee;const Re=WD(r,Oe),_e=e(Re);for(let Te=0;Te<i.length;++Te){const De=_e[Te];we[i[Te]]=De,fi(De)}if(he===ce.length-1&&N){const Te=I.testLoop(u,p,o);for(let xe=0;xe<i.length;++xe){const De=i[xe],je=Te[xe];fi(je),ee["val_"+De]=je}}}),yield V.onBatchEnd(he,we),E4(we),I.stopTraining_)break}ie.dispose()}if(yield V.onEpochEnd(Y,ee),I.stopTraining_)break}return yield V.onTrainEnd(),yield I.history.syncData(),I.history})()}fitDataset(e,r){var i=this;return $e(function*(){return function Nfe(n,t,e){return jD.apply(this,arguments)}(i,e,r)})()}trainOnBatch(e,r){var i=this;return $e(function*(){const o=yield i.standardizeUserData(e,r),s=o[0],a=o[1],u=i.makeTrainFunction()(s.concat(a)),p=[];for(const m of u){const g=yield m.data();p.push(g[0])}return un(u),pa(o[0],e),pa(o[1],r),Co(p)})()}getNamedWeights(e){const r=[],i=null!=e&&e.trainableOnly,o=i?this.trainableWeights:this.weights,s=this.getWeights(i);for(let a=0;a<o.length;++a)i&&!o[a].trainable||r.push({name:o[a].originalName,tensor:s[a]});return r}set stopTraining(e){this.stopTraining_=e}get stopTraining(){return this.stopTraining_}get optimizer(){return this.optimizer_}set optimizer(e){this.optimizer_!==e&&(this.optimizer_=e,this.isOptimizerOwned=!1)}dispose(){const e=super.dispose();if(0===e.refCountAfterDispose&&null!=this.optimizer&&this.isOptimizerOwned){const r=WI().numTensors;this.optimizer_.dispose(),e.numDisposedVariables+=r-WI().numTensors}return e}getLossIdentifiers(){let e;if("string"==typeof this.loss)e=El(this.loss);else if(Array.isArray(this.loss)){for(const r of this.loss)if("string"!=typeof r)throw new Error("Serialization of non-string loss is not supported.");e=this.loss.map(r=>El(r))}else{const r=Object.keys(this.loss);e={};const i=this.loss;for(const o of r){if("string"!=typeof i[o])throw new Error("Serialization of non-string loss is not supported.");e[o]=El(i[o])}}return e}getMetricIdentifiers(){if("string"==typeof this.metrics||"function"==typeof this.metrics)return[El(zv(this.metrics))];if(Array.isArray(this.metrics))return this.metrics.map(e=>El(zv(e)));{const e={};for(const r in this.metrics)e[r]=El(zv(this.metrics[r]));return e}}getTrainingConfig(){return{loss:this.getLossIdentifiers(),metrics:this.getMetricIdentifiers(),optimizer_config:{class_name:this.optimizer.getClassName(),config:this.optimizer.getConfig()}}}loadTrainingConfig(e){if(null!=e.weighted_metrics)throw new Error("Loading weight_metrics is not supported yet.");if(null!=e.loss_weights)throw new Error("Loading loss_weights is not supported yet.");if(null!=e.sample_weight_mode)throw new Error("Loading sample_weight_mode is not supported yet.");const i=Dl(BD(e.optimizer_config));let o,s;if("string"==typeof e.loss)o=Vu(e.loss);else if(Array.isArray(e.loss))o=e.loss.map(a=>Vu(a));else if(null!=e.loss){o={};for(const a in e.loss)o[a]=Vu(e.loss[a])}if(Array.isArray(e.metrics))s=e.metrics.map(a=>Vu(a));else if(null!=e.metrics){s={};for(const a in e.metrics)s[a]=Vu(e.metrics[a])}this.compile({loss:o,metrics:s,optimizer:i})}save(e,r){var i=this;return $e(function*(){if("string"==typeof e){const m=k3(e);if(0===m.length)throw new ye(`Cannot find any save handlers for URL '${e}'`);if(m.length>1)throw new ye(`Found more than one (${m.length}) save handlers for URL '${e}'`);e=m[0]}if(null==e.save)throw new ye("LayersModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");const o=yield OI(i.getNamedWeights(r)),u={modelTopology:i.toJSON(null,!1),format:"layers-model",generatedBy:"TensorFlow.js tfjs-layers v4.5.0",convertedBy:null};if(null!=r&&r.includeOptimizer&&null!=i.optimizer){u.trainingConfig=i.getTrainingConfig();const m="optimizer",{data:g,specs:_}=yield OI(yield i.optimizer.getWeights(),m);o.specs.push(..._),o.data=H0([o.data,g])}return null!=i.userDefinedMetadata&&($4(i.userDefinedMetadata,i.name,!0),u.userDefinedMetadata=i.userDefinedMetadata),u.weightData=o.data,u.weightSpecs=o.specs,e.save(u)})()}setUserDefinedMetadata(e){$4(e,this.name),this.userDefinedMetadata=e}getUserDefinedMetadata(){return this.userDefinedMetadata}}return n.className="Model",n})();Ye(Wh),Ye((()=>{class n extends Wh{}return n.className="Functional",n})()),Ye((()=>{class n extends Wh{constructor(e){if(super({inputs:[],outputs:[]}),e=e||{},this.trainable=!0,this.built=!1,this.name=null!=e.name?e.name:Cv("sequential_"),null!=e.layers)for(const r of e.layers)this.add(r)}checkShape(e){if(e.inboundNodes[0].outputTensors[0].shape.some(i=>i<0))throw new ye(`Negative dimension size caused by adding layer ${e.name} with input shape [${e.inboundNodes[0].inputTensors[0].shape}]`)}add(e){const r=e instanceof n||e instanceof Wh;let i;if(r){if(i=e,1!==i.outputs.length)throw new ye("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");if(1!==i.inputs.length)throw new ye("All layers in a Sequential model should have a single input tensor. For multi-input layers, use the functional API.")}if(0===this.outputs.length){if(0===e.inboundNodes.length){if(null==e.batchInputShape)throw new ye("The first layer in a Sequential model must get an `inputShape` or `batchInputShape` argument.");const o=function jpe(n){if(null==n.batchShape&&null==n.shape)throw new Error("Please provide to Input either a `shape` or a `batchShape` argument. Note that `shape` does not include the batch dimension.");if(null!=n.batchShape&&null!=n.shape)throw new ye("Please provide either a `shape` or `batchShape` argument to Input, but not both.");let t=n.batchShape;null!=n.shape&&null==t&&(t=[null].concat(n.shape));let e=n.dtype;return null==e&&(e="float32"),new Ov({batchInputShape:t,name:n.name,dtype:e,sparse:n.sparse}).inboundNodes[0].outputTensors[0]}({batchShape:e.batchInputShape,dtype:e.dtype,name:e.name+"_input"});e.apply(o)}if(r)this.outputs=i.outputs,this.inputs=i.inputs;else{if(1!==e.inboundNodes.length)throw new ye(`A layer added to a Sequential model must not already be connected somewhere else. LayersModel received layer ${e.name} which has ${e.inboundNodes.length} pre-existing inbound connections.`);if(1!==e.inboundNodes[0].outputTensors.length)throw new ye("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(e),this.outputs=[e.inboundNodes[0].outputTensors[0]],this.inputs=T4(this.outputs[0])}this.inboundNodes=[],new Nv({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:Bu(null,this.inputs.length),outputMasks:[null],inputShapes:this.inputs.map(o=>o.shape),outputShapes:this.outputs[0].shape})}else{const o=e.apply(this.outputs[0]);if(Array.isArray(o))throw new TypeError("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(e),this.outputs=[o],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}this.layers.push(e),this.built=!1}pop(){if(0===this.layers.length)throw new TypeError("There are no layers in the model.");if(this.layers.pop(),0===this.layers.length)this.outputs=[],this.inboundNodes=[],this.outboundNodes=[];else{const e=this.layers.length-1;this.layers[e].outboundNodes=[],this.outputs=[this.layers[e].output],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}}call(e,r){return null==this.model&&this.build(),this.model.call(e,r)}build(e){if(Dn(e),0===this.inputs.length||0===this.outputs.length)throw new TypeError("Sequential model cannot be built: model is empty. Add some layers first.");this.model=new Wh({inputs:this.inputs,outputs:this.outputs[0],name:this.name+"_model"}),this.model.trainable=this.trainable,this.supportsMasking=this.model.supportsMasking,this.inputLayers=this.model.inputLayers,this.inputLayersNodeIndices=this.model.inputLayersNodeIndices,this.inputLayersTensorIndices=this.model.inputLayersTensorIndices,this.outputLayers=this.model.outputLayers,this.outputLayersNodeIndices=this.model.outputLayersNodeIndices,this.outputLayersTensorIndices=this.model.outputLayersTensorIndices,this.nodesByDepth=this.model.nodesByDepth,this.containerNodes=this.model.containerNodes,this.outputNames=this.model.outputNames,this.inputNames=this.model.inputNames,this.built=!0}countParams(){return this.built||this.build(),super.countParams()}summary(e,r,i=console.log){this.built||this.build(),super.summary(e,r,i)}setWeights(e){null==this.model&&this.build(),this.model.setWeights(e)}evaluate(e,r,i={}){if(!this.built)throw new Ls("The model needs to be compiled before being used.");return this.model.evaluate(e,r,i)}evaluateDataset(e,r){var i=this;return $e(function*(){if(!i.built)throw new Ls("The model needs to be compiled before being used.");return i.model.evaluateDataset(e,r)})()}predict(e,r={}){return null==this.model&&this.build(),this.model.predict(e,r)}predictOnBatch(e){return null==this.model&&this.build(),this.model.predictOnBatch(e)}compile(e){this.build(),this.model.compile(e),this.optimizer_=this.model.optimizer,this.isOptimizerOwned=this.model.isOptimizerOwned,this.loss=this.model.loss,this.metrics=this.model.metrics,this.metricsTensors=this.model.metricsTensors,this.metricsNames=this.model.metricsNames}get optimizer(){return null==this.model?void 0:this.model.optimizer}set optimizer(e){this.model.optimizer=e}fit(e,r,i={}){var o=this;return $e(function*(){if(!o.built)throw new Ls("The model needs to be compiled before being used.");return o.model.fit(e,r,i)})()}fitDataset(e,r){var i=this;return $e(function*(){if(!i.built)throw new Ls("The model needs to be compiled before being used.");return i.model.fitDataset(e,r)})()}trainOnBatch(e,r){var i=this;return $e(function*(){return i.model.trainOnBatch(e,r)})()}static fromConfig(e,r,i={},o=!1){let s,a={};if(r instanceof Array){if(null==r[0].className||"Merge"===r[0].className)throw new ye("Legacy serialization format not supported yet.");s=r}else Z(null!=r.layers,()=>"When the config data for a Sequential model is not an Array, it must be an Object that contains the 'layers' field."),s=r.layers,delete r.layers,a=r;const c=new e(a);if(!(c instanceof n))throw new en(`Sequential.fromConfig called on non-Sequential input: ${c}`);for(const u of s){const m=Dl(u,void 0,o);o&&m.setFastWeightInitDuringBuild(!0),c.add(m)}return c}set stopTraining(e){if(null==this.model)throw new ye("Cannot set the stopTraining property of a sequential model before it is compiled.");this.model.stopTraining=e}get stopTraining(){if(null==this.model)throw new ye("Cannot get the stopTraining property of a sequential model before it is compiled.");return this.model.stopTraining}getConfig(){const e=[];for(const r of this.layers){const i={};i.className=r.getClassName(),i.config=r.getConfig(),e.push(i)}return{name:this.name,layers:e}}}return n.className="Sequential",n})());class Io extends kh{getConfig(){return{}}}Ye((()=>{class n extends Io{apply(e,r=1){return function Ape(n,t=1){if(1!==t)throw new en(`Support for alpha values other than 1 (${t}) is not implemented yet.`);return dg(n)}(e,r)}}return n.className="elu",n})()),Ye((()=>{class n extends Io{apply(e){return kE(e)}}return n.className="selu",n})()),Ye((()=>{class n extends Io{apply(e){return La(e)}}return n.className="relu",n})()),Ye((()=>{class n extends Io{apply(e){return Se(()=>Fu(6,La(e)))}}return n.className="relu6",n})()),Ye((()=>{class n extends Io{apply(e){return e}}return n.className="linear",n})()),Ye((()=>{class n extends Io{apply(e){return Pa(e)}}return n.className="sigmoid",n})()),Ye((()=>{class n extends Io{apply(e){return function Ope(n){return Se(()=>{const t=Xe(.5,fe(.2,n));return Uo(t,0,1)})}(e)}}return n.className="hardSigmoid",n})()),Ye((()=>{class n extends Io{apply(e){return Ph(e)}}return n.className="softplus",n})()),Ye((()=>{class n extends Io{apply(e){return function Npe(n){return Se(()=>Nt(n,Xe(ei(n),1)))}(e)}}return n.className="softsign",n})()),Ye((()=>{class n extends Io{apply(e){return Mh(e)}}return n.className="tanh",n})());let X4=(()=>{class n extends Io{apply(e,r=-1){return pv(e,r)}}return n.className="softmax",n})();function Oc(n){return n.getClassName()}function QD(n,t={}){return Tg(n,Os.getMap().classNameMap,t,"activation")}function Rc(n){if(null==n){return QD({className:"linear",config:{}})}if("string"==typeof n){const t={};return t.className=n,t.config={},QD(t)}return n instanceof Io?n:QD(n)}Ye(X4),Ye((()=>{class n extends Io{apply(e,r=-1){return yE(e,r)}}return n.className="logSoftmax",n})()),Ye((()=>{class n extends Io{apply(e,r=1){return Se(()=>fe(Pa(fe(e,r)),e))}}return n.className="swish",n})()),Ye((()=>{class n extends Io{apply(e){return Se(()=>fe(e,Mh(Ph(e))))}}return n.className="mish",n})());class Y4 extends kh{}Ye((()=>{class n extends Y4{constructor(e){super(),function JD(n){if(null!=n&&"object"!=typeof n)throw new Error(`Argument to L1L2 regularizer's constructor is expected to be an object, but received: ${n}`)}(e),this.l1=null==e||null==e.l1?.01:e.l1,this.l2=null==e||null==e.l2?.01:e.l2,this.hasL1=0!==this.l1,this.hasL2=0!==this.l2}apply(e){return Se(()=>{let r=ni([1]);return this.hasL1&&(r=Xe(r,St(fe(this.l1,ei(e))))),this.hasL2&&(r=Xe(r,St(fe(this.l2,Ig(e))))),be(r,[])})}getConfig(){return{l1:this.l1,l2:this.l2}}static fromConfig(e,r){return new e({l1:r.l1,l2:r.l2})}}return n.className="L1L2",n})());const Z4={l1l2:"L1L2"};function Wn(n){return TD(n)}function Q4(n,t={}){return Tg(n,Os.getMap().classNameMap,t,"regularizer")}function lr(n){return null==n?null:"string"==typeof n?Q4({className:n in Z4?Z4[n]:n,config:{}}):n instanceof Y4?n:Q4(n)}function qh(n,t,e){if("number"==typeof n)return Bu(n,t);if(n.length!==t)throw new ye(`The ${e} argument must be an integer or tuple of ${t} integers. Received: ${n.length} elements.`);for(let r=0;r<t;++r){const i=n[r];if(!Spe(i))throw new ye(`The ${e} argument must be an integer or tuple of ${t} integers. Received: ${JSON.stringify(n)} including a non-integer number ${i}`)}return n}function fa(n,t,e,r,i=1){if(null==n)return n;let s;return s="same"===e?n:n-(t+(t-1)*(i-1))+1,Math.floor((s+r-1)/r)}function Wa(n,t,e,r){if(null==n)return null;if("valid"===r)n=n*t+kc([e-t,0]);else{if("same"!==r)throw new ye(`Unsupport padding mode: ${r}.`);n*=t}return n}function tk(n,t){return Se(()=>(Fr(t),"channelsFirst"===t?wn(n,[0,2,3,1]):n))}function J4(n,t){return Se(()=>(Fr(t),"channelsFirst"===t?wn(n,[0,2,3,4,1]):n))}function nk(n,t,e,r=[1,1],i="valid",o,s,a=null){return Se(()=>{if(null==o&&(o="channelsLast"),Fr(o),3!==n.rank&&4!==n.rank)throw new ye(`conv2dWithBiasActivation expects input to be of rank 3 or 4, but received ${n.rank}.`);if(3!==t.rank&&4!==t.rank)throw new ye(`conv2dWithBiasActivation expects kernel to be of rank 3 or 4, but received ${n.rank}.`);let c=tk(n,o);if("causal"===i)throw new en("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");return c=sV({x:c,filter:t,strides:r,pad:"same"===i?"same":"valid",dilations:s,dataFormat:"NHWC",bias:e,activation:a}),"channelsFirst"===o&&(c=wn(c,[0,3,1,2])),c})}Ye((()=>{class n extends dn{constructor(e){super(e??{}),this.supportsMasking=!0,null!=e&&(this.maxValue=e.maxValue)}call(e,r){e=zt(e);let i=La(e);return null!=this.maxValue&&(i=Uo(i,0,this.maxValue)),i}computeOutputShape(e){return e}getConfig(){const e={maxValue:this.maxValue},r=super.getConfig();return Object.assign(e,r),e}}return n.className="ReLU",n})()),Ye((()=>{class n extends dn{constructor(e){super(e??{}),this.DEFAULT_ALPHA=.3,null==e&&(e={}),this.alpha=null==e.alpha?this.DEFAULT_ALPHA:e.alpha}call(e,r){const i=zt(e);return nv(i,this.alpha)}computeOutputShape(e){return e}getConfig(){const e={alpha:this.alpha},r=super.getConfig();return Object.assign(e,r),e}}return n.className="LeakyReLU",n})()),Ye((()=>{class n extends dn{constructor(e){if(super(e??{}),this.DEFAULT_ALPHA_INITIALIZER="zeros",null==e&&(e={}),this.supportsMasking=!0,this.alphaInitializer=ar(e.alphaInitializer||this.DEFAULT_ALPHA_INITIALIZER),this.alphaRegularizer=lr(e.alphaRegularizer),this.alphaConstraint=si(e.alphaConstraint),null==e.sharedAxes)this.sharedAxes=null;else if(Array.isArray(e.sharedAxes))this.sharedAxes=e.sharedAxes;else{if("number"!=typeof e.sharedAxes)throw new ye(`Expected sharedAxes to be a number or an array of numbers, but got ${e.sharedAxes}`);this.sharedAxes=[e.sharedAxes]}}build(e){const r=(e=Dn(e)).slice(1);if(null!=this.sharedAxes)for(const o of this.sharedAxes)r[o-1]=1;this.alpha=this.addWeight("alpha",r,"float32",this.alphaInitializer,this.alphaRegularizer,!0,this.alphaConstraint);const i={};if(null!=this.sharedAxes)for(let o=1;o<e.length;++o)i[o]=e[o];this.inputSpec=[new ii({ndim:e.length,axes:i})],this.built=!0}call(e,r){return e=zt(e),cv(e,this.alpha.read())}getConfig(){const e={alphaInitializer:mr(this.alphaInitializer),alphaRegularizer:Wn(this.alphaRegularizer),alphaConstraint:oi(this.alphaConstraint),sharedAxes:this.sharedAxes},r=super.getConfig();return Object.assign(e,r),e}}return n.className="PReLU",n})()),Ye((()=>{class n extends dn{constructor(e){if(super(e??{}),this.DEFAULT_ALPHA=1,null==e&&(e={}),null!=e.alpha&&e.alpha!==this.DEFAULT_ALPHA)throw new en(`Non-default alpha value (${e.alpha}) is not supported by the ELU layer yet.`);this.alpha=null==e.alpha?this.DEFAULT_ALPHA:e.alpha}call(e,r){const i=zt(e);return dg(i)}computeOutputShape(e){return e}getConfig(){const e={alpha:this.alpha},r=super.getConfig();return Object.assign(e,r),e}}return n.className="ELU",n})()),Ye((()=>{class n extends dn{constructor(e){super(e??{}),this.DEFAULT_THETA=1,null==e&&(e={}),this.theta=null==e.theta?this.DEFAULT_THETA:e.theta}call(e,r){const i=zt(e);return fe(i,ht(jo(i,this.theta),"float32"))}computeOutputShape(e){return e}getConfig(){const e={theta:this.theta},r=super.getConfig();return Object.assign(e,r),e}}return n.className="ThresholdedReLU",n})()),Ye((()=>{class n extends dn{constructor(e){super(e??{}),this.DEFAULT_AXIS=1,null==e&&(e={}),this.softmax=(new X4).apply,this.axis=null==e.axis?this.DEFAULT_AXIS:e.axis}call(e,r){const i=zt(e);return this.softmax(i,this.axis)}computeOutputShape(e){return e}getConfig(){const e={axis:this.axis},r=super.getConfig();return Object.assign(e,r),e}}return n.className="Softmax",n})());class jv extends dn{constructor(t,e){if(super(e),this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",jv.verifyArgs(e),this.rank=t,bi(this.rank,"rank"),1!==this.rank&&2!==this.rank&&3!==this.rank)throw new en(`Convolution layer for rank other than 1, 2, or 3 (${this.rank}) is not implemented yet.`);if(this.kernelSize=qh(e.kernelSize,t,"kernelSize"),this.strides=qh(null==e.strides?1:e.strides,t,"strides"),this.padding=null==e.padding?"valid":e.padding,fs(this.padding),this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,Fr(this.dataFormat),this.activation=Rc(e.activation),this.useBias=null==e.useBias||e.useBias,this.biasInitializer=ar(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.biasConstraint=si(e.biasConstraint),this.biasRegularizer=lr(e.biasRegularizer),this.activityRegularizer=lr(e.activityRegularizer),this.dilationRate=qh(null==e.dilationRate?1:e.dilationRate,t,"dilationRate"),1===this.rank&&Array.isArray(this.dilationRate)&&1!==this.dilationRate.length)throw new ye(`dilationRate must be a number or an array of a single number for 1D convolution, but received ${JSON.stringify(this.dilationRate)}`);if(2===this.rank){if("number"==typeof this.dilationRate)this.dilationRate=[this.dilationRate,this.dilationRate];else if(2!==this.dilationRate.length)throw new ye(`dilationRate must be a number or array of two numbers for 2D convolution, but received ${JSON.stringify(this.dilationRate)}`)}else if(3===this.rank)if("number"==typeof this.dilationRate)this.dilationRate=[this.dilationRate,this.dilationRate,this.dilationRate];else if(3!==this.dilationRate.length)throw new ye(`dilationRate must be a number or array of three numbers for 3D convolution, but received ${JSON.stringify(this.dilationRate)}`)}static verifyArgs(t){if(ps("kernelSize"in t,"required key 'kernelSize' not in config"),"number"!=typeof t.kernelSize&&!CD(t.kernelSize,"number",1,3))throw new ye(`BaseConv expects config.kernelSize to be number or number[] with length 1, 2, or 3, but received ${JSON.stringify(t.kernelSize)}.`)}getConfig(){const t={kernelSize:this.kernelSize,strides:this.strides,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,activation:Oc(this.activation),useBias:this.useBias,biasInitializer:mr(this.biasInitializer),biasRegularizer:Wn(this.biasRegularizer),activityRegularizer:Wn(this.activityRegularizer),biasConstraint:oi(this.biasConstraint)},e=super.getConfig();return Object.assign(t,e),t}}class Kh extends jv{constructor(t,e){super(t,e),this.kernel=null,Kh.verifyArgs(e),this.filters=e.filters,bi(this.filters,"filters"),this.kernelInitializer=ar(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.kernelConstraint=si(e.kernelConstraint),this.kernelRegularizer=lr(e.kernelRegularizer)}build(t){t=Dn(t);const e="channelsFirst"===this.dataFormat?1:t.length-1;if(null==t[e])throw new ye(`The channel dimension of the input should be defined. Found ${t[e]}`);const r=t[e],i=this.kernelSize.concat([r,this.filters]);this.kernel=this.addWeight("kernel",i,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[{ndim:this.rank+2,axes:{[e]:r}}],this.built=!0}call(t,e){return Se(()=>{let r;t=zt(t);const i=null==this.bias?null:this.bias.read(),o=t4(this.activation.getClassName());if(null!=o&&2===this.rank)r=nk(t,this.kernel.read(),i,this.strides,this.padding,this.dataFormat,this.dilationRate,o);else{if(1===this.rank)r=function ez(n,t,e,r=1,i="valid",o,s=1){return Se(()=>{if(null==o&&(o="channelsLast"),Fr(o),3!==n.shape.length)throw new ye(`The input of a conv1dWithBias operation should be 3, but is ${n.shape.length} instead.`);if(3!==t.shape.length)throw new ye(`The kernel for a conv1dWithBias operation should be 3, but is ${t.shape.length} instead`);if(null!=e&&1!==e.shape.length)throw new ye(`The bias for a conv1dWithBias operation should be 1, but is ${t.shape.length} instead`);if("channelsFirst"===o&&(n=wn(n,[0,2,1])),"causal"===i)throw new en("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");let a=uE(n,t,r,"same"===i?"same":"valid","NWC",s);return null!=e&&(a=da(a,e)),a})}(t,this.kernel.read(),i,this.strides[0],this.padding,this.dataFormat,this.dilationRate[0]);else if(2===this.rank)r=nk(t,this.kernel.read(),i,this.strides,this.padding,this.dataFormat,this.dilationRate);else{if(3!==this.rank)throw new en("convolutions greater than 3D are not implemented yet.");r=function tz(n,t,e,r=[1,1,1],i="valid",o,s){return Se(()=>{if(null==o&&(o="channelsLast"),Fr(o),4!==n.rank&&5!==n.rank)throw new ye(`conv3dWithBias expects input to be of rank 4 or 5, but received ${n.rank}.`);if(4!==t.rank&&5!==t.rank)throw new ye(`conv3dWithBias expects kernel to be of rank 4 or 5, but received ${n.rank}.`);let a=J4(n,o);if("causal"===i)throw new en("The support for CAUSAL padding mode in conv3dWithBias is not implemented yet.");return a=IB(a,t,r,"same"===i?"same":"valid","NDHWC",s),null!=e&&(a=da(a,e)),"channelsFirst"===o&&(a=wn(a,[0,4,1,2,3])),a})}(t,this.kernel.read(),i,this.strides,this.padding,this.dataFormat,this.dilationRate)}null!=this.activation&&(r=this.activation.apply(r))}return r})}computeOutputShape(t){t=Dn(t);const e=[],r="channelsLast"===this.dataFormat?t.slice(1,t.length-1):t.slice(2);for(let o=0;o<r.length;++o){const s=fa(r[o],this.kernelSize[o],this.padding,this.strides[o],"number"==typeof this.dilationRate?this.dilationRate:this.dilationRate[o]);e.push(s)}let i=[t[0]];return"channelsLast"===this.dataFormat?(i=i.concat(e),i.push(this.filters)):(i.push(this.filters),i=i.concat(e)),i}getConfig(){const t={filters:this.filters,kernelInitializer:mr(this.kernelInitializer),kernelRegularizer:Wn(this.kernelRegularizer),kernelConstraint:oi(this.kernelConstraint)},e=super.getConfig();return Object.assign(t,e),t}static verifyArgs(t){if(!("filters"in t)||"number"!=typeof t.filters||t.filters<1)throw new ye(`Convolution layer expected config.filters to be a 'number' > 0 but got ${JSON.stringify(t.filters)}`)}}let nz=(()=>{class n extends Kh{constructor(e){super(2,e),n.verifyArgs(e)}getConfig(){const e=super.getConfig();return delete e.rank,e}static verifyArgs(e){if("number"!=typeof e.kernelSize&&!CD(e.kernelSize,"number",1,2))throw new ye(`Conv2D expects config.kernelSize to be number or number[] with length 1 or 2, but received ${JSON.stringify(e.kernelSize)}.`)}}return n.className="Conv2D",n})();Ye(nz);let rz=(()=>{class n extends Kh{constructor(e){super(3,e),n.verifyArgs(e)}getConfig(){const e=super.getConfig();return delete e.rank,e}static verifyArgs(e){if("number"!=typeof e.kernelSize&&(!Array.isArray(e.kernelSize)||1!==e.kernelSize.length&&3!==e.kernelSize.length))throw new ye(`Conv3D expects config.kernelSize to be number or [number, number, number], but received ${JSON.stringify(e.kernelSize)}.`)}}return n.className="Conv3D",n})();Ye(rz),Ye((()=>{class n extends nz{constructor(e){if(super(e),this.inputSpec=[new ii({ndim:4})],"same"!==this.padding&&"valid"!==this.padding)throw new ye(`Conv2DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(e){if(4!==(e=Dn(e)).length)throw new ye("Input should have rank 4; Received input shape: "+JSON.stringify(e));const r="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[r])throw new ye("The channel dimension of the inputs should be defined. Found `None`.");const i=e[r],o=this.kernelSize.concat([this.filters,i]);this.kernel=this.addWeight("kernel",o,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new ii({ndim:4,axes:{[r]:i}})],this.built=!0}call(e,r){return Se(()=>{let i=zt(e);if(4!==i.shape.length)throw new ye(`Conv2DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${i.shape.length}`);const o=i.shape;let a,c;"channelsFirst"===this.dataFormat?(a=2,c=3):(a=1,c=2);const p=o[c],g=this.kernelSize[1],x=this.strides[1],N=[o[0],Wa(o[a],this.strides[0],this.kernelSize[0],this.padding),Wa(p,x,g,this.padding),this.filters];"channelsLast"!==this.dataFormat&&(i=wn(i,[0,2,3,1]));let R=hE(i,this.kernel.read(),N,this.strides,this.padding);return"channelsLast"!==this.dataFormat&&(R=wn(R,[0,3,1,2])),null!=this.bias&&(R=da(R,this.bias.read(),this.dataFormat)),null!=this.activation&&(R=this.activation.apply(R)),R})}computeOutputShape(e){const r=(e=Dn(e)).slice();let i,o,s;"channelsFirst"===this.dataFormat?(i=1,o=2,s=3):(i=3,o=1,s=2);const a=this.kernelSize[0],c=this.kernelSize[1],u=this.strides[0],p=this.strides[1];return r[i]=this.filters,r[o]=Wa(r[o],u,a,this.padding),r[s]=Wa(r[s],p,c,this.padding),r}getConfig(){const e=super.getConfig();return delete e.dilationRate,e}}return n.className="Conv2DTranspose",n})()),Ye((()=>{class n extends rz{constructor(e){if(super(e),this.inputSpec=[new ii({ndim:5})],"same"!==this.padding&&"valid"!==this.padding)throw new ye(`Conv3DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(e){if(5!==(e=Dn(e)).length)throw new ye("Input should have rank 5; Received input shape: "+JSON.stringify(e));const r="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[r])throw new ye("The channel dimension of the inputs should be defined. Found `None`.");const i=e[r],o=this.kernelSize.concat([this.filters,i]);this.kernel=this.addWeight("kernel",o,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new ii({ndim:5,axes:{[r]:i}})],this.built=!0}call(e,r){return Se(()=>{let i=zt(e);if(5!==i.shape.length)throw new ye(`Conv3DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${i.shape.length}`);const o=i.shape;let a,c,u;"channelsFirst"===this.dataFormat?(u=2,a=3,c=4):(u=1,a=2,c=3);const m=o[a],g=o[c],x=this.kernelSize[1],T=this.kernelSize[2],N=this.strides[1],R=this.strides[2],Y=[o[0],Wa(o[u],this.strides[0],this.kernelSize[0],this.padding),Wa(m,N,x,this.padding),Wa(g,R,T,this.padding),this.filters];"channelsLast"!==this.dataFormat&&(i=wn(i,[0,2,3,4,1]));let ee=DB(i,this.kernel.read(),Y,this.strides,this.padding);return"channelsLast"!==this.dataFormat&&(ee=wn(ee,[0,4,1,2,3])),null!==this.bias&&(ee=da(ee,this.bias.read(),this.dataFormat)),null!==this.activation&&(ee=this.activation.apply(ee)),ee})}computeOutputShape(e){const r=(e=Dn(e)).slice();let i,o,s,a;"channelsFirst"===this.dataFormat?(i=1,o=2,s=3,a=4):(i=4,o=1,s=2,a=3);const c=this.kernelSize[0],u=this.kernelSize[1],p=this.kernelSize[2],m=this.strides[0],g=this.strides[1],_=this.strides[2];return r[i]=this.filters,r[o]=Wa(r[o],m,c,this.padding),r[s]=Wa(r[s],g,u,this.padding),r[a]=Wa(r[a],_,p,this.padding),r}getConfig(){const e=super.getConfig();return delete e.dilationRate,e}}return n.className="Conv3DTranspose",n})());let Ufe=(()=>{class n extends Kh{constructor(e,r){if(super(e,r),this.DEFAULT_DEPTHWISE_INITIALIZER="glorotUniform",this.DEFAULT_POINTWISE_INITIALIZER="glorotUniform",this.depthwiseKernel=null,this.pointwiseKernel=null,null==r.filters)throw new ye("The `filters` configuration field is required by SeparableConv, but is unspecified.");if(null!=r.kernelInitializer||null!=r.kernelRegularizer||null!=r.kernelConstraint)throw new ye("Fields kernelInitializer, kernelRegularizer and kernelConstraint are invalid for SeparableConv2D. Use depthwiseInitializer, depthwiseRegularizer, depthwiseConstraint, pointwiseInitializer, pointwiseRegularizer and pointwiseConstraint instead.");if(null!=r.padding&&"same"!==r.padding&&"valid"!==r.padding)throw new ye(`SeparableConv${this.rank}D supports only padding modes: 'same' and 'valid', but received ${JSON.stringify(r.padding)}`);this.depthMultiplier=null==r.depthMultiplier?1:r.depthMultiplier,this.depthwiseInitializer=ar(r.depthwiseInitializer||this.DEFAULT_DEPTHWISE_INITIALIZER),this.depthwiseRegularizer=lr(r.depthwiseRegularizer),this.depthwiseConstraint=si(r.depthwiseConstraint),this.pointwiseInitializer=ar(r.depthwiseInitializer||this.DEFAULT_POINTWISE_INITIALIZER),this.pointwiseRegularizer=lr(r.pointwiseRegularizer),this.pointwiseConstraint=si(r.pointwiseConstraint)}build(e){if((e=Dn(e)).length<this.rank+2)throw new ye(`Inputs to SeparableConv${this.rank}D should have rank ${this.rank+2}, but received input shape: ${JSON.stringify(e)}`);const r="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[r]||e[r]<0)throw new ye(`The channel dimension of the inputs should be defined, but found ${JSON.stringify(e[r])}`);const i=e[r],o=this.kernelSize.concat([i,this.depthMultiplier]),s=[];for(let c=0;c<this.rank;++c)s.push(1);s.push(i*this.depthMultiplier,this.filters);const a=!0;this.depthwiseKernel=this.addWeight("depthwise_kernel",o,"float32",this.depthwiseInitializer,this.depthwiseRegularizer,a,this.depthwiseConstraint),this.pointwiseKernel=this.addWeight("pointwise_kernel",s,"float32",this.pointwiseInitializer,this.pointwiseRegularizer,a,this.pointwiseConstraint),this.bias=this.useBias?this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,a,this.biasConstraint):null,this.inputSpec=[new ii({ndim:this.rank+2,axes:{[r]:i}})],this.built=!0}call(e,r){return Se(()=>{let i;if(e=zt(e),1===this.rank)throw new en("1D separable convolution is not implemented yet.");return 2===this.rank&&("channelsFirst"===this.dataFormat&&(e=wn(e,[0,2,3,1])),i=AE(e,this.depthwiseKernel.read(),this.pointwiseKernel.read(),this.strides,this.padding,this.dilationRate,"NHWC")),this.useBias&&(i=da(i,this.bias.read(),this.dataFormat)),null!=this.activation&&(i=this.activation.apply(i)),"channelsFirst"===this.dataFormat&&(i=wn(i,[0,3,1,2])),i})}getConfig(){const e=super.getConfig();return delete e.rank,delete e.kernelInitializer,delete e.kernelRegularizer,delete e.kernelConstraint,e.depthwiseInitializer=mr(this.depthwiseInitializer),e.pointwiseInitializer=mr(this.pointwiseInitializer),e.depthwiseRegularizer=Wn(this.depthwiseRegularizer),e.pointwiseRegularizer=Wn(this.pointwiseRegularizer),e.depthwiseConstraint=oi(this.depthwiseConstraint),e.pointwiseConstraint=oi(this.pointwiseConstraint),e}}return n.className="SeparableConv",n})();function iz(n,t,e,r){if(Array.isArray(n)){if(null!=t||null!=e)throw new ye("When inputs is an array, neither initialState or constants should be provided");null!=r&&(e=n.slice(n.length-r,n.length),n=n.slice(0,n.length-r)),n.length>1&&(t=n.slice(1,n.length)),n=n[0]}function i(o){return null==o||Array.isArray(o)?o:[o]}return{inputs:n,initialState:t=i(t),constants:e=i(e)}}function oz(n,t,e,r=!1,i,o,s=!1,a=!1){return Se(()=>{const c=t.shape.length;if(c<3)throw new ye(`Input should be at least 3D, but is ${c}D.`);const u=[1,0].concat(ca(2,c));if(t=wn(t,u),null!=o)throw new en("The rnn() functoin of the deeplearn.js backend does not support constants yet.");s&&console.warn("Backend rnn(): the unroll = true option is not applicable to the imperative deeplearn.js backend."),null!=i&&((i=ht(ht(i,"bool"),"float32")).rank===c-1&&(i=To(i,-1)),i=wn(i,u)),r&&(t=Ps(t,0),null!=i&&(i=Ps(i,0)));const p=[];let m,g=e;const _=t.shape[0],x=$s(t);let T,I;null!=i&&(T=$s(i));for(let N=0;N<_;++N){const R=x[N],L=Se(()=>n(R,g));if(null==i)m=L[0],g=L[1];else{const V=Se(()=>{const j=T[N],Y=xt(ds(j),j);return{output:Xe(fe(L[0],j),fe(g[0],Y)),newStates:g.map((ce,he)=>Xe(fe(L[1][he],j),fe(ce,Y)))}});m=V.output,g=V.newStates}a&&p.push(m)}return a&&(I=hs(p,1)),[m,I,g]})}Ye((()=>{class n extends Ufe{constructor(e){super(2,e)}}return n.className="SeparableConv2D",n})()),Ye((()=>{class n extends Kh{constructor(e){super(1,e),n.verifyArgs(e),this.inputSpec=[{ndim:3}]}getConfig(){const e=super.getConfig();return delete e.rank,delete e.dataFormat,e}static verifyArgs(e){if("number"!=typeof e.kernelSize&&!CD(e.kernelSize,"number",1,1))throw new ye(`Conv1D expects config.kernelSize to be number or number[] with length 1, but received ${JSON.stringify(e.kernelSize)}.`)}}return n.className="Conv1D",n})()),Ye((()=>{class n extends dn{constructor(e){super(e),this.cropping="number"==typeof e.cropping?[[e.cropping,e.cropping],[e.cropping,e.cropping]]:"number"==typeof e.cropping[0]?[[e.cropping[0],e.cropping[0]],[e.cropping[1],e.cropping[1]]]:e.cropping,this.dataFormat=void 0===e.dataFormat?"channelsLast":e.dataFormat,this.inputSpec=[{ndim:4}]}computeOutputShape(e){return"channelsFirst"===this.dataFormat?[e[0],e[1],e[2]-this.cropping[0][0]-this.cropping[0][1],e[3]-this.cropping[1][0]-this.cropping[1][1]]:[e[0],e[1]-this.cropping[0][0]-this.cropping[0][1],e[2]-this.cropping[1][0]-this.cropping[1][1],e[3]]}call(e,r){return Se(()=>{if(e=zt(e),"channelsLast"===this.dataFormat){const i=Ev(e,this.cropping[0][0],e.shape[1]-this.cropping[0][0]-this.cropping[0][1],2);return Ev(i,this.cropping[1][0],e.shape[2]-this.cropping[1][1]-this.cropping[1][0],3)}{const i=Ev(e,this.cropping[0][0],e.shape[2]-this.cropping[0][0]-this.cropping[0][1],3);return Ev(i,this.cropping[1][0],e.shape[3]-this.cropping[1][1]-this.cropping[1][0],4)}})}getConfig(){const e={cropping:this.cropping,dataFormat:this.dataFormat},r=super.getConfig();return Object.assign(e,r),e}}return n.className="Cropping2D",n})()),Ye((()=>{class n extends dn{constructor(e){super(e),this.DEFAULT_SIZE=[2,2],this.inputSpec=[{ndim:4}],this.size=null==e.size?this.DEFAULT_SIZE:e.size,this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,Fr(this.dataFormat),this.interpolation=null==e.interpolation?"nearest":e.interpolation,function xpe(n){zu(bpe,"InterpolationFormat",n)}(this.interpolation)}computeOutputShape(e){return"channelsFirst"===this.dataFormat?[e[0],e[1],null==e[2]?null:this.size[0]*e[2],null==e[3]?null:this.size[1]*e[3]]:[e[0],null==e[1]?null:this.size[0]*e[1],null==e[2]?null:this.size[1]*e[2],e[3]]}call(e,r){return Se(()=>{let i=zt(e);const o=i.shape;if("channelsFirst"===this.dataFormat){i=wn(i,[0,2,3,1]);const s=this.size[0]*o[2],a=this.size[1]*o[3],c="nearest"===this.interpolation?Ba.resizeNearestNeighbor(i,[s,a]):Ba.resizeBilinear(i,[s,a]);return wn(c,[0,3,1,2])}{const s=this.size[0]*o[1],a=this.size[1]*o[2];return"nearest"===this.interpolation?Ba.resizeNearestNeighbor(i,[s,a]):Ba.resizeBilinear(i,[s,a])}})}getConfig(){const e={size:this.size,dataFormat:this.dataFormat,interpolation:this.interpolation},r=super.getConfig();return Object.assign(e,r),e}}return n.className="UpSampling2D",n})()),Ye((()=>{class n extends jv{constructor(e){super(2,e),this.depthwiseKernel=null,this.depthMultiplier=null==e.depthMultiplier?1:e.depthMultiplier,this.depthwiseInitializer=ar(e.depthwiseInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.depthwiseConstraint=si(e.depthwiseConstraint),this.depthwiseRegularizer=lr(e.depthwiseRegularizer)}build(e){if((e=Dn(e)).length<4)throw new ye(`Inputs to DepthwiseConv2D should have rank 4. Received input shape: ${JSON.stringify(e)}.`);const r="channelsFirst"===this.dataFormat?1:3;if(null==e[r]||e[r]<0)throw new ye(`The channel dimension of the inputs to DepthwiseConv2D should be defined, but is not (${e[r]}).`);const i=e[r];this.depthwiseKernel=this.addWeight("depthwise_kernel",[this.kernelSize[0],this.kernelSize[1],i,this.depthMultiplier],null,this.depthwiseInitializer,this.depthwiseRegularizer,!0,this.depthwiseConstraint),this.bias=this.useBias?this.addWeight("bias",[i*this.depthMultiplier],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):null,this.built=!0}call(e,r){return Se(()=>{let i=function jfe(n,t,e=[1,1],r="valid",i,o){return Se(()=>{null==i&&(i="channelsLast"),Fr(i);let s=tk(n,i);if(4!==n.rank)throw new ye(`Input for depthwiseConv2d is required to be 4-D, but is instead ${n.rank}-D`);if(4!==t.rank)throw new ye(`depthwiseKernel is required to be 4-D, but is instead ${t.rank}-D`);return s=ug(s,t,e,"same"===r?"same":"valid","NHWC",o),"channelsFirst"===i&&(s=wn(s,[0,3,1,2])),s})}(e=zt(e),this.depthwiseKernel.read(),this.strides,this.padding,this.dataFormat,null);return this.useBias&&(i=da(i,this.bias.read(),this.dataFormat)),null!=this.activation&&(i=this.activation.apply(i)),i})}computeOutputShape(e){e=Dn(e);const i="channelsFirst"===this.dataFormat?e[3]:e[2],o="channelsFirst"===this.dataFormat?e[1]*this.depthMultiplier:e[3]*this.depthMultiplier,s=fa("channelsFirst"===this.dataFormat?e[2]:e[1],this.kernelSize[0],this.padding,this.strides[0]),a=fa(i,this.kernelSize[1],this.padding,this.strides[1]);return"channelsFirst"===this.dataFormat?[e[0],o,s,a]:[e[0],s,a,o]}getConfig(){const e=super.getConfig();return e.depthMultiplier=this.depthMultiplier,e.depthwiseInitializer=mr(this.depthwiseInitializer),e.depthwiseRegularizer=Wn(this.depthwiseRegularizer),e.depthwiseConstraint=oi(this.depthwiseRegularizer),e}}return n.className="DepthwiseConv2D",n})());let Og=(()=>{class n extends dn{constructor(e){let r;if(super(e),null==e.cell)throw new ye("cell property is missing for the constructor of RNN.");if(r=Array.isArray(e.cell)?new lz({cells:e.cell}):e.cell,null==r.stateSize)throw new ye("The RNN cell should have an attribute `stateSize` (tuple of integers, one integer per RNN state).");this.cell=r,this.returnSequences=null!=e.returnSequences&&e.returnSequences,this.returnState=null!=e.returnState&&e.returnState,this.goBackwards=null!=e.goBackwards&&e.goBackwards,this._stateful=null!=e.stateful&&e.stateful,this.unroll=null!=e.unroll&&e.unroll,this.supportsMasking=!0,this.inputSpec=[new ii({ndim:3})],this.stateSpec=null,this.states_=null,this.numConstants=null,this.keptStates=[]}getStates(){return null==this.states_?ca(0,Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1).map(r=>null):this.states_}setStates(e){this.states_=e}computeOutputShape(e){AD(e)&&(e=e[0]);let r=this.cell.stateSize;Array.isArray(r)||(r=[r]);const i=r[0];let o;if(o=this.returnSequences?[e[0],e[1],i]:[e[0],i],this.returnState){const s=[];for(const a of r)s.push([e[0],a]);return[o].concat(s)}return o}computeMask(e,r){return Se(()=>{Array.isArray(r)&&(r=r[0]);const i=this.returnSequences?r:null;if(this.returnState){const o=this.states.map(s=>null);return[i].concat(o)}return i})}get states(){if(null==this.states_){const e=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1,r=[];for(let i=0;i<e;++i)r.push(null);return r}return this.states_}set states(e){this.states_=e}build(e){if(null!=this.numConstants)throw new en("Constants support is not implemented in RNN yet.");AD(e)&&(e=e[0]);const i=this.stateful?e[0]:null,o=e.slice(2);this.inputSpec[0]=new ii({shape:[i,null,...o]});const s=[e[0]].concat(e.slice(2));let a;if(this.cell.build(s),a=Array.isArray(this.cell.stateSize)?this.cell.stateSize:[this.cell.stateSize],null!=this.stateSpec){if(!mn(this.stateSpec.map(c=>c.shape[c.shape.length-1]),a))throw new ye(`An initialState was passed that is not compatible with cell.stateSize. Received stateSpec=${this.stateSpec}; However cell.stateSize is ${this.cell.stateSize}`)}else this.stateSpec=a.map(c=>new ii({shape:[null,c]}));this.stateful&&this.resetStates()}resetStates(e,r=!1){Se(()=>{if(!this.stateful)throw new za("Cannot call resetStates() on an RNN Layer that is not stateful.");const i=this.inputSpec[0].shape[0];if(null==i)throw new ye("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(null==this.states_)this.states_=Array.isArray(this.cell.stateSize)?this.cell.stateSize.map(o=>ni([i,o])):[ni([i,this.cell.stateSize])];else if(null==e)un(this.states_),null!=this.keptStates&&(un(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(o=>ni([i,o])):this.states_[0]=ni([i,this.cell.stateSize]);else{if(Array.isArray(e)||(e=[e]),e.length!==this.states_.length)throw new ye(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${e.length} state value(s). Input received: ${e}`);!0===r?this.keptStates.push(this.states_.slice()):un(this.states_);for(let o=0;o<this.states_.length;++o){const s=e[o],a=Array.isArray(this.cell.stateSize)?this.cell.stateSize[o]:this.cell.stateSize,c=[i,a];if(!mn(s.shape,c))throw new ye(`State ${o} is incompatible with layer ${this.name}: expected shape=${c}, received shape=${s.shape}`);this.states_[o]=s}}this.states_=this.states_.map(o=>fi(o.clone()))})}apply(e,r){let i=null==r?null:r.initialState,o=null==r?null:r.constants;null==r&&(r={});const s=iz(e,i,o,this.numConstants);e=s.inputs,i=s.initialState,o=s.constants;let a=[],c=[];if(null!=i){r.initialState=i,a=a.concat(i),this.stateSpec=[];for(const p of i)this.stateSpec.push(new ii({shape:p.shape}));c=c.concat(this.stateSpec)}if(null!=o&&(r.constants=o,a=a.concat(o),this.numConstants=o.length),a[0]instanceof Ha){const p=[e].concat(a),m=this.inputSpec.concat(c),g=this.inputSpec;this.inputSpec=m;const _=super.apply(p,r);return this.inputSpec=g,_}return super.apply(e,r)}call(e,r){return Se(()=>{const i=null==r?null:r.mask,o=null==r?null:r.training;let s=null==r?null:r.initialState;e=zt(e),null==s&&(s=this.stateful?this.states_:this.getInitialState(e));const a=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;if(s.length!==a)throw new ye(`RNN Layer has ${a} state(s) but was passed ${s.length} initial state(s).`);this.unroll&&console.warn("Ignoring unroll = true for RNN layer, due to imperative backend.");const c={training:o},p=oz((T,I)=>{const N=this.cell.call([T].concat(I),c);return[N[0],N.slice(1)]},e,s,this.goBackwards,i,null,this.unroll,this.returnSequences),m=p[0],g=p[1],_=p[2];this.stateful&&this.resetStates(_,o);const x=this.returnSequences?g:m;return this.returnState?[x].concat(_):x})}getInitialState(e){return Se(()=>{let r=ni(e.shape);return r=St(r,[1,2]),r=Cg(r),Array.isArray(this.cell.stateSize)?this.cell.stateSize.map(i=>i>1?DD(r,[1,i]):r):this.cell.stateSize>1?[DD(r,[1,this.cell.stateSize])]:[r]})}get trainableWeights(){return this.trainable?this.cell.trainableWeights:[]}get nonTrainableWeights(){return this.trainable?this.cell.nonTrainableWeights:this.cell.weights}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),null!=this.cell&&this.cell.setFastWeightInitDuringBuild(e)}getConfig(){const e=super.getConfig(),r={returnSequences:this.returnSequences,returnState:this.returnState,goBackwards:this.goBackwards,stateful:this.stateful,unroll:this.unroll};null!=this.numConstants&&(r.numConstants=this.numConstants);const i=this.cell.getConfig();return this.getClassName()===n.className&&(r.cell={className:this.cell.getClassName(),config:i}),Object.assign(Object.assign(Object.assign({},i),e),r)}static fromConfig(e,r,i={}){const s=Dl(r.cell,i);return new e(Object.assign(r,{cell:s}))}}return n.className="RNN",n})();Ye(Og);class Gv extends dn{}let sz=(()=>{class n extends Gv{constructor(e){super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=e.units,bi(this.units,"units"),this.activation=Rc(null==e.activation?this.DEFAULT_ACTIVATION:e.activation),this.useBias=null==e.useBias||e.useBias,this.kernelInitializer=ar(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=ar(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=ar(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=lr(e.kernelRegularizer),this.recurrentRegularizer=lr(e.recurrentRegularizer),this.biasRegularizer=lr(e.biasRegularizer),this.kernelConstraint=si(e.kernelConstraint),this.recurrentConstraint=si(e.recurrentConstraint),this.biasConstraint=si(e.biasConstraint),this.dropout=Gh([1,kc([0,null==e.dropout?0:e.dropout])]),this.recurrentDropout=Gh([1,kc([0,null==e.recurrentDropout?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){e=Dn(e),this.kernel=this.addWeight("kernel",[e[e.length-1],this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.bias=this.useBias?this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):null,this.built=!0}call(e,r){return Se(()=>{if(2!==e.length)throw new ye(`SimpleRNNCell expects 2 input Tensors, got ${e.length}.`);let i=e[1];e=e[0];const o=null!=r.training&&r.training;let s;0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=Mc({ones:()=>ds(e),rate:this.dropout,training:o,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=Mc({ones:()=>ds(i),rate:this.recurrentDropout,training:o,dropoutFunc:this.dropoutFunc}));const a=this.dropoutMask,c=this.recurrentDropoutMask;s=ja(null!=a?fe(e,a):e,this.kernel.read()),null!=this.bias&&(s=da(s,this.bias.read())),null!=c&&(i=fe(i,c));let u=Xe(s,ja(i,this.recurrentKernel.read()));return null!=this.activation&&(u=this.activation.apply(u)),[u,u]})}getConfig(){const e=super.getConfig(),r={units:this.units,activation:Oc(this.activation),useBias:this.useBias,kernelInitializer:mr(this.kernelInitializer),recurrentInitializer:mr(this.recurrentInitializer),biasInitializer:mr(this.biasInitializer),kernelRegularizer:Wn(this.kernelRegularizer),recurrentRegularizer:Wn(this.recurrentRegularizer),biasRegularizer:Wn(this.biasRegularizer),activityRegularizer:Wn(this.activityRegularizer),kernelConstraint:oi(this.kernelConstraint),recurrentConstraint:oi(this.recurrentConstraint),biasConstraint:oi(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout};return Object.assign(Object.assign({},e),r)}}return n.className="SimpleRNNCell",n})();Ye(sz),Ye((()=>{class n extends Og{constructor(e){e.cell=new sz(e),super(e)}call(e,r){return Se(()=>(null!=this.cell.dropoutMask&&(un(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(un(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),super.call(e,{mask:null==r?null:r.mask,training:null==r?null:r.training,initialState:null==r?null:r.initialState})))}static fromConfig(e,r){return new e(r)}}return n.className="SimpleRNN",n})());let az=(()=>{class n extends Gv{constructor(e){if(super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",e.resetAfter)throw new ye("GRUCell does not support reset_after parameter set to true.");this.units=e.units,bi(this.units,"units"),this.activation=Rc(void 0===e.activation?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=Rc(void 0===e.recurrentActivation?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=null==e.useBias||e.useBias,this.kernelInitializer=ar(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=ar(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=ar(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=lr(e.kernelRegularizer),this.recurrentRegularizer=lr(e.recurrentRegularizer),this.biasRegularizer=lr(e.biasRegularizer),this.kernelConstraint=si(e.kernelConstraint),this.recurrentConstraint=si(e.recurrentConstraint),this.biasConstraint=si(e.biasConstraint),this.dropout=Gh([1,kc([0,null==e.dropout?0:e.dropout])]),this.recurrentDropout=Gh([1,kc([0,null==e.recurrentDropout?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.implementation=e.implementation,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){e=Dn(e),this.kernel=this.addWeight("kernel",[e[e.length-1],3*this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,3*this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.bias=this.useBias?this.addWeight("bias",[3*this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):null,this.built=!0}call(e,r){return Se(()=>{if(2!==e.length)throw new ye(`GRUCell expects 2 input Tensors (inputs, h, c), got ${e.length}.`);const i=null!=r.training&&r.training;let o=e[1];e=e[0],0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=Mc({ones:()=>ds(e),rate:this.dropout,training:i,count:3,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=Mc({ones:()=>ds(o),rate:this.recurrentDropout,training:i,count:3,dropoutFunc:this.dropoutFunc}));const a=this.recurrentDropoutMask;let c,u,p;0<this.dropout&&this.dropout<1&&(e=fe(e,this.dropoutMask[0]));let m=ja(e,this.kernel.read());this.useBias&&(m=da(m,this.bias.read())),0<this.recurrentDropout&&this.recurrentDropout<1&&(o=fe(o,a[0]));const g=this.recurrentKernel.read(),[_,x]=Go(g,[2*this.units,this.units],g.rank-1),T=ja(o,_),[I,N,R]=Go(m,3,m.rank-1),[L,V]=Go(T,2,T.rank-1);c=this.recurrentActivation.apply(Xe(I,L)),u=this.recurrentActivation.apply(Xe(N,V));const j=ja(fe(u,o),x);p=this.activation.apply(Xe(R,j));const Y=Xe(fe(c,o),fe(Xe(1,tr(c)),p));return[Y,Y]})}getConfig(){const e=super.getConfig(),r={units:this.units,activation:Oc(this.activation),recurrentActivation:Oc(this.recurrentActivation),useBias:this.useBias,kernelInitializer:mr(this.kernelInitializer),recurrentInitializer:mr(this.recurrentInitializer),biasInitializer:mr(this.biasInitializer),kernelRegularizer:Wn(this.kernelRegularizer),recurrentRegularizer:Wn(this.recurrentRegularizer),biasRegularizer:Wn(this.biasRegularizer),activityRegularizer:Wn(this.activityRegularizer),kernelConstraint:oi(this.kernelConstraint),recurrentConstraint:oi(this.recurrentConstraint),biasConstraint:oi(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation,resetAfter:!1};return Object.assign(Object.assign({},e),r)}}return n.className="GRUCell",n})();Ye(az),Ye((()=>{class n extends Og{constructor(e){0===e.implementation&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new az(e),super(e)}call(e,r){return Se(()=>(null!=this.cell.dropoutMask&&(un(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(un(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),super.call(e,{mask:null==r?null:r.mask,training:null==r?null:r.training,initialState:null==r?null:r.initialState})))}static fromConfig(e,r){return 0===r.implmentation&&(r.implementation=1),new e(r)}}return n.className="GRU",n})());let rk=(()=>{class n extends Gv{constructor(e){super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=e.units,bi(this.units,"units"),this.activation=Rc(void 0===e.activation?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=Rc(void 0===e.recurrentActivation?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=null==e.useBias||e.useBias,this.kernelInitializer=ar(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=ar(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=ar(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.unitForgetBias=e.unitForgetBias,this.kernelRegularizer=lr(e.kernelRegularizer),this.recurrentRegularizer=lr(e.recurrentRegularizer),this.biasRegularizer=lr(e.biasRegularizer),this.kernelConstraint=si(e.kernelConstraint),this.recurrentConstraint=si(e.recurrentConstraint),this.biasConstraint=si(e.biasConstraint),this.dropout=Gh([1,kc([0,null==e.dropout?0:e.dropout])]),this.recurrentDropout=Gh([1,kc([0,null==e.recurrentDropout?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.implementation=e.implementation,this.stateSize=[this.units,this.units],this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){var r;let o;if(e=Dn(e),this.kernel=this.addWeight("kernel",[e[e.length-1],4*this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,4*this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){if(this.unitForgetBias){const s=this.biasInitializer,a=this.units;o=new((r=class extends Vs{apply(u,p){const m=s.apply([a]),g=(new p4).apply([a]),_=s.apply([2*a]);return u4(u4(m,g),_)}}).className="CustomInit",r)}else o=this.biasInitializer;this.bias=this.addWeight("bias",[4*this.units],null,o,this.biasRegularizer,!0,this.biasConstraint)}else this.bias=null;this.built=!0}call(e,r){return Se(()=>{const i=null!=r.training&&r.training;if(3!==e.length)throw new ye(`LSTMCell expects 3 input Tensors (inputs, h, c), got ${e.length}.`);let o=e[1];const s=e[2];e=e[0],0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=Mc({ones:()=>ds(e),rate:this.dropout,training:i,count:4,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=Mc({ones:()=>ds(o),rate:this.recurrentDropout,training:i,count:4,dropoutFunc:this.dropoutFunc}));const c=this.recurrentDropoutMask;let u,p,m,g;0<this.dropout&&this.dropout<1&&(e=fe(e,this.dropoutMask[0]));let _=ja(e,this.kernel.read());0<this.recurrentDropout&&this.recurrentDropout<1&&(o=fe(o,c[0])),_=Xe(_,ja(o,this.recurrentKernel.read())),this.useBias&&(_=da(_,this.bias.read()));const[x,T,I,N]=Go(_,4,_.rank-1);u=this.recurrentActivation.apply(x),p=this.recurrentActivation.apply(T),m=Xe(fe(p,s),fe(u,this.activation.apply(I))),g=this.recurrentActivation.apply(N);const R=fe(g,this.activation.apply(m));return[R,R,m]})}getConfig(){const e=super.getConfig(),r={units:this.units,activation:Oc(this.activation),recurrentActivation:Oc(this.recurrentActivation),useBias:this.useBias,kernelInitializer:mr(this.kernelInitializer),recurrentInitializer:mr(this.recurrentInitializer),biasInitializer:mr(this.biasInitializer),unitForgetBias:this.unitForgetBias,kernelRegularizer:Wn(this.kernelRegularizer),recurrentRegularizer:Wn(this.recurrentRegularizer),biasRegularizer:Wn(this.biasRegularizer),activityRegularizer:Wn(this.activityRegularizer),kernelConstraint:oi(this.kernelConstraint),recurrentConstraint:oi(this.recurrentConstraint),biasConstraint:oi(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation};return Object.assign(Object.assign({},e),r)}}return n.className="LSTMCell",n})();Ye(rk),Ye((()=>{class n extends Og{constructor(e){0===e.implementation&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new rk(e),super(e)}call(e,r){return Se(()=>(null!=this.cell.dropoutMask&&(un(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(un(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),super.call(e,{mask:null==r?null:r.mask,training:null==r?null:r.training,initialState:null==r?null:r.initialState})))}static fromConfig(e,r){return 0===r.implmentation&&(r.implementation=1),new e(r)}}return n.className="LSTM",n})());let lz=(()=>{class n extends Gv{constructor(e){super(e),this.cells=e.cells}get stateSize(){const e=[];for(const r of this.cells.slice().reverse())Array.isArray(r.stateSize)?e.push(...r.stateSize):e.push(r.stateSize);return e}call(e,r){return Se(()=>{let i=e.slice(1);const o=[];for(const c of this.cells.slice().reverse())Array.isArray(c.stateSize)?o.push(i.splice(0,c.stateSize.length)):o.push(i.splice(0,1));o.reverse();const s=[];let a;for(let c=0;c<this.cells.length;++c){const u=this.cells[c];i=o[c],a=0===c?[e[0]].concat(i):[a[0]].concat(i),a=u.call(a,r),s.push(a.slice(1))}i=[];for(const c of s.slice().reverse())i.push(...c);return[a[0]].concat(i)})}build(e){let r;AD(e)&&(e=e[0]),this.cells.forEach((i,o)=>{Uu(`RNNCell_${o}`,()=>{i.build(e),r=Array.isArray(i.stateSize)?i.stateSize[0]:i.stateSize,e=[e[0],r]})}),this.built=!0}getConfig(){const e=super.getConfig(),o={cells:this.cells.map(s=>({className:s.getClassName(),config:s.getConfig()}))};return Object.assign(Object.assign({},e),o)}static fromConfig(e,r,i={}){const o=[];for(const s of r.cells)o.push(Dl(s,i));return new e({cells:o})}get trainableWeights(){if(!this.trainable)return[];const e=[];for(const r of this.cells)e.push(...r.trainableWeights);return e}get nonTrainableWeights(){const e=[];for(const r of this.cells)e.push(...r.nonTrainableWeights);if(!this.trainable){const r=[];for(const i of this.cells)r.push(...i.trainableWeights);return r.concat(e)}return e}getWeights(){const e=[];for(const r of this.cells)e.push(...r.weights);return ND(e)}setWeights(e){const r=[];for(const i of this.cells){const s=e.splice(i.weights.length);for(let a=0;a<i.weights.length;++a)r.push([i.weights[a],s[a]])}OD(r)}}return n.className="StackedRNNCells",n})();function Mc(n){const{ones:t,rate:e,training:r=!1,count:i=1,dropoutFunc:o}=n,s=()=>null!=o?o(t(),e):h4(t(),e),a=()=>Eg(s,t,r);return!i||i<=1?fi(a().clone()):Array(i).fill(void 0).map(a).map(u=>fi(u.clone()))}Ye(lz);let Hfe=(()=>{class n extends Og{constructor(e){if(e.unroll)throw new en("Unrolling is not possible with convolutional RNNs.");if(Array.isArray(e.cell))throw new en("It is not possible at the moment to stack convolutional cells.");super(e),this.inputSpec=[new ii({ndim:5})]}call(e,r){return Se(()=>{if(null!=this.cell.dropoutMask&&(un(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(un(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),r&&r.constants)throw new ye("ConvRNN2D cell does not support constants");return super.call(e,{mask:null==r?null:r.mask,training:null==r?null:r.training,initialState:null==r?null:r.initialState})})}computeOutputShape(e){let r=this.computeSingleOutputShape(e);return this.returnSequences||(r=[r[0],...r.slice(2)]),this.returnState&&(r=[r,...Array(2).fill([e[0],...r.slice(-3)])]),r}getInitialState(e){return Se(()=>{const{stateSize:r}=this.cell,o=this.computeSingleOutputShape(e.shape),a=ni([o[0],...o.slice(2)]);return Array.isArray(r)?Array(r.length).fill(a):[a]})}resetStates(e,r=!1){Se(()=>{if(!this.stateful)throw new za("Cannot call resetStates() on an RNN Layer that is not stateful.");const i=this.inputSpec[0].shape,o=this.computeSingleOutputShape(i),s=[o[0],...o.slice(2)];if(null==i[0])throw new ye("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(null==this.getStates())this.states_=Array.isArray(this.cell.stateSize)?this.cell.stateSize.map(()=>ni(s)):[ni(s)];else if(null==e)un(this.states_),null!=this.keptStates&&(un(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(()=>ni(s)):this.states_[0]=ni(s);else{if(Array.isArray(e)||(e=[e]),e.length!==this.states_.length)throw new ye(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${e.length} state value(s). Input received: ${e}`);r?this.keptStates.push(this.states_.slice()):un(this.states_);for(let c=0;c<this.states_.length;++c){const u=e[c],p=s;if(!mn(u.shape,p))throw new ye(`State ${c} is incompatible with layer ${this.name}: expected shape=${p}, received shape=${u.shape}`);this.states_[c]=u}}this.states_=this.states_.map(c=>fi(c.clone()))})}computeSingleOutputShape(e){const{dataFormat:r,filters:i,kernelSize:o,padding:s,strides:a,dilationRate:c}=this.cell,u="channelsFirst"===r,m=e[u?4:3],g=fa(e[u?3:2],o[0],s,a[0],c[0]),_=fa(m,o[1],s,a[1],c[1]);return[...e.slice(0,2),...u?[i,g,_]:[g,_,i]]}}return n.className="ConvRNN2D",n})(),cz=(()=>{class n extends rk{constructor(e){const{filters:r,kernelSize:i,strides:o,padding:s,dataFormat:a,dilationRate:c}=e;super(Object.assign(Object.assign({},e),{units:r})),this.filters=r,bi(this.filters,"filters"),this.kernelSize=qh(i,2,"kernelSize"),this.kernelSize.forEach(u=>bi(u,"kernelSize")),this.strides=qh(o||1,2,"strides"),this.strides.forEach(u=>bi(u,"strides")),this.padding=s||"valid",fs(this.padding),this.dataFormat=a||"channelsLast",Fr(this.dataFormat),this.dilationRate=qh(c||1,2,"dilationRate"),this.dilationRate.forEach(u=>bi(u,"dilationRate"))}build(e){var r;e=Dn(e);const i="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[i])throw new ye(`The channel dimension of the input should be defined. Found ${e[i]}`);const a=this.kernelSize.concat([e[i],4*this.filters]);this.kernel=this.addWeight("kernel",a,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint);const c=this.kernelSize.concat([this.filters,4*this.filters]);if(this.recurrentKernel=this.addWeight("recurrent_kernel",c,null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){let u;if(this.unitForgetBias){const p=this.biasInitializer,m=this.filters;u=new((r=class extends Vs{apply(_,x){return ED([p.apply([m]),us([m]),p.apply([2*m])])}}).className="CustomInit",r)}else u=this.biasInitializer;this.bias=this.addWeight("bias",[4*this.filters],null,u,this.biasRegularizer,!0,this.biasConstraint)}this.built=!0}call(e,r){return Se(()=>{if(3!==e.length)throw new ye(`ConvLSTM2DCell expects 3 input Tensors (inputs, h, c), got ${e.length}.`);const i=r.training||!1,o=e[0],s=e[1],a=e[2];0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=Mc({ones:()=>ds(o),rate:this.dropout,training:i,count:4,dropoutFunc:this.dropoutFunc}));const u=this.dropoutMask,p=(We,Je,Ze)=>Je&&Je[Ze]?fe(Je[Ze],We):We;let m=p(o,u,0),g=p(o,u,1),_=p(o,u,2),x=p(o,u,3);0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=Mc({ones:()=>ds(s),rate:this.recurrentDropout,training:i,count:4,dropoutFunc:this.dropoutFunc}));const T=this.recurrentDropoutMask;let I=p(s,T,0),N=p(s,T,1),R=p(s,T,2),L=p(s,T,3);const[j,Y,ee,ie]=Go(this.kernel.read(),4,3),[ce,he,we,Ee]=this.useBias?Go(this.bias.read(),4):[null,null,null,null];m=this.inputConv(m,j,ce,this.padding),g=this.inputConv(g,Y,he,this.padding),_=this.inputConv(_,ee,we,this.padding),x=this.inputConv(x,ie,Ee,this.padding);const[Ae,Oe,Re,_e]=Go(this.recurrentKernel.read(),4,3);I=this.recurrentConv(I,Ae),N=this.recurrentConv(N,Oe),R=this.recurrentConv(R,Re),L=this.recurrentConv(L,_e);const Te=this.recurrentActivation.apply(Xe(m,I)),xe=this.recurrentActivation.apply(Xe(g,N)),De=Xe(fe(xe,a),fe(Te,this.activation.apply(Xe(_,R)))),je=fe(this.recurrentActivation.apply(Xe(x,L)),this.activation.apply(De));return[je,je,De]})}getConfig(){const i=function(n,t){var e={};for(var r in n)Object.prototype.hasOwnProperty.call(n,r)&&t.indexOf(r)<0&&(e[r]=n[r]);if(null!=n&&"function"==typeof Object.getOwnPropertySymbols){var i=0;for(r=Object.getOwnPropertySymbols(n);i<r.length;i++)t.indexOf(r[i])<0&&Object.prototype.propertyIsEnumerable.call(n,r[i])&&(e[r[i]]=n[r[i]])}return e}(super.getConfig(),["units"]),o={filters:this.filters,kernelSize:this.kernelSize,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,strides:this.strides};return Object.assign(Object.assign({},i),o)}inputConv(e,r,i,o){const s=Tc(e,r,this.strides,o||"valid","channelsFirst"===this.dataFormat?"NCHW":"NHWC",this.dilationRate);return i?da(s,i,this.dataFormat):s}recurrentConv(e,r){return Tc(e,r,1,"same","channelsFirst"===this.dataFormat?"NCHW":"NHWC")}}return n.className="ConvLSTM2DCell",n})();Ye(cz),Ye((()=>{class n extends Hfe{constructor(e){const r=new cz(e);super(Object.assign(Object.assign({},e),{cell:r}))}static fromConfig(e,r){return new e(r)}}return n.className="ConvLSTM2D",n})());let uz=(()=>{class n extends dn{constructor(e){super(e),this.rate=Math.max(Math.min(e.rate,1),0),this.noiseShape=e.noiseShape,this.seed=e.seed,this.supportsMasking=!0}getNoiseShape(e){if(null==this.noiseShape)return this.noiseShape;const r=e.shape,i=[];for(let o=0;o<this.noiseShape.length;++o)i.push(null==this.noiseShape[o]?r[o]:this.noiseShape[o]);return i}call(e,r){return Se(()=>{this.invokeCallHook(e,r);const i=zt(e);if(0<this.rate&&this.rate<1){const o=null!=r.training&&r.training,s=this.getNoiseShape(i);return Eg(()=>h4(i,this.rate,s,this.seed),()=>i,o)}return e})}getConfig(){const e={rate:this.rate,noiseShape:this.noiseShape,seed:this.seed},r=super.getConfig();return Object.assign(e,r),e}dispose(){return super.dispose()}}return n.className="Dropout",n})();Ye(uz),Ye((()=>{class n extends uz{constructor(e){super(e),this.inputSpec=[{ndim:3}]}getNoiseShape(e){const r=e.shape;return[r[0],1,r[2]]}}return n.className="SpatialDropout1D",n})()),Ye((()=>{class n extends dn{constructor(e){if(super(e),this.activation=null,this.useBias=!0,this.kernel=null,this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",null==e.batchInputShape&&null==e.inputShape&&null!=e.inputDim){let r=null;null!=e.batchSize&&(r=e.batchSize),this.batchInputShape=[r,e.inputDim]}this.units=e.units,bi(this.units,"units"),this.activation=Rc(e.activation),null!=e.useBias&&(this.useBias=e.useBias),this.kernelInitializer=ar(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.biasInitializer=ar(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelConstraint=si(e.kernelConstraint),this.biasConstraint=si(e.biasConstraint),this.kernelRegularizer=lr(e.kernelRegularizer),this.biasRegularizer=lr(e.biasRegularizer),this.activityRegularizer=lr(e.activityRegularizer),this.supportsMasking=!0,this.inputSpec=[{minNDim:2}]}build(e){const r=(e=Dn(e))[e.length-1];null==this.kernel&&(this.kernel=this.addWeight("kernel",[r,this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint))),this.inputSpec=[{minNDim:2,axes:{[-1]:r}}],this.built=!0}computeOutputShape(e){const r=(e=Dn(e)).slice();return r[r.length-1]=this.units,r}call(e,r){return Se(()=>{this.invokeCallHook(e,r);const i=zt(e),o=t4(this.activation.getClassName());let s;return null!=o?s=ja(i,this.kernel.read(),o,this.bias?this.bias.read():null):(s=ja(i,this.kernel.read()),null!=this.bias&&(s=da(s,this.bias.read())),null!=this.activation&&(s=this.activation.apply(s))),s})}getConfig(){const e={units:this.units,activation:Oc(this.activation),useBias:this.useBias,kernelInitializer:mr(this.kernelInitializer),biasInitializer:mr(this.biasInitializer),kernelRegularizer:Wn(this.kernelRegularizer),biasRegularizer:Wn(this.biasRegularizer),activityRegularizer:Wn(this.activityRegularizer),kernelConstraint:oi(this.kernelConstraint),biasConstraint:oi(this.biasConstraint)},r=super.getConfig();return Object.assign(e,r),e}}return n.className="Dense",n})()),Ye((()=>{class n extends dn{constructor(e){super(e=e||{}),this.inputSpec=[{minNDim:3}],this.dataFormat=e.dataFormat}computeOutputShape(e){e=Dn(e);for(const r of e.slice(1))if(null==r)throw new ye(`The shape of the input to "Flatten" is not fully defined (got ${e.slice(1)}). Make sure to pass a complete "input_shape" or "batch_input_shape" argument to the first layer in your model.`);return[e[0],Dc(e,1)]}call(e,r){return Se(()=>{this.invokeCallHook(e,r);let i=zt(e);if("channelsFirst"===this.dataFormat&&i.rank>1){const o=[0];for(let s=2;s<i.rank;++s)o.push(s);o.push(1),i=wn(i,o)}return function kpe(n){if(n.rank<=1)throw new ye(`batchFlatten requires a minimum rank of 2. Got rank: ${n.rank}.`);const t=[n.shape[0],Dc(n.shape,1)];return be(n,t)}(i)})}getConfig(){const e={};null!=this.dataFormat&&(e.dataFormat=this.dataFormat);const r=super.getConfig();return Object.assign(e,r),e}}return n.className="Flatten",n})()),Ye((()=>{class n extends dn{constructor(e){super(e),this.supportsMasking=!0,this.activation=Rc(e.activation)}call(e,r){return Se(()=>{this.invokeCallHook(e,r);const i=zt(e);return this.activation.apply(i)})}getConfig(){const e={activation:Oc(this.activation)},r=super.getConfig();return Object.assign(e,r),e}}return n.className="Activation",n})()),Ye((()=>{class n extends dn{constructor(e){super(e),this.n=e.n,this.inputSpec=[{ndim:2}]}computeOutputShape(e){return[e[0],this.n,e[1]]}call(e,r){return Se(()=>function Epe(n,t){return Se(()=>{if(2!==n.shape.length)throw new ye(`repeat() expects a rank-2 tensor, but received a rank-${n.shape.length} tensor.`);return DD(Cg(n,1),[1,t,1])})}(e=zt(e),this.n))}getConfig(){const e={n:this.n},r=super.getConfig();return Object.assign(e,r),e}}return n.className="RepeatVector",n})()),Ye((()=>{class n extends dn{constructor(e){super(e),this.targetShape=e.targetShape;for(let r=0;r<this.targetShape.length;++r)this.isUnknown(this.targetShape[r])&&(this.targetShape[r]=null)}isUnknown(e){return e<0||null==e}fixUnknownDimension(e,r){const i="Total size of new array must be unchanged.",o=r.slice();let s=1,a=null;for(let u=0;u<o.length;++u){const p=o[u];if(this.isUnknown(p)){if(null!==a)throw new ye("Can only specifiy one unknown dimension.");a=u}else s*=p}const c=Dc(e);if(null!==a){if(0===s||c%s!=0)throw new ye(i);o[a]=c/s}else if(c!==s)throw new ye(i);return o}computeOutputShape(e){let r=!1;for(let i=0;i<e.length;++i)if(this.isUnknown(e[i])){r=!0;break}return r?e.slice(0,1).concat(this.targetShape):e.slice(0,1).concat(this.fixUnknownDimension(e.slice(1),this.targetShape))}call(e,r){return Se(()=>{this.invokeCallHook(e,r);const i=zt(e),o=i.shape,s=o.slice(0,1).concat(this.fixUnknownDimension(o.slice(1),this.targetShape));return be(i,s)})}getConfig(){const e={targetShape:this.targetShape},r=super.getConfig();return Object.assign(e,r),e}}return n.className="Reshape",n})()),Ye((()=>{class n extends dn{constructor(e){if(super(e),null==e.dims)throw new Error("Required configuration field `dims` is missing during Permute constructor call.");if(!Array.isArray(e.dims))throw new Error(`Permute constructor requires \`dims\` to be an Array, but received ${e.dims} instead.`);const r=ca(1,e.dims.length+1);if(!mn(e.dims.slice().sort(),r))throw new Error("Invalid permutation `dims`: "+JSON.stringify(e.dims)+" `dims` must contain consecutive integers starting from 1.");this.dims=e.dims,this.dimsIncludingBatch=[0].concat(this.dims),this.inputSpec=[new ii({ndim:this.dims.length+1})]}computeOutputShape(e){const r=(e=Dn(e)).slice();return this.dims.forEach((i,o)=>{r[o+1]=e[i]}),r}call(e,r){return wn(zt(e),this.dimsIncludingBatch)}getConfig(){const e={dims:this.dims},r=super.getConfig();return Object.assign(e,r),e}}return n.className="Permute",n})()),Ye((()=>{class n extends dn{constructor(e){super(e??{}),this.supportsMasking=!0,this.maskValue=null!=e?null==e.maskValue?0:e.maskValue:0}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),r={maskValue:this.maskValue};return Object.assign(r,e),r}computeMask(e,r){const i=zt(e);return Y0($h(i,this.maskValue),-1)}call(e,r){return Se(()=>{this.invokeCallHook(e,r);const i=zt(e),a=Y0($h(i,this.maskValue),-1,!0);return fe(i,ht(a,i.dtype))})}}return n.className="Masking",n})()),Ye((()=>{class n extends dn{constructor(e){if(super(e),this.embeddings=null,this.DEFAULT_EMBEDDINGS_INITIALIZER="randomUniform",null==e.batchInputShape&&null==e.inputShape){let r=null;null!=e.batchSize&&(r=e.batchSize),this.batchInputShape=null==e.inputLength?[r,null]:[r].concat(Xn(e.inputLength))}this.inputDim=e.inputDim,bi(this.inputDim,"inputDim"),this.outputDim=e.outputDim,bi(this.outputDim,"outputDim"),this.embeddingsInitializer=ar(e.embeddingsInitializer||this.DEFAULT_EMBEDDINGS_INITIALIZER),this.embeddingsRegularizer=lr(e.embeddingsRegularizer),this.activityRegularizer=lr(e.activityRegularizer),this.embeddingsConstraint=si(e.embeddingsConstraint),this.maskZero=e.maskZero,this.supportsMasking=e.maskZero,this.inputLength=e.inputLength}build(e){this.embeddings=this.addWeight("embeddings",[this.inputDim,this.outputDim],this.dtype,this.embeddingsInitializer,this.embeddingsRegularizer,!0,this.embeddingsConstraint),this.built=!0}warnOnIncompatibleInputShape(e){}computeMask(e,r){return Se(()=>this.maskZero?(e=zt(e),$h(e,vn(e))):null)}computeOutputShape(e){if(e=Dn(e),null==this.inputLength)return[...e,this.outputDim];const r=Xn(this.inputLength);if(r.length!==e.length-1)throw new ye(`"inputLength" is ${this.inputLength}, but received input shape has shape ${e}`);{let i=0;for(let o=0;o<r.length;++o){const s=r[o],a=e[o+1];if(null!=s&&null!=a&&s!==a)throw new ye(`"inputLength" is ${this.inputLength}, but received input shape has shape ${e}`);null==s&&(r[i]=a),i++}}return[e[0],...r,this.outputDim]}call(e,r){return Se(()=>{this.invokeCallHook(e,r);let i=zt(e);"int32"!==i.dtype&&(i=Ua(i,"int32"));const o=d4(this.embeddings.read(),be(i,[i.size]));return be(o,Dn(this.computeOutputShape(i.shape)))})}getConfig(){const e={inputDim:this.inputDim,outputDim:this.outputDim,embeddingsInitializer:mr(this.embeddingsInitializer),embeddingsRegularizer:Wn(this.embeddingsRegularizer),activityRegularizer:Wn(this.activityRegularizer),embeddingsConstraint:oi(this.embeddingsConstraint),maskZero:this.maskZero,inputLength:this.inputLength},r=super.getConfig();return Object.assign(e,r),e}}return n.className="Embedding",n})());class Gu extends dn{constructor(t){super(t||{}),this.supportsMasking=!0}mergeFunction(t){throw new en}computeElementwiseOpOutputShape(t,e){if(null==t||null==e)return null;if(t.length<e.length)return this.computeElementwiseOpOutputShape(e,t);if(0===e.length)return t;const r=t.slice(0,t.length-e.length);for(let i=0;i<e.length;++i){const o=t[t.length-e.length+i],s=e[i];if(null==o||null==s||o<0||s<0)r.push(null);else if(1===o)r.push(s);else if(1===s)r.push(o);else{if(o!==s)throw new ye("Operands could not be broadcast together with shapes "+JSON.stringify(t)+" "+JSON.stringify(e));r.push(o)}}return r}build(t){if(Array.isArray(t)&&!Array.isArray(t[0])&&(t=[Dn(t)]),t.length<2)throw new ye(`A merge layer should be called on an Array of at least 2 inputs. Got ${t.length} input(s).`);let e=[];for(const o of t)null!=o&&null!==o[0]&&e.push(o[0]);if(e=Ec(e),e.length>1)throw new ye(`Can not merge tensors with different batch sizes. Got tensors with shapes: ${JSON.stringify(t)}.`);let r=null==t[0]?null:t[0].slice(1);for(let o=1;o<t.length;++o){const s=null==t[o]?null:t[o].slice(1);r=this.computeElementwiseOpOutputShape(r,s)}const i=t.map(o=>o.length);this.reshapeRequired=-1!==t.indexOf(null)||1!==Ec(i).length}call(t,e){return Se(()=>{if(this.reshapeRequired){const r=[],i=t.map(o=>o.rank);if(-1===i.indexOf(null)){const o=kc(i);for(let s of t){const a=s.rank;for(let c=0;c<o-a;++c)s=Cg(s,1);r.push(s)}return this.mergeFunction(r)}{let o=!1;for(const c of t){const u=c.rank;if(null==u){const p=c.shape,m=p[0],g=p.slice(1).concat([m]);let _=be(c,[m].concat(Dc(p.slice(1))));_=wn(_,[1,0]),_=be(_,g),r.push(_),o=!0}else if(u>1){const p=ca(1,u).concat([0]);r.push(wn(c,p)),o=!0}else r.push(c)}let s=this.mergeFunction(r);const a=s.rank;if(o)if(null==a){const c=s.shape,p=c[c.length-1],m=[p].concat(c.slice(0,c.length-1));s=be(wn(be(s,[-1,p]),[1,0]),m)}else if(a>1){const c=[a-1].concat(ca(0,a-1));s=wn(s,c)}return s}}return this.mergeFunction(t)})}computeOutputShape(t){let e;e=null==t[0]?null:t[0].slice(1);for(let i=1;i<t.length;++i){const o=null==t[i]?null:t[i].slice(1);e=this.computeElementwiseOpOutputShape(e,o)}let r=[];for(const i of t)null!=i&&null!==i[0]&&r.push(i[0]);return r=Ec(r),e=1===r.length?r.concat(e):[null].concat(e),e}computeMask(t,e){return Se(()=>{if(null==e)return null;if(!Array.isArray(e))throw new ye("`mask` should be an Array");if(!Array.isArray(t))throw new ye("`inputs` should be an Array");if(e.length!==t.length)throw new ye(`The Array 'inputs' and 'mask' are expected to have the same length, but have different lengths (${t.length} vs ${e.length})`);if(e.every(i=>null==i))return null;let r=(e=e.map(i=>null==i?i:To(i,0)))[0];for(let i=1;i<e.length-1;++i)r=$a(r,e[i]);return r})}}function Rg(n,t){for(;n<0;)n+=t;return n}function Mg(n,t,e,r,i,o=.001){let s;if(2===n.rank)s=bB(n,t,e,r,i,o);else if(3===n.rank)s=yB(n,t,e,r,i,o);else{if(4!==n.rank)throw new en(`batchNormalization is not implemented for array of rank ${n.rank} yet`);s=_B(n,t,e,r,i,o)}return s}function Hv(n,t,e,r,i,o){return Se(()=>{let s;Fr(i),r4(o),fs(r),null==e&&(e=[1,1]),null==r&&(r="valid"),null==i&&(i="channelsLast"),null==o&&(o="max"),n=tk(n,i);const a="same"===r?"same":"valid";return s="max"===o?sv(n,t,e,a):Z0(n,t,e,a),"channelsFirst"===i&&(s=wn(s,[0,3,1,2])),s})}function dz(n,t,e,r,i,o){return Se(()=>{let s;Fr(i),r4(o),fs(r),null==e&&(e=[1,1,1]),null==r&&(r="valid"),null==i&&(i="channelsLast"),null==o&&(o="max"),n=J4(n,i);const a="same"===r?"same":"valid";return s="max"===o?GB(n,t,e,a):gB(n,t,e,a),"channelsFirst"===i&&(s=wn(s,[0,4,1,2,3])),s})}Ye((()=>{class n extends Gu{constructor(e){super(e)}mergeFunction(e){return Se(()=>{let r=e[0].clone();for(let i=1;i<e.length;++i)r=Xe(r,e[i]);return r})}}return n.className="Add",n})()),Ye((()=>{class n extends Gu{constructor(e){super(e)}mergeFunction(e){return Se(()=>{let r=e[0].clone();for(let i=1;i<e.length;++i)r=fe(r,e[i]);return r})}}return n.className="Multiply",n})()),Ye((()=>{class n extends Gu{constructor(e){super(e)}mergeFunction(e){return Se(()=>{let r=e[0].clone();for(let i=1;i<e.length;++i)r=Xe(r,e[i]);return fe(1/e.length,r)})}}return n.className="Average",n})()),Ye((()=>{class n extends Gu{constructor(e){super(e)}mergeFunction(e){return Se(()=>{let r=e[0];for(let i=1;i<e.length;++i)r=xl(r,e[i]);return r})}}return n.className="Maximum",n})()),Ye((()=>{class n extends Gu{constructor(e){super(e)}mergeFunction(e){return Se(()=>{let r=e[0];for(let i=1;i<e.length;++i)r=Fu(r,e[i]);return r})}}return n.className="Minimum",n})()),Ye((()=>{class n extends Gu{constructor(e){super(e),this.DEFAULT_AXIS=-1,null==e&&(e={}),this.axis=null==e.axis?this.DEFAULT_AXIS:e.axis,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){if(!Array.isArray(e)||!Array.isArray(e[0])||1===e.length)throw new ye("A `Concatenate` layer should be called on a list of at least 2 inputs");let r=!0;for(const o of e)if(null!=o){r=!1;break}if(r)return;const i=[];for(let o=0;o<e.length;++o){const s=e[o].slice();s.splice(this.axis,1);let a=!1;for(const c of i)if(mn(c,s)){a=!0;break}a||i.push(s)}if(i.length>1)throw new ye("A `Concatenate` layer requires inputs with matching shapes except for the concat axis. Got input shapes: "+JSON.stringify(e))}mergeFunction(e){return Se(()=>ED(e,this.axis))}computeOutputShape(e){if(!Array.isArray(e)||!Array.isArray(e[0]))throw new ye("A `Concatenate` layer should be called on a list of inputs.");const r=e,i=r[0].slice(),o=this.axis<0?i.length+this.axis:this.axis;for(const s of r.slice(1)){if(null==i[o]||null==s[o]){i[o]=null;break}i[o]+=s[o]}return i}computeMask(e,r){if(null==r)return null;if(!Array.isArray(r))throw new ye("`mask` should be an array for Concatenate");if(!Array.isArray(e))throw new ye("`inputs` should be an array for Concatenate");if(r.length!==e.length)throw new ye(`Mismatch in the length of mask (${r.length}) and the legnth of inputs (${e.length})`);return Se(()=>{let i=!0;if(r.forEach(a=>{null==a||(i=!1)}),i)return null;const o=[];for(let a=0;a<e.length;++a)o.push(null==r[a]?ht(ds(e[a]),"bool"):r[a].rank<e[a].rank?To(r[a],-1):r[a]);const s=Ur(o,this.axis);return aE(s,-1,!1)})}getConfig(){const e={axis:this.axis},r=super.getConfig();return Object.assign(e,r),e}}return n.className="Concatenate",n})()),Ye((()=>{class n extends Gu{constructor(e){super(e),this.axes=e.axes,this.normalize=null!=e.normalize&&e.normalize,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){Z(Array.isArray(e)&&2===e.length&&Array.isArray(e[0])&&Array.isArray(e[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");const r=e[0],i=e[1];if(r.length>3||i.length>3)throw new en("Dot layer does not support tensors of 4D or higher rank yet.");const o=this.interpretAxes(r,i);if(r[o[0]]!==i[o[1]])throw new ye(`Dimension incompatibility: ${r[o[0]]} !== ${i[o[1]]}`)}mergeFunction(e){if(2!==e.length)throw new ye(`A \`Dot\` layer must be called on exactly 2 inputs, but received ${e.length} input(s).`);let o,r=e[0],i=e[1];return o=Array.isArray(this.axes)?this.axes.map((s,a)=>Rg(s,e[a].shape.length)):[Rg(this.axes,r.shape.length),Rg(this.axes,i.shape.length)],this.normalize&&(r=Fv(r,o[0]),i=Fv(i,o[1])),function Wfe(n,t,e){if(n.shape.length>3||t.shape.length>3)throw new en("batchDot is not implemented for tensors of 4D or higher rank yet");if(Z(n.shape.length>=2,()=>`batchDot requires the rank of x to be >= 2, but got ${n.shape.length}`),Z(n.shape.length>=2,()=>`batchDot requires the rank of y to be >= 2, but got ${t.shape.length}`),"number"==typeof e&&(e=[e,e]),"complex64"===n.dtype||"complex64"===t.dtype)throw new en("batchDot is not implemented for complex64-type Tensors yet.");const r=n.shape.length,i=t.shape.length;null==e&&(e=[r-1,i-2]);const o=e;return Se(()=>{let s,a;if(r>i){s=r-i;const c=[];for(let u=0;u<s;++u)c.push(1);t=be(t,t.shape.concat(c))}else if(i>r){s=i-r;const c=[];for(let u=0;u<s;++u)c.push(1);n=be(n,n.shape.concat(c))}else s=0;if(a=2===n.shape.length&&2===t.shape.length?o[0]===o[1]?St(fe(n,t),o[0]):St(fe(wn(n,[1,0]),t),o[1]):hn(n,t,o[0]!==n.shape.length-1,o[1]===t.shape.length-1),s>0){let c;c=r>i?r+i-3:r-1;const u=[];for(let p=c;p<c+s;++p)u.push(p);a=$u(a,u)}return 1===a.shape.length&&(a=To(a,1)),a})}(r,i,o)}interpretAxes(e,r){let i;return i=Array.isArray(this.axes)?this.axes:[Rg(this.axes,e.length),Rg(this.axes,r.length)],i}computeOutputShape(e){Z(Array.isArray(e)&&2===e.length&&Array.isArray(e[0])&&Array.isArray(e[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");const r=e[0].slice(),i=e[1].slice();if(r.length>3||i.length>3)throw new en("Dot layer does not support tensors of 4D or higher rank yet.");const o=this.interpretAxes(r,i);r.splice(o[0],1),i.splice(o[1],1),i.splice(0,1);const s=r.concat(i);return 1===s.length&&s.push(1),s}computeMask(e,r){return null}getConfig(){const e={axes:this.axes,normalize:this.normalize},r=super.getConfig();return Object.assign(e,r),e}}return n.className="Dot",n})()),Ye((()=>{class n extends dn{constructor(e){super(e),this.supportsMasking=!0,this.stddev=e.stddev}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),r={stddev:this.stddev};return Object.assign(r,e),r}call(e,r){return Se(()=>{this.invokeCallHook(e,r);const i=zt(e);return Eg(()=>Xe(Dv(i.shape,0,this.stddev),i),()=>i,r.training||!1)})}}return n.className="GaussianNoise",n})()),Ye((()=>{class n extends dn{constructor(e){super(e),this.supportsMasking=!0,this.rate=e.rate}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),r={rate:this.rate};return Object.assign(r,e),r}call(e,r){return Se(()=>{this.invokeCallHook(e,r);const i=zt(e);return this.rate>0&&this.rate<1?Eg(()=>{const s=Math.sqrt(this.rate/(1-this.rate));return fe(i,Dv(i.shape,1,s))},()=>i,r.training||!1):i})}}return n.className="GaussianDropout",n})()),Ye((()=>{class n extends dn{constructor(e){super(e),this.supportsMasking=!0,this.rate=e.rate,this.noiseShape=e.noiseShape}_getNoiseShape(e){return this.noiseShape||zt(e).shape}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),r={rate:this.rate};return Object.assign(r,e),r}call(e,r){return Se(()=>{if(this.rate<1&&this.rate>0){const i=this._getNoiseShape(e);return Eg(()=>{const s=zt(e),u=-1.7580993408473766;let p=Cc(Pu(i),this.rate);p=Ua(p,"float32");const m=((1-this.rate)*(1+this.rate*u**2))**-.5,g=-m*u*this.rate,_=Xe(fe(s,p),fe(Xe(p,-1),u));return Xe(fe(_,m),g)},()=>zt(e),r.training||!1)}return e})}}return n.className="AlphaDropout",n})()),Ye((()=>{class n extends dn{constructor(e){null==e&&(e={}),super(e),this.supportsMasking=!0,this.axis=null==e.axis?-1:e.axis,this.momentum=null==e.momentum?.99:e.momentum,this.epsilon=null==e.epsilon?.001:e.epsilon,this.center=null==e.center||e.center,this.scale=null==e.scale||e.scale,this.betaInitializer=ar(e.betaInitializer||"zeros"),this.gammaInitializer=ar(e.gammaInitializer||"ones"),this.movingMeanInitializer=ar(e.movingMeanInitializer||"zeros"),this.movingVarianceInitializer=ar(e.movingVarianceInitializer||"ones"),this.betaConstraint=si(e.betaConstraint),this.gammaConstraint=si(e.gammaConstraint),this.betaRegularizer=lr(e.betaRegularizer),this.gammaRegularizer=lr(e.gammaRegularizer)}build(e){e=Dn(e);const r=this.axis>=0?this.axis:this.axis+e.length,i=e[r];if(null==i)throw new ye(`Axis ${r} of input tensor should have a defined dimension but the layer received an input with shape ${JSON.stringify(e)}.`);this.inputSpec=[new ii({ndim:e.length,axes:{[r]:i}})];const o=[i];this.scale&&(this.gamma=this.addWeight("gamma",o,null,this.gammaInitializer,this.gammaRegularizer,!0,this.gammaConstraint)),this.center&&(this.beta=this.addWeight("beta",o,null,this.betaInitializer,this.betaRegularizer,!0,this.betaConstraint)),this.movingMean=this.addWeight("moving_mean",o,null,this.movingMeanInitializer,null,!1),this.movingVariance=this.addWeight("moving_variance",o,null,this.movingVarianceInitializer,null,!1),this.built=!0}call(e,r){return Se(()=>{const i=null!=r.training&&r.training,o=zt(e),s=o.shape,a=s.length,c=ca(0,a),u=this.axis>=0?this.axis:this.axis+a;c.splice(u,1);const p=Bu(1,a);p[u]=s[u];const m=c.slice();m.sort();const g=!mn(m,ca(0,a).slice(0,a-1));if(!i)return(()=>{if(g){const L=be(this.movingMean.read(),p),V=be(this.movingVariance.read(),p),j=this.center?be(this.beta.read(),p):null,Y=this.scale?be(this.gamma.read(),p):null;return Mg(o,L,V,j,Y,this.epsilon)}return Mg(o,this.movingMean.read(),this.movingVariance.read(),null==this.beta?null:this.beta.read(),null==this.gamma?null:this.gamma.read(),this.epsilon)})();const[x,T,I]=function Xfe(n,t,e,r,i=.001){return mn(r.slice().sort(),ca(0,n.rank-1))?function qfe(n,t,e,r,i=.001){return Se(()=>{const o=av(n,r),s=o.mean,a=o.variance;return[Mg(n,s,a,e,t,i),s,a]})}(n,t,e,r,i):function Kfe(n,t,e,r,i=.001){return Se(()=>{const o=av(n,r),s=o.mean,a=o.variance,c=[];for(const x of ca(0,n.rank))-1!==r.indexOf(x)?c.push(1):c.push(n.shape[x]);const u=be(s,c),p=be(a,c),m=null==t?null:be(t,c),g=null==e?null:be(e,c);return[Mg(n,u,p,g,m,i),s,a]})}(n,t,e,r,i)}(o,this.gamma.read(),this.beta.read(),c,this.epsilon),N=(L,V,j)=>{Se(()=>{const Y=1-j,ee=L.read(),ie=fe(xt(ee,V),Y);L.write(xt(ee,ie))})};return(()=>{N(this.movingMean,T,this.momentum),N(this.movingVariance,I,this.momentum)})(),x})}getConfig(){const e={axis:this.axis,momentum:this.momentum,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:mr(this.betaInitializer),gammaInitializer:mr(this.gammaInitializer),movingMeanInitializer:mr(this.movingMeanInitializer),movingVarianceInitializer:mr(this.movingVarianceInitializer),betaRegularizer:Wn(this.betaRegularizer),gammaRegularizer:Wn(this.gammaRegularizer),betaConstraint:oi(this.betaConstraint),gammaConstraint:oi(this.gammaConstraint)},r=super.getConfig();return Object.assign(e,r),e}}return n.className="BatchNormalization",n})()),Ye((()=>{class n extends dn{constructor(e){if(null==e&&(e={}),super(e),this.axis=null==e.axis?-1:e.axis,"number"==typeof this.axis){if(!Number.isInteger(this.axis))throw new Error(`Expected axis to be an integer, but received ${this.axis}`)}else{if(!Array.isArray(this.axis))throw new Error(`Expected axis to be an integer or an array of integers, but received ${JSON.stringify(this.axis)}`);for(const r of this.axis)if(!Number.isInteger(r))throw new Error(`Expected axis to be an array of integers, but received ${JSON.stringify(this.axis)}`)}this.epsilon=null==e.epsilon?.001:e.epsilon,this.center=null==e.center||e.center,this.scale=null==e.scale||e.scale,this.betaInitializer=ar(e.betaInitializer||"zeros"),this.gammaInitializer=ar(e.gammaInitializer||"ones"),this.betaRegularizer=lr(e.betaRegularizer),this.gammaRegularizer=lr(e.gammaRegularizer),this.supportsMasking=!0}build(e){const r=(e=Dn(e)).length;"number"==typeof this.axis&&(this.axis=[this.axis]);for(let s=0;s<this.axis.length;++s)this.axis[s]<0&&(this.axis[s]+=r);for(const s of this.axis)if(s<0||s>=r)throw new Error(`Invalid axis: ${s}`);if(this.axis.length!==Ec(this.axis).length)throw new Error(`Found duplicate axes in: ${this.axis}`);const i=this.axis.map(s=>e[s]);this.gamma=this.scale?this.addWeight("gamma",i,"float32",this.gammaInitializer,this.gammaRegularizer,!0):null,this.beta=this.center?this.addWeight("beta",i,"float32",this.betaInitializer,this.betaRegularizer,!0):null,this.built=!0}call(e,r){const i=zt(e),o=i.shape,s=o.length;return Se(()=>{let{mean:c,variance:u}=av(i,this.axis,!0);const p=Bu(1,s);for(const I of this.axis)p[I]=o[I];const m=I=>null!=I&&I.shape.length!==s?be(I,p):I;let g=this.scale?m(this.gamma.read()):null,_=this.center?m(this.beta.read()):null;const x=[],T=[];for(let I=0;I<s;++I)-1!==this.axis.indexOf(I)?(x.push(o[I]),T.push(1)):(x.push(1),T.push(o[I]));return c=Fs(c,x),u=Fs(u,x),null!=g&&(g=Fs(g,T)),null!=_&&(_=Fs(_,T)),Mg(i,c,u,_,g,this.epsilon)})}getConfig(){const e={axis:this.axis,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:mr(this.betaInitializer),gammaInitializer:mr(this.gammaInitializer),betaRegularizer:Wn(this.betaRegularizer),gammaRegularizer:Wn(this.gammaRegularizer)},r=super.getConfig();return Object.assign(e,r),e}}return n.className="LayerNormalization",n})()),Ye((()=>{class n extends dn{constructor(e){if(null==e&&(e={}),super(e),this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,null==e.padding)this.padding=[[1,1],[1,1]];else if("number"==typeof e.padding)this.padding=[[e.padding,e.padding],[e.padding,e.padding]];else{if(e.padding=e.padding,2!==e.padding.length)throw new ye(`ZeroPadding2D expects padding to be a length-2 array, but received a length-${e.padding.length} array.`);let r,i;if("number"==typeof e.padding[0])r=[e.padding[0],e.padding[0]],i=[e.padding[1],e.padding[1]];else{if(e.padding=e.padding,2!==e.padding[0].length)throw new ye(`ZeroPadding2D expects height padding to be a length-2 array, but received a length-${e.padding[0].length} array.`);if(r=e.padding[0],2!==e.padding[1].length)throw new ye(`ZeroPadding2D expects width padding to be a length-2 array, but received a length-${e.padding[1].length} array.`);i=e.padding[1]}this.padding=[r,i]}this.inputSpec=[new ii({ndim:4})]}computeOutputShape(e){let r,i;return e=Dn(e),"channelsFirst"===this.dataFormat?(r=null!=e[2]&&e[2]>=0?e[2]+this.padding[0][0]+this.padding[0][1]:null,i=null!=e[3]&&e[3]>=0?e[3]+this.padding[1][0]+this.padding[1][1]:null,[e[0],e[1],r,i]):(r=null!=e[1]&&e[1]>=0?e[1]+this.padding[0][0]+this.padding[0][1]:null,i=null!=e[2]&&e[2]>=0?e[2]+this.padding[1][0]+this.padding[1][1]:null,[e[0],r,i,e[3]])}call(e,r){return Se(()=>function Yfe(n,t,e){return Se(()=>{if(4!==n.rank)throw new ye(`temporalPadding expects input tensor to be 4-D, but received a ${n.rank}-D tensor.`);if(null==t&&(t=[[1,1],[1,1]]),2!==t.length||2!==t[0].length||2!==t[1].length)throw new ye("spatial2dPadding expects `padding` to be an Array of two Arrays, each of which is an Array of two integers.");if(null==e&&(e="channelsLast"),"channelsLast"!==e&&"channelsFirst"!==e)throw new ye(`Unknown data format: ${e}. Supported data formats are 'channelsLast' and 'channelsFirst.`);let r;return r="channelsFirst"===e?[[0,0],[0,0],t[0],t[1]]:[[0,0],t[0],t[1],[0,0]],Ic(n,r)})}(zt(e),this.padding,this.dataFormat))}getConfig(){const e={padding:this.padding,dataFormat:this.dataFormat},r=super.getConfig();return Object.assign(e,r),e}}return n.className="ZeroPadding2D",n})());class hz extends dn{constructor(t){if(null==t.poolSize&&(t.poolSize=2),super(t),"number"==typeof t.poolSize)this.poolSize=[t.poolSize];else{if(!Array.isArray(t.poolSize)||1!==t.poolSize.length||"number"!=typeof t.poolSize[0])throw new ye(`poolSize for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(t.poolSize)}`);this.poolSize=t.poolSize}if(bi(this.poolSize,"poolSize"),null==t.strides)this.strides=this.poolSize;else if("number"==typeof t.strides)this.strides=[t.strides];else{if(!Array.isArray(t.strides)||1!==t.strides.length||"number"!=typeof t.strides[0])throw new ye(`strides for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(t.strides)}`);this.strides=t.strides}bi(this.strides,"strides"),this.padding=null==t.padding?"valid":t.padding,fs(this.padding),this.inputSpec=[new ii({ndim:3})]}computeOutputShape(t){const e=fa((t=Dn(t))[1],this.poolSize[0],this.padding,this.strides[0]);return[t[0],e,t[2]]}call(t,e){return Se(()=>{this.invokeCallHook(t,e),t=Cg(zt(t),2);const r=this.poolingFunction(zt(t),[this.poolSize[0],1],[this.strides[0],1],this.padding,"channelsLast");return $u(r,[2])})}getConfig(){const t={poolSize:this.poolSize,padding:this.padding,strides:this.strides},e=super.getConfig();return Object.assign(t,e),t}}Ye((()=>{class n extends hz{constructor(e){super(e)}poolingFunction(e,r,i,o,s){return Fr(s),fs(o),Hv(e,r,i,o,s,"max")}}return n.className="MaxPooling1D",n})()),Ye((()=>{class n extends hz{constructor(e){super(e)}poolingFunction(e,r,i,o,s){return Fr(s),fs(o),Hv(e,r,i,o,s,"avg")}}return n.className="AveragePooling1D",n})());class pz extends dn{constructor(t){if(null==t.poolSize&&(t.poolSize=[2,2]),super(t),this.poolSize=Array.isArray(t.poolSize)?t.poolSize:[t.poolSize,t.poolSize],null==t.strides)this.strides=this.poolSize;else if(Array.isArray(t.strides)){if(2!==t.strides.length)throw new ye(`If the strides property of a 2D pooling layer is an Array, it is expected to have a length of 2, but received length ${t.strides.length}.`);this.strides=t.strides}else this.strides=[t.strides,t.strides];bi(this.poolSize,"poolSize"),bi(this.strides,"strides"),this.padding=null==t.padding?"valid":t.padding,this.dataFormat=null==t.dataFormat?"channelsLast":t.dataFormat,Fr(this.dataFormat),fs(this.padding),this.inputSpec=[new ii({ndim:4})]}computeOutputShape(t){t=Dn(t);let e="channelsFirst"===this.dataFormat?t[2]:t[1],r="channelsFirst"===this.dataFormat?t[3]:t[2];return e=fa(e,this.poolSize[0],this.padding,this.strides[0]),r=fa(r,this.poolSize[1],this.padding,this.strides[1]),"channelsFirst"===this.dataFormat?[t[0],t[1],e,r]:[t[0],e,r,t[3]]}call(t,e){return Se(()=>(this.invokeCallHook(t,e),this.poolingFunction(zt(t),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){const t={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(t,e),t}}Ye((()=>{class n extends pz{constructor(e){super(e)}poolingFunction(e,r,i,o,s){return Fr(s),fs(o),Hv(e,r,i,o,s,"max")}}return n.className="MaxPooling2D",n})()),Ye((()=>{class n extends pz{constructor(e){super(e)}poolingFunction(e,r,i,o,s){return Fr(s),fs(o),Hv(e,r,i,o,s,"avg")}}return n.className="AveragePooling2D",n})());class fz extends dn{constructor(t){if(null==t.poolSize&&(t.poolSize=[2,2,2]),super(t),this.poolSize=Array.isArray(t.poolSize)?t.poolSize:[t.poolSize,t.poolSize,t.poolSize],null==t.strides)this.strides=this.poolSize;else if(Array.isArray(t.strides)){if(3!==t.strides.length)throw new ye(`If the strides property of a 3D pooling layer is an Array, it is expected to have a length of 3, but received length ${t.strides.length}.`);this.strides=t.strides}else this.strides=[t.strides,t.strides,t.strides];bi(this.poolSize,"poolSize"),bi(this.strides,"strides"),this.padding=null==t.padding?"valid":t.padding,this.dataFormat=null==t.dataFormat?"channelsLast":t.dataFormat,Fr(this.dataFormat),fs(this.padding),this.inputSpec=[new ii({ndim:5})]}computeOutputShape(t){t=Dn(t);let e="channelsFirst"===this.dataFormat?t[2]:t[1],r="channelsFirst"===this.dataFormat?t[3]:t[2],i="channelsFirst"===this.dataFormat?t[4]:t[3];return e=fa(e,this.poolSize[0],this.padding,this.strides[0]),r=fa(r,this.poolSize[1],this.padding,this.strides[1]),i=fa(i,this.poolSize[2],this.padding,this.strides[2]),"channelsFirst"===this.dataFormat?[t[0],t[1],e,r,i]:[t[0],e,r,i,t[4]]}call(t,e){return Se(()=>(this.invokeCallHook(t,e),this.poolingFunction(zt(t),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){const t={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(t,e),t}}Ye((()=>{class n extends fz{constructor(e){super(e)}poolingFunction(e,r,i,o,s){return Fr(s),fs(o),dz(e,r,i,o,s,"max")}}return n.className="MaxPooling3D",n})()),Ye((()=>{class n extends fz{constructor(e){super(e)}poolingFunction(e,r,i,o,s){return Fr(s),fs(o),dz(e,r,i,o,s,"avg")}}return n.className="AveragePooling3D",n})());class mz extends dn{constructor(t){super(t),this.inputSpec=[new ii({ndim:3})]}computeOutputShape(t){return[t[0],t[2]]}call(t,e){throw new en}}Ye((()=>{class n extends mz{constructor(e){super(e||{})}call(e,r){return Se(()=>{const i=zt(e);return Sr(i,1)})}}return n.className="GlobalAveragePooling1D",n})()),Ye((()=>{class n extends mz{constructor(e){super(e||{})}call(e,r){return Se(()=>{const i=zt(e);return Ms(i,1)})}}return n.className="GlobalMaxPooling1D",n})());class gz extends dn{constructor(t){super(t),this.dataFormat=null==t.dataFormat?"channelsLast":t.dataFormat,Fr(this.dataFormat),this.inputSpec=[new ii({ndim:4})]}computeOutputShape(t){return"channelsLast"===this.dataFormat?[t[0],t[3]]:[t[0],t[1]]}call(t,e){throw new en}getConfig(){const t={dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(t,e),t}}Ye((()=>{class n extends gz{call(e,r){return Se(()=>{const i=zt(e);return Sr(i,"channelsLast"===this.dataFormat?[1,2]:[2,3])})}}return n.className="GlobalAveragePooling2D",n})()),Ye((()=>{class n extends gz{call(e,r){return Se(()=>{const i=zt(e);return Ms(i,"channelsLast"===this.dataFormat?[1,2]:[2,3])})}}return n.className="GlobalMaxPooling2D",n})());class bz extends dn{constructor(t){super(t),this.layer=t.layer}build(t){this.built=!0}get trainable(){return null!=this.layer&&this.layer.trainable}set trainable(t){null!=this.layer&&(this.layer.trainable=t)}get trainableWeights(){return this.layer.trainableWeights}get nonTrainableWeights(){return this.layer.nonTrainableWeights}get updates(){return this.layer._updates}get losses(){return this.layer.losses}getWeights(){return this.layer.getWeights()}setWeights(t){this.layer.setWeights(t)}getConfig(){const t={layer:{className:this.layer.getClassName(),config:this.layer.getConfig()}},e=super.getConfig();return Object.assign(t,e),t}setFastWeightInitDuringBuild(t){super.setFastWeightInitDuringBuild(t),null!=this.layer&&this.layer.setFastWeightInitDuringBuild(t)}static fromConfig(t,e,r={}){const o=Dl(e.layer,r);delete e.layer;const s={layer:o};return Object.assign(s,e),new t(s)}}Ye((()=>{class n extends bz{constructor(e){super(e),this.supportsMasking=!0}build(e){if((e=Dn(e)).length<3)throw new ye(`TimeDistributed layer expects an input shape >= 3D, but received input shape ${JSON.stringify(e)}`);this.inputSpec=[{shape:e}];const r=[e[0]].concat(e.slice(2));this.layer.built||(this.layer.build(r),this.layer.built=!0),super.build(e)}computeOutputShape(e){const r=[(e=Dn(e))[0]].concat(e.slice(2)),i=this.layer.computeOutputShape(r);return[i[0],e[1]].concat(i.slice(1))}call(e,r){return Se(()=>oz((a,c)=>[zt(this.layer.call(a,r)),[]],e=zt(e),[],!1,null,null,!1,!0)[1])}}return n.className="TimeDistributed",n})()),Ye((()=>{class n extends bz{constructor(e){super(e);const r=e.layer.getConfig(),i={};i.className=e.layer.getClassName(),i.config=r,this.forwardLayer=Dl(i),r.goBackwards=!0!==r.goBackwards;const o={};if(o.className=e.layer.getClassName(),o.config=r,this.backwardLayer=Dl(o),this.forwardLayer.name="forward_"+this.forwardLayer.name,this.backwardLayer.name="backward_"+this.backwardLayer.name,this.mergeMode=void 0===e.mergeMode?"concat":e.mergeMode,function Zfe(n){zu(vpe,"BidirectionalMergeMode",n)}(this.mergeMode),e.weights)throw new en("weights support is not implemented for Bidirectional layer yet.");this._stateful=e.layer.stateful,this.returnSequences=e.layer.returnSequences,this.returnState=e.layer.returnState,this.supportsMasking=!0,this._trainable=!0,this.inputSpec=e.layer.inputSpec,this.numConstants=null}get trainable(){return this._trainable}set trainable(e){this._trainable=e,null!=this.forwardLayer&&(this.forwardLayer.trainable=e),null!=this.backwardLayer&&(this.backwardLayer.trainable=e)}getWeights(){return this.forwardLayer.getWeights().concat(this.backwardLayer.getWeights())}setWeights(e){const i=Math.floor(e.length/2);this.forwardLayer.setWeights(e.slice(0,i)),this.backwardLayer.setWeights(e.slice(i))}computeOutputShape(e){let i,o,s,r=this.forwardLayer.computeOutputShape(e);return Array.isArray(r)&&Array.isArray(r[0])||(r=[r]),this.returnState&&(s=r.slice(1)),i=r[0],"concat"===this.mergeMode?(i[i.length-1]*=2,o=[i]):o=null==this.mergeMode?[i,i.slice()]:[i],this.returnState?null==this.mergeMode?o.concat(s).concat(s.slice()):[i].concat(s).concat(s.slice()):Co(o)}apply(e,r){let i=null==r?null:r.initialState,o=null==r?null:r.constants;null==r&&(r={});const s=iz(e,i,o,this.numConstants);if(e=s.inputs,i=s.initialState,o=s.constants,Array.isArray(e)&&(i=e.slice(1),e=e[0]),(null==i||0===i.length)&&null==o)return super.apply(e,r);const a=[],c=[];if(null!=i){const p=i.length;if(p%2>0)throw new ye("When passing `initialState` to a Bidrectional RNN, the state should be an Array containing the states of the underlying RNNs.");r.initialState=i,a.push(...i);const m=i.map(g=>new ii({shape:g.shape}));this.forwardLayer.stateSpec=m.slice(0,p/2),this.backwardLayer.stateSpec=m.slice(p/2),c.push(...m)}if(null!=o)throw new en("Support for constants in Bidirectional layers is not implemented yet.");const u=a[0]instanceof Ha;for(const p of a)if(p instanceof Ha!==u)throw new ye("The initial state of a Bidirectional layer cannot be specified as a mix of symbolic and non-symbolic tensors");if(u){const p=[e].concat(a),m=this.inputSpec.concat(c),g=this.inputSpec;this.inputSpec=m;const _=super.apply(p,r);return this.inputSpec=g,_}return super.apply(e,r)}call(e,r){return Se(()=>{const i=r.initialState;let o,s,a,c;if(null==i)o=this.forwardLayer.call(e,r),s=this.backwardLayer.call(e,r);else{const u=i.slice(0,i.length/2),p=i.slice(i.length/2);o=this.forwardLayer.call(e,Object.assign(r,{initialState:u})),s=this.backwardLayer.call(e,Object.assign(r,{initialState:p}))}return this.returnState&&(Array.isArray(o)&&(a=o.slice(1).concat(s.slice(1))),o=o[0],s=s[0]),this.returnSequences&&(s=Ps(s,1)),"concat"===this.mergeMode?c=ED([o,s]):"sum"===this.mergeMode?c=Xe(o,s):"ave"===this.mergeMode?c=fe(.5,Xe(o,s)):"mul"===this.mergeMode?c=fe(o,s):null==this.mergeMode&&(c=[o,s]),this.returnState?null==this.mergeMode?c.concat(a):[c].concat(a):c})}resetStates(e){this.forwardLayer.resetStates(),this.backwardLayer.resetStates()}build(e){Uu(this.forwardLayer.name,()=>{this.forwardLayer.build(e)}),Uu(this.backwardLayer.name,()=>{this.backwardLayer.build(e)}),this.built=!0}computeMask(e,r){let i;if(Array.isArray(r)&&(r=r[0]),i=this.returnSequences?null==this.mergeMode?[r,r]:r:null==this.mergeMode?[null,null]:null,this.returnState){const s=this.forwardLayer.states.map(a=>null);return Array.isArray(i)?i.concat(s).concat(s):[i].concat(s).concat(s)}return i}get trainableWeights(){return this.forwardLayer.trainableWeights.concat(this.backwardLayer.trainableWeights)}get nonTrainableWeights(){return this.forwardLayer.nonTrainableWeights.concat(this.backwardLayer.nonTrainableWeights)}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),null!=this.forwardLayer&&this.forwardLayer.setFastWeightInitDuringBuild(e),null!=this.backwardLayer&&this.backwardLayer.setFastWeightInitDuringBuild(e)}getConfig(){const e={mergeMode:this.mergeMode},r=super.getConfig();return Object.assign(e,r),e}static fromConfig(e,r){const i=Dl(r.layer);if(delete r.layer,null!=r.numConstants)throw new en("Deserialization of a Bidirectional layer with numConstants present is not supported yet.");const o=r;return o.layer=i,new e(o)}}return n.className="Bidirectional",n})()),Ye((()=>{class n extends dn{constructor(e){super(e),this.scale=e.scale,this.offset=e.offset?e.offset:0}getConfig(){const e={scale:this.scale,offset:this.offset},r=super.getConfig();return Object.assign(e,r),e}call(e,r){return Se(()=>("float32"!==(e=zt(e)).dtype&&(e=Ua(e,"float32")),Xe(fe(e,this.scale),this.offset)))}}return n.className="Rescaling",n})());const{resizeBilinear:Jfe,cropAndResize:eme}=Ba;Ye((()=>{class n extends dn{constructor(e){super(e),this.height=e.height,this.width=e.width}centerCrop(e,r,i,o,s,a,c,u){return Se(()=>{let p,m=!1;const I=[r/a,i/c,(o+r)/a,(s+i)/c],N=[];3===e.rank?(m=!0,p=hs([e])):p=e;for(let Y=0;Y<p.shape[0];Y++)N.push(I);const R=aa(N,[N.length,4]),L=Lh(0,N.length,1,"int32"),j=eme(p,R,L,[o,s],"nearest");return Ua(m?zt($s(j)):j,u)})}upsize(e,r,i,o){return Se(()=>Ua(Jfe(e,[r,i]),o))}call(e,r){return Se(()=>{const i=zt(e),o=i.dtype,s=i.shape,a=s[s.length-3],c=s[s.length-2];let u=0;a!==this.height&&(u=Math.floor((a-this.height)/2));let p=0;return c!==this.width&&(p=Math.floor((c-this.width)/2),0===p&&(p=1)),u>=0&&p>=0?this.centerCrop(i,u,p,this.height,this.width,a,c,o):this.upsize(e,this.height,this.width,o)})}getConfig(){const e={height:this.height,width:this.width},r=super.getConfig();return Object.assign(e,r),e}computeOutputShape(e){const i=(e=Dn(e)).length-2;return e[e.length-3]=this.height,e[i]=this.width,e}}return n.className="CenterCrop",n})()),Ye((()=>{class n extends dn{constructor(e){super(e),this.numTokens=e.numTokens,this.outputMode=e.outputMode?e.outputMode:"multiHot"}getConfig(){const e={numTokens:this.numTokens,outputMode:this.outputMode},r=super.getConfig();return Object.assign(e,r),e}computeOutputShape(e){return null==(e=Dn(e))?[this.numTokens]:"oneHot"===this.outputMode&&1!==e[e.length-1]?(e.push(this.numTokens),e):(e[e.length-1]=this.numTokens,e)}call(e,r){return Se(()=>{let i;if("int32"!==(e=zt(e)).dtype&&(e=Ua(e,"int32")),typeof r.countWeights<"u"){if("count"!==this.outputMode)throw new ye(`countWeights is not used when outputMode !== count.\n              Received countWeights=${r.countWeights}`);i=zt(r.countWeights)}const o=Ms(e),s=hg(e),a=jo(this.numTokens,o).bufferSync().get(0),c=Cc(s,0).bufferSync().get(0);if(!a||!c)throw new ye(`Input values must be between 0 < values <= numTokens with numTokens=${this.numTokens}`);return function tme(n,t,e,r){let i=zt(n);if("int32"!==i.dtype&&(i=Ua(i,"int32")),"int"===t)return i;const o=i.shape;if(0===i.rank&&(i=To(i,-1)),"oneHot"===t&&1!==i.shape[i.shape.length-1]&&(i=To(i,-1)),i.rank>2)throw new ye(`When outputMode is not int, maximum output rank is 2 Received outputMode ${t} and input shape ${o} which would result in output rank ${i.rank}.`);const s=["multiHot","oneHot"].includes(t);let c;if(c=mE(i,typeof r<"u"&&"count"===t?r:[],e,s),"tfIdf"!==t)return c;if(r)return fe(c,r);throw new ye("When outputMode is 'tfIdf', weights must be provided.")}(e,this.outputMode,this.numTokens,i)})}}return n.className="CategoryEncoding",n})());const yz=new Set(["bilinear","nearest"]);Ye((()=>{class n extends dn{constructor(e){if(super(e),this.height=e.height,this.width=e.width,e.interpolation){if(!yz.has(e.interpolation))throw new ye(`Invalid interpolation parameter: ${e.interpolation} is not implemented`);this.interpolation=e.interpolation}else this.interpolation="bilinear";this.cropToAspectRatio=!!e.cropToAspectRatio}computeOutputShape(e){return e=Dn(e),[this.height,this.width,e[2]]}getConfig(){const e={height:this.height,width:this.width,interpolation:this.interpolation,cropToAspectRatio:this.cropToAspectRatio},r=super.getConfig();return Object.assign(e,r),e}call(e,r){return Se(()=>{const i=[this.height,this.width];if("bilinear"===this.interpolation)return Ba.resizeBilinear(e,i,!this.cropToAspectRatio);if("nearest"===this.interpolation)return Ba.resizeNearestNeighbor(e,i,!this.cropToAspectRatio);throw new Error(`Interpolation is ${this.interpolation} but only ${[...yz]} are supported`)})}}return n.className="Resizing",n})());let rme=(()=>{class n{constructor(e){this.seed=e}next(){if(void 0!==this.seed)return this.seed++}}return n.className="RandomSeed",n})(),ime=(()=>{class n extends dn{constructor(e){super(e),this.randomGenerator=new rme(e.seed)}getConfig(){const e={seed:this.randomGenerator.seed},r=super.getConfig();return Object.assign(e,r),e}}return n.className="BaseRandomLayer",n})();const _z=new Set(["bilinear","nearest"]);Ye((()=>{class n extends ime{constructor(e){super(e);const{factor:r,interpolation:i="bilinear"}=e;if(this.factor=r,Array.isArray(this.factor)&&2===this.factor.length)this.widthLower=this.factor[0],this.widthUpper=this.factor[1];else{if(Array.isArray(this.factor)||!(this.factor>0))throw new ye(`Invalid factor: ${this.factor}. Must be positive number or tuple of 2 numbers`);this.widthLower=-this.factor,this.widthUpper=this.factor}if(this.widthLower<-1||this.widthUpper<-1)throw new ye(`factor must have values larger than -1. Got: ${this.factor}`);if(this.widthUpper<this.widthLower)throw new ye(`factor cannot have upper bound less than lower bound.\n        Got upper bound: ${this.widthUpper}.\n        Got lower bound: ${this.widthLower}\n      `);if(i){if(!_z.has(i))throw new ye(`Invalid interpolation parameter: ${i} is not implemented`);this.interpolation=i}}getConfig(){const e={factor:this.factor,interpolation:this.interpolation},r=super.getConfig();return Object.assign(e,r),e}computeOutputShape(e){return e=Dn(e),[this.imgHeight,-1,e[2]]}call(e,r){return Se(()=>{const i=zt(e);this.imgHeight=i.shape[i.shape.length-3];const o=i.shape[i.shape.length-2];this.widthFactor=Pu([1],1+this.widthLower,1+this.widthUpper,"float32",this.randomGenerator.next());let s=this.widthFactor.dataSync()[0]*o;s=Math.round(s);const a=[this.imgHeight,s];switch(this.interpolation){case"bilinear":return Ba.resizeBilinear(e,a);case"nearest":return Ba.resizeNearestNeighbor(e,a);default:throw new Error(`Interpolation is ${this.interpolation}\n          but only ${[..._z]} are supported`)}})}}return n.className="RandomWidth",n})()),Ie().registerFlag("KEEP_INTERMEDIATE_TENSORS",()=>!1,n=>{n&&console.warn("Keep intermediate tensors is ON. This will print the values of all intermediate tensors during model inference. Not all models support this mode. For details, check e2e/benchmarks/ model_config.js. This significantly impacts performance.")});var Sz,Ke=(()=>((Ke=Ke||{})[Ke.DT_INVALID=0]="DT_INVALID",Ke[Ke.DT_FLOAT=1]="DT_FLOAT",Ke[Ke.DT_DOUBLE=2]="DT_DOUBLE",Ke[Ke.DT_INT32=3]="DT_INT32",Ke[Ke.DT_UINT8=4]="DT_UINT8",Ke[Ke.DT_INT16=5]="DT_INT16",Ke[Ke.DT_INT8=6]="DT_INT8",Ke[Ke.DT_STRING=7]="DT_STRING",Ke[Ke.DT_COMPLEX64=8]="DT_COMPLEX64",Ke[Ke.DT_INT64=9]="DT_INT64",Ke[Ke.DT_BOOL=10]="DT_BOOL",Ke[Ke.DT_QINT8=11]="DT_QINT8",Ke[Ke.DT_QUINT8=12]="DT_QUINT8",Ke[Ke.DT_QINT32=13]="DT_QINT32",Ke[Ke.DT_BFLOAT16=14]="DT_BFLOAT16",Ke[Ke.DT_QINT16=15]="DT_QINT16",Ke[Ke.DT_QUINT16=16]="DT_QUINT16",Ke[Ke.DT_UINT16=17]="DT_UINT16",Ke[Ke.DT_COMPLEX128=18]="DT_COMPLEX128",Ke[Ke.DT_HALF=19]="DT_HALF",Ke[Ke.DT_RESOURCE=20]="DT_RESOURCE",Ke[Ke.DT_VARIANT=21]="DT_VARIANT",Ke[Ke.DT_UINT32=22]="DT_UINT32",Ke[Ke.DT_UINT64=23]="DT_UINT64",Ke[Ke.DT_FLOAT_REF=101]="DT_FLOAT_REF",Ke[Ke.DT_DOUBLE_REF=102]="DT_DOUBLE_REF",Ke[Ke.DT_INT32_REF=103]="DT_INT32_REF",Ke[Ke.DT_UINT8_REF=104]="DT_UINT8_REF",Ke[Ke.DT_INT16_REF=105]="DT_INT16_REF",Ke[Ke.DT_INT8_REF=106]="DT_INT8_REF",Ke[Ke.DT_STRING_REF=107]="DT_STRING_REF",Ke[Ke.DT_COMPLEX64_REF=108]="DT_COMPLEX64_REF",Ke[Ke.DT_INT64_REF=109]="DT_INT64_REF",Ke[Ke.DT_BOOL_REF=110]="DT_BOOL_REF",Ke[Ke.DT_QINT8_REF=111]="DT_QINT8_REF",Ke[Ke.DT_QUINT8_REF=112]="DT_QUINT8_REF",Ke[Ke.DT_QINT32_REF=113]="DT_QINT32_REF",Ke[Ke.DT_BFLOAT16_REF=114]="DT_BFLOAT16_REF",Ke[Ke.DT_QINT16_REF=115]="DT_QINT16_REF",Ke[Ke.DT_QUINT16_REF=116]="DT_QUINT16_REF",Ke[Ke.DT_UINT16_REF=117]="DT_UINT16_REF",Ke[Ke.DT_COMPLEX128_REF=118]="DT_COMPLEX128_REF",Ke[Ke.DT_HALF_REF=119]="DT_HALF_REF",Ke[Ke.DT_RESOURCE_REF=120]="DT_RESOURCE_REF",Ke[Ke.DT_VARIANT_REF=121]="DT_VARIANT_REF",Ke[Ke.DT_UINT32_REF=122]="DT_UINT32_REF",Ke[Ke.DT_UINT64_REF=123]="DT_UINT64_REF",Ke))();!function(n){let t;var e;(e=t=n.CheckpointFormatVersion||(n.CheckpointFormatVersion={}))[e.LEGACY=0]="LEGACY",e[e.V1=1]="V1",e[e.V2=2]="V2"}(Sz||(Sz={}));const uk={};function Cz(n){return uk[n]}function U(n,t,e,r,i){const o=t.inputParams[n];if(o&&void 0!==o.inputIndexStart){const a=o.inputIndexStart,c=0===o.inputIndexEnd?void 0:void 0===o.inputIndexEnd?a+1:o.inputIndexEnd,u=a<0?t.inputNames.length+a:a;if("tensor"===o.type)return Ai(t.inputNames[u],e,r,i);if("tensors"===o.type){const g=t.inputs.slice(a,c);return t.inputNames.slice(a,c).filter((x,T)=>{var I;return"NoOp"!==(null===(I=g[T])||void 0===I?void 0:I.op)}).map(x=>Ai(x,e,r,i))}const p=Ai(t.inputNames[u],e,r,i),m=p.dataSync();return"number"===o.type?m[0]:As(p.shape,m)}const s=t.attrParams[n];return s&&s.value}function Ai(n,t,e,r){const[i,o]=Ho(n,e);if(null!=r){const a=r.getHashTableHandleByName(i);if(null!=a)return a}const s=e.currentContextIds.find(a=>!!t[qv(i,a)]);return void 0!==s?t[qv(i,s)][o]:void 0}function Iz(n,t,e){return t[qv(n,e.currentContextId)]}function kl(n,t){const[e,r,i]=Ho(n,t);return[qv(e,t&&t.currentContextId),r,i]}function qv(n,t){return t?`${n}-${t}`:n}function Ho(n,t){if(""===n)return["",0,void 0];const e=null!=t&&null!=t.parseNodeNameCache;if(e){const o=t.parseNodeNameCache.get(n);if(null!=o)return o}const r=n.split(":");let i;if(1===r.length)i=[n,0,void 0];else{const s=3===r.length?r[1]:void 0;i=[r[0],Number(r[r.length-1]),s]}return e&&t.parseNodeNameCache.set(n,i),i}function Kv(n,t,e){let r=U("pad",n,t,e);if("explicit"===r){r=U("explicitPaddings",n,t,e);const i=[[0,0],[0,0],[0,0],[0,0]];for(let o=0;o<4;o++)i[o][0]=r[2*o],i[o][1]=r[2*o+1];return i}return r}function Al(n){return n.kept?n:_l(n)}const cme=[{tfOpName:"Add",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddV2",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddN",category:"arithmetic",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"BiasAdd",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"Sub",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"RealDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Div",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"DivNoNan",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mul",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Maximum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Minimum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Pow",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SquaredDifference",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorMod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],ume=[{tfOpName:"Abs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan2",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ceil",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ClipByValue",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"clipValueMin",type:"number"},{start:2,name:"clipValueMax",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Complex",category:"basic_math",inputs:[{start:0,name:"real",type:"tensor"},{start:1,name:"imag",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ComplexAbs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Elu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Exp",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Floor",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Imag",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Neg",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Real",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Prelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"alpha",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu6",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Selu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sigmoid",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Rsqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Square",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sign",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Round",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Expm1",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log1p",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Reciprocal",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Softplus",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Erf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LeakyRelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"alpha",name:"alpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsNan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsFinite",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsInf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],dme=[{tfOpName:"EmptyTensorList",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"maxNumElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"LoopCond",category:"control",inputs:[{start:0,name:"pred",type:"tensor"}]},{tfOpName:"Switch",category:"control",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"pred",type:"tensor"}]},{tfOpName:"Merge",category:"control",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"Enter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"frame_name",name:"frameName",type:"string"},{tfName:"is_constant",name:"isConstant",type:"bool"}]},{tfOpName:"Exit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NextIteration",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayV3",category:"control",inputs:[{start:0,name:"size",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"dynamic_size",name:"dynamicSize",type:"bool"},{tfName:"clear_after_read",name:"clearAfterRead",type:"bool"},{tfName:"identical_element_shapes",name:"identicalElementShapes",type:"bool"},{tfName:"tensor_array_name",name:"name",type:"string"}]},{tfOpName:"TensorArrayWriteV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayReadV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayGatherV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"}]},{tfOpName:"TensorArrayScatterV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArrayConcatV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape_except0",name:"elementShapeExcept0",type:"shape",notSupported:!0}]},{tfOpName:"TensorArraySplitV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"tensor",type:"tensor"},{start:2,name:"lengths",type:"number[]"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArraySizeV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}]},{tfOpName:"TensorArrayCloseV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"}]},{tfOpName:"StatelessIf",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"If",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"StatelessWhile",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"While",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"TensorListScatter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListScatterV2",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"},{start:3,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGather",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListSetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListReserve",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListFromTensor",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListStack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"},{tfName:"num_elements",name:"numElements",type:"dtype"}]},{tfOpName:"TensorListSplit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"},{start:2,name:"lengths",type:"number[]"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcat",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcatV2",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPopBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPushBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListLength",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}]},{tfOpName:"TensorListResize",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"size",type:"number"}]}],hme=[{tfOpName:"AvgPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[],notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPoolWithArgmax",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"include_batch_in_index",name:"includeBatchInIndex",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AvgPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Conv1D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"stride",name:"stride",type:"number"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NWC"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"dilation",name:"dilation",type:"number",defaultValue:1}]},{tfOpName:"Conv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"useCudnnOnGpu",name:"useCudnnOnGpu",type:"bool"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"_FusedConv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"use_cudnn_on_gpu",name:"useCudnnOnGpu",type:"bool",defaultValue:!0},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2}]},{tfOpName:"Conv2DBackpropInput",category:"convolution",inputs:[{start:2,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:0,name:"outputShape",type:"number[]"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]",notSupported:!0}]},{tfOpName:"DepthwiseConv2d",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"DepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"FusedDepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]}]},{tfOpName:"Conv3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"Dilation2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"rates",name:"dilations",type:"number[]"},{tfName:"padding",name:"pad",type:"string"}]}],pme=[{tfOpName:"Fill",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"},{start:1,name:"value",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"LinSpace",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"num",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"OneHot",category:"creation",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"depth",type:"number"},{start:2,name:"onValue",type:"number",defaultValue:1},{start:3,name:"offValue",type:"number",defaultValue:0}],attrs:[{tfName:"axis",name:"axis",type:"number",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Ones",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"OnesLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"RandomStandardNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniform",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number",defaultValue:0},{tfName:"maxval",name:"maxval",type:"number",defaultValue:1},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniformInt",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number"},{tfName:"maxval",name:"maxval",type:"number"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Range",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"step",type:"number",defaultValue:0}],attrs:[{tfName:"Tidx",name:"dtype",type:"dtype"}]},{tfOpName:"TruncatedNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"means",name:"mean",type:"number",defaultValue:0},{tfName:"stddev",name:"stdDev",type:"number",defaultValue:1},{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Zeros",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"ZerosLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Multinomial",category:"creation",inputs:[{start:0,name:"logits",type:"tensor"},{start:1,name:"numSamples",type:"number"}],attrs:[{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number"},{tfName:"T",name:"dtype",type:"dtype"},{tfName:"output_dtype",name:"output_dtype",type:"dtype"}]}],fme=[{tfOpName:"NonMaxSuppressionV2",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV3",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV4",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"T_threshold",name:"threshold",type:"dtype",notSupported:!0},{tfName:"pad_to_max_output_size",name:"padToMaxOutputSize",type:"bool"}]},{tfOpName:"NonMaxSuppressionV5",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"},{start:5,name:"softNmsSigma",type:"number"}]},{tfOpName:"Where",category:"dynamic",inputs:[{start:0,name:"condition",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ListDiff",category:"dynamic",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],mme=[{tfOpName:"LowerBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"TopKV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"k",type:"number"}],attrs:[{tfName:"sorted",name:"sorted",type:"bool"}]},{tfOpName:"UpperBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"Unique",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"UniqueV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]}],gme=[{tfOpName:"PlaceholderWithDefault",category:"graph",inputs:[{start:0,name:"default",type:"tensor"}],attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Placeholder",category:"graph",attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Const",category:"graph"},{tfOpName:"Identity",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IdentityN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Snapshot",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Rank",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Size",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Shape",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"ShapeN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Print",category:"graph",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"data",type:"tensors"}],attrs:[{tfName:"message",name:"message",type:"string"},{tfName:"first_n",name:"firstN",type:"number",notSupported:!0},{tfName:"summarize",name:"summarize",type:"number",defaultValue:3}]},{tfOpName:"NoOp",category:"graph",inputs:[]},{tfOpName:"StopGradient",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"FakeQuantWithMinMaxVars",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"min",name:"min",type:"number"},{tfName:"max",name:"max",type:"number"}]}],bme=[{tfOpName:"HashTable",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"HashTableV2",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"LookupTableImport",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableImportV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFind",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFindV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableSize",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"LookupTableSizeV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"InitializeTable",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]},{tfOpName:"InitializeTableV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]}],yme=[{tfOpName:"ResizeBilinear",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ResizeNearestNeighbor",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"CropAndResize",category:"image",inputs:[{start:0,name:"image",type:"tensor"},{start:1,name:"boxes",type:"tensor"},{start:2,name:"boxInd",type:"tensor"},{start:3,name:"cropSize",type:"number[]"}],attrs:[{tfName:"method",name:"method",type:"string"},{tfName:"extrapolation_value",name:"extrapolationValue",type:"number"}]},{tfOpName:"ImageProjectiveTransformV3",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"transforms",type:"tensor"},{start:2,name:"outputShape",type:"number[]"},{start:3,name:"fillValue",type:"number"}],attrs:[{tfName:"interpolation",name:"interpolation",type:"string"},{tfName:"fill_mode",name:"fillMode",type:"string"}]}],_me=[{tfOpName:"Equal",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NotEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Greater",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"GreaterEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Less",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LessEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalAnd",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalNot",category:"logical",inputs:[{start:0,name:"a",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalOr",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Select",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SelectV2",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BitwiseAnd",category:"logical",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}]}],vme=[{tfOpName:"_FusedMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMulV2",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Transpose",category:"matrices",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"perm",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Einsum",category:"matrices",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"equation",name:"equation",type:"string"},{tfName:"N",name:"n",type:"number",defaultValue:2},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"MatrixBandPart",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"numLower",type:"tensor"},{start:1,name:"numUpper",type:"tensor"}]}],xme=[{tfOpName:"EuclideanNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",defaultValue:!1}]},{tfOpName:"FusedBatchNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV2",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV3",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"LRN",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"depth_radius",name:"radius",type:"number",defaultValue:5},{tfName:"bias",name:"bias",type:"number",defaultValue:1},{tfName:"alpha",name:"alpha",type:"number",defaultValue:1},{tfName:"beta",name:"beta",type:"number",defaultValue:.5}]},{tfOpName:"Softmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"LogSoftmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]}],wme=[{tfOpName:"Bincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}]},{tfOpName:"DenseBincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}],attrs:[{tfName:"binary_output",name:"binaryOutput",type:"bool"}]},{tfOpName:"Max",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Mean",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Min",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Sum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"All",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Any",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"ArgMax",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"ArgMin",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"Prod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cumprod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]},{tfOpName:"Cumsum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]}],Tme=[{tfOpName:"ConcatV2",category:"slice_join",inputs:[{start:0,end:-1,name:"tensors",type:"tensors"},{start:-1,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"Concat",category:"slice_join",inputs:[{start:1,end:0,name:"tensors",type:"tensors"},{start:0,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"GatherV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"axis",type:"number",defaultValue:0}],attrs:[{tfName:"batch_dims",name:"batchDims",type:"number",defaultValue:0}]},{tfOpName:"Gather",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",notSupported:!0}]},{tfOpName:"Reverse",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"dims",type:"bool[]"}]},{tfOpName:"ReverseV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}]},{tfOpName:"Slice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"size",type:"number[]"}]},{tfOpName:"StridedSlice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"end",type:"number[]"},{start:3,name:"strides",type:"number[]"}],attrs:[{tfName:"begin_mask",name:"beginMask",type:"number",defaultValue:0},{tfName:"end_mask",name:"endMask",type:"number",defaultValue:0},{tfName:"new_axis_mask",name:"newAxisMask",type:"number",defaultValue:0},{tfName:"ellipsis_mask",name:"ellipsisMask",type:"number",defaultValue:0},{tfName:"shrink_axis_mask",name:"shrinkAxisMask",type:"number",defaultValue:0}]},{tfOpName:"Pack",category:"slice_join",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0}]},{tfOpName:"Unpack",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0},{tfName:"num",name:"num",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Tile",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"reps",type:"number[]"}]},{tfOpName:"Split",category:"slice_join",inputs:[{start:0,name:"axis",type:"number",defaultValue:0},{start:1,name:"x",type:"tensor"}],attrs:[{tfName:"num_split",name:"numOrSizeSplits",type:"number",defaultValue:1}]},{tfOpName:"SplitV",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"numOrSizeSplits",type:"number[]"},{start:2,name:"axis",type:"number",defaultValue:0}]},{tfOpName:"ScatterNd",category:"slice_join",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"shape",type:"number[]"}]},{tfOpName:"GatherNd",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}]},{tfOpName:"SparseToDense",category:"slice_join",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!1,notSupported:!0}]},{tfOpName:"TensorScatterUpdate",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"values",type:"tensor"}]}],Sme=[{tfOpName:"SparseFillEmptyRows",category:"sparse",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"denseShape",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}]},{tfOpName:"SparseReshape",category:"sparse",inputs:[{start:0,name:"inputIndices",type:"tensor"},{start:1,name:"inputShape",type:"tensor"},{start:2,name:"newShape",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SparseSegmentMean",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]},{tfOpName:"SparseSegmentSum",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]}],Cme=[{tfOpName:"FFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"RFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]},{tfOpName:"IRFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]}],Ime=[{tfOpName:"StaticRegexReplace",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"pattern",name:"pattern",type:"string"},{tfName:"rewrite",name:"rewrite",type:"string"},{tfName:"replace_global",name:"replaceGlobal",type:"bool"}]},{tfOpName:"StringNGrams",category:"string",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"dataSplits",type:"tensor"}],attrs:[{tfName:"separator",name:"separator",type:"string"},{tfName:"ngram_widths",name:"nGramWidths",type:"number[]"},{tfName:"left_pad",name:"leftPad",type:"string"},{tfName:"right_pad",name:"rightPad",type:"string"},{tfName:"pad_width",name:"padWidth",type:"number"},{tfName:"preserve_short_sequences",name:"preserveShortSequences",type:"bool"}],outputs:["ngrams","ngrams_splits"]},{tfOpName:"StringSplit",category:"string",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"delimiter",type:"tensor"}],attrs:[{tfName:"skip_empty",name:"skipEmpty",type:"bool"}],outputs:["indices","values","shape"]},{tfOpName:"StringToHashBucketFast",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"num_buckets",name:"numBuckets",type:"number"}]}],Eme=[{tfOpName:"Cast",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"SrcT",name:"sdtype",type:"dtype",notSupported:!0},{tfName:"DstT",name:"dtype",type:"dtype"}]},{tfOpName:"ExpandDims",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"MirrorPad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"mode",name:"mode",type:"string"}]},{tfOpName:"Pad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"constant_value",name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"PadV2",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"},{start:2,name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"Reshape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"EnsureShape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"Squeeze",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"axis",tfDeprecatedName:"squeeze_dims",name:"axis",type:"number[]"}]},{tfOpName:"SpaceToBatchND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"paddings",type:"number[]"}]},{tfOpName:"BatchToSpaceND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"crops",type:"number[]"}]},{tfOpName:"DepthToSpace",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"block_size",name:"blockSize",type:"number"},{tfName:"data_format",name:"dataFormat",type:"string"}]},{tfOpName:"BroadcastTo",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}],attrs:[]},{tfOpName:"BroadcastArgs",category:"transformation",inputs:[{start:0,name:"s0",type:"tensor"},{start:1,name:"s1",type:"tensor"}],attrs:[]}];class Ez{static get Instance(){return this._instance||(this._instance=new this)}constructor(){const e=[].concat(...[C,v,b,h,l,d,f,y,w,D,M,$,B,z,G,H,te,ae,J].map(r=>r.json));this.opMappers=e.reduce((r,i)=>(r[i.tfOpName]=i,r),{})}transformGraph(t,e={}){const i=[],o=[],s=[],a=t.node.reduce((T,I)=>(T[I.name]=this.mapNode(I),I.op.startsWith("Placeholder")?i.push(T[I.name]):"Const"===I.op?o.push(T[I.name]):(null==I.input||0===I.input.length)&&s.push(T[I.name]),T),{});let c=[];const u=[];let p={},m={};null!=e&&(p=this.mapSignatureEntries(e.inputs),m=this.mapSignatureEntries(e.outputs));const g=Object.keys(a);g.forEach(T=>{const I=a[T];I.inputNames.forEach((N,R)=>{const[L,,V]=kl(N),j=a[L];if(null!=j.outputs){const Y=j.outputs.indexOf(V);-1!==Y&&(I.inputNames[R]=`${L}:${Y}`)}I.inputs.push(j),j.children.push(I)})}),0===Object.keys(m).length?g.forEach(T=>{const I=a[T];0===I.children.length&&u.push(I)}):Object.keys(m).forEach(T=>{const[I]=kl(T),N=a[I];null!=N&&(N.signatureKey=m[T],u.push(N))}),Object.keys(p).length>0?Object.keys(p).forEach(T=>{const[I]=kl(T),N=a[I];N&&(N.signatureKey=p[T],c.push(N))}):c=i;let _={};null!=t.library&&null!=t.library.function&&(_=t.library.function.reduce((T,I)=>(T[I.signature.name]=this.mapFunction(I),T),{}));const x={nodes:a,inputs:c,outputs:u,weights:o,placeholders:i,signature:e,functions:_};return s.length>0&&(x.initNodes=s),x}mapSignatureEntries(t){return Object.keys(t||{}).reduce((e,r)=>(e[t[r].name]=r,e),{})}mapNode(t){const e=Cz(t.op)||this.opMappers[t.op]||{};null==t.attr&&(t.attr={});const r={name:t.name,op:t.op,category:e.category,inputNames:(t.input||[]).map(i=>i.startsWith("^")?i.slice(1):i),inputs:[],children:[],inputParams:{},attrParams:{},rawAttrs:t.attr,outputs:e.outputs};return null!=e.inputs&&(r.inputParams=e.inputs.reduce((i,o)=>(i[o.name]={type:o.type,inputIndexStart:o.start,inputIndexEnd:o.end},i),{})),null!=e.attrs&&(r.attrParams=e.attrs.reduce((i,o)=>{const s=o.type;let a;switch(o.type){case"string":a=dk(t.attr,o.tfName,o.defaultValue),void 0===a&&o.tfDeprecatedName&&(a=dk(t.attr,o.tfDeprecatedName,o.defaultValue));break;case"string[]":a=_k(t.attr,o.tfName,o.defaultValue),void 0===a&&o.tfDeprecatedName&&(a=_k(t.attr,o.tfDeprecatedName,o.defaultValue));break;case"number":a=pk(t.attr,o.tfName,o.defaultValue||0),void 0===a&&o.tfDeprecatedName&&(a=pk(t.attr,o.tfDeprecatedName,o.defaultValue));break;case"number[]":a=yk(t.attr,o.tfName,o.defaultValue),void 0===a&&o.tfDeprecatedName&&(a=yk(t.attr,o.tfDeprecatedName,o.defaultValue));break;case"bool":a=hk(t.attr,o.tfName,o.defaultValue),void 0===a&&o.tfDeprecatedName&&(a=hk(t.attr,o.tfDeprecatedName,o.defaultValue));break;case"bool[]":a=xk(t.attr,o.tfName,o.defaultValue),void 0===a&&o.tfDeprecatedName&&(a=xk(t.attr,o.tfDeprecatedName,o.defaultValue));break;case"shape":a=bk(t.attr,o.tfName,o.defaultValue),void 0===a&&o.tfDeprecatedName&&(a=bk(t.attr,o.tfDeprecatedName,o.defaultValue));break;case"shape[]":a=vk(t.attr,o.tfName,o.defaultValue),void 0===a&&o.tfDeprecatedName&&(a=vk(t.attr,o.tfDeprecatedName,o.defaultValue));break;case"dtype":a=mk(t.attr,o.tfName,o.defaultValue),void 0===a&&o.tfDeprecatedName&&(a=mk(t.attr,o.tfDeprecatedName,o.defaultValue));break;case"dtype[]":a=gk(t.attr,o.tfName,o.defaultValue),void 0===a&&o.tfDeprecatedName&&(a=gk(t.attr,o.tfDeprecatedName,o.defaultValue));break;case"func":a=kz(t.attr,o.tfName,o.defaultValue),void 0===a&&o.tfDeprecatedName&&(a=kz(t.attr,o.tfDeprecatedName,o.defaultValue));break;case"tensor":case"tensors":break;default:throw new Error(`Unsupported param type: ${o.type} for op: ${t.op}`)}return i[o.name]={value:a,type:s},i},{})),r}mapFunction(t){const e=t.nodeDef,i=[];let o={};null!=e&&(o=e.reduce((m,g)=>(m[g.name]=this.mapNode(g),"Const"===g.op&&i.push(m[g.name]),m),{}));const s=[],a=[];t.signature.inputArg.forEach(m=>{const[g]=kl(m.name),_={name:g,op:"Placeholder",inputs:[],inputNames:[],category:"graph",inputParams:{},attrParams:{dtype:{value:fk(m.type),type:"dtype"}},children:[]};_.signatureKey=m.name,s.push(_),o[g]=_}),Object.keys(o).forEach(m=>{const g=o[m];g.inputNames.forEach((_,x)=>{const[T,,I]=kl(_),N=o[T];if(null!=N.outputs){const R=N.outputs.indexOf(I);-1!==R&&(g.inputNames[x]=`${T}:${R}`)}g.inputs.push(N),N.children.push(g)})});const u=t.ret;t.signature.outputArg.forEach(m=>{const[g,_]=kl(u[m.name]),x=o[g];null!=x&&(x.defaultOutput=_,a.push(x))});const p=this.mapArgsToSignature(t);return{nodes:o,inputs:s,outputs:a,weights:i,placeholders:[],signature:p}}mapArgsToSignature(t){return{methodName:t.signature.name,inputs:t.signature.inputArg.reduce((e,r)=>(e[r.name]=this.mapArgToTensorInfo(r),e),{}),outputs:t.signature.outputArg.reduce((e,r)=>(e[r.name]=this.mapArgToTensorInfo(r,t.ret),e),{})}}mapArgToTensorInfo(t,e){let r=t.name;return null!=e&&(r=e[r]),{name:r,dtype:t.type}}}function Dz(n,t){const e=Array.isArray(n)?String.fromCharCode.apply(null,n):function Dme(n){const t=Ie().global;if(typeof t.atob<"u")return t.atob(n);if(typeof Buffer<"u")return new Buffer(n,"base64").toString();throw new Error("Unable to decode base64 in this environment. Missing built-in atob() or Buffer()")}(n);return t?e:e.toLowerCase()}function dk(n,t,e,r=!1){const i=n[t];return null!=i?Dz(i.s,r):e}function hk(n,t,e){const r=n[t];return r?r.b:e}function pk(n,t,e){const r=n[t]||{},i=null!=r.i?r.i:null!=r.f?r.f:e;return"number"==typeof i?i:parseInt(i,10)}function fk(n){switch("string"==typeof n&&(n=Ke[n]),n){case Ke.DT_FLOAT:case Ke.DT_HALF:return"float32";case Ke.DT_INT32:case Ke.DT_INT64:case Ke.DT_INT8:case Ke.DT_UINT8:return"int32";case Ke.DT_BOOL:return"bool";case Ke.DT_DOUBLE:return"float32";case Ke.DT_STRING:return"string";default:return null}}function kz(n,t,e){const r=n[t];return r&&r.func?r.func.name:e}function mk(n,t,e){const r=n[t];return r&&r.type?fk(r.type):e}function gk(n,t,e){const r=n[t];return r&&r.list&&r.list.type?r.list.type.map(i=>fk(i)):e}function Az(n){if(!n.unknownRank)return null!=n.dim?n.dim.map(t=>"number"==typeof t.size?t.size:parseInt(t.size,10)):[]}function bk(n,t,e){const r=n[t];return r&&r.shape?Az(r.shape):e}function yk(n,t,e){const r=n[t];return r?((r.list.f&&r.list.f.length?r.list.f:r.list.i)||[]).map(i=>"number"==typeof i?i:parseInt(i,10)):e}function _k(n,t,e,r=!1){const i=n[t];return i&&i.list&&i.list.s?i.list.s.map(o=>Dz(o,r)):e}function vk(n,t,e){const r=n[t];return r&&r.list&&r.list.shape?r.list.shape.map(i=>Az(i)):e}function xk(n,t,e){const r=n[t];return r&&r.list&&r.list.b?r.list.b:e}class kme{constructor(t,e,r){this.node=t,this.tensorMap=e,this.context=r,this.inputs=[],this.attrs={},this.inputs=t.inputNames.map(i=>this.getInput(i)),null!=t.rawAttrs&&(this.attrs=Object.keys(t.rawAttrs).reduce((i,o)=>(i[o]=this.getAttr(o),i),{}))}getInput(t){return Ai(t,this.tensorMap,this.context)}getAttr(t,e){const r=this.node.rawAttrs[t];if(null!=r.tensor)return Ai(t,this.tensorMap,this.context);if(null!=r.i||null!=r.f)return pk(this.node.rawAttrs,t,e);if(null!=r.s)return dk(this.node.rawAttrs,t,e);if(null!=r.b)return hk(this.node.rawAttrs,t,e);if(null!=r.shape)return bk(this.node.rawAttrs,t,e);if(null!=r.type)return mk(this.node.rawAttrs,t,e);if(null!=r.list){if(null!=r.list.i||null!=r.list.f)return yk(this.node.rawAttrs,t,e);if(null!=r.list.s)return _k(this.node.rawAttrs,t,e);if(null!=r.list.shape)return vk(this.node.rawAttrs,t,e);if(null!=r.list.b)return xk(this.node.rawAttrs,t,e);if(null!=r.list.type)return gk(this.node.rawAttrs,t,e)}return e}}function zs(n,t,e=""){if("number"!=typeof n&&"number"!=typeof t){Z(n.length===t.length,()=>e+` Shapes ${n} and ${t} must match`);for(let r=0;r<n.length;r++){const i=n[r],o=t[r];Z(i<0||o<0||i===o,()=>e+` Shapes ${n} and ${t} must match`)}}}function Nz(n){return!("number"==typeof n||n.some(t=>t<0))}function Fg(n,t,e){let r=wk(n,e);const i=!Nz(r);if(i&&0===t.length)throw new Error(`Tried to calculate elements of an empty list with non-fully-defined elementShape: ${r}`);if(i&&t.forEach(o=>{r=wk(o.shape,r)}),!Nz(r))throw new Error(`Non-fully-defined elementShape: ${r}`);return r}function wk(n,t){if("number"==typeof n)return t;if("number"==typeof t)return n;if(n.length!==t.length)throw new Error(`Incompatible ranks during merge: ${n} vs. ${t}`);const e=[];for(let r=0;r<n.length;++r){const i=n[r],o=t[r];if(i>=0&&o>=0&&i!==o)throw new Error(`Incompatible shape during merge: ${n} vs. ${t}`);e[r]=i>=0?i:o}return e}class Ome{constructor(t,e,r,i,o,s,a){this.name=t,this.dtype=e,this.maxSize=r,this.elementShape=i,this.identicalElementShapes=o,this.dynamicSize=s,this.clearAfterRead=a,this.tensors=[],this.closed_=!1,this.idTensor=Ft(0),fi(this.idTensor)}get id(){return this.idTensor.id}get closed(){return this.closed_}clearAndClose(t){this.tensors.forEach(e=>{(null==t||!t.has(e.tensor.id))&&e.tensor.dispose()}),this.tensors=[],this.closed_=!0,this.idTensor.dispose()}size(){return this.tensors.length}read(t){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(t<0||t>=this.size())throw new Error(`Tried to read from index ${t}, but array size is: ${this.size()}`);const e=this.tensors[t];if(e.cleared)throw new Error(`TensorArray ${this.name}: Could not read index ${t} twice because it was cleared after a previous read (perhaps try setting clear_after_read = false?).`);return this.clearAfterRead&&(e.cleared=!0),e.read=!0,e.tensor}readMany(t){return t.map(e=>this.read(e))}write(t,e){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(t<0||!this.dynamicSize&&t>=this.maxSize)throw new Error(`Tried to write to index ${t}, but array is not resizeable and size is: ${this.maxSize}`);const r=this.tensors[t]||{};if(e.dtype!==this.dtype)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${t},\n          because the value dtype is ${e.dtype}, but TensorArray dtype is ${this.dtype}.`);if(0===this.size()&&(null==this.elementShape||0===this.elementShape.length)&&(this.elementShape=e.shape),zs(this.elementShape,e.shape,`TensorArray ${this.name}: Could not write to TensorArray index ${t}.`),r.read)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${t}, because it has already been read.`);if(r.written)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${t}, because it has already been written.`);r.tensor=e,fi(e),r.written=!0,this.tensors[t]=r}writeMany(t,e){if(t.length!==e.length)throw new Error(`TensorArray ${this.name}: could not write multiple tensors,because the index size: ${t.length} is not the same as tensors size: ${e.length}.`);t.forEach((r,i)=>this.write(r,e[i]))}gather(t,e){if(e&&e!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but gather requested dtype ${e}`);if(t)t=t.slice(0,this.size());else{t=[];for(let i=0;i<this.size();i++)t.push(i)}if(0===t.length)return aa([],[0].concat(this.elementShape));const r=this.readMany(t);return zs(this.elementShape,r[0].shape,"TensorArray shape mismatch: "),hs(r,0)}concat(t){if(t&&t!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but concat requested dtype ${t}`);if(0===this.size())return aa([],[0].concat(this.elementShape));const e=[];for(let i=0;i<this.size();i++)e.push(i);const r=this.readMany(e);return zs(this.elementShape,r[0].shape,`TensorArray shape mismatch: tensor array shape (${this.elementShape}) vs first tensor shape (${r[0].shape})`),Ur(r,0)}scatter(t,e){if(e.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${e.dtype}`);if(t.length!==e.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${t.length} vs. ${e.shape[0]}`);const r=Math.max(...t);if(!this.dynamicSize&&r>=this.maxSize)throw new Error(`Max index must be < array size (${r}  vs. ${this.maxSize})`);this.writeMany(t,$s(e,0))}split(t,e){if(e.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${e.dtype}`);let r=0;const i=t.map(c=>(r+=c,r));if(r!==e.shape[0])throw new Error(`Expected sum of lengths to be equal to\n          tensor.shape[0], but sum of lengths is\n        ${r}, and tensor's shape is: ${e.shape}`);if(!this.dynamicSize&&t.length!==this.maxSize)throw new Error(`TensorArray's size is not equal to the size of lengths (${this.maxSize} vs. ${t.length}), and the TensorArray is not marked as dynamically resizeable`);const o=0===r?0:e.size/r,s=[];Se(()=>{e=be(e,[1,r,o]);for(let c=0;c<t.length;++c)s[c]=be(xn(e,[0,0===c?0:i[c-1],0],[1,t[c],o]),this.elementShape);return s});const a=[];for(let c=0;c<t.length;c++)a[c]=c;this.writeMany(a,s)}}class Hu{get id(){return this.idTensor.id}constructor(t,e,r,i=-1){this.tensors=t,this.elementShape=e,this.elementDtype=r,t?.forEach(o=>{if(r!==o.dtype)throw new Error(`Invalid data types; op elements ${r}, but list elements ${o.dtype}`);zs(e,o.shape,"TensorList shape mismatch: "),fi(o)}),this.idTensor=Ft(0),this.maxNumElements=i,fi(this.idTensor)}copy(){return new Hu([...this.tensors],this.elementShape,this.elementDtype)}clearAndClose(t){this.tensors.forEach(e=>{(null==t||!t.has(e.id))&&e.dispose()}),this.tensors.length=0,this.idTensor.dispose()}size(){return this.tensors.length}stack(t,e,r=-1){if(e!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e}, but list elements ${this.elementDtype}`);if(-1!==r&&this.tensors.length!==r)throw new Error(`Operation expected a list with ${r} elements but got a list with ${this.tensors.length} elements.`);zs(t,this.elementShape,"TensorList shape mismatch: ");const i=Fg(this.elementShape,this.tensors,t);return Se(()=>{const o=this.tensors.map(s=>be(s,i));return hs(o,0)})}popBack(t,e){if(e!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e}, but list elements ${this.elementDtype}`);if(0===this.size())throw new Error("Trying to pop from an empty list.");const r=Fg(this.elementShape,this.tensors,t),i=this.tensors.pop();return i.kept=!1,zs(i.shape,t,"TensorList shape mismatch: "),be(i,r)}pushBack(t){if(t.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t.dtype}, but list elements ${this.elementDtype}`);if(zs(t.shape,this.elementShape,"TensorList shape mismatch: "),this.maxNumElements===this.size())throw new Error("Trying to push element into a full list.");fi(t),this.tensors.push(t)}resize(t){if(t<0)throw new Error(`TensorListResize expects size to be non-negative. Got: ${t}`);if(-1!==this.maxNumElements&&t>this.maxNumElements)throw new Error(`TensorListResize input size ${t} is greater maxNumElement ${this.maxNumElements}.`);const e=new Hu([],this.elementShape,this.elementDtype,this.maxNumElements);e.tensors.length=t;for(let r=0;r<Math.min(this.tensors.length,t);++r)e.tensors[r]=this.tensors[r];return e}getItem(t,e,r){if(r!==this.elementDtype)throw new Error(`Invalid data types; op elements ${r}, but list elements ${this.elementDtype}`);if(t<0||t>this.tensors.length)throw new Error(`Trying to access element ${t} in a list with ${this.tensors.length} elements.`);if(null==this.tensors[t])throw new Error(`element at index ${t} is null.`);zs(this.tensors[t].shape,e,"TensorList shape mismatch: ");const i=Fg(this.elementShape,this.tensors,e);return be(this.tensors[t],i)}setItem(t,e){if(e.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e.dtype}, but list elements ${this.elementDtype}`);if(t<0||-1!==this.maxNumElements&&t>=this.maxNumElements)throw new Error(`Trying to set element ${t} in a list with max ${this.maxNumElements} elements.`);zs(this.elementShape,e.shape,"TensorList shape mismatch: "),fi(e),null!=this.tensors[t]&&(this.tensors[t].kept=!1),this.tensors[t]=e}gather(t,e,r){if(e!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e}, but list elements ${this.elementDtype}`);zs(this.elementShape,r,"TensorList shape mismatch: "),t=t.slice(0,this.size());const i=Fg(this.elementShape,this.tensors,r);return 0===t.length?aa([],[0].concat(i)):Se(()=>{const o=t.map(s=>be(this.tensors[s],i));return hs(o,0)})}concat(t,e){if(t&&t!==this.elementDtype)throw new Error(`TensorList dtype is ${this.elementDtype} but concat requested dtype ${t}`);zs(this.elementShape,e,"TensorList shape mismatch: ");const r=Fg(this.elementShape,this.tensors,e);return 0===this.size()?aa([],[0].concat(r)):Se(()=>{const i=this.tensors.map(o=>be(o,r));return Ur(i,0)})}}const $me=function(){var n=$e(function*(t,e,r){switch(t.op){case"If":case"StatelessIf":{const i=U("thenBranch",t,e,r),o=U("elseBranch",t,e,r),s=U("cond",t,e,r),a=U("args",t,e,r);return(yield s.data())[0]?r.functionMap[i].executeFunctionAsync(a,r.tensorArrayMap,r.tensorListMap):r.functionMap[o].executeFunctionAsync(a,r.tensorArrayMap,r.tensorListMap)}case"While":case"StatelessWhile":{const i=U("body",t,e,r),o=U("cond",t,e,r),s=U("args",t,e,r),a=yield r.functionMap[o].executeFunctionAsync(s,r.tensorArrayMap,r.tensorListMap),c=s.map(m=>m.id);let u=yield a[0].data();a.forEach(m=>{!m.kept&&-1===c.indexOf(m.id)&&m.dispose()});let p=s;for(;u[0];){const m=p;p=yield r.functionMap[i].executeFunctionAsync(p,r.tensorArrayMap,r.tensorListMap);const g=p.map(x=>x.id);m.forEach(x=>{!x.kept&&-1===c.indexOf(x.id)&&-1===g.indexOf(x.id)&&x.dispose()});const _=yield r.functionMap[o].executeFunctionAsync(p,r.tensorArrayMap,r.tensorListMap);u=yield _[0].data(),_.forEach(x=>{!x.kept&&-1===c.indexOf(x.id)&&-1===g.indexOf(x.id)&&x.dispose()})}return p}case"LoopCond":return[Al(U("pred",t,e,r))];case"Switch":{const i=U("pred",t,e,r);let o=U("data",t,e,r);return o.kept||(o=Al(o)),(yield i.data())[0]?[void 0,o]:[o,void 0]}case"Merge":{const i=t.inputNames.find(o=>void 0!==Ai(o,e,r));return i?[Al(Ai(i,e,r))]:void 0}case"Enter":{const i=U("frameName",t,e,r),o=U("tensor",t,e,r);return r.enterFrame(i),[Al(o)]}case"Exit":{const i=U("tensor",t,e,r);return r.exitFrame(),[Al(i)]}case"NextIteration":{const i=U("tensor",t,e,r);return r.nextIteration(),[Al(i)]}case"TensorArrayV3":{const i=U("size",t,e,r),o=U("dtype",t,e,r),s=U("elementShape",t,e,r),a=U("dynamicSize",t,e,r),c=U("clearAfterRead",t,e,r),u=U("identicalElementShapes",t,e,r),p=U("name",t,e,r),m=new Ome(p,o,i,s,u,a,c);return r.addTensorArray(m),[m.idTensor,Ft(1)]}case"TensorArrayWriteV3":{const i=U("tensorArrayId",t,e,r),o=U("index",t,e,r),s=U("tensor",t,e,r),a=r.getTensorArray(i.id);return a.write(o,s),[a.idTensor]}case"TensorArrayReadV3":{const i=U("tensorArrayId",t,e,r),o=U("index",t,e,r);return[r.getTensorArray(i.id).read(o)]}case"TensorArrayGatherV3":{const i=U("tensorArrayId",t,e,r),o=U("indices",t,e,r),s=U("dtype",t,e,r);return[r.getTensorArray(i.id).gather(o,s)]}case"TensorArrayScatterV3":{const i=U("tensorArrayId",t,e,r),o=U("indices",t,e,r),s=U("tensor",t,e,r),a=r.getTensorArray(i.id);return a.scatter(o,s),[a.idTensor]}case"TensorArrayConcatV3":{const i=U("tensorArrayId",t,e,r),o=r.getTensorArray(i.id),s=U("dtype",t,e,r);return[o.concat(s)]}case"TensorArraySplitV3":{const i=U("tensorArrayId",t,e,r),o=U("tensor",t,e,r),s=U("lengths",t,e,r),a=r.getTensorArray(i.id);return a.split(s,o),[a.idTensor]}case"TensorArraySizeV3":{const i=U("tensorArrayId",t,e,r);return[Ft(r.getTensorArray(i.id).size(),"int32")]}case"TensorArrayCloseV3":{const i=U("tensorArrayId",t,e,r),o=r.getTensorArray(i.id);return o.clearAndClose(),[o.idTensor]}case"TensorListSetItem":{const i=U("tensorListId",t,e,r),o=U("index",t,e,r),s=U("tensor",t,e,r),a=r.getTensorList(i.id);return a.setItem(o,s),[a.idTensor]}case"TensorListGetItem":{const i=U("tensorListId",t,e,r),o=U("index",t,e,r),s=U("elementShape",t,e,r),a=U("elementDType",t,e,r);return[r.getTensorList(i.id).getItem(o,s,a)]}case"TensorListScatterV2":case"TensorListScatter":{const i=U("indices",t,e,r),c=function Fme(n,t,e,r){if(t.length!==n.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${t.length} vs. ${n.shape[0]}`);const i=Math.max(...t);if(null!=r&&-1!==r&&i>=r)throw new Error(`Max index must be < array size (${i}  vs. ${r})`);const o=new Hu([],e,n.dtype,r),s=$s(n,0);return t.forEach((a,c)=>{o.setItem(a,s[c])}),o}(U("tensor",t,e,r),i,U("elementShape",t,e,r),U("numElements",t,e,r));return r.addTensorList(c),[c.idTensor]}case"TensorListReserve":case"EmptyTensorList":{const i=U("elementShape",t,e,r),o=U("elementDType",t,e,r);let s;s="TensorListReserve"===t.op?"numElements":"maxNumElements";const a=U(s,t,e,r),u=function Mme(n,t,e,r){return new Hu([],n,t,r)}(i,o,0,"TensorListReserve"===t.op?-1:a);return r.addTensorList(u),[u.idTensor]}case"TensorListGather":{const i=U("tensorListId",t,e,r),o=U("indices",t,e,r),s=U("elementShape",t,e,r),a=U("elementDType",t,e,r);return[r.getTensorList(i.id).gather(o,a,s)]}case"TensorListStack":{const i=U("tensorListId",t,e,r),o=U("elementShape",t,e,r),s=U("elementDType",t,e,r),a=U("numElements",t,e,r);return[r.getTensorList(i.id).stack(o,s,a)]}case"TensorListFromTensor":{const a=function Rme(n,t,e){const r=n.dtype;if(n.shape.length<1)throw new Error(`Tensor must be at least a vector, but saw shape: ${n.shape}`);if(n.dtype!==e)throw new Error(`Invalid data types; op elements ${n.dtype}, but list elements ${e}`);zs(n.shape.slice(1),t,"TensorList shape mismatch: ");const o=$s(n);return new Hu(o,t,r)}(U("tensor",t,e,r),U("elementShape",t,e,r),U("elementDType",t,e,r));return r.addTensorList(a),[a.idTensor]}case"TensorListConcat":case"TensorListConcatV2":{const i=U("tensorListId",t,e,r),o=r.getTensorList(i.id),s=U("dtype",t,e,r),a=U("elementShape",t,e,r);return[o.concat(s,a)]}case"TensorListPushBack":{const i=U("tensorListId",t,e,r),o=U("tensor",t,e,r),s=r.getTensorList(i.id);return s.pushBack(o),[s.idTensor]}case"TensorListPopBack":{const i=U("tensorListId",t,e,r),o=U("elementShape",t,e,r),s=U("elementDType",t,e,r);return[r.getTensorList(i.id).popBack(o,s)]}case"TensorListSplit":{const i=U("tensor",t,e,r),o=U("elementShape",t,e,r),a=function Pme(n,t,e){let r=0;const i=t.map(p=>(r+=p,r));if(r!==n.shape[0])throw new Error(`Expected sum of lengths to be equal to\n          tensor.shape[0], but sum of lengths is\n        ${r}, and tensor's shape is: ${n.shape}`);const s=wk(n.shape.slice(1),e),a=0===r?0:n.size/r,c=Se(()=>{const p=[];n=be(n,[1,r,a]);for(let m=0;m<t.length;++m)p[m]=be(xn(n,[0,0===m?0:i[m-1],0],[1,t[m],a]),s);return n.dispose(),p}),u=new Hu([],e,n.dtype,t.length);for(let p=0;p<c.length;p++)u.setItem(p,c[p]);return u}(i,U("lengths",t,e,r),o);return r.addTensorList(a),[a.idTensor]}case"TensorListLength":{const i=U("tensorListId",t,e,r);return[Ft(r.getTensorList(i.id).size(),"int32")]}case"TensorListResize":{const i=U("tensorListId",t,e,r),o=U("size",t,e,r),a=r.getTensorList(i.id).resize(o);return r.addTensorList(a),[a.idTensor]}default:throw TypeError(`Node type ${t.op} is not implemented`)}});return function(e,r,i){return n.apply(this,arguments)}}();function Oz(n,t,e){const[r,i]=U("fusedOps",n,t,e),o="biasadd"===r,s=!o,a="prelu"===i,c="fusedbatchnorm"===r,u=U("numArgs",n,t,e);if(o){if(a&&2!==u)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!a&&o&&1!==u)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd must have one extra argument: bias.")}if(c)throw new Error("FusedConv2d and DepthwiseConv2d with FusedBatchNorm is not supported");const p=U("strides",n,t,e),m=Kv(n,t,e),g=U("dataFormat",n,t,e).toUpperCase(),_=U("dilations",n,t,e);let[x,T]=U("args",n,t,e);return s&&(T=x,x=void 0),{stride:p,pad:m,dataFormat:g,dilations:_,biasArg:x,preluArg:T,activationFunc:i,leakyreluAlpha:U("leakyreluAlpha",n,t,e)}}function Tk(n,t,e){return{boxes:U("boxes",n,t,e),scores:U("scores",n,t,e),maxOutputSize:U("maxOutputSize",n,t,e),iouThreshold:U("iouThreshold",n,t,e),scoreThreshold:U("scoreThreshold",n,t,e),softNmsSigma:U("softNmsSigma",n,t,e)}}const Vme=function(){var n=$e(function*(t,e,r,i,o=ne){switch(t.op){case"NonMaxSuppressionV5":{const{boxes:s,scores:a,maxOutputSize:c,iouThreshold:u,scoreThreshold:p,softNmsSigma:m}=Tk(t,e,r),g=yield o.image.nonMaxSuppressionWithScoreAsync(s,a,c,u,p,m);return[g.selectedIndices,g.selectedScores]}case"NonMaxSuppressionV4":{const{boxes:s,scores:a,maxOutputSize:c,iouThreshold:u,scoreThreshold:p}=Tk(t,e,r),m=U("padToMaxOutputSize",t,e,r),g=yield o.image.nonMaxSuppressionPaddedAsync(s,a,c,u,p,m);return[g.selectedIndices,g.validOutputs]}case"NonMaxSuppressionV3":case"NonMaxSuppressionV2":{const{boxes:s,scores:a,maxOutputSize:c,iouThreshold:u,scoreThreshold:p}=Tk(t,e,r);return[yield o.image.nonMaxSuppressionAsync(s,a,c,u,p)]}case"Where":{const s=o.cast(U("condition",t,e,r),"bool"),a=[yield o.whereAsync(s)];return s.dispose(),a}case"ListDiff":return o.setdiff1dAsync(U("x",t,e,r),U("y",t,e,r));default:throw TypeError(`Node type ${t.op} is not implemented`)}});return function(e,r,i,o){return n.apply(this,arguments)}}();class jme{get id(){return this.handle.id}constructor(t,e){this.keyDType=t,this.valueDType=e,this.handle=Ft(0),this.tensorMap=new Map,fi(this.handle)}clearAndClose(){this.tensorMap.forEach(t=>t.dispose()),this.tensorMap.clear(),this.handle.dispose()}size(){return this.tensorMap.size}tensorSize(){return Ft(this.size(),"int32")}import(t,e){var r=this;return $e(function*(){r.checkKeyAndValueTensor(t,e);const i=yield t.data();return r.tensorMap.forEach(o=>o.dispose()),r.tensorMap.clear(),Se(()=>{const o=$s(e),s=i.length,a=o.length;Z(s===a,()=>`The number of elements doesn't match, keys has ${s} elements, the values has ${a} elements.`);for(let c=0;c<s;c++){const u=i[c],p=o[c];fi(p),r.tensorMap.set(u,p)}return r.handle})})()}find(t,e){var r=this;return $e(function*(){r.checkKeyAndValueTensor(t,e);const i=yield t.data();return Se(()=>{const o=[];for(let s=0;s<i.length;s++){const c=r.findWithDefault(i[s],e);o.push(c)}return hs(o)})})()}findWithDefault(t,e){return this.tensorMap.get(t)??e}checkKeyAndValueTensor(t,e){if(t.dtype!==this.keyDType)throw new Error(`Expect key dtype ${this.keyDType}, but got ${t.dtype}`);if(e.dtype!==this.valueDType)throw new Error(`Expect value dtype ${this.valueDType}, but got ${e.dtype}`)}}const Gme=function(){var n=$e(function*(t,e,r,i){switch(t.op){case"HashTable":case"HashTableV2":{const o=i.getHashTableHandleByName(t.name);if(null!=o)return[o];{const s=U("keyDType",t,e,r),a=U("valueDType",t,e,r),c=new jme(s,a);return i.addHashTable(t.name,c),[c.handle]}}case"InitializeTable":case"InitializeTableV2":case"LookupTableImport":case"LookupTableImportV2":{const o=U("tableHandle",t,e,r,i),s=U("keys",t,e,r),a=U("values",t,e,r);return[yield i.getHashTableById(o.id).import(s,a)]}case"LookupTableFind":case"LookupTableFindV2":{const o=U("tableHandle",t,e,r,i),s=U("keys",t,e,r),a=U("defaultValue",t,e,r);return[yield i.getHashTableById(o.id).find(s,a)]}case"LookupTableSize":case"LookupTableSizeV2":{const o=U("tableHandle",t,e,r,i);return[i.getHashTableById(o.id).tensorSize()]}default:throw TypeError(`Node type ${t.op} is not implemented`)}});return function(e,r,i,o){return n.apply(this,arguments)}}();function Rz(n,t,e,r,i=Se){const o=((s,a,c)=>{switch(s.category){case"arithmetic":return i(()=>((n,t,e,r=ne)=>{switch(n.op){case"BiasAdd":case"AddV2":case"Add":return[r.add(U("a",n,t,e),U("b",n,t,e))];case"AddN":return[r.addN(U("tensors",n,t,e))];case"FloorMod":case"Mod":return[r.mod(U("a",n,t,e),U("b",n,t,e))];case"Mul":return[r.mul(U("a",n,t,e),U("b",n,t,e))];case"RealDiv":case"Div":return[r.div(U("a",n,t,e),U("b",n,t,e))];case"DivNoNan":return[r.divNoNan(U("a",n,t,e),U("b",n,t,e))];case"FloorDiv":return[r.floorDiv(U("a",n,t,e),U("b",n,t,e))];case"Sub":return[r.sub(U("a",n,t,e),U("b",n,t,e))];case"Minimum":return[r.minimum(U("a",n,t,e),U("b",n,t,e))];case"Maximum":return[r.maximum(U("a",n,t,e),U("b",n,t,e))];case"Pow":return[r.pow(U("a",n,t,e),U("b",n,t,e))];case"SquaredDifference":return[r.squaredDifference(U("a",n,t,e),U("b",n,t,e))];default:throw TypeError(`Node type ${n.op} is not implemented`)}})(s,a,c));case"basic_math":return i(()=>((n,t,e,r=ne)=>{switch(n.op){case"Abs":case"ComplexAbs":return[r.abs(U("x",n,t,e))];case"Acos":return[r.acos(U("x",n,t,e))];case"Acosh":return[r.acosh(U("x",n,t,e))];case"Asin":return[r.asin(U("x",n,t,e))];case"Asinh":return[r.asinh(U("x",n,t,e))];case"Atan":return[r.atan(U("x",n,t,e))];case"Atan2":return[r.atan2(U("x",n,t,e),U("y",n,t,e))];case"Atanh":return[r.atanh(U("x",n,t,e))];case"Ceil":return[r.ceil(U("x",n,t,e))];case"Complex":return[r.complex(U("real",n,t,e),U("imag",n,t,e))];case"Cos":return[r.cos(U("x",n,t,e))];case"Cosh":return[r.cosh(U("x",n,t,e))];case"Elu":return[r.elu(U("x",n,t,e))];case"Erf":return[r.erf(U("x",n,t,e))];case"Exp":return[r.exp(U("x",n,t,e))];case"Expm1":return[r.expm1(U("x",n,t,e))];case"Floor":return[r.floor(U("x",n,t,e))];case"Log":return[r.log(U("x",n,t,e))];case"Log1p":return[r.log1p(U("x",n,t,e))];case"Imag":return[r.imag(U("x",n,t,e))];case"Neg":return[r.neg(U("x",n,t,e))];case"Reciprocal":return[r.reciprocal(U("x",n,t,e))];case"Real":return[r.real(U("x",n,t,e))];case"Relu":return[r.relu(U("x",n,t,e))];case"Round":return[r.round(U("x",n,t,e))];case"Selu":return[r.selu(U("x",n,t,e))];case"Sigmoid":return[r.sigmoid(U("x",n,t,e))];case"Sin":return[r.sin(U("x",n,t,e))];case"Sign":return[r.sign(U("x",n,t,e))];case"Sinh":return[r.sinh(U("x",n,t,e))];case"Softplus":return[r.softplus(U("x",n,t,e))];case"Sqrt":return[r.sqrt(U("x",n,t,e))];case"Square":return[r.square(U("x",n,t,e))];case"Tanh":return[r.tanh(U("x",n,t,e))];case"Tan":return[r.tan(U("x",n,t,e))];case"ClipByValue":return[r.clipByValue(U("x",n,t,e),U("clipValueMin",n,t,e),U("clipValueMax",n,t,e))];case"Relu6":return[r.relu6(U("x",n,t,e))];case"Rsqrt":return[r.rsqrt(Ai(n.inputNames[0],t,e))];case"LeakyRelu":return[r.leakyRelu(U("x",n,t,e),U("alpha",n,t,e))];case"Prelu":return[r.prelu(U("x",n,t,e),U("alpha",n,t,e))];case"IsNan":return[r.isNaN(Ai(n.inputNames[0],t,e))];case"IsInf":return[r.isInf(Ai(n.inputNames[0],t,e))];case"IsFinite":return[r.isFinite(Ai(n.inputNames[0],t,e))];default:throw TypeError(`Node type ${n.op} is not implemented`)}})(s,a,c));case"control":return $me(s,a,c);case"convolution":return i(()=>((n,t,e,r=ne)=>{switch(n.op){case"Conv1D":{const i=U("stride",n,t,e),o=U("pad",n,t,e),s=U("dataFormat",n,t,e).toUpperCase(),a=U("dilation",n,t,e);return[r.conv1d(U("x",n,t,e),U("filter",n,t,e),i,o,s,a)]}case"Conv2D":{const i=U("strides",n,t,e),o=Kv(n,t,e),s=U("dataFormat",n,t,e).toUpperCase(),a=U("dilations",n,t,e);return[r.conv2d(U("x",n,t,e),U("filter",n,t,e),[i[1],i[2]],o,s,[a[1],a[2]])]}case"_FusedConv2D":{const{stride:i,pad:o,dataFormat:s,dilations:a,biasArg:c,preluArg:u,activationFunc:p,leakyreluAlpha:m}=Oz(n,t,e);return[r.fused.conv2d({x:U("x",n,t,e),filter:U("filter",n,t,e),strides:[i[1],i[2]],pad:o,dataFormat:s,dilations:[a[1],a[2]],bias:c,activation:p,preluActivationWeights:u,leakyreluAlpha:m})]}case"FusedDepthwiseConv2dNative":{const{stride:i,pad:o,dataFormat:s,dilations:a,biasArg:c,preluArg:u,activationFunc:p,leakyreluAlpha:m}=Oz(n,t,e);return[r.fused.depthwiseConv2d({x:U("x",n,t,e),filter:U("filter",n,t,e),strides:[i[1],i[2]],pad:o,dataFormat:s,dilations:[a[1],a[2]],bias:c,activation:p,preluActivationWeights:u,leakyreluAlpha:m})]}case"Conv2DBackpropInput":case"Conv2dTranspose":{const i=U("outputShape",n,t,e),o=U("strides",n,t,e),s=Kv(n,t,e);return[r.conv2dTranspose(U("x",n,t,e),U("filter",n,t,e),i,[o[1],o[2]],s)]}case"DepthwiseConv2dNative":case"DepthwiseConv2d":{const i=U("strides",n,t,e),o=Kv(n,t,e),s=U("dilations",n,t,e),a=U("dataFormat",n,t,e).toUpperCase();return[r.depthwiseConv2d(U("input",n,t,e),U("filter",n,t,e),[i[1],i[2]],o,a,[s[1],s[2]])]}case"Conv3D":{const i=U("strides",n,t,e),o=U("pad",n,t,e),s=U("dataFormat",n,t,e).toUpperCase(),a=U("dilations",n,t,e);return[r.conv3d(U("x",n,t,e),U("filter",n,t,e),[i[1],i[2],i[3]],o,s,[a[1],a[2],a[3]])]}case"AvgPool":{const i=U("strides",n,t,e),o=U("pad",n,t,e),s=U("kernelSize",n,t,e);return[r.avgPool(U("x",n,t,e),[s[1],s[2]],[i[1],i[2]],o)]}case"MaxPool":{const i=U("strides",n,t,e),o=U("pad",n,t,e),s=U("kernelSize",n,t,e);return[r.maxPool(U("x",n,t,e),[s[1],s[2]],[i[1],i[2]],o)]}case"MaxPoolWithArgmax":{const i=U("strides",n,t,e),o=U("pad",n,t,e),s=U("kernelSize",n,t,e),a=U("includeBatchInIndex",n,t,e),{result:c,indexes:u}=r.maxPoolWithArgmax(U("x",n,t,e),[s[1],s[2]],[i[1],i[2]],o,a);return[c,u]}case"AvgPool3D":{const i=U("strides",n,t,e),o=U("pad",n,t,e),s=U("kernelSize",n,t,e);return[r.avgPool3d(U("x",n,t,e),[s[1],s[2],s[3]],[i[1],i[2],i[3]],o)]}case"MaxPool3D":{const i=U("strides",n,t,e),o=U("pad",n,t,e),s=U("kernelSize",n,t,e);return[r.maxPool3d(U("x",n,t,e),[s[1],s[2],s[3]],[i[1],i[2],i[3]],o)]}case"Dilation2D":{const i=U("strides",n,t,e),o=U("pad",n,t,e),s=U("dilations",n,t,e),a=i[1],c=i[2],u=s[1],p=s[2];return[r.dilation2d(U("x",n,t,e),U("filter",n,t,e),[a,c],o,[u,p],"NHWC")]}default:throw TypeError(`Node type ${n.op} is not implemented`)}})(s,a,c));case"creation":return i(()=>((n,t,e,r=ne)=>{switch(n.op){case"Fill":{const i=U("shape",n,t,e),o=U("dtype",n,t,e),s=U("value",n,t,e);return[r.fill(i,s,o)]}case"LinSpace":{const i=U("start",n,t,e),o=U("stop",n,t,e),s=U("num",n,t,e);return[r.linspace(i,o,s)]}case"Multinomial":{const i=U("logits",n,t,e),o=U("numSamples",n,t,e),s=U("seed",n,t,e);return[r.multinomial(i,o,s)]}case"OneHot":{const i=U("indices",n,t,e),o=U("depth",n,t,e),s=U("onValue",n,t,e),a=U("offValue",n,t,e),c=U("dtype",n,t,e);return[r.oneHot(i,o,s,a,c)]}case"Ones":return[r.ones(U("shape",n,t,e),U("dtype",n,t,e))];case"OnesLike":return[r.onesLike(U("x",n,t,e))];case"RandomStandardNormal":return[r.randomStandardNormal(U("shape",n,t,e),U("dtype",n,t,e),U("seed",n,t,e))];case"RandomUniform":return[r.randomUniform(U("shape",n,t,e),U("minval",n,t,e),U("maxval",n,t,e),U("dtype",n,t,e))];case"RandomUniformInt":return[r.randomUniformInt(U("shape",n,t,e),U("minval",n,t,e),U("maxval",n,t,e),U("seed",n,t,e))];case"Range":{const i=U("start",n,t,e),o=U("stop",n,t,e),s=U("step",n,t,e);return[r.range(i,o,s,U("dtype",n,t,e))]}case"TruncatedNormal":{const i=U("shape",n,t,e),o=U("mean",n,t,e),s=U("stdDev",n,t,e),a=U("seed",n,t,e);return[r.truncatedNormal(i,o,s,U("dtype",n,t,e),a)]}case"Zeros":return[r.zeros(U("shape",n,t,e),U("dtype",n,t,e))];case"ZerosLike":return[r.zerosLike(U("x",n,t,e))];default:throw TypeError(`Node type ${n.op} is not implemented`)}})(s,a,c));case"dynamic":return Vme(s,a,c);case"evaluation":return i(()=>((n,t,e,r=ne)=>{switch(n.op){case"LowerBound":{const i=U("sortedSequence",n,t,e),o=U("values",n,t,e);return[r.lowerBound(i,o)]}case"TopKV2":{const i=U("x",n,t,e),o=U("k",n,t,e),s=U("sorted",n,t,e),a=r.topk(i,o,s);return[a.values,a.indices]}case"UpperBound":{const i=U("sortedSequence",n,t,e),o=U("values",n,t,e);return[r.upperBound(i,o)]}case"Unique":{const i=U("x",n,t,e),o=r.unique(i);return[o.values,o.indices]}case"UniqueV2":{const i=U("x",n,t,e),o=U("axis",n,t,e),s=r.unique(i,o);return[s.values,s.indices]}default:throw TypeError(`Node type ${n.op} is not implemented`)}})(s,a,c));case"image":return i(()=>((n,t,e,r=ne)=>{switch(n.op){case"ResizeBilinear":{const i=U("images",n,t,e),o=U("size",n,t,e),s=U("alignCorners",n,t,e),a=U("halfPixelCenters",n,t,e);return[r.image.resizeBilinear(i,[o[0],o[1]],s,a)]}case"ResizeNearestNeighbor":{const i=U("images",n,t,e),o=U("size",n,t,e),s=U("alignCorners",n,t,e),a=U("halfPixelCenters",n,t,e);return[r.image.resizeNearestNeighbor(i,[o[0],o[1]],s,a)]}case"CropAndResize":{const i=U("image",n,t,e),o=U("boxes",n,t,e),s=U("boxInd",n,t,e),a=U("cropSize",n,t,e),c=U("method",n,t,e),u=U("extrapolationValue",n,t,e);return[r.image.cropAndResize(i,o,s,a,c,u)]}case"ImageProjectiveTransformV3":{const i=U("images",n,t,e),o=U("transforms",n,t,e),s=U("outputShape",n,t,e),a=U("fillValue",n,t,e),c=U("interpolation",n,t,e),u=U("fillMode",n,t,e);return[r.image.transform(i,o,c.toLowerCase(),u.toLowerCase(),a,s)]}default:throw TypeError(`Node type ${n.op} is not implemented`)}})(s,a,c));case"graph":return i(()=>((n,t,e,r=ne)=>{switch(n.op){case"Const":return t[n.name];case"PlaceholderWithDefault":const i=U("default",n,t,e);return[Ai(n.name,t,e)||i];case"Placeholder":return[Ai(n.name,t,e)];case"Identity":case"StopGradient":case"FakeQuantWithMinMaxVars":case"Snapshot":return[Al(U("x",n,t,e))];case"IdentityN":return U("x",n,t,e).map(p=>Al(p));case"Shape":return[r.tensor1d(U("x",n,t,e).shape,"int32")];case"ShapeN":return U("x",n,t,e).map(p=>r.tensor1d(p.shape));case"Size":return[r.scalar(U("x",n,t,e).size,"int32")];case"Rank":return[r.scalar(U("x",n,t,e).rank,"int32")];case"NoOp":return[r.scalar(1)];case"Print":const s=U("x",n,t,e),a=U("data",n,t,e),c=U("message",n,t,e),u=U("summarize",n,t,e);console.warn("The graph has a tf.print() operation,usually used for debugging, which slows down performance."),console.log(c);for(let p=0;p<a.length;p++)console.log(Array.prototype.slice.call(a[p].dataSync()).slice(0,u));return[s];default:throw TypeError(`Node type ${n.op} is not implemented`)}})(s,a,c));case"logical":return i(()=>((n,t,e,r=ne)=>{switch(n.op){case"Equal":return[r.equal(U("a",n,t,e),U("b",n,t,e))];case"NotEqual":return[r.notEqual(U("a",n,t,e),U("b",n,t,e))];case"Greater":return[r.greater(U("a",n,t,e),U("b",n,t,e))];case"GreaterEqual":return[r.greaterEqual(U("a",n,t,e),U("b",n,t,e))];case"Less":return[r.less(U("a",n,t,e),U("b",n,t,e))];case"LessEqual":return[r.lessEqual(U("a",n,t,e),U("b",n,t,e))];case"LogicalAnd":return[r.logicalAnd(U("a",n,t,e),U("b",n,t,e))];case"LogicalNot":return[r.logicalNot(U("a",n,t,e))];case"LogicalOr":return[r.logicalOr(U("a",n,t,e),U("b",n,t,e))];case"Select":case"SelectV2":return[r.where(U("condition",n,t,e),U("a",n,t,e),U("b",n,t,e))];case"BitwiseAnd":return[r.bitwiseAnd(U("a",n,t,e),U("b",n,t,e))];default:throw TypeError(`Node type ${n.op} is not implemented`)}})(s,a,c));case"matrices":return i(()=>((n,t,e,r=ne)=>{switch(n.op){case"BatchMatMul":case"BatchMatMulV2":case"MatMul":return[r.matMul(U("a",n,t,e),U("b",n,t,e),U("transposeA",n,t,e),U("transposeB",n,t,e))];case"Einsum":return[r.einsum(U("equation",n,t,e),...U("tensors",n,t,e))];case"Transpose":return[r.transpose(U("x",n,t,e),U("perm",n,t,e))];case"_FusedMatMul":const[i,o]=U("fusedOps",n,t,e),s="biasadd"===i,a="prelu"===o,c=U("numArgs",n,t,e),u=U("leakyreluAlpha",n,t,e);if(s){if(a&&2!==c)throw new Error("Fused MatMul with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!a&&1!==c)throw new Error("Fused MatMul with BiasAdd must have one extra argument: bias.")}const[p,m]=U("args",n,t,e);return[r.fused.matMul({a:U("a",n,t,e),b:U("b",n,t,e),transposeA:U("transposeA",n,t,e),transposeB:U("transposeB",n,t,e),bias:p,activation:o,preluActivationWeights:m,leakyreluAlpha:u})];case"MatrixBandPart":return[r.linalg.bandPart(U("a",n,t,e),U("numLower",n,t,e),U("numUpper",n,t,e))];default:throw TypeError(`Node type ${n.op} is not implemented`)}})(s,a,c));case"normalization":return i(()=>((n,t,e,r=ne)=>{switch(n.op){case"EuclideanNorm":return[r.euclideanNorm(U("x",n,t,e),U("axis",n,t,e),U("keepDims",n,t,e))];case"FusedBatchNorm":case"FusedBatchNormV2":case"FusedBatchNormV3":return[r.batchNorm(U("x",n,t,e),U("mean",n,t,e),U("variance",n,t,e),U("offset",n,t,e),U("scale",n,t,e),U("epsilon",n,t,e))];case"LRN":return[r.localResponseNormalization(U("x",n,t,e),U("radius",n,t,e),U("bias",n,t,e),U("alpha",n,t,e),U("beta",n,t,e))];case"Softmax":return[r.softmax(U("x",n,t,e))];case"LogSoftmax":return[r.logSoftmax(U("x",n,t,e))];default:throw TypeError(`Node type ${n.op} is not implemented`)}})(s,a,c));case"ragged":return i(()=>((n,t,e,r=ne)=>{switch(n.op){case"RaggedGather":{const{outputNestedSplits:i,outputDenseValues:o}=r.raggedGather(U("paramsNestedSplits",n,t,e),U("paramsDenseValues",n,t,e),U("indices",n,t,e),U("outputRaggedRank",n,t,e));return i.concat(o)}case"RaggedRange":{const{rtNestedSplits:i,rtDenseValues:o}=r.raggedRange(U("starts",n,t,e),U("limits",n,t,e),U("splits",n,t,e));return[i,o]}case"RaggedTensorToTensor":return[r.raggedTensorToTensor(U("shape",n,t,e),U("values",n,t,e),U("defaultValue",n,t,e),U("rowPartitionTensors",n,t,e),U("rowPartitionTypes",n,t,e))];default:throw TypeError(`Node type ${n.op} is not implemented`)}})(s,a,c));case"reduction":return i(()=>((n,t,e,r=ne)=>{switch(n.op){case"Max":{const a=U("axis",n,t,e),c=U("keepDims",n,t,e);return[r.max(U("x",n,t,e),a,c)]}case"Mean":{const a=U("axis",n,t,e),c=U("keepDims",n,t,e);return[r.mean(U("x",n,t,e),a,c)]}case"Min":{const a=U("axis",n,t,e),c=U("keepDims",n,t,e);return[r.min(U("x",n,t,e),a,c)]}case"Sum":{const a=U("axis",n,t,e),c=U("keepDims",n,t,e);return[r.sum(U("x",n,t,e),a,c)]}case"All":{const a=U("axis",n,t,e),c=U("keepDims",n,t,e);return[r.all(U("x",n,t,e),a,c)]}case"Any":{const a=U("axis",n,t,e),c=U("keepDims",n,t,e);return[r.any(U("x",n,t,e),a,c)]}case"ArgMax":{const a=U("axis",n,t,e);return[r.argMax(U("x",n,t,e),a)]}case"ArgMin":{const a=U("axis",n,t,e);return[r.argMin(U("x",n,t,e),a)]}case"Prod":{const a=U("axis",n,t,e),c=U("keepDims",n,t,e);return[r.prod(U("x",n,t,e),a,c)]}case"Cumprod":{const a=U("axis",n,t,e),c=U("exclusive",n,t,e),u=U("reverse",n,t,e);return[r.cumprod(U("x",n,t,e),a,c,u)]}case"Cumsum":{const a=U("axis",n,t,e),c=U("exclusive",n,t,e),u=U("reverse",n,t,e);return[r.cumsum(U("x",n,t,e),a,c,u)]}case"Bincount":const i=U("x",n,t,e),o=U("weights",n,t,e),s=U("size",n,t,e);return[r.bincount(i,o,s)];case"DenseBincount":{const a=U("x",n,t,e),c=U("weights",n,t,e),u=U("size",n,t,e),p=U("binaryOutput",n,t,e);return[r.denseBincount(a,c,u,p)]}default:throw TypeError(`Node type ${n.op} is not implemented`)}})(s,a,c));case"slice_join":return i(()=>((n,t,e,r=ne)=>{switch(n.op){case"ConcatV2":case"Concat":{const i=U("n",n,t,e),o=U("axis",n,t,e);let s=U("tensors",n,t,e);return s=s.slice(0,i),[r.concat(s,o)]}case"Gather":{const i=U("x",n,t,e),o=U("indices",n,t,e);return[r.gather(i,r.cast(o,"int32"),0)]}case"GatherV2":{const i=U("axis",n,t,e),o=U("batchDims",n,t,e),s=U("x",n,t,e),a=U("indices",n,t,e);return[r.gather(s,r.cast(a,"int32"),i,o)]}case"Reverse":{const i=U("dims",n,t,e),o=[];for(let a=0;a<i.length;a++)i[a]&&o.push(a);const s=U("x",n,t,e);return[r.reverse(s,o)]}case"ReverseV2":{const i=U("axis",n,t,e),o=U("x",n,t,e);return[r.reverse(o,i)]}case"Slice":{const i=U("begin",n,t,e),o=U("size",n,t,e);return[r.slice(U("x",n,t,e),i,o)]}case"StridedSlice":{const i=U("begin",n,t,e),o=U("end",n,t,e),s=U("strides",n,t,e),a=U("beginMask",n,t,e),c=U("endMask",n,t,e),u=U("ellipsisMask",n,t,e),p=U("newAxisMask",n,t,e),m=U("shrinkAxisMask",n,t,e),g=U("x",n,t,e);return[r.stridedSlice(g,i,o,s,a,c,u,p,m)]}case"Pack":return Se(()=>{const i=U("axis",n,t,e),o=U("tensors",n,t,e),s=o[0].shape,a=r.squeeze(o[0]).shape,c=o.map(u=>{const p=mn(u.shape,s);if(!p&&!mn(r.squeeze(u).shape,a))throw new Error("the input tensors shape does not match");return p?u:r.reshape(u,s)});return[r.stack(c,i)]});case"Unpack":{const i=U("axis",n,t,e),o=U("tensor",n,t,e);return r.unstack(o,i)}case"Tile":{const i=U("reps",n,t,e);return[r.tile(U("x",n,t,e),i)]}case"Split":case"SplitV":{const i=U("axis",n,t,e),o=U("numOrSizeSplits",n,t,e),s=U("x",n,t,e);return r.split(s,o,i)}case"ScatterNd":{const i=U("indices",n,t,e),o=U("values",n,t,e),s=U("shape",n,t,e);return[r.scatterND(i,o,s)]}case"GatherNd":{const i=U("x",n,t,e),o=U("indices",n,t,e);return[r.gatherND(i,o)]}case"SparseToDense":{const i=U("sparseIndices",n,t,e),o=U("outputShape",n,t,e),s=U("sparseValues",n,t,e),a=U("defaultValue",n,t,e);return[r.sparseToDense(i,s,o,s.dtype===a.dtype?a:r.cast(a,s.dtype))]}case"TensorScatterUpdate":{const i=U("indices",n,t,e),o=U("values",n,t,e),s=U("tensor",n,t,e);return[r.tensorScatterUpdate(s,i,o)]}default:throw TypeError(`Node type ${n.op} is not implemented`)}})(s,a,c));case"sparse":return i(()=>((n,t,e,r=ne)=>{switch(n.op){case"SparseFillEmptyRows":{const{outputIndices:i,outputValues:o,emptyRowIndicator:s,reverseIndexMap:a}=r.sparse.sparseFillEmptyRows(U("indices",n,t,e),U("values",n,t,e),U("denseShape",n,t,e),U("defaultValue",n,t,e));return[i,o,s,a]}case"SparseReshape":{const{outputIndices:i,outputShape:o}=r.sparse.sparseReshape(U("inputIndices",n,t,e),U("inputShape",n,t,e),U("newShape",n,t,e));return[i,o]}case"SparseSegmentMean":return[r.sparse.sparseSegmentMean(U("data",n,t,e),U("indices",n,t,e),U("segmentIds",n,t,e))];case"SparseSegmentSum":return[r.sparse.sparseSegmentSum(U("data",n,t,e),U("indices",n,t,e),U("segmentIds",n,t,e))];default:throw TypeError(`Node type ${n.op} is not implemented`)}})(s,a,c));case"spectral":return i(()=>((n,t,e,r=ne)=>{switch(n.op){case"FFT":return[r.fft(U("x",n,t,e))];case"IFFT":return[r.ifft(U("x",n,t,e))];case"RFFT":return[r.rfft(U("x",n,t,e))];case"IRFFT":return[r.irfft(U("x",n,t,e))];default:throw TypeError(`Node type ${n.op} is not implemented`)}})(s,a,c));case"string":return i(()=>((n,t,e,r=ne)=>{switch(n.op){case"StaticRegexReplace":return[r.string.staticRegexReplace(U("input",n,t,e),U("pattern",n,t,e),U("rewrite",n,t,e),U("replaceGlobal",n,t,e))];case"StringNGrams":{const{nGrams:i,nGramsSplits:o}=r.string.stringNGrams(U("data",n,t,e),U("dataSplits",n,t,e),U("separator",n,t,e),U("nGramWidths",n,t,e),U("leftPad",n,t,e),U("rightPad",n,t,e),U("padWidth",n,t,e),U("preserveShortSequences",n,t,e));return[i,o]}case"StringSplit":{const{indices:i,values:o,shape:s}=r.string.stringSplit(U("input",n,t,e),U("delimiter",n,t,e),U("skipEmpty",n,t,e));return[i,o,s]}case"StringToHashBucketFast":return[r.string.stringToHashBucketFast(U("input",n,t,e),U("numBuckets",n,t,e))];default:throw TypeError(`Node type ${n.op} is not implemented`)}})(s,a,c));case"transformation":return i(()=>((n,t,e,r=ne)=>{switch(n.op){case"Cast":return[r.cast(U("x",n,t,e),U("dtype",n,t,e))];case"ExpandDims":{const i=U("axis",n,t,e);return[r.expandDims(U("x",n,t,e),i)]}case"Squeeze":{const i=U("axis",n,t,e);return[r.squeeze(U("x",n,t,e),i)]}case"Reshape":return[r.reshape(U("x",n,t,e),U("shape",n,t,e))];case"EnsureShape":return[r.ensureShape(U("x",n,t,e),U("shape",n,t,e))];case"MirrorPad":return[r.mirrorPad(U("x",n,t,e),U("padding",n,t,e),U("mode",n,t,e))];case"PadV2":case"Pad":return[r.pad(U("x",n,t,e),U("padding",n,t,e),U("constantValue",n,t,e))];case"SpaceToBatchND":{const i=U("blockShape",n,t,e),o=U("paddings",n,t,e);return[r.spaceToBatchND(U("x",n,t,e),i,o)]}case"BatchToSpaceND":{const i=U("blockShape",n,t,e),o=U("crops",n,t,e);return[r.batchToSpaceND(U("x",n,t,e),i,o)]}case"DepthToSpace":{const i=U("blockSize",n,t,e),o=U("dataFormat",n,t,e).toUpperCase();return[r.depthToSpace(U("x",n,t,e),i,o)]}case"BroadcastTo":return[r.broadcastTo(U("x",n,t,e),U("shape",n,t,e))];case"BroadcastArgs":return[r.broadcastArgs(U("s0",n,t,e),U("s1",n,t,e))];default:throw TypeError(`Node type ${n.op} is not implemented`)}})(s,a,c));case"hash_table":return Gme(s,a,c,r);case"custom":const u=Cz(s.op);if(u&&u.customExecutor)return u.customExecutor(new kme(s,a,c));throw TypeError(`Custom op ${s.op} is not registered.`);default:throw TypeError(`Unknown op '${s.op}'. File an issue at https://github.com/tensorflow/tfjs/issues so we can add it, or register a custom execution with tf.registerOp()`)}})(n,t,e);return Iu(o)?o.then(s=>[].concat(s)):[].concat(o)}class Mz{constructor(t={},e={},r={},i={},o){this.weightMap=t,this.tensorArrayMap=e,this.tensorListMap=r,this.functionMap=i,this.parseNodeNameCache=o,this.rootContext={id:0,frameName:"",iterationId:0},this.contexts=[this.rootContext],this.lastId=0,this.generateCurrentContextIds()}newFrame(t,e){return{id:t,frameName:e,iterationId:0}}set currentContext(t){this.contexts!==t&&(this.contexts=t,this.generateCurrentContextIds())}get currentContext(){return this.contexts}get currentContextId(){return this._currentContextIds[0]}get currentContextIds(){return this._currentContextIds}generateCurrentContextIds(){const t=[];for(let e=0;e<this.contexts.length-1;e++){const r=this.contexts.slice(0,this.contexts.length-e);t.push(this.contextIdforContexts(r))}t.push(""),this._currentContextIds=t}contextIdforContexts(t){return t?t.map(e=>0===e.id&&0===e.iterationId?"":`${e.frameName}-${e.iterationId}`).join("/"):""}enterFrame(t){this.contexts&&(this.lastId++,this.contexts=this.contexts.slice(),this.contexts.push(this.newFrame(this.lastId,t)),this._currentContextIds.unshift(this.contextIdforContexts(this.contexts)))}exitFrame(){if(!(this.contexts&&this.contexts.length>1))throw new Error("Cannot exit frame, the context is empty");this.contexts=this.contexts.slice(),this.contexts.splice(-1),this.currentContextIds.shift()}nextIteration(){if(!(this.contexts&&this.contexts.length>0))throw new Error("Cannot increase frame iteration, the context is empty");{this.contexts=this.contexts.slice(),this.lastId++;const t=Object.assign({},this.contexts[this.contexts.length-1]);t.iterationId+=1,t.id=this.lastId,this.contexts.splice(-1,1,t),this._currentContextIds.splice(0,1,this.contextIdforContexts(this.contexts))}}getWeight(t){return this.weightMap[t]}addTensorArray(t){this.tensorArrayMap[t.id]=t}getTensorArray(t){return this.tensorArrayMap[t]}addTensorList(t){this.tensorListMap[t.id]=t}getTensorList(t){return this.tensorListMap[t]}dispose(t){for(const e in this.tensorArrayMap)this.tensorArrayMap[e].clearAndClose(t);for(const e in this.tensorListMap)this.tensorListMap[e].clearAndClose(t)}}function Fz(n,t,e,r){const i=new Set,o=[];let s=null,a=null;const c=new Set,u=new Set(Object.keys(n).map(g=>Ho(g)[0]));r=r||[];const p=new Set(r.map(g=>Ho(g.name)[0])),m=[...t];for(;m.length>0;){const g=m.pop();if((Wu(g)||cge(g)||uge(g))&&null==s&&(s=g,a=s.children.map(_=>_.name).filter(_=>i.has(_))),i.add(g.name),null==e[g.name]&&!u.has(g.name)&&!p.has(g.name)){if(0===g.inputs.length){o.push(g.name);continue}g.inputs.forEach(_=>{c.has(_.name)||(c.add(_.name),m.push(_))})}}return{inputs:n,outputs:t,usedNodes:i,missingInputs:o,dynamicNode:s,syncInputs:a}}class Xv extends Error{constructor(t){super(`NodesExecutionOrderError: ${t}`)}}const sge=new Set(["Switch","Merge","Enter","Exit","NextIteration","StatelessIf","StatelessWhile","if","While"]),age=new Set(["NonMaxSuppressionV2","NonMaxSuppressionV3","NonMaxSuppressionV5","Where"]),lge=new Set(["HashTable","HashTableV2","LookupTableImport","LookupTableImportV2","LookupTableFind","LookupTableFindV2","LookupTableSize","LookupTableSizeV2"]);function Wu(n){return sge.has(n.op)}function cge(n){return age.has(n.op)}function uge(n){return lge.has(n.op)}class Yv{get weightIds(){return this.parent?this.parent.weightIds:this._weightIds}get functionExecutorMap(){return this.parent?this.parent.functionExecutorMap:this._functionExecutorMap}get weightMap(){return this.parent?this.parent.weightMap:this._weightMap}set weightMap(t){const e=Object.keys(t).map(r=>t[r].map(i=>i.id));this._weightIds=[].concat(...e),this._weightMap=t}set resourceManager(t){this._resourceManager=t}get inputs(){return this._inputs.map(t=>({name:t.name,shape:t.attrParams.shape?t.attrParams.shape.value:void 0,dtype:t.attrParams.dtype?t.attrParams.dtype.value:void 0}))}get outputs(){return this._outputs.map(t=>({name:t.name,shape:t.attrParams.shape?t.attrParams.shape.value:void 0,dtype:t.attrParams.dtype?t.attrParams.dtype.value:void 0}))}get inputNodes(){return this._inputs.map(t=>t.signatureKey||t.name)}get outputNodes(){return this._outputs.map(t=>{const e=t.signatureKey||t.name;return t.defaultOutput?`${e}:${t.defaultOutput}`:e})}get functions(){return Object.keys(this._functions).reduce((t,e)=>(t[e]=this._functions[e].signature,t),{})}constructor(t,e){this.graph=t,this.parent=e,this.compiledMap=new Map,this.parseNodeNameCache=new Map,this._weightMap={},this.SEPARATOR=",",this._functions={},this._functionExecutorMap={},this.keepIntermediateTensors=!1,this._outputs=t.outputs,this._inputs=t.inputs,this._initNodes=t.initNodes,this._signature=t.signature,this._functions=t.functions,null!=t.functions&&Object.keys(t.functions).forEach(r=>{this._functionExecutorMap[r]=new Yv(t.functions[r],this)})}getCompilationKey(t,e){const r=t.map(o=>o.name).sort(),i=e.map(o=>o.name).sort();return r.join(this.SEPARATOR)+"--"+i.join(this.SEPARATOR)}compile(t,e){const r=Fz(t,e,this.weightMap,this._initNodes),{missingInputs:i,dynamicNode:o,syncInputs:s}=r;if(null!=o)throw new Error(`This execution contains the node '${o.name}', which has the dynamic op '${o.op}'. Please use model.executeAsync() instead. Alternatively, to avoid the dynamic ops, specify the inputs [${s}]`);if(i.length>0){const u=e.map(m=>m.name),p=Object.keys(t);throw new Error(`Cannot compute the outputs [${u}] from the provided inputs [${p}]. Missing the following inputs: [${i}]`)}const a=function nge(n,t){const{usedNodes:e,inputs:r}=t,s=I=>e.has("string"==typeof I?I:I.name);function a(I){return[...new Map(I.map(N=>[N.name,N])).values()]}const c=a([...Object.keys(r).map(I=>Ho(I)[0]).map(I=>n.nodes[I]),...n.weights,...n.initNodes||[]]).filter(s),u=a([...c,...Object.values(n.nodes)]).filter(s),p=new Map(u.map(I=>[I.name,I])),m={};for(const I of u){m[I.name]=m[I.name]||0;for(const N of I.children)s(N)||(m[N.name]=Number.POSITIVE_INFINITY),m[N.name]=(m[N.name]||0)+1}const g=Object.entries(m).filter(([,I])=>0===I).map(([I])=>I),_=[...g];for(;g.length>0;){const I=g.pop(),N=p.get(I);for(const R of N.children.filter(s))0==--m[R.name]&&(_.push(R.name),g.push(R.name))}const T=function rge(n,t){const e=new Map(n.map(s=>[s.name,s])),r=t.map(s=>s.name),i=new Set(r);for(;r.length>0;){const s=r.pop(),a=e.get(s);for(const c of a.children)!e.has(c.name)||i.has(c.name)||(i.add(c.name),r.push(c.name))}return n.filter(s=>i.has(s.name))}(_.map(I=>p.get(I)),c);return function ige(n,t){const e=new Map(n.map((a,c)=>[a.name,c])),r=new Set(t.map(a=>a.name)),i=a=>r.has("string"==typeof a?a:a.name),o=new Set(n.map(a=>a.name)),s=a=>o.has("string"==typeof a?a:a.name);for(const a of n){for(const c of a.children.filter(s)){if(!e.has(c.name))throw new Xv(`Child ${c.name} of node ${a.name} is unreachable.`);if(e.get(a.name)>e.get(c.name))throw new Xv(`Node ${a.name} is scheduled to run after its child ${c.name}.`)}if(!i(a))for(const c of a.inputs){if(!e.has(c.name))throw new Xv(`Input ${c.name} of node ${a.name} is unreachable.`);if(e.get(c.name)>e.get(a.name))throw new Xv(`Node ${a.name} is scheduled to run before its input ${c.name}.`)}}}(T,c),T}(this.graph,r),c=function oge(n){const t=new Map(n.map((a,c)=>[a.name,c])),e=Number.MAX_SAFE_INTEGER,r=n.map((a,c)=>Wu(a)?e:c),i=a=>r[t.get(a.name)]??-1,o=n.map((a,c)=>a.children.map(i).reduce((u,p)=>Math.max(u,p),r[c])),s=new Map;for(let a=0;a<n.length;++a){const c=o[a];if(c===e)continue;const u=n[a],p=n[c];s.has(p.name)||s.set(p.name,[]),s.get(p.name).push(u)}return s}(a);return{orderedNodes:a,nodeLiveUntilMap:c}}cloneAndKeepTensor(t){if(null==t)return null;const e=t.clone();return fi(e),e}cloneTensorList(t){return t?t.map(r=>this.cloneAndKeepTensor(r)):null}cloneTensorMap(t){return Object.fromEntries(Object.entries(t).map(([e,r])=>[e,this.cloneTensorList(r)]))}execute(t,e){this.disposeIntermediateTensors(),t=this.mapInputs(t);const r=Object.keys(t).sort();this.checkInputs(t),this.checkInputShapeAndType(t),e=this.mapOutputs(e),this.checkOutputs(e);const i=r.map(g=>this.graph.nodes[Ho(g)[0]]),o=e.map(g=>Ho(g)[0]),s=new Set(o);let a=o.map(g=>this.graph.nodes[g]);0===a.length&&(a=this._outputs);const c=this.getCompilationKey(i,a);let u=this.compiledMap.get(c);null==u&&(u=this.compile(t,a),this.compiledMap.set(c,u));try{this.keepIntermediateTensors=Ie().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(g){this.keepIntermediateTensors=!1,console.warn(g.message)}const p={},m={};return Se(()=>{const g=new Mz(this.weightMap,p,m,this.functionExecutorMap,this.parseNodeNameCache),_=Object.assign({},this.weightMap);this.keepIntermediateTensors&&(this.clonedTensorsMap=this.cloneTensorMap(this.weightMap)),Object.keys(t).forEach(N=>{const[R,L]=Ho(N,g),V=[];V[L]=t[N],_[R]=V,this.keepIntermediateTensors&&(this.clonedTensorsMap[R]=this.cloneTensorList(V))});const x=this.getFrozenTensorIds(_),{orderedNodes:T,nodeLiveUntilMap:I}=u;for(const N of T){if(_[N.name])continue;const R=Rz(N,_,g,this._resourceManager);if(Iu(R))throw new Error(`The execution of the op '${N.op}' returned a promise. Please use model.executeAsync() instead.`);_[N.name]=R,this.keepIntermediateTensors&&(this.clonedTensorsMap[N.name]=this.cloneTensorList(R)),this.checkTensorForDisposalWithNodeLiveUntilInfo(N,_,g,x,s,I.get(N.name))}return null==this.parent&&g.dispose(x),e.map(N=>Ai(N,_,g))})}getFrozenTensorIds(t){const e=[].concat.apply([],Object.keys(t).map(r=>t[r]).map(r=>r.map(i=>i.id)));return new Set(e)}checkTensorForDisposal(t,e,r,i,o,s,a){if(!Wu(e)&&!s.has(t)){for(const c of r[t])null!=c&&(a[c.id]=(a[c.id]||0)+e.children.length);for(const c of e.inputs){if(Wu(c))continue;const u=Iz(c.name,r,i);if(null!=u)for(const p of u){if(!p||p.kept||o.has(p.id))continue;const m=a[p.id];1===m?(p.dispose(),delete a[p.id]):null!=m&&a[p.id]--}}}}checkTensorForDisposalWithNodeLiveUntilInfo(t,e,r,i,o,s){function a(c){return Wu(c)||o.has(c.name)}if(!Wu(t)&&null!=s)for(const c of s){if(a(c))continue;const u=Iz(c.name,e,r);for(const p of u)!p||p.kept||i.has(p.id)||p.dispose()}}executeAsync(t,e){var r=this;return $e(function*(){return r._executeAsync(t,e)})()}disposeIntermediateTensors(){this.clonedTensorsMap&&(Object.values(this.clonedTensorsMap).forEach(t=>{for(const e of t)e&&!e.isDisposed&&e.dispose()}),this.clonedTensorsMap=null)}getIntermediateTensors(){return this.clonedTensorsMap}_executeAsync(t,e,r=!1,i={},o={}){var s=this;return $e(function*(){s.disposeIntermediateTensors(),r||(t=s.mapInputs(t),s.checkInputs(t),s.checkInputShapeAndType(t),e=s.mapOutputs(e),s.checkOutputs(e));try{s.keepIntermediateTensors=Ie().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(_){s.keepIntermediateTensors=!1,console.warn(_.message)}const a=new Mz(s.weightMap,i,o,s.functionExecutorMap,s.parseNodeNameCache);s.keepIntermediateTensors&&(s.clonedTensorsMap=s.cloneTensorMap(s.weightMap));const c=yield s.executeWithControlFlow(t,a,e,r),u=e.map(_=>Ai(_,c,a)),p=u.map(_=>_.id),m=Object.keys(t).map(_=>t[_].id),g=new Set([...p,...m,...s.weightIds]);return Object.values(c).forEach(_=>{_.forEach(x=>{x&&!x.isDisposed&&!g.has(x.id)&&x.dispose()})}),null==s.parent&&a.dispose(g),u})()}executeFunctionAsync(t,e,r){var i=this;return $e(function*(){const o=t.reduce((s,a,c)=>(s[i.inputs[c].name]=a,s),{});return i._executeAsync(o,i.outputNodes,!0,e,r)})()}executeWithControlFlow(t,e,r,i){var o=this;return $e(function*(){const s=Object.keys(t),a=s.map(j=>o.graph.nodes[Ho(j)[0]]),c=r.map(j=>Ho(j)[0]),u=new Set(c);let p=c.map(j=>o.graph.nodes[j]);0===p.length&&(p=o._outputs);const{usedNodes:m,missingInputs:g,dynamicNode:_,syncInputs:x}=Fz(t,p,o.weightMap,o._initNodes),T=[...a,...o.graph.weights,...o._initNodes||[]].map(j=>({node:j,contexts:e.currentContext})),I=Object.assign({},o.weightMap);Object.keys(t).forEach(j=>{const[Y,ee]=Ho(j),ie=[];ie[ee]=t[j],I[Y]=ie});const N={},R=o.getFrozenTensorIds(I),L={};for(;T.length>0;){const j=o.processStack(a,T,e,I,L,R,u,N,m);yield Promise.all(j)}null==_&&!i&&console.warn("This model execution did not contain any nodes with control flow or dynamic output shapes. You can use model.execute() instead.");const V=p.filter(j=>!Wu(j)&&!Ai(j.name,I,e)).map(j=>j.name);if(V.length>0){let j="";throw null!=_&&(j=`Alternatively, to avoid the dynamic ops, use model.execute() and specify the inputs [${x}]`),new Error(`Cannot compute the outputs [${V}] from the provided inputs [${s}]. Consider providing the following inputs: [${g}]. ${j}`)}return I})()}processStack(t,e,r,i,o,s,a,c,u){const p=[];for(;e.length>0;){const m=e.pop();r.currentContext=m.contexts;let g="";if("Enter"===m.node.op&&U("isConstant",m.node,i,r)&&([g]=kl(m.node.name,r)),null==i[m.node.name]){const _=Rz(m.node,i,r,this._resourceManager);g||([g]=kl(m.node.name,r));const x=r.currentContext;Iu(_)?p.push(_.then(T=>(i[g]=T,this.keepIntermediateTensors&&(this.clonedTensorsMap[g]=this.cloneTensorList(T)),r.currentContext=x,this.checkTensorForDisposal(g,m.node,i,r,s,a,c),this.processChildNodes(m.node,e,r,i,o,u),T))):(i[g]=_,this.keepIntermediateTensors&&(this.clonedTensorsMap[g]=this.cloneTensorList(_)),this.checkTensorForDisposal(g,m.node,i,r,s,a,c),this.processChildNodes(m.node,e,r,i,o,u))}else this.processChildNodes(m.node,e,r,i,o,u)}return p}processChildNodes(t,e,r,i,o,s){t.children.forEach(a=>{const[c]=kl(a.name,r);o[c]||!s.has(a.name)||("Merge"===a.op?a.inputNames.some(u=>!!Ai(u,i,r))&&(o[c]=!0,e.push({contexts:r.currentContext,node:a})):a.inputNames.every(u=>!!Ai(u,i,r))&&(o[c]=!0,e.push({contexts:r.currentContext,node:a})))})}dispose(){Object.keys(this.weightMap).forEach(t=>this.weightMap[t].forEach(e=>e.dispose()))}checkInputShapeAndType(t){Object.keys(t).forEach(e=>{const r=t[e],[i]=Ho(e),o=this.graph.nodes[i];if(o.attrParams.shape&&o.attrParams.shape.value){const s=o.attrParams.shape.value;Z(s.length===r.shape.length&&r.shape.every((c,u)=>-1===s[u]||s[u]===c),()=>`The shape of dict['${o.name}'] provided in model.execute(dict) must be [${s}], but was [${r.shape}]`)}o.attrParams.dtype&&o.attrParams.dtype.value&&Z(r.dtype===o.attrParams.dtype.value,()=>`The dtype of dict['${o.name}'] provided in model.execute(dict) must be ${o.attrParams.dtype.value}, but was ${r.dtype}`)})}mapInputs(t){var e,r;const i={};for(const o in t){const s=null===(r=null===(e=this._signature)||void 0===e?void 0:e.inputs)||void 0===r?void 0:r[o];null!=s?i[s.name]=t[o]:i[o]=t[o]}return i}checkInputs(t){const e=Object.keys(t).filter(r=>{const[i]=Ho(r);return null==this.graph.nodes[i]});if(e.length>0)throw new Error(`The dict provided in model.execute(dict) has keys: [${e}] that are not part of graph`)}mapOutputs(t){return t.map(e=>{var r,i;const o=null===(i=null===(r=this._signature)||void 0===r?void 0:r.outputs)||void 0===i?void 0:i[e];return null!=o?o.name:e},{})}checkOutputs(t){t.forEach(e=>{const[r]=Ho(e);if(!this.graph.nodes[r])throw new Error(`The output '${e}' is not found in the graph`)})}}class dge{constructor(t={},e={}){this.hashTableNameToHandle=t,this.hashTableMap=e}addHashTable(t,e){this.hashTableNameToHandle[t]=e.handle,this.hashTableMap[e.id]=e}getHashTableHandleByName(t){return this.hashTableNameToHandle[t]}getHashTableById(t){return this.hashTableMap[t]}dispose(){for(const t in this.hashTableMap)this.hashTableMap[t].clearAndClose(),delete this.hashTableMap[t];for(const t in this.hashTableNameToHandle)this.hashTableNameToHandle[t].dispose(),delete this.hashTableNameToHandle[t]}}const hge="?tfjs-format=file",pge="model.json";class Pz{get modelVersion(){return this.version}get inputNodes(){return this.executor.inputNodes}get outputNodes(){return this.executor.outputNodes}get inputs(){return this.executor.inputs}get outputs(){return this.executor.outputs}get weights(){return this.executor.weightMap}get metadata(){return this.artifacts.userDefinedMetadata}get modelSignature(){return this.signature}get modelStructuredOutputKeys(){return this.structuredOutputKeys}constructor(t,e={},r=F){this.modelUrl=t,this.loadOptions=e,this.version="n/a",this.io=r,null==e&&(this.loadOptions={}),this.resourceManager=new dge}findIOHandler(){const t=this.modelUrl;if(null!=t.load)this.handler=t;else if(null!=this.loadOptions.requestInit)this.handler=this.io.browserHTTPRequest(t,this.loadOptions);else{const e=this.io.getLoadHandlers(t,this.loadOptions);if(0===e.length)e.push(this.io.browserHTTPRequest(t,this.loadOptions));else if(e.length>1)throw new Error(`Found more than one (${e.length}) load handlers for URL '${[t]}'`);this.handler=e[0]}}load(){if(this.findIOHandler(),null==this.handler.load)throw new Error("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");const t=this.handler.load();return Iu(t)?t.then(e=>this.loadSync(e)):this.loadSync(t)}loadSync(t){this.artifacts=t;const e=this.artifacts.modelTopology;let r=this.artifacts.signature;if(null!=this.artifacts.userDefinedMetadata){const o=this.artifacts.userDefinedMetadata;null!=o.signature&&(r=o.signature),null!=o.structuredOutputKeys&&(this.structuredOutputKeys=o.structuredOutputKeys)}this.signature=r,this.version=`${e.versions.producer}.${e.versions.minConsumer}`;const i=this.io.decodeWeights(this.artifacts.weightData,this.artifacts.weightSpecs);if(this.executor=new Yv(Ez.Instance.transformGraph(e,this.signature)),this.executor.weightMap=this.convertTensorMapToTensorsMap(i),this.executor.resourceManager=this.resourceManager,null!=t.modelInitializer&&null!=t.modelInitializer.node){const o=Ez.Instance.transformGraph(t.modelInitializer);this.initializer=new Yv(o),this.initializer.weightMap=this.executor.weightMap,this.initializer.resourceManager=this.resourceManager,this.initializerSignature=t.initializerSignature}return!0}save(t,e){var r=this;return $e(function*(){if("string"==typeof t){const i=r.io.getSaveHandlers(t);if(0===i.length)throw new Error(`Cannot find any save handlers for URL '${t}'`);if(i.length>1)throw new Error(`Found more than one (${i.length}) save handlers for URL '${t}'`);t=i[0]}if(null==t.save)throw new Error("GraphModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");return t.save(r.artifacts)})()}addStructuredOutputNames(t){if(this.structuredOutputKeys){const r={};return(t instanceof sr?[t]:t).forEach((i,o)=>r[this.structuredOutputKeys[o]]=i),r}return t}predict(t,e){const r=this.execute(t,this.outputNodes);return this.addStructuredOutputNames(r)}predictAsync(t,e){var r=this;return $e(function*(){const i=yield r.executeAsync(t,r.outputNodes);return r.addStructuredOutputNames(i)})()}normalizeInputs(t){var e;if(!(t instanceof sr||Array.isArray(t))){const o=null===(e=this.signature)||void 0===e?void 0:e.inputs;if(null!=o)for(const s in o){const a=o[s];null!=a.resourceId&&(t[s]=this.resourceIdToCapturedInput[a.resourceId])}return t}t=Array.isArray(t)?t:[t];const r=Object.keys(this.resourceIdToCapturedInput).length;if(t.length+r!==this.inputNodes.length)throw new Error(`Input tensor count mismatch, the graph model has ${this.inputNodes.length-r} non-resource placeholders, while there are ${t.length} input tensors provided.`);let i=0;return this.inputNodes.reduce((o,s)=>{var a,c,u;const p=null===(u=null===(c=null===(a=this.signature)||void 0===a?void 0:a.inputs)||void 0===c?void 0:c[s])||void 0===u?void 0:u.resourceId;return o[s]=null!=p?this.resourceIdToCapturedInput[p]:t[i++],o},{})}normalizeOutputs(t){return t=t||this.outputNodes,Array.isArray(t)?t:[t]}executeInitializerGraph(){return null==this.initializer?[]:this.initializer.execute({},null==this.initializerSignature?[]:Object.keys(this.initializerSignature.outputs))}executeInitializerGraphAsync(){var t=this;return $e(function*(){return null==t.initializer?[]:t.initializer.executeAsync({},null==t.initializerSignature?[]:Object.keys(t.initializerSignature.outputs))})()}setResourceIdToCapturedInput(t){if(this.resourceIdToCapturedInput={},this.initializerSignature){const e=this.initializerSignature.outputs,r=Object.keys(e);for(let i=0;i<r.length;i++)this.resourceIdToCapturedInput[e[r[i]].resourceId]=t[i]}}execute(t,e){null==this.resourceIdToCapturedInput&&this.setResourceIdToCapturedInput(this.executeInitializerGraph()),t=this.normalizeInputs(t),e=this.normalizeOutputs(e);const r=this.executor.execute(t,e);return r.length>1?r:r[0]}executeAsync(t,e){var r=this;return $e(function*(){null==r.resourceIdToCapturedInput&&r.setResourceIdToCapturedInput(yield r.executeInitializerGraphAsync()),t=r.normalizeInputs(t),e=r.normalizeOutputs(e);const i=yield r.executor.executeAsync(t,e);return i.length>1?i:i[0]})()}getIntermediateTensors(){return this.executor.getIntermediateTensors()}disposeIntermediateTensors(){this.executor.disposeIntermediateTensors()}convertTensorMapToTensorsMap(t){return Object.keys(t).reduce((e,r)=>(e[r]=[t[r]],e),{})}dispose(){this.executor.dispose(),this.initializer&&(this.initializer.dispose(),this.resourceIdToCapturedInput&&un(this.resourceIdToCapturedInput)),this.resourceManager.dispose()}}function Sk(n){return Ck.apply(this,arguments)}function Ck(){return(Ck=$e(function*(n,t={},e=F){if(null==n)throw new Error("modelUrl in loadGraphModel() cannot be null. Please provide a url or an IOHandler that loads the model");null==t&&(t={}),t.fromTFHub&&"string"==typeof n&&(n=function fge(n){return n.endsWith("/")||(n+="/"),`${n}${pge}${hge}`}(n));const r=new Pz(n,t,e);return yield r.load(),r})).apply(this,arguments)}function Ct(n,t){Array.isArray(n)||(n=[n]),n.forEach(e=>{null!=e&&Z("complex64"!==e.dtype,()=>`${t} does not support complex64 tensors in the CPU backend.`)})}Symbol("out"),Symbol("field"),Symbol("quote"),Symbol("quoteafterquote"),Symbol("quoteinquote");const Uge=VE;let jge=(()=>{class n extends aC{nextDataId(){return n.nextDataId++}constructor(){super(),this.blockSize=48,this.firstUse=!0,this.data=new HL(this,Fa())}write(e,r,i){this.firstUse&&(this.firstUse=!1,Ie().get("IS_NODE")&&as("\n============================\nHi, looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, visit https://github.com/tensorflow/tfjs-node for more details. \n============================"));const o={id:this.nextDataId()};return this.data.set(o,{values:e,dtype:i,refCount:1}),o}makeTensorInfo(e,r,i){let o;if("string"===r&&null!=i&&i.length>0&&om(i[0])){const s=i.map(a=>cc(a));o=this.write(s,e,r)}else o=this.write(i,e,r);return{dataId:o,shape:e,dtype:r}}refCount(e){return this.data.has(e)?this.data.get(e).refCount:0}incRef(e){this.data.get(e).refCount++}decRef(e){this.data.has(e)&&this.data.get(e).refCount--}move(e,r,i,o,s){this.data.set(e,{values:r,dtype:o,refCount:s})}numDataIds(){return this.data.numDataIds()}read(e){var r=this;return $e(function*(){return r.readSync(e)})()}readSync(e){const{dtype:r,complexTensorInfos:i}=this.data.get(e);return"complex64"===r?Cl(this.readSync(i.real.dataId),this.readSync(i.imag.dataId)):function cre(n,t){if(Array.isArray(n))return n;if("float32"===t)return n instanceof Float32Array?n:new Float32Array(n);if("int32"===t)return n instanceof Int32Array?n:new Int32Array(n);if("bool"===t||"string"===t)return Uint8Array.from(new Int32Array(n));throw new Error(`Unknown dtype ${t}`)}(this.data.get(e).values,r)}bufferSync(e){const r=this.readSync(e.dataId);if("string"===e.dtype)try{const i=r.map(o=>uc(o));return sn(e.shape,e.dtype,i)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return sn(e.shape,e.dtype,r)}makeOutput(e,r,i){return Fa().makeTensorFromTensorInfo(this.makeTensorInfo(r,i,e),this)}disposeData(e,r=!1){if(this.data.has(e)){if(this.data.get(e).refCount--,!r&&this.data.get(e).refCount>0)return!1;const{complexTensorInfos:i}=this.data.get(e);null!=i&&(this.disposeData(i.real.dataId,!0),this.disposeData(i.imag.dataId,!0)),this.data.delete(e)}return!0}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}time(e){return $e(function*(){const r=xo();return e(),{kernelMs:xo()-r}})()}memory(){return{unreliable:!0,reasons:["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."]}}where(e){Ct([e],"where");const r=this.readSync(e.dataId);return Uge(e.shape,r)}dispose(){}floatPrecision(){return 32}epsilon(){return super.epsilon()}}return n.nextDataId=0,n})();function qa(n){return(t,e,r)=>{const i=Or(e,t.length);for(let o=0;o<t.length;++o)i[o]=n(t[o],r);return i}}function $n(n,t,e){return Fc(n,qa(t),e)}function Fc(n,t,e){return({inputs:r,attrs:i,backend:o})=>{const{x:s}=r;Ct(s,n);const a=o,c=a.data.get(s.dataId).values;let u;if("string"===s.dtype){if(!Array.isArray(c))throw new Error("String tensor's value was not an instance of Array");u=Il(c)}else u=c;const p=e||s.dtype,m=t(u,p,i);return a.makeTensorInfo(s.shape,p,m)}}L3("cpu",()=>new jge,1);const qz=$n(_m,n=>n>=0?n:Math.exp(n)-1),Hge={kernelName:_m,backendName:"cpu",kernelFunc:qz};function Ka(n){const{inputs:t,backend:e}=n,{x:r}=t;return e.incRef(r.dataId),{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}const Wge={kernelName:Im,backendName:"cpu",kernelFunc:Ka};function Kz(n){const{inputs:t,backend:e,attrs:r}=n,{x:i}=t,{alpha:o}=r;Ct([i],"leakyRelu");const s=Me(i.shape),a=e.data.get(i.dataId).values,c=Ei("float32",s);for(let u=0;u<a.length;u++)c[u]=a[u]<0?o*a[u]:a[u];return e.makeTensorInfo(i.shape,"float32",c)}const qge={kernelName:e0,backendName:"cpu",kernelFunc:Kz};function Pr(n){return(t,e,r,i,o)=>{const s=Yt(t,e),a=s.length,c=Rt(s),p=Ei(o,Me(s)),m=t.length,g=e.length,_=Rt(t),x=Rt(e),T=Nh(t,s),I=Nh(e,s);if(T.length+I.length===0)for(let N=0;N<p.length;++N)p[N]=n(r[N%r.length],i[N%i.length]);else for(let N=0;N<p.length;++N){const R=vh(N,a,c),L=R.slice(-m);T.forEach(ee=>L[ee]=0);const V=Ra(L,m,_),j=R.slice(-g);I.forEach(ee=>j[ee]=0);const Y=Ra(j,g,x);p[N]=n(r[V],i[Y])}return[p,s]}}const Kge=Pr((n,t)=>n<0?t*n:n);function Xz(n){const{inputs:t,backend:e}=n,{x:r,alpha:i}=t;Ct([r,i],"prelu");const o=e.data.get(r.dataId).values,s=e.data.get(i.dataId).values,[a,c]=Kge(r.shape,i.shape,o,s,"float32");return e.makeTensorInfo(c,"float32",a)}const Xge={kernelName:v0,backendName:"cpu",kernelFunc:Xz},Yz=$n(Lm,n=>Math.max(0,n)),Yge={kernelName:Lm,backendName:"cpu",kernelFunc:Yz},Zz=$n(Bm,n=>Math.min(Math.max(0,n),6)),Zge={kernelName:Bm,backendName:"cpu",kernelFunc:Zz},Qge=qa(n=>1/(1+Math.exp(-n))),Qz=$n(Wm,n=>1/(1+Math.exp(-n))),Jge={kernelName:Wm,backendName:"cpu",kernelFunc:Qz};function ex(n,t,e,r,i){if("linear"===e)return Ka({inputs:{x:t},backend:n});if("relu"===e)return Yz({inputs:{x:t},backend:n});if("elu"===e)return qz({inputs:{x:t},backend:n});if("relu6"===e)return Zz({inputs:{x:t},backend:n});if("prelu"===e)return Xz({inputs:{x:t,alpha:r},backend:n});if("leakyrelu"===e)return Kz({inputs:{x:t},backend:n,attrs:{alpha:i}});if("sigmoid"===e)return Qz({inputs:{x:t},backend:n});throw new Error(`Activation ${e} has not been implemented for the CPU backend.`)}function Wo(n){const{inputs:t,backend:e}=n,{real:r,imag:i}=t,o=e.data.get(r.dataId).values,s=e.data.get(i.dataId).values,a=e.makeTensorInfo(r.shape,"complex64");return e.data.get(a.dataId).complexTensorInfos={real:e.makeTensorInfo(r.shape,"float32",o),imag:e.makeTensorInfo(i.shape,"float32",s)},a}const ebe={kernelName:TC,backendName:"cpu",kernelFunc:Wo};function tx(n,t,e="float32"){if("complex64"===e)return Wo({inputs:{real:tx(n,t,"float32"),imag:tx(n,t,"float32")},backend:n});const r=Ui(Me(t),e);return n.makeTensorInfo(t,e,r)}function qu(n){const{inputs:t,backend:e}=n,{input:r}=t,i=e.data.get(r.dataId).complexTensorInfos.real,o=e.data.get(i.dataId).values;return e.makeTensorInfo(i.shape,i.dtype,o)}const tbe={kernelName:rI,backendName:"cpu",kernelFunc:qu};function Jz(n,t,e,r){if("int32"===r)return[t,"int32",Int32Array.from(n)];if("bool"===r){const i=ku([0],e),[o,s]=Pr((a,c)=>a!==c?1:0)(t,[],n,i,"bool");return[s,"bool",o]}throw new Error(`Error in Cast: failed to cast ${e} to ${r}`)}function Pc(n){const{inputs:t,backend:e,attrs:r}=n,{x:i}=t,{dtype:o}=r;if("complex64"===o){if("complex64"===i.dtype)return Ka({inputs:{x:i},backend:e});const p=tx(e,i.shape,i.dtype),m=Pc({inputs:{x:i},backend:e,attrs:{dtype:"float32"}}),g=Wo({inputs:{real:m,imag:p},backend:e});return e.disposeIntermediateTensorInfo(p),e.disposeIntermediateTensorInfo(m),g}if("complex64"===i.dtype){const p=qu({inputs:{input:i},backend:e}),m=Pc({inputs:{x:p},backend:e,attrs:{dtype:o}});return e.disposeIntermediateTensorInfo(p),m}if(!XL(i.dtype,o)){const p=Ka({inputs:{x:i},backend:e});return{dataId:p.dataId,shape:p.shape,dtype:o}}const s=e.data.get(i.dataId).values,[a,c,u]=Jz(s,i.shape,i.dtype,o);return e.makeTensorInfo(a,c,u)}const nbe={kernelName:pm,backendName:"cpu",kernelFunc:Pc};function ai(n,t,e,r){return null==e?({inputs:i,backend:o})=>{const{a:s,b:a}=i,c=o;Ct([s,a],n);const u=c.data.get(s.dataId).values,p=c.data.get(a.dataId).values,m="string"===s.dtype?Il(u):u,g="string"===s.dtype?Il(p):p,_=r||s.dtype,[x,T]=t(s.shape,a.shape,m,g,_);return c.makeTensorInfo(T,_,x)}:({inputs:i,backend:o})=>{const{a:s,b:a}=i,c=o;if("complex64"===s.dtype||"complex64"===a.dtype){const u=Pc({inputs:{x:s},backend:c,attrs:{dtype:"complex64"}}),p=c.data.get(u.dataId),g=p.complexTensorInfos.imag,_=c.data.get(p.complexTensorInfos.real.dataId).values,x=c.data.get(g.dataId).values,T=Pc({inputs:{x:a},backend:c,attrs:{dtype:"complex64"}}),I=c.data.get(T.dataId),R=I.complexTensorInfos.imag,L=c.data.get(I.complexTensorInfos.real.dataId).values,V=c.data.get(R.dataId).values,[j,Y,ee]=e(s.shape,a.shape,_,x,L,V),ie=c.makeTensorInfo(ee,"float32",j),ce=c.makeTensorInfo(ee,"float32",Y),he=Wo({inputs:{real:ie,imag:ce},backend:c});return c.disposeIntermediateTensorInfo(u),c.disposeIntermediateTensorInfo(T),c.disposeIntermediateTensorInfo(ie),c.disposeIntermediateTensorInfo(ce),he}{const u=c.data.get(s.dataId).values,p=c.data.get(a.dataId).values,m=r||s.dtype,[g,_]=t(s.shape,a.shape,u,p,m);return c.makeTensorInfo(_,m,g)}}}function Ok(n){return(t,e,r,i,o,s)=>{const a=Yt(t,e),c=Me(a),u=a.length,p=Rt(a),m=Ei("float32",c),g=Ei("float32",c),_=Nh(t,a),x=Nh(e,a),T=Cl(r,i),I=Cl(o,s),N=t.length,R=Rt(t),L=e.length,V=Rt(e);if(_.length+x.length===0)for(let j=0;j<m.length;j++){const Y=j%T.length,ee=j%I.length,ie=n(T[2*Y],T[2*Y+1],I[2*ee],I[2*ee+1]);m[j]=ie.real,g[j]=ie.imag}else for(let j=0;j<m.length;j++){const Y=vh(j,u,p),ee=Y.slice(-N);_.forEach(Ee=>ee[Ee]=0);const ie=Ra(ee,N,R),ce=Y.slice(-L);x.forEach(Ee=>ce[Ee]=0);const he=Ra(ce,L,V),we=n(T[2*ie],T[2*ie+1],I[2*he],I[2*he+1]);m[j]=we.real,g[j]=we.imag}return[m,g,a]}}const eU=Pr((n,t)=>n+t),rbe=Ok((n,t,e,r)=>({real:n+e,imag:t+r})),Xh=ai(xh,eU,rbe),ibe={kernelName:xh,backendName:"cpu",kernelFunc:Xh};function Yn(n){const{inputs:t,backend:e,attrs:r}=n,{x:i}=t,{shape:o}=r,s=Me(i.shape),a=KL(o,s),c=Me(a);Z(s===c,()=>`The new shape (${a}) has ${c} elements and the old shape (${i.shape}) has ${s} elements. The new shape and old shape must have the same number of elements.`),e.incRef(i.dataId);const u=e.data.get(i.dataId);if(null!=u.complexTensorInfos){const m=u.complexTensorInfos.imag;u.complexTensorInfos.real.shape=a,m.shape=a}return{dataId:i.dataId,shape:a,dtype:i.dtype}}const obe={kernelName:w0,backendName:"cpu",kernelFunc:Yn};function tU(n){const{inputs:t,backend:e,attrs:r}=n,{a:i,b:o}=t,{transposeA:s,transposeB:a}=r;Ct([i,o],"matMul");const c=i.shape.length,u=o.shape.length,p=s?i.shape[c-2]:i.shape[c-1],m=a?o.shape[u-1]:o.shape[u-2],g=s?i.shape[c-1]:i.shape[c-2],_=a?o.shape[u-2]:o.shape[u-1],x=i.shape.slice(0,-2),T=o.shape.slice(0,-2),I=Me(x),N=Me(T),L=Yt(i.shape.slice(0,-2),o.shape.slice(0,-2)).concat([g,_]);Z(p===m,()=>`Error in matMul: inner shapes (${p}) and (${m}) of Tensors with shapes ${i.shape} and ${o.shape} and transposeA=${s} and transposeB=${a} must match.`);const j=a?[N,_,m]:[N,m,_],Y=Yn({inputs:{x:i},backend:e,attrs:{shape:s?[I,p,g]:[I,g,p]}}),ee=Yn({inputs:{x:o},backend:e,attrs:{shape:j}}),ie=s?Y.shape[1]:Y.shape[2],ce=s?Y.shape[2]:Y.shape[1],he=a?ee.shape[1]:ee.shape[2],we=Math.max(I,N),Ee=e.data.get(Y.dataId).values,Ae=e.data.get(ee.dataId).values,Oe=Rt(Y.shape),Re=Rt(ee.shape),[_e,Te,xe]=s?[Oe[0],1,Oe[1]]:[Oe[0],Oe[1],1],[De,je,We]=a?[1,Re[1],Re[0]]:[Re[1],1,Re[0]],Je=ce*he,Ze=sn([we,ce,he],Y.dtype),et=Ze.values,rt=e.blockSize;for(let bt=0;bt<we;bt++){const pt=bt%I,Ot=bt%N;for(let Tt=0;Tt<ce;Tt+=rt){const Wt=Math.min(Tt+rt,ce);for(let Zt=0;Zt<he;Zt+=rt){const Ln=Math.min(Zt+rt,he);for(let Zn=0;Zn<ie;Zn+=rt){const Cr=Math.min(Zn+rt,ie);for(let Qn=Tt;Qn<Wt;Qn++)for(let Gn=Zt;Gn<Ln;Gn++){let br=0;for(let cr=Zn;cr<Cr;cr++)br+=Ee[pt*_e+Qn*Te+cr*xe]*Ae[cr*De+Gn*je+Ot*We];et[bt*Je+(Qn*he+Gn)]+=br}}}}}return e.disposeIntermediateTensorInfo(Y),e.disposeIntermediateTensorInfo(ee),e.makeTensorInfo(L,Ze.dtype,Ze.values)}const sbe={kernelName:B_,backendName:"cpu",kernelFunc:tU},lbe={kernelName:P0,backendName:"cpu",kernelFunc:function abe(n){const{inputs:t,backend:e,attrs:r}=n,{a:i,b:o,bias:s,preluActivationWeights:a}=t,{transposeA:c,transposeB:u,activation:p,leakyreluAlpha:m}=r;let g,_,x;const T=[];g=tU({inputs:{a:i,b:o},attrs:{transposeA:c,transposeB:u},backend:e}),s&&(_=Xh({inputs:{a:g,b:s},backend:e}),T.push(g),g=_),p&&(x=ex(e,g,p,a,m),T.push(g),g=x);for(const N of T)e.disposeIntermediateTensorInfo(N);return g}};function nU(n){const t=new Float32Array(n.length);for(let e=0;e<n.length;++e)t[e]=Math.abs(n[e]);return t}const cbe={kernelName:R_,backendName:"cpu",kernelFunc:n=>{const{x:t}=n.inputs,e=n.backend;Ct(t,"abs");let r=new Float32Array(Me(t.shape));return r=nU(e.data.get(t.dataId).values),e.makeOutput(r,t.shape,t.dtype)}},ube=$n(sm,n=>Math.acos(n)),dbe={kernelName:sm,backendName:"cpu",kernelFunc:ube},hbe=$n(am,n=>Math.acosh(n)),pbe={kernelName:am,backendName:"cpu",kernelFunc:hbe},mbe={kernelName:M_,backendName:"cpu",kernelFunc:function fbe(n){const{inputs:t,backend:e}=n,r=t;Ct(t,"addN");const i=r.map(a=>e.data.get(a.dataId).values),o=sn(r[0].shape,r[0].dtype),s=o.values;for(let a=0;a<r.length;a++){const c=i[a];for(let u=0;u<s.length;u++)s[u]+=c[u]}return e.makeTensorInfo(o.shape,o.dtype,o.values)}};function Rk(n,t,e,r,i){const o=t.length,s=Me(t),a=Rt(t),c=Rt(i),u=Ei(e,Me(i));for(let p=0;p<s;++p){const m=vh(p,o,a),g=new Array(m.length);for(let x=0;x<g.length;x++)g[x]=m[r[x]];u[Ra(g,o,c)]=n[p]}return u}function Eo(n){const{inputs:t,attrs:e,backend:r}=n,{x:i}=t,{perm:o}=e;Ct(i,"transpose");const a=new Array(i.shape.length);for(let m=0;m<a.length;m++)a[m]=i.shape[o[m]];const u=Rk(r.data.get(i.dataId).values,i.shape,i.dtype,o,a);return{dataId:r.write(u,a,i.dtype),shape:a,dtype:i.dtype}}const gbe={kernelName:wh,backendName:"cpu",kernelFunc:Eo},ybe={kernelName:"All",backendName:"cpu",kernelFunc:function bbe(n){const{inputs:t,backend:e,attrs:r}=n,{x:i}=t,{axis:o,keepDims:s}=r;Ct(i,"all");const a=cn(o,i.shape);let c=a;const u=hr(c,i.shape.length);let p=i;null!=u&&(p=Eo({inputs:{x:i},backend:e,attrs:{perm:u}}),c=Mr(c.length,i.shape.length)),ki("all",c,p.shape.length);const[m,g]=gi(p.shape,c),_=Me(g),x=Ui(Me(m),p.dtype),T=e.data.get(p.dataId).values;for(let N=0;N<x.length;++N){const R=N*_;let L=T[R];for(let V=0;V<_;++V)L=L&&T[R+V];x[N]=L}null!=u&&e.disposeIntermediateTensorInfo(p);const I=e.makeTensorInfo(m,p.dtype,x);if(s){const R=Yn({inputs:{x:I},backend:e,attrs:{shape:Rr(m,a)}});return e.disposeIntermediateTensorInfo(I),R}return I}},vbe={kernelName:"Any",backendName:"cpu",kernelFunc:function _be(n){const{inputs:t,backend:e,attrs:r}=n,{x:i}=t,{axis:o,keepDims:s}=r;Ct(i,"any");const a=cn(o,i.shape);let c=a;const u=hr(c,i.shape.length);let p=i;null!=u&&(p=Eo({inputs:{x:i},backend:e,attrs:{perm:u}}),c=Mr(c.length,i.shape.length)),ki("any",c,p.shape.length);const[m,g]=gi(p.shape,c),_=Me(g),x=Ui(Me(m),p.dtype),T=e.data.get(p.dataId).values;for(let N=0;N<x.length;++N){const R=N*_;let L=T[R];for(let V=0;V<_;++V)L=L||T[R+V];x[N]=L}null!=u&&e.disposeIntermediateTensorInfo(p);const I=e.makeTensorInfo(m,p.dtype,x);if(s){const R=Yn({inputs:{x:I},backend:e,attrs:{shape:Rr(m,a)}});return e.disposeIntermediateTensorInfo(I),R}return I}},wbe={kernelName:F_,backendName:"cpu",kernelFunc:function xbe(n){const{inputs:t,backend:e,attrs:r}=n,{x:i}=t,{axis:o}=r;Ct(i,"argMax");let s=cn(o,i.shape);const a=hr(s,i.shape.length);let c=i;const u=[];null!=a&&(c=Eo({inputs:{x:i},backend:e,attrs:{perm:a}}),u.push(c),s=Mr(s.length,c.shape.length)),s=[s[0]],ki("argMax",s,c.shape.length);const[p,m]=gi(c.shape,s),_=Ui(Me(p),"int32"),x=Me(m),T=e.data.get(c.dataId).values;for(let I=0;I<_.length;++I){const N=I*x;let R=T[N],L=0;for(let V=0;V<x;++V){const j=T[N+V];j>R&&(R=j,L=V)}_[I]=L}return u.forEach(I=>e.disposeIntermediateTensorInfo(I)),e.makeTensorInfo(p,"int32",_)}},Sbe={kernelName:P_,backendName:"cpu",kernelFunc:function Tbe(n){const{inputs:t,backend:e,attrs:r}=n,{x:i}=t,{axis:o}=r;Ct(i,"argMin");let s=cn(o,i.shape);const a=hr(s,i.shape.length);let c=i;const u=[];null!=a&&(c=Eo({inputs:{x:i},backend:e,attrs:{perm:a}}),u.push(c),s=Mr(s.length,c.shape.length)),s=[s[0]],ki("argMin",s,c.shape.length);const[p,m]=gi(c.shape,s),_=Ui(Me(p),"int32"),x=Me(m),T=e.data.get(c.dataId).values;for(let I=0;I<_.length;++I){const N=I*x;let R=T[N],L=0;for(let V=0;V<x;++V){const j=T[N+V];j<R&&(R=j,L=V)}_[I]=L}return u.forEach(I=>e.disposeIntermediateTensorInfo(I)),e.makeTensorInfo(p,"int32",_)}},Cbe=$n(lm,n=>Math.asin(n)),Ibe={kernelName:lm,backendName:"cpu",kernelFunc:Cbe},Ebe=$n(cm,n=>Math.asinh(n)),Dbe={kernelName:cm,backendName:"cpu",kernelFunc:Ebe},kbe=$n(um,n=>Math.atan(n)),Abe={kernelName:um,backendName:"cpu",kernelFunc:kbe},Nbe=Pr((n,t)=>Math.atan2(n,t)),Obe=ai(hm,Nbe),Rbe={kernelName:hm,backendName:"cpu",kernelFunc:Obe},Mbe=$n(dm,n=>Math.atanh(n)),Fbe={kernelName:dm,backendName:"cpu",kernelFunc:Mbe};function Mk(n,t,e,r,i,o){const s=i.strideHeight,a=i.strideWidth,c=i.dilationHeight,u=i.dilationWidth,p=i.effectiveFilterHeight,m=i.effectiveFilterWidth,g=i.padInfo.top,_=i.padInfo.left,x="max"===o?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,T=sn(i.outShape,e),I=T.values,N=i.outShape[1]*i.outShape[2]*i.outShape[3],R=i.outShape[2]*i.outShape[3],L=i.outShape[3];for(let V=0;V<i.batchSize;++V){const j=V*N,Y=V*r[0];for(let ee=0;ee<i.inChannels;++ee)for(let ie=0;ie<i.outHeight;++ie){const ce=ie*s-g,he=Math.max(0,ce),we=Math.min(i.inHeight,p+ce),Ee=j+ie*R;for(let Ae=0;Ae<i.outWidth;++Ae){const Oe=Ae*a-_,Re=Math.max(0,Oe),_e=Math.min(i.inWidth,m+Oe);let Te=x,xe=0,De=0;for(let We=he;We<we;We+=c){const Je=Y+We*r[1];for(let Ze=Re;Ze<_e;Ze+=u){const rt=n[Je+Ze*r[2]+ee];"max"===o&&rt>Te?Te=rt:"avg"===o&&(xe+=rt,De++)}if(isNaN(Te))break}I[Ee+Ae*L+ee]="avg"===o?xe/De:Te}}}return T}function rU(n,t,e,r,i=!1,o=!1){const s=sn(r.outShape,"int32"),a=r.strideHeight,c=r.strideWidth,u=r.dilationHeight,p=r.dilationWidth,m=r.effectiveFilterHeight,g=r.effectiveFilterWidth,_=r.padInfo.top,x=r.padInfo.left,T=sn(t,e,n);for(let I=0;I<r.batchSize;++I)for(let N=0;N<r.inChannels;++N)for(let R=0;R<r.outHeight;++R){const L=R*a-_;let V=L;for(;V<0;)V+=u;const j=Math.min(r.inHeight,m+L);for(let Y=0;Y<r.outWidth;++Y){const ee=Y*c-x;let ie=ee;for(;ie<0;)ie+=p;const ce=Math.min(r.inWidth,g+ee);let he=Number.NEGATIVE_INFINITY,we=-1;for(let Ee=V;Ee<j;Ee+=u){const Ae=Ee-L;for(let Oe=ie;Oe<ce;Oe+=p){const Re=Oe-ee,_e=T.get(I,Ee,Oe,N);_e>he&&(he=_e,we=i?o?((I*r.inHeight+Ee)*r.inWidth+Oe)*r.inChannels+N:(Ee*r.inWidth+Oe)*r.inChannels+N:Ae*g+Re)}}s.set(we,I,R,Y,N)}}return s}function iU(n,t,e,r,i,o){const s=i.strideDepth,a=i.strideHeight,c=i.strideWidth,u=i.dilationDepth,p=i.dilationHeight,m=i.dilationWidth,g=i.effectiveFilterDepth,_=i.effectiveFilterHeight,x=i.effectiveFilterWidth,T=i.padInfo.front,I=i.padInfo.top,N=i.padInfo.left,R="max"===o?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,L=sn(i.outShape,e),V=L.values,j=i.outShape[1]*i.outShape[2]*i.outShape[3]*i.outShape[4],Y=i.outShape[2]*i.outShape[3]*i.outShape[4],ee=i.outShape[3]*i.outShape[4],ie=i.outShape[4];for(let ce=0;ce<i.batchSize;++ce){const he=ce*j,we=ce*r[0];for(let Ee=0;Ee<i.inChannels;++Ee)for(let Ae=0;Ae<i.outDepth;++Ae){const Oe=Ae*s-T;let Re=Oe;for(;Re<0;)Re+=u;const _e=Math.min(i.inDepth,g+Oe),Te=he+Ae*Y;for(let xe=0;xe<i.outHeight;++xe){const De=xe*a-I;let je=De;for(;je<0;)je+=p;const We=Math.min(i.inHeight,_+De),Je=Te+xe*ee;for(let Ze=0;Ze<i.outWidth;++Ze){const et=Ze*c-N;let rt=et;for(;rt<0;)rt+=m;const bt=Math.min(i.inWidth,x+et),pt=Je+Ze*ie;let Ot=R,Tt=0,Wt=0;for(let Ln=Re;Ln<_e;Ln+=u){const Zn=we+Ln*r[1];for(let Cr=je;Cr<We;Cr+=p){const Qn=Zn+Cr*r[2];for(let Gn=rt;Gn<bt;Gn+=m){const cr=n[Qn+Gn*r[3]+Ee];if("max"===o&&cr>Ot?Ot=cr:"avg"===o&&(Tt+=cr,Wt++),isNaN(Ot))break}if(isNaN(Ot))break}if(isNaN(Ot))break}V[pt+Ee]="avg"===o?Tt/Math.max(Wt,1):Ot}}}}return L}const Lbe={kernelName:$_,backendName:"cpu",kernelFunc:function $be(n){const{inputs:t,backend:e,attrs:r}=n,{x:i}=t;Ct(i,"avgPool");const{filterSize:o,strides:s,pad:a,dimRoundingMode:c}=r;Z(Di(s,1),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${s} and dilations '1'`);const p=Rs(i.shape,o,s,1,a,c);let m;if(1===p.filterWidth&&1===p.filterHeight&&mn(p.inShape,p.outShape))m=Ka({inputs:{x:i},backend:e});else{const g=e.data.get(i.dataId).values,_=Rt(i.shape),x=Mk(g,0,i.dtype,_,p,"avg");m=e.makeTensorInfo(p.outShape,i.dtype,x.values)}return m}},Vbe={kernelName:L_,backendName:"cpu",kernelFunc:function Bbe(n){const{inputs:t,backend:e,attrs:r}=n,{x:i}=t,{filterSize:o,strides:s,pad:a,dimRoundingMode:c,dataFormat:u}=r;Ct(i,"avgPool3d");const p=wl(i.shape,o,s,1,a,c,u),g=iU(e.data.get(i.dataId).values,0,i.dtype,Rt(i.shape),p,"avg");return e.makeTensorInfo(g.shape,"float32",g.values)}},Ube={kernelName:_C,backendName:"cpu",kernelFunc:function zbe(n){const{inputs:t,backend:e,attrs:r}=n,{dy:i,input:o}=t,{filterSize:s,strides:a,pad:c,dimRoundingMode:u}=r;Ct([i,o],"avgPool3DGrad");const p=wl(o.shape,s,a,1,c,u),m=p.strideDepth,g=p.strideHeight,_=p.strideWidth,x=p.filterDepth,T=p.filterHeight,I=p.filterWidth,N=p.dilationDepth,R=p.dilationHeight,L=p.dilationWidth,V=p.effectiveFilterDepth,j=p.effectiveFilterHeight,Y=p.effectiveFilterWidth,ee=V-1-p.padInfo.front,ie=Y-1-p.padInfo.left,ce=j-1-p.padInfo.top,he=sn(o.shape,"float32"),we=1/(x*T*I),Ee=e.bufferSync(i);for(let Ae=0;Ae<p.batchSize;++Ae)for(let Oe=0;Oe<p.inChannels;++Oe)for(let Re=0;Re<p.inDepth;++Re)for(let _e=0;_e<p.inHeight;++_e)for(let Te=0;Te<p.inWidth;++Te){const xe=Re-ee,De=_e-ce,je=Te-ie;let We=0;for(let Je=0;Je<V;Je+=N){const Ze=(xe+Je)/m;if(!(Ze<0||Ze>=p.outDepth||Math.floor(Ze)!==Ze))for(let et=0;et<j;et+=R){const rt=(De+et)/g;if(!(rt<0||rt>=p.outHeight||Math.floor(rt)!==rt))for(let bt=0;bt<Y;bt+=L){const pt=(je+bt)/_;pt<0||pt>=p.outWidth||Math.floor(pt)!==pt||(We+=Ee.get(Ae,Ze,rt,pt,Oe))}}}he.set(We*we,Ae,Re,_e,Te,Oe)}return e.makeTensorInfo(he.shape,he.dtype,he.values)}},Gbe={kernelName:yC,backendName:"cpu",kernelFunc:function jbe(n){const{inputs:t,backend:e,attrs:r}=n,{dy:i,input:o}=t,s=o;Ct([i,o],"avgPoolGrad");const{filterSize:a,strides:c,pad:u}=r,p=Rs(s.shape,a,c,1,u),m=p.strideHeight,g=p.strideWidth,_=p.filterHeight,x=p.filterWidth,T=p.dilationHeight,I=p.dilationWidth,N=p.effectiveFilterHeight,R=p.effectiveFilterWidth,L=R-1-p.padInfo.left,V=N-1-p.padInfo.top,j=sn(s.shape,"float32"),Y=1/(_*x),ee=e.data.get(i.dataId).values,ie=sn(i.shape,"float32",ee);for(let ce=0;ce<p.batchSize;++ce)for(let he=0;he<p.inChannels;++he)for(let we=0;we<p.inHeight;++we)for(let Ee=0;Ee<p.inWidth;++Ee){const Ae=we-V,Oe=Ee-L;let Re=0;for(let _e=0;_e<N;_e+=T){const Te=(Ae+_e)/m;if(!(Te<0||Te>=p.outHeight||Math.floor(Te)!==Te))for(let xe=0;xe<R;xe+=I){const De=(Oe+xe)/g;De<0||De>=p.outWidth||Math.floor(De)!==De||(Re+=ie.get(ce,Te,De,he))}}j.set(Re*Y,ce,we,Ee,he)}return e.makeTensorInfo(j.shape,j.dtype,j.values)}},Wbe={kernelName:Z_,backendName:"cpu",kernelFunc:function Hbe(n){const{inputs:t,backend:e,attrs:r}=n,{x:i,scale:o,offset:s,mean:a,variance:c}=t;Z(a.shape.length===c.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),Z(null==s||a.shape.length===s.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),Z(null==o||a.shape.length===o.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks."),Ct([i,a,c,o,s],"batchNorm");let{varianceEpsilon:u}=r;null==u&&(u=.001);const p=e.data.get(i.dataId).values,m=e.data.get(a.dataId).values,g=e.data.get(c.dataId).values,_=o?e.data.get(o.dataId).values:new Float32Array([1]),x=s?e.data.get(s.dataId).values:new Float32Array([0]),T=new Float32Array(p.length),I=x.length,N=_.length,R=g.length,L=m.length;let V=0,j=0,Y=0,ee=0;for(let ie=0;ie<p.length;++ie)T[ie]=x[V++]+(p[ie]-m[j++])*_[Y++]/Math.sqrt(g[ee++]+u),V>=I&&(V=0),j>=L&&(j=0),Y>=N&&(Y=0),ee>=R&&(ee=0);return e.makeTensorInfo(i.shape,i.dtype,T)}};function oU(n,t,e,r,i){const o=iE(r,t,e),s=Me(e),a=Rt(r);if(o){const m=oE(t,a);return"string"===i?n.slice(m,m+s):n.subarray(m,m+s)}const u=sn(r,i,"string"===i?Il(n):n),p=sn(e,i);for(let m=0;m<p.size;++m){const g=p.indexToLoc(m),_=g.map((x,T)=>x+t[T]);p.set(u.get(..._),...g)}return"string"===i?UV(p.values):p.values}function Ku(n){const{inputs:t,backend:e,attrs:r}=n,{x:i}=t,{begin:o,size:s}=r;Ct(i,"slice");const[a,c]=X0(i,o,s);nE(i,a,c);const p=oU(e.data.get(i.dataId).values,a,c,i.shape,i.dtype);return e.makeTensorInfo(c,i.dtype,p)}const qbe={kernelName:E0,backendName:"cpu",kernelFunc:Ku},Xbe={kernelName:V_,backendName:"cpu",kernelFunc:function Kbe(n){const{inputs:t,backend:e,attrs:r}=n,{x:i}=t,{blockShape:o,crops:s}=r;Ct([i],"batchToSpaceND");const a=o.reduce((N,R)=>N*R),c=vg(i.shape,o,a),u=xg(c.length,o.length),p=wg(i.shape,o,a),m=rD(s,o.length),g=iD(p,s,o.length),_=Yn({inputs:{x:i},backend:e,attrs:{shape:c}}),x=Eo({inputs:{x:_},backend:e,attrs:{perm:u}}),T=Yn({inputs:{x},backend:e,attrs:{shape:p}}),I=Ku({inputs:{x:T},backend:e,attrs:{begin:m,size:g}});return e.disposeIntermediateTensorInfo(_),e.disposeIntermediateTensorInfo(x),e.disposeIntermediateTensorInfo(T),I}};function Fk(n,t,e,r,i){const o=Me(r),s=Ui(i,e);for(let a=0;a<n.length;a++){const c=n[a];if(c<0)throw new Error("Input x must be non-negative!");c>=i||(s[c]+=o>0?t[a]:1)}return s}function sU(n,t,e,r=!1){const i=n.shape[0],o=n.shape[1],s=sn([i,e],t.dtype);for(let a=0;a<i;a++)for(let c=0;c<o;c++){const u=n.get(a,c);if(u<0)throw new Error("Input x must be non-negative!");u>=e||s.set(r?1:t.size>0?s.get(a,u)+t.get(a,c):s.get(a,u)+1,a,u)}return s}const Zbe={kernelName:vC,backendName:"cpu",kernelFunc:function Ybe(n){const{inputs:t,backend:e,attrs:r}=n,{x:i,weights:o}=t,{size:s}=r,u=Fk(e.data.get(i.dataId).values,e.data.get(o.dataId).values,o.dtype,o.shape,s);return e.makeTensorInfo([s],o.dtype,u)}},Qbe=Pr((n,t)=>n&t),Jbe=ai(xC,Qbe),eye={kernelName:xC,backendName:"cpu",kernelFunc:Jbe},nye={kernelName:wC,backendName:"cpu",kernelFunc:function tye(n){const{inputs:t,backend:e}=n,{s0:r,s1:i}=t,o=e.data.get(r.dataId).values,s=e.data.get(i.dataId).values,a=Yt(Array.from(o),Array.from(s));return e.makeTensorInfo([a.length],"int32",Int32Array.from(a))}},aU=qa(n=>Math.ceil(n)),rye=Fc(fm,aU),iye={kernelName:fm,backendName:"cpu",kernelFunc:rye},oye=$n(mm,(n,t)=>n>t.clipValueMax?t.clipValueMax:n<t.clipValueMin?t.clipValueMin:n),sye={kernelName:mm,backendName:"cpu",kernelFunc:oye},aye={kernelName:z_,backendName:"cpu",kernelFunc:n=>{const{x:t}=n.inputs,e=n.backend,r=new Float32Array(Me(t.shape)),i=e.data.get(t.dataId),s=i.complexTensorInfos.imag,a=e.data.get(i.complexTensorInfos.real.dataId).values,c=e.data.get(s.dataId).values;for(let u=0;u<a.length;u++)r[u]=Math.hypot(a[u],c[u]);return e.makeOutput(r,t.shape,"float32")}};function lU(n,t,e,r){const i=Or(e,Me(t));if(r&&"string"!==e){let o=0;n.forEach(s=>{const a=Me(s.shape);i.set(s.vals,o),o+=a})}else{let o=0;n.forEach(s=>{const a="string"===e?Il(s.vals):s.vals;let c=0;for(let u=0;u<s.shape[0];++u){const p=u*t[1]+o;for(let m=0;m<s.shape[1];++m)i[p+m]=a[c++]}o+=s.shape[1]})}return i}function Yh(n){const{inputs:t,backend:e}=n,{input:r}=t,i=e.data.get(r.dataId).complexTensorInfos.imag,o=e.data.get(i.dataId).values;return e.makeTensorInfo(i.shape,i.dtype,o)}const lye={kernelName:jC,backendName:"cpu",kernelFunc:Yh};function Zh(n){const{inputs:t,backend:e,attrs:r}=n,{axis:i}=r,o=cn(i,t[0].shape)[0];eD(t.map(T=>T.shape),o);let a=Va(t.map(T=>T.shape),o);if(0===Me(a))return e.makeTensorInfo(a,t[0].dtype,[]);const c=t.filter(T=>Me(T.shape)>0);if(1===c.length)return Ka({inputs:{x:c[0]},backend:e});if("complex64"===c[0].dtype){const T=c.map(V=>qu({inputs:{input:V},backend:e})),I=c.map(V=>Yh({inputs:{input:V},backend:e})),N=Zh({inputs:T,backend:e,attrs:{axis:o}}),R=Zh({inputs:I,backend:e,attrs:{axis:o}}),L=Wo({inputs:{real:N,imag:R},backend:e});return T.forEach(V=>e.disposeIntermediateTensorInfo(V)),I.forEach(V=>e.disposeIntermediateTensorInfo(V)),e.disposeIntermediateTensorInfo(N),e.disposeIntermediateTensorInfo(R),L}const u=c.map(T=>{const N=[-1,Me(T.shape.slice(o))];return Yn({inputs:{x:T},backend:e,attrs:{shape:N}})}),p=u.map(T=>({vals:e.data.get(T.dataId).values,shape:T.shape}));a=Va(u.map(T=>T.shape),1);const g=lU(p,a,t[0].dtype,1===u[0].shape[0]),_=Va(c.map(T=>T.shape),o),x=e.makeTensorInfo(_,t[0].dtype,g);return u.forEach(T=>e.disposeIntermediateTensorInfo(T)),x}const cye={kernelName:U_,backendName:"cpu",kernelFunc:Zh};function cU(n){const{inputs:t,backend:e,attrs:r}=n,{x:i,filter:o}=t,{strides:s,pad:a,dataFormat:c,dilations:u,dimRoundingMode:p}=r;Ct([i,o],"conv2d");const m=Tl(c),g=mi(i.shape,o.shape,s,u,a,p,!1,m),_=g.filterHeight,x=g.filterWidth,T=g.dilationHeight,I=g.dilationWidth,N=g.padInfo.left,R=g.padInfo.top,L="channelsLast"===g.dataFormat,V=new Jr(g.outShape,i.dtype),j=Rt(i.shape),Y=Rt(o.shape),ee=j[0],ie=L?j[1]:j[2],ce=L?j[2]:1,he=L?1:j[1],we=V.strides[0],Ee=L?V.strides[1]:V.strides[2],Ae=L?V.strides[2]:1,Oe=L?1:V.strides[1],Re=e.data.get(i.dataId).values,_e=e.data.get(o.dataId).values,Te=V.values;for(let xe=0;xe<g.batchSize;++xe){const De=xe*ee,je=xe*we;for(let We=0;We<g.outHeight;++We){const Je=je+We*Ee,Ze=We*g.strideHeight-R;for(let et=0;et<_;++et){const rt=Ze+et*T;if(rt<0||rt>=g.inHeight)continue;const bt=et*Y[0],pt=De+rt*ie;for(let Ot=0;Ot<g.outWidth;++Ot){const Tt=Je+Ot*Ae,Wt=Ot*g.strideWidth-N;for(let Zt=0;Zt<x;++Zt){const Ln=Wt+Zt*I;if(Ln<0||Ln>=g.inWidth)continue;const Cr=pt+Ln*ce;let Qn=bt+Zt*Y[1];for(let Gn=0;Gn<g.inChannels;++Gn){const br=Re[Cr+Gn*he];for(let cr=0;cr<g.outChannels;++cr)Te[Tt+cr*Oe]+=br*_e[Qn+cr];Qn+=g.outChannels}}}}}}return e.makeTensorInfo(V.shape,V.dtype,Te)}const uye={kernelName:j_,backendName:"cpu",kernelFunc:cU},hye={kernelName:SC,backendName:"cpu",kernelFunc:function dye(n){const{inputs:t,backend:e,attrs:r}=n,{x:i,dy:o}=t,{strides:s,pad:a,dataFormat:c,dimRoundingMode:u,filterShape:p}=r;Ct([i,o],"conv2dBackpropFilter");const m=Tl(c),g=mi(i.shape,p,s,1,a,u,!1,m),{strideHeight:_,strideWidth:x,filterHeight:T,filterWidth:I}=g,N="channelsLast"===g.dataFormat,R=new Jr(g.filterShape,"float32"),L=g.padInfo.left,V=g.padInfo.top,j=e.data.get(i.dataId).values,Y=e.data.get(o.dataId).values,ee=new Jr(i.shape,i.dtype,j),ie=new Jr(o.shape,o.dtype,Y);for(let ce=0;ce<T;++ce){const he=Math.max(0,Math.ceil((V-ce)/_)),we=Math.min(g.outHeight,(g.inHeight+V-ce)/_);for(let Ee=0;Ee<I;++Ee){const Ae=Math.max(0,Math.ceil((L-Ee)/x)),Oe=Math.min(g.outWidth,(g.inWidth+L-Ee)/x);for(let Re=0;Re<g.inChannels;++Re)for(let _e=0;_e<g.outChannels;++_e){let Te=0;for(let xe=0;xe<g.batchSize;++xe)for(let De=he;De<we;++De){const je=ce+De*_-V;for(let We=Ae;We<Oe;++We){const Je=Ee+We*x-L;Te+=N?ee.get(xe,je,Je,Re)*ie.get(xe,De,We,_e):ee.get(xe,Re,je,Je)*ie.get(xe,_e,De,We)}}R.set(Te,ce,Ee,Re,_e)}}}return e.makeTensorInfo(R.shape,R.dtype,R.values)}},fye={kernelName:G_,backendName:"cpu",kernelFunc:function pye(n){const{inputs:t,backend:e,attrs:r}=n,{dy:i,filter:o}=t,{inputShape:s,strides:a,pad:c,dataFormat:u,dimRoundingMode:p}=r;Ct([i,o],"conv2dBackpropInput");const m=Rt(o.shape),g=Rt(i.shape);let _=Tl(u);const x=mi(s,o.shape,a,1,c,p,!1,_),T=new Jr(x.inShape,"float32"),I=T.values,N=e.data.get(i.dataId).values,R=e.data.get(o.dataId).values,[L,V,j]=m,{batchSize:Y,filterHeight:ee,filterWidth:ie,inChannels:ce,inHeight:he,inWidth:we,outChannels:Ee,outHeight:Ae,outWidth:Oe,strideHeight:Re,strideWidth:_e}=x;_=x.dataFormat;const Te=ee-1-x.padInfo.top,xe=ie-1-x.padInfo.left,De="channelsLast"===_,je=T.strides[0],We=De?T.strides[1]:T.strides[2],Je=De?T.strides[2]:1,Ze=De?1:T.strides[1],et=g[0],rt=De?g[1]:g[2],bt=De?g[2]:1,pt=De?1:g[1];for(let Ot=0;Ot<Y;++Ot)for(let Tt=0;Tt<ce;++Tt)for(let Wt=0;Wt<he;++Wt){const Zt=Wt-Te,Ln=Math.max(0,Math.ceil(Zt/Re)),Zn=Math.min(Ae,(ee+Zt)/Re);for(let Cr=0;Cr<we;++Cr){const Qn=Cr-xe,Gn=Math.max(0,Math.ceil(Qn/_e)),br=Math.min(Oe,(ie+Qn)/_e);let cr=0;for(let Oi=Ln;Oi<Zn;++Oi){const Kc=Oi*Re-Zt;for(let xs=Gn;xs<br;++xs){const ga=et*Ot+rt*Oi+bt*xs,Ll=L*(ee-1-Kc)+V*(ie-1-(xs*_e-Qn))+j*Tt;for(let Xc=0;Xc<Ee;++Xc)cr+=N[ga+pt*Xc]*R[Ll+Xc]}}I[je*Ot+We*Wt+Je*Cr+Ze*Tt]=cr}}return e.makeTensorInfo(T.shape,T.dtype,T.values)}},gye={kernelName:H_,backendName:"cpu",kernelFunc:function mye(n){const{inputs:t,backend:e,attrs:r}=n,{x:i,filter:o}=t,{strides:s,pad:a,dilations:c}=r;Ct([i,o],"conv3d");const u=xc(i.shape,o.shape,s,c,a),{filterDepth:p,filterHeight:m,filterWidth:g,dilationDepth:_,dilationHeight:x,dilationWidth:T,padInfo:I}=u,N=I.front,R=I.left,L=I.top,V=new Jr(u.outShape,i.dtype),j=e.data.get(i.dataId).values,Y=e.data.get(o.dataId).values,ee=V.values,ie=Rt(i.shape),ce=Rt(o.shape);for(let he=0;he<u.batchSize;++he){const we=he*ie[0],Ee=he*V.strides[0];for(let Ae=0;Ae<u.outDepth;++Ae){const Oe=Ee+Ae*V.strides[1],Re=Ae*u.strideDepth-N;for(let _e=0;_e<p;++_e){const Te=Re+_e*_;if(Te<0||Te>=u.inDepth)continue;const xe=_e*ce[0],De=we+Te*ie[1];for(let je=0;je<u.outHeight;++je){const We=Oe+je*V.strides[2],Je=je*u.strideHeight-L;for(let Ze=0;Ze<m;++Ze){const et=Je+Ze*x;if(et<0||et>=u.inHeight)continue;const rt=xe+Ze*ce[1],bt=De+et*ie[2];for(let pt=0;pt<u.outWidth;++pt){const Ot=We+pt*u.outChannels,Tt=pt*u.strideWidth-R;for(let Wt=0;Wt<g;++Wt){const Zt=Tt+Wt*T;if(Zt<0||Zt>=u.inWidth)continue;const Zn=bt+Zt*u.inChannels;let Cr=rt+Wt*ce[2];for(let Qn=0;Qn<u.inChannels;++Qn){const Gn=j[Zn+Qn];for(let br=0;br<u.outChannels;++br)ee[Ot+br]+=Gn*Y[Cr+br];Cr+=u.outChannels}}}}}}}}return e.makeTensorInfo(V.shape,V.dtype,V.values)}},yye={kernelName:CC,backendName:"cpu",kernelFunc:function bye(n){const{inputs:t,backend:e,attrs:r}=n,{x:i,dy:o}=t,{strides:s,pad:a,filterShape:c}=r;Ct([i,o],"conv3dBackpropFilterV2");const u=Rt(i.shape),p=Rt(o.shape),m=xc(i.shape,c,s,1,a),g=m.strideDepth,_=m.strideHeight,x=m.strideWidth,T=m.filterDepth,I=m.filterHeight,N=m.filterWidth,R=new Jr(m.filterShape,"float32"),L=R.values,[V,j,Y,ee]=R.strides,ie=e.data.get(o.dataId).values,[ce,he,we,Ee]=p,Ae=e.data.get(i.dataId).values,[Oe,Re,_e,Te]=u,xe=m.padInfo.front,De=m.padInfo.left,je=m.padInfo.top;for(let We=0;We<T;++We){const Je=Math.max(0,Math.ceil((xe-We)/g)),Ze=Math.min(m.outDepth,(m.inDepth+xe-We)/g),et=We*V;for(let rt=0;rt<I;++rt){const bt=Math.max(0,Math.ceil((je-rt)/_)),pt=Math.min(m.outHeight,(m.inHeight+je-rt)/_),Ot=rt*j+et;for(let Tt=0;Tt<N;++Tt){const Wt=Math.max(0,Math.ceil((De-Tt)/x)),Zt=Math.min(m.outWidth,(m.inWidth+De-Tt)/x),Ln=Tt*Y+Ot;for(let Zn=0;Zn<m.inChannels;++Zn){const Cr=Zn*ee+Ln;for(let Qn=0;Qn<m.outChannels;++Qn){let Gn=0;for(let br=0;br<m.batchSize;++br){const cr=br*Oe,$l=br*ce;for(let Oi=Je;Oi<Ze;++Oi){const xs=(We+Oi*g-xe)*Re+cr,cd=Oi*he+$l;for(let ga=bt;ga<pt;++ga){const Xc=(rt+ga*_-je)*_e+xs,Yc=ga*we+cd;for(let Zc=Wt;Zc<Zt;++Zc)Gn+=Ae[(Tt+Zc*x-De)*Te+Xc+Zn]*ie[Zc*Ee+Yc+Qn]}}}L[Cr+Qn]=Gn}}}}}return e.makeTensorInfo(R.shape,R.dtype,R.values)}},vye={kernelName:IC,backendName:"cpu",kernelFunc:function _ye(n){const{inputs:t,backend:e,attrs:r}=n,{dy:i,filter:o}=t,{pad:s,strides:a,inputShape:c}=r;Ct([i],"conv3dBackpropInputV2");const u=Rt(i.shape),p=Rt(o.shape),m=xc(c,o.shape,a,1,s),g=new Jr(m.inShape,"float32"),_=g.values,[x,T,I,N]=g.strides,R=e.data.get(i.dataId).values,[L,V,j,Y]=u,ee=e.data.get(o.dataId).values,[ie,ce,he,we]=p,{batchSize:Ee,filterDepth:Ae,filterHeight:Oe,filterWidth:Re,inChannels:_e,inDepth:Te,inHeight:xe,inWidth:De,outChannels:je,outDepth:We,outHeight:Je,outWidth:Ze,strideDepth:et,strideHeight:rt,strideWidth:bt}=m,pt=Ae-1-m.padInfo.front,Ot=Oe-1-m.padInfo.top,Tt=Re-1-m.padInfo.left;for(let Wt=0;Wt<Ee;++Wt)for(let Zt=0;Zt<_e;++Zt)for(let Ln=0;Ln<Te;++Ln){const Zn=Ln-pt,Cr=Math.max(0,Math.ceil(Zn/et)),Qn=Math.min(We,(Ae+Zn)/et);for(let Gn=0;Gn<xe;++Gn){const br=Gn-Ot,cr=Math.max(0,Math.ceil(br/rt)),$l=Math.min(Je,(Oe+br)/rt);for(let Oi=0;Oi<De;++Oi){const Kc=Oi-Tt,xs=Math.max(0,Math.ceil(Kc/bt)),cd=Math.min(Ze,(Re+Kc)/bt);let ga=0;for(let Ll=Cr;Ll<Qn;++Ll){const Xc=Ll*et-Zn;for(let Yc=cr;Yc<$l;++Yc){const Zc=Yc*rt-br;for(let bb=xs;bb<cd;++bb){const S2=L*Wt+V*Ll+j*Yc+Y*bb,yLe=ie*(Ae-1-Xc)+ce*(Oe-1-Zc)+he*(Re-1-(bb*bt-Kc))+we*Zt;for(let hw=0;hw<je;++hw)ga+=R[S2+hw]*ee[yLe+hw]}}}_[x*Wt+T*Ln+I*Gn+N*Oi+Zt]=ga}}}return e.makeTensorInfo(g.shape,g.dtype,g.values)}},xye=$n(gm,n=>Math.cos(n)),wye={kernelName:gm,backendName:"cpu",kernelFunc:xye},Tye=$n(bm,n=>Math.cosh(n)),Sye={kernelName:bm,backendName:"cpu",kernelFunc:Tye},Iye={kernelName:DC,backendName:"cpu",kernelFunc:function Cye(n){const{inputs:t,backend:e,attrs:r}=n,{image:i,boxes:o,boxInd:s}=t,{cropSize:a,method:c,extrapolationValue:u}=r,[p,m,g,_]=i.shape,x=o.shape[0],[T,I]=a,N=sn([x,T,I,_],"float32"),R=e.data.get(o.dataId).values,L=e.data.get(s.dataId).values,V=e.data.get(i.dataId).values,j=Rt(i.shape),Y=Rt(N.shape);for(let ee=0;ee<x;ee++){const ie=4*ee,ce=R[ie],he=R[ie+1],we=R[ie+2],Ee=R[ie+3],Ae=L[ee];if(Ae>=p)continue;const Oe=T>1?(we-ce)*(m-1)/(T-1):0,Re=I>1?(Ee-he)*(g-1)/(I-1):0;for(let _e=0;_e<T;_e++){const Te=T>1?ce*(m-1)+_e*Oe:.5*(ce+we)*(m-1);if(Te<0||Te>m-1)for(let xe=0;xe<I;xe++)for(let De=0;De<_;De++)N.values[De+xe*Y[2]+_e*Y[1]+ee*Y[0]]=u;else if("bilinear"===c){const xe=Math.floor(Te),De=Math.ceil(Te),je=Te-xe;for(let We=0;We<I;We++){const Je=I>1?he*(g-1)+We*Re:.5*(he+Ee)*(g-1);if(Je<0||Je>g-1){for(let bt=0;bt<_;bt++)N.values[bt+We*Y[2]+_e*Y[1]+ee*Y[0]]=u;continue}const Ze=Math.floor(Je),et=Math.ceil(Je),rt=Je-Ze;for(let bt=0;bt<_;bt++){let pt=bt+Ze*j[2]+xe*j[1]+Ae*j[0];const Ot=V[pt];pt=bt+et*j[2]+xe*j[1]+Ae*j[0];const Tt=V[pt];pt=bt+Ze*j[2]+De*j[1]+Ae*j[0];const Wt=V[pt];pt=bt+et*j[2]+De*j[1]+Ae*j[0];const Zt=V[pt],Ln=Ot+(Tt-Ot)*rt;pt=bt+We*Y[2]+_e*Y[1]+ee*Y[0],N.values[pt]=Ln+(Wt+(Zt-Wt)*rt-Ln)*je}}}else for(let xe=0;xe<I;++xe){const De=I>1?he*(g-1)+xe*Re:.5*(he+Ee)*(g-1);if(De<0||De>g-1){for(let Je=0;Je<_;Je++)N.values[Je+xe*Y[2]+_e*Y[1]+ee*Y[0]]=u;continue}const je=Math.round(De),We=Math.round(Te);for(let Je=0;Je<_;Je++)N.values[Je+xe*Y[2]+_e*Y[1]+ee*Y[0]]=V[Je+je*j[2]+We*j[1]+Ae*j[0]]}}}return e.makeTensorInfo(N.shape,N.dtype,N.values)}},Dye={kernelName:EC,backendName:"cpu",kernelFunc:function Eye(n){const{inputs:t,backend:e,attrs:r}=n,{x:i}=t,{axis:o,exclusive:s,reverse:a}=r;Ct(i,"cumprod");const c=hr([o],i.shape.length);let u=i;null!=c&&(u=Eo({inputs:{x:i},backend:e,attrs:{perm:c}}));const p=Mr(1,i.shape.length)[0];if(p!==u.shape.length-1)throw new Error(`backend.cumprod in CPU expects an inner-most axis=${u.shape.length-1} but got axis=${p}`);const m=zo(u.dtype,"int32"),g=pC(Me(u.shape),m),_=e.data.get(u.dataId).values,x=u.shape[u.shape.length-1],T=a?(N,R)=>N+x-R-1:(N,R)=>N+R;for(let N=0;N<_.length;N+=x)for(let R=0;R<x;R++){const L=T(N,R);if(0===R)g[L]=s?1:_[L];else{const V=T(N,R-1);g[L]=s?_[V]*g[V]:_[L]*g[V]}}const I=e.makeTensorInfo(u.shape,m,g);if(null!=c){const R=Eo({inputs:{x:I},backend:e,attrs:{perm:Sc(c)}});return e.disposeIntermediateTensorInfo(I),e.disposeIntermediateTensorInfo(u),R}return I}},Aye={kernelName:W_,backendName:"cpu",kernelFunc:function kye(n){const{inputs:t,backend:e,attrs:r}=n,{x:i}=t,{axis:o,exclusive:s,reverse:a}=r;Ct(i,"cumsum");const c=hr([o],i.shape.length);let u=i;null!=c&&(u=Eo({inputs:{x:i},backend:e,attrs:{perm:c}}));const p=Mr(1,i.shape.length)[0];if(p!==u.shape.length-1)throw new Error(`backend.cumsum in CPU expects an inner-most axis=${u.shape.length-1} but got axis=${p}`);const m=zo(u.dtype,"int32"),g=Ui(Me(u.shape),m),_=e.data.get(u.dataId).values,x=u.shape[u.shape.length-1],T=a?(N,R)=>N+x-R-1:(N,R)=>N+R;for(let N=0;N<_.length;N+=x)for(let R=0;R<x;R++){const L=T(N,R);if(0===R)g[L]=s?0:_[L];else{const V=T(N,R-1);g[L]=s?_[V]+g[V]:_[L]+g[V]}}const I=e.makeTensorInfo(u.shape,m,g);if(null!=c){const R=Eo({inputs:{x:I},backend:e,attrs:{perm:Sc(c)}});return e.disposeIntermediateTensorInfo(I),e.disposeIntermediateTensorInfo(u),R}return I}},Oye={kernelName:kC,backendName:"cpu",kernelFunc:function Nye(n){const{inputs:t,backend:e,attrs:r}=n,{x:i,weights:o}=t,{size:s,binaryOutput:a}=r;if(1===i.shape.length){const p=Fk(e.data.get(i.dataId).values,e.data.get(o.dataId).values,o.dtype,o.shape,s);return e.makeTensorInfo([s],o.dtype,p)}if(2===i.shape.length){const p=sU(e.bufferSync(i),e.bufferSync(o),s,a);return e.makeTensorInfo(p.shape,o.dtype,p.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${i.shape.length}.`)}},Mye={kernelName:AC,backendName:"cpu",kernelFunc:function Rye(n){const{inputs:t,backend:e,attrs:r}=n,{x:i}=t,{blockSize:o,dataFormat:s}=r;Z("NHWC"===s,()=>`Only NHWC dataFormat supported on CPU for depthToSpace. Got ${s}`);const a=i.shape[0],c=i.shape[1],u=i.shape[2],p=i.shape[3],m=c*o,g=u*o,_=p/(o*o),x=e.data.get(i.dataId).values,T=new Float32Array(a*m*g*_);let I=0;for(let N=0;N<a;++N)for(let R=0;R<m;++R){const L=Math.floor(R/o),V=R%o;for(let j=0;j<g;++j){const Y=Math.floor(j/o),ie=(V*o+j%o)*_;for(let ce=0;ce<_;++ce)T[I++]=x[ce+ie+p*(Y+u*(L+c*N))]}}return e.makeTensorInfo([a,m,g,_],i.dtype,T)}};function uU(n){const{inputs:t,backend:e,attrs:r}=n,{x:i,filter:o}=t,{strides:s,pad:a,dilations:c,dimRoundingMode:u}=r;Ct([i,o],"depthwiseConv2DNative");const p=Rt(i.shape),m=Rt(o.shape);let g=c;null==g&&(g=[1,1]),Z(Di(s,g),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${s} and dilations '${g}'`);const _=mi(i.shape,o.shape,s,g,a,u,!0),{filterHeight:x,filterWidth:T,dilationHeight:I,dilationWidth:N,padInfo:R}=_,L=R.left,V=R.top,j=_.outChannels/_.inChannels,Y=new Jr(_.outShape,i.dtype),ee=e.data.get(i.dataId).values,ie=e.data.get(o.dataId).values,ce=Y.values;for(let he=0;he<_.batchSize;++he){const we=he*p[0],Ee=he*Y.strides[0];for(let Ae=0;Ae<_.outHeight;++Ae){const Oe=Ee+Ae*Y.strides[1],Re=Ae*_.strideHeight-V;for(let _e=0;_e<x;++_e){const Te=Re+_e*I;if(Te<0||Te>=_.inHeight)continue;const xe=_e*m[0],De=we+Te*p[1];for(let je=0;je<_.outWidth;++je){const We=Oe+je*Y.strides[2],Je=je*_.strideWidth-L;for(let Ze=0;Ze<T;++Ze){const et=Je+Ze*N;if(et<0||et>=_.inWidth)continue;const bt=De+et*_.inChannels;let pt=We,Ot=xe+Ze*m[1];for(let Tt=0;Tt<_.inChannels;++Tt){const Wt=ee[bt+Tt];for(let Zt=0;Zt<j;++Zt)ce[pt+Zt]+=Wt*ie[Ot+Zt];pt+=j,Ot+=j}}}}}}return e.makeTensorInfo(Y.shape,Y.dtype,Y.values)}const Fye={kernelName:q_,backendName:"cpu",kernelFunc:uU},$ye={kernelName:NC,backendName:"cpu",kernelFunc:function Pye(n){const{inputs:t,backend:e,attrs:r}=n,{x:i,dy:o}=t,{strides:s,dilations:a,pad:c,dimRoundingMode:u,filterShape:p}=r;Ct([i,o],"depthwiseConv2dNativeBackpropFilter");const m=mi(i.shape,p,s,a,c,u,!0),{strideHeight:g,strideWidth:_,filterHeight:x,filterWidth:T}=m,I=new Jr(m.filterShape,"float32"),N=m.padInfo.left,R=m.padInfo.top,L=m.outChannels/m.inChannels,V=e.data.get(i.dataId).values,j=new Jr(i.shape,i.dtype,V),Y=e.data.get(o.dataId).values,ee=new Jr(o.shape,o.dtype,Y);for(let ie=0;ie<x;++ie){const ce=Math.max(0,Math.ceil((R-ie)/g)),he=Math.min(m.outHeight,(m.inHeight+R-ie)/g);for(let we=0;we<T;++we){const Ee=Math.max(0,Math.ceil((N-we)/_)),Ae=Math.min(m.outWidth,(m.inWidth+N-we)/_);for(let Oe=0;Oe<m.outChannels;++Oe){const Re=Math.trunc(Oe/L),_e=Oe%L;let Te=0;for(let xe=0;xe<m.batchSize;++xe)for(let De=ce;De<he;++De){const je=ie+De*g-R;for(let We=Ee;We<Ae;++We)Te+=j.get(xe,je,we+We*_-N,Re)*ee.get(xe,De,We,Oe)}I.set(Te,ie,we,Re,_e)}}}return e.makeTensorInfo(I.shape,I.dtype,I.values)}},Bye={kernelName:OC,backendName:"cpu",kernelFunc:function Lye(n){const{inputs:t,backend:e,attrs:r}=n,{dy:i,filter:o}=t,{strides:s,dilations:a,pad:c,dimRoundingMode:u,inputShape:p}=r;Ct([i,o],"depthwiseConv2DNativeBackpropInput");const m=Rt(i.shape),g=Rt(o.shape),_=mi(p,o.shape,s,a,c,u,!0),x=new Jr(_.inShape,"float32"),T=x.values,[I,N,R]=x.strides,L=e.data.get(i.dataId).values,[V,j,Y]=m,ee=e.data.get(o.dataId).values,[ie,ce,he]=g,{batchSize:we,filterHeight:Ee,filterWidth:Ae,inChannels:Oe,inHeight:Re,inWidth:_e,outChannels:Te,outHeight:xe,outWidth:De,strideHeight:je,strideWidth:We}=_,Je=Ee-1-_.padInfo.top,Ze=Ae-1-_.padInfo.left,et=Te/Oe;for(let rt=0;rt<we;++rt)for(let bt=0;bt<Oe;++bt)for(let pt=0;pt<Re;++pt){const Ot=pt-Je,Tt=Math.max(0,Math.ceil(Ot/je)),Wt=Math.min(xe,(Ee+Ot)/je);for(let Zt=0;Zt<_e;++Zt){const Ln=Zt-Ze,Zn=Math.max(0,Math.ceil(Ln/We)),Cr=Math.min(De,(Ae+Ln)/We);let Qn=0;for(let Gn=Tt;Gn<Wt;++Gn){const br=Gn*je-Ot;for(let cr=Zn;cr<Cr;++cr){const Oi=V*rt+j*Gn+Y*cr,Kc=ie*(Ee-1-br)+ce*(Ae-1-(cr*We-Ln))+he*bt;for(let xs=0;xs<et;++xs)Qn+=L[Oi+(bt*et+xs)]*ee[Kc+xs]}}T[I*rt+N*pt+R*Zt+bt]=Qn}}return e.makeTensorInfo(x.shape,x.dtype,x.values)}},zye={kernelName:RC,backendName:"cpu",kernelFunc:function Vye(n){const{inputs:t,backend:e}=n,{x:r}=t,i=Me(r.shape),o=e.data.get(r.dataId).values,s=sn([i,i],r.dtype),a=s.values;for(let u=0;u<o.length;u++)a[u*i+u]=o[u];const c=[...r.shape,...r.shape];return e.makeTensorInfo(c,s.dtype,s.values)}},Uye={kernelName:K_,backendName:"cpu",kernelFunc:({inputs:n,backend:t,attrs:e})=>{const{x:r,filter:i}=n,{strides:o,pad:s,dilations:a}=e,c=t,u=c.data.get(r.dataId).values,p=r.shape.length,m=c.data.get(i.dataId).values,g=i.shape.length,{batchSize:_,inHeight:x,inWidth:T,inChannels:I,outHeight:N,outWidth:R,padInfo:L,strideHeight:V,strideWidth:j,filterHeight:Y,filterWidth:ee,dilationHeight:ie,dilationWidth:ce,outShape:he}=sg(r.shape,i.shape,o,s,"NHWC",a),we=Me(he),Ee=he.length,Ae=Or(r.dtype,we);for(let Re=0;Re<_;++Re)for(let _e=0;_e<N;++_e){const Te=_e*V-L.top;for(let xe=0;xe<R;++xe){const De=xe*j-L.left;for(let je=0;je<I;++je){let We=Number.MIN_SAFE_INTEGER;for(let Ze=0;Ze<Y;++Ze){const et=Te+Ze*ie;if(et>=0&&et<x)for(let rt=0;rt<ee;++rt){const bt=De+rt*ce;if(bt>=0&&bt<T){const pt=Ra([Re,et,bt,je],p,Rt(r.shape)),Ot=Ra([Ze,rt,je],g,Rt(i.shape)),Tt=u[pt]+m[Ot];Tt>We&&(We=Tt)}}}Ae[Ra([Re,_e,xe,je],Ee,Rt(he))]=We}}}return{dataId:c.write(ku(Ae,r.dtype),he,r.dtype),shape:he,dtype:r.dtype}}},jye={kernelName:FC,backendName:"cpu",kernelFunc:({inputs:n,backend:t,attrs:e})=>{const{x:r,filter:i,dy:o}=n,{strides:s,pad:a,dilations:c}=e,u=t,p=As(r.shape,u.data.get(r.dataId).values),m=As(i.shape,u.data.get(i.dataId).values),{batchSize:g,inHeight:_,inWidth:x,inChannels:T,outHeight:I,outWidth:N,padInfo:R,strideHeight:L,strideWidth:V,filterHeight:j,filterWidth:Y,dilationHeight:ee,dilationWidth:ie,outShape:ce}=sg(r.shape,i.shape,s,a,"NHWC",c);Z(o.rank===ce.length,()=>`Error in ${FC}, dy must have the same rank as output ${ce.length}, but got ${o.rank}`);const he=As(ce,u.data.get(o.dataId).values),we=ZL(i.shape,i.dtype);for(let Ae=0;Ae<g;++Ae)for(let Oe=0;Oe<I;++Oe){const Re=Oe*L-R.top;for(let _e=0;_e<N;++_e){const Te=_e*V-R.left;for(let xe=0;xe<T;++xe){let De=Number.MIN_SAFE_INTEGER,je=0,We=0;for(let Je=0;Je<j;++Je){const Ze=Re+Je*ee;if(Ze>=0&&Ze<_)for(let et=0;et<Y;++et){const rt=Te+et*ie;if(rt>=0&&rt<x){const bt=p[Ae][Ze][rt][xe]+m[Je][et][xe];bt>De&&(De=bt,je=Je,We=et)}}}we[je][We][xe]+=he[Ae][Oe][_e][xe]}}}return{dataId:u.write(ku(we,r.dtype),i.shape,i.dtype),shape:i.shape,dtype:i.dtype}}},Gye={kernelName:MC,backendName:"cpu",kernelFunc:({inputs:n,backend:t,attrs:e})=>{const{x:r,filter:i,dy:o}=n,{strides:s,pad:a,dilations:c}=e,u=t,p=As(r.shape,u.data.get(r.dataId).values),m=As(i.shape,u.data.get(i.dataId).values),{batchSize:g,inHeight:_,inWidth:x,inChannels:T,outHeight:I,outWidth:N,padInfo:R,strideHeight:L,strideWidth:V,filterHeight:j,filterWidth:Y,dilationHeight:ee,dilationWidth:ie,outShape:ce}=sg(r.shape,i.shape,s,a,"NHWC",c);Z(o.rank===ce.length,()=>`Error in ${MC}, dy must have the same rank as output ${ce.length}, but got ${o.rank}`);const he=As(ce,u.data.get(o.dataId).values),we=ZL(r.shape,r.dtype);for(let Ae=0;Ae<g;++Ae)for(let Oe=0;Oe<I;++Oe){const Re=Oe*L-R.top;for(let _e=0;_e<N;++_e){const Te=_e*V-R.left;for(let xe=0;xe<T;++xe){let De=Number.MIN_SAFE_INTEGER,je=Re<0?0:Re,We=Te<0?0:Te;for(let Je=0;Je<j;++Je){const Ze=Re+Je*ee;if(Ze>=0&&Ze<_)for(let et=0;et<Y;++et){const rt=Te+et*ie;if(rt>=0&&rt<x){const bt=p[Ae][Ze][rt][xe]+m[Je][et][xe];bt>De&&(De=bt,je=Ze,We=rt)}}}we[Ae][je][We][xe]+=he[Ae][Oe][_e][xe]}}}return{dataId:u.write(ku(we,r.dtype),r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}},Pk=Pr((n,t)=>n*t),Hye=Ok((n,t,e,r)=>({real:n*e-t*r,imag:n*r+t*e})),nx=ai(Fm,Pk,Hye),Wye={kernelName:Fm,backendName:"cpu",kernelFunc:nx};function Lg(n){const{inputs:t,backend:e,attrs:r}=n,{x:i}=t,{axis:o,keepDims:s}=r;let a;Ct(i,"sum"),a="bool"===i.dtype?Pc({inputs:{x:i},backend:e,attrs:{dtype:"int32"}}):Ka({inputs:{x:i},backend:e});const c=a.shape.length,u=cn(o,a.shape),p=hr(u,c);let m=u,g=a;null!=p&&(g=Eo({inputs:{x:a},backend:e,attrs:{perm:p}}),m=Mr(m.length,c)),ki("sum",m,g.shape.length);const[_,x]=gi(g.shape,m);let I=tx(e,_,zo(g.dtype,"int32"));const N=Me(x),R=e.data.get(I.dataId).values,L=e.data.get(g.dataId).values;for(let V=0;V<R.length;++V){const j=V*N;let Y=0;for(let ee=0;ee<N;++ee)Y+=L[j+ee];R[V]=Y}if(s){const j=I;I=Yn({inputs:{x:I},backend:e,attrs:{shape:Rr(I.shape,u)}}),e.disposeIntermediateTensorInfo(j)}return e.disposeIntermediateTensorInfo(a),null!=p&&e.disposeIntermediateTensorInfo(g),I}const qye={kernelName:D0,backendName:"cpu",kernelFunc:Lg},Xye={kernelName:PC,backendName:"cpu",kernelFunc:function Kye(n){const{inputs:t,backend:e,attrs:r}=n,{equation:i}=r,o=t,{allDims:s,summedDims:a,idDims:c}=fD(i,o.length);gD(s.length,c,o);const{path:u,steps:p}=bD(a,c),m=p.length;let g=null,_=s.length;const x=[];for(let T=0;T<m;++T){for(const I of p[T]){const{permutationIndices:N,expandDims:R}=mD(_,c[I]);let L;yD(N)?L=o[I]:(L=Eo({inputs:{x:o[I]},backend:e,attrs:{perm:N}}),x.push(L));const V=L.shape.slice();for(let j=0;j<R.length;++j)V.splice(R[j],0,1);mn(L.shape,V)||(L=Yn({inputs:{x:L},backend:e,attrs:{shape:V}}),x.push(L)),null===g?g=L:(g=nx({inputs:{a:L,b:g},backend:e}),x.push(g))}T<m-1&&(u[T]>=0&&(g=Lg({inputs:{x:g},backend:e,attrs:{axis:u[T]-(s.length-_),keepDims:!1}}),x.push(g)),_--)}for(const T of x)T!==g&&e.disposeIntermediateTensorInfo(T);return g}},Zye={kernelName:$C,backendName:"cpu",kernelFunc:function Yye(n){const{inputs:t,backend:e}=n,{dy:r,y:i}=t;Ct([r,i],"eluGrad");const o=new Float32Array(Me(i.shape)),s=e.data.get(i.dataId).values,a=e.data.get(r.dataId).values;for(let c=0;c<s.length;++c){const u=s[c];o[c]=u>=0?a[c]:a[c]*(u+1)}return e.makeTensorInfo(i.shape,"float32",o)}},dU=Pr((n,t)=>n===t?1:0),hU=ai(X_,dU,null,"bool"),Qye={kernelName:X_,backendName:"cpu",kernelFunc:hU},Jye=sD,e_e=aD,t_e=lD,n_e=cD,r_e=uD,i_e=dD,o_e=$n(vm,n=>{const t=Math.sign(n),e=Math.abs(n),r=1/(1+Jye*e);return t*(1-((((i_e*r+r_e)*r+n_e)*r+t_e)*r+e_e)*r*Math.exp(-e*e))}),s_e={kernelName:vm,backendName:"cpu",kernelFunc:o_e},pU=qa(n=>Math.exp(n)),fU=Fc(xm,pU,"float32"),a_e={kernelName:xm,backendName:"cpu",kernelFunc:fU};function rx(n){const{inputs:t,backend:e,attrs:r}=n,{input:i}=t,{dim:o}=r,s=i.shape.length,a=i.shape.slice();let c=o;return o<0&&(Z(-(s+1)<=o,()=>`Axis must be in the interval [${-(s+1)}, ${s}]`),c=s+o+1),a.splice(c,0,1),Yn({inputs:{x:i},backend:e,attrs:{shape:a}})}const l_e={kernelName:Y_,backendName:"cpu",kernelFunc:rx},mU=qa(n=>Math.expm1(n)),c_e=Fc(wm,mU),u_e={kernelName:wm,backendName:"cpu",kernelFunc:c_e},d_e=Pr((n,t)=>n/t),$k=ai(ym,d_e),Lk={kernelName:ym,backendName:"cpu",kernelFunc:$k},gU=Pr((n,t)=>n-t),h_e=Ok((n,t,e,r)=>({real:n-e,imag:t-r})),Bk=ai(Ym,gU,h_e),p_e={kernelName:Ym,backendName:"cpu",kernelFunc:Bk};function bU(n,t,e){const r=n.shape,i=r[0],o=r[1],s=e.data.get(n.dataId),a=s.complexTensorInfos.real,c=s.complexTensorInfos.imag,u=[i,o],p=Me(u),m=Ei("float32",p),g=Ei("float32",p);for(let I=0;I<i;I++){const N=Ku({inputs:{x:a},backend:e,attrs:{begin:[I,0],size:[1,o]}}),R=Ku({inputs:{x:c},backend:e,attrs:{begin:[I,0],size:[1,o]}}),L=Wo({inputs:{real:N,imag:R},backend:e}),{real:V,imag:j}=f_e(L,t,e),Y=Cl(V,j);for(let ee=0;ee<o;ee++){const ie=hD(Y,ee);m[I*o+ee]=ie.real,g[I*o+ee]=ie.imag}e.disposeIntermediateTensorInfo(N),e.disposeIntermediateTensorInfo(R),e.disposeIntermediateTensorInfo(L)}const _=e.makeTensorInfo(u,"float32",m),x=e.makeTensorInfo(u,"float32",g),T=Wo({inputs:{real:_,imag:x},backend:e});return e.disposeIntermediateTensorInfo(_),e.disposeIntermediateTensorInfo(x),T}function f_e(n,t,e){const r=Me(n.shape),i=e.data.get(n.dataId),o=e.data.get(i.complexTensorInfos.real.dataId).values,s=e.data.get(i.complexTensorInfos.imag.dataId).values;if(function m_e(n){return 0==(n&n-1)}(r)){const a=Vk(o,s,r,t,e),c=[n.shape[0],n.shape[1]];if(t){const u=e.makeTensorInfo(c,"float32",a.real),p=e.makeTensorInfo(c,"float32",a.imag),m=e.makeTensorInfo([],"float32",lc(r,"float32")),g=Ka({inputs:{x:m},backend:e}),_=Lk.kernelFunc({inputs:{a:u,b:m},backend:e}),x=Lk.kernelFunc({inputs:{a:p,b:g},backend:e}),T=e.data.get(_.dataId).values,I=e.data.get(x.dataId).values;return e.disposeIntermediateTensorInfo(u),e.disposeIntermediateTensorInfo(p),e.disposeIntermediateTensorInfo(m),e.disposeIntermediateTensorInfo(g),e.disposeIntermediateTensorInfo(_),e.disposeIntermediateTensorInfo(x),{real:T,imag:I}}return a}{const c=function g_e(n,t,e){const r=new Float32Array(2*t);for(let i=0;i<t;i++){let o=0,s=0;for(let a=0;a<t;a++){const c=IV(i*a,t,e),u=hD(n,a);o+=u.real*c.real-u.imag*c.imag,s+=u.real*c.imag+u.imag*c.real}e&&(o/=t,s/=t),SV(r,o,s,i)}return r}(Cl(o,s),r,t);return xV(c)}}function Vk(n,t,e,r,i){if(1===e)return{real:n,imag:t};const o=Cl(n,t),s=e/2,a=wV(o),c=a.real,u=a.imag,p=[c.length],m=i.makeTensorInfo(p,"float32",c),g=i.makeTensorInfo(p,"float32",u),_=Wo({inputs:{real:m,imag:g},backend:i}),x=TV(o),T=x.real,I=x.imag,N=[T.length],R=i.makeTensorInfo(N,"float32",T),L=i.makeTensorInfo(N,"float32",I),V=Wo({inputs:{real:R,imag:L},backend:i}),j=Vk(c,u,s,r,i),Y=j.real,ee=j.imag,ie=[Y.length],ce=i.makeTensorInfo(ie,"float32",Y),he=i.makeTensorInfo(ie,"float32",ee),we=Wo({inputs:{real:ce,imag:he},backend:i}),Ee=Vk(T,I,s,r,i),Ae=Ee.real,Oe=Ee.imag,Re=[Ae.length],_e=i.makeTensorInfo(Re,"float32",Ae),Te=i.makeTensorInfo(Re,"float32",Oe),xe=Wo({inputs:{real:_e,imag:Te},backend:i}),De=CV(e,r),je=[De.real.length],We=i.makeTensorInfo(je,"float32",De.real),Je=i.makeTensorInfo(je,"float32",De.imag),Ze=Wo({inputs:{real:We,imag:Je},backend:i}),et=nx({inputs:{a:Ze,b:xe},backend:i}),rt=Xh({inputs:{a:we,b:et},backend:i}),bt=Bk({inputs:{a:we,b:et},backend:i}),pt=qu({inputs:{input:rt},backend:i}),Ot=qu({inputs:{input:bt},backend:i}),Tt=Yh({inputs:{input:rt},backend:i}),Wt=Yh({inputs:{input:bt},backend:i}),Zt=Zh({inputs:[pt,Ot],backend:i,attrs:{axis:0}}),Ln=Zh({inputs:[Tt,Wt],backend:i,attrs:{axis:0}}),Zn=i.data.get(Zt.dataId).values,Cr=i.data.get(Ln.dataId).values;return i.disposeIntermediateTensorInfo(m),i.disposeIntermediateTensorInfo(g),i.disposeIntermediateTensorInfo(_),i.disposeIntermediateTensorInfo(R),i.disposeIntermediateTensorInfo(L),i.disposeIntermediateTensorInfo(V),i.disposeIntermediateTensorInfo(ce),i.disposeIntermediateTensorInfo(he),i.disposeIntermediateTensorInfo(we),i.disposeIntermediateTensorInfo(_e),i.disposeIntermediateTensorInfo(Te),i.disposeIntermediateTensorInfo(xe),i.disposeIntermediateTensorInfo(We),i.disposeIntermediateTensorInfo(Je),i.disposeIntermediateTensorInfo(Ze),i.disposeIntermediateTensorInfo(et),i.disposeIntermediateTensorInfo(rt),i.disposeIntermediateTensorInfo(bt),i.disposeIntermediateTensorInfo(pt),i.disposeIntermediateTensorInfo(Tt),i.disposeIntermediateTensorInfo(Ot),i.disposeIntermediateTensorInfo(Wt),i.disposeIntermediateTensorInfo(Zt),i.disposeIntermediateTensorInfo(Ln),{real:Zn,imag:Cr}}const y_e={kernelName:"FFT",backendName:"cpu",kernelFunc:function b_e(n){const{inputs:t,backend:e}=n,{input:r}=t,i=Me(r.shape),o=r.shape[r.shape.length-1],a=Yn({inputs:{x:r},backend:e,attrs:{shape:[i/o,o]}}),c=bU(a,!1,e),u=Yn({inputs:{x:c},backend:e,attrs:{shape:r.shape}});return e.disposeIntermediateTensorInfo(a),e.disposeIntermediateTensorInfo(c),u}};function zk(n){const{backend:t,attrs:e}=n,{shape:r,value:i,dtype:o}=e,s=o||_h(i),a=Or(s,Me(r));return function v_e(n,t,e){n.fill(t)}(a,i),t.makeTensorInfo(r,s,a)}const __e={kernelName:BC,backendName:"cpu",kernelFunc:zk},x_e={kernelName:VC,backendName:"cpu",kernelFunc:({inputs:n,backend:e})=>{const{image:r}=n,i=e,o=Ei(r.dtype,Me(r.shape)),[s,a,c,u]=r.shape,p=i.data.get(r.dataId).values;for(let g=0;g<s;g++){const _=g*c*a*u;for(let x=0;x<a;x++){const T=x*(c*u);for(let I=0;I<c;I++){const N=I*u;for(let R=0;R<u;R++){const L=Math.round(c-I-1),V=_+T+N+R;let j=p[V];L>=0&&L<c&&(j=p[_+T+L*u+R]),o[V]=j}}}}return{dataId:i.write(o,r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}},yU=qa(n=>Math.floor(n)),w_e=Fc(Tm,yU),T_e={kernelName:Tm,backendName:"cpu",kernelFunc:w_e},S_e=Pr((n,t)=>Math.floor(n/t)),C_e=ai(Sm,S_e,null,"int32"),I_e={kernelName:Sm,backendName:"cpu",kernelFunc:C_e},D_e={kernelName:$0,backendName:"cpu",kernelFunc:function E_e(n){const{inputs:t,backend:e,attrs:r}=n,{x:i,filter:o,bias:s,preluActivationWeights:a}=t,{strides:c,pad:u,dataFormat:p,dilations:m,dimRoundingMode:g,activation:_,leakyreluAlpha:x}=r;let T=cU({inputs:{x:i,filter:o},backend:e,attrs:{strides:c,pad:u,dataFormat:p,dilations:m,dimRoundingMode:g}});if(s){const I=T;if("NCHW"===p&&1===s.shape.length&&1!==s.shape[0]){const N=Yn({inputs:{x:s},backend:e,attrs:{shape:[s.shape[0],1,1]}});T=Xh({inputs:{a:T,b:N},backend:e}),e.disposeIntermediateTensorInfo(N)}else T=Xh({inputs:{a:T,b:s},backend:e});e.disposeIntermediateTensorInfo(I)}if(_){const I=T;if("NCHW"===p&&"prelu"===_&&1===a.shape.length&&1!==a.shape[0]){const N=Yn({inputs:{x:a},backend:e,attrs:{shape:[a.shape[0],1,1]}});T=ex(e,T,_,N,x),e.disposeIntermediateTensorInfo(N)}else T=ex(e,T,_,a,x);e.disposeIntermediateTensorInfo(I)}return T}},A_e={kernelName:L0,backendName:"cpu",kernelFunc:function k_e(n){const{inputs:t,backend:e,attrs:r}=n,{x:i,filter:o,bias:s,preluActivationWeights:a}=t,{strides:c,pad:u,dataFormat:p,dilations:m,dimRoundingMode:g,activation:_,leakyreluAlpha:x}=r;let T=uU({inputs:{x:i,filter:o},backend:e,attrs:{strides:c,pad:u,dataFormat:p,dilations:m,dimRoundingMode:g}});if(s){const I=T;T=Xh({inputs:{a:T,b:s},backend:e}),e.disposeIntermediateTensorInfo(I)}if(_){const I=T;T=ex(e,T,_,a,x),e.disposeIntermediateTensorInfo(I)}return T}};function _U(n,t,e,r,i,o,s,a,c){const u=sn([r,o],e);for(let p=0;p<r;p++){const m=[];let g=0;for(let _=0;_<i;_++){const x=n[p*i+_];g+=x*s[_],m.push(x)}if(g<0||g>=c/o)throw new Error(`Invalid indices: ${m} does not index into ${a}`);for(let _=0;_<o;_++)u.values[p*o+_]=t.get(...t.indexToLoc(g*o+_))}return u}const O_e={kernelName:zC,backendName:"cpu",kernelFunc:function N_e(n){const{inputs:t,backend:e}=n,{params:r,indices:i}=t,o=Me(r.shape),s=i.shape,a=s[s.length-1],[c,u,p,m]=oD(r,i);if(0===u)return e.makeTensorInfo(c,r.dtype,[]);const x=_U(e.data.get(i.dataId).values,e.bufferSync(r),r.dtype,u,a,p,m,r.shape,o);return e.makeTensorInfo(c,r.dtype,x.values)}};function vU(n,t,e){const r=sn(e,n.dtype);for(let i=0;i<r.size;++i){const s=r.indexToLoc(i).slice(),u=t.locToIndex([s[0],s[2]]);s[2]=t.values[u];const p=n.locToIndex(s);0<=p&&p<n.values.length&&(r.values[i]=n.values[p])}return r}const M_e={kernelName:Q_,backendName:"cpu",kernelFunc:function R_e(n){const{inputs:t,backend:e,attrs:r}=n,{x:i,indices:o}=t,{axis:s,batchDims:a}=r;Ct([i,o],"gatherV2");const c=cn(s,i.shape)[0],u=e.data.get(o.dataId).values,p=i.shape[c];for(let V=0;V<u.length;++V){const j=u[V];Z(j<=p-1&&j>=0,()=>`GatherV2: the index value ${j} is not in [0, ${p-1}]`)}let m=a;null==a&&(m=0);const g=Me(o.shape),_=xD(i,o,c,m),x=Yn({inputs:{x:i},backend:e,attrs:{shape:[_.batchSize,_.outerSize,_.dimSize,_.sliceSize]}}),T=Yn({inputs:{x:o},backend:e,attrs:{shape:[_.batchSize,g/_.batchSize]}}),I=[_.batchSize,_.outerSize,g/_.batchSize,_.sliceSize],N=e.bufferSync(T),L=vU(e.bufferSync(x),N,I);return e.disposeIntermediateTensorInfo(x),e.disposeIntermediateTensorInfo(T),e.makeTensorInfo(_.outputShape,L.dtype,L.values)}},xU=Pr((n,t)=>n>t?1:0),F_e=ai(J_,xU,null,"bool"),P_e={kernelName:J_,backendName:"cpu",kernelFunc:F_e},wU=Pr((n,t)=>n>=t?1:0),$_e=ai(Cm,wU,null,"bool"),L_e={kernelName:Cm,backendName:"cpu",kernelFunc:$_e},V_e={kernelName:UC,backendName:"cpu",kernelFunc:function B_e(n){const{inputs:t,backend:e}=n,{input:r}=t,i=Me(r.shape),o=r.shape[r.shape.length-1],a=Yn({inputs:{x:r},backend:e,attrs:{shape:[i/o,o]}}),c=bU(a,!0,e),u=Yn({inputs:{x:c},backend:e,attrs:{shape:r.shape}});return e.disposeIntermediateTensorInfo(a),e.disposeIntermediateTensorInfo(c),u}},z_e=$n(Em,n=>Number.isFinite(n)?1:0,"bool"),U_e={kernelName:Em,backendName:"cpu",kernelFunc:z_e},j_e=$n(Dm,n=>Math.abs(n)===1/0?1:0,"bool"),G_e={kernelName:Dm,backendName:"cpu",kernelFunc:j_e},H_e=$n(km,n=>Number.isNaN(n)?1:0,"bool"),W_e={kernelName:km,backendName:"cpu",kernelFunc:H_e},TU=Pr((n,t)=>n<t?1:0),q_e=ai(t0,TU,null,"bool"),K_e={kernelName:t0,backendName:"cpu",kernelFunc:q_e},SU=Pr((n,t)=>n<=t?1:0),X_e=ai(n0,SU,null,"bool"),Y_e={kernelName:n0,backendName:"cpu",kernelFunc:X_e};function CU(n,t,e){const r=(t-n)/(e-1),i=Ui(e,"float32");i[0]=n;for(let o=1;o<i.length;o++)i[o]=i[o-1]+r;return i}const Q_e={kernelName:GC,backendName:"cpu",kernelFunc:function Z_e(n){const{backend:t,attrs:e}=n,{start:r,stop:i,num:o}=e,s=CU(r,i,o);return t.makeTensorInfo([s.length],"float32",s)}},IU=qa(n=>Math.log(n)),J_e=Fc(Am,IU),e0e={kernelName:Am,backendName:"cpu",kernelFunc:J_e},t0e=$n(Nm,n=>Math.log1p(n)),n0e={kernelName:Nm,backendName:"cpu",kernelFunc:t0e},r0e=Pr((n,t)=>n&&t),i0e=ai(r0,r0e,null,"bool"),o0e={kernelName:r0,backendName:"cpu",kernelFunc:i0e},s0e=$n(o0,n=>n?0:1,"bool"),a0e={kernelName:o0,backendName:"cpu",kernelFunc:s0e},l0e=Pr((n,t)=>n||t),c0e=ai(s0,l0e,null,"bool"),u0e={kernelName:s0,backendName:"cpu",kernelFunc:c0e},h0e={kernelName:a0,backendName:"cpu",kernelFunc:function d0e(n){const{inputs:t,backend:e,attrs:r}=n,{x:i}=t,{depthRadius:o,bias:s,alpha:a,beta:c}=r;Ct(i,"LRN");const u=i.shape[3],p=u-1,m=e.data.get(i.dataId).values,g=Me(i.shape),_=new Float32Array(g);function x(T){const I=T%u;let N=T-I+Math.max(0,I-o);const R=T-I+Math.min(I+o,p);let L=0;for(;N<=R;N++){const V=m[N];L+=V*V}return L}for(let T=0;T<g;T++){const I=x(T),N=m[T]*Math.pow(s+a*I,-c);_[T]=N}return e.makeTensorInfo(i.shape,i.dtype,_)}},f0e={kernelName:HC,backendName:"cpu",kernelFunc:function p0e(n){const{inputs:t,backend:e,attrs:r}=n,{x:i,y:o,dy:s}=t,{depthRadius:a,bias:c,alpha:u,beta:p}=r;Ct(s,"LRNGrad");const m=Me(s.shape),g=s.shape[3],_=e.data.get(s.dataId).values,x=e.data.get(i.dataId).values,T=e.data.get(o.dataId).values,I=new Float32Array(m),N=m;for(let R=0;R<N;R++){const L=R%g,V=R-L+Math.max(0,L-a),j=R-L+Math.min(g,L+a+1);let Y=0;for(let ee=V;ee<j;ee++)Y+=Math.pow(x[ee],2);Y=u*Y+c;for(let ee=V;ee<j;ee++){let ie=-2*u*p*x[ee]*T[R]/Y;R===ee&&(ie+=Math.pow(Y,-p)),ie*=_[R],I[ee]+=ie}}return e.makeTensorInfo(s.shape,i.dtype,I)}};function EU(n,t,e,r){const i=Ei(r,Me(e));for(let o=0;o<i.length;++o){const s=o*t;let a=n[s];for(let c=0;c<t;++c){const u=n[s+c];(Number.isNaN(u)||u>a)&&(a=u)}i[o]=a}return i}function DU(n){const{inputs:t,backend:e,attrs:r}=n,{x:i}=t,{reductionIndices:o,keepDims:s}=r,a=e;let c=i.shape;const u=c.length,p=cn(o,c);let m=p;const g=hr(m,u);let _=a.data.get(i.dataId).values;if(null!=g){const V=new Array(u);for(let j=0;j<V.length;j++)V[j]=c[g[j]];_=Rk(_,c,i.dtype,g,V),m=Mr(m.length,u),c=V}Ct(i,"max"),ki("max",m,u);const[x,T]=gi(c,m),N=EU(_,Me(T),x,i.dtype),R=a.write(N,x,i.dtype);let L=x;return s&&(L=Rr(x,p)),{dataId:R,shape:L,dtype:i.dtype}}const m0e={kernelName:l0,backendName:"cpu",kernelFunc:DU},kU=Pr((n,t)=>Math.max(n,t)),g0e=ai(Om,kU),b0e={kernelName:Om,backendName:"cpu",kernelFunc:g0e},_0e={kernelName:c0,backendName:"cpu",kernelFunc:function y0e(n){const{inputs:t,backend:e,attrs:r}=n,{x:i}=t;Ct(i,"maxPool");const{filterSize:o,strides:s,pad:a,dimRoundingMode:c}=r;Z(Di(s,1),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${s} and dilations '1'`);const p=Rs(i.shape,o,s,1,a,c);let m;if(1===p.filterWidth&&1===p.filterHeight&&mn(p.inShape,p.outShape))m=Ka({inputs:{x:i},backend:e});else{const g=e.data.get(i.dataId).values,_=Rt(i.shape),x=Mk(g,0,i.dtype,_,p,"max");m=e.makeTensorInfo(p.outShape,i.dtype,x.values)}return m}},x0e={kernelName:u0,backendName:"cpu",kernelFunc:function v0e(n){const{inputs:t,backend:e,attrs:r}=n,{x:i}=t,{filterSize:o,strides:s,pad:a,dimRoundingMode:c,dataFormat:u}=r;Ct(i,"maxPool3d");const p=wl(i.shape,o,s,1,a,c,u),g=iU(e.data.get(i.dataId).values,0,i.dtype,Rt(i.shape),p,"max");return e.makeTensorInfo(g.shape,"float32",g.values)}},T0e={kernelName:qC,backendName:"cpu",kernelFunc:function w0e(n){const{inputs:t,backend:e,attrs:r}=n,{dy:i,input:o}=t,{filterSize:s,strides:a,pad:c,dimRoundingMode:u}=r;Ct([i,o],"maxPool3DGrad");const p=wl(o.shape,s,a,1,c,u),g=function Pbe(n,t){const e=sn(t.outShape,"int32"),r=t.strideDepth,i=t.strideHeight,o=t.strideWidth,s=t.dilationDepth,a=t.dilationHeight,c=t.dilationWidth,u=t.effectiveFilterDepth,p=t.effectiveFilterHeight,m=t.effectiveFilterWidth,g=t.padInfo.front,_=t.padInfo.top,x=t.padInfo.left;for(let T=0;T<t.batchSize;++T)for(let I=0;I<t.inChannels;++I)for(let N=0;N<t.outDepth;++N){const R=N*r-g;let L=R;for(;L<0;)L+=s;const V=Math.min(t.inDepth,u+R);for(let j=0;j<t.outHeight;++j){const Y=j*i-_;let ee=Y;for(;ee<0;)ee+=a;const ie=Math.min(t.inHeight,p+Y);for(let ce=0;ce<t.outWidth;++ce){const he=ce*o-x;let we=he;for(;we<0;)we+=c;const Ee=Math.min(t.inWidth,m+he);let Ae=Number.NEGATIVE_INFINITY,Oe=-1;for(let Re=L;Re<V;Re+=s){const _e=Re-R;for(let Te=ee;Te<ie;Te+=a){const xe=Te-Y;for(let De=we;De<Ee;De+=c){const je=De-he,We=n.get(T,Re,Te,De,I);We>=Ae&&(Ae=We,Oe=_e*p*m+xe*p+je)}}}e.set(Oe,T,N,j,ce,I)}}}return e}(e.bufferSync(o),p),_=p.strideDepth,x=p.strideHeight,T=p.strideWidth,I=p.dilationDepth,N=p.dilationHeight,R=p.dilationWidth,L=p.effectiveFilterDepth,V=p.effectiveFilterHeight,j=p.effectiveFilterWidth,Y=L-1-p.padInfo.front,ee=j-1-p.padInfo.left,ie=V-1-p.padInfo.top,ce=sn(o.shape,"float32"),he=e.bufferSync(i);for(let we=0;we<p.batchSize;++we)for(let Ee=0;Ee<p.inChannels;++Ee)for(let Ae=0;Ae<p.inDepth;++Ae)for(let Oe=0;Oe<p.inHeight;++Oe)for(let Re=0;Re<p.inWidth;++Re){const _e=Ae-Y,Te=Oe-ie,xe=Re-ee;let De=0;for(let je=0;je<L;je+=I){const We=(_e+je)/_;if(!(We<0||We>=p.outDepth||Math.floor(We)!==We))for(let Je=0;Je<V;Je+=N){const Ze=(Te+Je)/x;if(!(Ze<0||Ze>=p.outHeight||Math.floor(Ze)!==Ze))for(let et=0;et<j;et+=R){const rt=(xe+et)/T;if(rt<0||rt>=p.outWidth||Math.floor(rt)!==rt)continue;const Ot=L*V*j-1-g.get(we,We,Ze,rt,Ee)===je*V*j+Je*j+et?1:0;0!==Ot&&(De+=he.get(we,We,Ze,rt,Ee)*Ot)}}}ce.set(De,we,Ae,Oe,Re,Ee)}return e.makeTensorInfo(ce.shape,ce.dtype,ce.values)}},C0e={kernelName:WC,backendName:"cpu",kernelFunc:function S0e(n){const{inputs:t,backend:e,attrs:r}=n,{dy:i,input:o,output:s}=t,a=o;Ct([o,s],"maxPoolGrad");const{filterSize:c,strides:u,pad:p,dimRoundingMode:m}=r,g=Rs(a.shape,c,u,1,p,m),_=e.data.get(a.dataId).values,x=sn(g.outShape,a.dtype,rU(_,a.shape,a.dtype,g).values),T=g.strideHeight,I=g.strideWidth,N=g.dilationHeight,R=g.dilationWidth,L=g.effectiveFilterHeight,V=g.effectiveFilterWidth,j=V-1-g.padInfo.left,Y=L-1-g.padInfo.top,ee=sn(a.shape,"float32"),ie=e.data.get(i.dataId).values,ce=sn(i.shape,"float32",ie);for(let he=0;he<g.batchSize;++he)for(let we=0;we<g.inChannels;++we)for(let Ee=0;Ee<g.inHeight;++Ee)for(let Ae=0;Ae<g.inWidth;++Ae){const Oe=Ee-Y,Re=Ae-j;let _e=0;for(let Te=0;Te<L;Te+=N){const xe=(Oe+Te)/T;if(!(xe<0||xe>=g.outHeight||Math.floor(xe)!==xe))for(let De=0;De<V;De+=R){const je=(Re+De)/I;if(je<0||je>=g.outWidth||Math.floor(je)!==je)continue;const Ze=L*V-1-x.get(he,xe,je,we)===Te*V+De?1:0;0!==Ze&&(_e+=ce.get(he,xe,je,we)*Ze)}}ee.set(_e,he,Ee,Ae,we)}return e.makeTensorInfo(ee.shape,ee.dtype,ee.values)}},E0e={kernelName:KC,backendName:"cpu",kernelFunc:({inputs:n,attrs:t,backend:e})=>{const{x:r}=n,{filterSize:i,strides:o,pad:s,includeBatchInIndex:a}=t,c=e;Ct(r,"MaxPoolWithArgmax");const u=c.data.get(r.dataId).values,p=Rs(r.shape,i,o,[1,1],s),[m,g]=function I0e(n,t,e,r,i){const s=Mk(n,0,e,Rt(t),i,"max"),a=rU(n,t,e,i,!0,r);return[s.values,a.values]}(u,r.shape,r.dtype,a,p),_=c.write(m,p.outShape,r.dtype),x=c.write(g,p.outShape,r.dtype);return[{dataId:_,shape:p.outShape,dtype:r.dtype},{dataId:x,shape:p.outShape,dtype:"int32"}]}},k0e={kernelName:d0,backendName:"cpu",kernelFunc:function D0e(n){const{inputs:t,backend:e,attrs:r}=n,{x:i}=t,{axis:o,keepDims:s}=r,a=cn(o,i.shape),p=Me(gi(i.shape,a)[1]),m=[],g=e.makeTensorInfo([],"float32",new Float32Array([p]));m.push(g);const _=Pc({inputs:{x:i},backend:e,attrs:{dtype:"float32"}});m.push(_);const x=$k({inputs:{a:_,b:g},backend:e});m.push(x);const T=Lg({inputs:{x},backend:e,attrs:{axis:o,keepDims:s}});return m.forEach(I=>e.disposeIntermediateTensorInfo(I)),T}},N0e={kernelName:h0,backendName:"cpu",kernelFunc:function A0e(n){const{inputs:t,backend:e,attrs:r}=n,{x:i}=t,{axis:o,keepDims:s}=r;Ct(i,"min");const a=cn(o,i.shape);let c=a;const u=hr(c,i.shape.length);let p=i;null!=u&&(p=Eo({inputs:{x:i},backend:e,attrs:{perm:u}}),c=Mr(c.length,i.shape.length)),ki("min",c,p.shape.length);const[m,g]=gi(p.shape,c),_=Me(g),x=Ui(Me(m),p.dtype),T=e.data.get(p.dataId).values;for(let N=0;N<x.length;++N){const R=N*_;let L=T[R];for(let V=0;V<_;++V){const j=T[R+V];(Number.isNaN(j)||j<L)&&(L=j)}x[N]=L}null!=u&&e.disposeIntermediateTensorInfo(p);const I=e.makeTensorInfo(m,p.dtype,x);if(s){const R=Yn({inputs:{x:I},backend:e,attrs:{shape:Rr(m,a)}});return e.disposeIntermediateTensorInfo(I),R}return I}},AU=Pr((n,t)=>Math.min(n,t)),O0e=ai(Rm,AU),R0e={kernelName:Rm,backendName:"cpu",kernelFunc:O0e},F0e={kernelName:p0,backendName:"cpu",kernelFunc:function M0e(n){const{inputs:t,backend:e,attrs:r}=n,{x:i}=t,{paddings:o,mode:s}=r;Ct(i,"mirrorPad");const a=o.map((L,V)=>L[0]+i.shape[V]+L[1]),c=o.map(L=>L[0]),u=o.map((L,V)=>L[0]+i.shape[V]),p="reflect"===s?0:1,m=e.data.get(i.dataId).values,g=i.shape.length,_=Rt(i.shape),x=Me(a),T=a.length,I=Rt(a),N=Ei(i.dtype,x);for(let L=0;L<x;L++){let V=vh(L,T,I);for(let Y=0;Y<T;Y++)V[Y]<c[Y]?V[Y]=2*c[Y]-V[Y]-p:V[Y]>=u[Y]&&(V[Y]=2*(u[Y]-1)-V[Y]+p);V=V.map((Y,ee)=>Y-c[ee]);const j=Ra(V,g,_);N[L]=m[j]}return{dataId:e.write(N,a,i.dtype),shape:a,dtype:i.dtype}}},P0e=Pr((n,t)=>{const e=n%t;return n<0&&t<0||n>=0&&t>=0?e:(e+t)%t}),$0e=ai(Mm,P0e),L0e={kernelName:Mm,backendName:"cpu",kernelFunc:$0e};function NU(n){const{inputs:t,backend:e,attrs:r}=n,{logits:i}=t,{dim:o}=r,s=i.shape.length;let a=o;if(-1===a&&(a=s-1),a!==s-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${s} and dim was ${a}`);const c=cn([a],i.shape),u=DU({inputs:{x:i},backend:e,attrs:{reductionIndices:c,keepDims:!1}}),p=Rr(u.shape,c),m=Yn({inputs:{x:u},backend:e,attrs:{shape:p}}),g=Bk({inputs:{a:i,b:m},backend:e}),_=fU({inputs:{x:g},backend:e}),x=Lg({inputs:{x:_},backend:e,attrs:{axis:c,keepDims:!1}}),T=Yn({inputs:{x},backend:e,attrs:{shape:p}}),I=$k({inputs:{a:_,b:T},backend:e});return e.disposeIntermediateTensorInfo(u),e.disposeIntermediateTensorInfo(m),e.disposeIntermediateTensorInfo(g),e.disposeIntermediateTensorInfo(_),e.disposeIntermediateTensorInfo(x),e.disposeIntermediateTensorInfo(T),I}const B0e={kernelName:N0,backendName:"cpu",kernelFunc:NU},z0e={kernelName:XC,backendName:"cpu",kernelFunc:function V0e(n){const{inputs:t,backend:e,attrs:r}=n,{logits:i}=t,{numSamples:o,seed:s,normalized:a}=r;Ct(i,"multinomial");const c=a?i:NU({inputs:{logits:i},backend:e,attrs:{dim:-1}}),u=c.shape[0],p=c.shape[1],m=e.data.get(c.dataId).values,g=[u,o],_=Ui(Me(g),"int32");for(let x=0;x<u;++x){const T=x*p,I=new Float32Array(p-1);I[0]=m[T];for(let L=1;L<I.length;++L)I[L]=I[L-1]+m[T+L];const N=uv.alea(s.toString()),R=x*o;for(let L=0;L<o;++L){const V=N();_[R+L]=I.length;for(let j=0;j<I.length;j++)if(V<I[j]){_[R+L]=j;break}}}return a||e.disposeIntermediateTensorInfo(c),e.makeTensorInfo(g,"int32",_)}};function OU(n,t,e){const r=lc(-1,e);return Pk([],t,r,n,e)}const j0e={kernelName:f0,backendName:"cpu",kernelFunc:function U0e(n){const{inputs:t,backend:e}=n,{x:r}=t;Ct(r,"neg");const i=e.data.get(r.dataId).values,[o,s]=OU(i,r.shape,r.dtype);return e.makeTensorInfo(s,r.dtype,o)}},G0e=qE,W0e={kernelName:YC,backendName:"cpu",kernelFunc:function H0e(n){const{inputs:t,backend:e,attrs:r}=n,{boxes:i,scores:o}=t,{maxOutputSize:s,iouThreshold:a,scoreThreshold:c}=r;Ct(i,"NonMaxSuppression");const u=e.data.get(i.dataId).values,p=e.data.get(o.dataId).values,{selectedIndices:m}=G0e(u,p,s,a,c);return e.makeTensorInfo([m.length],"int32",new Int32Array(m))}},q0e=KE,X0e={kernelName:ZC,backendName:"cpu",kernelFunc:function K0e(n){const{inputs:t,backend:e,attrs:r}=n,{boxes:i,scores:o}=t,{maxOutputSize:s,iouThreshold:a,scoreThreshold:c,padToMaxOutputSize:u}=r;Ct(i,"NonMaxSuppressionPadded");const p=e.data.get(i.dataId).values,m=e.data.get(o.dataId).values,{selectedIndices:g,validOutputs:_}=q0e(p,m,s,a,c,u);return[e.makeTensorInfo([g.length],"int32",new Int32Array(g)),e.makeTensorInfo([],"int32",new Int32Array([_]))]}},Y0e=XE,Q0e={kernelName:QC,backendName:"cpu",kernelFunc:function Z0e(n){const{inputs:t,backend:e,attrs:r}=n,{boxes:i,scores:o}=t,{maxOutputSize:s,iouThreshold:a,scoreThreshold:c,softNmsSigma:u}=r;Ct(i,"NonMaxSuppressionWithScore");const p=e.data.get(i.dataId).values,m=e.data.get(o.dataId).values,g=s,_=a,x=c,T=u,{selectedIndices:I,selectedScores:N}=Y0e(p,m,g,_,x,T);return[e.makeTensorInfo([I.length],"int32",new Int32Array(I)),e.makeTensorInfo([N.length],"float32",new Float32Array(N))]}},RU=Pr((n,t)=>n!==t?1:0),J0e=ai(m0,RU,null,"bool"),eve={kernelName:m0,backendName:"cpu",kernelFunc:J0e},nve={kernelName:b0,backendName:"cpu",kernelFunc:function tve(n){const{inputs:t,backend:e,attrs:r}=n,{indices:i}=t,{dtype:o,depth:s,onValue:a,offValue:c}=r;Ct(i,"oneHot");const u=Me(i.shape),p=new Float32Array(u*s);p.fill(c);const m=e.data.get(i.dataId).values;for(let g=0;g<u;++g)m[g]>=0&&m[g]<s&&(p[g*s+m[g]]=a);return e.makeTensorInfo([...i.shape,s],o,p)}};function ix(n){const{inputs:t,backend:e}=n,{x:r}=t;if("string"===r.dtype)throw new Error("zerosLike is not supported for string tensors");if("complex64"===r.dtype){const i=qu({inputs:{input:r},backend:e}),o=ix({inputs:{x:i},backend:e}),s=Yh({inputs:{input:r},backend:e}),a=ix({inputs:{x:s},backend:e}),c=Wo({inputs:{real:o,imag:a},backend:e});return e.disposeIntermediateTensorInfo(i),e.disposeIntermediateTensorInfo(o),e.disposeIntermediateTensorInfo(s),e.disposeIntermediateTensorInfo(a),c}return zk({backend:e,attrs:{shape:r.shape,value:0,dtype:r.dtype}})}const rve={kernelName:F0,backendName:"cpu",kernelFunc:ix},ive={kernelName:g0,backendName:"cpu",kernelFunc:function MU(n){const{inputs:t,backend:e}=n,{x:r}=t;if("string"===r.dtype)throw new Error("onesLike is not supported for string tensors");if("complex64"===r.dtype){const i=qu({inputs:{input:r},backend:e}),o=MU({inputs:{x:i},backend:e}),s=Yh({inputs:{input:r},backend:e}),a=ix({inputs:{x:s},backend:e}),c=Wo({inputs:{real:o,imag:a},backend:e});return e.disposeIntermediateTensorInfo(i),e.disposeIntermediateTensorInfo(o),e.disposeIntermediateTensorInfo(s),e.disposeIntermediateTensorInfo(a),c}return zk({backend:e,attrs:{shape:r.shape,value:1,dtype:r.dtype}})}};function FU(n){const{inputs:t,backend:e,attrs:r}=n,{axis:i}=r;if(1===t.length)return rx({inputs:{input:t[0]},backend:e,attrs:{dim:i}});const o=t[0].shape,s=t[0].dtype;t.forEach(p=>{Vo(o,p.shape,"All tensors passed to stack must have matching shapes"),Z(s===p.dtype,()=>"All tensors passed to stack must have matching dtypes")});const a=[],u=Zh({inputs:t.map(p=>{const m=rx({inputs:{input:p},backend:e,attrs:{dim:i}});return a.push(m),m}),backend:e,attrs:{axis:i}});return a.forEach(p=>e.disposeIntermediateTensorInfo(p)),u}const ove={kernelName:y0,backendName:"cpu",kernelFunc:FU},PU={kernelName:_0,backendName:"cpu",kernelFunc:function sve(n){const{inputs:t,backend:e,attrs:r}=n,{x:i}=t,{paddings:o,constantValue:s}=r;Ct(i,"pad");const a=o.map((R,L)=>R[0]+i.shape[L]+R[1]),c=o.map(R=>R[0]),u=e.data.get(i.dataId).values,p=Me(i.shape),m=i.shape.length,g=Rt(i.shape),_=Me(a),x=a.length,T=Rt(a),I=Ei(i.dtype,_);0!==s&&I.fill(s);for(let R=0;R<p;R++)I[Ra(vh(R,m,g).map((Y,ee)=>Y+c[ee]),x,T)]=u[R];return{dataId:e.write(I,a,i.dtype),shape:a,dtype:i.dtype}}},ave=Pr((n,t)=>Math.pow(n,t)),lve=ai(Pm,ave),cve={kernelName:Pm,backendName:"cpu",kernelFunc:lve};function $U(n,t,e,r){const[i,o]=gi(n,r),s=zo(t,"int32"),a=Ui(Me(i),s),c=Me(o);for(let u=0;u<a.length;++u){const p=u*c;let m=1;for(let g=0;g<c;++g)m*=e[p+g];a[u]=m}return{outVals:a,outShape:i,outDtype:s}}const dve={kernelName:x0,backendName:"cpu",kernelFunc:function uve(n){const{inputs:t,backend:e,attrs:r}=n,{x:i}=t,{axis:o,keepDims:s}=r;Ct(i,"prod");const a=i.shape.length,c=cn(o,i.shape),u=hr(c,a);let p=c,m=i;const g=[];null!=u&&(m=Eo({inputs:{x:i},backend:e,attrs:{perm:u}}),g.push(m),p=Mr(p.length,a));const _=e.data.get(m.dataId).values,{outVals:x,outShape:T,outDtype:I}=$U(m.shape,m.dtype,_,p);let N=T;return s&&(N=Rr(T,c)),g.forEach(R=>e.disposeIntermediateTensorInfo(R)),e.makeTensorInfo(N,I,x)}};function LU(n,t){const e=n.slice(0,t);for(;e.length<t;)e.push(1);for(let r=t;r<n.length;r++)e[t-1]*=n[r];return e}function BU(n,t,e,r,i,o,s,a){if(0===n.length)throw new Error("paramsNestedSplits must be non empty");if(0===t[0].length)throw new Error("Split tensors must not be scalars");if(function hve(n,t,e){n.forEach((r,i)=>{if(r<0||r>=e){const o=vh(i,t.length,Rt(t)).join(",");throw new Error(`indices[${o}] = ${r} is not in [0, ${e})`)}})}(o,s,t[0][0]-1),0===r.length)throw new Error("params.rank must be nonzero");const u=r[0],{outSplits:p,valueSlices:m,numValues:g}=function fve(n,t,e,r){const i=[];let o=0;const a=new Array(t.length-1+e.length).fill(null).map(()=>[0]);!function pve(n,t){for(let e=0;e<n.length;++e){const r=n[e],i=e===n.length-1?t:n[e+1].length;if(0===r.length)throw new Error("Ragged splits may not be empty");if(r[0]<0)throw new Error("Ragged splits must be non-negative");if(r[r.length-1]>i)throw new Error("Ragged splits must not point past values");for(let o=1;o<r.length;++o)if(r[o-1]>r[o])throw new Error("Ragged splits must be sorted in ascending order")}}(e,r);let c=1;for(let u=0;u<t.length-1;++u){c*=t[u];const p=t[u+1];for(let m=1;m<c+1;++m)a[u].push(m*p)}for(let u=0;u<n.length;++u){let p=n[u],m=n[u]+1;for(let g=0;g<e.length;++g){const _=e[g],x=g+t.length-1;if(x>=0){const T=a[x],I=T[T.length-1]-_[p];for(let N=p;N<m;++N)a[x].push(_[N+1]+I)}p=_[p],m=_[m]}m!==p&&(i.push([p,m]),o+=m-p)}return{outSplits:a,valueSlices:i,numValues:o}}(o,s,n,u),_=function mve(n){const t=[];for(let e=0;e<n.length;++e){const i=Or("int32",n[e].length);t.push(i),n[e].forEach((o,s)=>i[s]=o)}return t}(p),x=function bve(n,t,e,r,i){const o=t.slice();o[0]=i;const s=Or(e,Me(o)),a=n.length;return function gve(n,t,e,r,i,o){const s=LU(t,2)[1],a=LU(o,2)[1];let c=0;for(const u of e)for(let p=u[0];p<u[1];++p){for(let m=0;m<r;++m)i[c*a+m]=n[p*s+m];++c}}(n,t,r,0===a?0:a/t[0],s,o),[s,o]}(e,r,i,m,g);return[_,x[0],x[1]]}const _ve={kernelName:JC,backendName:"cpu",kernelFunc:function yve(n){const{inputs:t,backend:e,attrs:r}=n,{paramsNestedSplits:i,paramsDenseValues:o,indices:s}=t,c=i.map(N=>e.data.get(N.dataId).values),u=i.map(N=>N.shape),p=e.data.get(o.dataId).values,m=e.data.get(s.dataId).values,[g,_,x]=BU(c,u,p,o.shape,o.dtype,m,s.shape),T=g.map(N=>e.makeTensorInfo([N.length],"int32",N)),I=e.makeTensorInfo(x,o.dtype,_);return T.concat([I])}},VU=2147483647;function zU(n,t,e,r,i,o,s){if(t.length>1)throw new Error("starts must be a scalar or vector");if(i.length>1)throw new Error("limits must be a scalar or vector");if(s.length>1)throw new Error("deltas must be a scalar or vector");const a=0===t.length,c=0===i.length,u=0===s.length,p=[];a||p.push(t[0]),c||p.push(i[0]),u||p.push(s[0]);for(let I=1;I<p.length;++I)if(p[I]!==p[I-1])throw new Error("starts, limits, and deltas must have the same shape");const m=0===p.length?1:p[0],g=Or("int32",m+1);g[0]=0;for(let I=0;I<m;++I){const N=a?n[0]:n[I],R=c?r[0]:r[I],L=u?o[0]:o[I];if(0===L)throw new Error("Requires delta != 0");let V;if(L>0&&R<N||L<0&&R>N)V=0;else if(V=Math.ceil(Math.abs((R-N)/L)),V>VU)throw new Error(`Requires ((limit - start) / delta) <= ${VU}`);g[I+1]=g[I]+V}const x=Or(e,g[m]);let T=0;for(let I=0;I<m;++I){const N=g[I+1]-g[I];let R=a?n[0]:n[I];const L=u?o[0]:o[I];for(let V=0;V<N;++V)x[T++]=R,R+=L}return[g,x]}const xve={kernelName:eI,backendName:"cpu",kernelFunc:function vve(n){const{inputs:t,backend:e}=n,{starts:r,limits:i,deltas:o}=t,s=e.data.get(r.dataId).values,a=e.data.get(i.dataId).values,c=e.data.get(o.dataId).values,[u,p]=zU(s,r.shape,r.dtype,a,i.shape,c,o.shape);return[e.makeTensorInfo([u.length],"int32",u),e.makeTensorInfo([p.length],r.dtype,p)]}};var Us=fr;class ox{constructor(t,e,r,i,o,s,a,c,u,p){this.shape=t,this.shapeShape=e,this.values=r,this.valuesShape=i,this.valuesDType=o,this.defaultValue=s,this.defaultValueShape=a,this.rowPartitionValues=c,this.rowPartitionValuesShapes=u,this.rowPartitionTypes=yV(p),this.raggedRank=_V(this.rowPartitionTypes)}getRowPartitionTypeByDimension(t){return this.rowPartitionTypes[0]===Us.FIRST_DIM_SIZE?this.rowPartitionTypes[t+1]:this.rowPartitionTypes[t]}getRowPartitionTensor(t){return this.rowPartitionTypes[0]===Us.FIRST_DIM_SIZE?this.rowPartitionValues[t+1]:this.rowPartitionValues[t]}getMaxWidth(t){const e=this.getRowPartitionTensor(t-1);switch(this.getRowPartitionTypeByDimension(t-1)){case Us.VALUE_ROWIDS:return ox.getMaxWidthValueRowID(e);case Us.ROW_SPLITS:return ox.getMaxWidthRowSplit(e);default:throw new Error(`Cannot handle partition type ${Us[this.getRowPartitionTypeByDimension(t-1)]}`)}}static getMaxWidthRowSplit(t){const e=t.length;if(0===e||1===e)return 0;let r=0;for(let i=0;i<e-1;++i){const o=t[i+1]-t[i];o>r&&(r=o)}return r}static getMaxWidthValueRowID(t){const e=t.length;if(0===e)return 0;let r=0,i=t[0],o=0;for(let s=1;s<e;++s){const a=t[s];a!==i&&(i=a,o=Math.max(s-r,o),r=s)}return Math.max(e-r,o)}tensorShapeFromTensor(t,e,r=!0){if(0===e.length){if(-1===t[0])return[];throw new Error("The only valid scalar shape tensor is the fully unknown shape specified as -1.")}return jU(t,r)}calculateOutputSize(t){const e=this.valuesShape;vV(this.defaultValueShape,e);const i=this.tensorShapeFromTensor(this.shape,this.shapeShape),s=bV(this.raggedRank,i,e);s[0]<0&&(s[0]=t);for(let a=1;a<=this.raggedRank;++a)s[a]<0&&(s[a]=this.getMaxWidth(a));return s}calculateFirstParentOutputIndex(t,e,r){const i=Math.min(t,r),o=[];let s=0;for(let a=0;a<i;++a,s+=e)o.push(s);for(let a=i;a<t;++a)o.push(-1);return Z(o.length===t,()=>"Final length of result must be equal to firstDimension."),o}calculateOutputIndexRowSplit(t,e,r,i){const o=t.length,s=[];for(let a=0;a<o-1;++a){const c=t[a+1]-t[a];let u=Math.min(i,c),p=e[a];-1===p&&(u=0);for(let m=0;m<u;++m)s.push(p),p+=r;for(let m=0;m<c-u;++m)s.push(-1)}if(o>0&&s.length!==t[o-1])throw new Error("Invalid row split size.");return s}calculateOutputIndexValueRowID(t,e,r,i){const o=t.length,s=[];if(0===o)return[];let a=0,c=t[0];if(c>=e.length)throw new Error(`Got currentValueRowId=${c}, which is not less than ${e.length}`);let u=e[c];s.push(u);for(let p=1;p<o;++p){const m=t[p];if(m===c)u>=0&&(++a,a<i?u+=r:u=-1);else{if(a=0,c=m,m>=e.length)throw new Error(`Got nextValueRowId=${m} which is not less than ${e.length}`);u=e[m]}s.push(u)}if(s.length!==t.length)throw new Error("Invalid row ids.");return s}calculateOutputIndex(t,e,r,i){const o=this.getRowPartitionTensor(t),s=this.getRowPartitionTypeByDimension(t);switch(s){case Us.VALUE_ROWIDS:return this.calculateOutputIndexValueRowID(o,e,r,i);case Us.ROW_SPLITS:if(o.length-1>e.length)throw new Error(`Row partition size is greater than output size: ${o.length-1} > ${e.length}`);return this.calculateOutputIndexRowSplit(o,e,r,i);default:throw new Error(`Unsupported partition type: ${Us[s]}`)}}getFirstDimensionSize(){const t=this.rowPartitionValues[0];if(0===this.rowPartitionTypes.length)throw new Error("No row_partition_types given.");const e=this.rowPartitionTypes[0];switch(e){case Us.FIRST_DIM_SIZE:return t[0];case Us.VALUE_ROWIDS:throw new Error("Cannot handle VALUE_ROWIDS in first dimension.");case Us.ROW_SPLITS:return this.rowPartitionValuesShapes[0][0]-1;default:throw new Error(`Cannot handle type ${Us[e]}`)}}compute(){if(this.rowPartitionValues[0].length<=0)throw new Error("Invalid first partition input. Tensor requires at least one element.");const e=this.getFirstDimensionSize(),r=this.calculateOutputSize(e),i=new Array(this.raggedRank+1);i[i.length-1]=1;for(let c=i.length-2;c>=0;--c)i[c]=i[c+1]*r[c+1];const o=jU(r,!1),s=Or(this.valuesDType,Me(o));if(i[0]*r[0]>0){let c=this.calculateFirstParentOutputIndex(e,i[0],r[0]);for(let u=1;u<=this.raggedRank;++u)c=this.calculateOutputIndex(u-1,c,i[u],r[u]);this.setOutput(this.raggedRank,c,s,o)}return[o,s]}setOutput(t,e,r,i){if(0===r.length)return;const o=this.values,s=r;let a=i.slice();a=a.slice(t+1);const c=Me(a),u=e.length;let p=this.defaultValue;if(p.length!==c&&1!==p.length){const x=this.defaultValueShape;Se(()=>{const T=be(p,x);p=Fh(T,a).dataSync()})}let m=0,g=0,_=0;for(let x=0;x<=u;++x){let T=x<u?e[x]:-1;if(T!==_){if(g<_){const I=o.subarray(m*c);UU(s.subarray(g*c),I,(_-g)*c)}if(x>=u&&(T=Math.floor(r.length/c)),T>_)if(1===this.defaultValue.length)s.subarray(_*c,T*c).fill(this.defaultValue[0]),_=T;else for(;T>_;)UU(s.slice(_*c),p,c),++_;T<0?(m=x+1,g=_):(m=x,g=_,_=g+1)}else++_}}}function UU(n,t,e){for(let r=0;r<e;r++)n[r]=t[r]}function jU(n,t){const e=[];for(let r of n){if(r<0){if(!t)throw new Error(`Dimension ${r} must be >= 0`);if(r<-1)throw new Error(`Dimension ${r} must be >= -1`);r=-1}e.push(r)}return e}function GU(n,t,e,r,i,o,s,a,c,u){return new ox(n,t,e,r,i,o,s,a,c,u).compute()}const Tve={kernelName:tI,backendName:"cpu",kernelFunc:function wve(n){const{inputs:t,backend:e,attrs:r}=n,{shape:i,values:o,defaultValue:s,rowPartitionTensors:a}=t,{rowPartitionTypes:c}=r,u=e.data.get(i.dataId).values,p=e.data.get(o.dataId).values,m=e.data.get(s.dataId).values,g=a.map(I=>e.data.get(I.dataId).values),_=a.map(I=>I.shape),[x,T]=GU(u,i.shape,p,o.shape,o.dtype,m,s.shape,g,_,c);return e.makeTensorInfo(x,o.dtype,T)}};function HU(n,t,e,r){if(n===t||n<t&&e<0||t<n&&e>1)return Ui(0,r);const c=Ui(Math.abs(Math.ceil((t-n)/e)),r);t<n&&1===e&&(e=-1),c[0]=n;for(let u=1;u<c.length;u++)c[u]=c[u-1]+e;return c}const Cve={kernelName:nI,backendName:"cpu",kernelFunc:function Sve(n){const{backend:t,attrs:e}=n,{start:r,stop:i,dtype:o,step:s}=e,a=HU(r,i,s,o);return t.makeTensorInfo([a.length],o,a)}},Ive=$n($m,n=>1/n),Eve={kernelName:$m,backendName:"cpu",kernelFunc:Ive},kve={kernelName:S0,backendName:"cpu",kernelFunc:function Dve(n){const{inputs:t,backend:e,attrs:r}=n,{images:i}=t,{alignCorners:o,halfPixelCenters:s,size:a}=r;Ct(i,"resizeBilinear");const c=Rt(i.shape),[u,p]=a,[m,g,_,x]=i.shape,T=e.data.get(i.dataId).values,I=new Float32Array(Me([m,u,p,x])),N=[o&&u>1?g-1:g,o&&p>1?_-1:_],R=[o&&u>1?u-1:u,o&&p>1?p-1:p];let L=0;const V=N[0]/R[0],j=N[1]/R[1];for(let Y=0;Y<m;Y++)for(let ee=0;ee<u;ee++){let ie;ie=s?V*(ee+.5)-.5:V*ee;const ce=Math.max(0,Math.floor(ie)),he=ie-ce,we=Math.min(g-1,Math.ceil(ie)),Ee=Y*c[0]+ce*c[1],Ae=Y*c[0]+we*c[1];for(let Oe=0;Oe<p;Oe++){let Re;Re=s?j*(Oe+.5)-.5:j*Oe;const _e=Math.max(0,Math.floor(Re)),Te=Re-_e,xe=Math.min(_-1,Math.ceil(Re)),De=Ee+_e*c[2],je=Ae+_e*c[2],We=Ee+xe*c[2],Je=Ae+xe*c[2];for(let Ze=0;Ze<x;Ze++){const et=T[De+Ze],rt=T[je+Ze],Ot=et+(T[We+Ze]-et)*Te;I[L++]=Ot+(rt+(T[Je+Ze]-rt)*Te-Ot)*he}}}return e.makeTensorInfo([m,u,p,x],"float32",I)}},Nve={kernelName:oI,backendName:"cpu",kernelFunc:function Ave(n){const{inputs:t,backend:e,attrs:r}=n,{images:i,dy:o}=t,{alignCorners:s}=r;Ct([o,i],"resizeBilinearGrad");const a=Rt(i.shape),[c,u,p,m]=i.shape,[,g,_]=o.shape,x=new Float32Array(c*u*p*m),T=[s&&g>1?u-1:u,s&&_>1?p-1:p],I=[s&&g>1?g-1:g,s&&_>1?_-1:_],N=T[0]/I[0],R=T[1]/I[1],L=e.data.get(o.dataId).values;let V=0;for(let j=0;j<c;j++){const Y=j*a[0];for(let ee=0;ee<g;ee++){const ie=ee*N,ce=Math.floor(ie),he=Math.min(Math.ceil(ie),u-1),we=Y+ce*a[1],Ee=Y+he*a[1],Ae=ie-ce,Oe=1-Ae;for(let Re=0;Re<_;Re++){const _e=Re*R,Te=Math.floor(_e),xe=Math.min(Math.ceil(_e),p-1),De=_e-Te,je=1-De,We=we+Te*a[2],Je=we+xe*a[2],Ze=Ee+Te*a[2],et=Ee+xe*a[2],rt=Oe*je,bt=Oe*De,pt=Ae*je,Ot=Ae*De;for(let Tt=0;Tt<m;Tt++){const Wt=L[V++];x[We+Tt]+=Wt*rt,x[Je+Tt]+=Wt*bt,x[Ze+Tt]+=Wt*pt,x[et+Tt]+=Wt*Ot}}}}return e.makeTensorInfo([c,p,u,m],"float32",x)}},Rve={kernelName:T0,backendName:"cpu",kernelFunc:function Ove(n){const{inputs:t,backend:e,attrs:r}=n,{images:i}=t,{alignCorners:o,halfPixelCenters:s,size:a}=r;Ct(i,"resizeNearestNeighbor");const c=Rt(i.shape),[u,p]=a,[m,g,_,x]=i.shape,T=e.data.get(i.dataId).values,I=new Float32Array(m*u*p*x),N=[o&&u>1?g-1:g,o&&p>1?_-1:_],R=[o&&u>1?u-1:u,o&&p>1?p-1:p],L=N[0]/R[0],V=N[1]/R[1];let j=0;for(let Y=0;Y<m;Y++){const ee=Y*c[0];for(let ie=0;ie<u;ie++){const ce=s?L*(ie+.5):L*ie;let he=Math.min(g-1,o?Math.round(ce):Math.floor(ce));s&&(he=Math.max(0,he));const we=ee+he*c[1];for(let Ee=0;Ee<p;Ee++){const Ae=s?V*(Ee+.5):V*Ee;let Oe=Math.min(_-1,o?Math.round(Ae):Math.floor(Ae));s&&(Oe=Math.max(0,Oe));const Re=we+Oe*c[2];for(let _e=0;_e<x;_e++)I[j++]=T[Re+_e]}}}return e.makeTensorInfo([m,u,p,x],i.dtype,I)}},Fve={kernelName:iI,backendName:"cpu",kernelFunc:function Mve(n){const{inputs:t,backend:e,attrs:r}=n,{images:i,dy:o}=t,{alignCorners:s}=r;Ct([o,i],"resizeNearestNeighborGrad");const a=Rt(i.shape),c=Rt(o.shape),[u,p,m,g]=i.shape,[,_,x]=o.shape,T=new Float32Array(u*p*m*g),I=e.data.get(o.dataId).values,N=[s&&_>1?p-1:p,s&&x>1?m-1:m],R=[s&&_>1?_-1:_,s&&x>1?x-1:x],L=N[0]/R[0],V=N[1]/R[1],j=1/L,Y=1/V,ee=2*Math.ceil(j)+2,ie=2*Math.ceil(Y)+2;for(let ce=0;ce<u;ce++){const he=ce*a[0];for(let we=0;we<p;we++){const Ee=he+we*a[1],Ae=Math.floor(we*j),Oe=Math.floor(Ae-ee/2);for(let Re=0;Re<m;Re++){const _e=Ee+Re*a[2],Te=Math.floor(Re*Y),xe=Math.floor(Te-ie/2);for(let De=0;De<g;De++){let je=0;for(let We=0;We<ee;We++){const Je=We+Oe;if(Je<0||Je>=_)continue;const Ze=he+Je*c[1],et=Je*L;if(we===Math.min(p-1,s?Math.round(et):Math.floor(et)))for(let bt=0;bt<ie;bt++){const pt=bt+xe;if(pt<0||pt>=x)continue;const Ot=Ze+pt*c[2],Tt=pt*V;Re===Math.min(m-1,s?Math.round(Tt):Math.floor(Tt))&&(je+=I[Ot+De])}}T[_e+De]=je}}}}return e.makeTensorInfo(i.shape,i.dtype,T)}},$ve={kernelName:C0,backendName:"cpu",kernelFunc:function Pve(n){const{inputs:t,backend:e,attrs:r}=n,{x:i}=t,{dims:o}=r;Ct(i,"reverse");const s=i.shape.length,a=cn(o,i.shape);if(0===s)return Ka({inputs:{x:i},backend:e});const c=new Jr(i.shape,i.dtype),u=e.bufferSync(i);for(let p=0;p<c.size;p++){const m=c.indexToLoc(p),g=m.slice();a.forEach(_=>g[_]=i.shape[_]-1-g[_]),c.set(u.get(...g),...m)}return e.makeTensorInfo(c.shape,c.dtype,c.values)}},Lve={kernelName:wI,backendName:"cpu",kernelFunc:({inputs:n,attrs:t,backend:e})=>{const{image:r}=n,{radians:i,fillValue:o,center:s}=t,a=e,c=Ei(r.dtype,Me(r.shape)),[u,p,m,g]=r.shape,[_,x]=nD(s,p,m),I=Math.sin(i),N=Math.cos(i),R=a.data.get(r.dataId).values;for(let V=0;V<u;V++){const j=V*m*p*g;for(let Y=0;Y<p;Y++){const ee=Y*(m*g);for(let ie=0;ie<m;ie++){const ce=ie*g;for(let he=0;he<g;he++){const we=[u,Y,ie,he],Ee=we[2],Ae=we[1];let Oe=(Ee-_)*N-(Ae-x)*I,Re=(Ee-_)*I+(Ae-x)*N;Oe=Math.round(Oe+_),Re=Math.round(Re+x);let _e=o;"number"!=typeof o&&(_e=3===he?255:o[he]),Oe>=0&&Oe<m&&Re>=0&&Re<p&&(_e=R[j+Re*(m*g)+Oe*g+he]),c[j+ee+ce+he]=_e}}}}return{dataId:a.write(c,r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}},Bve=$n(Vm,n=>{const t=Math.floor(n);return n-t<.5?Math.floor(n):n-t>.5?Math.ceil(n):t%2==0?t:t+1}),Vve={kernelName:Vm,backendName:"cpu",kernelFunc:Bve},WU=qa(n=>1/Math.sqrt(n)),zve=Fc(zm,WU),Uve={kernelName:zm,backendName:"cpu",kernelFunc:zve};function Xu(n,t,e,r,i,o,s,a,c,u){const p=[r/i,i],m=n.values,g=t.values;if(0===r)return sn(e,t.dtype);const _=c instanceof Jr?c:sn(p,t.dtype);"string"==typeof c||"number"==typeof c?_.values.fill(c):"boolean"==typeof c&&_.values.fill(+c);for(let x=0;x<o;x++){const T=[];let I=0;for(let N=0;N<s;N++){const R=m[x*s+N];T.push(R),I+=R*a[N]}if(I<0||I>=r/i)throw new Error(`Invalid indices: ${T} does not index into ${e}`);for(let N=0;N<i;N++)u?_.values[I*i+N]+=g[x*i+N]:_.values[I*i+N]=0===t.rank?g[0]:g[x*i+N]}return _}const Gve={kernelName:sI,backendName:"cpu",kernelFunc:function jve(n){const{inputs:t,backend:e,attrs:r}=n,{indices:i,updates:o}=t,{shape:s}=r,{sliceRank:a,numUpdates:c,sliceSize:u,strides:p,outputSize:m}=Lu(0,i,s),T=Xu(e.bufferSync(i),e.bufferSync(o),s,m,u,c,a,p,0,!0);return e.makeTensorInfo(s,T.dtype,T.values)}};function Hve(n,t){let e=0,r=n.length,i=0;for(;e<r;)i=Math.floor((e+r)/2),n[i]<t?e=i+1:r=i;return r}function Wve(n,t){let e=0,r=n.length,i=0;for(;e<r;)i=Math.floor((e+r)/2),n[i]<=t?e=i+1:r=i;return r}const Xve={kernelName:lI,backendName:"cpu",kernelFunc:function Kve(n){const{inputs:t,backend:e,attrs:r}=n,{sortedSequence:i,values:o}=t,{side:s}=r,u=function qve(n,t,e,r,i,o){const s=Or("int32",e*i);for(let a=0;a<e;++a){const c=n.slice(a*r,(a+1)*r),u=a*i;for(let p=0;p<i;++p)s[u+p]="left"===o?Hve(c,t[p+u]):Wve(c,t[p+u])}return s}(e.data.get(i.dataId).values,e.data.get(o.dataId).values,i.shape[0],i.shape[1],o.shape[1],s);return e.makeTensorInfo(o.shape,"int32",u)}},Zve={kernelName:I0,backendName:"cpu",kernelFunc:function Yve(n){const{inputs:t,backend:e}=n,{condition:r,t:i,e:o}=t;Ct([r,i,o],"select");const s=r.shape.length,a=e.data.get(r.dataId).values,c=e.data.get(i.dataId).values,u=e.data.get(o.dataId).values,p=zo(i.dtype,o.dtype),m=Ui(Me(i.shape),p);let g=0;const _=0===s||s>1||1===i.shape.length?1:Me(i.shape.slice(1));for(let x=0;x<a.length;x++)for(let T=0;T<_;T++)m[g++]=1===a[x]?c[x]:u[x];return e.makeTensorInfo(i.shape,p,m)}},Qve=xv,Jve=wv,exe=$n(Um,n=>n>=0?Jve*n:Qve*(Math.exp(n)-1)),txe={kernelName:Um,backendName:"cpu",kernelFunc:exe},nxe=$n(Hm,n=>n<0?-1:n>0?1:0),rxe={kernelName:Hm,backendName:"cpu",kernelFunc:nxe},ixe=$n(jm,n=>Math.sin(n)),oxe={kernelName:jm,backendName:"cpu",kernelFunc:ixe},sxe=$n(Gm,n=>Math.sinh(n)),axe={kernelName:Gm,backendName:"cpu",kernelFunc:sxe},qU=Math.log(1.1920928955078125e-7)+2,lxe=$n(qm,n=>{const t=n>-qU,e=n<qU,r=Math.exp(n);let i;return i=e?r:t?n:Math.log(1+r),i}),cxe={kernelName:qm,backendName:"cpu",kernelFunc:lxe},dxe={kernelName:k0,backendName:"cpu",kernelFunc:function uxe(n){const{inputs:t,backend:e,attrs:r}=n,{x:i}=t,{blockShape:o,paddings:s}=r;Ct([i],"spaceToBatchND");const a=Me(o),c=[[0,0]];c.push(...s);for(let Y=1+o.length;Y<i.shape.length;++Y)c.push([0,0]);const u=PU.kernelFunc({inputs:{x:i},backend:e,attrs:{paddings:c,constantValue:0}}),p=vg(u.shape,o,a,!1),m=xg(p.length,o.length,!1),g=wg(u.shape,o,a,!1),T=Yn({inputs:{x:u},backend:e,attrs:{shape:p}}),R=Eo({inputs:{x:T},backend:e,attrs:{perm:m}}),j=Yn({inputs:{x:R},backend:e,attrs:{shape:g}});return e.disposeIntermediateTensorInfo(u),e.disposeIntermediateTensorInfo(T),e.disposeIntermediateTensorInfo(R),j}};function KU(n,t,e,r,i,o,s){const a=t[0],c=o[0],u=new Array(c),p=new Array(a),m=t[1];if(0===c){if(0!==a)throw new Error(kV(a));return[Or(e,0),[0,m],Or(i,0),u,p]}let g=!0,_=0;const x=new Array(c).fill(0);for(let I=0;I<a;++I){const N=n[I*m];if(N<0)throw new Error(AV(I,N));if(N>=c)throw new Error(NV(I,N,c));++x[N],g=g&&N>=_,_=N}let T=!0;for(let I=0;I<c;++I){const N=0===x[I];u[I]=N,T=T&&!N,x[I]=Math.max(x[I],1),I>0&&(x[I]+=x[I-1])}if(T&&g){const I=n,N=r;for(let R=0;R<a;++R)p[R]=R;return[I,[a,m],N,u,p]}{const I=x[c-1],N=Or(e,I*m),R=Or(i,I),L=new Array(c).fill(0);for(let V=0;V<a;++V){const j=n[V*m],ee=(0===j?0:x[j-1])+L[j];L[j]++;for(let ie=0;ie<m;++ie)N[ee*m+ie]=n[V*m+ie];R[ee]=r[V],p[V]=ee}for(let V=0;V<c;++V)if(0===L[V]){const Y=0===V?0:x[V-1];N[Y*m+0]=V;for(let ee=1;ee<m;++ee)N[Y*m+ee]=0;R[Y]=s}return[N,[I,m],R,u,p]}}const pxe={kernelName:cI,backendName:"cpu",kernelFunc:function hxe(n){const{inputs:t,backend:e}=n,{indices:r,values:i,denseShape:o,defaultValue:s}=t;if(1!==o.shape.length)throw new Error(`Dense shape must be a vector, saw:\n        ${o.shape}`);if(2!==r.shape.length)throw new Error(`Indices must be a matrix, saw:\n        ${r.shape}`);if(1!==i.shape.length)throw new Error(`Values must be a vector, saw:\n        ${i.shape}`);if(0!==s.shape.length)throw new Error(`Default value must be a scalar, saw:\n        ${s.shape}`);const a=e.data.get(r.dataId).values,c=e.data.get(i.dataId).values,u=e.data.get(o.dataId).values,p=e.data.get(s.dataId).values[0],[m,g,_,x,T]=KU(a,r.shape,r.dtype,c,i.dtype,u,p);return[e.makeTensorInfo(g,r.dtype,m),e.makeTensorInfo([g[0]],i.dtype,_),e.makeTensorInfo([x.length],"bool",new Uint8Array(x.map(I=>Number(I)))),e.makeTensorInfo([T.length],r.dtype,new Int32Array(T))]}};function XU(n,t,e,r,i){const o=Me(r),s=t[0],a=i.length,c=[];let u=1,p=-1;for(let I=0;I<a;++I){const N=i[I];if(-1===N){if(-1!==p)throw new Error(OV(p,I));p=I,c.push(1)}else{if(N<0)throw new Error(RV(I,N));u*=N,c.push(N)}}if(-1!==p){if(u<=0)throw new Error("reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero");const I=Math.trunc(o/u);if(u*I!==o)throw new Error(FV(r,c));c[p]=I}if(Me(c)!==o)throw new Error(PV(r,c));const g=r.length,_=[];if(g>0){_[g-1]=1;for(let I=g-2;I>=0;--I)_[I]=_[I+1]*r[I+1]}const x=[];if(a>0){x[a-1]=1;for(let I=a-2;I>=0;--I)x[I]=x[I+1]*c[I+1]}const T=Or(e,s*a);for(let I=0;I<s;++I){let N=0;for(let R=0;R<g;++R)N+=n[I*g+R]*_[R];for(let R=0;R<a;++R)T[I*a+R]=Math.trunc(N/x[R]),N%=x[R]}return[T,[s,a],c]}const mxe={kernelName:uI,backendName:"cpu",kernelFunc:function fxe(n){const{inputs:t,backend:e}=n,{inputIndices:r,inputShape:i,newShape:o}=t;if(2!==r.shape.length)throw new Error(`Input indices should be a matrix but received shape\n        ${r.shape}`);if(1!==i.shape.length)throw new Error(`Input shape should be a vector but received shape\n        ${i.shape}`);if(1!==o.shape.length)throw new Error(`Target shape should be a vector but received shape ${o.shape}`);const s=Array.from(e.data.get(i.dataId).values),a=e.data.get(r.dataId).values,c=Array.from(e.data.get(o.dataId).values),[u,p,m]=XU(a,r.shape,r.dtype,s,c);return[e.makeTensorInfo(p,r.dtype,u),e.makeTensorInfo([m.length],o.dtype,new Int32Array(m))]}};function Uk(n,t,e,r,i,o=!1,s=0){const a=r.length,c=[t[0],n.length/t[0]],u=c[1],m=a>0?i[a-1]+1:0;if(m<0)throw new Error("segment ids must be >= 0");const g=t.slice();g[0]=m;const x=Or(e,g.reduce((L,V)=>L*V,1));if(0===a)return m>0&&x.fill(s),[x,g];if(m<=0)throw new Error("segment ids must be >= 0");let T=0,I=1,N=0,R=i[T];for(;;){let L=0;if(I<a){if(L=i[I],R===L){++I;continue}if(R>=L)throw new Error("segment ids are not increasing")}if(R<0||R>=m)throw new Error(LV(R,m));R>N&&x.fill(s,N*u,R*u);for(let V=T;V<I;++V){const j=r[V];if(j<0||j>=c[0])throw new Error(BV(V,r[V],c[0]));for(let Y=0;Y<u;Y++)x[R*u+Y]+=n[j*u+Y]}if(o)for(let V=0;V<u;V++)x[R*u+V]/=I-T;if(T=I,++I,N=R+1,R=L,I>a)break}return N<m&&x.fill(s,N*u,m*u),[x,g]}const bxe={kernelName:dI,backendName:"cpu",kernelFunc:function gxe(n){const{inputs:t,backend:e}=n,{data:r,indices:i,segmentIds:o}=t;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==i.shape.length)throw new Error(`Indices should be a vector but received shape\n          ${i.shape}`);if(1!==o.shape.length)throw new Error(`Segment ids should be a vector but received shape\n          ${o.shape}`);if(i.shape[0]!==o.shape[0])throw new Error("segmentIds and indices should have same size.");const s=e.data.get(r.dataId).values,a=e.data.get(i.dataId).values,c=e.data.get(o.dataId).values,[u,p]=Uk(s,r.shape,r.dtype,a,c,!0);return e.makeTensorInfo(p,r.dtype,u)}},_xe={kernelName:hI,backendName:"cpu",kernelFunc:function yxe(n){const{inputs:t,backend:e}=n,{data:r,indices:i,segmentIds:o}=t;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==i.shape.length)throw new Error(`Indices should be a vector but received shape\n         ${i.shape}`);if(1!==o.shape.length)throw new Error(`Segment ids should be a vector but received shape\n         ${o.shape}`);if(i.shape[0]!==o.shape[0])throw new Error("segmentIds and indices should have same size.");const s=e.data.get(r.dataId).values,a=e.data.get(i.dataId).values,c=e.data.get(o.dataId).values,[u,p]=Uk(s,r.shape,r.dtype,a,c);return e.makeTensorInfo(p,r.dtype,u)}},xxe={kernelName:pI,backendName:"cpu",kernelFunc:function vxe(n){const{inputs:t,backend:e,attrs:r}=n,{sparseIndices:i,sparseValues:o,defaultValue:s}=t,{outputShape:a}=r,{sliceRank:c,numUpdates:u,sliceSize:p,strides:m,outputSize:g}=Lu(0,i,a),_=!1,x=e.bufferSync(i);let T;switch(o.dtype){case"bool":T=Xu(x,e.bufferSync(o),a,g,p,u,c,m,!!e.data.get(s.dataId).values[0],_);break;case"float32":case"int32":T=Xu(x,e.bufferSync(o),a,g,p,u,c,m,e.data.get(s.dataId).values[0],_);break;case"string":T=Xu(x,e.bufferSync(o),a,g,p,u,c,m,uc(e.data.get(s.dataId).values[0]),_);break;default:throw new Error(`Unsupported type ${o.dtype}`)}return e.makeTensorInfo(a,T.dtype,T.values)}},Txe={kernelName:A0,backendName:"cpu",kernelFunc:function wxe(n){const{inputs:t,backend:e,attrs:r}=n,{x:i}=t,{numOrSizeSplits:o,axis:s}=r,a=cn(s,i.shape)[0],c=_D(i,o,a),u=new Array(i.shape.length).fill(0),p=i.shape.slice();return c.map(m=>{const g=[...p];g[a]=m;const _=Ku({inputs:{x:i},backend:e,attrs:{begin:u,size:g}});return u[a]+=m,_})}},Sxe=qa(n=>Math.sqrt(n)),Cxe=$n(Km,n=>Math.sqrt(n)),Ixe={kernelName:Km,backendName:"cpu",kernelFunc:Cxe},Exe={kernelName:fI,backendName:"cpu",kernelFunc:({inputs:n,backend:t})=>{const{x:e}=n,r=t;Ct(e,"square");const i=r.data.get(e.dataId).values,o=new Float32Array(i.length);for(let a=0;a<i.length;++a){const c=i[a];o[a]=c*c}return{dataId:r.write(o,e.shape,e.dtype),shape:e.shape,dtype:e.dtype}}},Dxe=Pr((n,t)=>{const e=n-t;return e*e}),kxe=ai(Xm,Dxe),Axe={kernelName:Xm,backendName:"cpu",kernelFunc:kxe},YU=qa((n,t)=>{const{pattern:e,replaceGlobal:r,rewrite:i}=t;return n.replace(new RegExp(e,r?"g":""),i)}),Nxe=Fc(O0,YU),Oxe={kernelName:O0,backendName:"cpu",kernelFunc:Nxe},Rxe=$n(eg,(n,t)=>{const e=t;return isNaN(n)?NaN:n>0?1:e.alpha}),Mxe={kernelName:eg,backendName:"cpu",kernelFunc:Rxe};function ZU(n,t,e,r){const i=sn(n,t.dtype);for(let o=0;o<i.size;o++){const s=i.indexToLoc(o),a=new Array(s.length);for(let c=0;c<a.length;c++)a[c]=s[c]*e[c]+r[c];i.set(t.get(...a),...s)}return i}const Pxe={kernelName:mI,backendName:"cpu",kernelFunc:function Fxe(n){const{inputs:t,backend:e,attrs:r}=n,{x:i}=t,{begin:o,end:s,strides:a,beginMask:c,endMask:u,ellipsisMask:p,newAxisMask:m,shrinkAxisMask:g}=r;Ct(i,"stridedSlice");const{finalShapeSparse:_,finalShape:x,isIdentity:T,sliceDim0:I,isSimpleSlice:N,begin:R,end:L,strides:V}=sE(i.shape,o,s,a,c,u,p,m,g);let j;if(T)j=Yn({inputs:{x:i},backend:e,attrs:{shape:x}});else if(I||N){Z(i.shape.length>=1,()=>`Input must have rank at least 1, got: ${i.shape.length}`);const Y=rE(R,L,V),ee=Ku({inputs:{x:i},backend:e,attrs:{begin:R,size:Y}});j=Yn({inputs:{x:ee},backend:e,attrs:{shape:x}}),e.disposeIntermediateTensorInfo(ee)}else{const ee=ZU(_,e.bufferSync(i),V,R);j=e.makeTensorInfo(x,ee.dtype,ee.values)}return j}};class $xe{constructor(t,e,r,i,o,s){this.separator=cc(t),this.nGramWidths=e,this.leftPad=cc(r),this.rightPad=cc(i),this.padWidth=o,this.preserveShort=s}getPadWidth(t){return Math.min(this.padWidth<0?t-1:this.padWidth,t-1)}getNumNGrams(t,e){const r=this.getPadWidth(e);return Math.max(0,t+2*r-e+1)}createNGrams(t,e,r,i,o,s){for(let a=0;a<o;++a){const c=this.getPadWidth(s),u=Math.max(0,c-a),p=Math.max(0,c-(o-(a+1))),m=s-(u+p),g=e+(u>0?0:a-c);let _=0;_+=u*this.leftPad.length;for(let R=0;R<m;++R)_+=t[g+R].length;_+=p*this.rightPad.length,_+=(u+p+m-1)*this.separator.length,r[i+a]=new Uint8Array(_);const T=r[i+a];let I=0;const N=R=>R.forEach(L=>T[I++]=L);for(let R=0;R<u;++R)N(this.leftPad),N(this.separator);for(let R=0;R<m-1;++R)N(t[g+R]),N(this.separator);if(m>0){N(t[g+m-1]);for(let R=0;R<p;++R)N(this.separator),N(this.rightPad)}else{for(let R=0;R<p-1;++R)N(this.rightPad),N(this.separator);N(this.rightPad)}}}compute(t,e){const r=t.length,i=e.length;if(i>0){let c=e[0];if(0!==c)throw new Error(`First split value must be 0, got ${c}`);for(let u=1;u<i;++u){let p=e[u]>=c;if(p=p&&e[u]<=r,!p)throw new Error(`Invalid split value ${e[u]}, must be in [${c}, ${r}]`);c=e[u]}if(c!==r)throw new Error(`Last split value must be data size. Expected ${r}, got ${c}`)}const o=i-1,s=Or("int32",i);if(0===r||0===i){const c=new Array(r);for(let u=0;u<=o;++u)s[u]=0;return[c,s]}s[0]=0;for(let c=1;c<=o;++c){const u=e[c]-e[c-1];let p=0;this.nGramWidths.forEach(m=>{p+=this.getNumNGrams(u,m)}),this.preserveShort&&u>0&&0===p&&(p=1),s[c]=s[c-1]+p}const a=new Array(s[o]);for(let c=0;c<o;++c){const u=e[c];let p=s[c];if(this.nGramWidths.forEach(m=>{const _=this.getNumNGrams(e[c+1]-e[c],m);this.createNGrams(t,u,a,p,_,m),p+=_}),this.preserveShort&&p===s[c]){const m=e[c+1]-e[c];if(0===m)continue;this.createNGrams(t,u,a,p,1,m+2*this.padWidth)}}return[a,s]}}function QU(n,t,e,r,i,o,s,a){return new $xe(e,r,i,o,s,a).compute(n,t)}const Bxe={kernelName:gI,backendName:"cpu",kernelFunc:function Lxe(n){const{inputs:t,backend:e,attrs:r}=n,{separator:i,nGramWidths:o,leftPad:s,rightPad:a,padWidth:c,preserveShortSequences:u}=r,{data:p,dataSplits:m}=t,g=e.data.get(p.dataId).values,_=e.data.get(m.dataId).values,[x,T]=QU(g,_,i,o,s,a,c,u);return[e.makeTensorInfo([x.length],"string",x),e.makeTensorInfo(m.shape,"int32",T)]}};function Vxe(n,t,e,r){if(!n.length)return;if(0===t.length){for(let o=0;o<n.length;++o)r.push(n.subarray(o,o+1));return}if(1===t.length){const o=t[0];let s=n.indexOf(o);for(;-1!==s;){const a=n.subarray(0,s);(!e||0!==a.length)&&r.push(a),s=(n=n.subarray(s+1)).indexOf(o)}return void((!e||0!==n.length)&&r.push(n))}let i=0;for(let o=0;o<n.length+1;o++)if(o===n.length||-1!==t.indexOf(n[o])){const s=n.subarray(i,o);(!e||0!==s.length)&&r.push(s),i=o+1}}function JU(n,t,e){const r=n.length,i=[];let o=0,s=0;const a=new Array(r);for(let g=0;g<r;++g){const _=i.length;Vxe(n[g],t,e,i);const x=i.length-_;a[g]=x,o+=x,s=Math.max(s,x)}const c=Or("int32",2*o),u=new Array(o),p=[r,s];let m=0;for(let g=0;g<r;++g)for(let _=0;_<a[g];++_)c[2*m]=g,c[2*m+1]=_,u[m]=i[m],++m;return[c,u,p]}const Uxe={kernelName:bI,backendName:"cpu",kernelFunc:function zxe(n){const{inputs:t,backend:e,attrs:r}=n,{skipEmpty:i}=r,{input:o,delimiter:s}=t;if("string"!==o.dtype)throw new Error("Input must be of datatype string");if(1!==o.shape.length)throw new Error(`Input must be a vector, got shape: ${o.shape}`);if(0!==s.shape.length)throw new Error(`Delimiter must be a scalar, got shape: ${s.shape}`);const a=e.data.get(o.dataId).values,c=e.data.get(s.dataId).values[0],[u,p,m]=JU(a,c,i),g=p.length;return[e.makeTensorInfo([g,2],"int32",u),e.makeTensorInfo([g],"string",p),e.makeTensorInfo([2],"int32",new Int32Array(m))]}};function ej(n,t){const e=Or("int32",n.length);for(let r=0;r<n.length;++r)e[r]=Ire(n[r]).modulo(t).getLowBitsUnsigned();return e}const Gxe={kernelName:yI,backendName:"cpu",kernelFunc:function jxe(n){const{inputs:t,backend:e,attrs:r}=n,{numBuckets:i}=r,{input:o}=t;if("string"!==o.dtype)throw new Error("Input must be of datatype string");if(i<=0)throw new Error("Number of buckets must be at least 1");const a=ej(e.data.get(o.dataId).values,i);return e.makeTensorInfo(o.shape,"int32",a)}},Hxe=$n(Zm,n=>Math.tan(n)),Wxe={kernelName:Zm,backendName:"cpu",kernelFunc:Hxe},qxe=$n(Qm,n=>Math.tanh(n));function tj(n,t){const e=new Array(n.rank);for(let i=0;i<e.length;i++)e[i]=n.shape[i]*t[i];const r=sn(e,n.dtype);for(let i=0;i<r.values.length;++i){const o=r.indexToLoc(i),s=new Array(n.rank);for(let c=0;c<s.length;c++)s[c]=o[c]%n.shape[c];const a=n.locToIndex(s);r.values[i]=n.values[a]}return r}const Bg=(n,t)=>{const e=t.value-n.value;return 0===e?n.index-t.index:e};function nj(n,t,e=0,r=n.length-1){for(;r>e;){if(r-e>600){const a=r-e+1,c=t-e+1,u=Math.log(a),p=.5*Math.exp(2*u/3),m=.5*Math.sqrt(u*p*(a-p)/a)*Math.sign(c-a/2);nj(n,t,Math.max(e,Math.floor(t-c*p/a+m)),Math.min(r,Math.floor(t+(a-c)*p/a+m)))}const i=n[t];let o=e,s=r;for(oc(n,e,t),Bg(n[r],i)>0&&oc(n,e,r);o<s;){for(oc(n,o,s),o++,s--;Bg(n[o],i)<0;)o+=1;for(;Bg(n[s],i)>0;)s-=1}0===Bg(n[e],i)?oc(n,e,s):(s+=1,oc(n,s,r)),s<=t&&(e=s+1),t<=s&&(r=s-1)}}function rj(n,t,e,r,i){const o=t[t.length-1],[s,a]=[n.length/o,o],c=Ei(e,s*r),u=Ei("int32",s*r);for(let m=0;m<s;m++){const g=m*a,_=n.subarray(g,g+a);let x=new Array(_.length);_.forEach((R,L)=>x[L]={value:R,index:L}),r<x.length&&(nj(x,r),x=x.slice(0,r)),i&&x.sort(Bg);const T=m*r,I=c.subarray(T,T+r),N=u.subarray(T,T+r);for(let R=0;R<r;R++)I[R]=x[R].value,N[R]=x[R].index}const p=t.slice();return p[p.length-1]=r,[sn(p,e,c),sn(p,"int32",u)]}function ij(n,t,e){switch(e){case"reflect":return function rwe(n,t){let e=n;if(e<0)if(t<=1)e=0;else{const r=2*t;e<r&&(e=r*Math.trunc(-e/r)+e),e=e<-t?e+r:-e-1}else if(e>t-1)if(t<=1)e=0;else{const r=2*t;e-=r*Math.trunc(e/r),e>=t&&(e=r-e-1)}return Cu(0,e,t-1)}(n,t);case"wrap":return function iwe(n,t){let e=n;return e<0?t<=1?e=0:e+=t*(Math.trunc(-e/(t-1))+1):e>t-1&&(t<=1?e=0:e-=t*Math.trunc(e/(t-1))),Cu(0,e,t-1)}(n,t);case"nearest":return function swe(n,t){return Cu(0,n,t-1)}(n,t);default:return function owe(n,t){return n}(n)}}function Vg(n,t,e,r,i,o,s,a,c,u,p){return 0<=a&&a<t&&0<=c&&c<e?n[s*r+a*i+c*o+u]:p}function awe(n,t,e,r,i,o,s,a,c,u,p){return Vg(n,t,e,r,i,o,s,Math.round(a),Math.round(c),u,p)}function lwe(n,t,e,r,i,o,s,a,c,u,p){const m=Math.floor(a),g=Math.floor(c),_=m+1,x=g+1;return(_-a)*((x-c)*Vg(n,t,e,r,i,o,s,m,g,u,p)+(c-g)*Vg(n,t,e,r,i,o,s,m,x,u,p))+(a-m)*((x-c)*Vg(n,t,e,r,i,o,s,_,g,u,p)+(c-g)*Vg(n,t,e,r,i,o,s,_,x,u,p))}function oj(n,t,e,r){const i=cn(t,e)[0],o=[1,e[0],1];for(let x=0;x<i;x++)o[0]*=e[x];o[1]=e[i];for(let x=i+1;x<e.length;x++)o[2]*=e[x];const s=new Map,a=new Int32Array(e[i]),c=new Jr(o,r,n),u=[],p=1===o[0]&&1===o[2];for(let x=0;x<e[i];x++){let T;if(p)T=n[x].toString();else{const N=[];for(let R=0;R<o[0];R++)for(let L=0;L<o[2];L++)N.push(c.get(R,x,L));T=N.join(",")}const I=s.get(T);if(null!=I)a[x]=I;else{const N=s.size;s.set(T,N),a[x]=N,u.push(x)}}const m=o.slice();m[1]=s.size;const g=new Jr(m,r);u.forEach((x,T)=>{for(let I=0;I<o[0];I++)for(let N=0;N<o[2];N++)g.set(c.get(I,x,N),I,T,N)});const _=e.slice();return _[i]=m[1],{outputValues:g.values,outputShape:_,indices:a}}const mwe=[lbe,cbe,dbe,pbe,ibe,mbe,ybe,vbe,wbe,Sbe,Ibe,Dbe,Abe,Rbe,Fbe,Lbe,Vbe,Ube,Gbe,sbe,Wbe,Xbe,Zbe,eye,nye,nbe,iye,sye,ebe,aye,cye,uye,hye,fye,gye,yye,vye,wye,Sye,Iye,Dye,Aye,Oye,Mye,Fye,$ye,Bye,zye,Uye,jye,Gye,Xye,Hge,Zye,Qye,s_e,a_e,l_e,u_e,y_e,__e,x_e,T_e,I_e,D_e,A_e,O_e,M_e,P_e,L_e,Wge,V_e,lye,U_e,G_e,W_e,qge,K_e,Y_e,Q_e,e0e,n0e,o0e,a0e,u0e,h0e,f0e,m0e,b0e,_0e,x0e,T0e,C0e,E0e,k0e,N0e,R0e,F0e,L0e,z0e,Wye,j0e,W0e,X0e,Q0e,eve,nve,ive,ove,PU,cve,Xge,dve,_ve,xve,Tve,Cve,tbe,Lk,Eve,Yge,Zge,obe,kve,Nve,Rve,Fve,$ve,Lve,Vve,Uve,Gve,Xve,Zve,txe,Jge,rxe,oxe,axe,qbe,B0e,cxe,dxe,pxe,mxe,bxe,_xe,xxe,Txe,Ixe,Exe,Axe,Oxe,Mxe,Pxe,Bxe,Uxe,Gxe,p_e,qye,Wxe,{kernelName:Qm,backendName:"cpu",kernelFunc:qxe},{kernelName:aI,backendName:"cpu",kernelFunc:function Xxe(n){const{inputs:t,backend:e}=n,{tensor:r,indices:i,updates:o}=t,{sliceRank:s,numUpdates:a,sliceSize:c,strides:u,outputSize:p}=Lu(0,i,r.shape),g=e.bufferSync(i),_=e.bufferSync(o),x=e.bufferSync(r),T=Xu(g,_,r.shape,p,c,a,s,u,x,!1);return e.makeTensorInfo(r.shape,T.dtype,T.values)}},{kernelName:Jm,backendName:"cpu",kernelFunc:function Zxe(n){const{inputs:t,backend:e,attrs:r}=n,{x:i}=t,{reps:o}=r;Ct(i,"tile");const s=tj(e.bufferSync(i),o);return e.makeTensorInfo(s.shape,s.dtype,s.values)}},{kernelName:_I,backendName:"cpu",kernelFunc:function Jxe(n){const{inputs:t,backend:e,attrs:r}=n,{x:i}=t,{k:o,sorted:s}=r;Ct(i,"topk");const a=e.data.get(i.dataId).values,[c,u]=rj(a,i.shape,i.dtype,o,s);return[e.makeTensorInfo(c.shape,c.dtype,c.values),e.makeTensorInfo(u.shape,u.dtype,u.values)]}},{kernelName:vI,backendName:"cpu",kernelFunc:function twe(n){const{inputs:t,attrs:e,backend:r}=n,{image:i,transforms:o}=t,{interpolation:s,fillMode:a,fillValue:c,outputShape:u}=e,[p,m,g,_]=i.shape,[x,T]=u??[m,g],I=[p,x,T,_],N=Rt(i.shape),R=N[0],L=N[1],V=N[2],j=Rt(I),Y=j[0],ee=j[1],ie=j[2],ce=Ei(i.dtype,Me(I));ce.fill(c);const he=r.data.get(i.dataId).values,we=r.data.get(o.dataId).values;for(let Ae=0;Ae<p;++Ae){const Oe=1===o.shape[0]?we:we.subarray(8*Ae,8*Ae+8);for(let Re=0;Re<x;++Re)for(let _e=0;_e<T;++_e)for(let Te=0;Te<_;++Te){let xe;const De=Oe[6]*_e+Oe[7]*Re+1;if(0===De)continue;const We=(Oe[3]*_e+Oe[4]*Re+Oe[5])/De,Je=ij((Oe[0]*_e+Oe[1]*Re+Oe[2])/De,g,a),Ze=ij(We,m,a);switch(s){case"nearest":xe=awe(he,m,g,R,L,V,Ae,Ze,Je,Te,c);break;case"bilinear":xe=lwe(he,m,g,R,L,V,Ae,Ze,Je,Te,c);break;default:throw new Error(`Error in Transform: Expect 'nearest' or 'bilinear', but got ${s}`)}ce[Ae*Y+Re*ee+_e*ie+Te]=xe}return r.makeTensorInfo(I,i.dtype,ce)}return{dataId:r.write(ce,I,i.dtype),shape:i.shape,dtype:i.dtype}}},gbe,{kernelName:xI,backendName:"cpu",kernelFunc:function cwe(n){const{inputs:t,attrs:e,backend:r}=n,{axis:i}=e,{x:o}=t;Ct(o,"unique");const s=r.data.get(o.dataId).values,{outputValues:a,outputShape:c,indices:u}=oj(s,i,o.shape,o.dtype);return[r.makeTensorInfo(c,o.dtype,a),r.makeTensorInfo([u.length],"int32",u)]}},{kernelName:R0,backendName:"cpu",kernelFunc:function dwe(n){const{inputs:t,backend:e,attrs:r}=n,{value:i}=t;let{axis:o}=r;o<0&&(o+=i.shape.length);const s=i.shape.length,a=i.shape[o],c=new Array(s-1);let u=0;for(let _=0;_<s;_++)_!==o&&(c[u++]=i.shape[_]);const p=new Array(s).fill(0),m=i.shape.slice();m[o]=1;const g=new Array(a);for(let _=0;_<g.length;_++){p[o]=_;const x=Ku({inputs:{x:i},backend:e,attrs:{begin:p,size:m}});g[_]=Yn({inputs:{x},backend:e,attrs:{shape:c}}),e.disposeIntermediateTensorInfo(x)}return g}},{kernelName:M0,backendName:"cpu",kernelFunc:function pwe(n){const{inputs:t,backend:e,attrs:r}=n,{x:i,segmentIds:o}=t,{numSegments:s}=r;Ct(i,"unsortedSegmentSum");const u=[],p=[],m=i.shape.length-o.shape.length;let g=o;for(let x=0;x<m;++x){const T=rx({inputs:{input:g},backend:e,attrs:{dim:x+1}});g=T,p.push(T)}for(let x=0;x<s;++x){const T=lc(x,"int32"),I=e.makeTensorInfo([],"int32",T),N=hU({inputs:{a:I,b:g},backend:e}),R=Pc({inputs:{x:N},backend:e,attrs:{dtype:"float32"}}),L=nx({inputs:{a:R,b:i},backend:e}),V=Lg({inputs:{x:L},backend:e,attrs:{axis:0,keepDims:!1}});u.push(V),p.push(I),p.push(N),p.push(R),p.push(L),p.push(V)}const _=FU({inputs:u,backend:e,attrs:{axis:0}});return p.forEach(x=>e.disposeIntermediateTensorInfo(x)),_}},rve];for(const n of mwe)SI(n);const $c={},sx={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0};function ma(n,t){if(!(n in $c)||null!=t){const r=function ywe(n,t){if(1!==n&&2!==n)throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");const e=t??function bwe(n){if(!Ie().getBool("IS_SAFARI")&&typeof OffscreenCanvas<"u"&&2===n)return new OffscreenCanvas(300,150);if(typeof document<"u")return document.createElement("canvas");throw new Error("Cannot create a canvas in this context")}(n);return e.addEventListener("webglcontextlost",r=>{r.preventDefault(),delete $c[n]},!1),Ie().getBool("SOFTWARE_WEBGL_ENABLED")&&(sx.failIfMajorPerformanceCaveat=!1),1===n?e.getContext("webgl",sx)||e.getContext("experimental-webgl",sx):e.getContext("webgl2",sx)}(n,t);if(null===r)return console.log("Could not get context for WebGL version",n),null;$c[n]=r}const e=$c[n];return null==e||e.isContextLost()?(delete $c[n],ma(n)):(e.disable(e.DEPTH_TEST),e.disable(e.STENCIL_TEST),e.disable(e.BLEND),e.disable(e.DITHER),e.disable(e.POLYGON_OFFSET_FILL),e.disable(e.SAMPLE_COVERAGE),e.enable(e.SCISSOR_TEST),e.enable(e.CULL_FACE),e.cullFace(e.BACK),$c[n])}var Xa=(()=>((Xa=Xa||{})[Xa.DENSE=0]="DENSE",Xa[Xa.SHARED_BATCH=1]="SHARED_BATCH",Xa))(),$r=(()=>(($r=$r||{})[$r.RENDER=0]="RENDER",$r[$r.UPLOAD=1]="UPLOAD",$r[$r.PIXELS=2]="PIXELS",$r[$r.DOWNLOAD=3]="DOWNLOAD",$r))(),Un=(()=>((Un=Un||{})[Un.UNPACKED_FLOAT16=0]="UNPACKED_FLOAT16",Un[Un.UNPACKED_FLOAT32=1]="UNPACKED_FLOAT32",Un[Un.PACKED_4X1_UNSIGNED_BYTE=2]="PACKED_4X1_UNSIGNED_BYTE",Un[Un.PACKED_2X2_FLOAT32=3]="PACKED_2X2_FLOAT32",Un[Un.PACKED_2X2_FLOAT16=4]="PACKED_2X2_FLOAT16",Un))();function zg(n,t){return[t,n]}function ax(n){const t=Me(n);return cC(Math.ceil(t/4))}function Qh(n,t){return[Math.max(1,Math.ceil(t/2)),Math.max(1,Math.ceil(n/2))]}function jk(n,t){const e=n;let r,i,o,s,a,c,u,p,m,g;return 2===Ie().getNumber("WEBGL_VERSION")?(r=e.R32F,i=e.R16F,o=e.RGBA16F,s=e.RGBA32F,a=e.RED,u=4,p=1,m=e.HALF_FLOAT,g=e.FLOAT,c=e.RGBA8):(r=n.RGBA,i=n.RGBA,o=n.RGBA,s=e.RGBA,a=n.RGBA,u=4,p=4,m=null!=t?t.HALF_FLOAT_OES:null,g=n.FLOAT,c=n.RGBA),{internalFormatFloat:r,internalFormatHalfFloat:i,internalFormatPackedHalfFloat:o,internalFormatPackedFloat:s,textureFormatFloat:a,downloadTextureFormat:c,downloadUnpackNumChannels:u,defaultNumChannels:p,textureTypeHalfFloat:m,textureTypeFloat:g}}function dt(n,t){const e=t();return Ie().getBool("DEBUG")&&function xwe(n){const t=n.getError();if(t!==n.NO_ERROR)throw new Error("WebGL Error: "+function Cwe(n,t){switch(t){case n.NO_ERROR:return"NO_ERROR";case n.INVALID_ENUM:return"INVALID_ENUM";case n.INVALID_VALUE:return"INVALID_VALUE";case n.INVALID_OPERATION:return"INVALID_OPERATION";case n.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case n.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case n.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return`Unknown error code ${t}`}}(n,t))}(n),e}function Swe(n){return!!(Ie().getBool("WEBGL_RENDER_FLOAT32_ENABLED")||0===n||5.96e-8<Math.abs(n)&&Math.abs(n)<65504)}function lx(n,t){return Nl(n,()=>n.getExtension(t),'Extension "'+t+'" not supported on this browser.')}const Dwe=/ERROR: [0-9]+:([0-9]+):/g;function sj(n,t){const e=Dwe.exec(t);if(null==e)return console.log(`Couldn't parse line number in error: ${t}`),void console.log(n);const r=+e[1],i=n.split("\n"),o=i.length.toString().length+2,s=i.map((m,g)=>yh((g+1).toString(),o)+m);let a=0;for(let m=0;m<s.length;m++)a=Math.max(s[m].length,a);const c=s.slice(0,r-1),u=s.slice(r-1,r),p=s.slice(r);console.log(c.join("\n")),console.log(t.split("\n")[0]),console.log(`%c ${yh(u[0],a)}`,"border:1px solid red; background-color:#e3d2d2; color:#a61717"),console.log(p.join("\n"))}function Gk(n,t){if(dt(n,()=>n.validateProgram(t)),!1===n.getProgramParameter(t,n.VALIDATE_STATUS))throw console.log(n.getProgramInfoLog(t)),new Error("Shader program validation failed.")}function aj(n,t,e,r,i,o,s){const a=n.getAttribLocation(t,e);return-1!==a&&(dt(n,()=>n.bindBuffer(n.ARRAY_BUFFER,r)),dt(n,()=>n.vertexAttribPointer(a,i,n.FLOAT,!1,o,s)),dt(n,()=>n.enableVertexAttribArray(a)),!0)}function Bwe(n,t,e,r){dt(n,()=>function Pwe(n,t,e){(function cj(n,t){const e=n.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,r=t+n.TEXTURE0;if(r<n.TEXTURE0||r>e)throw new Error(`textureUnit must be in [gl.TEXTURE0, gl.TEXTURE${e}].`)})(n,e),dt(n,()=>n.activeTexture(n.TEXTURE0+e)),dt(n,()=>n.bindTexture(n.TEXTURE_2D,t))}(n,t,r)),dt(n,()=>n.uniform1i(e,r))}function Hk(n,t,e){dt(n,()=>n.bindFramebuffer(n.FRAMEBUFFER,e)),dt(n,()=>n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,t,0))}function lj(n,t){dt(n,()=>n.bindFramebuffer(n.FRAMEBUFFER,t)),dt(n,()=>n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,null,0))}function cx(n){const t=n.checkFramebufferStatus(n.FRAMEBUFFER);if(t!==n.FRAMEBUFFER_COMPLETE)throw new Error("Error binding framebuffer: "+function Vwe(n,t){switch(t){case n.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case n.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case n.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case n.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return`unknown error ${t}`}}(n,t))}function Nl(n,t,e){const r=dt(n,()=>t());if(null==r)throw new Error(e);return r}function Jh(n,t=2){return Me(n.slice(0,n.length-t))}function ep(n){if(0===n.length)throw Error("Cannot get rows and columns of an empty shape array.");return[n.length>1?n[n.length-2]:1,n[n.length-1]]}function ux(n){let t=[1,1,1];return 0===n.length||1===n.length&&1===n[0]||(t=[Jh(n),...ep(n)]),t}function dx(n){return n%2==0}function hx(n,t){if(mn(n=n.slice(-2),t=t.slice(-2))||!n.length||!t.length||0===n[0]||0===n[1]||0===t[0]||0===t[1])return!0;if(n.length!==t.length){const e=n[n.length-1],r=t[t.length-1];if(e===r||dx(e)&&dx(r)&&(1===n[0]||1===t[0]))return!0}return n[1]===t[1]&&dx(n[0])&&dx(t[0])}let px,fx;function js(n,t){return null!=n.getExtension(t)}function uj(n){try{if(null!=ma(n))return!0}catch(t){return console.log("Error when getting WebGL context: ",t),!1}return!1}function Wk(n){const t=jk(n),e=n.createTexture();n.bindTexture(n.TEXTURE_2D,e),n.texImage2D(n.TEXTURE_2D,0,t.internalFormatFloat,1,1,0,t.textureFormatFloat,t.textureTypeFloat,null);const o=n.createFramebuffer();n.bindFramebuffer(n.FRAMEBUFFER,o),n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,e,0);const s=n.checkFramebufferStatus(n.FRAMEBUFFER)===n.FRAMEBUFFER_COMPLETE;return n.bindTexture(n.TEXTURE_2D,null),n.bindFramebuffer(n.FRAMEBUFFER,null),n.deleteTexture(e),n.deleteFramebuffer(o),s}function Ug(n,t){Array.isArray(n)||(n=[n]),n.forEach(e=>{null!=e&&Z("complex64"!==e.dtype,()=>`${t} does not support complex64 tensors in the WebGL backend.`)})}const kt=Ie();function so(){let n,t,e,r,i,o,s,a,c,u;return 2===Ie().getNumber("WEBGL_VERSION")?(n="#version 300 es",t="in",e="out",r="in",i="texture",o="outputColor",s="out vec4 outputColor;",a=Ie().getBool("WEBGL2_ISNAN_CUSTOM")?"\n      bool isnan_custom(float val) {\n        uint floatToUint = floatBitsToUint(val);\n        return (floatToUint & 0x7fffffffu) > 0x7f800000u;\n      }\n\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan_custom(val.x),\n          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));\n      }\n\n      #define isnan(value) isnan_custom(value)\n    ":"",c="",u="\n      #define round(value) newRound(value)\n      int newRound(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 newRound(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "):(n="",t="attribute",e="varying",r="varying",i="texture2D",o="gl_FragColor",s="",a="\n      #define isnan(value) isnan_custom(value)\n      bool isnan_custom(float val) {\n        return (val > 0. || val < 1. || val == 0.) ? false : true;\n      }\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));\n      }\n    ",c="\n      uniform float INFINITY;\n\n      bool isinf(float val) {\n        return abs(val) == INFINITY;\n      }\n      bvec4 isinf(vec4 val) {\n        return equal(abs(val), vec4(INFINITY));\n      }\n    ",u="\n      int round(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 round(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "),{version:n,attribute:t,varyingVs:e,varyingFs:r,texture2D:i,output:o,defineOutput:s,defineSpecialNaN:a,defineSpecialInf:c,defineRound:u}}function Yu(n,t,e="index"){const r=Rt(t);return r.map((i,o)=>`int ${n[o]} = ${e} / ${i}; ${o===r.length-1?`int ${n[o+1]} = ${e} - ${n[o]} * ${i}`:`index -= ${n[o]} * ${i}`};`).join("")}function mx(n,t,e="index"){const r=Rt(t);return r.map((i,o)=>`int ${n[o]} = ${e} / outShapeStrides[${o}]; ${o===r.length-1?`int ${n[o+1]} = ${e} - ${n[o]} * outShapeStrides[${o}]`:`index -= ${n[o]} * outShapeStrides[${o}]`};`).join("")}function qk(n){const t=Rt(n).map(e=>e.toString());return`\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * ${t[0]} + coords.y * ${t[1]} + coords.z;\n  }\n`}kt.registerFlag("HAS_WEBGL",()=>kt.getNumber("WEBGL_VERSION")>0),kt.registerFlag("WEBGL_VERSION",()=>uj(2)?2:uj(1)?1:0),kt.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS",()=>!1),kt.registerFlag("WEBGL_BUFFER_SUPPORTED",()=>2===kt.get("WEBGL_VERSION")),kt.registerFlag("WEBGL_CPU_FORWARD",()=>!0),kt.registerFlag("WEBGL_FORCE_F16_TEXTURES",()=>!1),kt.registerFlag("WEBGL_PACK",()=>kt.getBool("HAS_WEBGL")),kt.registerFlag("WEBGL_PACK_NORMALIZATION",()=>kt.getBool("WEBGL_PACK")),kt.registerFlag("WEBGL_PACK_CLIP",()=>kt.getBool("WEBGL_PACK")),kt.registerFlag("WEBGL_PACK_DEPTHWISECONV",()=>kt.getBool("WEBGL_PACK")),kt.registerFlag("WEBGL_PACK_BINARY_OPERATIONS",()=>kt.getBool("WEBGL_PACK")),kt.registerFlag("WEBGL_PACK_UNARY_OPERATIONS",()=>kt.getBool("WEBGL_PACK")),kt.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS",()=>kt.getBool("WEBGL_PACK")),kt.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS",()=>kt.getBool("WEBGL_PACK")),kt.registerFlag("WEBGL_PACK_REDUCE",()=>kt.getBool("WEBGL_PACK")),kt.registerFlag("WEBGL_LAZILY_UNPACK",()=>kt.getBool("WEBGL_PACK")),kt.registerFlag("WEBGL_CONV_IM2COL",()=>kt.getBool("WEBGL_PACK")),kt.registerFlag("WEBGL_MAX_TEXTURE_SIZE",()=>function Uwe(n){if(null==px){const t=ma(n);px=t.getParameter(t.MAX_TEXTURE_SIZE)}return px}(kt.getNumber("WEBGL_VERSION"))),kt.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER",()=>function jwe(n){if(null==fx){const t=ma(n);fx=t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,fx)}(kt.getNumber("WEBGL_VERSION"))),kt.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",()=>{const n=kt.getNumber("WEBGL_VERSION");return 0===n?0:function Gwe(n){if(0===n)return 0;let t;const e=ma(n);return t=js(e,"EXT_disjoint_timer_query_webgl2")&&2===n?2:js(e,"EXT_disjoint_timer_query")?1:0,t}(n)}),kt.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",()=>kt.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0&&!y3()),kt.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE",()=>function Hwe(n){if(0===n)return!1;const t=ma(n);if(1===n){if(!js(t,"OES_texture_float"))return!1}else if(!js(t,"EXT_color_buffer_float"))return!1;return Wk(t)}(kt.getNumber("WEBGL_VERSION"))),kt.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED",()=>!kt.getBool("WEBGL_FORCE_F16_TEXTURES")&&kt.getBool("WEBGL_RENDER_FLOAT32_CAPABLE")),kt.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED",()=>function Wwe(n){if(0===n)return!1;const t=ma(n);if(1!==n){if(js(t,"EXT_color_buffer_float"))return Wk(t);const r="EXT_color_buffer_half_float";if(js(t,r)){const i=t.getExtension(r);return function qwe(n,t){const e=jk(n,t),r=n.createTexture();n.bindTexture(n.TEXTURE_2D,r),n.texImage2D(n.TEXTURE_2D,0,e.internalFormatHalfFloat,1,1,0,e.textureFormatFloat,e.textureTypeHalfFloat,null);const s=n.createFramebuffer();n.bindFramebuffer(n.FRAMEBUFFER,s),n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,r,0);const a=n.checkFramebufferStatus(n.FRAMEBUFFER)===n.FRAMEBUFFER_COMPLETE;return n.bindTexture(n.TEXTURE_2D,null),n.bindFramebuffer(n.FRAMEBUFFER,null),n.deleteTexture(r),n.deleteFramebuffer(s),a}(t,i)}return!1}return!(!js(t,"OES_texture_float")||!js(t,"WEBGL_color_buffer_float"))&&Wk(t)}(kt.getNumber("WEBGL_VERSION"))),kt.registerFlag("WEBGL_FENCE_API_ENABLED",()=>function Kwe(n){return 2===n&&null!=ma(n).fenceSync}(kt.getNumber("WEBGL_VERSION"))),kt.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM",()=>kt.getBool("WEBGL_RENDER_FLOAT32_ENABLED")?4:0),kt.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD",()=>-1,n=>{if(n<0&&-1!==n)throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never delete) or at least 0, but got ${n}.`)}),kt.registerFlag("WEBGL_FLUSH_THRESHOLD",()=>y3()?1:-1,n=>{if(n<0&&-1!==n)throw new Error(`WEBGL_FLUSH_THRESHOLD must be -1 (indicating never manual flush) or at least 0, but got ${n}.`)}),kt.registerFlag("CPU_HANDOFF_SIZE_THRESHOLD",()=>128),kt.registerFlag("WEBGL_USE_SHAPES_UNIFORMS",()=>!1),kt.registerFlag("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD",()=>1e5),kt.registerFlag("TOPK_K_CPU_HANDOFF_THRESHOLD",()=>128),kt.registerFlag("WEBGL_EXP_CONV",()=>!1),kt.registerFlag("SOFTWARE_WEBGL_ENABLED",()=>kt.getBool("IS_TEST")),kt.registerFlag("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE",()=>1/0),kt.registerFlag("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE",()=>!1),kt.registerFlag("WEBGL2_ISNAN_CUSTOM",()=>!1),kt.registerFlag("ENGINE_COMPILE_ONLY",()=>!1);const dj="\n  const float FLOAT_MAX = 1.70141184e38;\n  const float FLOAT_MIN = 1.17549435e-38;\n\n  lowp vec4 encode_float(highp float v) {\n    if (isnan(v)) {\n      return vec4(255, 255, 255, 255);\n    }\n\n    highp float av = abs(v);\n\n    if(av < FLOAT_MIN) {\n      return vec4(0.0, 0.0, 0.0, 0.0);\n    } else if(v > FLOAT_MAX) {\n      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;\n    } else if(v < -FLOAT_MAX) {\n      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;\n    }\n\n    highp vec4 c = vec4(0,0,0,0);\n\n    highp float e = floor(log2(av));\n    highp float m = exp2(fract(log2(av))) - 1.0;\n\n    c[2] = floor(128.0 * m);\n    m -= c[2] / 128.0;\n    c[1] = floor(32768.0 * m);\n    m -= c[1] / 32768.0;\n    c[0] = floor(8388608.0 * m);\n\n    highp float ebias = e + 127.0;\n    c[3] = floor(ebias / 2.0);\n    ebias -= c[3] * 2.0;\n    c[2] += floor(ebias) * 128.0;\n\n    c[3] += 128.0 * step(0.0, -v);\n\n    return c / 255.0;\n  }\n",{getBroadcastDims:hj}=S;function Zwe(n,t,e){const r=[];if(n.forEach(_=>{const x=Me(_.shapeInfo.logicalShape);if(_.shapeInfo.isUniform?r.push(`uniform float ${_.name}${x>1?`[${x}]`:""};`):(r.push(`uniform sampler2D ${_.name};`),r.push(`uniform int offset${_.name};`)),e.enableShapeUniforms){const{uniformShape:T}=Xk(e.packedInputs,_.shapeInfo.logicalShape,_.shapeInfo.texShape);switch(T.length){case 1:r.push(`uniform int ${_.name}Shape;`);break;case 2:r.push(`uniform ivec2 ${_.name}Shape;`);break;case 3:r.push(`uniform ivec3 ${_.name}Shape;`);break;case 4:r.push(`uniform ivec4 ${_.name}Shape;`)}r.push(`uniform ivec2 ${_.name}TexShape;`)}}),e.enableShapeUniforms){switch(t.logicalShape.length){case 1:r.push("uniform int outShape;");break;case 2:r.push("uniform ivec2 outShape;"),r.push("uniform int outShapeStrides;");break;case 3:r.push("uniform ivec3 outShape;"),r.push("uniform ivec2 outShapeStrides;");break;case 4:r.push("uniform ivec4 outShape;"),r.push("uniform ivec3 outShapeStrides;")}r.push("uniform ivec2 outTexShape;")}e.customUniforms&&e.customUniforms.forEach(_=>{r.push(`uniform ${_.type} ${_.name}${_.arrayIndex?`[${_.arrayIndex}]`:""};`)});const i=r.join("\n"),o=n.map(_=>function Qwe(n,t,e=!1,r){let i="";i+=e?pj(n,r):tp(n,r);return n.shapeInfo.logicalShape.length<=t.logicalShape.length&&(i+=e?function NTe(n,t){const e=n.name,r=e.charAt(0).toUpperCase()+e.slice(1),i="get"+r+"AtOutCoords",o=n.shapeInfo.logicalShape.length,s=t.logicalShape.length,a=hj(n.shapeInfo.logicalShape,t.logicalShape),c=jn(s),u=s-o;let p;const m=["x","y","z","w","u","v"];p=0===o?"":s<2&&a.length>=1?"coords = 0;":a.map(R=>`coords.${m[R+u]} = 0;`).join("\n");let g="";g=s<2&&o>0?"coords":n.shapeInfo.logicalShape.map((R,L)=>`coords.${m[L+u]}`).join(", ");let _="return outputValue;";const T=1===Me(n.shapeInfo.logicalShape),N=1===Me(t.logicalShape);if(1!==o||T||N){if(T&&!N)_=1===s?"\n        return vec4(outputValue.x, outputValue.x, 0., 0.);\n      ":"\n        return vec4(outputValue.x);\n      ";else if(a.length){const R=o-2,L=o-1;a.indexOf(R)>-1&&a.indexOf(L)>-1?_="return vec4(outputValue.x);":a.indexOf(R)>-1?_="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":a.indexOf(L)>-1&&(_="return vec4(outputValue.xx, outputValue.zz);")}}else _="\n      return vec4(outputValue.xy, outputValue.xy);\n    ";return`\n    vec4 ${i}() {\n      ${c} coords = getOutputCoords();\n      ${p}\n      vec4 outputValue = get${r}(${g});\n      ${_}\n    }\n  `}(n,t):function OTe(n,t){const e=n.name,r=e.charAt(0).toUpperCase()+e.slice(1),i="get"+r+"AtOutCoords",a=n.shapeInfo.logicalShape.length,c=t.logicalShape.length;if(!n.shapeInfo.isUniform&&a===c&&null==n.shapeInfo.flatOffset&&mn(n.shapeInfo.texShape,t.texShape))return`\n      float ${i}() {\n        return sampleTexture(${e}, resultUV);\n      }\n    `;const u=jn(c),p=hj(n.shapeInfo.logicalShape,t.logicalShape),m=c-a;let g;const _=["x","y","z","w","u","v"];g=0===a?"":c<2&&p.length>=1?"coords = 0;":p.map(T=>`coords.${_[T+m]} = 0;`).join("\n");let x="";return x=c<2&&a>0?"coords":n.shapeInfo.logicalShape.map((T,I)=>`coords.${_[I+m]}`).join(", "),`\n    float ${i}() {\n      ${u} coords = getOutputCoords();\n      ${g}\n      return get${r}(${x});\n    }\n  `}(n,t)),i}(_,t,e.packedInputs,e.enableShapeUniforms)).join("\n"),s=t.texShape,a=so(),c=function tTe(n){return`\n    float sampleTexture(sampler2D textureSampler, vec2 uv) {\n      return ${n.texture2D}(textureSampler, uv).r;\n    }\n  `}(a);let u,p,m=function iTe(n){return`${n.version}\n    precision highp float;\n    precision highp int;\n    precision highp sampler2D;\n    ${n.varyingFs} vec2 resultUV;\n    ${n.defineOutput}\n    const vec2 halfCR = vec2(0.5, 0.5);\n\n    struct ivec5\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n    };\n\n    struct ivec6\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n      int v;\n    };\n\n    uniform float NAN;\n    ${n.defineSpecialNaN}\n    ${n.defineSpecialInf}\n    ${n.defineRound}\n\n    int imod(int x, int y) {\n      return x - y * (x / y);\n    }\n\n    int idiv(int a, int b, float sign) {\n      int res = a / b;\n      int mod = imod(a, b);\n      if (sign < 0. && mod != 0) {\n        res -= 1;\n      }\n      return res;\n    }\n\n    //Based on the work of Dave Hoskins\n    //https://www.shadertoy.com/view/4djSRW\n    #define HASHSCALE1 443.8975\n    float random(float seed){\n      vec2 p = resultUV * seed;\n      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n      p3 += dot(p3, p3.yzx + 19.19);\n      return fract((p3.x + p3.y) * p3.z);\n    }\n\n    ${oTe}\n    ${sTe}\n    ${aTe}\n  `}(a);return t.isPacked?(u=function Jwe(n,t,e){switch(n.length){case 0:return"\n    int getOutputCoords() {\n      return 0;\n    }\n  ";case 1:return function cTe(n,t,e){const r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];return 1===r[0]?e?"\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * ceil(float(outTexShape[1]) / 2.0));\n      }\n    ":`\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * ${r[1]}.0);\n      }\n    `:1===r[1]?e?"\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * ceil(float(outTexShape[0]) / 2.0));\n      }\n    ":`\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * ${r[0]}.0);\n      }\n    `:e?"\n    int getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      return 2 * (resTexRC.x * packedTexShape[1] + resTexRC.y);\n    }\n  ":`\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${r[0]}, ${r[1]}));\n      return 2 * (resTexRC.x * ${r[1]} + resTexRC.y);\n    }\n  `}(0,t,e);case 2:return function bTe(n,t,e){const r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];if(mn(n,t))return e?"\n      ivec2 getOutputCoords() {\n        ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n        return 2 * ivec2(resultUV.yx * vec2(packedTexShape[0], packedTexShape[1]));\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        return 2 * ivec2(resultUV.yx * vec2(${r[0]}, ${r[1]}));\n      }\n    `;const i=Math.ceil(n[1]/2);return e?"\n    ivec2 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      int texelsInLogicalRow = int(ceil(float(outShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec2(r, c);\n    }\n  ":`\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${r[0]}, ${r[1]}));\n\n      int index = resTexRC.x * ${r[1]} + resTexRC.y;\n      int r = 2 * (index / ${i});\n      int c = imod(index, ${i}) * 2;\n\n      return ivec2(r, c);\n    }\n  `}(n,t,e);case 3:return function dTe(n,t,e){if(e)return"\n    ivec3 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      int texelsInLogicalRow = int(ceil(float(outShape[2]) / 2.0));\n      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n\n      int b = index / texelsInBatch;\n      index -= b * texelsInBatch;\n\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec3(b, r, c);\n    }\n  ";const r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],i=Math.ceil(n[2]/2),o=i*Math.ceil(n[1]/2);return`\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${r[0]}, ${r[1]}));\n      int index = resTexRC.x * ${r[1]} + resTexRC.y;\n\n      int b = index / ${o};\n      index -= b * ${o};\n\n      int r = 2 * (index / ${i});\n      int c = imod(index, ${i}) * 2;\n\n      return ivec3(b, r, c);\n    }\n  `}(n,t,e);default:return function pTe(n,t,e){if(e)return"\n    ivec4 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n\n      int texelsInLogicalRow = int(ceil(float(outShape[3]) / 2.0));\n      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[2]) / 2.0));\n      int texelsInBatchN = texelsInBatch * outShape[1];\n\n      int b2 = index / texelsInBatchN;\n      index -= b2 * texelsInBatchN;\n\n      int b = index / texelsInBatch;\n      index -= b * texelsInBatch;\n\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec4(b2, b, r, c);\n    }\n  ";const r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],i=Math.ceil(n[n.length-1]/2),o=i*Math.ceil(n[n.length-2]/2);let s=o,a="",c="b, r, c";for(let u=2;u<n.length-1;u++)s*=n[n.length-u-1],a=`\n      int b${u} = index / ${s};\n      index -= b${u} * ${s};\n    `+a,c=`b${u}, `+c;return`\n    ivec${n.length} getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${r[0]}, ${r[1]}));\n      int index = resTexRC.x * ${r[1]} + resTexRC.y;\n\n      ${a}\n\n      int b = index / ${o};\n      index -= b * ${o};\n\n      int r = 2 * (index / ${i});\n      int c = imod(index, ${i}) * 2;\n\n      return ivec${n.length}(${c});\n    }\n  `}(n,t,e)}}(t.logicalShape,s,e.enableShapeUniforms),p=function rTe(n){return`\n    void setOutput(vec4 val) {\n      ${n.output} = val;\n    }\n  `}(a)):(u=function eTe(n,t,e){switch(n.length){case 0:return"\n    int getOutputCoords() {\n      return 0;\n    }\n  ";case 1:return function uTe(n,t,e){return 1===t[0]?e?"\n      int getOutputCoords() {\n        return int(resultUV.x * float(outTexShape[1]));\n      }\n    ":`\n      int getOutputCoords() {\n        return int(resultUV.x * ${t[1]}.0);\n      }\n    `:1===t[1]?e?"\n      int getOutputCoords() {\n        return int(resultUV.y * float(outTexShape[0]));\n      }\n    ":`\n      int getOutputCoords() {\n        return int(resultUV.y * ${t[0]}.0);\n      }\n    `:e?"\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(outTexShape[0], outTexShape[1]));\n      return resTexRC.x * outTexShape[1] + resTexRC.y;\n    }\n  ":`\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${t[0]}, ${t[1]}));\n      return resTexRC.x * ${t[1]} + resTexRC.y;\n    }\n  `}(0,t,e);case 2:return function yTe(n,t,e){return mn(n,t)?e?"\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(outTexShape[0], outTexShape[1]));\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(${t[0]}, ${t[1]}));\n      }\n    `:1===n[1]?e?"\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(outTexShape[0], outTexShape[1]));\n        int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(${t[0]}, ${t[1]}));\n        int index = resTexRC.x * ${t[1]} + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    `:1===n[0]?e?"\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(outTexShape[0], outTexShape[1]));\n        int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n        return ivec2(0, index);\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(${t[0]}, ${t[1]}));\n        int index = resTexRC.x * ${t[1]} + resTexRC.y;\n        return ivec2(0, index);\n      }\n    `:e?"\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(outTexShape[0], outTexShape[1]));\n      int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n      int r = index / outShape[1];\n      int c = index - r * outShape[1];\n      return ivec2(r, c);\n    }\n  ":`\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n      int r = index / ${n[1]};\n      int c = index - r * ${n[1]};\n      return ivec2(r, c);\n    }\n  `}(n,t,e);case 3:return function hTe(n,t,e){if(e)return`\n  ivec3 getOutputCoords() {\n    ivec2 resTexRC = ivec2(resultUV.yx *\n                           vec2(outTexShape[0], outTexShape[1]));\n    int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n    ${mx(["r","c","d"],n)}\n    return ivec3(r, c, d);\n  }\n`;const r=Yu(["r","c","d"],n);return`\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n      ${r}\n      return ivec3(r, c, d);\n    }\n  `}(n,t,e);case 4:return function fTe(n,t,e){if(e)return`\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(outTexShape[0], outTexShape[1]));\n      int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n      ${mx(["r","c","d","d2"],n)}\n      return ivec4(r, c, d, d2);\n    }\n  `;const r=Yu(["r","c","d","d2"],n);return`\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n      ${r}\n      return ivec4(r, c, d, d2);\n    }\n  `}(n,t,e);case 5:return function mTe(n,t){const e=Yu(["r","c","d","d2","d3"],n);return`\n    ivec5 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx * vec2(${t[0]},\n                             ${t[1]}));\n\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n\n      ${e}\n\n      ivec5 outShape = ivec5(r, c, d, d2, d3);\n      return outShape;\n    }\n  `}(n,t);case 6:return function gTe(n,t){const e=Yu(["r","c","d","d2","d3","d4"],n);return`\n    ivec6 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n\n      ${e}\n\n      ivec6 result = ivec6(r, c, d, d2, d3, d4);\n      return result;\n    }\n  `}(n,t);default:throw new Error(`${n.length}-D output sampling is not yet supported`)}}(t.logicalShape,s,e.enableShapeUniforms),p=function nTe(n){return`\n    void setOutput(float val) {\n      ${n.output} = vec4(val, 0, 0, 0);\n    }\n  `}(a)),e.packedInputs&&(m+=lTe),[m,c,p,i,u,o,e.userCode].join("\n")}function tp(n,t=!1){const e=n.shapeInfo.logicalShape;switch(e.length){case 0:return function vTe(n,t){const e=n.name,r="get"+e.charAt(0).toUpperCase()+e.slice(1);if(n.shapeInfo.isUniform)return`float ${r}() {return ${e};}`;const[i,o]=n.shapeInfo.texShape;if(1===i&&1===o)return`\n      float ${r}() {\n        return sampleTexture(${e}, halfCR);\n      }\n    `;const s=Zu(e);if(t)return`\n    float ${r}() {\n      vec2 uv = uvFromFlat(${e}TexShape[0], ${e}TexShape[1], ${s});\n      return sampleTexture(${e}, uv);\n    }\n  `;const[a,c]=n.shapeInfo.texShape;return`\n    float ${r}() {\n      vec2 uv = uvFromFlat(${a}, ${c}, ${s});\n      return sampleTexture(${e}, uv);\n    }\n  `}(n,t);case 1:return function wTe(n,t){const e=n.name,r="get"+e.charAt(0).toUpperCase()+e.slice(1);if(n.shapeInfo.isUniform)return`\n      float ${r}(int index) {\n        ${np(n)}\n      }\n    `;const i=n.shapeInfo.texShape,o=i[0],s=i[1];if(1===s&&1===o)return`\n      float ${r}(int index) {\n        return sampleTexture(${e}, halfCR);\n      }\n    `;const a=Zu(e);return 1===s?t?`\n      float ${r}(int index) {\n        vec2 uv = vec2(0.5, (float(index + ${a}) + 0.5) / float(${e}TexShape[0]));\n        return sampleTexture(${e}, uv);\n      }\n    `:`\n      float ${r}(int index) {\n        vec2 uv = vec2(0.5, (float(index + ${a}) + 0.5) / ${o}.0);\n        return sampleTexture(${e}, uv);\n      }\n    `:1===o?t?`\n      float ${r}(int index) {\n        vec2 uv = vec2((float(index + ${a}) + 0.5) / float(${e}TexShape[1]), 0.5);\n        return sampleTexture(${e}, uv);\n      }\n    `:`\n      float ${r}(int index) {\n        vec2 uv = vec2((float(index + ${a}) + 0.5) / ${s}.0, 0.5);\n        return sampleTexture(${e}, uv);\n      }\n    `:t?`\n    float ${r}(int index) {\n      vec2 uv = uvFromFlat(${e}TexShape[0], ${e}TexShape[1], index + ${a});\n      return sampleTexture(${e}, uv);\n    }\n  `:`\n    float ${r}(int index) {\n      vec2 uv = uvFromFlat(${o}, ${s}, index + ${a});\n      return sampleTexture(${e}, uv);\n    }\n  `}(n,t);case 2:return function STe(n,t){const e=n.shapeInfo.logicalShape,r=n.name,i="get"+r.charAt(0).toUpperCase()+r.slice(1),o=n.shapeInfo.texShape;if(null!=o&&mn(e,o))return t?`\n      float ${i}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n    float ${i}(int row, int col) {\n      vec2 uv = (vec2(col, row) + halfCR) / vec2(${o[1]}.0, ${o[0]}.0);\n      return sampleTexture(${r}, uv);\n    }\n  `;const{newShape:s,keptDims:a}=sc(e);if(s.length<e.length){const _=["row","col"];return`\n      ${tp(rp(n,s),t)}\n      float ${i}(int row, int col) {\n        return ${i}(${ip(_,a)});\n      }\n    `}if(n.shapeInfo.isUniform)return`\n      float ${i}(int row, int col) {\n        int index = round(dot(vec2(row, col), vec2(${e[1]}, 1)));\n        ${np(n)}\n      }\n    `;const u=o[0],p=o[1],m=Zu(r);return 1===p?t?`\n      float ${i}(int row, int col) {\n        float index = dot(vec3(row, col, ${m}), vec3(${r}Shape[1], 1, 1));\n        vec2 uv = vec2(0.5, (index + 0.5) / float(${r}TexShape[0]));\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n    float ${i}(int row, int col) {\n      float index = dot(vec3(row, col, ${m}), vec3(${e[1]}, 1, 1));\n      vec2 uv = vec2(0.5, (index + 0.5) / ${u}.0);\n      return sampleTexture(${r}, uv);\n    }\n  `:1===u?t?`\n      float ${i}(int row, int col) {\n        float index = dot(vec3(row, col, ${m}), vec3(${r}Shape[1], 1, 1));\n        vec2 uv = vec2((index + 0.5) / float(${r}TexShape[1]), 0.5);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n    float ${i}(int row, int col) {\n      float index = dot(vec3(row, col, ${m}), vec3(${e[1]}, 1, 1));\n      vec2 uv = vec2((index + 0.5) / ${p}.0, 0.5);\n      return sampleTexture(${r}, uv);\n    }\n  `:t?`\n      float ${i}(int row, int col) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * ${r}Shape[1] + col + ${m};\n        vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n  float ${i}(int row, int col) {\n    // Explicitly use integer operations as dot() only works on floats.\n    int index = row * ${e[1]} + col + ${m};\n    vec2 uv = uvFromFlat(${u}, ${p}, index);\n    return sampleTexture(${r}, uv);\n  }\n`}(n,t);case 3:return function ITe(n,t){const e=n.shapeInfo.logicalShape,r=n.name,i="get"+r.charAt(0).toUpperCase()+r.slice(1),o=e[1]*e[2],s=e[2],{newShape:a,keptDims:c}=sc(e);if(a.length<e.length){const I=["row","col","depth"];return`\n        ${tp(rp(n,a),t)}\n        float ${i}(int row, int col, int depth) {\n          return ${i}(${ip(I,c)});\n        }\n      `}if(n.shapeInfo.isUniform)return`\n      float ${i}(int row, int col, int depth) {\n        int index = round(dot(vec3(row, col, depth),\n                          vec3(${o}, ${s}, 1)));\n        ${np(n)}\n      }\n    `;const p=n.shapeInfo.texShape,m=p[0],g=p[1],_=n.shapeInfo.flatOffset;if(g===o&&null==_)return t?`\n      float ${i}(int row, int col, int depth) {\n        int stride1 = ${r}Shape[2];\n        float texR = float(row);\n        float texC = dot(vec2(col, depth), vec2(stride1, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n        float ${i}(int row, int col, int depth) {\n          float texR = float(row);\n          float texC = dot(vec2(col, depth), vec2(${s}, 1));\n          vec2 uv = (vec2(texC, texR) + halfCR) /\n                     vec2(${g}.0, ${m}.0);\n          return sampleTexture(${r}, uv);\n        }\n      `;if(g===s&&null==_)return t?`\n      float ${i}(int row, int col, int depth) {\n        float texR = dot(vec2(row, col), vec2(${r}Shape[1], 1));\n        float texC = float(depth);\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n    float ${i}(int row, int col, int depth) {\n      float texR = dot(vec2(row, col), vec2(${e[1]}, 1));\n      float texC = float(depth);\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${g}.0, ${m}.0);\n      return sampleTexture(${r}, uv);\n    }\n  `;const x=Zu(r);return t?`\n    float ${i}(int row, int col, int depth) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int stride0 = ${r}Shape[1] * ${r}Shape[2];\n      int stride1 = ${r}Shape[2];\n      int index = row * stride0 + col * stride1 + depth + ${x};\n      vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index);\n      return sampleTexture(${r}, uv);\n    }\n    `:`\n      float ${i}(int row, int col, int depth) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * ${o} + col * ${s} + depth + ${x};\n        vec2 uv = uvFromFlat(${m}, ${g}, index);\n        return sampleTexture(${r}, uv);\n      }\n  `}(n,t);case 4:return function DTe(n,t){const e=n.shapeInfo.logicalShape,r=n.name,i="get"+r.charAt(0).toUpperCase()+r.slice(1),o=e[3],s=e[2]*o,a=e[1]*s,{newShape:c,keptDims:u}=sc(e);if(c.length<e.length){const L=["row","col","depth","depth2"];return`\n      ${tp(rp(n,c),t)}\n      float ${i}(int row, int col, int depth, int depth2) {\n        return ${i}(${ip(L,u)});\n      }\n    `}if(n.shapeInfo.isUniform)return`\n      float ${i}(int row, int col, int depth, int depth2) {\n        int index = round(dot(vec4(row, col, depth, depth2),\n                          vec4(${a}, ${s}, ${o}, 1)));\n        ${np(n)}\n      }\n    `;const p=n.shapeInfo.flatOffset,m=n.shapeInfo.texShape,g=m[0],_=m[1],x=`int stride2 = ${r}Shape[3];`,T=`int stride1 = ${r}Shape[2] * stride2;`,I=`int stride0 = ${r}Shape[1] * stride1;`;if(_===a&&null==p)return t?`\n      float ${i}(int row, int col, int depth, int depth2) {\n        ${x}\n        ${T}\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3(stride1, stride2, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n      float ${i}(int row, int col, int depth, int depth2) {\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3(${s}, ${o}, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${_}.0, ${g}.0);\n        return sampleTexture(${r}, uv);\n      }\n    `;if(_===o&&null==p)return t?`\n      float ${i}(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3(${r}Shape[1] * ${r}Shape[2], ${r}Shape[2], 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n      float ${i}(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3(${e[1]*e[2]}, ${e[2]}, 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${_}.0, ${g}.0);\n        return sampleTexture(${r}, uv);\n      }\n    `;const N=Zu(r);return t?`\n    float ${i}(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      ${x}\n      ${T}\n      ${I}\n      int index = row * stride0 + col * stride1 +\n          depth * stride2 + depth2;\n      vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index + ${N});\n      return sampleTexture(${r}, uv);\n    }\n  `:`\n    float ${i}(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${a} + col * ${s} +\n          depth * ${o} + depth2;\n      vec2 uv = uvFromFlat(${g}, ${_}, index + ${N});\n      return sampleTexture(${r}, uv);\n    }\n  `}(n,t);case 5:return function kTe(n){const t=n.shapeInfo.logicalShape,e=n.name,r="get"+e.charAt(0).toUpperCase()+e.slice(1),i=t[4],o=t[3]*i,s=t[2]*o,a=t[1]*s,{newShape:c,keptDims:u}=sc(t);if(c.length<t.length){const I=["row","col","depth","depth2","depth3"];return`\n      ${tp(rp(n,c))}\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        return ${r}(${ip(I,u)});\n      }\n    `}if(n.shapeInfo.isUniform)return`\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        float index = dot(\n          vec4(row, col, depth, depth2),\n          vec4(${a}, ${s}, ${o}, ${i})) +\n          depth3;\n        ${np(n)}\n      }\n    `;const p=n.shapeInfo.flatOffset,m=n.shapeInfo.texShape,g=m[0],_=m[1];if(_===a&&null==p)return`\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n                         vec4(${s}, ${o}, ${i}, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${_}.0, ${g}.0);\n        return sampleTexture(${e}, uv);\n      }\n    `;if(_===i&&null==p)return`\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        float texR = dot(\n          vec4(row, col, depth, depth2),\n          vec4(${t[1]*t[2]*t[3]},\n               ${t[2]*t[3]}, ${t[3]}, 1));\n        int texC = depth3;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${_}.0, ${g}.0);\n        return sampleTexture(${e}, uv);\n      }\n    `;return`\n    float ${r}(int row, int col, int depth, int depth2, int depth3) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${a} + col * ${s} + depth * ${o} +\n          depth2 * ${i} + depth3 + ${Zu(e)};\n      vec2 uv = uvFromFlat(${g}, ${_}, index);\n      return sampleTexture(${e}, uv);\n    }\n  `}(n);case 6:return function ATe(n){const t=n.shapeInfo.logicalShape,e=n.name,r="get"+e.charAt(0).toUpperCase()+e.slice(1),{newShape:i,keptDims:o}=sc(t);if(i.length<t.length){const N=["row","col","depth","depth2","depth3","depth4"];return`\n      ${tp(rp(n,i))}\n      float ${r}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        return ${r}(${ip(N,o)});\n      }\n    `}const s=t[5],a=t[4]*s,c=t[3]*a,u=t[2]*c,p=t[1]*u;if(n.shapeInfo.isUniform)return`\n      float ${r}(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n        int index = round(dot(\n          vec4(row, col, depth, depth2),\n          vec4(${p}, ${u}, ${c}, ${a})) +\n          dot(\n            vec2(depth3, depth4),\n            vec2(${s}, 1)));\n        ${np(n)}\n      }\n    `;const m=n.shapeInfo.flatOffset,g=n.shapeInfo.texShape,_=g[0],x=g[1];if(x===p&&null==m)return`\n      float ${r}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n          vec4(${u}, ${c}, ${a}, ${s})) +\n               float(depth4);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${x}.0, ${_}.0);\n        return sampleTexture(${e}, uv);\n      }\n    `;if(x===s&&null==m)return`\n      float ${r}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        float texR = dot(vec4(row, col, depth, depth2),\n          vec4(${t[1]*t[2]*t[3]*t[4]},\n               ${t[2]*t[3]*t[4]},\n               ${t[3]*t[4]},\n               ${t[4]})) + float(depth3);\n        int texC = depth4;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${x}.0, ${_}.0);\n        return sampleTexture(${e}, uv);\n      }\n    `;return`\n    float ${r}(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${p} + col * ${u} + depth * ${c} +\n          depth2 * ${a} + depth3 * ${s} + depth4 + ${Zu(e)};\n      vec2 uv = uvFromFlat(${_}, ${x}, index);\n      return sampleTexture(${e}, uv);\n    }\n  `}(n);default:throw new Error(`${e.length}-D input sampling is not yet supported`)}}function pj(n,t){switch(n.shapeInfo.logicalShape.length){case 0:return function _Te(n){const t=n.name;return`\n    vec4 ${"get"+t.charAt(0).toUpperCase()+t.slice(1)}() {\n      return ${so().texture2D}(${t}, halfCR);\n    }\n  `}(n);case 1:return function xTe(n,t){const e=n.name,r="get"+e.charAt(0).toUpperCase()+e.slice(1),i=n.shapeInfo.texShape,o=so();if(t)return`\n    vec4 ${r}(int index) {\n      ivec2 packedTexShape = ivec2(ceil(float(${e}TexShape[0]) / 2.0), ceil(float(${e}TexShape[1]) / 2.0));\n      vec2 uv = packedUVfrom1D(\n        packedTexShape[0], packedTexShape[1], index);\n      return ${o.texture2D}(${e}, uv);\n    }\n  `;const s=[Math.ceil(i[0]/2),Math.ceil(i[1]/2)];return`\n    vec4 ${r}(int index) {\n      vec2 uv = packedUVfrom1D(\n        ${s[0]}, ${s[1]}, index);\n      return ${o.texture2D}(${e}, uv);\n    }\n  `}(n,t);case 2:return function TTe(n,t){const e=n.shapeInfo.logicalShape,r=n.name,i="get"+r.charAt(0).toUpperCase()+r.slice(1),o=n.shapeInfo.texShape,s=o[0],a=o[1],c=so();if(null!=o&&mn(e,o))return t?`\n      vec4 ${i}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);\n\n        return ${c.texture2D}(${r}, uv);\n      }\n    `:`\n      vec4 ${i}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${a}.0, ${s}.0);\n\n        return ${c.texture2D}(${r}, uv);\n      }\n    `;if(t)return`\n    vec4 ${i}(int row, int col) {\n      ivec2 packedTexShape = ivec2(ceil(float(${r}TexShape[0]) / 2.0), ceil(float(${r}TexShape[1]) / 2.0));\n      int valuesPerRow = int(ceil(float(${r}Shape[1]) / 2.0));\n      vec2 uv = packedUVfrom2D(valuesPerRow, packedTexShape[0], packedTexShape[1], row, col);\n      return ${c.texture2D}(${r}, uv);\n    }\n  `;const u=[Math.ceil(o[0]/2),Math.ceil(o[1]/2)];return`\n    vec4 ${i}(int row, int col) {\n      vec2 uv = packedUVfrom2D(${Math.ceil(e[1]/2)}, ${u[0]}, ${u[1]}, row, col);\n      return ${c.texture2D}(${r}, uv);\n    }\n  `}(n,t);case 3:return function CTe(n,t){const e=n.shapeInfo.logicalShape,r=n.name,i="get"+r.charAt(0).toUpperCase()+r.slice(1),o=n.shapeInfo.texShape,s=[Math.ceil(o[0]/2),Math.ceil(o[1]/2)];if(1===e[0]){const _=[1,2],T=["b","row","col"];return`\n        ${pj(rp(n,e.slice(1)),t)}\n        vec4 ${i}(int b, int row, int col) {\n          return ${i}(${ip(T,_)});\n        }\n      `}const a=so();if(t)return`\n    vec4 ${i}(int b, int row, int col) {\n      ivec2 packedTexShape = ivec2(ceil(float(${r}TexShape[0]) / 2.0), ceil(float(${r}TexShape[1]) / 2.0));\n      int valuesPerRow = int(ceil(float(${r}Shape[2]) / 2.0));\n      int texelsInBatch = valuesPerRow * int(ceil(float(${r}Shape[1]) / 2.0));\n      vec2 uv = packedUVfrom3D(\n        packedTexShape[0], packedTexShape[1], texelsInBatch, valuesPerRow, b, row, col);\n      return ${a.texture2D}(${r}, uv);\n    }\n  `;const c=s[0],u=s[1],p=Math.ceil(e[2]/2);return`\n    vec4 ${i}(int b, int row, int col) {\n      vec2 uv = packedUVfrom3D(\n        ${c}, ${u}, ${p*Math.ceil(e[1]/2)}, ${p}, b, row, col);\n      return ${a.texture2D}(${r}, uv);\n    }\n  `}(n,t);default:return function ETe(n,t){const e=n.name,r="get"+e.charAt(0).toUpperCase()+e.slice(1),i=so();if(t)return`\n    vec4 ${r}(int b2, int b, int row, int col) {\n      int valuesPerRow = int(ceil(float(${e}Shape[3]) / 2.0));\n      int texelsInBatch = valuesPerRow * int(ceil(float(${e}Shape[2]) / 2.0));\n      int index = b * texelsInBatch + (row / 2) * valuesPerRow + (col / 2);\n      texelsInBatch *= ${e}Shape[1];\n      index = b2 * texelsInBatch + index;\n      ivec2 packedTexShape = ivec2(ceil(float(${e}TexShape[0]) / 2.0), ceil(float(${e}TexShape[1]) / 2.0));\n      int texR = index / packedTexShape[1];\n      int texC = index - texR * packedTexShape[1];\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(packedTexShape[1], packedTexShape[0]); return ${i.texture2D}(${e}, uv);\n    }\n  `;const o=n.shapeInfo.logicalShape,s=o.length,a=n.shapeInfo.texShape,c=[Math.ceil(a[0]/2),Math.ceil(a[1]/2)],u=c[0],p=c[1],m=Math.ceil(o[s-1]/2);let g=m*Math.ceil(o[s-2]/2),_="int b, int row, int col",x=`b * ${g} + (row / 2) * ${m} + (col / 2)`;for(let T=2;T<s-1;T++)_=`int b${T}, `+_,g*=o[s-T-1],x=`b${T} * ${g} + `+x;return`\n    vec4 ${r}(${_}) {\n      int index = ${x};\n      int texR = index / ${p};\n      int texC = index - texR * ${p};\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${p}, ${u});\n      return ${i.texture2D}(${e}, uv);\n    }\n  `}(n,t)}}const oTe="\nvec2 uvFromFlat(int texNumR, int texNumC, int index) {\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\nvec2 packedUVfrom1D(int texNumR, int texNumC, int index) {\n  int texelIndex = index / 2;\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",sTe="\nvec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,\n  int texNumC, int row, int col) {\n  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",aTe="\nvec2 packedUVfrom3D(int texNumR, int texNumC,\n    int texelsInBatch, int texelsInLogicalRow, int b,\n    int row, int col) {\n  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",lTe="\n  float getChannel(vec4 frag, vec2 innerDims) {\n    vec2 modCoord = mod(innerDims, 2.);\n    return modCoord.x == 0. ?\n      (modCoord.y == 0. ? frag.r : frag.g) :\n      (modCoord.y == 0. ? frag.b : frag.a);\n  }\n  float getChannel(vec4 frag, int dim) {\n    float modCoord = mod(float(dim), 2.);\n    return modCoord == 0. ? frag.r : frag.g;\n  }\n";function Zu(n){return`offset${n}`}function np(n){const t=n.name,e=Me(n.shapeInfo.logicalShape);return e<2?`return ${t};`:`\n    for (int i = 0; i < ${e}; i++) {\n      if (i == index) {\n        return ${t}[i];\n      }\n    }\n  `}function jn(n){if(n<=1)return"int";if(2===n)return"ivec2";if(3===n)return"ivec3";if(4===n)return"ivec4";if(5===n)return"ivec5";if(6===n)return"ivec6";throw Error(`GPU for rank ${n} is not yet supported`)}function Xk(n,t,e){const{newShape:r,keptDims:i}=sc(t),o=t.length,s=n&&3===o&&1===t[0],a=s?t.slice(1):r,c=!n&&o>1&&!mn(t,e)&&r.length<o||s;return{useSqueezeShape:c,uniformShape:c?a:t,keptDims:i}}function rp(n,t){const e=JSON.parse(JSON.stringify(n));return e.shapeInfo.logicalShape=t,e}function ip(n,t){return t.map(e=>n[e]).join(", ")}function mj(n,t,e){const r=[],i=[];let o,s,a,c=null,u=null;u=n.getUniformLocation(e,"NAN",!1),1===Ie().getNumber("WEBGL_VERSION")&&(c=n.getUniformLocation(e,"INFINITY",!1));const p=!1;for(const m of t.variableNames){const g={name:m,uniform:n.getUniformLocation(e,m,p),offset:n.getUniformLocation(e,`offset${m}`,p)};t.enableShapeUniforms&&(g.shape=n.getUniformLocation(e,`${m}Shape`,p),g.texShape=n.getUniformLocation(e,`${m}TexShape`,p)),r.push(g)}if(t.enableShapeUniforms&&(o=n.getUniformLocation(e,"outShape",p),a=n.getUniformLocation(e,"outShapeStrides",p),s=n.getUniformLocation(e,"outTexShape",p)),t.customUniforms)for(const m of t.customUniforms)i.push(n.getUniformLocation(e,m.name,p));return{variablesLocations:r,customUniformLocations:i,infLoc:c,nanLoc:u,outShapeLocation:o,outShapeStridesLocation:a,outTexShapeLocation:s}}function gj(n,t){if(n.length!==t.length)throw Error(`Binary was compiled with ${n.length} inputs, but was executed with ${t.length} inputs`);n.forEach((e,r)=>{const i=e.logicalShape,o=t[r],s=o.shape;if(!mn(i,s))throw Error(`Binary was compiled with different shapes than the current args. Shapes ${i} and ${s} must match`);if(e.isUniform&&o.isUniform)return;const a=e.texShape,c=o.isUniform?null:o.texData.texShape;if(!mn(a,c))throw Error(`Binary was compiled with different texture shapes than the current args. Shape ${a} and ${c} must match`)})}function Hi(n){return Ie().getBool("WEBGL_USE_SHAPES_UNIFORMS")&&n<=4}class PTe{constructor(t){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outPackingScheme=Xa.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const e=so();this.outputShape=t,this.enableShapeUniforms=Hi(this.outputShape.length),this.userCode=`\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ${this.enableShapeUniforms?mx(["r","c","d"],t):Yu(["r","c","d"],t)}\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));\n        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getA(rc.x, rc.y, rc.z);\n        }\n\n        ${e.output} = result;\n      }\n    `}}class $Te{constructor(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outPackingScheme=Xa.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const e=so();this.outputShape=t,this.enableShapeUniforms=Hi(this.outputShape.length),this.userCode=`\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ${this.enableShapeUniforms?mx(["r","c","d"],t):Yu(["r","c","d"],t)}\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));\n        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));\n        }\n\n        ${e.output} = result;\n      }\n    `}}class LTe{constructor(t){this.variableNames=["A"],this.outTexUsage=$r.DOWNLOAD;const e=so();this.outputShape=t,this.userCode=`\n      ${dj}\n\n      void main() {\n        float x = getAAtOutCoords();\n        ${e.output} = encode_float(x);\n      }\n    `}}class BTe{constructor(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outTexUsage=$r.DOWNLOAD;const e=so();this.outputShape=t,this.userCode=`\n      ${dj}\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));\n        ${e.output} = encode_float(x);\n      }\n    `}}const VTe={R:0,G:1,B:2,A:3};class bj{constructor(t,e=!1,r="RGBA"){this.variableNames=["A"],this.customUniforms=[{name:"texShape",type:"ivec2"}];const i=so();this.outputShape=t,this.enableShapeUniforms=Hi(this.outputShape.length);let o="result";e&&(o="floor(result * 255. + 0.5)");let s="";for(let a=0;a<r.length;a++)s+=`\n          if(offset == ${a}) {\n            result = values[${VTe[r[a]]}];\n          }`;this.userCode=`\n      ${this.enableShapeUniforms?"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n":qk(t)}\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int flatIndex = getFlatIndex(coords);\n        float result = 0.;\n        int offset = imod(flatIndex, ${r.length});\n\n        flatIndex = idiv(flatIndex, ${r.length}, 1.);\n\n        int r = flatIndex / texShape[1];\n        if (r < texShape[0]) {\n          int c = imod(flatIndex, texShape[1]);\n          vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);\n          vec4 values = ${i.texture2D}(A, uv);\n          ${s}\n        }\n        ${i.output} = vec4(${o}, 0., 0., 0.);\n      }\n    `}}class zTe{constructor(t,e=!1){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.customUniforms=[{name:"texShape",type:"ivec2"}];const r=so();this.outputShape=t,this.enableShapeUniforms=Hi(this.outputShape.length);let i="",o="result";e&&(o="floor(result * 255. + 0.5)");for(let s=0;s<=1;s++)for(let a=0;a<=1;a++){const c=2*s+a;i+=`\n          localCoords = coords;\n          if(localCoords[2] + ${a} < ${this.enableShapeUniforms?"outShape[2]":`${t[2]}`}) {\n          localCoords[2] += ${a};\n          if (localCoords[1] + ${s} < ${this.enableShapeUniforms?"outShape[1]":`${t[1]}`}) {\n            localCoords[1] += ${s};\n\n            flatIndex = getFlatIndex(localCoords);\n            offset = imod(flatIndex, 4);\n\n            flatIndex = idiv(flatIndex, 4, 1.);\n\n            int r = flatIndex / texShape[1];\n            int c = imod(flatIndex, texShape[1]);\n            vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);\n            values = ${r.texture2D}(A, uv);\n\n            if (offset == 0) {\n              result[${c}] = values[0];\n            } else if (offset == 1) {\n              result[${c}] = values[1];\n            } else if (offset == 2) {\n              result[${c}] = values[2];\n            } else {\n              result[${c}] = values[3];\n            }\n          }\n        }\n        `}this.userCode=`\n        ${this.enableShapeUniforms?"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n":qk(t)}\n\n        void main() {\n          ivec3 coords = getOutputCoords();\n\n          vec4 result = vec4(0.);\n          int flatIndex, r, c, offset;\n          ivec3 localCoords;\n          vec2 uv;\n          vec4 values;\n\n          ${i}\n\n          ${r.output} = ${o};\n        }\n    `}}function jg(n,t,e,r,i,o){!function Mwe(n,t){const e=Ie().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(n<=0||t<=0)throw new Error(`Requested texture size [${n}x${t}] is invalid.`);if(n>e||t>e)throw new Error(`Requested texture size [${n}x${t}] greater than WebGL maximum on this browser / GPU [${e}x${e}].`)}(t,e);const s=function Rwe(n){return Nl(n,()=>n.createTexture(),"Unable to create WebGLTexture.")}(n),a=n.TEXTURE_2D;return dt(n,()=>n.bindTexture(a,s)),dt(n,()=>n.texParameteri(a,n.TEXTURE_WRAP_S,n.CLAMP_TO_EDGE)),dt(n,()=>n.texParameteri(a,n.TEXTURE_WRAP_T,n.CLAMP_TO_EDGE)),dt(n,()=>n.texParameteri(a,n.TEXTURE_MIN_FILTER,n.NEAREST)),dt(n,()=>n.texParameteri(a,n.TEXTURE_MAG_FILTER,n.NEAREST)),1===Ie().getNumber("WEBGL_VERSION")?dt(n,()=>n.texImage2D(a,0,r,t,e,0,i,o,null)):dt(n,()=>n.texStorage2D(a,1,r,t,e)),dt(n,()=>n.bindTexture(n.TEXTURE_2D,null)),{texture:s,texShape:[e,t]}}function yj(n){return n.internalFormatFloat}function _j(n){return n.internalFormatHalfFloat}function vj(n){return n.downloadTextureFormat}function xj(n){return n.internalFormatPackedFloat}function wj(n){return n.internalFormatPackedHalfFloat}class Yk{constructor(t){this.outputTexture=null,this.program=null,this.disposed=!1,this.itemsToPoll=[];const e=Ie().getNumber("WEBGL_VERSION");if(null!=t?(this.gl=t,function gwe(n,t){$c[n]=t}(e,t)):this.gl=ma(e),t=this.gl,2===Ie().getNumber("WEBGL_VERSION")){const o=t;this.createVertexArray=()=>dt(o,()=>o.createVertexArray()),this.bindVertexArray=s=>dt(o,()=>o.bindVertexArray(s)),this.deleteVertexArray=s=>dt(o,()=>o.deleteVertexArray(s)),this.getVertexArray=()=>dt(o,()=>o.getParameter(o.VERTEX_ARRAY_BINDING))}else if(null!=t){const o=t.getExtension("OES_vertex_array_object");if(null==o)throw new Error("All WebGL1 implementations are expected to offer OES_vertex_array_object.");this.createVertexArray=()=>dt(t,()=>o.createVertexArrayOES()),this.bindVertexArray=s=>dt(t,()=>o.bindVertexArrayOES(s)),this.deleteVertexArray=s=>dt(t,()=>o.deleteVertexArrayOES(s)),this.getVertexArray=()=>dt(t,()=>t.getParameter(o.VERTEX_ARRAY_BINDING_OES))}let r="WEBGL_color_buffer_float";const i="EXT_color_buffer_half_float";if(this.parallelCompilationExtension=this.gl.getExtension("KHR_parallel_shader_compile"),1===Ie().getNumber("WEBGL_VERSION")){const s="OES_texture_half_float";if(this.textureFloatExtension=lx(this.gl,"OES_texture_float"),js(this.gl,s))this.textureHalfFloatExtension=lx(this.gl,s);else if(Ie().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");if(this.colorBufferFloatExtension=this.gl.getExtension(r),js(this.gl,i))this.colorBufferHalfFloatExtension=lx(this.gl,i);else if(Ie().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}else if(r="EXT_color_buffer_float",js(this.gl,r))this.colorBufferFloatExtension=this.gl.getExtension(r);else{if(!js(this.gl,i))throw new Error("GL context does not support color renderable floats");this.colorBufferHalfFloatExtension=this.gl.getExtension(i)}this.vertexBuffer=function jTe(n){return function Nwe(n,t){const e=Nl(n,()=>n.createBuffer(),"Unable to create WebGLBuffer");return dt(n,()=>n.bindBuffer(n.ARRAY_BUFFER,e)),dt(n,()=>n.bufferData(n.ARRAY_BUFFER,t,n.STATIC_DRAW)),e}(n,new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]))}(this.gl),this.indexBuffer=function GTe(n){return function Owe(n,t){const e=Nl(n,()=>n.createBuffer(),"Unable to create WebGLBuffer");return dt(n,()=>n.bindBuffer(n.ELEMENT_ARRAY_BUFFER,e)),dt(n,()=>n.bufferData(n.ELEMENT_ARRAY_BUFFER,t,n.STATIC_DRAW)),e}(n,new Uint16Array([0,1,2,2,1,3]))}(this.gl),this.framebuffer=function Fwe(n){return Nl(n,()=>n.createFramebuffer(),"Unable to create WebGLFramebuffer.")}(this.gl),this.textureConfig=jk(this.gl,this.textureHalfFloatExtension)}get debug(){return Ie().getBool("DEBUG")}dispose(){if(this.disposed)return;null!=this.program&&console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."),null!=this.outputTexture&&console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");const t=this.gl;dt(t,()=>t.finish()),dt(t,()=>t.bindFramebuffer(t.FRAMEBUFFER,null)),dt(t,()=>t.deleteFramebuffer(this.framebuffer)),dt(t,()=>t.bindBuffer(t.ARRAY_BUFFER,null)),dt(t,()=>t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,null)),dt(t,()=>t.deleteBuffer(this.indexBuffer)),this.disposed=!0}createFloat32MatrixTexture(t,e){return this.throwIfDisposed(),function HTe(n,t,e,r){const[i,o]=zg(t,e);return jg(n,i,o,yj(r),r.textureFormatFloat,n.FLOAT)}(this.gl,t,e,this.textureConfig)}createFloat16MatrixTexture(t,e){return this.throwIfDisposed(),function WTe(n,t,e,r){const[i,o]=zg(t,e);return jg(n,i,o,_j(r),r.textureFormatFloat,r.textureTypeHalfFloat)}(this.gl,t,e,this.textureConfig)}createUnsignedBytesMatrixTexture(t,e){return this.throwIfDisposed(),function qTe(n,t,e,r){const[i,o]=zg(t,e);return jg(n,i,o,vj(r),n.RGBA,n.UNSIGNED_BYTE)}(this.gl,t,e,this.textureConfig)}uploadPixelDataToTexture(t,e){this.throwIfDisposed(),function QTe(n,t,e){dt(n,()=>n.bindTexture(n.TEXTURE_2D,t)),e.data instanceof Uint8Array?2===Ie().getNumber("WEBGL_VERSION")?dt(n,()=>n.texSubImage2D(n.TEXTURE_2D,0,0,0,e.width,e.height,n.RGBA,n.UNSIGNED_BYTE,e.data)):dt(n,()=>n.texImage2D(n.TEXTURE_2D,0,n.RGBA,e.width,e.height,0,n.RGBA,n.UNSIGNED_BYTE,e.data)):2===Ie().getNumber("WEBGL_VERSION")?dt(n,()=>n.texSubImage2D(n.TEXTURE_2D,0,0,0,n.RGBA,n.UNSIGNED_BYTE,e)):dt(n,()=>n.texImage2D(n.TEXTURE_2D,0,n.RGBA,n.RGBA,n.UNSIGNED_BYTE,e)),dt(n,()=>n.bindTexture(n.TEXTURE_2D,null))}(this.gl,t,e)}uploadDenseMatrixToTexture(t,e,r,i){this.throwIfDisposed(),function ZTe(n,t,e,r,i,o){let s,a,c;dt(n,()=>n.bindTexture(n.TEXTURE_2D,t)),i instanceof Uint8Array?(s=new Uint8Array(e*r*4),a=n.UNSIGNED_BYTE,c=n.RGBA):(s=new Float32Array(e*r*4),a=n.FLOAT,c=o.internalFormatPackedFloat),s.set(i),2===Ie().getNumber("WEBGL_VERSION")?dt(n,()=>n.texSubImage2D(n.TEXTURE_2D,0,0,0,e,r,n.RGBA,a,s)):dt(n,()=>n.texImage2D(n.TEXTURE_2D,0,c,e,r,0,n.RGBA,a,s)),dt(n,()=>n.bindTexture(n.TEXTURE_2D,null))}(this.gl,t,e,r,i,this.textureConfig)}createFloat16PackedMatrixTexture(t,e){return this.throwIfDisposed(),function XTe(n,t,e,r){const[i,o]=Qh(t,e);return jg(n,i,o,wj(r),n.RGBA,r.textureTypeHalfFloat)}(this.gl,t,e,this.textureConfig)}createPackedMatrixTexture(t,e){return this.throwIfDisposed(),function KTe(n,t,e,r){const[i,o]=Qh(t,e);return jg(n,i,o,xj(r),n.RGBA,n.FLOAT)}(this.gl,t,e,this.textureConfig)}deleteMatrixTexture(t){this.throwIfDisposed(),this.outputTexture===t&&(lj(this.gl,this.framebuffer),this.outputTexture=null),dt(this.gl,()=>this.gl.deleteTexture(t))}downloadByteEncodedFloatMatrixFromOutputTexture(t,e,r){return this.downloadMatrixDriver(t,()=>function t1e(n,t,e,r){const[i,o]=zg(t,e),a=new Uint8Array(function _we(n,t){return n*t}(t*e,4));return dt(n,()=>n.readPixels(0,0,i,o,r.downloadTextureFormat,n.UNSIGNED_BYTE,a)),new Float32Array(a.buffer)}(this.gl,e,r,this.textureConfig))}downloadPackedMatrixFromBuffer(t,e,r,i,o,s){return function n1e(n,t,e,r,i,o,s,a){const c=n,u=new Float32Array(function vwe(n,t){const[e,r]=Qh(n,t);return e*r*4}(o,s));return c.bindBuffer(c.PIXEL_PACK_BUFFER,t),c.getBufferSubData(c.PIXEL_PACK_BUFFER,0,u),c.bindBuffer(c.PIXEL_PACK_BUFFER,null),u}(this.gl,t,0,0,0,o,s)}downloadFloat32MatrixFromBuffer(t,e){return function e1e(n,t,e){const r=n,i=new Float32Array(e);return r.bindBuffer(r.PIXEL_PACK_BUFFER,t),r.getBufferSubData(r.PIXEL_PACK_BUFFER,0,i),r.bindBuffer(r.PIXEL_PACK_BUFFER,null),i}(this.gl,t,e)}createBufferFromTexture(t,e,r){this.bindTextureToFrameBuffer(t);const i=function JTe(n,t,e,r){const i=n.createBuffer();dt(n,()=>n.bindBuffer(n.PIXEL_PACK_BUFFER,i));const a=16*t*e;return dt(n,()=>n.bufferData(n.PIXEL_PACK_BUFFER,a,n.STREAM_READ)),dt(n,()=>n.readPixels(0,0,e,t,n.RGBA,n.FLOAT,0)),dt(n,()=>n.bindBuffer(n.PIXEL_PACK_BUFFER,null)),i}(this.gl,e,r);return this.unbindTextureToFrameBuffer(),i}createAndWaitForFence(){const t=this.createFence(this.gl);return this.pollFence(t)}createFence(t){let e,r;if(Ie().getBool("WEBGL_FENCE_API_ENABLED")){const i=t,o=i.fenceSync(i.SYNC_GPU_COMMANDS_COMPLETE,0);t.flush(),r=()=>{const s=i.clientWaitSync(o,0,0);return s===i.ALREADY_SIGNALED||s===i.CONDITION_SATISFIED},e=o}else Ie().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(e=this.beginQuery(),this.endQuery(),r=()=>this.isQueryAvailable(e,Ie().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))):r=()=>!0;return{query:e,isFencePassed:r}}downloadMatrixFromPackedTexture(t,e,r){return this.downloadMatrixDriver(t,()=>function r1e(n,t,e){const r=new Float32Array(t*e*4);return dt(n,()=>n.readPixels(0,0,e,t,n.RGBA,n.FLOAT,r)),r}(this.gl,e,r))}createProgram(t){this.throwIfDisposed();const e=this.gl;null==this.vertexShader&&(this.vertexShader=function UTe(n){const t=so();return function Iwe(n,t){const e=Nl(n,()=>n.createShader(n.VERTEX_SHADER),"Unable to create vertex WebGLShader.");if(dt(n,()=>n.shaderSource(e,t)),dt(n,()=>n.compileShader(e)),!1===n.getShaderParameter(e,n.COMPILE_STATUS))throw console.log(n.getShaderInfoLog(e)),new Error("Failed to compile vertex shader.");return e}(n,`${t.version}\n    precision highp float;\n    ${t.attribute} vec3 clipSpacePos;\n    ${t.attribute} vec2 uv;\n    ${t.varyingVs} vec2 resultUV;\n\n    void main() {\n      gl_Position = vec4(clipSpacePos, 1);\n      resultUV = uv;\n    }`)}(e));const r=function kwe(n){return Nl(n,()=>n.createProgram(),"Unable to create WebGLProgram.")}(e);dt(e,()=>e.attachShader(r,this.vertexShader)),dt(e,()=>e.attachShader(r,t)),function Awe(n,t){if(dt(n,()=>n.linkProgram(t)),!Ie().get("ENGINE_COMPILE_ONLY")&&!1===n.getProgramParameter(t,n.LINK_STATUS))throw console.log(n.getProgramInfoLog(t)),new Error("Failed to link vertex and fragment shaders.")}(e,r);const i=Object.assign(r,{vao:this.createVertexArray()});return this.debug&&Gk(e,i),i}buildVao(t){this.setProgram(t),this.bindVertexArray(t.vao);const e=this.gl;dt(e,()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,this.indexBuffer)),function YTe(n,t,e){dt(n,()=>n.bindBuffer(n.ARRAY_BUFFER,e)),aj(n,t,"clipSpacePos",e,3,20,0)&&aj(n,t,"uv",e,2,20,12)}(e,t,this.vertexBuffer)}deleteProgram(t){this.throwIfDisposed(),t===this.program&&(this.program=null),null!=t&&(dt(this.gl,()=>this.gl.deleteProgram(t)),this.deleteVertexArray(t.vao))}setProgram(t){this.throwIfDisposed(),this.program=t,null!=this.program&&this.debug&&Gk(this.gl,this.program),dt(this.gl,()=>this.gl.useProgram(t))}getUniformLocation(t,e,r=!0){return this.throwIfDisposed(),r?function $we(n,t,e){return Nl(n,()=>n.getUniformLocation(t,e),'uniform "'+e+'" not present in program.')}(this.gl,t,e):function Lwe(n,t,e){return n.getUniformLocation(t,e)}(this.gl,t,e)}getAttributeLocation(t,e){return this.throwIfDisposed(),dt(this.gl,()=>this.gl.getAttribLocation(t,e))}getUniformLocationNoThrow(t,e){return this.throwIfDisposed(),this.gl.getUniformLocation(t,e)}setInputMatrixTexture(t,e,r){this.throwIfDisposed(),this.throwIfNoProgram(),Bwe(this.gl,t,e,r)}setOutputMatrixTexture(t,e,r){this.setOutputMatrixTextureDriver(t,r,e)}setOutputPackedMatrixTexture(t,e,r){this.throwIfDisposed();const[i,o]=Qh(e,r);this.setOutputMatrixTextureDriver(t,i,o)}setOutputMatrixWriteRegion(t,e,r,i){this.setOutputMatrixWriteRegionDriver(r,t,i,e)}setOutputPackedMatrixWriteRegion(t,e,r,i){throw new Error("setOutputPackedMatrixWriteRegion not implemented.")}debugValidate(){null!=this.program&&Gk(this.gl,this.program),cx(this.gl)}executeProgram(){this.throwIfDisposed(),this.throwIfNoProgram();const t=this.gl;if(this.debug){const e=this.getVertexArray();console.assert(e===this.program.vao,"VAO changed between setProgram and executeProgram!"),this.debugValidate()}dt(t,()=>t.drawElements(t.TRIANGLES,6,t.UNSIGNED_SHORT,0))}blockUntilAllProgramsCompleted(){this.throwIfDisposed(),dt(this.gl,()=>this.gl.finish())}getQueryTimerExtension(){return null==this.disjointQueryTimerExtension&&(this.disjointQueryTimerExtension=lx(this.gl,2===Ie().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")),this.disjointQueryTimerExtension}getQueryTimerExtensionWebGL2(){return this.getQueryTimerExtension()}getQueryTimerExtensionWebGL1(){return this.getQueryTimerExtension()}beginQuery(){if(2===Ie().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){const r=this.gl,i=this.getQueryTimerExtensionWebGL2(),o=r.createQuery();return r.beginQuery(i.TIME_ELAPSED_EXT,o),o}const t=this.getQueryTimerExtensionWebGL1(),e=t.createQueryEXT();return t.beginQueryEXT(t.TIME_ELAPSED_EXT,e),e}endQuery(){if(2===Ie().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){const e=this.gl,r=this.getQueryTimerExtensionWebGL2();return void e.endQuery(r.TIME_ELAPSED_EXT)}const t=this.getQueryTimerExtensionWebGL1();t.endQueryEXT(t.TIME_ELAPSED_EXT)}waitForQueryAndGetTime(t){var e=this;return $e(function*(){return yield qL(()=>e.disposed||e.isQueryAvailable(t,Ie().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))),e.getQueryTime(t,Ie().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))})()}getQueryTime(t,e){if(0===e)return null;if(2===e){const r=this.gl;return r.getQueryParameter(t,r.QUERY_RESULT)/1e6}{const r=this.getQueryTimerExtensionWebGL1();return r.getQueryObjectEXT(t,r.QUERY_RESULT_EXT)/1e6}}isQueryAvailable(t,e){if(0===e)return!0;if(2===e){const r=this.gl,i=this.getQueryTimerExtensionWebGL2(),o=r.getQueryParameter(t,r.QUERY_RESULT_AVAILABLE);return null==this.disjoint&&(this.disjoint=this.gl.getParameter(i.GPU_DISJOINT_EXT)),o&&!this.disjoint}{const r=this.getQueryTimerExtensionWebGL1(),i=r.getQueryObjectEXT(t,r.QUERY_RESULT_AVAILABLE_EXT);return null==this.disjoint&&(this.disjoint=this.gl.getParameter(r.GPU_DISJOINT_EXT)),i&&!this.disjoint}}pollFence(t){return new Promise(e=>{this.addItemToPoll(()=>t.isFencePassed(),()=>e())})}pollItems(){const t=function i1e(n){let t=0;for(;t<n.length&&n[t]();++t);return t-1}(this.itemsToPoll.map(e=>e.isDoneFn));for(let e=0;e<=t;++e){const{resolveFn:r}=this.itemsToPoll[e];r()}this.itemsToPoll=this.itemsToPoll.slice(t+1)}addItemToPoll(t,e){if(this.itemsToPoll.push({isDoneFn:t,resolveFn:e}),this.itemsToPoll.length>1)return;let r;"setTimeoutCustom"in Ie().platform&&(r=Ie().platform.setTimeoutCustom.bind(Ie().platform)),qL(()=>(this.pollItems(),0===this.itemsToPoll.length),()=>0,null,r)}bindTextureToFrameBuffer(t){this.throwIfDisposed(),Hk(this.gl,t,this.framebuffer),this.debug&&cx(this.gl)}unbindTextureToFrameBuffer(){null!=this.outputTexture?(Hk(this.gl,this.outputTexture,this.framebuffer),this.debug&&cx(this.gl)):lj(this.gl,this.framebuffer)}downloadMatrixDriver(t,e){this.bindTextureToFrameBuffer(t);const r=e();return this.unbindTextureToFrameBuffer(),r}setOutputMatrixTextureDriver(t,e,r){this.throwIfDisposed();const i=this.gl;Hk(i,t,this.framebuffer),this.debug&&cx(i),this.outputTexture=t,dt(i,()=>i.viewport(0,0,e,r)),dt(i,()=>i.scissor(0,0,e,r))}setOutputMatrixWriteRegionDriver(t,e,r,i){this.throwIfDisposed(),dt(this.gl,()=>this.gl.scissor(t,e,r,i))}throwIfDisposed(){if(this.disposed)throw new Error("Attempted to use disposed GPGPUContext.")}throwIfNoProgram(){if(null==this.program)throw new Error("No GPU program is currently set.")}}const{addImpl:o1e,bincountImpl:Tj,bincountReduceImpl:s1e,castImpl:a1e,ceilImpl:l1e,concatImpl:c1e,equalImpl:u1e,expImpl:d1e,expm1Impl:h1e,floorImpl:p1e,gatherNdImpl:f1e,gatherV2Impl:m1e,greaterImpl:g1e,greaterEqualImpl:b1e,lessImpl:y1e,lessEqualImpl:_1e,linSpaceImpl:v1e,logImpl:x1e,maxImpl:w1e,maximumImpl:T1e,minimumImpl:S1e,multiplyImpl:C1e,negImpl:I1e,notEqualImpl:E1e,prodImpl:D1e,raggedGatherImpl:k1e,raggedRangeImpl:A1e,raggedTensorToTensorImpl:N1e,rangeImpl:O1e,rsqrtImpl:R1e,scatterImpl:M1e,sigmoidImpl:F1e,simpleAbsImpl:Sj,sliceImpl:P1e,sparseFillEmptyRowsImpl:$1e,sparseReshapeImpl:L1e,sparseSegmentReductionImpl:Cj,sqrtImpl:B1e,staticRegexReplaceImpl:V1e,stridedSliceImpl:z1e,stringNGramsImpl:U1e,stringSplitImpl:j1e,stringToHashBucketFastImpl:G1e,subImpl:H1e,tileImpl:W1e,topKImpl:q1e,transposeImpl:Zk,uniqueImpl:K1e}=X;function Ij(n,t){return["x","y","z","w","u","v"].slice(0,t).map(e=>`${n}.${e}`)}function ao(n,t){return 1===t?[n]:Ij(n,t)}class Y1e{constructor(t){if(this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outputShape=t,this.rank=t.length,this.enableShapeUniforms=Hi(this.outputShape.length),0===this.rank)this.userCode="\n        void main() {\n          setOutput(vec4(getA(), 0., 0., 0.));\n        }\n      ";else{const e=ao("rc",this.rank),r=jn(this.rank),i=this.getOutOfBoundsCondition(e),o=this.getSetup(e),s=this.getOutput(e);this.userCode=`\n        void main() {\n          ${r} rc = getOutputCoords();\n\n          if(${i}) {\n            setOutput(vec4(0));\n          } else {\n            ${o}\n\n            setOutput(vec4(${s}));\n          }\n        }\n      `}}getSourceCoordsArr(t){const e=[];for(let r=0;r<=1;r++)for(let i=0;i<=1;i++){let o=`${0===r?"r":"rp1"}, ${0===i?"c":"cp1"}`;for(let s=2;s<this.rank;s++)o=`${t[t.length-1-s]},`+o;e.push(o)}return e}getOutOfBoundsCondition(t){if(1===this.rank)return`rc > ${this.enableShapeUniforms?"outShape":this.outputShape[0]}`;let e="";for(let r=this.rank-2;r<this.rank;r++)e+=`${t[r]} >= ${this.enableShapeUniforms?`outShape[${r}]`:this.outputShape[r]}`,r<this.rank-1&&(e+="||");return e}getSetup(t){if(1===this.rank)return"";const e=t.slice(-2);return`\n      int r = ${e[0]};\n      int c = ${e[1]};\n      int rp1 = r + 1;\n      int cp1 = c + 1;\n\n      bool cEdge = cp1 >= ${this.enableShapeUniforms?`outShape[${this.rank} - 1]`:this.outputShape[this.rank-1]};\n      bool rEdge = rp1 >= ${this.enableShapeUniforms?`outShape[${this.rank} - 2]`:this.outputShape[this.rank-2]};\n    `}getOutput(t){const e=this.getSourceCoordsArr(t);return 1===this.rank?`getA(rc), (rc + 1 >= ${this.enableShapeUniforms?"outShape":this.outputShape[0]} ? 0. : getA(rc + 1)), 0, 0`:`getA(${e[0]}),\n            cEdge ? 0. : getA(${e[1]}),\n            rEdge ? 0. : getA(${e[2]}),\n            rEdge || cEdge ? 0. : getA(${e[3]})`}}class Ej{constructor(t,e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec3"}],this.outputShape=t,this.enableShapeUniforms=Hi(this.outputShape.length);let r="";for(let i=0;i<4;i++){let o="thisRC = rc;";i%2==1&&(o+="thisRC.z += 1;"),i>1&&(o+="thisRC.y += 1;"),r+=`\n        ${o}\n        ${i>0?"if(thisRC.y < rows && thisRC.z < cols){":""}\n          int flatIndex = getFlatIndex(thisRC);\n\n          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);\n          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));\n\n          result[${i}] =\n            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);\n        ${i>0?"}":""}\n      `}this.userCode=`\n      ${function Z1e(n,t){return`\n    ivec3 inputCoordsFromReshapedOutCoords(int index) {\n      ${t?function Ywe(n,t,e="index"){const i=function Xwe(n,t){const e=n.length,r=n.map(o=>`${t}[${o}]`),i=new Array(e-1);i[e-2]=r[e-1];for(let o=e-3;o>=0;--o)i[o]=`(${i[o+1]} * ${r[o+1]})`;return i}(n.map((o,s)=>s),t);return i.map((o,s)=>`int ${n[s]} = ${e} / ${i[s]}; ${s===i.length-1?`int ${n[s+1]} = ${e} - ${n[s]} * ${i[s]}`:`index -= ${n[s]} * ${i[s]}`};`).join("")}(["r","c","d"],"inputShape"):Yu(["r","c","d"],n)}\n      return ivec3(r, c, d);\n    }\n  `}(e,this.enableShapeUniforms)}\n      ${this.enableShapeUniforms?"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n":qk(t)}\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0.);\n\n        ivec3 thisRC;\n        int rows = ${this.enableShapeUniforms?"outShape[1]":t[1]};\n        int cols = ${this.enableShapeUniforms?"outShape[2]":t[2]};\n\n        ${r}\n\n        setOutput(result);\n      }\n    `}}class Q1e{constructor(t){this.gpgpu=t,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0,this.freeTextures={},this.usedTextures={},this.logEnabled=!1}acquireTexture(t,e,r){const i=kj(e,r),o=Aj(t,i,r);o in this.freeTextures||(this.freeTextures[o]=[]),o in this.usedTextures||(this.usedTextures[o]=[]);const s=Dj(t,i,this.gpgpu.gl,this.gpgpu.textureConfig,r);if(this.freeTextures[o].length>0){this.numFreeTextures--,this.numUsedTextures++,this._numBytesFree-=s,this.log();const c=this.freeTextures[o].pop();return this.usedTextures[o].push(c),c}let a;return i===Un.PACKED_2X2_FLOAT32?a=this.gpgpu.createPackedMatrixTexture(t[0],t[1]):i===Un.PACKED_2X2_FLOAT16?a=this.gpgpu.createFloat16PackedMatrixTexture(t[0],t[1]):i===Un.UNPACKED_FLOAT32?a=this.gpgpu.createFloat32MatrixTexture(t[0],t[1]):i===Un.UNPACKED_FLOAT16?a=this.gpgpu.createFloat16MatrixTexture(t[0],t[1]):i===Un.PACKED_4X1_UNSIGNED_BYTE&&(a=this.gpgpu.createUnsignedBytesMatrixTexture(t[0],t[1])),this.usedTextures[o].push(a),this.numUsedTextures++,this._numBytesAllocated+=s,this.log(),a}releaseTexture(t,e,r,i){if(null==this.freeTextures)return;const o=kj(r,i),s=Aj(e,o,i);s in this.freeTextures||(this.freeTextures[s]=[]);const a=Dj(e,o,this.gpgpu.gl,this.gpgpu.textureConfig,i),c=Ie().get("WEBGL_DELETE_TEXTURE_THRESHOLD");-1!==c&&this._numBytesAllocated>c?(this.gpgpu.deleteMatrixTexture(t.texture),this._numBytesAllocated-=a):(this.freeTextures[s].push(t),this.numFreeTextures++,this._numBytesFree+=a),this.numUsedTextures--;const u=this.usedTextures[s],p=u&&u.indexOf(t);if(null==p||p<0)throw new Error("Cannot release a texture that was never provided by this texture manager");u[p]=u[u.length-1],u.pop(),this.log()}log(){if(!this.logEnabled)return;console.log("Free/Used",`${this.numFreeTextures} / ${this.numUsedTextures}`,`(${this.numFreeTextures+this.numUsedTextures})`);const e=this._numBytesFree/this._numBytesAllocated;console.log(`Bytes allocated: ${this._numBytesAllocated}`),console.log(`Bytes unused: ${this._numBytesFree} (${Math.round(100*e)}%)`)}get numBytesAllocated(){return this._numBytesAllocated}get numBytesFree(){return this._numBytesFree}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){if(null!=this.freeTextures){for(const t in this.freeTextures)this.freeTextures[t].forEach(e=>{this.gpgpu.deleteMatrixTexture(e.texture)});for(const t in this.usedTextures)this.usedTextures[t].forEach(e=>{this.gpgpu.deleteMatrixTexture(e.texture)});this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0}}}function Dj(n,t,e,r,i){const o=function eSe(n,t){switch(n){case Un.PACKED_2X2_FLOAT32:return xj(t);case Un.PACKED_2X2_FLOAT16:return wj(t);case Un.UNPACKED_FLOAT32:return yj(t);case Un.UNPACKED_FLOAT16:return _j(t);case Un.PACKED_4X1_UNSIGNED_BYTE:return vj(t);default:throw new Error(`Unknown physical texture type ${n}`)}}(t,r);let s;if(i){const[c,u]=Qh(n[0],n[1]);s=c*u}else{const[c,u]=zg(n[0],n[1]);s=c*u}const a=function J1e(n,t){if(t===n.R32F)return 4;if(t===n.R16F)return 2;if(t===n.RGBA32F)return 16;if(t===n.RGBA)return 16;if(t===n.RGBA16F)return 8;if(t===n.RGBA8)return 4;throw new Error(`Unknown internal format ${t}`)}(e,o);return s*a}function kj(n,t){if(n===$r.UPLOAD)return Un.PACKED_2X2_FLOAT32;if(n===$r.RENDER||null==n)return function tSe(n){return Ie().getBool("WEBGL_RENDER_FLOAT32_ENABLED")?n?Un.PACKED_2X2_FLOAT32:Un.UNPACKED_FLOAT32:n?Un.PACKED_2X2_FLOAT16:Un.UNPACKED_FLOAT16}(t);if(n===$r.DOWNLOAD||n===$r.PIXELS)return Un.PACKED_4X1_UNSIGNED_BYTE;throw new Error(`Unknown logical texture type ${n}`)}function Aj(n,t,e){return`${n[0]}_${n[1]}_${t}_${e}`}class Ya{constructor(t,e){this.variableNames=["A"],this.outputShape=t,this.enableShapeUniforms=Hi(this.outputShape.length),this.userCode=`\n      float unaryOperation(float x) {\n        ${e}\n      }\n\n      void main() {\n        float x = getAAtOutCoords();\n        float y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    `}}const gs="if (isnan(x)) return x;",nSe="return x;",Nj="return abs(x);",rSe="return (x >= 0.0) ? x : (exp(x) - 1.0);",iSe=gs+"\n  return (x < 0.0) ? 0.0 : x;\n",oSe=gs+"\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n",Lc="return x;",sSe="return 1.0 / (1.0 + exp(-1.0 * x));",aSe="return x;",lSe="\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n",cSe="\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",uSe="\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",dSe="return 1.0 / (1.0 + exp(-1.0 * x));";class Bc{constructor(t,e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t,this.enableShapeUniforms=Hi(this.outputShape.length),this.userCode=`\n      vec4 unaryOperation(vec4 x) {\n        ${e}\n      }\n\n      void main() {\n        vec4 x = getAAtOutCoords();\n        vec4 y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    `}}class hSe{constructor(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outputShape=t,this.enableShapeUniforms=Hi(this.outputShape.length);const e=t.length,r=ao("rc",e),i=jn(e),o=function X1e(n,t){if(1===n)return"rc";let e="";for(let r=0;r<n;r++)e+=t[r],r<n-1&&(e+=",");return e}(e,r),s=r.slice(-2),a=e<=1?"rc":`vec2(${s.join(",")})`;this.userCode=`\n      void main() {\n        ${i} rc = getOutputCoords();\n        vec4 packedInput = getA(${o});\n\n        setOutput(getChannel(packedInput, ${a}));\n      }\n    `}}const pSe=VE,bx={},bSe=Ie().getNumber("CPU_HANDOFF_SIZE_THRESHOLD");let vSe=(()=>{class n extends aC{nextDataId(){return n.nextDataId++}constructor(e){if(super(),this.pendingRead=new WeakMap,this.pendingDisposal=new WeakSet,this.dataRefCount=new WeakMap,this.numBytesInGPU=0,this.uploadWaitMs=0,this.downloadWaitMs=0,this.lastGlFlushTime=0,this.warnedAboutMemory=!1,this.pendingDeletes=0,this.disposed=!1,!Ie().getBool("HAS_WEBGL"))throw new Error("WebGL is not supported on this device");let r;if(null!=e){if(e instanceof Yk)r=e;else{const i=ma(Ie().getNumber("WEBGL_VERSION"),e);r=new Yk(i)}this.binaryCache={},this.gpgpuCreatedLocally=!1}else{const i=ma(Ie().getNumber("WEBGL_VERSION"));r=new Yk(i),this.binaryCache=function gSe(n){return n in bx||(bx[n]={}),bx[n]}(Ie().getNumber("WEBGL_VERSION")),this.gpgpuCreatedLocally=!0}this.gpgpu=r,this.canvas=this.gpgpu.gl.canvas,this.textureManager=new Q1e(this.gpgpu),this.numMBBeforeWarning=function _Se(){return null==Ie().global.screen?1024:Ie().global.screen.height*Ie().global.screen.width*window.devicePixelRatio*600/1024/1024}(),this.texData=new HL(this,Fa())}numDataIds(){return this.texData.numDataIds()-this.pendingDeletes}writeTexture(e,r,i,o,s,a){const c=this.makeTensorInfo(r,i),u=this.texData.get(c.dataId);u.isPacked=!1,u.texture={texture:e,texShape:[o,s]},u.texShape=[o,s];const p=ux(r),m=new bj(p,!1,a),g=this.runWebGLProgram(m,[c],i,[[o,s]]);return g.shape=r,u.texture=null,this.disposeIntermediateTensorInfo(c),g.dataId}write(e,r,i){if((Ie().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS")||Ie().getBool("DEBUG"))&&this.checkNumericalProblems(e),"complex64"===i&&null!=e)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");const o={id:this.nextDataId()};return this.texData.set(o,{shape:r,dtype:i,values:e,usage:$r.UPLOAD,refCount:1}),o}refCount(e){return this.texData.has(e)?this.texData.get(e).refCount:0}incRef(e){this.texData.get(e).refCount++}decRef(e){this.texData.has(e)&&this.texData.get(e).refCount--}move(e,r,i,o,s){if(Ie().getBool("DEBUG")&&this.checkNumericalProblems(r),"complex64"===o)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.texData.set(e,{shape:i,dtype:o,values:r,usage:$r.UPLOAD,refCount:s})}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}readSync(e){const r=this.texData.get(e),{values:i,dtype:o,complexTensorInfos:s,slice:a,shape:c,isPacked:u}=r;if(null!=a){let _;_=u?new Bc(c,Lc):new Ya(c,Lc);const x=this.runWebGLProgram(_,[{dataId:e,shape:c,dtype:o}],o),T=this.readSync(x.dataId);return this.disposeIntermediateTensorInfo(x),T}if(null!=i)return this.convertAndCacheOnCPU(e);if("string"===o)return i;const p=null!=this.activeTimers;let m,g;return p&&(m=xo()),g="complex64"===o?Cl(this.readSync(s.real.dataId),this.readSync(s.imag.dataId)):this.getValuesFromTexture(e),p&&(this.downloadWaitMs+=xo()-m),this.convertAndCacheOnCPU(e,g)}read(e){var r=this;return $e(function*(){if(r.pendingRead.has(e)){const I=r.pendingRead.get(e);return new Promise(N=>I.push(N))}const i=r.texData.get(e),{values:o,shape:s,slice:a,dtype:c,complexTensorInfos:u,isPacked:p}=i;if(null!=a){let I;I=p?new Bc(s,Lc):new Ya(s,Lc);const N=r.runWebGLProgram(I,[{dataId:e,shape:s,dtype:c}],c),R=r.read(N.dataId);return r.disposeIntermediateTensorInfo(N),R}if(null!=o)return r.convertAndCacheOnCPU(e);if(Ie().getBool("DEBUG")&&!Ie().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&2===Ie().getNumber("WEBGL_VERSION"))throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");let g,_,m=null;if("complex64"!==c&&Ie().get("WEBGL_BUFFER_SUPPORTED")){g=r.decode(e);const I=r.texData.get(g.dataId);m=r.gpgpu.createBufferFromTexture(I.texture.texture,...ax(s))}if(r.pendingRead.set(e,[]),"complex64"!==c&&(yield r.gpgpu.createAndWaitForFence()),"complex64"===c){const I=yield Promise.all([r.read(u.real.dataId),r.read(u.imag.dataId)]);_=Cl(I[0],I[1])}else if(null==m)_=r.getValuesFromTexture(e);else{const I=Me(s);_=r.gpgpu.downloadFloat32MatrixFromBuffer(m,I)}if(null!=g&&r.disposeIntermediateTensorInfo(g),null!=m){const I=r.gpgpu.gl;dt(I,()=>I.deleteBuffer(m))}const x=r.convertAndCacheOnCPU(e,_),T=r.pendingRead.get(e);return r.pendingRead.delete(e),T.forEach(I=>I(x)),r.pendingDisposal.has(e)&&(r.pendingDisposal.delete(e),r.disposeData(e)&&Fa().removeDataId(e,r),r.pendingDeletes--),x})()}readToGPU(e,r={}){const i=this.texData.get(e),{values:o,shape:s,slice:a,dtype:c,isPacked:u,texture:p}=i;if("complex64"===c)throw new Error("Does not support reading texture for complex64 dtype.");if(null!=a){let x;x=u?new Bc(s,Lc):new Ya(s,Lc);const T=this.runWebGLProgram(x,[{dataId:e,shape:s,dtype:c}],c),I=this.readToGPU(T,r);return this.disposeIntermediateTensorInfo(T),I}if(null==p)throw null!=o?new Error("Data is not on GPU but on CPU."):new Error("There is no data on GPU or CPU.");const m=this.decode(e,r.customTexShape),g=Fa().makeTensorFromTensorInfo(m),_=this.texData.get(m.dataId);return Object.assign({tensorRef:g},_.texture)}bufferSync(e){const r=this.readSync(e.dataId);if("string"===e.dtype)try{const i=r.map(o=>uc(o));return sn(e.shape,e.dtype,i)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return sn(e.shape,e.dtype,r)}checkNumericalProblems(e){if(null!=e)for(let r=0;r<e.length;r++){const i=e[r];if(!Swe(i))throw Ie().getBool("WEBGL_RENDER_FLOAT32_CAPABLE")?Error(`The value ${i} cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'`):Error(`The value ${i} cannot be represented on this device.`)}}getValuesFromTexture(e){const{shape:r,dtype:i,isPacked:o}=this.texData.get(e),s=Me(r);if(Ie().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")){const _=this.decode(e),x=this.texData.get(_.dataId),T=this.gpgpu.downloadMatrixFromPackedTexture(x.texture.texture,...ax(r)).subarray(0,s);return this.disposeIntermediateTensorInfo(_),T}const a=Ie().getBool("WEBGL_PACK")&&!0===o,c=a?ux(r):r,u=a?new BTe(c):new LTe(c),p=this.runWebGLProgram(u,[{shape:c,dtype:i,dataId:e}],"float32"),m=this.texData.get(p.dataId),g=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(m.texture.texture,m.texShape[0],m.texShape[1]).subarray(0,s);return this.disposeIntermediateTensorInfo(p),g}timerAvailable(){return Ie().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0}time(e){var r=this;const i=this.activeTimers,o=[];let s=!1;null==this.programTimersStack?(this.programTimersStack=o,s=!0):this.activeTimers.push(o),this.activeTimers=o,e();const a=Au(this.activeTimers.map(p=>p.query)).filter(p=>null!=p),c=Au(this.activeTimers.map(p=>p.name)).filter(p=>null!=p);this.activeTimers=i,s&&(this.programTimersStack=null);const u={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null};return $e(function*(){if(Ie().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0){const p=yield Promise.all(a);u.kernelMs=function rre(n){let t=0;for(let e=0;e<n.length;e++)t+=n[e];return t}(p),u.getExtraProfileInfo=()=>p.map((m,g)=>({name:c[g],ms:m})).map(m=>`${m.name}: ${m.ms}`).join(", ")}else u.kernelMs={error:"WebGL query timers are not supported in this environment."};return r.uploadWaitMs=0,r.downloadWaitMs=0,u})()}memory(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU,numBytesInGPUAllocated:this.textureManager.numBytesAllocated,numBytesInGPUFree:this.textureManager.numBytesFree}}startTimer(){return Ie().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.beginQuery():{startMs:xo(),endMs:null}}endTimer(e){return Ie().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?(this.gpgpu.endQuery(),e):(e.endMs=xo(),e)}getQueryTime(e){var r=this;return $e(function*(){return Ie().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?r.gpgpu.waitForQueryAndGetTime(e):e.endMs-e.startMs})()}disposeData(e,r=!1){if(this.pendingDisposal.has(e))return!1;if(!this.texData.has(e))return!0;if(r?this.texData.get(e).refCount=0:this.texData.get(e).refCount--,!r&&this.texData.get(e).refCount>0)return!1;if(this.pendingRead.has(e))return this.pendingDisposal.add(e),this.pendingDeletes++,!1;this.releaseGPUData(e);const{complexTensorInfos:i}=this.texData.get(e);return null!=i&&(this.disposeData(i.real.dataId,r),this.disposeData(i.imag.dataId,r)),this.texData.delete(e),!0}releaseGPUData(e){const{texture:r,dtype:i,texShape:o,usage:s,isPacked:a,slice:c}=this.texData.get(e),u=c&&c.origDataId||e,p=this.dataRefCount.get(u);p>1?this.dataRefCount.set(u,p-1):(this.dataRefCount.delete(u),null!=r&&(this.numBytesInGPU-=this.computeBytes(o,i),this.textureManager.releaseTexture(r,o,s,a)));const m=this.texData.get(e);m.texture=null,m.texShape=null,m.isPacked=!1,m.slice=null}getTexture(e){return this.uploadToGPU(e),this.texData.get(e).texture.texture}getDataInfo(e){return this.texData.get(e)}shouldExecuteOnCPU(e,r=bSe){return Ie().getBool("WEBGL_CPU_FORWARD")&&e.every(i=>null==this.texData.get(i.dataId).texture&&Me(i.shape)<r)}getGPGPUContext(){return this.gpgpu}where(e){as("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");const r=e.dataSync();return pSe(e.shape,r)}packedUnaryOp(e,r,i){const o=new Bc(e.shape,r),s=this.compileAndRun(o,[e],i);return Fa().makeTensorFromTensorInfo(s)}abs(e){if(this.shouldExecuteOnCPU([e])&&"complex64"!==e.dtype){const o=Sj(this.texData.get(e.dataId).values);return this.makeOutput(e.shape,e.dtype,o)}if(Ie().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(e,Nj,e.dtype);const r=new Ya(e.shape,Nj),i=this.compileAndRun(r,[e]);return Fa().makeTensorFromTensorInfo(i)}makeTensorInfo(e,r,i){let o;if("string"===r&&null!=i&&i.length>0&&om(i[0])){const s=i.map(a=>cc(a));o=this.write(s,e,r)}else o=this.write(i,e,r);return this.texData.get(o).usage=null,{dataId:o,shape:e,dtype:r}}makeOutput(e,r,i){return Fa().makeTensorFromTensorInfo(this.makeTensorInfo(e,r,i),this)}unpackTensor(e){const r=new hSe(e.shape);return this.runWebGLProgram(r,[e],e.dtype)}packTensor(e){const r=new Y1e(e.shape);return this.runWebGLProgram(r,[e],e.dtype,null,!0)}packedReshape(e,r){const i=[Jh(e.shape),...ep(e.shape)],o={dtype:e.dtype,shape:i,dataId:e.dataId},s=[Jh(r),...ep(r)],a=new Ej(s,i),p=this.runWebGLProgram(a,[o],e.dtype,[i],!0);return{dataId:p.dataId,shape:r,dtype:p.dtype}}decode(e,r){const i=this.texData.get(e),{isPacked:o,shape:s,dtype:a}=i;null!=r&&Z(Me(s)<=r[0]*r[1]*4,()=>"customTexShape is too small. Row * Column * 4 should be equal or larger than the size of the tensor data.");const c=ux(s);let u;u=o?new $Te(c):new PTe(c);const m=[r??ax(c)];return{dtype:a,shape:s,dataId:this.runWebGLProgram(u,[{shape:c,dtype:a,dataId:e}],a,m,!0,r).dataId}}runWebGLProgram(e,r,i,o,s=!1,a){const c=this.makeTensorInfo(e.outputShape,i),u=this.texData.get(c.dataId);if(e.packedOutput&&(u.isPacked=!0),e.outPackingScheme===Xa.DENSE){const R=a??ax(e.outputShape);u.texShape=R.map(L=>2*L)}if(null!=e.outTexUsage&&(u.usage=e.outTexUsage),0===Me(c.shape))return u.values=Ei(c.dtype,0),c;const p=[],m=r.map(R=>{if("complex64"===R.dtype)throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");let L=this.texData.get(R.dataId);if(null==L.texture){if(!e.packedInputs&&Me(R.shape)<=Ie().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))return{shape:R.shape,texData:null,isUniform:!0,uniformValues:L.values};e.packedInputs&&(L.isPacked=!0,L.shape=R.shape)}if(this.uploadToGPU(R.dataId),!!L.isPacked!=!!e.packedInputs)R=L.isPacked?this.unpackTensor(R):this.packTensor(R),p.push(R),L=this.texData.get(R.dataId);else if(L.isPacked&&!hx(L.shape,R.shape)){const V=R,j=R.shape;R.shape=L.shape,R=this.packedReshape(R,j),p.push(R),L=this.texData.get(R.dataId),V.shape=j}return{shape:R.shape,texData:L,isUniform:!1}});this.uploadToGPU(c.dataId);const g={shape:c.shape,texData:u,isUniform:!1},_=function FTe(n,t,e){let r="";t.concat(e).forEach(s=>{const a=null!=s.texData&&null!=s.texData.slice&&s.texData.slice.flatOffset>0;if(n.enableShapeUniforms&&!s.isUniform){const c=s.texData.texShape,{useSqueezeShape:u,uniformShape:p,keptDims:m}=Xk(n.packedInputs,s.shape,c);let g="",_="",x="";if(1===p.length&&n.packedInputs){const j=[Math.ceil(c[0]/2),Math.ceil(c[1]/2)];g=`${j[0]>1}_${j[1]>1}`}else if(2!==p.length||n.packedInputs){if(p.length>2&&!n.packedInputs){const j=Rt(p);x=`${j[0]===c[1]}_${j[j.length-1]===c[1]}`}}else _=`${p[0]>1}_${p[1]>1}`;const T=s.shape.length,I=2===p.length&&mn(s.shape,c),N=1===Me(s.shape),R=Nh(s.shape,e.shape),L=!n.packedInputs&&T===e.shape.length&&mn(c,e.texData.texShape);r+=`${T}_${L}_${u?m:""}_${p.length}_${N}_${R}_${I}_${g}_${_}_${x}_${n.packedInputs||p.length>2?"":`${c[0]>1}_${c[1]>1}`}_${a}`}else r+=`${s.shape}_${s.isUniform?"uniform":s.texData.texShape}_${a}`});let o=n.constructor.name;return o+="_"+r+"_"+n.userCode+`${Ie().getNumber("WEBGL_VERSION")}`,o}(e,m,g),x=this.getAndSaveBinary(_,()=>function RTe(n,t,e,r){const i=e.map((p,m)=>{const g={logicalShape:p.shape,texShape:p.isUniform?null:p.texData.texShape,isUniform:p.isUniform,isPacked:!p.isUniform&&p.texData.isPacked,flatOffset:null};return null!=p.texData&&null!=p.texData.slice&&p.texData.slice.flatOffset>0&&(g.flatOffset=p.texData.slice.flatOffset),{name:t.variableNames[m],shapeInfo:g}}),o=i.map(p=>p.shapeInfo),s={logicalShape:r.shape,texShape:r.texData.texShape,isUniform:!1,isPacked:r.texData.isPacked,flatOffset:null},a=Zwe(i,s,t),c=function Ewe(n,t){const e=Nl(n,()=>n.createShader(n.FRAGMENT_SHADER),"Unable to create fragment WebGLShader.");if(dt(n,()=>n.shaderSource(e,t)),dt(n,()=>n.compileShader(e)),Ie().get("ENGINE_COMPILE_ONLY"))return e;if(!1===n.getShaderParameter(e,n.COMPILE_STATUS))throw sj(t,n.getShaderInfoLog(e)),new Error("Failed to compile fragment shader.");return e}(n.gl,a),u=n.createProgram(c);return Ie().get("ENGINE_COMPILE_ONLY")?{program:t,fragmentShader:c,source:a,webGLProgram:u,inShapeInfos:o,outShapeInfo:s,variablesLocations:null,customUniformLocations:null,infLoc:null,nanLoc:null,outShapeLocation:null,outShapeStridesLocation:null,outTexShapeLocation:null}:(n.buildVao(u),Object.assign({program:t,fragmentShader:c,source:a,webGLProgram:u,inShapeInfos:o,outShapeInfo:s},mj(n,t,u)))}(this.gpgpu,e,m,g)),T=null!=this.activeTimers;let I;T&&(I=this.startTimer()),Ie().get("ENGINE_COMPILE_ONLY")||function MTe(n,t,e,r,i){t.program.enableShapeUniforms||(gj(t.inShapeInfos,e),gj([t.outShapeInfo],[r]));const o=r.texData.texture,s=r.texData.texShape;r.texData.isPacked?n.setOutputPackedMatrixTexture(o.texture,s[0],s[1]):n.setOutputMatrixTexture(o.texture,s[0],s[1]),n.setProgram(t.webGLProgram),n.bindVertexArray(t.webGLProgram.vao),1===Ie().getNumber("WEBGL_VERSION")&&null!==t.infLoc&&n.gl.uniform1f(t.infLoc,1/0),null!==t.nanLoc&&n.gl.uniform1f(t.nanLoc,NaN);for(let c=0;c<e.length;++c){const u=e[c],{uniform:p,offset:m,shape:g,texShape:_}=t.variablesLocations[c];if(g){const{uniformShape:x}=Xk(t.program.packedInputs,u.shape,u.texData.texShape);switch(x.length){case 1:n.gl.uniform1iv(g,new Int32Array(x));break;case 2:n.gl.uniform2iv(g,new Int32Array(x));break;case 3:n.gl.uniform3iv(g,new Int32Array(x));break;case 4:n.gl.uniform4iv(g,new Int32Array(x))}}if(_&&n.gl.uniform2i(_,u.texData.texShape[0],u.texData.texShape[1]),null!=p){if(u.isUniform){if(Me(u.shape)<2)n.gl.uniform1f(p,u.uniformValues[0]);else{let x=u.uniformValues;x instanceof Float32Array||(x=new Float32Array(x)),n.gl.uniform1fv(p,x)}continue}null!=u.texData.slice&&null!=m&&n.gl.uniform1i(m,u.texData.slice.flatOffset),n.setInputMatrixTexture(u.texData.texture.texture,p,c)}}const a=t.outShapeLocation;if(a)switch(r.shape.length){case 1:n.gl.uniform1iv(a,new Int32Array(r.shape));break;case 2:n.gl.uniform2iv(a,new Int32Array(r.shape));break;case 3:n.gl.uniform3iv(a,new Int32Array(r.shape));break;case 4:n.gl.uniform4iv(a,new Int32Array(r.shape))}if(t.outShapeStridesLocation){const c=Rt(r.shape);switch(r.shape.length){case 2:n.gl.uniform1iv(t.outShapeStridesLocation,new Int32Array(c));break;case 3:n.gl.uniform2iv(t.outShapeStridesLocation,new Int32Array(c));break;case 4:n.gl.uniform3iv(t.outShapeStridesLocation,new Int32Array(c))}}if(t.outTexShapeLocation&&n.gl.uniform2i(t.outTexShapeLocation,r.texData.texShape[0],r.texData.texShape[1]),t.program.customUniforms&&i)for(let c=0;c<t.program.customUniforms.length;++c){const u=t.program.customUniforms[c],p=t.customUniformLocations[c],m=i[c];if("float"===u.type)n.gl.uniform1fv(p,m);else if("vec2"===u.type)n.gl.uniform2fv(p,m);else if("vec3"===u.type)n.gl.uniform3fv(p,m);else if("vec4"===u.type)n.gl.uniform4fv(p,m);else if("int"===u.type)n.gl.uniform1iv(p,m);else if("ivec2"===u.type)n.gl.uniform2iv(p,m);else if("ivec3"===u.type)n.gl.uniform3iv(p,m);else{if("ivec4"!==u.type)throw Error(`uniform type ${u.type} is not supported yet.`);n.gl.uniform4iv(p,m)}}n.executeProgram()}(this.gpgpu,x,m,g,o),p.forEach(R=>this.disposeIntermediateTensorInfo(R)),T&&(I=this.endTimer(I),this.activeTimers.push({name:e.constructor.name,query:this.getQueryTime(I)}));const N=Ie().get("WEBGL_FLUSH_THRESHOLD");if(N>0){const R=xo();R-this.lastGlFlushTime>N&&(this.gpgpu.gl.flush(),this.lastGlFlushTime=R)}if(!Ie().getBool("WEBGL_LAZILY_UNPACK")&&u.isPacked&&!1===s){const R=this.unpackTensor(c);return this.disposeIntermediateTensorInfo(c),R}return c}compileAndRun(e,r,i,o,s=!1){return this.runWebGLProgram(e,r,i=i||r[0].dtype,o,s)}getAndSaveBinary(e,r){return e in this.binaryCache||(this.binaryCache[e]=r()),this.binaryCache[e]}getTextureManager(){return this.textureManager}dispose(){this.disposed||(Ie().getBool("IS_TEST")||Object.keys(this.binaryCache).forEach(r=>{this.gpgpu.deleteProgram(this.binaryCache[r].webGLProgram),delete this.binaryCache[r]}),this.textureManager.dispose(),null!=this.canvas&&typeof HTMLCanvasElement<"u"&&this.canvas instanceof HTMLCanvasElement?this.canvas.remove():this.canvas=null,this.gpgpuCreatedLocally&&(this.gpgpu.program=null,this.gpgpu.dispose()),this.disposed=!0)}floatPrecision(){return null==this.floatPrecisionValue&&(this.floatPrecisionValue=Se(()=>{if(!Ie().get("WEBGL_RENDER_FLOAT32_ENABLED")){const e=Ie().getBool("DEBUG");Ie().set("DEBUG",!1);const r=this.abs(Ft(1e-8)).dataSync()[0];if(Ie().set("DEBUG",e),r>0)return 32}return 16})),this.floatPrecisionValue}epsilon(){return 32===this.floatPrecision()?1e-7:1e-4}uploadToGPU(e){const r=this.texData.get(e),{shape:i,dtype:o,values:s,texture:a,usage:c,isPacked:u}=r;if(null!=a)return;const p=null!=this.activeTimers;let m;p&&(m=xo());let g=r.texShape;if(null==g&&(g=function zwe(n,t=!1){let e=Ie().getNumber("WEBGL_MAX_TEXTURE_SIZE"),r=Ie().getNumber("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE");r===1/0&&Ie().getBool("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE")&&(r=e/2),t&&(e*=2,r*=2,1===(n=n.map((a,c)=>c>=n.length-2?lC(n[c]):n[c])).length&&(n=[2,n[0]])),2!==n.length&&(n=sc(n).newShape);let i=Me(n),o=null;n.length<=1&&i<=e?o=[1,i]:2===n.length&&n[0]<=e&&n[1]<=e?o=n:3===n.length&&n[0]*n[1]<=e&&n[2]<=e?o=[n[0]*n[1],n[2]]:3===n.length&&n[0]<=e&&n[1]*n[2]<=e?o=[n[0],n[1]*n[2]]:4===n.length&&n[0]*n[1]*n[2]<=e&&n[3]<=e?o=[n[0]*n[1]*n[2],n[3]]:4===n.length&&n[0]<=e&&n[1]*n[2]*n[3]<=e&&(o=[n[0],n[1]*n[2]*n[3]]);const s=null!=o&&Math.max(...o)>r&&Math.min(...o)<=(t?2:1)&&Math.min(...o)>0;if(null==o||s)if(t){const a=Jh(n);let c=2,u=2;n.length&&([c,u]=ep(n)),i=a*(c/2)*(u/2),o=cC(i).map(p=>2*p)}else o=cC(i);return o}(i,u),r.texShape=g),null!=s){const _=ux(i);let x,T=g[1],I=g[0];const N=s instanceof Uint8Array||s instanceof Uint8ClampedArray;(u||!N)&&([T,I]=Qh(g[0],g[1])),x=u?new zTe(_,N):new bj(_,N);const R=N?[I,T]:g,L=this.makeTensorInfo(R,o),V=this.texData.get(L.dataId);V.usage=N?$r.PIXELS:$r.UPLOAD,V.texShape=R,this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(L.dataId),T,I,s);const ee=this.runWebGLProgram(x,[L],o,[[I,T]],!0),ie=this.texData.get(ee.dataId);r.texShape=ie.texShape,r.isPacked=ie.isPacked,r.usage=ie.usage,Ie().get("ENGINE_COMPILE_ONLY")?this.disposeData(ee.dataId):(r.texture=ie.texture,r.values=null,this.texData.delete(ee.dataId)),this.disposeIntermediateTensorInfo(L),p&&(this.uploadWaitMs+=xo()-m)}else{const _=this.acquireTexture(g,c,o,u);r.texture=_}}convertAndCacheOnCPU(e,r){const i=this.texData.get(e),{dtype:o}=i;return null!=r&&(i.values=function xSe(n,t){if("float32"===t||"complex64"===t)return n;if("int32"===t||"bool"===t){const e="int32"===t?new Int32Array(n.length):new Uint8Array(n.length);for(let r=0;r<e.length;++r)e[r]=Math.round(n[r]);return e}throw new Error(`Unknown dtype ${t}`)}(r,o)),i.values}acquireTexture(e,r,i,o){if(this.numBytesInGPU+=this.computeBytes(e,i),!this.warnedAboutMemory&&this.numBytesInGPU>1024*this.numMBBeforeWarning*1024){const s=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=!0,console.warn(`High memory usage in GPU: ${s} MB, most likely due to a memory leak`)}return this.textureManager.acquireTexture(e,r,o)}computeBytes(e,r){return e[0]*e[1]*O_(r)}checkCompileCompletion(){for(const[,e]of Object.entries(this.binaryCache))this.checkCompletion_(e)}checkCompileCompletionAsync(){var e=this;return $e(function*(){const r=[];if(e.gpgpu.parallelCompilationExtension){for(const[,i]of Object.entries(e.binaryCache))r.push(e.checkCompletionAsync_(i));return Promise.all(r)}for(const[,i]of Object.entries(e.binaryCache)){const o=new Promise(s=>{try{e.checkCompletion_(i),s(!0)}catch(a){throw a}});r.push(o)}return Promise.all(r)})()}checkCompletionAsync_(e){var r=this;return $e(function*(){return r.gpgpu.gl.getProgramParameter(e.webGLProgram,r.gpgpu.parallelCompilationExtension.COMPLETION_STATUS_KHR)?r.checkCompletion_(e):(yield gV(),r.checkCompletionAsync_(e))})()}checkCompletion_(e){if(!1===this.gpgpu.gl.getProgramParameter(e.webGLProgram,this.gpgpu.gl.LINK_STATUS))throw console.log(this.gpgpu.gl.getProgramInfoLog(e.webGLProgram)),!1===this.gpgpu.gl.getShaderParameter(e.fragmentShader,this.gpgpu.gl.COMPILE_STATUS)?(sj(e.source,this.gpgpu.gl.getShaderInfoLog(e.fragmentShader)),new Error("Failed to compile fragment shader.")):new Error("Failed to link vertex and fragment shaders.");return!0}getUniformLocations(){for(const e of Object.values(this.binaryCache)){this.gpgpu.buildVao(e.webGLProgram);const{variablesLocations:r,customUniformLocations:i,infLoc:o,nanLoc:s,outShapeLocation:a,outShapeStridesLocation:c,outTexShapeLocation:u}=mj(this.gpgpu,e.program,e.webGLProgram);e.variablesLocations=r,e.customUniformLocations=i,e.infLoc=o,e.nanLoc=s,e.outShapeLocation=a,e.outShapeStridesLocation=c,e.outTexShapeLocation=u}}createTensorFromGPUData(e,r,i){e.channels=e.channels||"RGBA";const{texture:o,height:s,width:a,channels:c}=e,u=Fa().backend;if(!u.gpgpu.gl.isTexture(o))throw new Error("The texture is invalid. Also, please make sure the texture and the TFJS WebGL backend are using the same canvas. If you want to use your own custom canvas, you have to create and use the custom TFJS WebGL backend created from the canvas through 'new tf.MathBackendWebGL(customCanvas)'.");const p=u.writeTexture(o,r,i,s,a,c);return Fa().makeTensorFromDataId(p,r,i,u)}}return n.nextDataId=0,n})();_3()&&L3("webgl",()=>new vSe,2);const Qk="\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n";class op{constructor(t,e,r){this.variableNames=["A","B"],this.outputShape=Yt(e,r),this.enableShapeUniforms=Hi(this.outputShape.length),this.userCode=`\n      float binaryOperation(float a, float b) {\n        ${t}\n      }\n\n      void main() {\n        float a = getAAtOutCoords();\n        float b = getBAtOutCoords();\n        setOutput(binaryOperation(a, b));\n      }\n    `}}const Qu="\n  result.r = isNaN.r ? NAN : result.r;\n  result.g = isNaN.g ? NAN : result.g;\n  result.b = isNaN.b ? NAN : result.b;\n  result.a = isNaN.a ? NAN : result.a;\n";class Gg{constructor(t,e,r,i=!1){this.variableNames=["A","B"],this.supportsBroadcasting=!0,this.packedInputs=!0,this.packedOutput=!0,this.outputShape=Yt(e,r);const o=this.outputShape.length;this.enableShapeUniforms=Hi(o);let s="";if(i)if(0===o||1===Me(this.outputShape))s="\n          result.y = 0.;\n          result.z = 0.;\n          result.w = 0.;\n        ";else if(s=`\n          ${jn(o)} coords = getOutputCoords();\n        `,1===o)s+=this.enableShapeUniforms?"\n            result.y = (coords + 1) >= outShape ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          ":`\n            result.y = (coords + 1) >= ${this.outputShape[0]} ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          `;else{const c=ao("coords",o);s+=this.enableShapeUniforms?`\n            bool nextRowOutOfBounds =\n              (${c[o-2]} + 1) >= outShape[${o} - 2];\n            bool nextColOutOfBounds =\n              (${c[o-1]} + 1) >= outShape[${o} - 1];\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          `:`\n            bool nextRowOutOfBounds =\n              (${c[o-2]} + 1) >= ${this.outputShape[o-2]};\n            bool nextColOutOfBounds =\n              (${c[o-1]} + 1) >= ${this.outputShape[o-1]};\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          `}this.userCode=`\n      vec4 binaryOperation(vec4 a, vec4 b) {\n        ${t}\n      }\n\n      void main() {\n        vec4 a = getAAtOutCoords();\n        vec4 b = getBAtOutCoords();\n\n        vec4 result = binaryOperation(a, b);\n        ${s}\n\n        setOutput(result);\n      }\n    `}}function qo(n){const{inputs:t,backend:e}=n,{x:r}=t;return e.incRef(r.dataId),{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}const SSe={kernelName:Im,backendName:"webgl",kernelFunc:qo};function Vc(n){const{inputs:t,backend:e}=n,{real:r,imag:i}=t,o=e.makeTensorInfo(r.shape,"complex64"),s=e.texData.get(o.dataId),a=qo({inputs:{x:r},backend:e}),c=qo({inputs:{x:i},backend:e});return s.complexTensorInfos={real:a,imag:c},o}const CSe={kernelName:TC,backendName:"webgl",kernelFunc:Vc},Oj="return (a < 0.) ? b * a : a;",Rj="\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n",ESe={kernelName:e0,backendName:"webgl",kernelFunc:function ISe(n){const{inputs:t,backend:e,attrs:r}=n,{x:i}=t,{alpha:o}=r,s=e.makeTensorInfo([],"float32",lc(o,"float32")),a=Ie().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Gg(Rj,i.shape,s.shape):new op(Oj,i.shape,s.shape),c=e.runWebGLProgram(a,[i,s],"float32");return e.disposeIntermediateTensorInfo(s),c}},Mj="return (a < 0.) ? b * a : a;",Fj="\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n",kSe={kernelName:v0,backendName:"webgl",kernelFunc:function DSe(n){const{inputs:t,backend:e}=n,{x:r,alpha:i}=t,o=Ie().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Gg(Fj,r.shape,i.shape):new op(Mj,r.shape,i.shape);return e.runWebGLProgram(o,[r,i],"float32")}},sp="if (isnan(x)) return x;";function Sn({opSnippet:n,packedOpSnippet:t,cpuKernelImpl:e,dtype:r}){return({inputs:i,backend:o})=>{const{x:s}=i,a=o,c=r||s.dtype;if(a.shouldExecuteOnCPU([s])&&null!=e){const m=a.texData.get(s.dataId),g=e(m.values,c);return a.makeTensorInfo(s.shape,c,g)}let p;return p=Ie().getBool("WEBGL_PACK_UNARY_OPERATIONS")&&null!=t?new Bc(s.shape,t):new Ya(s.shape,n),a.runWebGLProgram(p,[s],c)}}function Ni({opSnippet:n,packedOpSnippet:t,checkOutOfBounds:e=!1,supportsComplex:r=!1,cpuKernelImpl:i,dtype:o}){return({inputs:s,backend:a})=>{const{a:c,b:u}=s,p=a;if(r&&"complex64"===c.dtype){const x=p.texData.get(c.dataId),T=p.texData.get(u.dataId),[I,N]=[[x.complexTensorInfos.real,T.complexTensorInfos.real],[x.complexTensorInfos.imag,T.complexTensorInfos.imag]].map(L=>{const[V,j]=L,Y={dataId:V.dataId,dtype:V.dtype,shape:c.shape},ee={dataId:j.dataId,dtype:j.dtype,shape:u.shape},ie=new op(n,c.shape,u.shape);return p.runWebGLProgram(ie,[Y,ee],zo(V.dtype,j.dtype))}),R=Vc({inputs:{real:I,imag:N},backend:p});return p.disposeIntermediateTensorInfo(I),p.disposeIntermediateTensorInfo(N),R}const m=o||zo(c.dtype,u.dtype);if(("string"===c.dtype||"string"===u.dtype||p.shouldExecuteOnCPU([c,u]))&&null!=i){const x=p.texData.get(c.dataId).values,T=p.texData.get(u.dataId).values,I="string"===c.dtype?Il(x):x,N="string"===c.dtype?Il(T):T,[R,L]=i(c.shape,u.shape,I,N,m),V=p.makeTensorInfo(L,m);return p.texData.get(V.dataId).values=R,V}let _;return _=Ie().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&null!=t?new Gg(t,c.shape,u.shape,e):new op(n,c.shape,u.shape),p.runWebGLProgram(_,[c,u],m)}}function Hg(n,t=!1){if("linear"===n)return t?aSe:nSe;if("relu"===n)return t?cSe:iSe;if("elu"===n)return t?lSe:rSe;if("relu6"===n)return t?uSe:oSe;if("prelu"===n)return t?Fj:Mj;if("leakyrelu"===n)return t?Rj:Oj;if("sigmoid"===n)return t?dSe:sSe;throw new Error(`Activation ${n} has not been implemented for the WebGL backend.`)}class Pj{constructor(t,e,r,i=!1,o=!1,s=!1,a=null,c=!1,u=!1){this.variableNames=["matrixA","matrixB"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=r,this.enableShapeUniforms=Hi(this.outputShape.length);const m=Math.ceil((i?t[1]:t[2])/2),g=i?"i * 2, rc.y":"rc.y, i * 2",_=o?"rc.z, i * 2":"i * 2, rc.z",x=i?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"],T=o?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"];let I="",N="";a&&(I=c?`vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ${a}\n        }`:u?`vec4 activation(vec4 a) {\n          vec4 b = getLeakyreluAlphaAtOutCoords();\n          ${a}\n        }`:`vec4 activation(vec4 x) {\n          ${a}\n        }`,N="result = activation(result);");const R=s?"result += getBiasAtOutCoords();":"";s&&this.variableNames.push("bias"),c&&this.variableNames.push("preluActivationWeights"),u&&this.variableNames.push("leakyreluAlpha");let L="rc.x",V="rc.x";t[0]<e[0]?L=`imod(rc.x, ${t[0]})`:e[0]<t[0]&&(V=`imod(rc.x, ${e[0]})`),this.userCode=`\n      ${I}\n      // Don't use uniform for sharedDimensionPacked for performance.\n      const float sharedDimension = ${m}.0;\n\n      vec4 dot2x2ARowBCol(ivec3 rc) {\n        vec4 result = vec4(0);\n        int batchA = ${L};\n        int batchB = ${V};\n        for (int i = 0; i < ${m}; i++) {\n          vec4 a = getMatrixA(batchA, ${g});\n          vec4 b = getMatrixB(batchB, ${_});\n\n          // These swizzled products need to be separately added.\n          // See: https://github.com/tensorflow/tfjs/issues/1735\n          result += (${x[0]} * ${T[0]});\n          result += (${x[1]} * ${T[1]});\n        }\n        return result;\n      }\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n        vec4 result = dot2x2ARowBCol(rc);\n\n        ${R}\n\n        ${N}\n\n        setOutput(result);\n      }\n    `}}const $j={REAL:"return areal * breal - aimag * bimag;",IMAG:"return areal * bimag + aimag * breal;"};class Lj{constructor(t,e,r){this.variableNames=["AReal","AImag","BReal","BImag"],this.outputShape=Yt(e,r),this.userCode=`\n      float binaryOpComplex(\n          float areal, float aimag, float breal, float bimag) {\n        ${t}\n      }\n\n      void main() {\n        float areal = getARealAtOutCoords();\n        float aimag = getAImagAtOutCoords();\n        float breal = getBRealAtOutCoords();\n        float bimag = getBImagAtOutCoords();\n        setOutput(binaryOpComplex(areal, aimag, breal, bimag));\n      }\n    `}}const Bj="return a * b;";function Jk(n){const{inputs:t,backend:e}=n,{a:r,b:i}=t,o=zo(r.dtype,i.dtype);if("complex64"===r.dtype){const a=e.texData.get(r.dataId),c=e.texData.get(i.dataId),u=new Lj($j.REAL,r.shape,i.shape),p=new Lj($j.IMAG,r.shape,i.shape),m=[{dataId:a.complexTensorInfos.real.dataId,dtype:a.complexTensorInfos.real.dtype,shape:r.shape},{dataId:a.complexTensorInfos.imag.dataId,dtype:a.complexTensorInfos.imag.dtype,shape:r.shape},{dataId:c.complexTensorInfos.real.dataId,dtype:c.complexTensorInfos.real.dtype,shape:i.shape},{dataId:c.complexTensorInfos.imag.dataId,dtype:c.complexTensorInfos.imag.dtype,shape:i.shape}],g=e.runWebGLProgram(u,m,"float32"),_=e.runWebGLProgram(p,m,"float32"),x=Vc({inputs:{real:g,imag:_},backend:e});return e.disposeIntermediateTensorInfo(g),e.disposeIntermediateTensorInfo(_),x}if(e.shouldExecuteOnCPU([r,i])){const a=e.texData.get(r.dataId),c=e.texData.get(i.dataId),[u,p]=C1e(r.shape,i.shape,a.values,c.values,o),m=e.makeTensorInfo(p,o);return e.texData.get(m.dataId).values=u,m}let s;return s=Ie().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Gg(Bj,r.shape,i.shape):new op(Bj,r.shape,i.shape),e.runWebGLProgram(s,[r,i],o)}const ASe={kernelName:Fm,backendName:"webgl",kernelFunc:Jk};function lt(n){const{inputs:t,backend:e,attrs:r}=n,{x:i}=t,{shape:o}=r,s=e,a=Me(i.shape),c=KL(o,a),u=Me(c);Z(a===u,()=>`The new shape (${c}) has ${u} elements and the old shape (${i.shape}) has ${a} elements. The new shape and old shape must have the same number of elements.`);const p=s.texData.get(i.dataId);return!p.isPacked||hx(i.shape,c)||null!==p.texture&&hx(p.shape,c)?(s.incRef(i.dataId),{dataId:i.dataId,shape:c,dtype:i.dtype}):function NSe(n,t,e){const r=[Jh(n.shape),...ep(n.shape)],i={dtype:n.dtype,shape:r,dataId:n.dataId},o=[Jh(t),...ep(t)],s=new Ej(o,r),u=e.runWebGLProgram(s,[i],n.dtype,[r],!0);return{dataId:u.dataId,shape:t,dtype:u.dtype}}(i,c,s)}const OSe={kernelName:w0,backendName:"webgl",kernelFunc:lt};class Vj{constructor(t,e){this.variableNames=["x"];const{windowSize:r,batchSize:i,inSize:o,outSize:s}=t;this.outputShape=[i,s];const a=4*Math.floor(r/4),c=r%4;let u="sumValue += dot(values, ones);";if(null!=e){const m=1/e;u=`sumValue += dot(values * ${bh(m)?m.toPrecision(2):m}, ones);`}let p="";o%r>0&&(p=`\n        if (inIdx < 0 || inIdx >= ${o}) {\n          return 0.0;\n        }\n      `),this.userCode=`\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ${p}\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${r};\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ${a}; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ${u}\n        }\n\n        int inIdx = inOffset + ${a};\n        if (${1===c}) {\n          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);\n\n          ${u}\n        } else if (${2===c}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1), 0.0, 0.0);\n\n          ${u}\n        } else if (${3===c}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2), 0.0);\n\n          ${u}\n        }\n        setOutput(sumValue);\n      }\n    `}}class RSe{constructor(t,e){this.variableNames=["x"];const{windowSize:r,batchSize:i,inSize:o,outSize:s}=t;this.outputShape=[i,s];let a="0.0",c="";"prod"===e?a="1.0":"min"===e?(a="1.0 / 1e-20",c="min"):"max"===e&&(a="-1.0 / 1e-20",c="max");let u=`${e}(${e}(${e}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"sum"===e?u="sumValue":"prod"===e?u="prodValue":"all"===e?u="allValue":"any"===e&&(u="anyValue");const p=4*Math.floor(r/4),m=r%4;let g=`\n      if (${"sum"===e}) {\n        sumValue += dot(values, ones);\n      } else if (${"prod"===e}) {\n        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);\n        prodValue *= tmp[0] * tmp[1];\n      } else {\n        minMaxValue = ${c}(values, minMaxValue);\n        if (${"min"===e} || ${"max"===e}) {\n          minMaxValue = ${c}(values, minMaxValue);\n          bvec4 isNaN = isnan(values);\n          if (isNaN.r || isNaN.g || isNaN.b || isNaN.a) {\n            minMaxValue = vec4(NAN);\n          }\n        }\n      }\n    `,_="vec4";"all"===e?(a="1.0",g="\n        bool reducedAllValue = all(values);\n        float floatedReducedAllValue = float(reducedAllValue);\n        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);\n      ",_="bvec4"):"any"===e&&(a="0.0",g="\n        bool reducedAnyValue = any(values);\n        float floatedReducedAnyValue = float(reducedAnyValue);\n        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);\n      ",_="bvec4");let x="";o%r>0&&(x=`\n        if (inIdx < 0 || inIdx >= ${o}) {\n          return initializationValue;\n        }\n      `),this.userCode=`\n      const float initializationValue = ${a};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ${x}\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${r};\n\n        vec4 minMaxValue = vec4(${a});\n        float prodValue = 1.0;\n        float sumValue = 0.0;\n        float allValue = 1.0;\n        float anyValue = 0.0;\n\n        for (int i = 0; i < ${p}; i += 4) {\n          int inIdx = inOffset + i;\n          ${_} values = ${_}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ${g}\n        }\n\n        int inIdx = inOffset + ${p};\n        if (${1===m}) {\n          ${_} values = ${_}(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          ${g}\n        } else if (${2===m}) {\n          ${_} values = ${_}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          ${g}\n        } else if (${3===m}) {\n          ${_} values = ${_}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          ${g}\n        }\n        setOutput(${u});\n      }\n    `}}function Ju(n,t,e,r){const i=function MSe(n){const t=[];for(;0===t.length||1!==t[t.length-1].outSize;){const e=t.length?t[t.length-1].outSize:n[1],r=vv(e);t.push({inSize:e,windowSize:r,outSize:Math.ceil(e/r)})}return t}(n.shape);let o=n;for(let s=0;s<i.length;s++){const{inSize:a,windowSize:c,outSize:u}=i[s];let p,m;p="mean"===e?0===s?new Vj({windowSize:c,inSize:a,batchSize:n.shape[0],outSize:u},a):new Vj({windowSize:c,inSize:a,batchSize:n.shape[0],outSize:u}):new RSe({windowSize:c,inSize:a,batchSize:n.shape[0],outSize:u},e),m=o,o=r.runWebGLProgram(p,[o],t),m.dataId!==n.dataId&&r.disposeIntermediateTensorInfo(m)}return o}class FSe{constructor(t,e){this.variableNames=["A"];const r=new Array(t.length);for(let s=0;s<r.length;s++)r[s]=t[e[s]];this.outputShape=r,this.rank=r.length;const i=jn(this.rank),o=function PSe(n){const t=n.length;if(t>6)throw Error(`Transpose for rank ${t} is not yet supported`);const e=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"],r=new Array(t);for(let i=0;i<n.length;i++)r[n[i]]=e[i];return r.join()}(e);this.userCode=`\n    void main() {\n      ${i} resRC = getOutputCoords();\n      setOutput(getA(${o}));\n    }\n    `}}class $Se{constructor(t,e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0;const r=new Array(t.length);for(let p=0;p<r.length;p++)r[p]=t[e[p]];if(this.outputShape=r,this.rank=r.length,this.rank>6)throw Error(`Packed transpose for rank ${this.rank} is not yet supported.`);const i=jn(this.rank),o=Ij("rc",this.rank),s=new Array(this.rank);for(let p=0;p<e.length;p++)s[e[p]]=o[p];const a=`vec2(${s.slice(-2).join()})`,c=`++${o[this.rank-1]} < ${r[this.rank-1]}`,u=`getChannel(getA(${s.join()}), ${a})`;this.userCode=`\n    void main() {\n      ${i} rc = getOutputCoords();\n      vec4 result = vec4(0.);\n      result[0] = ${u};\n      if(${c}) {\n        result[1] = ${u};\n      }\n      --${o[this.rank-1]};\n      if(++${o[this.rank-2]} < ${r[this.rank-2]}) {\n        result[2] = ${u};\n        if(${c}) {\n          result[3] = ${u};\n        }\n      }\n      setOutput(result);\n    }\n    `}}function yx(n,t,e){const r=Ie().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new $Se(n.shape,t):new FSe(n.shape,t);return e.runWebGLProgram(r,[n],n.dtype)}function _x(n){const{inputs:t,backend:e,attrs:r}=n,{x:i}=t,{axis:o,keepDims:s}=r;return function LSe(n,t,e,r){const o=n.shape.length,s=cn(t,n.shape);let a=s;const c=hr(a,o),u=null!=c;let p=n;u&&(p=yx(n,c,r),a=Mr(a.length,o)),ki("sum",a,o);const[m,g]=gi(p.shape,a);let _=m;e&&(_=Rr(m,s));const x=Me(g),N=lt({inputs:{x:p},attrs:{shape:[Me(n.shape)/x,x]},backend:r}),L=Ju(N,DI(n.dtype),"sum",r),V=lt({inputs:{x:L},attrs:{shape:_},backend:r});return r.disposeIntermediateTensorInfo(N),r.disposeIntermediateTensorInfo(L),u&&r.disposeIntermediateTensorInfo(p),V}(i,o,s,e)}const BSe={kernelName:D0,backendName:"webgl",kernelFunc:_x};function lo(n){const{inputs:t,backend:e,attrs:r}=n,{x:i}=t,{perm:o}=r,s=e,c=new Array(i.shape.length);for(let p=0;p<c.length;p++)c[p]=i.shape[o[p]];let u;if(s.shouldExecuteOnCPU([i])){const m=s.texData.get(i.dataId).values,g=Zk(m,i.shape,i.dtype,o,c);u=s.makeTensorInfo(c,i.dtype),s.texData.get(u.dataId).values=g}else u=yx(i,o,s);return u}const VSe={kernelName:wh,backendName:"webgl",kernelFunc:lo},zj=1e3;function vx({a:n,b:t,transposeA:e,transposeB:r,backend:i,bias:o=null,preluActivationWeights:s=null,leakyreluAlpha:a=0,activation:c=null}){const u=n.shape.length,p=t.shape.length,m=e?n.shape[u-2]:n.shape[u-1],g=r?t.shape[p-1]:t.shape[p-2],_=e?n.shape[u-1]:n.shape[u-2],x=r?t.shape[p-2]:t.shape[p-1],T=n.shape.slice(0,-2),I=t.shape.slice(0,-2),N=Me(T),R=Me(I),V=Yt(n.shape.slice(0,-2),t.shape.slice(0,-2)).concat([_,x]);Z(m===g,()=>`Error in matMul: inner shapes (${m}) and (${g}) of Tensors with shapes ${n.shape} and ${t.shape} and transposeA=${e} and transposeB=${r} must match.`);const j=e?[N,m,_]:[N,_,m],Y=r?[R,x,g]:[R,g,x],ee=lt({inputs:{x:n},backend:i,attrs:{shape:j}}),ie=lt({inputs:{x:t},backend:i,attrs:{shape:Y}}),ce=[ee,ie],he=Math.max(N,R),we=e?ee.shape[1]:ee.shape[2],Ee=null!=o,Ae=null!=s,Oe="leakyrelu"===c,Re=null!=c?Hg(c,!0):null;let Te;if((1===_||1===x)&&we>zj&&!1===(Ee||Ae||Oe||null!=Re)){let De=ee,je=ie;e&&(De=lo({inputs:{x:ee},backend:i,attrs:{perm:[0,2,1]}}),ce.push(De)),r&&(je=lo({inputs:{x:ie},backend:i,attrs:{perm:[0,2,1]}}),ce.push(je));const Je=1===x;let Ze=De;1!==x&&(Ze=lt({inputs:{x:De},backend:i,attrs:{shape:[he,we,1]}}),ce.push(Ze));const et=1===x?2:1;let rt=je;Je&&(rt=lt({inputs:{x:je},backend:i,attrs:{shape:[he,1,we]}}),ce.push(rt));const bt=Jk({inputs:{a:Ze,b:rt},backend:i});Te=_x({inputs:{x:bt},backend:i,attrs:{axis:et,keepDims:!0}}),ce.push(bt)}else{const De=zo(n.dtype,t.dtype),je=new Pj(j,Y,[he,_,x],e,r,Ee,Re,Ae,Oe),We=[ee,ie];if(null!=o&&We.push(o),Ae&&We.push(s),Oe){const Je=i.makeTensorInfo([],"float32",lc(a,"float32"));We.push(Je),ce.push(Je)}Te=i.runWebGLProgram(je,We,De)}const xe=lt({inputs:{x:Te},backend:i,attrs:{shape:V}});ce.push(Te);for(const De of ce)i.disposeIntermediateTensorInfo(De);return xe}const USe={kernelName:P0,backendName:"webgl",kernelFunc:function zSe(n){const{inputs:t,backend:e,attrs:r}=n,{a:i,b:o,bias:s,preluActivationWeights:a}=t,{transposeA:c,transposeB:u,activation:p,leakyreluAlpha:m}=r;return vx({a:i,b:o,transposeA:c,transposeB:u,backend:e,bias:s,preluActivationWeights:a,leakyreluAlpha:m,activation:p})}},Uj="return abs(x);",GSe={kernelName:R_,backendName:"webgl",kernelFunc:function jSe(n){const{inputs:t,backend:e}=n,{x:r}=t;if(e.shouldExecuteOnCPU([r])&&"complex64"!==r.dtype){const o=e.texData.get(r.dataId),s=Sj(o.values);return e.makeTensorInfo(r.shape,r.dtype,s)}let i;return i=Ie().getBool("WEBGL_PACK_UNARY_OPERATIONS")?new Bc(r.shape,Uj):new Ya(r.shape,Uj),e.runWebGLProgram(i,[r],r.dtype)}},WSe=Sn({opSnippet:gs+"\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return acos(x);\n"}),qSe={kernelName:sm,backendName:"webgl",kernelFunc:WSe},XSe=Sn({opSnippet:gs+"\n  if (x < 1.0) return NAN;\nreturn log(x + sqrt(x * x - 1.0));"}),YSe={kernelName:am,backendName:"webgl",kernelFunc:XSe},jj="return a + b;",ZSe=Ni({opSnippet:jj,packedOpSnippet:jj,supportsComplex:!0,cpuKernelImpl:o1e}),QSe={kernelName:xh,backendName:"webgl",kernelFunc:ZSe};class JSe{constructor(t,e){this.outputShape=[],this.outputShape=t,this.variableNames=e.map((o,s)=>`T${s}`);const r=[];this.variableNames.forEach(o=>{r.push(`float v${o} = get${o}AtOutCoords();`)});const i=this.variableNames.map(o=>`v${o}`).join(" + ");this.userCode=`\n      void main() {\n        ${r.join("\n        ")}\n\n        float result = ${i};\n        setOutput(result);\n      }\n    `}}class eCe{constructor(t,e){this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t,this.variableNames=e.map((o,s)=>`T${s}`);const r=[];this.variableNames.forEach(o=>{r.push(`vec4 v${o} = get${o}AtOutCoords();`)});const i=this.variableNames.map(o=>`v${o}`).join(" + ");this.userCode=`\n      void main() {\n        ${r.join("\n        ")}\n\n        vec4 result = ${i};\n        setOutput(result);\n      }\n    `}}const tCe={kernelName:M_,backendName:"webgl",kernelFunc:function xx(n){const{inputs:t,backend:e}=n,r=t;if(1===r.length)return qo({inputs:{x:r[0]},backend:e});if(r.length>Ie().get("WEBGL_MAX_TEXTURES_IN_SHADER")){const c=Math.floor(r.length/2),u=xx({inputs:r.slice(0,c),backend:e}),p=xx({inputs:r.slice(c),backend:e});return xx({inputs:[u,p],backend:e})}const i=r.map(c=>c.dtype).reduce((c,u)=>zo(c,u)),o=r.map(c=>c.shape),a=Ie().getBool("WEBGL_PACK")?new eCe(r[0].shape,o):new JSe(r[0].shape,o);return e.runWebGLProgram(a,r,i)}},rCe={kernelName:"All",backendName:"webgl",kernelFunc:function nCe(n){const{inputs:t,backend:e,attrs:r}=n,{x:i}=t,{axis:o,keepDims:s}=r,a=i.shape.length,c=cn(o,i.shape);let u=c;const p=hr(u,a);let m=i;null!=p&&(m=lo({inputs:{x:i},backend:e,attrs:{perm:p}}),u=Mr(u.length,a)),ki("all",u,a);const[g,_]=gi(m.shape,u),T=lt({inputs:{x:m},backend:e,attrs:{shape:[-1,Me(_)]}}),I=Ju(T,T.dtype,"all",e);let N;return N=lt(s?{inputs:{x:I},backend:e,attrs:{shape:Rr(g,c)}}:{inputs:{x:I},backend:e,attrs:{shape:g}}),e.disposeIntermediateTensorInfo(T),e.disposeIntermediateTensorInfo(I),null!=p&&e.disposeIntermediateTensorInfo(m),N}},oCe={kernelName:"Any",backendName:"webgl",kernelFunc:function iCe(n){const{inputs:t,backend:e,attrs:r}=n,{x:i}=t,{axis:o,keepDims:s}=r,a=i.shape.length,c=cn(o,i.shape);let u=c;const p=hr(u,a);let m=i;null!=p&&(m=lo({inputs:{x:i},backend:e,attrs:{perm:p}}),u=Mr(u.length,a)),ki("any",u,a);const[g,_]=gi(m.shape,u),T=lt({inputs:{x:m},backend:e,attrs:{shape:[-1,Me(_)]}}),I=Ju(T,T.dtype,"any",e);let N;return N=lt(s?{inputs:{x:I},backend:e,attrs:{shape:Rr(g,c)}}:{inputs:{x:I},backend:e,attrs:{shape:g}}),e.disposeIntermediateTensorInfo(T),e.disposeIntermediateTensorInfo(I),null!=p&&e.disposeIntermediateTensorInfo(m),N}};class sCe{constructor(t,e,r){this.variableNames=["A"];const{windowSize:i,batchSize:o,outSize:s}=t;r||this.variableNames.push("bestIndicesA"),this.outputShape=[o,s],this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${i};\n\n        int bestIndex = inOffset;\n        float bestValue = getA(batch, bestIndex);\n\n        for (int i = 0; i < ${i}; i++) {\n          int inIdx = ${r?"inOffset + i;":"round(getBestIndicesA(batch, inOffset + i));"};\n          float candidate = getA(batch, inIdx);\n          if (candidate ${"max"===e?">":"<"} bestValue) {\n            bestValue = candidate;\n            bestIndex = inIdx;\n          }\n        }\n        setOutput(float(bestIndex));\n      }\n    `}}class aCe{constructor(t,e,r,i){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,Z(t.length>2,()=>`Packed arg${r.charAt(0).toUpperCase()+r.slice(1)} supports only inputs with rank above 2.`);const s=Math.ceil(t[t.length-1]/e);this.outputShape=t.slice(0,-1),s>1&&this.outputShape.push(s),i||this.variableNames.push("bestIndicesA");const a=this.outputShape,c=a.length,u=jn(c),p=ao("coords",c);let m,g;if(1===s){g=c+1;const ie=jn(g);m=`\n        ${ie} sourceLocR = ${ie}(${p.join()}, 0);\n        ++${p[c-1]};\n        ${ie} sourceLocG = ${ie}(${p.join()}, 0);\n        ++${p[c-2]};\n        ${ie} sourceLocA = ${ie}(${p.join()}, 0);\n        --${p[c-1]};\n        ${ie} sourceLocB = ${ie}(${p.join()}, 0);\n        --${p[c-2]};`}else g=c,m=`\n        ${u} sourceLocR = coords;\n        ++${p[c-1]};\n        ${u} sourceLocG = coords;\n        ++${p[c-2]};\n        ${u} sourceLocA = coords;\n        --${p[c-1]};\n        ${u} sourceLocB = coords;\n        --${p[c-2]};`;const _=["x","y","z","w","u","v"].slice(0,g),x="."+_[g-1],T=_.map(ie=>"int "+ie),I=ao("sourceLocR",g-1).concat("inIdx.r"),N=ao("sourceLocG",g-1).concat("inIdx.g"),R=ao("sourceLocB",g-1).concat("inIdx.b"),L=ao("sourceLocA",g-1).concat("inIdx.a"),V="max"===r?"greaterThan":"lessThan",j=i?"":`\n          inIdx = round(vec4(getBestIndicesAChannel(${I.join()}),\n                             getBestIndicesAChannel(${N.join()}),\n                             getBestIndicesAChannel(${R.join()}),\n                             getBestIndicesAChannel(${L.join()})));`,Y=`vec4(\n            getAChannel(${I.join()}),\n            hasNextCol ? getAChannel(${N.join()}) : 0.,\n            hasNextRow ? getAChannel(${R.join()}) : 0.,\n            hasNextRow && hasNextCol ? getAChannel(${L.join()}) : 0.)`,ee=i?"":`\n      float getBestIndicesAChannel(${T.join()}) {\n        return getChannel(getBestIndicesA(${_.join()}),\n                                          vec2(${_.slice(-2).join()}));\n      }`;this.userCode=`\n      float getAChannel(${T.join()}) {\n        return getChannel(getA(${_.join()}),\n                               vec2(${_.slice(-2).join()}));\n      }\n      ${ee}\n      void main() {\n        ${u} coords = getOutputCoords();\n        bool hasNextCol = ${p[c-1]} < ${a[c-1]-1};\n        bool hasNextRow = ${p[c-2]} < ${a[c-2]-1};\n        ${m}\n        ivec4 srcIdx = ivec4(sourceLocR${x}, sourceLocG${x},\n          sourceLocB${x}, sourceLocA${x}) * ${e};\n        ivec4 inIdx = srcIdx;\n        vec4 bestIndex = vec4(inIdx);\n        vec4 bestValue = ${Y};\n\n        for (int i = 0; i < ${e}; i++) {\n          inIdx = srcIdx;\n          ${j}\n          vec4 candidate = ${Y};\n          bvec4 nan = isnan(candidate);\n          bvec4 replace = bvec4(\n            vec4(${V}(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));\n\n          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,\n                           replace.y  ? candidate.y : bestValue.y,\n                           replace.z  ? candidate.z : bestValue.z,\n                           replace.w  ? candidate.w : bestValue.w);\n          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));\n          srcIdx++;\n        }\n        setOutput(bestIndex);\n      }\n    `}}function Gj(n,t,e,r=null){let i=t.shape[0],o=t.shape[1];null!=r&&(i=r.shape[0],o=r.shape[1]);const s=vv(o),a={windowSize:s,inSize:o,batchSize:i,outSize:Math.ceil(o/s)},c=new sCe(a,e,null==r),u=[t];null!=r&&u.push(r);const p=n.runWebGLProgram(c,u,"int32");if(1===p.shape[1])return p;const m=Gj(n,t,e,p);return n.disposeIntermediateTensorInfo(p),m}function Hj(n,t,e,r=null){const i=null!=r?r.shape:t.shape,s=vv(i[i.length-1]),a=new aCe(i,s,e,null==r),u=n.runWebGLProgram(a,null==r?[t]:[t,r],"int32");if(u.shape.length===t.shape.length){const p=Hj(n,t,e,u);return n.disposeIntermediateTensorInfo(u),p}return u}function Wj(n,t,e,r){const i=[e];if(ki("arg"+r.charAt(0).toUpperCase()+r.slice(1),i,t.shape.length),!Ie().getBool("WEBGL_PACK_REDUCE")||t.shape.length<=2){const o=[],s=n.texData.get(t.dataId);let c=t;null!==s&&s.isPacked&&(c=n.unpackTensor(t),o.push(c));const[u,p]=gi(c.shape,i),m=Me(p),g=lt({inputs:{x:c},backend:n,attrs:{shape:[-1,m]}});o.push(g);const _=Gj(n,g,r);o.push(_);const x=lt({inputs:{x:_},backend:n,attrs:{shape:u}});return o.forEach(T=>n.disposeIntermediateTensorInfo(T)),x}return Hj(n,t,r)}const cCe={kernelName:F_,backendName:"webgl",kernelFunc:function lCe(n){const{inputs:t,backend:e,attrs:r}=n,{x:i}=t,{axis:o}=r;let s=cn(o,i.shape);const a=hr(s,i.shape.length);let c=i;const u=[];null!=a&&(c=lo({inputs:{x:i},backend:e,attrs:{perm:a}}),u.push(c),s=Mr(s.length,c.shape.length)),ki("argMax",[s[0]],c.shape.length);const p=Wj(e,c,s[0],"max");return u.forEach(m=>e.disposeIntermediateTensorInfo(m)),p}},dCe={kernelName:P_,backendName:"webgl",kernelFunc:function uCe(n){const{inputs:t,backend:e,attrs:r}=n,{x:i}=t,{axis:o}=r;let s=cn(o,i.shape);const a=hr(s,i.shape.length);let c=i;const u=[];null!=a&&(c=lo({inputs:{x:i},backend:e,attrs:{perm:a}}),u.push(c),s=Mr(s.length,c.shape.length)),ki("argMin",[s[0]],c.shape.length);const p=Wj(e,c,s[0],"min");return u.forEach(m=>e.disposeIntermediateTensorInfo(m)),p}},pCe=Sn({opSnippet:gs+"\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return asin(x);\n"}),fCe={kernelName:lm,backendName:"webgl",kernelFunc:pCe},gCe=Sn({opSnippet:gs+"return log(x + sqrt(x * x + 1.0));"}),bCe={kernelName:cm,backendName:"webgl",kernelFunc:gCe},_Ce=Sn({opSnippet:gs+"\n  return atan(x);\n"}),vCe={kernelName:um,backendName:"webgl",kernelFunc:_Ce},TCe=Ni({opSnippet:Qk+"\n  return atan(a, b);\n",packedOpSnippet:"\n  vec4 result = atan(a, b);\n  bvec4 isNaNA = isnan(a);\n  bvec4 isNaNB = isnan(b);\n  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);\n  "+Qu+"\n  return result;\n"}),SCe={kernelName:hm,backendName:"webgl",kernelFunc:TCe},ICe=Sn({opSnippet:gs+"\n  if ((x < -1.0) || (x > 1.0)) return NAN;\nreturn (log(1.0 + x) - log(1.0 - x)) / 2.0;"}),ECe={kernelName:dm,backendName:"webgl",kernelFunc:ICe};class Wg{constructor(t,e,r,i=!1,o=!1){if(this.variableNames=["x"],"avg"===e&&r)throw new Error("Cannot compute positions for average pool.");const s=t.filterWidth,a=t.strideHeight,c=t.strideWidth,u=t.dilationHeight,p=t.dilationWidth,m=t.effectiveFilterHeight,g=t.effectiveFilterWidth,_=t.padInfo.top,x=t.padInfo.left;this.outputShape=t.outShape;const T="avg"===e;let R="0.0";if(T||(R="-1.0 / 1e-20"),r)return void(this.userCode=`\n        const ivec2 strides = ivec2(${a}, ${c});\n        const ivec2 pads = ivec2(${_}, ${x});\n\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int batch = coords[0];\n          int d = coords[3];\n\n          ivec2 xRCCorner = coords.yz * strides - pads;\n          int xRCorner = xRCCorner.x;\n          int xCCorner = xRCCorner.y;\n\n          // max/min x(?, ?, d) to get y(yR, yC, d).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n          float avgValue = 0.0;\n\n          for (int wR = 0; wR < ${m};\n              wR += ${u}) {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ${t.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${g};\n                wC += ${p}) {\n              int xC = xCCorner + wC;\n\n              if (xC < 0 || xC >= ${t.inWidth}) {\n                continue;\n              }\n\n              float value = getX(batch, xR, xC, d);\n\n              // If a min / max value has already been found, use it. If not,\n              // use the current value.\n              float currMinMaxValue = mix(\n                  value, minMaxValue, minMaxValueFound);\n              if (value >= currMinMaxValue) {\n                minMaxValue = value;\n                minMaxValueFound = 1.0;\n                minMaxPosition = ${i?o?`((batch  * ${t.inHeight} + xR) * ${t.inWidth} + xC) * ${t.inChannels} + d`:`(xR * ${t.inWidth} + xC) * ${t.inChannels} + d`:`wR * ${g} + wC`};\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      `);let V=`${e}(${e}(${e}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"avg"===e&&(V="avgValue / max(count, 1.0)");const j=4*Math.floor(s/4),Y=s%4,ee=`\n      if (${T}) {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = max(values, minMaxValue);\n      }\n    `;this.userCode=`\n      const ivec2 strides = ivec2(${a}, ${c});\n      const ivec2 pads = ivec2(${_}, ${x});\n      const float initializationValue = ${R};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xR, int xC, int d) {\n        if (xC < 0 || xC >= ${t.inWidth}) {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xR, xC, d);\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d = coords[3];\n\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // max/min x(?, ?, d) to get y(yR, yC, d).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(${R});\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wR = 0; wR < ${m};\n            wR += ${u}) {\n          int xR = xRCorner + wR;\n\n          if (xR < 0 || xR >= ${t.inHeight}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${j}; wC += 4) {\n            int xC = xCCorner + wC * ${p};\n\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${p}, d),\n              getValue(batch, xR, xC + 2 * ${p}, d),\n              getValue(batch, xR, xC + 3 * ${p}, d)\n            );\n\n            ${ee}\n          }\n\n          int xC = xCCorner + ${j};\n          if (${1===Y}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              initializationValue,\n              initializationValue,\n              initializationValue\n            );\n\n            ${ee}\n          } else if (${2===Y}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${p}, d),\n              initializationValue,\n              initializationValue\n            );\n\n            ${ee}\n          } else if (${3===Y}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${p}, d),\n              getValue(batch, xR, xC + 2 * ${p}, d),\n              initializationValue\n            );\n\n            ${ee}\n          }\n        }\n        setOutput(${V});\n      }\n    `}}class eA{constructor(t,e,r,i=!1,o=!1){if(this.variableNames=["x"],"avg"===e&&r)throw new Error("Cannot compute positions for average pool.");const s=t.filterWidth,a=t.strideDepth,c=t.strideHeight,u=t.strideWidth,p=t.dilationDepth,m=t.dilationHeight,g=t.dilationWidth,_=t.effectiveFilterDepth,x=t.effectiveFilterHeight,T=t.effectiveFilterWidth,I=t.padInfo.front,N=t.padInfo.top,R=t.padInfo.left;this.outputShape=t.outShape;const L="avg"===e;let V="0.0";if(L||(V="-1.0 / 1e-20"),r)return void(this.userCode=`\n        const ivec3 strides =\n            ivec3(${a}, ${c}, ${u});\n        const ivec3 pads = ivec3(${I}, ${N}, ${R});\n\n        void main() {\n          ivec5 coords = getOutputCoords();\n          int batch = coords.x;\n          int ch = coords.u;\n\n          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n          int xDCorner = xCorner.x;\n          int xRCorner = xCorner.y;\n          int xCCorner = xCorner.z;\n\n          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n\n          for (int wD = 0; wD < ${_};\n              wD += ${p}) {\n            int xD = xDCorner + wD;\n\n            if (xD < 0 || xD >= ${t.inDepth}) {\n              continue;\n            }\n\n            for (int wR = 0; wR < ${x};\n                wR += ${m}) {\n              int xR = xRCorner + wR;\n\n              if (xR < 0 || xR >= ${t.inHeight}) {\n                continue;\n              }\n\n              for (int wC = 0; wC < ${T};\n                  wC += ${g}) {\n                int xC = xCCorner + wC;\n\n                if (xC < 0 || xC >= ${t.inWidth}) {\n                  continue;\n                }\n\n                float value = getX(batch, xD, xR, xC, ch);\n\n                // If a min / max value has already been found, use it. If not,\n                // use the current value.\n                float currMinMaxValue = mix(\n                    value, minMaxValue, minMaxValueFound);\n                if (value >= currMinMaxValue) {\n                  minMaxValue = value;\n                  minMaxValueFound = 1.0;\n                  minMaxPosition = ${i?o?`(((batch * ${t.inDepth} + xD) * ${t.inHeight} + xR) * ${t.inWidth} + xC) * ${t.inChannels} + ch`:`((xD * ${t.inHeight} + xR) * ${t.inWidth} + xC) * ${t.inChannels} + ch`:`wD * ${x} * ${T} +\n                      wR * ${T} + wC`};\n                }\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      `);let Y=`${e}(${e}(${e}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"avg"===e&&(Y="avgValue / max(count, 1.0)");const ee=4*Math.floor(s/4),ie=s%4,ce=`\n      if (${L}) {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = max(values, minMaxValue);\n      }\n    `;this.userCode=`\n      const ivec3 strides =\n        ivec3(${a}, ${c}, ${u});\n      const ivec3 pads = ivec3(${I}, ${N}, ${R});\n      const float initializationValue = ${V};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xD, int xR, int xC, int ch) {\n        if (xC < 0 || xC >= ${t.inWidth}) {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xD, xR, xC, ch);\n      }\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xDCorner = xCorner.x;\n        int xRCorner = xCorner.y;\n        int xCCorner = xCorner.z;\n\n        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(${V});\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wD = 0; wD < ${_};\n            wD += ${p}) {\n          int xD = xDCorner + wD;\n\n          if (xD < 0 || xD >= ${t.inDepth}) {\n            continue;\n          }\n\n          for (int wR = 0; wR < ${x};\n            wR += ${m}) {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ${t.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${ee}; wC += 4) {\n              int xC = xCCorner + wC * ${g};\n\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${g}, ch),\n                getValue(batch, xD, xR, xC + 2 * ${g}, ch),\n                getValue(batch, xD, xR, xC + 3 * ${g}, ch)\n              );\n\n              ${ce}\n            }\n\n            int xC = xCCorner + ${ee};\n            if (${1===ie}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                initializationValue,\n                initializationValue,\n                initializationValue\n              );\n\n              ${ce}\n            } else if (${2===ie}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${g}, ch),\n                initializationValue,\n                initializationValue\n              );\n\n              ${ce}\n            } else if (${3===ie}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${g}, ch),\n                getValue(batch, xD, xR, xC + 2 * ${g}, ch),\n                initializationValue\n              );\n\n              ${ce}\n            }\n          }\n        }\n        setOutput(${Y});\n      }\n    `}}const kCe={kernelName:$_,backendName:"webgl",kernelFunc:function DCe(n){const{inputs:t,backend:e,attrs:r}=n,{x:i}=t;Ug(i,"avgPool");const{filterSize:o,strides:s,pad:a,dimRoundingMode:c}=r;Z(Di(s,1),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${s} and dilations '1'`);const p=Rs(i.shape,o,s,1,a,c);if(1===p.filterWidth&&1===p.filterHeight&&mn(p.inShape,p.outShape))return qo({inputs:{x:i},backend:e});const m=new Wg(p,"avg",!1);return e.runWebGLProgram(m,[i],"float32")}},NCe={kernelName:L_,backendName:"webgl",kernelFunc:function ACe(n){const{inputs:t,backend:e,attrs:r}=n,{x:i}=t,{filterSize:o,strides:s,pad:a,dimRoundingMode:c,dataFormat:u}=r,m=wl(i.shape,o,s,[1,1,1],a,c,u),g=new eA(m,"avg",!1);return e.runWebGLProgram(g,[i],"float32")}};class OCe{constructor(t){this.variableNames=["dy"],this.outputShape=t.inShape;const c=t.effectiveFilterHeight,u=t.effectiveFilterWidth;this.userCode=`\n      const ivec2 pads = ivec2(${c-1-t.padInfo.top}, ${u-1-t.padInfo.left});\n      const float avgMultiplier = float(${1/(t.filterHeight*t.filterWidth)});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${c};\n            wR += ${t.dilationHeight}) {\n          float dyR = float(dyRCorner + wR) / ${t.strideHeight}.0;\n\n          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ${u};\n            wC+= ${t.dilationWidth}) {\n            float dyC = float(dyCCorner + wC) / ${t.strideWidth}.0;\n\n            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n\n            dotProd += dyValue * avgMultiplier;\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class RCe{constructor(t){this.variableNames=["dy"],this.outputShape=t.inShape;const m=t.effectiveFilterDepth,g=t.effectiveFilterHeight,_=t.effectiveFilterWidth;this.userCode=`\n      const ivec3 pads = ivec3(${m-1-t.padInfo.front}, ${g-1-t.padInfo.top}, ${_-1-t.padInfo.left});\n      const float avgMultiplier = float(${1/(t.filterDepth*t.filterHeight*t.filterWidth)});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ${m};\n            wD += ${t.dilationDepth}) {\n          float dyD = float(dyDCorner + wD) / ${t.strideDepth}.0;\n\n          if (dyD < 0.0 || dyD >= ${t.outDepth}.0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ${g};\n              wR += ${t.dilationHeight}) {\n            float dyR = float(dyRCorner + wR) / ${t.strideHeight}.0;\n\n            if (dyR < 0.0 || dyR >= ${t.outHeight}.0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ${_};\n                wC += ${t.dilationWidth}) {\n              float dyC = float(dyCCorner + wC) / ${t.strideWidth}.0;\n\n              if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n\n              dotProd += dyValue * avgMultiplier;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const FCe={kernelName:_C,backendName:"webgl",kernelFunc:function MCe(n){const{inputs:t,backend:e,attrs:r}=n,{dy:i,input:o}=t,s=o,{filterSize:a,strides:c,pad:u,dimRoundingMode:p}=r,g=wl(s.shape,a,c,[1,1,1],u,p),_=new RCe(g);return e.runWebGLProgram(_,[i],s.dtype)}},$Ce={kernelName:yC,backendName:"webgl",kernelFunc:function PCe(n){const{inputs:t,backend:e,attrs:r}=n,{dy:i,input:o}=t,s=o;Ug([i,o],"avgPoolGrad");const{filterSize:a,strides:c,pad:u}=r,p=Rs(s.shape,a,c,1,u),m=new OCe(p);return e.runWebGLProgram(m,[i],s.dtype)}},BCe={kernelName:B_,backendName:"webgl",kernelFunc:function LCe(n){const{inputs:t,backend:e,attrs:r}=n,{a:i,b:o}=t,{transposeA:s,transposeB:a}=r;return vx({a:i,b:o,transposeA:s,transposeB:a,backend:e})}};class VCe{constructor(t,e,r,i,o,s){this.outputShape=[],this.variableNames=["x","mean","variance"],Yt(t,e),Yt(t,r);let a="0.0";null!=i&&(Yt(t,i),this.variableNames.push("offset"),a="getOffsetAtOutCoords()");let c="1.0";null!=o&&(Yt(t,o),this.variableNames.push("scale"),c="getScaleAtOutCoords()"),this.outputShape=t,this.userCode=`\n      void main() {\n        float x = getXAtOutCoords();\n        float mean = getMeanAtOutCoords();\n        float variance = getVarianceAtOutCoords();\n        float offset = ${a};\n        float scale = ${c};\n        float inv = scale * inversesqrt(variance + float(${s}));\n        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));\n      }\n    `}}class zCe{constructor(t,e,r,i,o,s){this.packedInputs=!0,this.packedOutput=!0,this.variableNames=["x","mean","variance"],Yt(t,e),Yt(t,r);let a="vec4(0.0)";null!=i&&(Yt(t,i),this.variableNames.push("offset"),a="getOffsetAtOutCoords()");let c="vec4(1.0)";null!=o&&(Yt(t,o),this.variableNames.push("scale"),c="getScaleAtOutCoords()"),this.outputShape=t,this.userCode=`\n      void main() {\n        vec4 offset = ${a};\n        vec4 scale = ${c};\n\n        vec4 x = getXAtOutCoords();\n        vec4 mean = getMeanAtOutCoords();\n        vec4 variance = getVarianceAtOutCoords();\n\n        vec4 inv = scale * inversesqrt(variance + vec4(${s}));\n\n        setOutput((x - mean) * inv + offset);\n      }\n    `}}const UCe={kernelName:Z_,backendName:"webgl",kernelFunc:({inputs:n,backend:t,attrs:e})=>{const{x:r,mean:i,variance:o,offset:s,scale:a}=n;Z(i.shape.length===o.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),Z(null==s||i.shape.length===s.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),Z(null==a||i.shape.length===a.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");let{varianceEpsilon:c}=e;null==c&&(c=.001);const u=[r,i,o];let p=null;null!=s&&(p=s.shape,u.push(s));let m=null;null!=a&&(m=a.shape,u.push(a));const g=Ie().getBool("WEBGL_PACK_NORMALIZATION")?new zCe(r.shape,i.shape,o.shape,p,m,c):new VCe(r.shape,i.shape,o.shape,p,m,c);return t.runWebGLProgram(g,u,u[0].dtype)}};class jCe{constructor(t){this.variableNames=["source"],this.outputShape=t,this.rank=t.length;const e=jn(this.rank);this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const r=function GCe(n){if(1===n)return"sourceLoc";if(n<=6)return tA.slice(0,n).map(t=>"sourceLoc."+t).join(",");throw Error(`Slicing for rank ${n} is not yet supported`)}(this.rank);let i;i=`\n        ${e} sourceLoc;\n        ${e} coords = getOutputCoords();\n        ${t.map((s,a)=>`sourceLoc.${tA[a]} = start[${a}] + coords.${tA[a]};`).join("\n")}\n      `,this.userCode=`\n      void main() {\n        ${i}\n        setOutput(getSource(${r}));\n      }\n    `}}const tA=["x","y","z","w","u","v"];class HCe{constructor(t){this.variableNames=["source"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t,this.rank=t.length,this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const e=jn(this.rank),r=ao("coords",this.rank),i=ao("sourceLoc",this.rank),o=1===this.rank?"sourceLoc":`vec2(${i.slice(-2).join()})`,s=`getChannel(getSource(${i.join()}), ${o})`,a=`\n      result.x = ${s};\n      if (++${r[this.rank-1]} < ${t[this.rank-1]}) {\n        ++${i[this.rank-1]};\n        result.y = ${s};\n        --${i[this.rank-1]};\n      }\n    `,c=1===this.rank?"":`\n      --${r[this.rank-1]};\n      if (++${r[this.rank-2]} < ${t[this.rank-2]}) {\n        ++${i[this.rank-2]};\n        result.z = ${s};\n        if (++${r[this.rank-1]} < ${t[this.rank-1]}) {\n          ++${i[this.rank-1]};\n          result.w = ${s};\n        }\n      }\n    `,u=this.rank<=4?`sourceLoc = coords +\n            ${e}(${t.map((p,m)=>`start[${m}]`).join()});`:t.map((p,m)=>`${i[m]} = ${r[m]} + start[${m}];`).join("\n");this.userCode=`\n      void main() {\n        ${e} coords = getOutputCoords();\n        ${e} sourceLoc;\n        ${u}\n        vec4 result = vec4(0.);\n        ${a}\n        ${c}\n        setOutput(result);\n      }\n    `}}function ap(n){const{inputs:t,backend:e,attrs:r}=n,{x:i}=t,{begin:o,size:s}=r,[a,c]=X0(i,o,s);if(nE(i,a,c),0===Me(c))return e.makeTensorInfo(c,i.dtype,[]);if(e.shouldExecuteOnCPU([i])||"string"===i.dtype){const m=e.texData.get(i.dataId),g=P1e(m.values,a,c,i.shape,i.dtype);return e.makeTensorInfo(c,i.dtype,g)}const{isPacked:u}=e.texData.get(i.dataId),p=iE(i.shape,a,c);if(u||!p){const m=Ie().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new HCe(c):new jCe(c);return e.runWebGLProgram(m,[i],i.dtype,[a])}return e.uploadToGPU(i.dataId),function WCe(n,t,e,r){const i=r.texData.get(n.dataId),o=r.makeTensorInfo(e,n.dtype),s=r.texData.get(o.dataId);Object.assign(s,i),s.refCount=1,s.shape=e,s.dtype=n.dtype;let a=oE(t,Rt(n.shape));i.slice&&(a+=i.slice.flatOffset),s.slice={flatOffset:a,origDataId:i.slice&&i.slice.origDataId||n.dataId};const c=r.dataRefCount.get(s.slice.origDataId)||1;return r.dataRefCount.set(s.slice.origDataId,c+1),o}(i,a,c,e)}const qCe={kernelName:E0,backendName:"webgl",kernelFunc:ap},KCe={kernelName:V_,backendName:"webgl",kernelFunc:n=>{const{inputs:t,backend:e,attrs:r}=n,{x:i}=t,{blockShape:o,crops:s}=r;Z(i.shape.length<=4,()=>"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet");const a=o.reduce((R,L)=>R*L),c=vg(i.shape,o,a),u=xg(c.length,o.length),p=wg(i.shape,o,a),m=rD(s,o.length),g=iD(p,s,o.length),_=[],x=lt({inputs:{x:i},backend:e,attrs:{shape:c}}),T=lo({inputs:{x},backend:e,attrs:{perm:u}}),I=lt({inputs:{x:T},backend:e,attrs:{shape:p}}),N=ap({inputs:{x:I},backend:e,attrs:{begin:m,size:g}});return _.push(x),_.push(T),_.push(I),_.forEach(R=>e.disposeIntermediateTensorInfo(R)),N}},YCe={kernelName:vC,backendName:"webgl",kernelFunc:function XCe(n){const{inputs:t,backend:e,attrs:r}=n,{x:i,weights:o}=t,{size:s}=r,a=e.readSync(i.dataId),c=e.readSync(o.dataId),u=Tj(a,c,o.dtype,o.shape,s);return e.makeTensorInfo([s],o.dtype,u)}},QCe={kernelName:wC,backendName:"webgl",kernelFunc:function ZCe(n){const{inputs:t,backend:e}=n,{s0:r,s1:i}=t,o=e.readSync(r.dataId),s=e.readSync(i.dataId),a=Yt(Array.from(o),Array.from(s));return e.makeTensorInfo([a.length],"int32",Int32Array.from(a))}},qj=Ni({opSnippet:"return float(a != b);",cpuKernelImpl:E1e,dtype:"bool"}),JCe={kernelName:m0,backendName:"webgl",kernelFunc:qj};function qg(n){const{inputs:t,backend:e}=n,{input:r}=t;return qo({inputs:{x:e.texData.get(r.dataId).complexTensorInfos.real},backend:e})}const eIe={kernelName:rI,backendName:"webgl",kernelFunc:qg},rIe={kernelName:pm,backendName:"webgl",kernelFunc:function nA(n){const{inputs:t,backend:e,attrs:r}=n,{x:i}=t,{dtype:o}=r;if("complex64"===o){if("complex64"===i.dtype)return qo({inputs:{x:i},backend:e});const s=ni(i.shape),a=nA({inputs:{x:i},backend:e,attrs:{dtype:"float32"}}),c=Vc({inputs:{real:a,imag:s},backend:e});return s.dispose(),e.disposeIntermediateTensorInfo(a),c}if("complex64"===i.dtype){const s=qg({inputs:{input:i},backend:e}),a=nA({inputs:{x:s},backend:e,attrs:{dtype:o}});return e.disposeIntermediateTensorInfo(s),a}if(!XL(i.dtype,o)){const s=qo({inputs:{x:i},backend:e});return{dataId:s.dataId,shape:s.shape,dtype:o}}if(e.shouldExecuteOnCPU([i])){const s=e.texData.get(i.dataId).values,[a,c,u]=a1e(s,i.shape,i.dtype,o);return e.makeTensorInfo(a,c,u)}if("int32"===o)return function nIe(n,t){const e=new Ya(n.shape,"return float(int(x));"),r=t.runWebGLProgram(e,[n],"int32");return{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}(i,e);if("bool"===o){const s=e.makeTensorInfo([],"bool",Ei("bool",1)),c=qj({inputs:{a:i,b:s},backend:e});return e.disposeIntermediateTensorInfo(s),c}throw new Error(`Error in Cast: failed to cast ${i.dtype} to ${o}`)}},Kj="return ceil(x);",iIe=Sn({opSnippet:Kj,packedOpSnippet:Kj,cpuKernelImpl:l1e}),oIe={kernelName:fm,backendName:"webgl",kernelFunc:iIe};class sIe{constructor(t){this.variableNames=["A"],this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=t,this.userCode="\n\n      void main() {\n        float value = getAAtOutCoords();\n        if (isnan(value)) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, minVal, maxVal));\n      }\n    "}}class aIe{constructor(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=t,this.userCode="\n      void main() {\n        vec4 value = getAAtOutCoords();\n\n        if (any(isnan(value))) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));\n      }\n    "}}const cIe={kernelName:mm,backendName:"webgl",kernelFunc:function lIe(n){const{inputs:t,backend:e,attrs:r}=n,{x:i}=t,{clipValueMin:o,clipValueMax:s}=r;let a;return a=Ie().getBool("WEBGL_PACK_CLIP")?new aIe(i.shape):new sIe(i.shape),e.runWebGLProgram(a,[i],i.dtype,[[o],[s]])}};class uIe{constructor(t){this.variableNames=["real","imag"],this.outputShape=t,this.userCode="\n      void main() {\n        float re = abs(getRealAtOutCoords());\n        float im = abs(getImagAtOutCoords());\n        float mx = max(re, im);\n\n        // sadly the length function in glsl is not underflow-safe\n        // (at least not on Intel GPUs). So the safe solution is\n        // to ensure underflow-safety in all cases.\n        setOutput(\n          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))\n        );\n      }\n    "}}function Xj(n,t){return{dataId:t.dataId,dtype:t.dtype,shape:n.shape}}const hIe={kernelName:z_,backendName:"webgl",kernelFunc:function dIe(n){const{inputs:t,backend:e}=n,{x:r}=t,i=e.texData.get(r.dataId),o=new uIe(r.shape),s=[Xj(r,i.complexTensorInfos.real),Xj(r,i.complexTensorInfos.imag)];return e.runWebGLProgram(o,s,s[0].dtype)}};class pIe{constructor(t){this.outputShape=[],this.outputShape=Va(t,1),this.variableNames=t.map((s,a)=>`T${a}`);const e=new Array(t.length-1);e[0]=t[0][1];for(let s=1;s<e.length;s++)e[s]=e[s-1]+t[s][1];const r=[`if (yC < ${e[0]}) setOutput(getT0(yR, yC));`];for(let s=1;s<e.length;s++)r.push(`else if (yC < ${e[s]}) setOutput(getT${s}(yR, yC-${e[s-1]}));`);r.push(`else setOutput(getT${e.length}(yR, yC-${e[e.length-1]}));`),this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int yR = coords.x;\n        int yC = coords.y;\n\n        ${r.join("\n        ")}\n      }\n    `}}class fIe{constructor(t,e){this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[],this.outputShape=Va(t,e);const r=this.outputShape,i=r.length,o=jn(i),s=ao("coords",i),a=["x","y","z","w","u","v"].slice(0,i);this.variableNames=t.map((T,I)=>`T${I}`);const c=new Array(t.length-1);c[0]=t[0][e];for(let T=1;T<c.length;T++)c[T]=c[T-1]+t[T][e];const u=a[e],p=a.slice(-2),m=a.join();let g=`if (${u} < ${c[0]}) {\n        return getChannel(\n            getT0(${m}), vec2(${p.join()}));\n        }`;for(let T=1;T<c.length;T++){const I=c[T-1];g+=`\n        if (${u} < ${c[T]}  && ${u} >= ${c[T-1]}) {\n          return getChannel(\n            getT${T}(${wx(a,u,I)}),\n            vec2(${wx(p,u,I)}));\n        }`}const x=c[c.length-1];g+=`\n        return getChannel(\n          getT${c.length}(${wx(a,u,x)}),\n          vec2(${wx(p,u,x)}));`,this.userCode=`\n      float getValue(${a.map(T=>"int "+T)}) {\n        ${g}\n      }\n\n      void main() {\n        ${o} coords = getOutputCoords();\n        vec4 result = vec4(getValue(${s}), 0., 0., 0.);\n\n        ${s[i-1]} = ${s[i-1]} + 1;\n        if (${s[i-1]} < ${r[i-1]}) {\n          result.g = getValue(${s});\n        }\n\n        ${s[i-2]} = ${s[i-2]} + 1;\n        if (${s[i-2]} < ${r[i-2]}) {\n          result.a = getValue(${s});\n        }\n\n        ${s[i-1]} = ${s[i-1]} - 1;\n        if (${s[i-2]} < ${r[i-2]} &&\n            ${s[i-1]} < ${r[i-1]}) {\n          result.b = getValue(${s});\n        }\n        setOutput(result);\n      }\n    `}}function wx(n,t,e){const r=n.indexOf(t);return n.map((o,s)=>s===r?`${o} - ${e}`:o).join()}function Tx(n){const{inputs:t,backend:e}=n,{input:r}=t;return qo({inputs:{x:e.texData.get(r.dataId).complexTensorInfos.imag},backend:e})}const mIe={kernelName:jC,backendName:"webgl",kernelFunc:Tx};function Kg(n,t,e){const r=n[0].dtype;if("complex64"===r){const _=n.map(R=>qg({inputs:{input:R},backend:e})),x=n.map(R=>Tx({inputs:{input:R},backend:e})),T=Kg(_,t,e),I=Kg(x,t,e),N=Vc({inputs:{real:T,imag:I},backend:e});return _.forEach(R=>e.disposeIntermediateTensorInfo(R)),x.forEach(R=>e.disposeIntermediateTensorInfo(R)),e.disposeIntermediateTensorInfo(T),e.disposeIntermediateTensorInfo(I),N}let i=e.shouldExecuteOnCPU(n);if("string"===r&&(i=!0),i){const _=n.map(V=>{const Y=[-1,Me(V.shape.slice(t))];return lt({inputs:{x:V},backend:e,attrs:{shape:Y}})}),x=_.map(V=>({vals:e.readSync(V.dataId),shape:V.shape})),T=Va(_.map(V=>V.shape),1),N=c1e(x,T,r,1===_[0].shape[0]),R=Va(n.map(V=>V.shape),t),L=e.makeTensorInfo(R,r,N);return _.forEach(V=>e.disposeIntermediateTensorInfo(V)),L}const o=n.filter(_=>Me(_.shape)>0),s=Ie().getBool("WEBGL_PACK_ARRAY_OPERATIONS")&&o[0].shape.length>1;if(1===o.length){const _=s?new Ya(n[0].shape,Lc):new Bc(n[0].shape,Lc);return e.runWebGLProgram(_,n,r)}const a=Ie().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER");if(o.length>a){const _=[];for(let T=0;T<o.length;T+=a){const I=o.slice(T,T+a);_.push(Kg(I,t,e))}const x=Kg(_,t,e);for(const T of _)e.disposeIntermediateTensorInfo(T);return x}if(s){const _=new fIe(o.map(x=>x.shape),t);return e.runWebGLProgram(_,o,r)}const{tensors2D:c,outShape:u}=function gIe(n,t,e){const r=Va(n.map(o=>o.shape),t);return{tensors2D:n.map(o=>lt({inputs:{x:o},attrs:{shape:[-1,Me(o.shape.slice(t))]},backend:e})),outShape:r}}(o,t,e),p=new pIe(c.map(_=>_.shape)),m=e.runWebGLProgram(p,c,r);c.forEach(_=>e.disposeIntermediateTensorInfo(_));const g=lt({inputs:{x:m},attrs:{shape:u},backend:e});return e.disposeIntermediateTensorInfo(m),g}function Yj(n){const{inputs:t,backend:e,attrs:r}=n,{axis:i}=r,o=cn(i,t[0].shape)[0];eD(t.map(u=>u.shape),o);const a=Va(t.map(u=>u.shape),o);if(0===Me(a))return e.makeTensorInfo(a,t[0].dtype,[]);const c=t.filter(u=>Me(u.shape)>0);return 1===c.length?qo({inputs:{x:c[0]},backend:e}):Kg(c,o,e)}const bIe={kernelName:U_,backendName:"webgl",kernelFunc:Yj};class Zj{constructor(t,e=!1,r=null,i=!1,o=!1){this.variableNames=["x","W"],this.outputShape=t.outShape;const s=t.padInfo.top,a=t.padInfo.left,c=t.strideHeight,u=t.strideWidth,p=t.dilationHeight,m=t.dilationWidth,g=t.filterHeight,_=t.filterWidth,x=4*Math.floor(t.inChannels/4),T=t.inChannels%4,I="channelsLast"===t.dataFormat,N=I?1:2,R=I?2:3,L=I?3:1;let V="",j="";r&&(V=i?`float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ${r}\n        }`:o?`float activation(float a) {\n          float b = getLeakyreluAlphaAtOutCoords();\n          ${r}\n        }`:`\n          float activation(float x) {\n            ${r}\n          }\n        `,j="result = activation(result);");const Y=e?"result += getBiasAtOutCoords();":"";e&&this.variableNames.push("bias"),i&&this.variableNames.push("preluActivationWeights"),o&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n      ${V}\n\n      const ivec2 strides = ivec2(${c}, ${u});\n      const ivec2 pads = ivec2(${s}, ${a});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d2 = coords[${L}];\n\n        ivec2 xRCCorner =\n            ivec2(coords[${N}], coords[${R}]) * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${g}; wR++) {\n          int xR = xRCorner + wR * ${p};\n\n          if (xR < 0 || xR >= ${t.inHeight}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${_}; wC++) {\n            int xC = xCCorner + wC * ${m};\n\n            if (xC < 0 || xC >= ${t.inWidth}) {\n              continue;\n            }\n\n            for (int d1 = 0; d1 < ${x}; d1 += 4) {\n              vec4 wValues = vec4(\n                getW(wR, wC, d1, d2),\n                getW(wR, wC, d1 + 1, d2),\n                getW(wR, wC, d1 + 2, d2),\n                getW(wR, wC, d1 + 3, d2)\n              );\n\n              if (${I}) {\n                vec4 xValues = vec4(\n                  getX(batch, xR, xC, d1),\n                  getX(batch, xR, xC, d1 + 1),\n                  getX(batch, xR, xC, d1 + 2),\n                  getX(batch, xR, xC, d1 + 3)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec4 xValues = vec4(\n                  getX(batch, d1, xR, xC),\n                  getX(batch, d1 + 1, xR, xC),\n                  getX(batch, d1 + 2, xR, xC),\n                  getX(batch, d1 + 3, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n\n            if (${1===T}) {\n\n              if (${I}) {\n                dotProd +=\n                    getX(batch, xR, xC, ${x}) *\n                    getW(wR, wC, ${x}, d2);\n              } else {\n                dotProd +=\n                    getX(batch, ${x}, xR, xC) *\n                    getW(wR, wC, ${x}, d2);\n              }\n\n            } else if (${2===T}) {\n              vec2 wValues = vec2(\n                getW(wR, wC, ${x}, d2),\n                getW(wR, wC, ${x} + 1, d2)\n              );\n\n              if (${I}) {\n                vec2 xValues = vec2(\n                  getX(batch, xR, xC, ${x}),\n                  getX(batch, xR, xC, ${x} + 1)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec2 xValues = vec2(\n                  getX(batch, ${x}, xR, xC),\n                  getX(batch, ${x} + 1, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            } else if (${3===T}) {\n              vec3 wValues = vec3(\n                getW(wR, wC, ${x}, d2),\n                getW(wR, wC, ${x} + 1, d2),\n                getW(wR, wC, ${x} + 2, d2)\n              );\n\n              if (${I}) {\n                vec3 xValues = vec3(\n                  getX(batch, xR, xC, ${x}),\n                  getX(batch, xR, xC, ${x} + 1),\n                  getX(batch, xR, xC, ${x} + 2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec3 xValues = vec3(\n                  getX(batch, ${x}, xR, xC),\n                  getX(batch, ${x} + 1, xR, xC),\n                  getX(batch, ${x} + 2, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            }\n          }\n        }\n\n        float result = dotProd;\n        ${Y}\n        ${j}\n        setOutput(result);\n      }\n    `}}class yIe{constructor(t){this.variableNames=["x","W"],this.outputShape=t.outShape;const e=t.padInfo.front,r=t.padInfo.top,i=t.padInfo.left,o=t.strideDepth,s=t.strideHeight,a=t.strideWidth,c=t.dilationDepth,u=t.dilationHeight,p=t.dilationWidth,m=t.filterDepth,g=t.filterHeight,_=t.filterWidth,x=4*Math.floor(t.inChannels/4),T=t.inChannels%4;this.userCode=`\n      const ivec3 strides = ivec3(${o}, ${s}, ${a});\n      const ivec3 pads = ivec3(${e}, ${r}, ${i});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d2 = coords.u;\n\n        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xFCorner = xFRCCorner.x;\n        int xRCorner = xFRCCorner.y;\n        int xCCorner = xFRCCorner.z;\n\n        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get\n        // y(yF, yR, yC, d2). ? = to be determined. : = across all\n        // values in that axis.\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ${m}; wF++) {\n          int xF = xFCorner + wF * ${c};\n\n          if (xF < 0 || xF >= ${t.inDepth}) {\n            continue;\n          }\n\n          for (int wR = 0; wR < ${g}; wR++) {\n            int xR = xRCorner + wR * ${u};\n\n            if (xR < 0 || xR >= ${t.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${_}; wC++) {\n              int xC = xCCorner + wC * ${p};\n\n              if (xC < 0 || xC >= ${t.inWidth}) {\n                continue;\n              }\n\n              for (int d1 = 0; d1 < ${x}; d1 += 4) {\n                vec4 xValues = vec4(\n                  getX(batch, xF, xR, xC, d1),\n                  getX(batch, xF, xR, xC, d1 + 1),\n                  getX(batch, xF, xR, xC, d1 + 2),\n                  getX(batch, xF, xR, xC, d1 + 3)\n                );\n                vec4 wValues = vec4(\n                  getW(wF, wR, wC, d1, d2),\n                  getW(wF, wR, wC, d1 + 1, d2),\n                  getW(wF, wR, wC, d1 + 2, d2),\n                  getW(wF, wR, wC, d1 + 3, d2)\n                );\n\n                dotProd += dot(xValues, wValues);\n              }\n\n              if (${1===T}) {\n                dotProd +=\n                  getX(batch, xF, xR, xC, ${x}) *\n                  getW(wF, wR, wC, ${x}, d2);\n              } else if (${2===T}) {\n                vec2 xValues = vec2(\n                  getX(batch, xF, xR, xC, ${x}),\n                  getX(batch, xF, xR, xC, ${x} + 1)\n                );\n                vec2 wValues = vec2(\n                  getW(wF, wR, wC, ${x}, d2),\n                  getW(wF, wR, wC, ${x} + 1, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else if (${3===T}) {\n                vec3 xValues = vec3(\n                  getX(batch, xF, xR, xC, ${x}),\n                  getX(batch, xF, xR, xC, ${x} + 1),\n                  getX(batch, xF, xR, xC, ${x} + 2)\n                );\n                vec3 wValues = vec3(\n                  getW(wF, wR, wC, ${x}, d2),\n                  getW(wF, wR, wC, ${x} + 1, d2),\n                  getW(wF, wR, wC, ${x} + 2, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class Qj{constructor(t,e=!1,r=null,i=!1,o=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=t.outShape,this.enableShapeUniforms=Hi(this.outputShape.length);const s=t.padInfo.left,a=t.strideWidth,c=t.dilationWidth,u=t.filterHeight,p=t.filterWidth,m=p;let g="\n       int xR; int xC; int xCOffset;\n       vec4 wTexel; vec4 previous; vec4 final;";for(let I=0;I<p;I++)g+=`\n           vec4 xTexelC${2*I};\n           int xTexelC${2*I}Ready;\n           vec4 xTexelC${2*I+1};\n           int xTexelC${2*I+1}Ready;\n           vec4 xC${I};`;g+=`\n     for (int r = 0; r < ${u}; r++) {\n      for (int d1 = 0; d1 < ${t.inChannels}; d1 += 2) {\n       `;for(let I=0;I<p;I++)g+=`\n           xTexelC${2*I} = vec4(0.0);\n           xTexelC${2*I}Ready = 0;\n           xTexelC${2*I+1} = vec4(0.0);\n           xTexelC${2*I+1}Ready = 0;\n           xC${I} = vec4(0.0);`;g+="\n         xR = xRCorner + r * dilations[0];\n         if (xR >=0 && xR < inDims[0]) {\n       ";for(let I=0;I<(m+1)/2;I++){const N=2*I;if(g+=`\n           xC = xCCorner + ${N*c};\n           `,1===a){if(N<p&&(s%2==1?(g+=`\n                 xCOffset = xC + 1;\n                 if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${N}Ready == 0) {\n                   xTexelC${N} = getX(batch, xR, xCOffset, d1);\n\n                   // Need to manually clear unused channels in case\n                   // we're reading from recycled texture.\n                   if (xCOffset + 1 >= inDims[1]) {\n                     xTexelC${N}.zw = vec2(0.0);\n                   }\n                   xTexelC${N}Ready = 1;\n                 }\n               `,g+=1===c&&N>0?`\n                 xC${N} = vec4(xTexelC${N-2}.zw, xTexelC${N}.xy);\n                 `:`\n                   xCOffset = xC + 1 - 2;\n\n                   if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                     previous = getX(batch, xR, xCOffset, d1);\n\n                     // Need to manually clear unused channels in case\n                     // we're reading from recycled texture.\n                     if (xCOffset + 1 >= inDims[1]) {\n                       previous.zw = vec2(0.0);\n                     }\n\n                     xC${N} = vec4(previous.zw, xTexelC${N}.xy);\n                   } else {\n                     xC${N} = vec4(0.0, 0.0, xTexelC${N}.xy);\n                   }\n                   `):g+=`\n                 if (xC >= 0 && xC < inDims[1] && xTexelC${N}Ready == 0) {\n                   xTexelC${N} = getX(batch, xR, xC, d1);\n                   if (xC + 1 >= inDims[1]) {\n                     xTexelC${N}.zw = vec2(0.0);\n                   }\n                   xTexelC${N}Ready = 1;\n                 }\n\n                 xC${N} = xTexelC${N};\n                 `,N+1<p)){const R=s%2==0?lC(c):c;c%2==0&&s%2==1||c%2!=0&&s%2!=1?(g+=`\n                   xCOffset = xC + imod(pads[1], 2) + ${R};\n\n                   if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${N+1}Ready == 0) {\n                     xTexelC${N+1} = getX(batch, xR, xCOffset, d1);\n\n                     // Need to manually clear unused channels in case\n                     // we're reading from recycled texture.\n                     if (xCOffset + 1 >= inDims[1]) {\n                       xTexelC${N+1}.zw = vec2(0.0);\n                     }\n                     xTexelC${N+1}Ready = 1;\n                   }\n                   `,g+=c>1?`\n                     xCOffset -= 2;\n                     if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                      previous = getX(batch, xR, xCOffset, d1);\n                      xC${N+1} = vec4(previous.zw, xTexelC${N+1}.xy);\n                     } else {\n                      xC${N+1} = vec4(0.0, 0.0, xTexelC${N+1}.xy);\n                     }\n                     `:`\n                     xC${N+1} = vec4(xTexelC${N}.zw, xTexelC${N+1}.xy);\n                     `):g+=1===R?`\n                     xC${N+1} = xTexelC${N};\n                     `:`\n                     xCOffset = xC + ${R};\n\n                     if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${N+1}Ready == 0) {\n                       xTexelC${N+1} = getX(batch, xR, xCOffset, d1);\n                       if (xCOffset + 1 >= inDims[1]) {\n                         xTexelC${N+1}.zw = vec2(0.0);\n                       }\n                       xTexelC${N+1}Ready = 1;\n                     }\n\n                     xC${N+1} = xTexelC${N+1};\n                     `}}else N<p&&(s%2==1?(g+=`\n                 xCOffset = xC + 1 - strides[1];\n                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${N}Ready == 0) {\n                   xTexelC${N} = getX(batch, xR, xCOffset, d1);\n                   // Need to manually clear unused channels in case\n                   // we're reading from recycled texture.\n                   if (xCOffset + 1 >= inDims[1]) {\n                     xTexelC${N}.zw = vec2(0.0);\n                   }\n                   xTexelC${N}Ready = 1;\n                 }\n\n                 if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${N+1}Ready == 0) {\n                   xTexelC${N+1} = getX(batch, xR, xC + 1, d1);\n                   // Need to manually clear unused channels in case\n                   // we're reading from recycled texture.\n                   if (xC + 2 >= inDims[1]) {\n                     xTexelC${N+1}.zw = vec2(0.0);\n                   }\n                   xTexelC${N+1}Ready = 1;\n                 }\n\n                 xC${N} = vec4(xTexelC${N}.zw, xTexelC${N+1}.zw);\n               `,N+1<p&&(g+=`\n                   final = vec4(0.0);\n                   xCOffset = xC + 1 + strides[1];\n                   if(xCOffset >= 0 && xCOffset < inDims[1]) {\n                     final = getX(batch, xR, xCOffset, d1);\n                   }\n                   xC${N+1} = vec4(xTexelC${N+1}.xy, final.xy);\n                 `)):(g+=`\n                 if(xC >= 0 && xC < inDims[1] && xTexelC${N}Ready == 0) {\n                   xTexelC${N} = getX(batch, xR, xC, d1);\n                   if (xC + 1 >= inDims[1]) {\n                     xTexelC${N}.zw = vec2(0.0);\n                   }\n                   xTexelC${N}Ready = 1;\n                 }\n\n                 xCOffset = xC + strides[1];\n                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${N+1}Ready == 0) {\n                   xTexelC${N+1} = getX(batch, xR, xCOffset, d1);\n                   if (xCOffset + 1 >= inDims[1]) {\n                     xTexelC${N+1}.zw = vec2(0.);\n                   }\n                   xTexelC${N+1}Ready = 1;\n                 }\n\n                 xC${N} = vec4(\n                   xTexelC${N}.xy, xTexelC${N+1}.xy);\n               `,N+1<p&&(g+=`\n                   xC${N+1} = vec4(xTexelC${N}.zw, xTexelC${N+1}.zw);\n                 `)));N<p&&(g+=`\n             wTexel = getW(r, ${N}, d1, d2);\n             dotProd += xC${N}.xxzz * vec4(wTexel.xy, wTexel.xy);\n             if(d1 + 1 < ${t.inChannels}) {\n               dotProd += xC${N}.yyww * vec4(wTexel.zw, wTexel.zw);\n             }\n           `,N+1<p&&(g+=`\n               wTexel = getW(r, ${N+1}, d1, d2);\n               dotProd += xC${N+1}.xxzz * vec4(wTexel.xy, wTexel.xy);\n               if(d1 + 1 < ${t.inChannels}) {\n                 dotProd += xC${N+1}.yyww * vec4(wTexel.zw, wTexel.zw);\n               }\n             `))}g+="\n     }\n   ",g+="\n     }\n   ",g+="\n     }\n   ";let _="",x="";r&&(_=i?`vec4 activation(vec4 a) {\n           vec4 b = getPreluActivationWeightsAtOutCoords();\n           ${r}\n         }`:o?`vec4 activation(vec4 a) {\n           vec4 b = getLeakyreluAlphaAtOutCoords();\n           ${r}\n         }`:`vec4 activation(vec4 x) {\n           ${r}\n         }`,x="result = activation(result);");const T=e?"result += getBiasAtOutCoords();":"";e&&this.variableNames.push("bias"),i&&this.variableNames.push("preluActivationWeights"),o&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n       ${_}\n\n       void main() {\n         ivec4 coords = getOutputCoords();\n         int batch = coords.x;\n         ivec2 xRCCorner = coords.yz * strides - pads;\n         int d2 = coords.w;\n         int xRCorner = xRCCorner.x;\n         int xCCorner = xRCCorner.y;\n\n         //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.\n         vec4 dotProd = vec4(0.000000000000001);\n\n         ${g}\n\n         vec4 result = dotProd - vec4(0.000000000000001);\n         ${T}\n         ${x}\n         setOutput(result);\n       }\n     `}}class _Ie{constructor(t,e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec4"},{name:"pad",type:"ivec2"},{name:"stride",type:"ivec2"},{name:"dilation",type:"ivec2"},{name:"inChannels",type:"int"},{name:"itemsPerBlockRow",type:"int"},{name:"outWidth",type:"int"}],this.outputShape=t,this.enableShapeUniforms=Hi(this.outputShape.length);const{dataFormat:r}=e,i=so(),o="channelsLast"===r,s=o?1:2,a=o?2:3,c=this.enableShapeUniforms?"if(blockIndex < outShape[2] && pos < outShape[1]) {":`if(blockIndex < ${t[2]} && pos < ${t[1]}) {`;let u="";for(let p=0;p<=1;p++)for(let m=0;m<=1;m++)u+=`\n          blockIndex = rc.z + ${m};\n          pos = rc.y + ${p};\n\n          ${c}\n            offsetY = int(blockIndex / outWidth) * stride[0] - pad[0];\n            d0 = offsetY + dilation[0] * (pos / itemsPerBlockRow);\n\n            if(d0 < inputShape[${s}] && d0 >= 0) {\n              // Use custom imod instead mod. On Intel GPU, mod may generate\n              // unexpected value.\n              // https://github.com/tensorflow/tfjs/issues/5447\n              offsetX = imod(blockIndex, outWidth) * stride[1] - pad[1];\n              d1 = offsetX + dilation[1] * (imod(pos, itemsPerBlockRow) /\n                  inChannels);\n\n              if(d1 < inputShape[${a}] && d1 >= 0) {\n\n                ch = imod(pos, inChannels);\n\n                if (${o}) {\n                  innerDims = vec2(d1, ch);\n                  result[${2*p+m}] = getChannel(\n                    getA(rc.x, d0, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                } else {\n                  innerDims = vec2(d0, d1);\n                  result[${2*p+m}] = getChannel(\n                    getA(rc.x, ch, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                }\n              }\n            }\n          }\n        `;this.userCode=`\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0);\n\n        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;\n        vec2 innerDims;\n\n        ${u}\n\n        ${i.output} = result;\n      }\n    `}}function Sx(n,t){const e=n.length;return e>=3?t?[...n.slice(0,-3),n[e-3]*n[e-2],n[e-1]]:[...n.slice(0,-3),n[e-3],n[e-2]*n[e-1]]:!t&&1===e&&n[0]>1?[n[0],1]:null}function Jj({x:n,filter:t,convInfo:e,backend:r,bias:i=null,preluActivationWeights:o=null,leakyreluAlpha:s=0,activation:a=null}){const c=n.shape,u=r.texData.get(n.dataId),p=e.inChannels,m=c[0]*c[1]*c[2],g=e.outChannels,_="channelsLast"===e.dataFormat;let I;const N=[];if(null!=o){const V=Sx(o.shape,_);null!=V&&(o=lt({inputs:{x:o},backend:r,attrs:{shape:V}}),N.push(o))}if(null!=i){const V=Sx(i.shape,_);null!=V&&(i=lt({inputs:{x:i},backend:r,attrs:{shape:V}}),N.push(i))}if((1!==m&&1!==g||!(p>zj))&&u.isPacked&&_&&null!=u.texture&&c[2]%2!=0&&mn(u.shape.slice(-3),c.slice(-3))){const j={dataId:n.dataId,shape:[1,c[0]*c[1]*(c[2]+1),e.inChannels],dtype:n.dtype},Y=u.shape;u.shape=u.shape.slice(),u.shape[u.shape.length-2]++,Z(hx(u.shape,j.shape),()=>`packed reshape ${u.shape} to ${j.shape} isn't free`);const ee=lt({inputs:{x:t},backend:r,attrs:{shape:[1,e.inChannels,e.outChannels]}});N.push(ee);const ie=vx({a:j,b:ee,backend:r,transposeA:!1,transposeB:!1,bias:i,activation:a,preluActivationWeights:o,leakyreluAlpha:s}),ce=r.texData.get(ie.dataId);Z(ce.isPacked,()=>"batchMatMul result is expected to be packed"),u.shape=Y,ce.shape=e.outShape,I=qo({inputs:{x:ie},backend:r}),I.shape=e.outShape,N.push(ie)}else{const V=e.outHeight*e.outWidth,j=lt({inputs:{x:n},backend:r,attrs:{shape:_?[e.batchSize,V,e.inChannels]:[e.batchSize,e.inChannels,V]}}),Y=lt({inputs:{x:t},backend:r,attrs:{shape:[1,e.inChannels,e.outChannels]}}),ee=vx({a:_?j:Y,b:_?Y:j,transposeA:!_,transposeB:!1,backend:r,bias:i,activation:a,preluActivationWeights:o,leakyreluAlpha:s});I=lt({inputs:{x:ee},backend:r,attrs:{shape:e.outShape}}),N.push(j),N.push(Y),N.push(ee)}for(const V of N)r.disposeIntermediateTensorInfo(V);return I}function eG({x:n,filter:t,convInfo:e,backend:r,bias:i=null,preluActivationWeights:o=null,leakyreluAlpha:s=0,activation:a=null}){const{filterWidth:c,filterHeight:u,inChannels:p,outWidth:m,outHeight:g,dataFormat:_}=e,x="channelsLast"===_,T=c*u*p,I=g*m,N=[e.batchSize,T,I],V=[];if(null!=o){const xe=Sx(o.shape,x);null!=xe&&(o=lt({inputs:{x:o},backend:r,attrs:{shape:xe}}),V.push(o))}if(null!=i){const xe=Sx(i.shape,x);null!=xe&&(i=lt({inputs:{x:i},backend:r,attrs:{shape:xe}}),V.push(i))}const j=lt({inputs:{x:t},backend:r,attrs:{shape:[1,T,Me(t.shape)/T]}});V.push(j);const Y=new _Ie(N,e),ie=r.runWebGLProgram(Y,[n],"float32",[n.shape,[e.padInfo.top,e.padInfo.left],[e.strideHeight,e.strideWidth],[e.dilationHeight,e.dilationWidth],[e.inChannels],[e.filterWidth*e.inChannels],[e.outWidth]]),ce=lt({inputs:{x:ie},backend:r,attrs:{shape:N}});V.push(ie),V.push(ce);const he=null!=i,we=null!=o,Ee="leakyrelu"===a,Ae=a?Hg(a,!0):null,Oe=new Pj(x?ce.shape:j.shape,x?j.shape:ce.shape,x?[e.batchSize,I,e.outChannels]:[e.batchSize,e.outChannels,I],!0,!1,he,Ae,we,Ee),Re=x?[ce,j]:[j,ce];if(i&&Re.push(i),we&&Re.push(o),Ee){const xe=r.makeTensorInfo([],"float32",lc(s,"float32"));Re.push(xe),V.push(xe)}const _e=r.runWebGLProgram(Oe,Re,"float32"),Te=lt({inputs:{x:_e},backend:r,attrs:{shape:e.outShape}});V.push(_e);for(const xe of V)r.disposeIntermediateTensorInfo(xe);return Te}const xIe={kernelName:j_,backendName:"webgl",kernelFunc:function vIe(n){const{inputs:t,backend:e,attrs:r}=n,{x:i,filter:o}=t,{strides:s,pad:a,dataFormat:c,dilations:u,dimRoundingMode:p}=r,m=Tl(c),g=mi(i.shape,o.shape,s,u,a,p,!1,m);let _;if(1!==g.filterHeight||1!==g.filterWidth||1!==g.dilationHeight||1!==g.dilationWidth||1!==g.strideHeight||1!==g.strideWidth||"SAME"!==g.padInfo.type&&"VALID"!==g.padInfo.type)if(g.strideWidth<=2&&"channelsLast"===m&&Ie().getBool("WEBGL_EXP_CONV")){const T=new Qj(g);_=e.runWebGLProgram(T,[i,o],"float32",[[g.padInfo.top,g.padInfo.left],[g.strideHeight,g.strideWidth],[g.dilationHeight,g.dilationWidth],[g.inHeight,g.inWidth]])}else if(Ie().getBool("WEBGL_CONV_IM2COL"))_=eG({x:i,filter:o,convInfo:g,backend:e});else{const T=new Zj(g);_=e.runWebGLProgram(T,[i,o],"float32")}else _=Jj({x:i,filter:o,convInfo:g,backend:e});const x=lt({inputs:{x:_},backend:e,attrs:{shape:g.outShape}});return e.disposeIntermediateTensorInfo(_),x}};class wIe{constructor(t){this.variableNames=["x","dy"],this.outputShape=t.filterShape,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int d2 = coords.w;\n\n        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ${t.batchSize}; b++) {\n          for (int yR = 0; yR < ${t.outHeight}; yR++) {\n            int xR = wR + yR * ${t.strideHeight} - ${t.padInfo.top};\n\n            if (xR < 0 || xR >= ${t.inHeight}) {\n              continue;\n            }\n\n            for (int yC = 0; yC < ${t.outWidth}; yC++) {\n              int xC = wC + yC * ${t.strideWidth} - ${t.padInfo.left};\n\n              if (xC < 0 || xC >= ${t.inWidth}) {\n                continue;\n              }\n\n              ${"channelsLast"===t.dataFormat?"float dyValue = getDy(b, yR, yC, d2);\n              float xValue = getX(b, xR, xC, d1);\n              dotProd += (xValue * dyValue);":"float dyValue = getDy(b, d2, yR, yC);\n              float xValue = getX(b, d1, xR, xC);\n              dotProd += (xValue * dyValue);"}\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class TIe{constructor(t){this.variableNames=["dy","W"],this.outputShape=t.inShape;const e=t.filterHeight,r=t.filterWidth,s="channelsLast"===t.dataFormat;this.userCode=`\n      const ivec2 pads = ivec2(${e-1-t.padInfo.top}, ${r-1-t.padInfo.left});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[${s?3:1}];\n\n        ivec2 dyCorner = ivec2(coords[${s?1:2}], coords[${s?2:3}]) - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${e}; wR++) {\n          float dyR = float(dyRCorner + wR) / ${t.strideHeight}.0;\n\n          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ${e} - 1 - wR;\n\n          for (int wC = 0; wC < ${r}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${t.strideWidth}.0;\n\n            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ${r} - 1 - wC;\n\n            for (int d2 = 0; d2 < ${t.outChannels}; d2++) {\n\n              if (${s}) {\n                float xValue = getDy(batch, idyR, idyC, d2);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              } else {\n                float xValue = getDy(batch, d2, idyR, idyC);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class SIe{constructor(t){this.variableNames=["x","dy"],this.outputShape=t.filterShape,this.userCode=`\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int wF = coords.x;\n        int wR = coords.y;\n        int wC = coords.z;\n        int d1 = coords.w;\n        int d2 = coords.u;\n\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ${t.batchSize}; b++) {\n          for (int yF = 0; yF < ${t.outDepth}; yF++) {\n            int xF = wF + yF * ${t.strideDepth} - ${t.padInfo.front};\n\n            if (xF < 0 || xF >= ${t.inDepth}) {\n              continue;\n            }\n\n            for (int yR = 0; yR < ${t.outHeight}; yR++) {\n              int xR = wR + yR * ${t.strideHeight} - ${t.padInfo.top};\n\n              if (xR < 0 || xR >= ${t.inHeight}) {\n                continue;\n              }\n\n              for (int yC = 0; yC < ${t.outWidth}; yC++) {\n                int xC = wC + yC * ${t.strideWidth} - ${t.padInfo.left};\n\n                if (xC < 0 || xC >= ${t.inWidth}) {\n                  continue;\n                }\n\n                float dyValue = getDy(b, yF, yR, yC, d2);\n                float xValue = getX(b, xF, xR, xC, d1);\n                dotProd += (xValue * dyValue);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class CIe{constructor(t){this.variableNames=["dy","W"],this.outputShape=t.inShape;const e=t.filterDepth,r=t.filterHeight,i=t.filterWidth;this.userCode=`\n      const ivec3 pads = ivec3(${e-1-t.padInfo.front}, ${r-1-t.padInfo.top}, ${i-1-t.padInfo.left});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.u;\n\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyFCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ${e}; wF++) {\n          float dyF = float(dyFCorner + wF) / ${t.strideDepth}.0;\n\n          if (dyF < 0.0 || dyF >= ${t.outDepth}.0 || fract(dyF) > 0.0) {\n            continue;\n          }\n          int idyF = int(dyF);\n\n          int wFPerm = ${e} - 1 - wF;\n\n          for (int wR = 0; wR < ${r}; wR++) {\n            float dyR = float(dyRCorner + wR) / ${t.strideHeight}.0;\n\n            if (dyR < 0.0 || dyR >= ${t.outHeight}.0 ||\n              fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            int wRPerm = ${r} - 1 - wR;\n\n            for (int wC = 0; wC < ${i}; wC++) {\n              float dyC = float(dyCCorner + wC) / ${t.strideWidth}.0;\n\n              if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              int wCPerm = ${i} - 1 - wC;\n\n              for (int d2 = 0; d2 < ${t.outChannels}; d2++) {\n                float xValue = getDy(batch, idyF, idyR, idyC, d2);\n                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const EIe={kernelName:SC,backendName:"webgl",kernelFunc:function IIe(n){const{inputs:t,backend:e,attrs:r}=n,{x:i,dy:o}=t,{strides:s,pad:a,dataFormat:c,dimRoundingMode:u,filterShape:p}=r,m=Tl(c),g=mi(i.shape,p,s,1,a,u,!1,m),_=new wIe(g);return e.runWebGLProgram(_,[i,o],"float32")}};class DIe{constructor(t){this.variableNames=["dy","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"strides",type:"vec2"}],this.outputShape=t.inShape,this.enableShapeUniforms=Hi(this.outputShape.length);const e=t.filterHeight,r=t.filterWidth;this.userCode=`\n      const ivec2 pads = ivec2(${e-1-t.padInfo.top}, ${r-1-t.padInfo.left});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[3];\n\n        ivec2 dyCorner = ivec2(coords[1], coords[2]) - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        vec4 result = vec4(0.);\n        for (int wR = 0; wR < ${e}; wR++) {\n          float dyR = float(dyRCorner + wR) / strides[0];\n          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n          int wRPerm = ${e} - 1 - wR;\n\n          for (int wC = 0; wC < ${r}; wC++) {\n            int wCPerm = ${r} - 1 - wC;\n\n            float dyC = float(dyCCorner + wC) / strides[1];\n            bool idyCVal = (dyC >= 0.0) && (dyC < ${t.outWidth}.0)\n              && (fract(dyC) == 0.0);\n            int idyC = int(dyC);\n\n            float dyC2 = float(dyCCorner + wC + 1) / strides[1];\n            bool idyCVal2 = (dyC2 >= 0.0) && (dyC2 < ${t.outWidth}.0)\n              && (fract(dyC2) == 0.0);\n            int idyC2 = int(dyC2);\n\n            if (idyCVal && idyCVal2) {\n              for (int d2 = 0; d2 < ${t.outChannels}; d2 += 2) {\n                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);\n                vec4 dySample = getDy(batch, idyR, idyC, d2);\n                vec4 dySample2 = (idyC / 2 == idyC2 / 2) ?\n                  dySample : getDy(batch, idyR, idyC2, d2);\n\n                vec2 dyValue = mod(float(idyC), 2.) == 0. ?\n                  dySample.xy : dySample.zw;\n                result.xy += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n\n                dyValue = mod(float(idyC2), 2.) == 0. ?\n                  dySample2.xy : dySample2.zw;\n                result.zw += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n              }\n            } else if (idyCVal) {\n              for (int d2 = 0; d2 < ${t.outChannels}; d2 += 2) {\n                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);\n                vec4 dySample = getDy(batch, idyR, idyC, d2);\n                vec2 dyValue = mod(float(idyC), 2.) == 0. ?\n                  dySample.xy : dySample.zw;\n                result.xy += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n              }\n            } else if (idyCVal2) {\n              for (int d2 = 0; d2 < ${t.outChannels}; d2 += 2) {\n                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);\n                vec4 dySample = getDy(batch, idyR, idyC2, d2);\n                vec2 dyValue = mod(float(idyC2), 2.) == 0. ?\n                  dySample.xy : dySample.zw;\n                result.zw += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n              }\n            }\n          }\n        }\n        setOutput(result);\n      }\n    `}}const AIe={kernelName:G_,backendName:"webgl",kernelFunc:function kIe(n){const{inputs:t,backend:e,attrs:r}=n,{dy:i,filter:o}=t,{inputShape:s,strides:a,pad:c,dataFormat:u,dimRoundingMode:p}=r,m=Tl(u),g=mi(s,o.shape,a,1,c,p,!1,m);if(Ie().getBool("WEBGL_PACK")&&"channelsLast"===m){const _=[[g.strideHeight,g.strideWidth]],x=new DIe(g);return e.runWebGLProgram(x,[i,o],"float32",_)}{const _=new TIe(g);return e.runWebGLProgram(_,[i,o],"float32")}}},OIe={kernelName:H_,backendName:"webgl",kernelFunc:function NIe(n){const{inputs:t,backend:e,attrs:r}=n,{x:i,filter:o}=t,{strides:s,pad:a,dilations:c}=r,u=xc(i.shape,o.shape,s,c,a),p=new yIe(u);return e.runWebGLProgram(p,[i,o],"float32")}},MIe={kernelName:CC,backendName:"webgl",kernelFunc:function RIe(n){const{inputs:t,backend:e,attrs:r}=n,{x:i,dy:o}=t,{strides:s,pad:a,filterShape:c}=r,u=xc(i.shape,c,s,1,a),p=new SIe(u);return e.runWebGLProgram(p,[i,o],"float32")}},PIe={kernelName:IC,backendName:"webgl",kernelFunc:function FIe(n){const{inputs:t,backend:e,attrs:r}=n,{dy:i,filter:o}=t,{pad:s,strides:a,inputShape:c}=r,u=xc(c,o.shape,a,1,s),p=new CIe(u);return e.runWebGLProgram(p,[i,o],"float32")}},BIe=Sn({opSnippet:sp+"\n  return cos(x);\n",packedOpSnippet:`\n  vec4 result = cos(x);\n  bvec4 isNaN = isnan(x);\n  ${Qu}\n  return result;\n`}),VIe={kernelName:gm,backendName:"webgl",kernelFunc:BIe},zIe=Sn({opSnippet:"\n  float e2x = exp(-x);\n  return (e2x + 1.0 / e2x) / 2.0;\n"}),UIe={kernelName:bm,backendName:"webgl",kernelFunc:zIe};class jIe{constructor(t,e,r,i,o){this.variableNames=["Image","Boxes","BoxInd"],this.outputShape=[];const[s,a,c,u]=t,[p]=e,[m,g]=r;this.outputShape=[p,m,g,u];const _="bilinear"===i?1:0,[x,T]=[a-1+".0",c-1+".0"],[I,N,R]=m>1?[""+(a-1)/(m-1),"(y2-y1) * height_ratio",`y1*${x} + float(y)*(height_scale)`]:["0.0","0.0",`0.5 * (y1+y2) * ${x}`],[L,V,j]=g>1?[""+(c-1)/(g-1),"(x2-x1) * width_ratio",`x1*${T} + float(x)*(width_scale)`]:["0.0","0.0",`0.5 * (x1+x2) * ${T}`];this.userCode=`\n      const float height_ratio = float(${I});\n      const float width_ratio = float(${L});\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int y = coords[1];\n        int x = coords[2];\n        int d = coords[3];\n\n        // get box vals\n        float y1 = getBoxes(b,0);\n        float x1 = getBoxes(b,1);\n        float y2 = getBoxes(b,2);\n        float x2 = getBoxes(b,3);\n\n        // get image in batch index\n        int bInd = round(getBoxInd(b));\n        if(bInd < 0 || bInd >= ${s}) {\n          return;\n        }\n\n        float height_scale = ${N};\n        float width_scale = ${V};\n\n        float in_y = ${R};\n        if( in_y < 0.0 || in_y > ${x} ) {\n          setOutput(float(${o}));\n          return;\n        }\n        float in_x = ${j};\n        if( in_x < 0.0 || in_x > ${T} ) {\n          setOutput(float(${o}));\n          return;\n        }\n\n        vec2 sourceFracIndexCR = vec2(in_x,in_y);\n        if(${_} == 1) {\n          // Compute the four integer indices.\n          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);\n          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));\n\n          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);\n          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);\n          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);\n          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);\n\n          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);\n\n          float top = topLeft + (topRight - topLeft) * fracCR.x;\n          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;\n          float newValue = top + (bottom - top) * fracCR.y;\n          setOutput(newValue);\n        } else {\n          // Compute the coordinators of nearest neighbor point.\n          ivec2 sourceNearestCR = ivec2(floor(\n            sourceFracIndexCR + vec2(0.5,0.5)));\n          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);\n          setOutput(newValue);\n        }\n      }\n    `}}const GIe={kernelName:DC,backendName:"webgl",kernelFunc:n=>{const{inputs:t,backend:e,attrs:r}=n,{image:i,boxes:o,boxInd:s}=t,{cropSize:a,method:c,extrapolationValue:u}=r,p=new jIe(i.shape,o.shape,a,c,u);return e.runWebGLProgram(p,[i,o,s],"float32")}};var zc=(()=>((zc=zc||{}).Prod="*",zc.Sum="+",zc))();class tG{constructor(t,e,r,i){this.op=t,this.outputShape=e,this.variableNames=["x"],this.customUniforms=[{name:"index",type:"float"}];const o=this.outputShape.length,a=r?this.op===zc.Prod?"1.0":"0.0":`getX(${nG(o,"coords",this.op)})`,c=this.outputShape[this.outputShape.length-1];let u="",p="";r?(u=i?"end != "+(c-1):"end != 0",p=i?"end + 1":"end - 1"):(u=i?`end + pow2 < ${c}`:"end >= pow2",p=i?"end + pow2":"end - pow2"),this.userCode=`\n      void main() {\n        ${jn(o)} coords = getOutputCoords();\n        int end = ${rG(o,"coords",this.op)};\n        float val = ${a};\n        int pow2 = int(pow(2.0, index));\n        if (${u}) {\n          int idx = ${p};\n          ${rG(o,"coords",this.op)} = idx;\n          val ${this.op}= getX(${nG(o,"coords",this.op)});\n        }\n        setOutput(val);\n      }\n    `}}function nG(n,t,e){if(1===n)return`${t}`;if(2===n)return`${t}.x, ${t}.y`;if(3===n)return`${t}.x, ${t}.y, ${t}.z`;if(4===n)return`${t}.x, ${t}.y, ${t}.z, ${t}.w`;throw new Error(`Cumulative ${e} for rank ${n} is not yet supported`)}function rG(n,t,e){if(1===n)return`${t}`;if(2===n)return`${t}.y`;if(3===n)return`${t}.z`;if(4===n)return`${t}.w`;throw new Error(`Cumulative ${e} for rank ${n} is not yet supported`)}function iG(n,t,e,r,i,o){const s=t.shape.length,a=hr([r],s);let c=t;null!=a&&(c=lo({inputs:{x:t},backend:e,attrs:{perm:a}}));const u=Mr(1,s)[0];if(u!==s-1)throw new Error(`WebGL cumprod shader expects an inner-most axis=${t.shape.length-1} but got axis=${r}`);const p=c.shape[u];let m=qo({inputs:{x:c},backend:e});for(let g=0;g<=Math.ceil(Math.log2(p))-1;g++){const _=new tG(n,c.shape,!1,o),T=m;m=e.runWebGLProgram(_,[m],m.dtype,[[g]]),e.disposeIntermediateTensorInfo(T)}if(i){const g=new tG(n,c.shape,i,o),_=m;m=e.runWebGLProgram(g,[m],m.dtype),e.disposeIntermediateTensorInfo(_)}if(null!=a){const _=lo({inputs:{x:m},backend:e,attrs:{perm:Sc(a)}});return e.disposeIntermediateTensorInfo(m),e.disposeIntermediateTensorInfo(c),_}return m}const WIe={kernelName:EC,backendName:"webgl",kernelFunc:function HIe(n){const{inputs:t,backend:e,attrs:r}=n,{x:i}=t,{axis:o,exclusive:s,reverse:a}=r;return iG(zc.Prod,i,e,o,s,a)}},KIe={kernelName:W_,backendName:"webgl",kernelFunc:function qIe(n){const{inputs:t,backend:e,attrs:r}=n,{x:i}=t,{axis:o,exclusive:s,reverse:a}=r;return iG(zc.Sum,i,e,o,s,a)}},YIe={kernelName:kC,backendName:"webgl",kernelFunc:function XIe(n){const{inputs:t,backend:e,attrs:r}=n,{x:i,weights:o}=t,{size:s,binaryOutput:a}=r;if(1===i.shape.length){const c=e.readSync(i.dataId),u=e.readSync(o.dataId),p=Tj(c,u,o.dtype,o.shape,s);return e.makeTensorInfo([s],o.dtype,p)}if(2===i.shape.length){const c=e.bufferSync(i),u=e.bufferSync(o),p=s1e(c,u,s,a);return e.makeTensorInfo(p.shape,o.dtype,p.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${i.shape.length}.`)}};class ZIe{constructor(t,e,r){this.variableNames=["x"],this.outputShape=[],this.outputShape=t,this.blockSize=e,this.dataFormat=r,this.userCode=`\n    void main() {\n      ivec4 coords = getOutputCoords();\n      int b = coords[0];\n      int h = ${this.getHeightCoordString()};\n      int w = ${this.getWidthCoordString()};\n      int d = ${this.getDepthCoordString()};\n\n      int in_h = h / ${e};\n      int offset_h = imod(h, ${e});\n      int in_w = w / ${e};\n      int offset_w = imod(w, ${e});\n      int offset_d = (offset_h * ${e} + offset_w) *\n        ${this.getOutputDepthSize()};\n      int in_d = d + offset_d;\n\n      float result = ${this.getInputSamplingString()};\n      setOutput(result);\n    }\n  `}getHeightCoordString(){return"NHWC"===this.dataFormat?"coords[1]":"coords[2]"}getWidthCoordString(){return"NHWC"===this.dataFormat?"coords[2]":"coords[3]"}getDepthCoordString(){return"NHWC"===this.dataFormat?"coords[3]":"coords[1]"}getOutputDepthSize(){return"NHWC"===this.dataFormat?this.outputShape[3]:this.outputShape[1]}getInputSamplingString(){return"NHWC"===this.dataFormat?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}}const JIe={kernelName:AC,backendName:"webgl",kernelFunc:function QIe(n){const{inputs:t,backend:e,attrs:r}=n,{x:i}=t,{blockSize:o,dataFormat:s}=r,a=i.shape[0],m=("NHWC"===s?i.shape[1]:i.shape[2])*o,g=("NHWC"===s?i.shape[2]:i.shape[3])*o,_=("NHWC"===s?i.shape[3]:i.shape[1])/(o*o),T=new ZIe("NHWC"===s?[a,m,g,_]:[a,_,m,g],o,s);return e.runWebGLProgram(T,[i],i.dtype)}};class oG{constructor(t,e=!1,r=null,i=!1,o=!1){this.variableNames=["x","W"],this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=t.outShape,this.enableShapeUniforms=Hi(this.outputShape.length);const s=t.filterHeight,a=t.filterWidth,c=t.outChannels/t.inChannels;let u="",p="";r&&(u=i?`float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ${r}\n        }`:o?`float activation(float a) {\n          float b = getLeakyreluAlphaAtOutCoords();\n          ${r}\n        }`:`\n          float activation(float x) {\n            ${r}\n          }\n        `,p="result = activation(result);");const m=e?"result += getBiasAtOutCoords();":"";e&&this.variableNames.push("bias"),i&&this.variableNames.push("preluActivationWeights"),o&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n      ${u}\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / ${c};\n        int q = d2 - d1 * ${c};\n\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.\n        for (int wR = 0; wR < ${s}; wR++) {\n          int xR = xRCorner + wR * dilations[0];\n\n          if (xR < 0 || xR >= inDims[0]) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${a}; wC++) {\n            int xC = xCCorner + wC * dilations[1];\n\n            if (xC < 0 || xC >= inDims[1]) {\n              continue;\n            }\n\n            float xVal = getX(batch, xR, xC, d1);\n            float wVal = getW(wR, wC, d1, q);\n            dotProd += xVal * wVal;\n          }\n        }\n\n        float result = dotProd;\n        ${m}\n        ${p}\n        setOutput(result);\n      }\n    `}}class sG{constructor(t,e=!1,r=null,i=!1,o=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=t.outShape,this.enableShapeUniforms=Hi(this.outputShape.length);const s=t.outChannels/t.inChannels,a=t.padInfo.left,c=t.strideWidth,u=t.dilationWidth,p=t.filterHeight,m=t.filterWidth,g=m;let _="\n      int xR; int xC; int xCOffset;\n      vec4 wTexel; vec4 previous; vec4 final;";for(let N=0;N<m;N++)_+=`\n          vec4 xTexelC${2*N};\n          int xTexelC${2*N}Ready;\n          vec4 xTexelC${2*N+1};\n          int xTexelC${2*N+1}Ready;\n          vec4 xC${N};`;_+=`\n    for (int r = 0; r < ${p}; r++) {\n      `;for(let N=0;N<m;N++)_+=`\n          xTexelC${2*N} = vec4(0.0);\n          xTexelC${2*N}Ready = 0;\n          xTexelC${2*N+1} = vec4(0.0);\n          xTexelC${2*N+1}Ready = 0;\n          xC${N} = vec4(0.0);`;_+="\n        xR = xRCorner + r * dilations[0];\n        if (xR >=0 && xR < inDims[0]) {\n      ";for(let N=0;N<(g+1)/2;N++){const R=2*N;if(_+=`\n          xC = xCCorner + ${R*u};\n          `,1===c){if(R<m&&(a%2==1?(_+=`\n                xCOffset = xC + 1;\n                if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${R}Ready == 0) {\n                  xTexelC${R} = getX(batch, xR, xCOffset, d1);\n\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC${R}.zw = vec2(0.0);\n                  }\n                  xTexelC${R}Ready = 1;\n                }\n              `,_+=1===u&&R>0?`\n                xC${R} = vec4(xTexelC${R-2}.zw, xTexelC${R}.xy);\n                `:`\n                  xCOffset = xC + 1 - 2;\n\n                  if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                    previous = getX(batch, xR, xCOffset, d1);\n\n                    // Need to manually clear unused channels in case\n                    // we're reading from recycled texture.\n                    if (xCOffset + 1 >= inDims[1]) {\n                      previous.zw = vec2(0.0);\n                    }\n\n                    xC${R} = vec4(previous.zw, xTexelC${R}.xy);\n                  } else {\n                    xC${R} = vec4(0.0, 0.0, xTexelC${R}.xy);\n                  }\n                  `):_+=`\n                if (xC >= 0 && xC < inDims[1] && xTexelC${R}Ready == 0) {\n                  xTexelC${R} = getX(batch, xR, xC, d1);\n                  if (xC + 1 >= inDims[1]) {\n                    xTexelC${R}.zw = vec2(0.0);\n                  }\n                  xTexelC${R}Ready = 1;\n                }\n\n                xC${R} = xTexelC${R};\n                `,R+1<m)){const L=a%2==0?lC(u):u;u%2==0&&a%2==1||u%2!=0&&a%2!=1?(_+=`\n                  xCOffset = xC + imod(pads[1], 2) + ${L};\n\n                  if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${R+1}Ready == 0) {\n                    xTexelC${R+1} = getX(batch, xR, xCOffset, d1);\n\n                    // Need to manually clear unused channels in case\n                    // we're reading from recycled texture.\n                    if (xCOffset + 1 >= inDims[1]) {\n                      xTexelC${R+1}.zw = vec2(0.0);\n                    }\n                    xTexelC${R+1}Ready = 1;\n                  }\n                  `,_+=u>1?`\n                    xCOffset -= 2;\n                    if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                     previous = getX(batch, xR, xCOffset, d1);\n                     xC${R+1} = vec4(previous.zw, xTexelC${R+1}.xy);\n                    } else {\n                     xC${R+1} = vec4(0.0, 0.0, xTexelC${R+1}.xy);\n                    }\n                    `:`\n                    xC${R+1} = vec4(xTexelC${R}.zw, xTexelC${R+1}.xy);\n                    `):_+=1===L?`\n                    xC${R+1} = xTexelC${R};\n                    `:`\n                    xCOffset = xC + ${L};\n\n                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${R+1}Ready == 0) {\n                      xTexelC${R+1} = getX(batch, xR, xCOffset, d1);\n                      if (xCOffset + 1 >= inDims[1]) {\n                        xTexelC${R+1}.zw = vec2(0.0);\n                      }\n                      xTexelC${R+1}Ready = 1;\n                    }\n\n                    xC${R+1} = xTexelC${R+1};\n                    `}}else R<m&&(a%2==1?(_+=`\n                xCOffset = xC + 1 - strides[1];\n                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${R}Ready == 0) {\n                  xTexelC${R} = getX(batch, xR, xCOffset, d1);\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC${R}.zw = vec2(0.0);\n                  }\n                  xTexelC${R}Ready = 1;\n                }\n\n                if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${R+1}Ready == 0) {\n                  xTexelC${R+1} = getX(batch, xR, xC + 1, d1);\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xC + 2 >= inDims[1]) {\n                    xTexelC${R+1}.zw = vec2(0.0);\n                  }\n                  xTexelC${R+1}Ready = 1;\n                }\n\n                xC${R} = vec4(xTexelC${R}.zw, xTexelC${R+1}.zw);\n              `,R+1<m&&(_+=`\n                  final = vec4(0.0);\n                  xCOffset = xC + 1 + strides[1];\n                  if(xCOffset >= 0 && xCOffset < inDims[1]) {\n                    final = getX(batch, xR, xCOffset, d1);\n                  }\n                  xC${R+1} = vec4(xTexelC${R+1}.xy, final.xy);\n                `)):(_+=`\n                if(xC >= 0 && xC < inDims[1] && xTexelC${R}Ready == 0) {\n                  xTexelC${R} = getX(batch, xR, xC, d1);\n                  if (xC + 1 >= inDims[1]) {\n                    xTexelC${R}.zw = vec2(0.0);\n                  }\n                  xTexelC${R}Ready = 1;\n                }\n\n                xCOffset = xC + strides[1];\n                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${R+1}Ready == 0) {\n                  xTexelC${R+1} = getX(batch, xR, xCOffset, d1);\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC${R+1}.zw = vec2(0.);\n                  }\n                  xTexelC${R+1}Ready = 1;\n                }\n\n                xC${R} = vec4(\n                  xTexelC${R}.xy, xTexelC${R+1}.xy);\n              `,R+1<m&&(_+=`\n                  xC${R+1} = vec4(xTexelC${R}.zw, xTexelC${R+1}.zw);\n                `)));R<m&&(_+=`\n            wTexel = getW(r, ${R}, d1, q);\n            dotProd += xC${R} * vec4(wTexel.xz, wTexel.xz);\n          `,R+1<m&&(_+=`\n              wTexel = getW(r, ${R+1}, d1, q);\n              dotProd += xC${R+1} * vec4(wTexel.xz, wTexel.xz);\n            `))}_+="\n    }\n  ",_+="\n      }\n    ";let x="",T="";r&&(x=i?`vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ${r}\n        }`:o?`vec4 activation(vec4 a) {\n          vec4 b = getLeakyreluAlphaAtOutCoords();\n          ${r}\n        }`:`vec4 activation(vec4 x) {\n          ${r}\n        }`,T="result = activation(result);");const I=e?"result += getBiasAtOutCoords();":"";e&&this.variableNames.push("bias"),i&&this.variableNames.push("preluActivationWeights"),o&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n      ${x}\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / ${s};\n        int q = d2 - d1 * ${s};\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.\n        vec4 dotProd = vec4(0.000000000000001);\n\n        ${_}\n\n        vec4 result = dotProd - vec4(0.000000000000001);\n        ${I}\n        ${T}\n        setOutput(result);\n      }\n    `}}const tEe={kernelName:q_,backendName:"webgl",kernelFunc:function eEe(n){const{inputs:t,backend:e,attrs:r}=n,{x:i,filter:o}=t,{strides:s,pad:a,dilations:c,dimRoundingMode:u}=r;let p=c;null==p&&(p=[1,1]),Z(Di(s,p),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${s} and dilations '${p}'`);const m=mi(i.shape,o.shape,s,p,a,u,!0);let g;return g=Ie().getBool("WEBGL_PACK_DEPTHWISECONV")&&m.strideWidth<=2&&m.outChannels/m.inChannels==1?new sG(m):new oG(m),e.runWebGLProgram(g,[i,o],"float32",[[m.padInfo.top,m.padInfo.left],[m.strideHeight,m.strideWidth],[m.dilationHeight,m.dilationWidth],[m.inHeight,m.inWidth]])}};class nEe{constructor(t){this.variableNames=["x","dy"],this.outputShape=t.filterShape,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int dm = coords.w;\n        int d2 = d1 * ${t.outChannels/t.inChannels} + dm;\n\n        float dotProd = 0.0;\n\n        // TO DO: Vec4 over the batch size\n        for (int b = 0; b < ${t.batchSize}; b++) {\n          for (int yR = 0; yR < ${t.outHeight}; yR++) {\n            int xR = wR + yR * ${t.strideHeight} - ${t.padInfo.top};\n\n            if (xR < 0 || xR >= ${t.inHeight}) {\n              continue;\n            }\n\n            for (int yC = 0; yC < ${t.outWidth}; yC++) {\n              int xC = wC + yC * ${t.strideWidth} - ${t.padInfo.left};\n\n              if (xC < 0 || xC >= ${t.inWidth}) {\n                continue;\n              }\n\n              float dyValue = getDy(b, yR, yC, d2);\n              float xValue = getX(b, xR, xC, d1);\n              dotProd += (xValue * dyValue);\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class rEe{constructor(t){this.variableNames=["dy","W"],this.outputShape=t.inShape;const e=t.filterHeight,r=t.filterWidth,c=t.outChannels/t.inChannels;this.userCode=`\n      const ivec2 pads = ivec2(${e-1-t.padInfo.top}, ${r-1-t.padInfo.left});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[3];\n        ivec2 dyCorner = coords.yz - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        float dotProd = 0.0;\n\n        for (int wR = 0; wR < ${e}; wR++) {\n          float dyR = float(dyRCorner + wR) / ${t.strideHeight}.0;\n\n          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ${e} - 1 - wR;\n\n          for (int wC = 0; wC < ${r}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${t.strideWidth}.0;\n\n            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ${r} - 1 - wC;\n\n            // TO DO: Vec4 over the channelMul\n            for (int dm = 0; dm < ${c}; dm++) {\n              int d2 = d1 * ${c} + dm;\n              float xValue = getDy(batch, idyR, idyC, d2);\n              float wValue = getW(wRPerm, wCPerm, d1, dm);\n              dotProd += xValue * wValue;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const oEe={kernelName:NC,backendName:"webgl",kernelFunc:function iEe(n){const{inputs:t,backend:e,attrs:r}=n,{x:i,dy:o}=t,{strides:s,dilations:a,pad:c,dimRoundingMode:u,filterShape:p}=r,m=mi(i.shape,p,s,a,c,u,!0),g=new nEe(m);return e.runWebGLProgram(g,[i,o],"float32")}},aEe={kernelName:OC,backendName:"webgl",kernelFunc:function sEe(n){const{inputs:t,backend:e,attrs:r}=n,{dy:i,filter:o}=t,{strides:s,dilations:a,pad:c,dimRoundingMode:u,inputShape:p}=r,m=mi(p,o.shape,s,a,c,u,!0),g=new rEe(m);return e.runWebGLProgram(g,[i,o],"float32")}};class lEe{constructor(t){this.variableNames=["X"],this.outputShape=[t,t],this.userCode="\n      void main() {\n          ivec2 coords = getOutputCoords();\n          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;\n          setOutput(val);\n      }\n    "}}const uEe={kernelName:RC,backendName:"webgl",kernelFunc:function cEe(n){const{inputs:t,backend:e}=n,{x:r}=t,i=[...r.shape,...r.shape],o=Me(r.shape),s=lt({inputs:{x:r},backend:e,attrs:{shape:[o]}}),a=new lEe(o),c=e.runWebGLProgram(a,[s],s.dtype),u=lt({inputs:{x:c},backend:e,attrs:{shape:i}});return e.disposeIntermediateTensorInfo(s),e.disposeIntermediateTensorInfo(c),u}};class dEe{constructor(t){this.variableNames=["x","W"],this.outputShape=t.outShape;const{inHeight:e,inWidth:r,padInfo:i,strideHeight:o,strideWidth:s,filterHeight:a,filterWidth:c,dilationHeight:u,dilationWidth:p}=t,{top:m,left:g}=i;this.userCode=`\n      const ivec2 strides = ivec2(${o}, ${s});\n      const ivec2 pads = ivec2(${m}, ${g});\n      const float neg_infinity = -3.4e38;\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.w;\n        ivec2 outTopLeftCorner =\n            coords.yz * strides - pads;\n        int hBeg = outTopLeftCorner.x;\n        int wBeg = outTopLeftCorner.y;\n\n        float curVal = neg_infinity;\n        for (int h = 0; h < ${a}; h++) {\n          int hIn = hBeg + h * ${u};\n\n          if (hIn >= 0 && hIn < ${e}) {\n            for (int w = 0; w < ${c}; w++) {\n              int wIn = wBeg + w * ${p};\n\n              if (wIn >= 0 && wIn < ${r}) {\n                float xVal = getX(batch, hIn, wIn, d1);\n                float wVal = getW(h, w, d1);\n\n                float val = xVal + wVal;\n                if (val > curVal) {\n                  curVal = val;\n                }\n              }\n            }\n          }\n        }\n\n        float result = curVal;\n        setOutput(result);\n      }\n    `}}const pEe={kernelName:K_,backendName:"webgl",kernelFunc:function hEe(n){const{inputs:t,backend:e,attrs:r}=n,{x:i,filter:o}=t,{strides:s,pad:a,dilations:c}=r,u=sg(i.shape,o.shape,s,a,"NHWC",c);let p;const m=new dEe(u);p=e.runWebGLProgram(m,[i,o],"float32");const g=lt({inputs:{x:p},backend:e,attrs:{shape:u.outShape}});return e.disposeIntermediateTensorInfo(p),g}},mEe={kernelName:PC,backendName:"webgl",kernelFunc:function fEe(n){const{inputs:t,backend:e,attrs:r}=n,{equation:i}=r,o=t,{allDims:s,summedDims:a,idDims:c}=fD(i,o.length);gD(s.length,c,o);const{path:u,steps:p}=bD(a,c),m=p.length;let g=null,_=s.length;const x=[];for(let T=0;T<m;++T){for(const I of p[T]){const{permutationIndices:N,expandDims:R}=mD(_,c[I]);let L;yD(N)?L=o[I]:(L=lo({inputs:{x:o[I]},backend:e,attrs:{perm:N}}),x.push(L));const V=L.shape.slice();for(let j=0;j<R.length;++j)V.splice(R[j],0,1);mn(L.shape,V)||(L=lt({inputs:{x:L},backend:e,attrs:{shape:V}}),x.push(L)),null===g?g=L:(g=Jk({inputs:{a:L,b:g},backend:e}),x.push(g))}T<m-1&&(u[T]>=0&&(g=_x({inputs:{x:g},backend:e,attrs:{axis:u[T]-(s.length-_),keepDims:!1}}),x.push(g)),_--)}for(const T of x)T!==g&&e.disposeIntermediateTensorInfo(T);return g}},gEe=Sn({opSnippet:"return (x >= 0.0) ? x : (exp(x) - 1.0);",packedOpSnippet:"\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n"}),bEe={kernelName:_m,backendName:"webgl",kernelFunc:gEe},vEe={kernelName:$C,backendName:"webgl",kernelFunc:n=>{const{inputs:t,backend:e}=n,{dy:r,y:i}=t,o=Ie().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Gg("\n  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));\n  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));\n",r.shape,i.shape):new op("return (b >= 0.0) ? a : a * (b + 1.0);",r.shape,i.shape);return e.runWebGLProgram(o,[r,i],r.dtype)}},xEe=Ni({opSnippet:"return float(a == b);",packedOpSnippet:"\n  return vec4(equal(a, b));\n",dtype:"bool",cpuKernelImpl:u1e}),wEe={kernelName:X_,backendName:"webgl",kernelFunc:xEe},SEe=Sn({opSnippet:`\n  // Error function is calculated approximately with elementary function.\n  // See "Handbook of Mathematical Functions with Formulas,\n  // Graphs, and Mathematical Tables", Abramowitz and Stegun.\n  float p = ${sD};\n  float a1 = ${aD};\n  float a2 = ${lD};\n  float a3 = ${cD};\n  float a4 = ${uD};\n  float a5 = ${dD};\n\n  float sign = sign(x);\n  x = abs(x);\n  float t = 1.0 / (1.0 + p * x);\n  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));\n`}),CEe={kernelName:vm,backendName:"webgl",kernelFunc:SEe},aG=Sn({opSnippet:sp+"\n  return exp(x);\n",packedOpSnippet:"\n  vec4 result = exp(x);\n  bvec4 isNaN = isnan(x);\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",cpuKernelImpl:d1e,dtype:"float32"}),EEe={kernelName:xm,backendName:"webgl",kernelFunc:aG};function rA(n){const{inputs:t,attrs:e,backend:r}=n,{dim:i}=e,{input:o}=t,s=o.shape.length,a=o.shape.slice();let c=i;return i<0&&(Z(-(s+1)<=i,()=>`Axis must be in the interval [${-(s+1)}, ${s}]`),c=s+i+1),a.splice(c,0,1),lt({inputs:{x:o},backend:r,attrs:{shape:a}})}const DEe={kernelName:Y_,backendName:"webgl",kernelFunc:rA},lG="return exp(x) - 1.0;",kEe=Sn({opSnippet:lG,packedOpSnippet:lG,cpuKernelImpl:h1e}),AEe={kernelName:wm,backendName:"webgl",kernelFunc:kEe};class cG{constructor(t,e,r){this.variableNames=["real","imag"];const i=e[1];this.outputShape=e;const o=r?`2.0 * ${Math.PI}`:`-2.0 * ${Math.PI}`,s=r?`${i}.0`:"1.0";let a;if("real"===t)a="return real * expR - imag * expI;";else{if("imag"!==t)throw new Error(`FFT component must be either "real" or "imag", got ${t}.`);a="return real * expI + imag * expR;"}this.userCode=`\n      const float exponentMultiplier = ${o};\n\n      float unaryOpComplex(float real, float expR, float imag, float expI) {\n        ${a}\n      }\n\n      float mulMatDFT(int batch, int index) {\n        float indexRatio = float(index) / float(${i});\n        float exponentMultiplierTimesIndexRatio =\n            exponentMultiplier * indexRatio;\n\n        float result = 0.0;\n\n        for (int i = 0; i < ${i}; i++) {\n          // x = (-2|2 * PI / N) * index * i;\n          float x = exponentMultiplierTimesIndexRatio * float(i);\n          float expR = cos(x);\n          float expI = sin(x);\n          float real = getReal(batch, i);\n          float imag = getImag(batch, i);\n\n          result +=\n              unaryOpComplex(real, expR, imag, expI) / ${s};\n        }\n\n        return result;\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        setOutput(mulMatDFT(coords[0], coords[1]));\n      }\n    `}}function uG(n,t,e){const r=e.texData.get(n.dataId),i=Me(n.shape),o=n.shape[n.shape.length-1],a=lt({inputs:{x:n},backend:e,attrs:{shape:[i/o,o]}}),c=a.shape,u=new cG("real",c,t),p=new cG("imag",c,t),m=[{dataId:r.complexTensorInfos.real.dataId,dtype:r.complexTensorInfos.real.dtype,shape:c},{dataId:r.complexTensorInfos.imag.dataId,dtype:r.complexTensorInfos.imag.dtype,shape:c}],g=e.runWebGLProgram(u,m,"float32"),_=e.runWebGLProgram(p,m,"float32"),x=Vc({inputs:{real:g,imag:_},backend:e});e.disposeIntermediateTensorInfo(g),e.disposeIntermediateTensorInfo(_);const T=lt({inputs:{x},backend:e,attrs:{shape:n.shape}});return e.disposeIntermediateTensorInfo(a),e.disposeIntermediateTensorInfo(x),T}const OEe={kernelName:"FFT",backendName:"webgl",kernelFunc:function NEe(n){const{inputs:t,backend:e}=n,{input:r}=t;return uG(r,!1,e)}};class REe{constructor(t,e){this.outputShape=[],this.customUniforms=[{name:"value",type:"float"}],this.variableNames=["x"],this.outputShape=t,this.userCode="\n      void main() {\n        // Input can be obtained from uniform value.\n        setOutput(value);\n      }\n    "}}function Xg(n){const{backend:t,attrs:e}=n,{shape:r,value:i}=e;let{dtype:o}=e;if(o=o||_h(i),"string"===o){const s=Or(o,Me(r));return s.fill(i),t.makeTensorInfo(r,o,s)}{const s=new REe(r,i);return t.runWebGLProgram(s,[],o,[[i]])}}const MEe={kernelName:BC,backendName:"webgl",kernelFunc:Xg};class FEe{constructor(t){this.variableNames=["Image"],this.outputShape=[];const e=t[2];this.outputShape=t,this.userCode=`\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int x = coords[2];\n\n          int coordX = ${e} - x - 1;\n          float outputValue;\n          if(coordX >= 0 && coordX < ${e}) {\n            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);\n          } else {\n            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);\n          }\n          setOutput(outputValue);\n        }\n    `}}const PEe={kernelName:VC,backendName:"webgl",kernelFunc:({inputs:n,backend:t})=>{const{image:e}=n,r=t,i=new FEe(e.shape);return r.runWebGLProgram(i,[e],e.dtype)}},dG="return floor(x);",$Ee=Sn({opSnippet:dG,packedOpSnippet:dG,cpuKernelImpl:p1e}),LEe={kernelName:Tm,backendName:"webgl",kernelFunc:$Ee},BEe=Ni({opSnippet:"\n  float s = sign(a) * sign(b);\n  int ia = round(a);\n  int ib = round(b);\n  if (ib != 0) {\n    // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n    return float(idiv(ia, ib, s));\n  } else {\n    return NAN;\n  }\n",packedOpSnippet:"\n  ivec4 ia = round(a);\n  ivec4 ib = round(b);\n  bvec4 cond = notEqual(ib, ivec4(0));\n  ivec4 result = ivec4(0);\n  vec4 s = sign(a) * sign(b);\n\n  // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n  if (cond[0]) {\n    result[0] = idiv(ia[0], ib[0], s[0]);\n  }\n  if (cond[1]) {\n    result[1] = idiv(ia[1], ib[1], s[1]);\n  }\n  if (cond[2]) {\n    result[2] = idiv(ia[2], ib[2], s[2]);\n  }\n  if (cond[3]) {\n    result[3] = idiv(ia[3], ib[3], s[3]);\n  }\n  return vec4(result);\n",dtype:"int32"}),VEe={kernelName:Sm,backendName:"webgl",kernelFunc:BEe};class zEe{constructor(t){this.variableNames=["A"];const e=so(),[r,i]=t;this.outputShape=t,this.userCode=`\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${i}.0, ${r}.0);\n\n        vec4 values = ${e.texture2D}(A, uv);\n        float value;\n        if (depth == 0) {\n          value = values.r;\n        } else if (depth == 1) {\n          value = values.g;\n        } else if (depth == 2) {\n          value = values.b;\n        } else if (depth == 3) {\n          value = values.a;\n        }\n\n        setOutput(floor(value * 255.0 + 0.5));\n      }\n    `}}class UEe{constructor(t){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;const e=so(),[r,i]=t;this.outputShape=t,this.userCode=`\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n\n        vec4 result = vec4(0.);\n\n        for(int row=0; row<=1; row++) {\n          for(int col=0; col<=1; col++) {\n            texC = coords[1] + row;\n            depth = coords[2] + col;\n\n            vec2 uv = (vec2(texC, texR) + halfCR) /\n                       vec2(${i}.0, ${r}.0);\n            vec4 values = ${e.texture2D}(A, uv);\n            float value;\n            if (depth == 0) {\n              value = values.r;\n            } else if (depth == 1) {\n              value = values.g;\n            } else if (depth == 2) {\n              value = values.b;\n            } else if (depth == 3) {\n              value = values.a;\n            }\n\n            result[row * 2 + col] = floor(value * 255.0 + 0.5);\n          }\n        }\n\n        ${e.output} = result;\n      }\n    `}}const jEe={kernelName:"FromPixels",backendName:"webgl",kernelFunc:function GEe(n){const{inputs:t,backend:e,attrs:r}=n;let{pixels:i}=t;const{numChannels:o}=r,s=typeof HTMLVideoElement<"u"&&i instanceof HTMLVideoElement,a=typeof HTMLImageElement<"u"&&i instanceof HTMLImageElement,[c,u]=s?[i.videoWidth,i.videoHeight]:[i.width,i.height],p=[u,c],m=[u,c,o];if(a||s){const T=Ie().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");(null==lp||T!==iA)&&(iA=T,lp=document.createElement("canvas").getContext("2d",{willReadFrequently:iA})),lp.canvas.width=c,lp.canvas.height=u,lp.drawImage(i,0,0,c,u),i=lp.canvas}const g=e.makeTensorInfo(p,"int32");e.texData.get(g.dataId).usage=$r.PIXELS,e.gpgpu.uploadPixelDataToTexture(e.getTexture(g.dataId),i);const _=Ie().getBool("WEBGL_PACK")?new UEe(m):new zEe(m),x=e.runWebGLProgram(_,[g],"int32");return e.disposeData(g.dataId),x}};let lp,iA=Ie().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");const WEe={kernelName:$0,backendName:"webgl",kernelFunc:function HEe(n){const{inputs:t,backend:e,attrs:r}=n,{x:i,filter:o,bias:s,preluActivationWeights:a}=t,{strides:c,pad:u,dataFormat:p,dilations:m,dimRoundingMode:g,activation:_,leakyreluAlpha:x}=r,T=Tl(p),I=mi(i.shape,o.shape,c,m,u,g,!1,T);let N;const R=[],L=null!=s,V=null!=a,j="leakyrelu"===_,Y=()=>{const ie=[i,o],ce=(he,we)=>{if("NCHW"===we&&1===he.shape.length&&1!==he.shape[0]){const Ee=lt({inputs:{x:he},backend:e,attrs:{shape:[he.shape[0],1,1]}});return R.push(Ee),Ee}return he};if(L&&ie.push(ce(s,p)),V&&ie.push(ce(a,p)),j){const he=e.makeTensorInfo([],"float32",lc(x,"float32"));ie.push(he),R.push(he)}return ie};if(1!==I.filterHeight||1!==I.filterWidth||1!==I.dilationHeight||1!==I.dilationWidth||1!==I.strideHeight||1!==I.strideWidth||"SAME"!==I.padInfo.type&&"VALID"!==I.padInfo.type)if(I.strideWidth<=2&&"channelsLast"===T&&Ie().getBool("WEBGL_EXP_CONV")){const ie=_?Hg(_,!0):null,ce=new Qj(I,L,ie,V,j),he=[[I.padInfo.top,I.padInfo.left],[I.strideHeight,I.strideWidth],[I.dilationHeight,I.dilationWidth],[I.inHeight,I.inWidth]],we=Y();N=e.runWebGLProgram(ce,we,"float32",he)}else if(Ie().getBool("WEBGL_CONV_IM2COL"))N=eG({x:i,filter:o,convInfo:I,backend:e,bias:s,activation:_,preluActivationWeights:a,leakyreluAlpha:x});else{const ie=_?Hg(_,!1):null,ce=new Zj(I,L,ie,V,j),he=Y();N=e.runWebGLProgram(ce,he,"float32")}else N=Jj({x:i,filter:o,convInfo:I,backend:e,bias:s,activation:_,preluActivationWeights:a,leakyreluAlpha:x});const ee=lt({inputs:{x:N},backend:e,attrs:{shape:I.outShape}});return R.push(N),R.forEach(ie=>e.disposeIntermediateTensorInfo(ie)),ee}},KEe={kernelName:L0,backendName:"webgl",kernelFunc:function qEe(n){const{inputs:t,backend:e,attrs:r}=n,{x:i,filter:o,bias:s,preluActivationWeights:a}=t,{strides:c,pad:u,dilations:p,dimRoundingMode:m,activation:g,leakyreluAlpha:_}=r,x=[];let T=p;null==T&&(T=[1,1]),Z(Di(c,T),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${c} and dilations '${T}'`);const I=mi(i.shape,o.shape,c,T,u,m,!0),N=Ie().getBool("WEBGL_PACK_DEPTHWISECONV")&&I.strideWidth<=2&&I.outChannels/I.inChannels==1,R=g?Hg(g,N):null,L=[i,o],V=null!=s,j=null!=a,Y="leakyrelu"===g;if(V&&L.push(s),j&&L.push(a),Y){const he=e.makeTensorInfo([],"float32",lc(_,"float32"));L.push(he),x.push(he)}let ee;ee=N?new sG(I,V,R,j,Y):new oG(I,V,R,j,Y);const ce=e.runWebGLProgram(ee,L,"float32",[[I.padInfo.top,I.padInfo.left],[I.strideHeight,I.strideWidth],[I.dilationHeight,I.dilationWidth],[I.inHeight,I.inWidth]]);return x.forEach(he=>e.disposeIntermediateTensorInfo(he)),ce}};class XEe{constructor(t,e,r,i){this.sliceDim=t,this.strides=e,this.paramsShape=i,this.variableNames=["x","indices"],this.outputShape=r;const o=jn(r.length);let s="\n    int index;";for(let a=0;a<this.sliceDim;a++)s+=`\n          index = round(getIndices(coords[0], ${a}));\n          out_of_bounds = out_of_bounds || index < 0;\n          out_of_bounds = out_of_bounds || index >= ${this.paramsShape[a]};\n          flattenIndex += index * ${this.strides[a]};`;this.userCode=`\n         void main() {\n          ${o} coords = getOutputCoords();\n          int flattenIndex = 0;\n          bool out_of_bounds = false;\n\n          ${s}\n\n          setOutput(out_of_bounds ? 0.0 : getX(flattenIndex, coords[1]));\n        }\n      `}}const ZEe={kernelName:zC,backendName:"webgl",kernelFunc:function YEe(n){const{inputs:t,backend:e}=n,{params:r,indices:i}=t,o=i.shape,s=o[o.length-1],a=Me(r.shape),[c,u,p,m]=oD(r,i),g=lt({inputs:{x:i},backend:e,attrs:{shape:[u,s]}}),_=lt({inputs:{x:r},backend:e,attrs:{shape:[Me(r.shape)/p,p]}});if(e.shouldExecuteOnCPU([r,i])||"string"===r.dtype){const N=e.readSync(i.dataId),R=e.bufferSync(r),L=f1e(N,R,r.dtype,u,s,p,m,r.shape,a);return e.makeTensorInfo(c,r.dtype,L.values)}const x=new XEe(s,m,[u,p],r.shape),T=e.runWebGLProgram(x,[_,g],_.dtype),I=lt({inputs:{x:T},backend:e,attrs:{shape:c}});return e.disposeIntermediateTensorInfo(g),e.disposeIntermediateTensorInfo(_),e.disposeIntermediateTensorInfo(T),I}};class QEe{constructor(t,e){this.variableNames=["A","indices"],this.outputShape=e,this.rank=e.length;const r=jn(this.rank),i=function JEe(n,t){const e=["resRC.x","resRC.y","resRC.z","resRC.w"],r=[];for(let i=0;i<n.length;i++)r.push(2===i?"index":`${e[i]}`);return r.join()}(t);this.userCode=`\n      void main() {\n        ${r} resRC = getOutputCoords();\n        int index = int(getIndices(resRC.x, resRC.z));\n        float inBounds = (index >= 0) && (index < ${t[2]}) ? 1.0 : 0.0;\n        setOutput(inBounds * getA(${i}));\n      }\n    `}}function hG(n){const{inputs:t,backend:e,attrs:r}=n,{x:i,indices:o}=t,{axis:s,batchDims:a}=r,c=cn(s,i.shape)[0];if(Ie().get("DEBUG")){const R=e.readSync(o.dataId),L=i.shape[c];for(let V=0;V<R.length;++V){const j=R[V];Z(j<=L-1&&j>=0,()=>`GatherV2: the index value ${j} is not in [0, ${L-1}]`)}}const u=xD(i,o,c,a),p=Me(o.shape),m=[],g=lt({inputs:{x:i},backend:e,attrs:{shape:[u.batchSize,u.outerSize,u.dimSize,u.sliceSize]}}),_=lt({inputs:{x:o},backend:e,attrs:{shape:[u.batchSize,p/u.batchSize]}});m.push(g),m.push(_);const x=[u.batchSize,u.outerSize,p/u.batchSize,u.sliceSize];if(e.shouldExecuteOnCPU([i,o])||"string"===i.dtype){const R=e.bufferSync(_),L=e.bufferSync(g),V=m1e(L,R,x);return m.forEach(j=>e.disposeIntermediateTensorInfo(j)),e.makeTensorInfo(u.outputShape,V.dtype,V.values)}const T=new QEe(g.shape,x),I=e.runWebGLProgram(T,[g,_],g.dtype);m.push(I);const N=lt({inputs:{x:I},backend:e,attrs:{shape:u.outputShape}});return m.forEach(R=>e.disposeIntermediateTensorInfo(R)),N}const eDe={kernelName:Q_,backendName:"webgl",kernelFunc:hG},tDe=Ni({opSnippet:"return float(a > b);",packedOpSnippet:"\n  return vec4(greaterThan(a, b));\n",cpuKernelImpl:g1e,dtype:"bool"}),nDe={kernelName:J_,backendName:"webgl",kernelFunc:tDe},rDe=Ni({opSnippet:"return float(a >= b);",packedOpSnippet:"\n  return vec4(greaterThanEqual(a, b));\n",dtype:"bool",cpuKernelImpl:b1e}),iDe={kernelName:Cm,backendName:"webgl",kernelFunc:rDe},sDe={kernelName:UC,backendName:"webgl",kernelFunc:function oDe(n){const{inputs:t,backend:e}=n,{input:r}=t;return uG(r,!0,e)}},aDe=Sn({opSnippet:"return float(!isnan(x) && !isinf(x));",dtype:"bool"}),lDe={kernelName:Em,backendName:"webgl",kernelFunc:aDe},cDe=Sn({opSnippet:"return float(isinf(x));",dtype:"bool"}),uDe={kernelName:Dm,backendName:"webgl",kernelFunc:cDe},dDe=Sn({opSnippet:"return float(isnan(x));",dtype:"bool"}),hDe={kernelName:km,backendName:"webgl",kernelFunc:dDe},pDe=Ni({opSnippet:"return float(a < b);",packedOpSnippet:"\n  return vec4(lessThan(a, b));\n",cpuKernelImpl:y1e,dtype:"bool"}),fDe={kernelName:t0,backendName:"webgl",kernelFunc:pDe},mDe=Ni({opSnippet:"return float(a <= b);",packedOpSnippet:"\n  return vec4(lessThanEqual(a, b));\n",cpuKernelImpl:_1e,dtype:"bool"}),gDe={kernelName:n0,backendName:"webgl",kernelFunc:mDe},yDe={kernelName:GC,backendName:"webgl",kernelFunc:function bDe(n){const{backend:t,attrs:e}=n,{start:r,stop:i,num:o}=e,s=v1e(r,i,o);return t.makeTensorInfo([s.length],"float32",s)}},vDe=Sn({opSnippet:sp+"\n  return x < 0.0 ? 0./0. : log(x);\n",packedOpSnippet:"\n  vec4 result = log(x);\n  bvec4 isNaN = isnan(x);\n  result.r = isNaN.r ? x.r : (x.r < 0.0 ? 0./0. : result.r);\n  result.g = isNaN.g ? x.g : (x.g < 0.0 ? 0./0. : result.g);\n  result.b = isNaN.b ? x.b : (x.b < 0.0 ? 0./0. : result.b);\n  result.a = isNaN.a ? x.a : (x.a < 0.0 ? 0./0. : result.a);\n  return result;\n",cpuKernelImpl:x1e}),xDe={kernelName:Am,backendName:"webgl",kernelFunc:vDe},TDe=Sn({opSnippet:sp+"\n  return log(1.0 + x);\n"}),SDe={kernelName:Nm,backendName:"webgl",kernelFunc:TDe},CDe=Ni({opSnippet:"return float(a >= 1.0 && b >= 1.0);",packedOpSnippet:"\n  return vec4(\n    vec4(greaterThanEqual(a, vec4(1.0))) *\n    vec4(greaterThanEqual(b, vec4(1.0))));\n",dtype:"bool"}),IDe={kernelName:r0,backendName:"webgl",kernelFunc:CDe},EDe=Sn({opSnippet:"return float(!(x >= 1.0));"}),DDe={kernelName:o0,backendName:"webgl",kernelFunc:EDe},kDe=Ni({opSnippet:"return float(a >= 1.0 || b >= 1.0);",packedOpSnippet:"\n  return min(\n    vec4(greaterThanEqual(a, vec4(1.0))) +\n    vec4(greaterThanEqual(b, vec4(1.0))),\n    vec4(1.0));\n",dtype:"bool"}),ADe={kernelName:s0,backendName:"webgl",kernelFunc:kDe};class NDe{constructor(t,e,r,i,o){this.variableNames=["x"],this.outputShape=[];const s=e,a=t[3]-1;let c;this.outputShape=t;const u=`float(${r}) + float(${i}) * sum`;c=.5===o?`inversesqrt(${u})`:1===o?`1.0/(${u})`:`exp(log(${u}) * float(-${o}));`,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n        int d = coords[3];\n        float x = getX(b, r, c, d);\n        float sum = 0.0;\n        for (int j = -${s}; j <= ${s}; j++) {\n          int idx = d + j;\n          if (idx >= 0 && idx <=  ${a}) {\n            float z = getX(b, r, c, idx);\n            sum += z * z;\n          }\n        }\n        float val = x * ${c};\n        setOutput(val);\n      }\n    `}}class ODe{constructor(t,e,r,i,o){this.variableNames=["x"],this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0;const s=e,a=t[3]-1;let c;this.outputShape=t;const u=`float(${r}) + float(${i}) * sum`;c=.5===o?`inversesqrt(${u})`:1===o?`1.0/(${u})`:`exp(log(${u}) * float(-${o}));`,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords.x;\n        int r = coords.y;\n        int c = coords.z;\n        int d = coords.w;\n\n        bool hasNextCol = d < ${this.outputShape[3]};\n        bool hasNextRow = c < ${this.outputShape[2]};\n\n        vec4 sum = vec4(0.);\n        vec4 xFragAtOutputCoords = getX(b, r, c, d);\n\n        vec4 xAtOutputCoords = vec4(\n          getChannel(xFragAtOutputCoords, vec2(c, d)),\n          hasNextCol ?\n            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,\n          hasNextRow ?\n            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0\n        );\n\n        int firstChannel = d - ${s};\n        vec2 cache = vec2(0.);\n        if(firstChannel >= 0){\n          vec4 firstChannelFrag = getX(b, r, c, firstChannel);\n          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));\n            if(hasNextRow){\n              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));\n            }\n        }\n\n        ivec2 depth = ivec2(d, d + 1);\n        for (int j = - ${s}; j <= ${s}; j++) {\n          ivec2 idx = depth + j;\n          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));\n          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(${a}));\n\n          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;\n          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;\n\n          if(depthInRange || depthPlusOneInRange){\n            vec4 z = vec4(0.);\n            vec4 xFragAtCurrentDepth;\n            z.xz = cache.xy;\n            if(depthPlusOneInRange && hasNextCol){\n              xFragAtCurrentDepth = idx.y != d ?\n                getX(b, r, c, idx.y) : xFragAtOutputCoords;\n              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));\n              if(hasNextRow){\n                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));\n              }\n            }\n            cache.xy = z.yw;\n            sum += z * z;\n          }\n        }\n        vec4 result = xAtOutputCoords * ${c};\n        setOutput(result);\n      }\n    `}}const RDe={kernelName:a0,backendName:"webgl",kernelFunc:n=>{const{inputs:t,backend:e,attrs:r}=n,{x:i}=t,{depthRadius:o,bias:s,alpha:a,beta:c}=r,u=Ie().getBool("WEBGL_PACK_NORMALIZATION")?new ODe(i.shape,o,s,a,c):new NDe(i.shape,o,s,a,c);return e.runWebGLProgram(u,[i],i.dtype)}};class MDe{constructor(t,e,r,i,o){this.variableNames=["inputImage","outputImage","dy"],this.outputShape=[],this.outputShape=t,this.depth=t[3],this.depthRadius=e,this.bias=r,this.alpha=i,this.beta=o,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n\n        float result = 0.0;\n        for (int d = 0; d < ${this.depth}; ++d) {\n          int depthBegin = int(max(0.0, float(d - ${e})));\n          int depthEnd = int(min(float(${this.depth}),\n              float(d + ${e} + 1)));\n\n          const int MIN_DEPTH_BEGIN = 0;\n          const int MAX_DEPTH_END = ${this.depth};\n\n          float norm = 0.0;\n          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd) {\n              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);\n            }\n            else {\n              break;\n            }\n          }\n\n          norm = float(${i}) * norm + float(${r});\n\n          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd){\n              float dyi = -2.0 * float(${i})\n                * float(${o})\n                * getInputImage(b, r, c, k) * getOutputImage(b, r, c, d)\n                / norm;\n              if (k == d) {\n                dyi += pow(norm, -1.0 * ${o});\n              }\n              if (k == coords[3]) {\n                dyi *= getDy(b, r, c, d);\n                result += dyi;\n              }\n            }\n            else {\n              break;\n            }\n          }\n      }\n      setOutput(result);\n      }\n    `}}const FDe={kernelName:HC,backendName:"webgl",kernelFunc:n=>{const{inputs:t,backend:e,attrs:r}=n,{x:i,y:o,dy:s}=t,{depthRadius:a,bias:c,alpha:u,beta:p}=r,m=new MDe(i.shape,a,c,u,p);return e.runWebGLProgram(m,[i,o,s],i.dtype)}};function pG(n){const{inputs:t,backend:e,attrs:r}=n,{x:i}=t,{reductionIndices:o,keepDims:s}=r,a=i.shape.length,c=cn(o,i.shape);let u=c;const p=hr(u,a),m=null!=p,g=e.shouldExecuteOnCPU([i]);let _=i;if(m){if(g){const L=e.texData.get(_.dataId).values,V=new Array(a);for(let ee=0;ee<V.length;ee++)V[ee]=i.shape[p[ee]];const j=Zk(L,i.shape,i.dtype,p,V);_=e.makeTensorInfo(V,i.dtype),e.texData.get(_.dataId).values=j}else _=yx(i,p,e);u=Mr(u.length,a)}ki("max",u,a);const[x,T]=gi(_.shape,u);let N,I=x;if(s&&(I=Rr(x,c)),g){const L=e.texData.get(_.dataId).values,V=w1e(L,Me(T),I,i.dtype);N=e.makeTensorInfo(I,i.dtype),e.texData.get(N.dataId).values=V}else N=function PDe(n,t,e,r){const i=Me(t),a=lt({inputs:{x:n},attrs:{shape:[Me(n.shape)/i,i]},backend:r}),c=Ju(a,n.dtype,"max",r),u=lt({inputs:{x:c},attrs:{shape:e},backend:r});return r.disposeIntermediateTensorInfo(a),r.disposeIntermediateTensorInfo(c),u}(_,T,I,e);return m&&e.disposeIntermediateTensorInfo(_),N}const $De={kernelName:l0,backendName:"webgl",kernelFunc:pG},VDe=Ni({opSnippet:Qk+"\n  return max(a, b);\n",packedOpSnippet:"\n  vec4 result = vec4(max(a, b));\n  bvec4 isNaNA = isnan(a);\n  bvec4 isNaNB = isnan(b);\n  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);\n  "+Qu+"\n  return result;\n",cpuKernelImpl:T1e}),zDe={kernelName:Om,backendName:"webgl",kernelFunc:VDe},jDe={kernelName:c0,backendName:"webgl",kernelFunc:function UDe(n){const{inputs:t,backend:e,attrs:r}=n,{x:i}=t;Ug(i,"maxPool");const{filterSize:o,strides:s,pad:a,dimRoundingMode:c}=r;Z(Di(s,1),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${s} and dilations '1'`);const p=Rs(i.shape,o,s,1,a,c);if(1===p.filterWidth&&1===p.filterHeight&&mn(p.inShape,p.outShape))return qo({inputs:{x:i},backend:e});const m=new Wg(p,"max",!1);return e.runWebGLProgram(m,[i],i.dtype)}},HDe={kernelName:u0,backendName:"webgl",kernelFunc:function GDe(n){const{inputs:t,backend:e,attrs:r}=n,{x:i}=t,{filterSize:o,strides:s,pad:a,dataFormat:c,dimRoundingMode:u}=r,m=wl(i.shape,o,s,[1,1,1],a,u,c),g=new eA(m,"max",!1);return e.runWebGLProgram(g,[i],i.dtype)}};class WDe{constructor(t){this.variableNames=["dy","maxPos"],this.outputShape=t.inShape;const o=t.effectiveFilterHeight,s=t.effectiveFilterWidth;this.userCode=`\n      const ivec2 pads = ivec2(${o-1-t.padInfo.top}, ${s-1-t.padInfo.left});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${o};\n          wR += ${t.dilationHeight}) {\n          float dyR = float(dyRCorner + wR) / ${t.strideHeight}.0;\n\n          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ${s}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${t.strideWidth}.0;\n\n            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n            int maxPosValue = ${o*s-1} - int(getMaxPos(b, idyR, idyC, d));\n\n            // Get the current value, check it against the value from the\n            // position matrix.\n            int curPosValue = wR * ${s} + wC;\n            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n            dotProd += dyValue * mask;\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class qDe{constructor(t){this.variableNames=["dy","maxPos"],this.outputShape=t.inShape;const c=t.effectiveFilterDepth,u=t.effectiveFilterHeight,p=t.effectiveFilterWidth;this.userCode=`\n      const ivec3 pads = ivec3(${c-1-t.padInfo.front}, ${u-1-t.padInfo.top}, ${p-1-t.padInfo.left});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ${c};\n           wD += ${t.dilationDepth}) {\n          float dyD = float(dyDCorner + wD) / ${t.strideDepth}.0;\n\n          if (dyD < 0.0 || dyD >= ${t.outDepth}.0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ${u};\n              wR += ${t.dilationHeight}) {\n            float dyR = float(dyRCorner + wR) / ${t.strideHeight}.0;\n\n            if (dyR < 0.0 || dyR >= ${t.outHeight}.0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ${p};\n                wC += ${t.dilationWidth}) {\n              float dyC = float(dyCCorner + wC) / ${t.strideWidth}.0;\n\n              if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n              int maxPosValue = ${c*u*p-1} -\n                  int(getMaxPos(batch, idyD, idyR, idyC, ch));\n\n              // Get the current value, check it against the value from the\n              // position matrix.\n              int curPosValue =\n                  wD * ${u} * ${p} +\n                  wR * ${p} + wC;\n              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n              dotProd += dyValue * mask;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const XDe={kernelName:qC,backendName:"webgl",kernelFunc:function KDe(n){const{inputs:t,backend:e,attrs:r}=n,{dy:i,input:o}=t,s=o,{filterSize:a,strides:c,pad:u,dimRoundingMode:p}=r,g=wl(s.shape,a,c,[1,1,1],u,p),_=new eA(g,"max",!0),x=e.runWebGLProgram(_,[s],s.dtype),T=new qDe(g),I=e.runWebGLProgram(T,[i,x],s.dtype);return e.disposeIntermediateTensorInfo(x),I}},ZDe={kernelName:WC,backendName:"webgl",kernelFunc:function YDe(n){const{inputs:t,backend:e,attrs:r}=n,{dy:i,input:o,output:s}=t,a=o;Ug([o,s],"maxPoolGrad");const{filterSize:c,strides:u,pad:p,dimRoundingMode:m}=r,g=Rs(a.shape,c,u,1,p,m),x=new Wg(g,"max",!0),T=e.runWebGLProgram(x,[a],a.dtype),I=new WDe(g),N=e.runWebGLProgram(I,[i,T],a.dtype);return e.disposeIntermediateTensorInfo(T),N}},JDe={kernelName:KC,backendName:"webgl",kernelFunc:({inputs:n,attrs:t,backend:e})=>{const{x:r}=n,{filterSize:i,strides:o,pad:s,includeBatchInIndex:a}=t,c=e;Z(4===r.shape.length,()=>`Error in maxPool: input must be rank 4 but got rank ${r.shape.length}.`);const u=[1,1];Z(Di(o,u),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${o} and dilations '${u}'`);const p=Rs(r.shape,i,o,u,s),[m,g]=function QDe(n,t,e,r){let i=new Wg(e,"max",!1);const o=r.runWebGLProgram(i,[n],"float32");return i=new Wg(e,"max",!0,!0,t),[o,r.runWebGLProgram(i,[n],"float32")]}(r,a,p,c);return[m,g]}},tke={kernelName:d0,backendName:"webgl",kernelFunc:({inputs:n,attrs:t,backend:e})=>{const{x:r}=n,{keepDims:i,axis:o}=t,s=e,a=r.shape.length,c=cn(o,r.shape);let u=c;const p=hr(u,a),m=null!=p,g=s.shouldExecuteOnCPU([r]),_=[];let x=r;if(m){if(g){const V=s.texData.get(x.dataId).values,j=new Array(a);for(let ie=0;ie<j.length;ie++)j[ie]=r.shape[p[ie]];const Y=Zk(V,r.shape,r.dtype,p,j);x=s.makeTensorInfo(j,r.dtype),s.texData.get(x.dataId).values=Y}else x=yx(r,p,s);_.push(x),u=Mr(u.length,a)}ki("sum",u,a);const[T,I]=gi(x.shape,u);let N=T;i&&(N=Rr(T,c));const R=function eke(n,t,e,r){const i=Me(t),a=lt({inputs:{x:n},attrs:{shape:[Me(n.shape)/i,i]},backend:r}),c=Ju(a,"float32","mean",r),u=lt({inputs:{x:c},attrs:{shape:e},backend:r});return r.disposeIntermediateTensorInfo(a),r.disposeIntermediateTensorInfo(c),u}(x,I,N,s);for(const L of _)s.disposeIntermediateTensorInfo(L);return R}},rke={kernelName:h0,backendName:"webgl",kernelFunc:function nke(n){const{inputs:t,backend:e,attrs:r}=n,{x:i}=t,{axis:o,keepDims:s}=r,a=i.shape.length,c=cn(o,i.shape);let u=c;const p=hr(u,a);let m=i;null!=p&&(m=lo({inputs:{x:i},backend:e,attrs:{perm:p}}),u=Mr(u.length,i.shape.length)),ki("min",u,a);const[g,_]=gi(m.shape,u),T=lt({inputs:{x:m},backend:e,attrs:{shape:[-1,Me(_)]}}),I=Ju(T,T.dtype,"min",e);let N;return N=lt(s?{inputs:{x:I},backend:e,attrs:{shape:Rr(g,c)}}:{inputs:{x:I},backend:e,attrs:{shape:g}}),e.disposeIntermediateTensorInfo(T),e.disposeIntermediateTensorInfo(I),null!=p&&e.disposeIntermediateTensorInfo(m),N}},ske=Ni({opSnippet:Qk+"\n  return min(a, b);\n",packedOpSnippet:"\n  vec4 result = vec4(min(a, b));\n  bvec4 isNaNA = isnan(a);\n  bvec4 isNaNB = isnan(b);\n  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);\n  "+Qu+"\n  return result;\n",cpuKernelImpl:S1e}),ake={kernelName:Rm,backendName:"webgl",kernelFunc:ske};class lke{constructor(t,e,r){this.variableNames=["x"],this.outputShape=e.map((p,m)=>p[0]+t[m]+p[1]);const i=t.length,o=jn(i),s=e.map(p=>p[0]).join(","),a=e.map((p,m)=>p[0]+t[m]).join(","),c=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,i),u="reflect"===r?0:1;this.userCode=1!==i?`\n      ${o} start = ${o}(${s});\n      ${o} end = ${o}(${a});\n\n      void main() {\n        ${o} outC = getOutputCoords();\n        for (int i = 0; i < ${i}; i++) {\n          if (outC[i] < start[i]) {\n            outC[i] = start[i] * 2 - outC[i] - ${u};\n          } else if(outC[i] >= end[i]) {\n            outC[i] = (end[i] - 1) * 2 - outC[i] + ${u};\n          }\n        }\n        ${o} coords = outC - start;\n        setOutput(getX(${c}));\n      }\n    `:`\n        int start = ${s};\n        int end = ${a};\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start) {\n            outC = start * 2 - outC - ${u};\n          } else if(outC >= end) {\n            outC = (end - 1) * 2 - outC + ${u};\n          }\n          setOutput(getX(outC - start));\n        }\n      `}}class cke{constructor(t,e,r){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e.map((x,T)=>x[0]+t[T]+x[1]);const i=t.length,o=jn(i),s=e.map(x=>x[0]).join(","),a=e.map((x,T)=>x[0]+t[T]).join(","),c=ao("rc",i),u=ao("source",i),p=`${c[i-1]} < ${this.outputShape[i-1]}`,m=1===i?"source":`vec2(${u.slice(-2).join()})`,g="reflect"===r?0:1;let _="";if(1===i){const x=`\n        ${o} source = rc;\n        if (source < start) {\n          source = start * 2 - source - ${g};\n        } else if (source >= end) {\n          source = (end - 1) * 2 - source + ${g};\n        }\n        source -= start;\n      `;_=`\n        ${o} rc = outputLoc;\n        ${x}\n        result[0] = getChannel(getX(${u.join()}), ${m});\n        ${c[i-1]} += 1;\n        if(${p}) {\n          ${x}\n          result[1] = getChannel(getX(${u.join()}), ${m});\n        }\n      `}else{const x=`\n        ${o} source = rc;\n        ${o} lt = ${o}(lessThan(source, start));\n        ${o} gte = ${o}(greaterThanEqual(source, end));\n        ${o} orig = 1 - (lt + gte);\n        source = orig * source +\n                lt * (start * 2 - source - ${g}) +\n                gte * ((end - 1) * 2 - source + ${g});\n        source -= start;\n      `;_=`\n        ${o} rc = outputLoc;\n        ${x}\n        result[0] = getChannel(getX(${u.join()}), ${m});\n        ${c[i-1]} += 1;\n        if(${p}) {\n          ${x}\n          result[1] = getChannel(getX(${u.join()}), ${m});\n        }\n        rc = outputLoc;\n        ${c[i-2]} += 1;\n        if(${c[i-2]} < ${this.outputShape[i-2]}) {\n          ${x}\n          result[2] = getChannel(getX(${u.join()}), ${m});\n          ${c[i-1]} += 1;\n          if(${p}) {\n            ${x}\n            result[3] = getChannel(getX(${u.join()}), ${m});\n          }\n        }\n      `}this.userCode=`\n      const ${o} start = ${o}(${s});\n      const ${o} end = ${o}(${a});\n\n      void main() {\n        ${o} outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        ${_}\n        setOutput(result);\n      }\n    `}}const uke={kernelName:p0,backendName:"webgl",kernelFunc:({inputs:n,backend:t,attrs:e})=>{const{x:r}=n,{paddings:i,mode:o}=e,s=Ie().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new cke(r.shape,i,o):new lke(r.shape,i,o);return t.runWebGLProgram(s,[r],r.dtype)}},pke=Ni({opSnippet:"if (b == 0.0) return NAN;\n  return mod(a, b);",packedOpSnippet:"\n  vec4 result = mod(a, b);\n  bvec4 isNaN = equal(b, vec4(0.0));\n  "+Qu+"\n  return result;\n"}),fke={kernelName:Mm,backendName:"webgl",kernelFunc:pke};class mke{constructor(t,e,r){this.variableNames=["probs"],this.customUniforms=[{name:"seed",type:"float"}],this.outputShape=[t,r],this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n\n        float r = random(seed);\n        float cdf = 0.0;\n\n        for (int i = 0; i < ${e-1}; i++) {\n          cdf += getProbs(batch, i);\n\n          if (r < cdf) {\n            setOutput(float(i));\n            return;\n          }\n        }\n\n        // If no other event happened, last event happened.\n        setOutput(float(${e-1}));\n      }\n    `}}const fG=Ni({opSnippet:"\nif (a == b) {\n  return 1.0;\n};\nreturn a / b;",packedOpSnippet:"\n  // vec4 one = vec4(equal(a, b));\n  // return one + (vec4(1.0) - one) * a / b;\n  vec4 result = a / b;\n  if(a.x == b.x) {\n    result.x = 1.;\n  }\n  if(a.y == b.y) {\n    result.y = 1.;\n  }\n  if(a.z == b.z) {\n    result.z = 1.;\n  }\n  if(a.w == b.w) {\n    result.w = 1.;\n  }\n\n  return result;\n",checkOutOfBounds:!0}),gke={kernelName:ym,backendName:"webgl",kernelFunc:fG},mG="return a - b;",gG=Ni({opSnippet:mG,packedOpSnippet:mG,supportsComplex:!0,cpuKernelImpl:H1e}),bke={kernelName:Ym,backendName:"webgl",kernelFunc:gG};function bG(n){const{inputs:t,backend:e,attrs:r}=n,{logits:i}=t,{dim:o}=r,s=cn([o],i.shape),a=pG({inputs:{x:i},backend:e,attrs:{reductionIndices:s,keepDims:!1}}),c=Rr(a.shape,s),u=lt({inputs:{x:a},backend:e,attrs:{shape:c}}),p=gG({inputs:{a:i,b:u},backend:e}),m=aG({inputs:{x:p},backend:e}),g=_x({inputs:{x:m},backend:e,attrs:{axis:s,keepDims:!1}}),_=lt({inputs:{x:g},backend:e,attrs:{shape:c}}),x=fG({inputs:{a:m,b:_},backend:e});return e.disposeIntermediateTensorInfo(a),e.disposeIntermediateTensorInfo(u),e.disposeIntermediateTensorInfo(p),e.disposeIntermediateTensorInfo(m),e.disposeIntermediateTensorInfo(g),e.disposeIntermediateTensorInfo(_),x}const yke={kernelName:N0,backendName:"webgl",kernelFunc:bG},vke={kernelName:XC,backendName:"webgl",kernelFunc:function _ke(n){const{inputs:t,backend:e,attrs:r}=n,{logits:i}=t,{numSamples:o,seed:s,normalized:a}=r,c=a?i:bG({inputs:{logits:i},backend:e,attrs:{dim:i.shape.length-1}}),m=new mke(c.shape[0],c.shape[1],o),_=e.runWebGLProgram(m,[c],"int32",[[s]]);return a||e.disposeIntermediateTensorInfo(c),_}},xke=gs+"\n  return -x;\n",Ske={kernelName:f0,backendName:"webgl",kernelFunc:function Tke(n){const{inputs:t,backend:e}=n,{x:r}=t;if(e.shouldExecuteOnCPU([r])){const o=e.texData.get(r.dataId),[s,a]=I1e(o.values,r.shape,r.dtype);return e.makeTensorInfo(a,r.dtype,s)}let i;return i=Ie().getBool("WEBGL_PACK_UNARY_OPERATIONS")?new Bc(r.shape,"\n  vec4 result = -x;\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"):new Ya(r.shape,xke),e.runWebGLProgram(i,[r],r.dtype)}},Cke=qE,Eke={kernelName:YC,backendName:"webgl",kernelFunc:function Ike(n){as("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:e,attrs:r}=n,{boxes:i,scores:o}=t,{maxOutputSize:s,iouThreshold:a,scoreThreshold:c}=r,u=e.readSync(i.dataId),p=e.readSync(o.dataId),{selectedIndices:m}=Cke(u,p,s,a,c);return e.makeTensorInfo([m.length],"int32",new Int32Array(m))}},Dke=KE,Ake={kernelName:ZC,backendName:"webgl",kernelFunc:function kke(n){as("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:e,attrs:r}=n,{boxes:i,scores:o}=t,{maxOutputSize:s,iouThreshold:a,scoreThreshold:c,padToMaxOutputSize:u}=r,p=e.readSync(i.dataId),m=e.readSync(o.dataId),{selectedIndices:g,validOutputs:_}=Dke(p,m,s,a,c,u);return[e.makeTensorInfo([g.length],"int32",new Int32Array(g)),e.makeTensorInfo([],"int32",new Int32Array([_]))]}},Nke=XE,Rke={kernelName:QC,backendName:"webgl",kernelFunc:function Oke(n){as("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:e,attrs:r}=n,{boxes:i,scores:o}=t,{maxOutputSize:s,iouThreshold:a,scoreThreshold:c,softNmsSigma:u}=r,p=e.readSync(i.dataId),m=e.readSync(o.dataId),g=s,_=a,x=c,T=u,{selectedIndices:I,selectedScores:N}=Nke(p,m,g,_,x,T);return[e.makeTensorInfo([I.length],"int32",new Int32Array(I)),e.makeTensorInfo([N.length],"float32",new Float32Array(N))]}};class Mke{constructor(t,e,r,i){this.variableNames=["indices"],this.outputShape=[t,e],this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int index = round(getIndices(coords.x));\n        setOutput(mix(float(${i}), float(${r}),\n                      float(index == coords.y)));\n      }\n    `}}const Fke={kernelName:b0,backendName:"webgl",kernelFunc:n=>{const{inputs:t,backend:e,attrs:r}=n,{indices:i}=t,{dtype:o,depth:s,onValue:a,offValue:c}=r,u=Me(i.shape),p=new Mke(u,s,a,c),m=lt({inputs:{x:i},backend:e,attrs:{shape:[u]}}),g=e.runWebGLProgram(p,[m],o);e.disposeIntermediateTensorInfo(m);const x=lt({inputs:{x:g},backend:e,attrs:{shape:[...i.shape,s]}});return e.disposeIntermediateTensorInfo(g),x}};function Cx(n){const{inputs:t,backend:e}=n,{x:r}=t;if("complex64"===r.dtype){const i=qg({inputs:{input:r},backend:e}),o=Cx({inputs:{x:i},backend:e}),s=Tx({inputs:{input:r},backend:e}),a=Cx({inputs:{x:s},backend:e}),c=Vc({inputs:{real:o,imag:a},backend:e});return e.disposeIntermediateTensorInfo(i),e.disposeIntermediateTensorInfo(o),e.disposeIntermediateTensorInfo(s),e.disposeIntermediateTensorInfo(a),c}return Xg({attrs:{shape:r.shape,dtype:r.dtype,value:"string"===r.dtype?"":0},backend:e})}const Pke={kernelName:F0,backendName:"webgl",kernelFunc:Cx},$ke={kernelName:g0,backendName:"webgl",kernelFunc:function yG(n){const{inputs:t,backend:e}=n,{x:r}=t;if("string"===r.dtype)throw new Error("onesLike is not supported under string dtype");if("complex64"===r.dtype){const i=qg({inputs:{input:r},backend:e}),o=yG({inputs:{x:i},backend:e}),s=Tx({inputs:{input:r},backend:e}),a=Cx({inputs:{x:s},backend:e}),c=Vc({inputs:{real:o,imag:a},backend:e});return e.disposeIntermediateTensorInfo(i),e.disposeIntermediateTensorInfo(o),e.disposeIntermediateTensorInfo(s),e.disposeIntermediateTensorInfo(a),c}return Xg({attrs:{shape:r.shape,dtype:r.dtype,value:1},backend:e})}},Bke={kernelName:y0,backendName:"webgl",kernelFunc:function Lke(n){const{inputs:t,backend:e,attrs:r}=n,{axis:i}=r;if(1===t.length)return rA({inputs:{input:t[0]},backend:e,attrs:{dim:i}});const o=t[0].shape,s=t[0].dtype;t.forEach(p=>{Vo(o,p.shape,"All tensors passed to stack must have matching shapes"),Z(s===p.dtype,()=>"All tensors passed to stack must have matching dtypes")});const a=[],u=Yj({inputs:t.map(p=>{const m=rA({inputs:{input:p},backend:e,attrs:{dim:i}});return a.push(m),m}),backend:e,attrs:{axis:i}});return a.forEach(p=>e.disposeIntermediateTensorInfo(p)),u}};class Vke{constructor(t,e,r){this.variableNames=["x"],this.customUniforms=[{name:"value",type:"float"}],this.outputShape=e.map((u,p)=>u[0]+t[p]+u[1]);const i=t.length,o=jn(i),s=e.map(u=>u[0]).join(","),a=e.map((u,p)=>u[0]+t[p]).join(","),c=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,i);this.userCode=1!==i?`\n      ${o} start = ${o}(${s});\n      ${o} end = ${o}(${a});\n\n      void main() {\n        ${o} outC = getOutputCoords();\n        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {\n          setOutput(value);\n        } else {\n          ${o} coords = outC - start;\n          setOutput(getX(${c}));\n        }\n      }\n    `:`\n        int start = ${s};\n        int end = ${a};\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start || outC >= end) {\n            setOutput(value);\n          } else {\n            setOutput(getX(outC - start));\n          }\n        }\n      `}}class zke{constructor(t,e,r){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"value",type:"float"}],this.outputShape=e.map((T,I)=>T[0]+t[I]+T[1]);const i=t.length,o=jn(i),s=e.map(T=>T[0]).join(","),a=e.map((T,I)=>T[0]+t[I]).join(","),c=ao("rc",i),u=ao("source",i),p=`${c[i-1]} < ${this.outputShape[i-1]}`,m=1===i?"source":`vec2(${u.slice(-2).join()})`,g=[`${o} rc = outputLoc;`,`${c[i-1]} += 1;\n       if(${p}) {\n      `,1===i?"":`}\n       rc = outputLoc;\n       ${c[i-2]} += 1;\n       if(${c[i-2]} < ${this.outputShape[i-2]}) {`,1===i?"":`  ${c[i-1]} += 1;\n         if(${p}) {`],_=1===i?"rc < start || rc >= end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))";let x="";for(let T=0,I=1===i?2:4;T<I;T++)x+=`\n        ${g[T]}\n        if (${_}) {\n          result[${T}] = float(value);\n        } else {\n          ${o} source = rc - start;\n          result[${T}] = getChannel(getX(${u.join()}), ${m});\n        }\n      `;x+=1===i?"} ":"}}",this.userCode=`\n      const ${o} start = ${o}(${s});\n      const ${o} end = ${o}(${a});\n\n      void main() {\n        ${o} outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        ${x}\n        setOutput(result);\n      }\n    `}}const _G=n=>{const{inputs:t,backend:e,attrs:r}=n,{x:i}=t,{paddings:o,constantValue:s}=r;if(0===Me(i.shape))return Xg({backend:e,attrs:{shape:o.map((p,m)=>p[0]+i.shape[m]+p[1]),value:s,dtype:i.dtype}});const a=Ie().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new zke(i.shape,o,s):new Vke(i.shape,o,s);return e.runWebGLProgram(a,[i],i.dtype,[[s]])},Uke={kernelName:_0,backendName:"webgl",kernelFunc:_G},Hke=Ni({opSnippet:"\n  if(a < 0.0 && floor(b) < b){\n    return NAN;\n  }\n  if (b == 0.0) {\n    return 1.0;\n  }\n  return (round(mod(b, 2.0)) != 1) ?\n      pow(abs(a), b) : sign(a) * pow(abs(a), b);\n",packedOpSnippet:"\n  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.\n  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));\n  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);\n  vec4 result = multiplier * pow(abs(a), b);\n\n  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS\n  bvec4 isExpZero = equal(b, vec4(0.0));\n  result.r = isExpZero.r ? 1.0 : result.r;\n  result.g = isExpZero.g ? 1.0 : result.g;\n  result.b = isExpZero.b ? 1.0 : result.b;\n  result.a = isExpZero.a ? 1.0 : result.a;\n\n  bvec4 isNaN1 = lessThan(a, vec4(0.0));\n  bvec4 isNaN2 = lessThan(floor(b), b);\n  bvec4 isNaN = bvec4(isNaN1.x && isNaN2.x, isNaN1.y && isNaN2.y, isNaN1.z && isNaN2.z, isNaN1.w && isNaN2.w);\n  "+Qu+"\n  return result;\n"}),Wke={kernelName:Pm,backendName:"webgl",kernelFunc:Hke},Kke={kernelName:x0,backendName:"webgl",kernelFunc:function qke(n){const{inputs:t,backend:e,attrs:r}=n,{x:i}=t,{axis:o,keepDims:s}=r,a=i.shape.length,c=[],u=cn(o,i.shape);let p=u;const m=hr(p,a);let _,g=i;if(null!=m&&(g=lo({inputs:{x:i},backend:e,attrs:{perm:m}}),p=Mr(p.length,a),c.push(g)),ki("prod",p,a),e.shouldExecuteOnCPU([g])){const x=e.texData.get(g.dataId).values,{outVals:T,outShape:I,outDtype:N}=D1e(g.shape,g.dtype,x,p);_=e.makeTensorInfo(I,N,T)}else{const[x,T]=gi(g.shape,p),I=Me(T),N=lt({inputs:{x:g},backend:e,attrs:{shape:[-1,I]}}),L=Ju(N,DI(i.dtype),"prod",e);_=lt({inputs:{x:L},backend:e,attrs:{shape:x}}),c.push(N),c.push(L)}if(s){c.push(_);const x=Rr(_.shape,u);_=lt({inputs:{x:_},backend:e,attrs:{shape:x}})}return c.forEach(x=>e.disposeIntermediateTensorInfo(x)),_}},Yke={kernelName:JC,backendName:"webgl",kernelFunc:function Xke(n){const{inputs:t,backend:e,attrs:r}=n,{paramsNestedSplits:i,paramsDenseValues:o,indices:s}=t,{outputRaggedRank:a}=r,c=i.map(N=>e.readSync(N.dataId)),u=i.map(N=>N.shape),p=e.readSync(o.dataId),m=e.readSync(s.dataId),[g,_,x]=k1e(c,u,p,o.shape,o.dtype,m,s.shape,a),T=g.map(N=>e.makeTensorInfo([N.length],"int32",N)),I=e.makeTensorInfo(x,o.dtype,_);return T.concat([I])}},Qke={kernelName:eI,backendName:"webgl",kernelFunc:function Zke(n){const{inputs:t,backend:e}=n,{starts:r,limits:i,deltas:o}=t,s=e.readSync(r.dataId),a=e.readSync(i.dataId),c=e.readSync(o.dataId),[u,p]=A1e(s,r.shape,r.dtype,a,i.shape,c,o.shape);return[e.makeTensorInfo([u.length],"int32",u),e.makeTensorInfo([p.length],r.dtype,p)]}},eAe={kernelName:tI,backendName:"webgl",kernelFunc:function Jke(n){const{inputs:t,backend:e,attrs:r}=n,{shape:i,values:o,defaultValue:s,rowPartitionTensors:a}=t,{rowPartitionTypes:c}=r,u=e.readSync(i.dataId),p=e.readSync(o.dataId),m=e.readSync(s.dataId),g=a.map(I=>e.readSync(I.dataId)),_=a.map(I=>I.shape),[x,T]=N1e(u,i.shape,p,o.shape,o.dtype,m,s.shape,g,_,c);return e.makeTensorInfo(x,o.dtype,T)}},vG=n=>{const{backend:t,attrs:e}=n,{start:r,stop:i,step:o,dtype:s}=e,a=O1e(r,i,o,s);return t.makeTensorInfo([a.length],s,a)},tAe={kernelName:nI,backendName:"webgl",kernelFunc:vG},nAe=Sn({opSnippet:"return 1.0 / x;"}),rAe={kernelName:$m,backendName:"webgl",kernelFunc:nAe},oAe=Sn({opSnippet:gs+"\n  return (x < 0.0) ? 0.0 : x;\n",packedOpSnippet:"\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"}),sAe={kernelName:Lm,backendName:"webgl",kernelFunc:oAe},lAe=Sn({opSnippet:gs+"\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n",packedOpSnippet:"\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"}),cAe={kernelName:Bm,backendName:"webgl",kernelFunc:lAe};class uAe{constructor(t,e,r,i,o){this.variableNames=["A"],this.outputShape=[];const[s,a,c,u]=t;this.outputShape=[s,e,r,u];const p=[i&&e>1?a-1:a,i&&r>1?c-1:c],m=[i&&e>1?e-1:e,i&&r>1?r-1:r];let g;g=o?"(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)":"vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ${p[0]/m[0]},\n          ${p[1]/m[1]});\n      const vec2 inputShapeRC = vec2(${a}.0, ${c}.0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = ${g};\n\n        // Compute the four integer indices.\n        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));\n        ivec2 sourceCeilRC = ivec2(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);\n        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);\n        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);\n        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);\n\n        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);\n\n        float top = topLeft + (topRight - topLeft) * fracRC.y;\n        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;\n        float newValue = top + (bottom - top) * fracRC.x;\n\n        setOutput(newValue);\n      }\n    `}}class dAe{constructor(t,e,r,i,o){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[s,a,c,u]=t;this.outputShape=[s,e,r,u];const p=[i&&e>1?a-1:a,i&&r>1?c-1:c],m=[i&&e>1?e-1:e,i&&r>1?r-1:r];let g;g=o?"(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)":"vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          ${p[0]/m[0]},\n          ${p[1]/m[1]},\n          ${p[1]/m[1]});\n      const vec3 inputShapeRC = vec3(${a}.0, ${c}.0,\n                                     ${c}.0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = ${g};\n\n        // Compute the four integer indices.\n        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));\n        ivec3 sourceCeilRC = ivec3(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < ${u-1};\n        bool hasNextRow = coords.z < ${r-1};\n\n        // In parallel, construct four corners for all four components in\n        // packed 2x2 cell.\n        vec4 topLeft = vec4(\n          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 bottomLeft = vec4(\n          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 topRight = vec4(\n          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec4 bottomRight = vec4(\n          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);\n\n        vec4 top = mix(topLeft, topRight, fracRC.yyzz);\n        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);\n        vec4 newValue = mix(top, bottom, fracRC.x);\n\n        setOutput(newValue);\n      }\n    `}}const pAe={kernelName:S0,backendName:"webgl",kernelFunc:function hAe(n){const{inputs:t,backend:e,attrs:r}=n,{images:i}=t,{alignCorners:o,halfPixelCenters:s,size:a}=r,[c,u]=a,p=Ie().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new dAe(i.shape,c,u,o,s):new uAe(i.shape,c,u,o,s);return e.runWebGLProgram(p,[i],"float32")}};class fAe{constructor(t,e,r){this.variableNames=["dy"],this.outputShape=[],this.outputShape=e;const[,i,o]=e,[,s,a]=t,c=[r&&s>1?i-1:i,r&&a>1?o-1:o],u=[r&&s>1?s-1:s,r&&a>1?a-1:a],p=c[0]/u[0],m=c[1]/u[1],g=1/p,_=1/m,x=2*Math.ceil(g)+2,T=2*Math.ceil(_)+2;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(${p});\n        const float widthScale = float(${m});\n\n        const float invHeightScale = float(${g});\n        const float invWidthScale = float(${_});\n\n        const int winHeight = int(${x});\n        const int winWidth = int(${T});\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(startRLerp - float(winHeight / 2));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(startCLerp - float(winWidth / 2));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ${s}) {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ${a}) {\n              continue;\n            }\n\n            float dxR = float(dyR) * heightScale;\n            int topDxRIndex = int(floor(dxR));\n            int bottomDxRIndex = int(min(ceil(dxR), ${i-1}.0));\n            float dxRLerp = dxR - float(topDxRIndex);\n            float inverseDxRLerp = 1.0 - dxRLerp;\n\n            float dxC = float(dyC) * widthScale;\n            int leftDxCIndex = int(floor(dxC));\n            int rightDxCIndex = int(min(ceil(dxC), ${o-1}.0));\n            float dxCLerp = dxC - float(leftDxCIndex);\n            float inverseDxCLerp = 1.0 - dxCLerp;\n\n            if (r == topDxRIndex && c == leftDxCIndex) {\n              // topLeft\n              accumulator +=\n                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;\n            }\n\n            if (r == topDxRIndex && c == rightDxCIndex) {\n              // topRight\n              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == leftDxCIndex) {\n              // bottomLeft\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == rightDxCIndex) {\n              // bottomRight\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    `}}const gAe={kernelName:oI,backendName:"webgl",kernelFunc:function mAe(n){const{inputs:t,backend:e,attrs:r}=n,{images:i,dy:o}=t,{alignCorners:s}=r,a=new fAe(o.shape,i.shape,s);return e.runWebGLProgram(a,[o],o.dtype)}};class bAe{constructor(t,e,r,i,o){this.variableNames=["A"],this.outputShape=[];const[s,a,c,u]=t;this.outputShape=[s,e,r,u];const p=[i&&e>1?a-1:a,i&&r>1?c-1:c],m=[i&&e>1?e-1:e,i&&r>1?r-1:r];let _;_=o?"max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC, vec2(0.0))":"vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ${p[0]/m[0]},\n          ${p[1]/m[1]});\n      const vec2 inputShapeRC = vec2(${a}.0, ${c}.0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = ${_};\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec2 sourceNearestRC = ivec2(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${i?"0.5":"0.0"})));\n        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);\n\n        setOutput(newValue);\n      }\n    `}}class yAe{constructor(t,e,r,i,o){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[s,a,c,u]=t;this.outputShape=[s,e,r,u];const p=[i&&e>1?a-1:a,i&&r>1?c-1:c],m=[i&&e>1?e-1:e,i&&r>1?r-1:r];let _;_=o?"max((vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC, vec3(0.0))":"vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          ${p[0]/m[0]},\n          ${p[1]/m[1]},\n          ${p[1]/m[1]});\n      const vec3 inputShapeRC = vec3(${a}.0, ${c}.0,\n                                     ${c}.0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = ${_};\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec3 sourceNearestRC = ivec3(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${i?"0.5":"0.0"})));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < ${u-1};\n        bool hasNextRow = coords.z < ${r-1};\n\n        vec4 newValue = vec4(\n          getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d),\n          hasNextCol ? getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d + 1) : 0.0);\n\n        setOutput(newValue);\n      }\n    `}}const vAe={kernelName:T0,backendName:"webgl",kernelFunc:function _Ae(n){const{inputs:t,backend:e,attrs:r}=n,{images:i}=t,{alignCorners:o,halfPixelCenters:s,size:a}=r,[c,u]=a,p=Ie().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new yAe(i.shape,c,u,o,s):new bAe(i.shape,c,u,o,s);return e.runWebGLProgram(p,[i],i.dtype)}};class xAe{constructor(t,e,r){this.variableNames=["dy"],this.outputShape=[],this.outputShape=e;const[,i,o]=e,[,s,a]=t,c=[r&&s>1?i-1:i,r&&a>1?o-1:o],u=[r&&s>1?s-1:s,r&&a>1?a-1:a],p=c[0]/u[0],m=c[1]/u[1],g=1/p,_=1/m,x=2*Math.ceil(g)+2,T=2*Math.ceil(_)+2;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(${p});\n        const float widthScale = float(${m});\n\n        const float invHeightScale = float(${g});\n        const float invWidthScale = float(${_});\n\n        const int winHeight = int(${x});\n        const int winWidth = int(${T});\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(floor(startRLerp - float(winHeight / 2)));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(floor(startCLerp - float(winWidth / 2)));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ${s}) {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ${a}) {\n              continue;\n            }\n\n            float sourceFracRow =\n              float(${c[0]}) *\n                (float(dyR) / float(${u[0]}));\n\n            float sourceFracCol =\n                float(${c[1]}) *\n                  (float(dyC) / float(${u[1]}));\n\n            int sourceNearestRow = int(min(\n                float(int(${i}) - 1),\n                ${r} ? float(round(sourceFracRow)) :\n                                  float(floor(sourceFracRow))));\n\n            int sourceNearestCol = int(min(\n                float(int(${o}) - 1),\n                ${r} ? float(round(sourceFracCol)) :\n                                  float(floor(sourceFracCol))));\n\n            if (r == sourceNearestRow && c == sourceNearestCol) {\n              accumulator += getDy(b, dyR, dyC, d);\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    `}}const TAe={kernelName:iI,backendName:"webgl",kernelFunc:function wAe(n){const{inputs:t,backend:e,attrs:r}=n,{images:i,dy:o}=t,{alignCorners:s}=r,a=new xAe(o.shape,i.shape,s);return e.runWebGLProgram(a,[o],o.dtype)}};class SAe{constructor(t,e){this.variableNames=["x"];const r=t.length;if(r>4)throw new Error(`WebGL backend: Reverse of rank-${r} tensor is not yet supported`);if(this.outputShape=t,1===r)return void(this.userCode=`\n        void main() {\n          int coord = getOutputCoords();\n          setOutput(getX(${t[0]} - coord - 1));\n        }\n      `);const o=t.map((a,c)=>(a=>-1!==e.indexOf(a)&&1!==t[a]?`${t[a]} - coords[${a}] - 1`:`coords[${a}]`)(c)).join(","),s=jn(r);this.userCode=`\n      void main() {\n        ${s} coords = getOutputCoords();\n        setOutput(getX(${o}));\n      }\n    `}}class CAe{constructor(t,e){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0;const r=t.length;if(r>4)throw new Error(`WebGL backend: Reverse of rank-${r} tensor is not yet supported`);this.outputShape=t;const i=ao("rc",r),o=`${i[r-1]} + 1 < ${this.outputShape[r-1]}`,s=`${i[r-2]} + 1 < ${this.outputShape[r-2]}`,a=jn(r);function g(x){const T=t.map((R,L)=>function _(x,T){return-1!==e.indexOf(x)&&1!==t[x]?`${t[x]} - ${T[x]} - 1`:`${T[x]}`}(L,x));return`getChannel(getX(${T.join(",")}), vec2(${T.slice(-2).join(",")}))`}this.userCode=1===r?`\n        void main(){\n          int rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = getChannel(getX(${t[0]} - rc - 1),\n            ${t[0]} - rc - 1);\n          if(${o}){\n              result.g = getChannel(getX(${t[0]} - (rc  + 1) - 1),\n                ${t[0]} - (rc  + 1) - 1);\n          }\n          setOutput(result);\n        }\n      `:`\n        void main() {\n          ${a} rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = ${function c(x){return g(x)}(i.slice())};\n          if(${o}){\n            result.g = ${function u(x){return x[r-1]="("+x[r-1]+" + 1)",g(x)}(i.slice())};\n          }\n          if(${s}) {\n            result.b = ${function p(x){return x[r-2]="("+x[r-2]+" + 1)",g(x)}(i.slice())};\n            if(${o}) {\n              result.a = ${function m(x){return x[r-1]="("+x[r-1]+" + 1)",x[r-2]="("+x[r-2]+" + 1)",g(x)}(i.slice())};\n            }\n          }\n          setOutput(result);\n        }\n    `}}const EAe={kernelName:C0,backendName:"webgl",kernelFunc:function IAe(n){const{inputs:t,backend:e,attrs:r}=n,{x:i}=t,{dims:o}=r,s=i.shape.length,a=cn(o,i.shape);if(0===s)return qo({inputs:{x:i},backend:e});const c=Ie().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new CAe(i.shape,a):new SAe(i.shape,a);return e.runWebGLProgram(c,[i],i.dtype)}};class DAe{constructor(t,e){this.variableNames=["Image"],this.outputShape=[],this.customUniforms=[{name:"params",type:"vec4"}];const r=t[1],i=t[2];this.outputShape=t;let o="";o="number"==typeof e?`float outputValue = ${e.toFixed(2)};`:`\n        vec3 fill = vec3(${e.join(",")});\n        float outputValue = fill[coords[3]];`,this.userCode=`\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int x = coords[2];\n          int y = coords[1];\n          float coordXFloat = (float(x) - params[0]) * params[3] -\n            (float(y) - params[1]) * params[2];\n          float coordYFloat = (float(x) - params[0]) * params[2] +\n            (float(y) - params[1]) * params[3];\n          int coordX = int(round(coordXFloat + params[0]));\n          int coordY = int(round(coordYFloat + params[1]));\n          ${o}\n          if(coordX >= 0 && coordX < ${i} && coordY >= 0 && coordY < ${r}) {\n            outputValue = getImage(coords[0], coordY, coordX, coords[3]);\n          }\n          setOutput(outputValue);\n        }\n    `}}const kAe={kernelName:wI,backendName:"webgl",kernelFunc:({inputs:n,attrs:t,backend:e})=>{const{image:r}=n,{radians:i,fillValue:o,center:s}=t,a=e,c=new DAe(r.shape,o),[u,p]=nD(s,r.shape[1],r.shape[2]),m=[[u,p,Math.sin(i),Math.cos(i)]];return a.runWebGLProgram(c,[r],r.dtype,m)}},AAe=Sn({opSnippet:"\n  // OpenGL ES does not support round function.\n  // The algorithm is based on banker's rounding.\n  float base = floor(x);\n  if ((x - base) < 0.5) {\n    return floor(x);\n  } else if ((x - base) > 0.5) {\n    return ceil(x);\n  } else {\n    if (mod(base, 2.0) == 0.0) {\n      return base;\n    } else {\n      return base + 1.0;\n    }\n  }\n"}),NAe={kernelName:Vm,backendName:"webgl",kernelFunc:AAe},OAe=Sn({opSnippet:"return inversesqrt(x);",cpuKernelImpl:R1e}),RAe={kernelName:zm,backendName:"webgl",kernelFunc:OAe};class oA{constructor(t,e,r,i,o,s,a=!0,c=!1){this.variableNames=["updates","indices","defaultValue"],this.outputShape=s;const u=jn(o.length),p=jn(s.length);let m="";1===r?m="i":2===r&&(m="i, j");let _="";1===i?_="i":2===i&&(_="i, coords[1]");let T="";c&&(T="coords[0], coords[1]"),this.userCode=`\n        ${u} strides = ${u}(${o});\n\n        void main() {\n          ${p} coords = getOutputCoords();\n          float sum = 0.0;\n          bool found = false;\n          for (int i = 0; i < ${t}; i++) {\n            int flattenedIndex = 0;\n            for (int j = 0; j < ${e}; j++) {\n              int index = round(getIndices(${m}));\n              flattenedIndex += index * ${e>1?"strides[j]":"strides"};\n            }\n            if (flattenedIndex == coords[0]) {\n              sum += getUpdates(${_});\n              found = true;\n            }\n          }\n          setOutput(mix(getDefaultValue(${T}), sum, float(found)));\n        }\n      `}}class MAe{constructor(t,e,r,i,o,s,a=!0,c=!1){this.variableNames=["updates","indices","defaultValue"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=s;const u=jn(o.length),p=jn(s.length);let m="";1===r?m="i":2===r&&(m="i, j");let _="";1===i?_="i":2===i&&(_="i, coords[1]");let T="";c&&(T="coords[0], coords[1]"),this.userCode=`\n        ${u} strides = ${u}(${o});\n\n        void main() {\n          ${p} coords = getOutputCoords();\n          vec4 sum = vec4(0.);\n          vec4 found = vec4(0.);\n          for (int i = 0; i < ${t}; i+=2) {\n            ivec2 flattenedIndex = ivec2(0);\n            for (int j = 0; j < ${e}; j+=2) {\n              ivec4 index = round(getIndices(${m}));\n              flattenedIndex += index.xz * ${e>1?"strides[j]":"strides"};\n              if (j + 1 < ${e}) {\n                flattenedIndex += index.yw * ${e>1?"strides[j + 1]":"strides"};\n              }\n            }\n            if (flattenedIndex[0] == coords[0] || flattenedIndex[1] == coords[0] ||\n                flattenedIndex[0] == coords[0] + 1 || flattenedIndex[1] == coords[0] + 1) {\n              vec4 updVals = getUpdates(${_});\n              if (flattenedIndex[0] == coords[0]) {\n                sum.xy += updVals.xy;\n                found.xy = vec2(1.);\n              } else if (flattenedIndex[0] == coords[0] + 1) {\n                sum.zw += updVals.xy;\n                found.zw = vec2(1.);\n              }\n              if (flattenedIndex[1] == coords[0]) {\n                sum.xy += updVals.zw;\n                found.xy = vec2(1.);\n              } else if (flattenedIndex[1] == coords[0] + 1) {\n                sum.zw += updVals.zw;\n                found.zw = vec2(1.);\n              }\n            }\n          }\n          setOutput(mix(getDefaultValue(${T}), sum, found));\n        }\n      `}}const PAe={kernelName:sI,backendName:"webgl",kernelFunc:function FAe(n){const{inputs:t,backend:e,attrs:r}=n,{indices:i,updates:o}=t,{shape:s}=r,{sliceRank:a,numUpdates:c,sliceSize:u,strides:p,outputSize:m}=Lu(0,i,s),g=[m/u,u];if(0===m)return e.makeTensorInfo(s,i.dtype);const _=lt({inputs:{x:i},backend:e,attrs:{shape:[c,a]}}),x=lt({inputs:{x:o},backend:e,attrs:{shape:[c,u]}}),T=e.makeTensorInfo([],"float32",new Float32Array([0]));let I;I=Ie().getBool("WEBGL_PACK")?new MAe(c,a,_.shape.length,x.shape.length,p,g):new oA(c,a,_.shape.length,x.shape.length,p,g);const N=e.runWebGLProgram(I,[x,_,T],x.dtype),R=lt({inputs:{x:N},backend:e,attrs:{shape:s}});return e.disposeIntermediateTensorInfo(_),e.disposeIntermediateTensorInfo(x),e.disposeIntermediateTensorInfo(N),e.disposeIntermediateTensorInfo(T),R}};class $Ae{constructor(t,e,r,i){this.variableNames=["sortedSequence","values"],this.customUniforms=[{name:"numInputs",type:"int"}],this.outputShape=[t,r];const s=`for (int i = 0; i < ${Math.ceil(Math.log2(e+1))}; ++i) { if (left >= right) break;`,a=2===Ie().getNumber("WEBGL_VERSION")?"while (left < right) {":s;this.userCode=`\n       int findBound(int batch, float value) {\n         int left = 0;\n         int right = numInputs;\n         int mid;\n         ${a}\n           mid = (left + right) / 2;\n           if (getSortedSequence(batch, mid) ${"left"===i?"<":"<="} value) {\n             left = mid + 1;\n           } else {\n             right = mid;\n           }\n         }\n         return right;\n       }\n\n       void main() {\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int valueIndex = coords[1];\n\n         float value = getValues(batch, valueIndex);\n\n         setOutput(float(findBound(batch, value)));\n       }\n     `}}const BAe={kernelName:lI,backendName:"webgl",kernelFunc:function LAe(n){const{inputs:t,backend:e,attrs:r}=n,{sortedSequence:i,values:o}=t,{side:s}=r,a=new $Ae(i.shape[0],i.shape[1],o.shape[1],s);return e.runWebGLProgram(a,[i,o],"int32",[[i.shape[1]]])}};class VAe{constructor(t,e,r){let i,o;if(this.variableNames=["c","a","b"],this.outputShape=e,r>4)throw Error(`Where for rank ${r} is not yet supported`);if(1===r)o="resRC",i="resRC";else{const a=["resRC.x","resRC.y","resRC.z","resRC.w"],c=[],u=[];for(let p=0;p<e.length;p++)u.push(`${a[p]}`),p<t&&c.push(`${a[p]}`);i=c.join(),o=u.join()}const s=jn(r);this.userCode=`\n      void main() {\n        ${s} resRC = getOutputCoords();\n        float cVal = getC(${i});\n        if (cVal >= 1.0) {\n          setOutput(getA(${o}));\n        } else {\n          setOutput(getB(${o}));\n        }\n      }\n    `}}const UAe={kernelName:I0,backendName:"webgl",kernelFunc:function zAe(n){const{inputs:t,backend:e}=n,{condition:r,t:i,e:o}=t,s=new VAe(r.shape.length,i.shape,i.shape.length);return e.runWebGLProgram(s,[r,i,o],zo(i.dtype,o.dtype))}},GAe=Sn({opSnippet:`\n  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.\n  // see: https://arxiv.org/abs/1706.02515\n  float scaleAlpha = ${xv};\n  float scale = ${wv};\n  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);\n`}),HAe={kernelName:Um,backendName:"webgl",kernelFunc:GAe},qAe=Sn({opSnippet:sp+"\n  return 1.0 / (1.0 + exp(-1.0 * x));\n",packedOpSnippet:"\n  vec4 result = 1.0 / (1.0 + exp(-1.0 * x));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",cpuKernelImpl:F1e}),KAe={kernelName:Wm,backendName:"webgl",kernelFunc:qAe},XAe=Sn({opSnippet:"\n  if (isnan(x)) { return 0.0; }\n  return sign(x);\n"}),YAe={kernelName:Hm,backendName:"webgl",kernelFunc:XAe},JAe=Sn({opSnippet:sp+"\n  return sin(x);\n",packedOpSnippet:`\n  vec4 result = sin(x);\n  bvec4 isNaN = isnan(x);\n  ${Qu}\n  return result;\n`}),e2e={kernelName:jm,backendName:"webgl",kernelFunc:JAe},t2e=Sn({opSnippet:"\n  float e2x = exp(x);\n  return (e2x - 1.0 / e2x) / 2.0;\n"}),n2e={kernelName:Gm,backendName:"webgl",kernelFunc:t2e},r2e=Sn({opSnippet:"\n  float epsilon = 1.1920928955078125e-7;\n  float threshold = log(epsilon) + 2.0;\n\n  bool too_large = x > -threshold;\n  bool too_small = x < threshold;\n\n  float result;\n  float exp_x = exp(x);\n\n  if (too_large){\n    result = x;\n  }\n  else if (too_small){\n    result = exp_x;\n  }\n  else{\n    result = log(exp_x + 1.0);\n  }\n  return result;\n"}),i2e={kernelName:qm,backendName:"webgl",kernelFunc:r2e},o2e={kernelName:k0,backendName:"webgl",kernelFunc:n=>{const{inputs:t,backend:e,attrs:r}=n,{x:i}=t,{blockShape:o,paddings:s}=r;Z(i.shape.length<=4,()=>"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet");const a=o.reduce((N,R)=>N*R),c=[[0,0]];c.push(...s);for(let N=1+o.length;N<i.shape.length;++N)c.push([0,0]);const u=[],p=_G({inputs:{x:i},backend:e,attrs:{paddings:c,constantValue:0}}),m=vg(p.shape,o,a,!1),g=xg(m.length,o.length,!1),_=wg(p.shape,o,a,!1),x=lt({inputs:{x:p},backend:e,attrs:{shape:m}}),T=lo({inputs:{x},backend:e,attrs:{perm:g}}),I=lt({inputs:{x:T},backend:e,attrs:{shape:_}});return u.push(p),u.push(x),u.push(T),u.forEach(N=>e.disposeIntermediateTensorInfo(N)),I}},a2e={kernelName:cI,backendName:"webgl",kernelFunc:function s2e(n){const{inputs:t,backend:e}=n,{indices:r,values:i,denseShape:o,defaultValue:s}=t;if(1!==o.shape.length)throw new Error(`Dense shape must be a vector, saw:\n         ${o.shape}`);if(2!==r.shape.length)throw new Error(`Indices must be a matrix, saw:\n         ${r.shape}`);if(1!==i.shape.length)throw new Error(`Values must be a vector, saw:\n         ${i.shape}`);if(0!==s.shape.length)throw new Error(`Default value must be a scalar, saw:\n        ${s.shape}`);const a=e.readSync(r.dataId),c=e.readSync(i.dataId),u=e.readSync(o.dataId),p=e.readSync(s.dataId)[0],[m,g,_,x,T]=$1e(a,r.shape,r.dtype,c,i.dtype,u,p);return[e.makeTensorInfo(g,r.dtype,m),e.makeTensorInfo([g[0]],i.dtype,_),e.makeTensorInfo([x.length],"bool",new Uint8Array(x.map(I=>Number(I)))),e.makeTensorInfo([T.length],r.dtype,new Int32Array(T))]}},c2e={kernelName:uI,backendName:"webgl",kernelFunc:function l2e(n){const{inputs:t,backend:e}=n,{inputIndices:r,inputShape:i,newShape:o}=t;if(2!==r.shape.length)throw new Error(`Input indices should be a matrix but received shape ${r.shape}`);if(1!==i.shape.length)throw new Error(`Input shape should be a vector but received shape ${i.shape}`);if(1!==o.shape.length)throw new Error(`Target shape should be a vector but received shape ${o.shape}`);const s=Array.from(e.readSync(i.dataId)),a=e.readSync(r.dataId),c=Array.from(e.readSync(o.dataId)),[u,p,m]=L1e(a,r.shape,r.dtype,s,c);return[e.makeTensorInfo(p,r.dtype,u),e.makeTensorInfo([m.length],o.dtype,new Int32Array(m))]}},d2e={kernelName:dI,backendName:"webgl",kernelFunc:function u2e(n){const{inputs:t,backend:e}=n,{data:r,indices:i,segmentIds:o}=t;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==i.shape.length)throw new Error(`Indices should be a vector but received shape\n              ${i.shape}`);if(1!==o.shape.length)throw new Error(`Segment ids should be a vector but received shape\n              ${o.shape}`);const s=e.readSync(r.dataId),a=e.readSync(i.dataId),c=e.readSync(o.dataId),[u,p]=Cj(s,r.shape,r.dtype,a,c,!0);return e.makeTensorInfo(p,r.dtype,u)}},p2e={kernelName:hI,backendName:"webgl",kernelFunc:function h2e(n){const{inputs:t,backend:e}=n,{data:r,indices:i,segmentIds:o}=t;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==i.shape.length)throw new Error(`Indices should be a vector but received shape\n             ${i.shape}`);if(1!==o.shape.length)throw new Error(`Segment ids should be a vector but received shape\n             ${o.shape}`);const s=e.readSync(r.dataId),a=e.readSync(i.dataId),c=e.readSync(o.dataId),[u,p]=Cj(s,r.shape,r.dtype,a,c);return e.makeTensorInfo(p,r.dtype,u)}},m2e={kernelName:pI,backendName:"webgl",kernelFunc:function f2e(n){const{inputs:t,backend:e,attrs:r}=n,{sparseIndices:i,sparseValues:o,defaultValue:s}=t,{outputShape:a}=r,{sliceRank:c,numUpdates:u,sliceSize:p,strides:m,outputSize:g}=Lu(0,i,a);if("string"===o.dtype){const N=e.bufferSync(i),R=e.bufferSync(o),L=uc(e.readSync(s.dataId)[0]),V=M1e(N,R,a,g,p,u,c,m,L,!1);return e.makeTensorInfo(a,V.dtype,V.values)}const x=new oA(u,c,i.shape.length,o.shape.length,m,[g,1],!1),T=e.runWebGLProgram(x,[o,i,s],o.dtype),I=lt({inputs:{x:T},backend:e,attrs:{shape:a}});return e.disposeIntermediateTensorInfo(T),I}},b2e={kernelName:A0,backendName:"webgl",kernelFunc:function g2e(n){const{inputs:t,backend:e,attrs:r}=n,{x:i}=t,{numOrSizeSplits:o,axis:s}=r,a=cn(s,i.shape)[0],c=_D(i,o,a),p=new Array(i.shape.length).fill(0),m=i.shape.slice();return c.map(g=>{const _=[...m];_[a]=g;const x=ap({inputs:{x:i},backend:e,attrs:{begin:p,size:_}});return p[a]+=g,x})}},xG="return sqrt(x);",y2e=Sn({opSnippet:xG,packedOpSnippet:xG,cpuKernelImpl:B1e}),_2e={kernelName:Km,backendName:"webgl",kernelFunc:y2e},x2e={kernelName:fI,backendName:"webgl",kernelFunc:Sn({opSnippet:"return x * x;"})},wG="return (a - b) * (a - b);",w2e=Ni({opSnippet:wG,packedOpSnippet:wG}),T2e={kernelName:Xm,backendName:"webgl",kernelFunc:w2e},C2e={kernelName:O0,backendName:"webgl",kernelFunc:function S2e(n){const{inputs:t,backend:e,attrs:r}=n,{x:i}=t;if("string"!==i.dtype)throw new Error("Input must be of datatype string");const s=Il(e.readSync(i.dataId)),a=V1e(s,"string",r);return e.makeTensorInfo(i.shape,"string",a)}},E2e={kernelName:eg,backendName:"webgl",kernelFunc:function I2e({inputs:n,attrs:t,backend:e}){const{x:r}=n,o=new Ya(r.shape,gs+`\n    return x > 0.0 ? 1.0 : float(${t.alpha});\n  `);return e.runWebGLProgram(o,[r],r.dtype)}};class D2e{constructor(t,e,r){this.variableNames=["x"],this.outputShape=r;const i=r.length,o=jn(r.length),s=jn(r.length);let a="";if(1===i)a="coords * strides + begin";else{let c=0;a=r.map((u,p)=>(c++,1===r.length?`coords * strides[${p}] + begin[${p}]`:`coords[${c-1}] * strides[${p}] + begin[${p}]`)).join(",")}this.userCode=`\n      ${o} begin = ${o}(${t});\n      ${o} strides = ${o}(${e});\n\n      void main() {\n        ${s} coords = getOutputCoords();\n        setOutput(getX(${a}));\n      }\n    `}}const A2e={kernelName:mI,backendName:"webgl",kernelFunc:function k2e(n){const{inputs:t,backend:e,attrs:r}=n,{x:i}=t,{begin:o,end:s,strides:a,beginMask:c,endMask:u,ellipsisMask:p,newAxisMask:m,shrinkAxisMask:g}=r,{finalShapeSparse:_,finalShape:x,isIdentity:T,sliceDim0:I,isSimpleSlice:N,begin:R,end:L,strides:V}=sE(i.shape,o,s,a,c,u,p,m,g);let j;if(T)j=lt({inputs:{x:i},backend:e,attrs:{shape:x}});else if(I||N){Z(i.shape.length>=1,()=>`Input must have rank at least 1, got: ${i.shape.length}`);const ee=rE(R,L,V),ie=ap({inputs:{x:i},backend:e,attrs:{begin:R,size:ee}});j=lt({inputs:{x:ie},backend:e,attrs:{shape:x}}),e.disposeIntermediateTensorInfo(ie)}else if(e.shouldExecuteOnCPU([i])){const ie=e.readSync(i.dataId),ce=sn(i.shape,i.dtype,ie),he=z1e(_,ce,V,R);j=e.makeTensorInfo(x,i.dtype,he.values)}else{const ie=new D2e(R,V,_);j=e.runWebGLProgram(ie,[i],i.dtype)}const Y=lt({inputs:{x:j},backend:e,attrs:{shape:x}});return e.disposeIntermediateTensorInfo(j),Y}},O2e={kernelName:gI,backendName:"webgl",kernelFunc:function N2e(n){const{inputs:t,backend:e,attrs:r}=n,{separator:i,nGramWidths:o,leftPad:s,rightPad:a,padWidth:c,preserveShortSequences:u}=r,{data:p,dataSplits:m}=t,g=e.readSync(p.dataId),_=e.readSync(m.dataId),[x,T]=U1e(g,_,i,o,s,a,c,u);return[e.makeTensorInfo([x.length],"string",x),e.makeTensorInfo(m.shape,"int32",T)]}},M2e={kernelName:bI,backendName:"webgl",kernelFunc:function R2e(n){const{inputs:t,backend:e,attrs:r}=n,{skipEmpty:i}=r,{input:o,delimiter:s}=t;if("string"!==o.dtype)throw new Error("Input must be of datatype string");if(1!==o.shape.length)throw new Error(`Input must be a vector, got shape: ${o.shape}`);if(0!==s.shape.length)throw new Error(`Delimiter must be a scalar, got shape: ${s.shape}`);const a=e.readSync(o.dataId),c=e.readSync(s.dataId)[0],[u,p,m]=j1e(a,c,i),g=p.length;return[e.makeTensorInfo([g,2],"int32",u),e.makeTensorInfo([g],"string",p),e.makeTensorInfo([2],"int32",new Int32Array(m))]}},P2e={kernelName:yI,backendName:"webgl",kernelFunc:function F2e(n){const{inputs:t,backend:e,attrs:r}=n,{numBuckets:i}=r,{input:o}=t;if("string"!==o.dtype)throw new Error("Input must be of datatype string");if(i<=0)throw new Error("Number of buckets must be at least 1");const s=e.readSync(o.dataId),a=G1e(s,i);return e.makeTensorInfo(o.shape,"int32",a)}},$2e=Sn({opSnippet:"return tan(x);"}),L2e={kernelName:Zm,backendName:"webgl",kernelFunc:$2e},B2e=Sn({opSnippet:"\n  float e2x = exp(-2.0 * abs(x));\n  return sign(x) * (1.0 - e2x) / (1.0 + e2x);\n"}),V2e={kernelName:Qm,backendName:"webgl",kernelFunc:B2e},U2e={kernelName:aI,backendName:"webgl",kernelFunc:function z2e(n){const{inputs:t,backend:e}=n,{tensor:i,indices:o,updates:s}=t,{sliceRank:a,numUpdates:c,sliceSize:u,strides:p,outputSize:m}=Lu(0,o,i.shape),g=[m/u,u];if(0===m)return e.makeTensorInfo(i.shape,o.dtype);const _=lt({inputs:{x:o},backend:e,attrs:{shape:[c,a]}}),x=lt({inputs:{x:s},backend:e,attrs:{shape:[c,u]}}),T=lt({inputs:{x:i},backend:e,attrs:{shape:g}}),I=new oA(c,a,_.shape.length,x.shape.length,p,g,!1,!0),N=e.runWebGLProgram(I,[x,_,T],T.dtype),R=lt({inputs:{x:N},backend:e,attrs:{shape:i.shape}});return e.disposeIntermediateTensorInfo(_),e.disposeIntermediateTensorInfo(x),e.disposeIntermediateTensorInfo(T),e.disposeIntermediateTensorInfo(N),R}};class j2e{constructor(t,e){this.variableNames=["A"];const r=new Array(t.length);for(let s=0;s<r.length;s++)r[s]=t[s]*e[s];this.outputShape=r,this.rank=r.length;const i=jn(this.rank),o=function G2e(n){const t=n.length;if(t>5)throw Error(`Tile for rank ${t} is not yet supported`);if(1===t)return`imod(resRC, ${n[0]})`;const e=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"],r=[];for(let i=0;i<n.length;i++)r.push(`imod(${e[i]}, ${n[i]})`);return r.join()}(t);this.userCode=`\n      void main() {\n        ${i} resRC = getOutputCoords();\n        setOutput(getA(${o}));\n      }\n    `}}function TG(n){const{inputs:t,backend:e,attrs:r}=n,{x:i}=t,{reps:o}=r;if("string"===i.dtype||i.shape.length>5){const c=e.readSync(i.dataId),u="string"===i.dtype?c.map(g=>uc(g)):c,p=sn(i.shape,i.dtype,u),m=W1e(p,o);return e.makeTensorInfo(m.shape,m.dtype,m.values)}const s=new j2e(i.shape,o);return e.runWebGLProgram(s,[i],i.dtype)}const H2e={kernelName:Jm,backendName:"webgl",kernelFunc:TG};class W2e{constructor(t){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"negativeInf",type:"float"},{name:"dir",type:"int"},{name:"inc",type:"int"}],this.outputShape=t,this.userCode="\n       void main() {\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int elemIdx = coords[1];\n\n         // We compare elements pair-wise within a group of size 2 * inc.\n         // The comparing rule for each group alternates between ascending\n         // and descending. Within each group, we compare each pair at\n         // positions i and i+inc. To decide whether an element at position i\n         // is x0 or x1, we mod it by 2 * inc, if the result is smaller than\n         // inc, it is in the first half of the group, we denote it as x0,\n         // otherwise we denote it as x1.\n         // For example, as shown in the Bitonic top K paper referenced above,\n         // Figure5(a) shows that element[1] is in the\n         // second half of the group when group size is 2, but it is in the\n         // first half of the group when group size is 4.\n\n         bool isFirstInPair = imod(elemIdx, 2 * inc) < inc;\n         int i = isFirstInPair ? elemIdx : elemIdx - inc;\n\n         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));\n         int i1 = firstPass == 1 ? i + inc : int(getIndices(batch, i + inc));\n         float x0 = i0 < n ? getX(batch, i0) : negativeInf;\n         float x1 = i1 < n ? getX(batch, i1) : negativeInf;\n\n         // Denotes which direction indices are in (ascending or descending).\n         bool reverse = imod(elemIdx, 2 * dir) >= dir;\n         bool isGreater = x0 > x1 || (x0 == x1 && i1 > i0);\n         if (reverse == isGreater) { // Elements in opposite order of direction\n           int iTemp = i0;\n           i0 = i1;\n           i1 = iTemp;\n         }\n         if (isFirstInPair) {\n            setOutput(float(i0));\n         } else {\n            setOutput(float(i1));\n         }\n       }\n     "}}class q2e{constructor(t){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"k",type:"int"}],this.outputShape=t,this.userCode="\n    void main() {\n         // Takes max of indices (0, k), (1, k + 1), (2, k + 2) ...\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int elemIdx = coords[1];\n\n         // The output size is half of the previous size.\n         // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _ (k=4),\n         // we only need to output the indices at positions |, the indices at\n         // positions _ can be thrown away, see Figure5(b) After Phase 2\n         // (Merge phase) in the Bitonic Top K paper referenced above.\n         // For example, the paper shows we only need to output the orange bars.\n         // The output sequence should look like this | | | | | | | |.\n         // Because the sequence is halved, to map the output index back\n         // to the previous sequence to find the corresponding value,\n         // we need to double the index. When we double the index,\n         // we basically interpolate a position, so 2i looks like\n         // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k position\n         // of each 2k positions by - elemIdx % k. E.g. for output at\n         // index 4,5,6,7, we want to get the corresponding element at\n         // original index 8,9,10,11, for output at index 8,9,10,11,\n         // we want to get the corresponding element at original index\n         // 16,17,18,19, so on and so forth.\n\n         int i = elemIdx < k ? elemIdx : (elemIdx * 2 - imod(elemIdx, k));\n         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));\n         int i1 = firstPass == 1 ? i + k : int(getIndices(batch, i + k));\n\n         float x0 = getX(batch, i0);\n         float x1 = i1 < n ? getX(batch, i1) : x0;\n\n         setOutput(x0 >= x1 ? float(i0) : float(i1));\n       }\n     "}}function ed(n,t){null!==t&&n.disposeIntermediateTensorInfo(t)}function SG(n){let t=1;for(;t<n;)t*=2;return t}const X2e={kernelName:_I,backendName:"webgl",kernelFunc:function K2e(n){const{inputs:t,backend:e,attrs:r}=n,{x:i}=t,{k:o,sorted:s}=r,a=Ie().getNumber("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD"),c=Ie().getNumber("TOPK_K_CPU_HANDOFF_THRESHOLD"),u=i.shape,p=u[u.length-1];if(e.shouldExecuteOnCPU([i])||p<a||o>c){const he=e.readSync(i.dataId),[we,Ee]=q1e(he,u,i.dtype,o,s);return[e.makeTensorInfo(we.shape,we.dtype,we.values),e.makeTensorInfo(Ee.shape,Ee.dtype,Ee.values)]}if(0===o)return u[u.length-1]=0,[e.makeTensorInfo(u,i.dtype,[]),e.makeTensorInfo(u,"int32",[])];if(1===p)return[i,Xg({attrs:{shape:u,dtype:"int32",value:0},backend:e})];const m=e.texData.get(i.dataId),g=null!==m&&m.isPacked,_=g?e.unpackTensor(i):i,T=Me(u)/p,I=lt({inputs:{x:_},attrs:{shape:[T,p]},backend:e});g&&ed(e,_);const N=SG(o),R=SG(p);let L=null;const V=()=>null===L?[I,I]:[I,L],j=(he,we,Ee)=>{const Ae=V(),Oe=new W2e(Ee),Te=L;L=e.runWebGLProgram(Oe,Ae,"int32",[[p],[null===L?1:0],[Number.NEGATIVE_INFINITY],[he],[we]]),ed(e,Te)};for(let he=1;he<N;he*=2){const we=2*he;for(let Ee=he;Ee>=1;Ee/=2)j(we,Ee,[T,R])}for(let he=R;he>N;he/=2){const we=V(),Ee=new q2e([T,he/2]),Re=L;L=e.runWebGLProgram(Ee,we,"int32",[[p],[null===L?1:0],[N]]),ed(e,Re);const _e=N/2,Te=2*_e;for(let xe=_e;xe>=1;xe/=2)j(Te,xe,L.shape)}let Y=L;L=ap({inputs:{x:L},backend:e,attrs:{begin:0,size:[T,o]}}),ed(e,Y);let ee=hG({inputs:{x:I,indices:L},backend:e,attrs:{axis:1,batchDims:1}});ed(e,I);const ie=u.slice(0,-1);ie.push(o),Y=L,L=lt({inputs:{x:L},attrs:{shape:ie},backend:e}),ed(e,Y);const ce=ee;return ee=lt({inputs:{x:ee},attrs:{shape:ie},backend:e}),ed(e,ce),[ee,L]}};class Y2e{constructor(t,e,r,i,o,s){this.variableNames=["Image","Transforms"],this.outputShape=s;const a="nearest"===r?1:2;let c;switch(i){case"constant":default:c=1;break;case"reflect":c=2;break;case"wrap":c=3;break;case"nearest":c=4}this.userCode=`\n            float mapCoord(float outCoord, float len) {\n              float inCoord = outCoord;\n              if(${c} == 2) {\n                if (inCoord < 0.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz2 = 2.0 * len;\n                    if (inCoord < sz2) {\n                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +\n                      inCoord;\n                    }\n                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;\n                  }\n                } else if (inCoord > len - 1.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz2 = 2.0 * len;\n                    inCoord -= sz2 * float(int(float(inCoord / sz2)));\n                    if (inCoord >= len) {\n                      inCoord = sz2 - inCoord - 1.0;\n                    }\n                  }\n                }\n                return clamp(inCoord, 0.0, len - 1.0);\n              } else if (${c} == 3) {\n                if (inCoord < 0.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz = len - 1.0;\n                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);\n                  }\n                } else if (inCoord > len - 1.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz = len - 1.0;\n                    inCoord -= len * float(int(float(inCoord / sz)));\n                  }\n                }\n                return clamp(inCoord, 0.0, len - 1.0);\n              } else if (${c} == 4) {\n                return clamp(outCoord, 0.0, len - 1.0);\n              } else {\n                return outCoord;\n              }\n            }\n\n            float readWithFillValue(int batch, int coordY, int coordX,\n              int channel) {\n              float outputValue;\n              if (0 <= coordY && coordY < ${t} && 0 <= coordX && coordX < ${e}) {\n                  outputValue = getImage(batch, coordY, coordX, channel);\n              } else {\n                outputValue = float(${o});\n              }\n              return outputValue;\n            }\n\n            void main() {\n              ivec4 coords = getOutputCoords();\n              float outputValue;\n              int batch = coords[0];\n              int x = coords[2];\n              int y = coords[1];\n              int channel = coords[3];\n              float xf = float(x);\n              float yf = float(y);\n              float a1 = getTransforms(batch, 0);\n              float a2 = getTransforms(batch, 1);\n              float a3 = getTransforms(batch, 2);\n              float b1 = getTransforms(batch, 3);\n              float b2 = getTransforms(batch, 4);\n              float b3 = getTransforms(batch, 5);\n              float c1 = getTransforms(batch, 6);\n              float c2 = getTransforms(batch, 7);\n              float projection = c1 * xf + c2 * yf + 1.0;\n              if (projection == 0.0) {\n                outputValue = float(${o});\n              } else {\n                float inX = (a1 * xf + a2 * yf + a3) / projection;\n                float inY = (b1 * xf + b2 * yf + b3) / projection;\n                float mapX = mapCoord(inX, float(${e}));\n                float mapY = mapCoord(inY, float(${t}));\n\n                if (${a} == 1) {\n                  int coordY = int(round(mapY));\n                  int coordX = int(round(mapX));\n                  outputValue = readWithFillValue(batch, coordY, coordX,\n                    channel);\n                } else {\n                  float yFloor = floor(mapY);\n                  float xFloor = floor(mapX);\n                  float yCeil = yFloor + 1.0;\n                  float xCeil = xFloor + 1.0;\n                  float valueYFloor = (xCeil - mapX) *\n                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);\n                  float valueYCeil = (xCeil - mapX) *\n                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);\n                  outputValue = (yCeil - mapY) * valueYFloor +\n                  (mapY - yFloor) * valueYCeil;\n                }\n              }\n              setOutput(outputValue);\n            }\n        `}}const Q2e={kernelName:vI,backendName:"webgl",kernelFunc:function Z2e(n){const{inputs:t,backend:e,attrs:r}=n,{image:i,transforms:o}=t,{interpolation:s,fillMode:a,fillValue:c,outputShape:u}=r,[p,m,g,_]=i.shape,[x,T]=u??[m,g],N=new Y2e(m,g,s,a,c,[p,x,T,_]);return e.runWebGLProgram(N,[i,o],"float32")}},eNe={kernelName:xI,backendName:"webgl",kernelFunc:function J2e(n){const{inputs:t,attrs:e,backend:r}=n,{axis:i}=e,{x:o}=t;Ug(o,"unique"),console.warn("WARNING: ","UI might be locked temporarily as data is being downloaded");const s=r.readSync(o.dataId),{outputValues:a,outputShape:c,indices:u}=K1e(s,i,o.shape,o.dtype);return[r.makeTensorInfo(c,o.dtype,a),r.makeTensorInfo([u.length],"int32",u)]}},nNe={kernelName:R0,backendName:"webgl",kernelFunc:function tNe(n){const{inputs:t,backend:e,attrs:r}=n,{value:i}=t;let{axis:o}=r;o<0&&(o+=i.shape.length);const s=i,a=s.shape.length,c=i.shape[o],u=new Array(a-1);let p=0;for(let T=0;T<a;T++)T!==o&&(u[p++]=s.shape[T]);const m=[],g=new Array(a).fill(0),_=s.shape.slice();_[o]=1;const x=new Array(c);for(let T=0;T<x.length;T++){g[o]=T;const I=ap({inputs:{x:s},backend:e,attrs:{begin:g,size:_}}),N=lt({inputs:{x:I},backend:e,attrs:{shape:u}});x[T]=N,m.push(I)}return m.forEach(T=>e.disposeIntermediateTensorInfo(T)),x}};class rNe{constructor(t,e){this.variableNames=["x","segmentIds"];const r=t.windowSize,i=t.batchSize,o=t.inSize,s=t.numSegments,a=s*Math.ceil(o/r);this.outputShape=[i,a];const p=4*Math.floor(r/4),m=r%4,g="\n        sumValue += dot(values, segFilter);\n    ";let _="";o%r>0&&(_=`\n        if (inIdx < 0 || inIdx >= ${o}) {\n          return initializationValue;\n        }\n      `);let x="";o%r>0&&(x=`\n        if (inIdx < 0 || inIdx >= ${o}) {\n          return -1.0;\n        }\n      `),this.userCode=`\n      const float initializationValue = 0.0;\n\n      float getValue(int batch, int inIdx) {\n        ${_}\n        return getX(batch, inIdx);\n      }\n\n      float getSegmentIdAtIndex(int inIdx) {\n        ${x}\n        return getSegmentIds(inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = int(floor(float(outIdx) / float(\n          ${s})) * float(${r}));\n        int currentSeg = int(mod(float(outIdx), float(${s})));\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ${p}; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0\n          );\n\n          ${g}\n        }\n\n        int inIdx = inOffset + ${p};\n        if (${1===m}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            0,\n            0,\n            0\n          );\n\n          ${g}\n        } else if (${2===m}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n              0,\n              0\n          );\n\n          ${g}\n        } else if (${3===m}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            0\n          );\n\n          ${g}\n        }\n        setOutput(sumValue);\n      }\n    `}}const sNe=[USe,GSe,qSe,YSe,QSe,tCe,rCe,oCe,cCe,dCe,fCe,bCe,vCe,SCe,ECe,kCe,NCe,FCe,$Ce,BCe,UCe,KCe,YCe,QCe,rIe,oIe,cIe,CSe,hIe,bIe,xIe,EIe,AIe,OIe,MIe,PIe,VIe,UIe,GIe,WIe,KIe,YIe,JIe,tEe,oEe,aEe,uEe,pEe,mEe,bEe,vEe,wEe,CEe,EEe,DEe,AEe,OEe,MEe,PEe,LEe,VEe,jEe,WEe,KEe,ZEe,eDe,nDe,iDe,SSe,sDe,mIe,lDe,uDe,hDe,ESe,fDe,gDe,yDe,xDe,SDe,IDe,DDe,ADe,RDe,FDe,$De,zDe,jDe,HDe,XDe,ZDe,JDe,tke,rke,ake,uke,fke,vke,ASe,Ske,Eke,Ake,Rke,JCe,Fke,$ke,Bke,Uke,Wke,kSe,Kke,Yke,Qke,eAe,tAe,eIe,gke,rAe,sAe,cAe,OSe,pAe,gAe,vAe,TAe,EAe,kAe,NAe,RAe,PAe,BAe,UAe,HAe,KAe,YAe,e2e,n2e,qCe,yke,i2e,o2e,a2e,c2e,d2e,p2e,m2e,b2e,_2e,x2e,T2e,C2e,E2e,A2e,O2e,M2e,P2e,bke,BSe,L2e,V2e,U2e,H2e,X2e,Q2e,VSe,eNe,nNe,{kernelName:M0,backendName:"webgl",kernelFunc:function iNe(n){const{inputs:t,backend:e,attrs:r}=n,{x:i,segmentIds:o}=t,{numSegments:s}=r,a=i.shape.length,c=[];let u=0;const p=hr([u],a);let m=i;null!=p&&(m=lo({inputs:{x:i},backend:e,attrs:{perm:p}}),c.push(m),u=Mr(1,a)[0]);const g=zV(m.shape,u,s),_=Me([m.shape[u]]),x=lt({inputs:{x:m},backend:e,attrs:{shape:[-1,_]}});c.push(x);const T=DI(i.dtype),I=(V,j,Y,ee,ie)=>{const ce=V.shape[0],he=V.shape[1],we=VV(he,ie),Ae=new rNe({windowSize:we,inSize:he,batchSize:ce,numSegments:ie},j),Oe=e.compileAndRun(Ae,[V,Y],ee);if(c.push(Oe),Oe.shape[1]===ie)return Oe;const Re=vG({backend:e,attrs:{start:0,stop:ie,step:1,dtype:"float32"}}),_e=TG({inputs:{x:Re},backend:e,attrs:{reps:[he/we]}});return c.push(Re),c.push(_e),I(Oe,j,_e,ee,ie)},R=lt({inputs:{x:I(x,"unsortedSegmentSum",o,T,s)},backend:e,attrs:{shape:g}});let L=R;if(null!=p){c.push(R);const V=Sc(p);L=lo({inputs:{x:L},backend:e,attrs:{perm:V}})}return c.forEach(V=>e.disposeIntermediateTensorInfo(V)),L}},Pke];for(const n of sNe)SI(n);const lNe={hipbreadthsitting:{.1:"assets/confidence_models/lightgbm_model_hipbreadthsitting_0.1_1-2-2024.onnx",.5:"assets/confidence_models/lightgbm_model_hipbreadthsitting_0.5_1-2-2024.onnx",.9:"assets/confidence_models/lightgbm_model_hipbreadthsitting_0.9_1-2-2024.onnx"},bideltoidbreadth:{.1:"assets/confidence_models/lightgbm_model_bideltoidbreadth_0.1_1-19-2024.onnx",.5:"assets/confidence_models/lightgbm_model_bideltoidbreadth_0.5_1-19-2024.onnx",.9:"assets/confidence_models/lightgbm_model_bideltoidbreadth_0.9_1-19-2024.onnx"},chestbreadth:{.1:"assets/confidence_models/lightgbm_model_chestbreadth_0.1_1-19-2024.onnx",.5:"assets/confidence_models/lightgbm_model_chestbreadth_0.5_1-19-2024.onnx",.9:"assets/confidence_models/lightgbm_model_chestbreadth_0.9_1-19-2024.onnx"},sittingheight:{.1:"assets/confidence_models/lightgbm_model_sittingheight_0.1_1-19-2024.onnx",.5:"assets/confidence_models/lightgbm_model_sittingheight_0.5_1-19-2024.onnx",.9:"assets/confidence_models/lightgbm_model_sittingheight_0.9_1-19-2024.onnx"},buttockpopliteallength:{.1:"assets/confidence_models/lightgbm_model_buttockpopliteallength_0.1_1-19-2024.onnx",.5:"assets/confidence_models/lightgbm_model_buttockpopliteallength_0.5_1-19-2024.onnx",.9:"assets/confidence_models/lightgbm_model_buttockpopliteallength_0.9_1-19-2024.onnx"},thighclearance:{.1:"assets/confidence_models/lightgbm_model_thighclearance_0.1_1-19-2024.onnx",.5:"assets/confidence_models/lightgbm_model_thighclearance_0.5_1-19-2024.onnx",.9:"assets/confidence_models/lightgbm_model_thighclearance_0.9_1-19-2024.onnx"},tibialheight:{.1:"assets/confidence_models/lightgbm_model_tibialheight_0.1_1-19-2024.onnx",.5:"assets/confidence_models/lightgbm_model_tibialheight_0.5_1-19-2024.onnx",.9:"assets/confidence_models/lightgbm_model_tibialheight_0.9_1-19-2024.onnx"},buttockkneelength:{.1:"assets/confidence_models/lightgbm_model_buttockkneelength_0.1_1-19-2024.onnx",.5:"assets/confidence_models/lightgbm_model_buttockkneelength_0.5_1-19-2024.onnx",.9:"assets/confidence_models/lightgbm_model_buttockkneelength_0.9_1-19-2024.onnx"},elbowrestheight:{.1:"assets/confidence_models/lightgbm_model_elbowrestheight_0.1_1-19-2024.onnx",.5:"assets/confidence_models/lightgbm_model_elbowrestheight_0.5_1-19-2024.onnx",.9:"assets/confidence_models/lightgbm_model_elbowrestheight_0.9_1-19-2024.onnx"},kneeheightsitting:{.1:"assets/confidence_models/lightgbm_model_kneeheightsitting_0.1_1-19-2024.onnx",.5:"assets/confidence_models/lightgbm_model_kneeheightsitting_0.5_1-19-2024.onnx",.9:"assets/confidence_models/lightgbm_model_kneeheightsitting_0.9_1-19-2024.onnx"},poplitealheight:{.1:"assets/confidence_models/lightgbm_model_poplitealheight_0.1_1-29-2024.onnx",.5:"assets/confidence_models/lightgbm_model_poplitealheight_0.5_1-29-2024.onnx",.9:"assets/confidence_models/lightgbm_model_poplitealheight_0.9_1-29-2024.onnx"}};class cNe{}function gr(n){return null!=n&&"false"!=`${n}`}function yi(n,t=0){return function uNe(n){return!isNaN(parseFloat(n))&&!isNaN(Number(n))}(n)?Number(n):t}function Ix(n){return Array.isArray(n)?n:[n]}function li(n){return null==n?"":"string"==typeof n?n:`${n}px`}function Ol(n){return n instanceof yn?n.nativeElement:n}const dNe=["addListener","removeListener"],hNe=["addEventListener","removeEventListener"],pNe=["on","off"];function cp(n,t,e,r){if(K(e)&&(r=e,e=void 0),r)return cp(n,t,e).pipe(PS(r));const[i,o]=function gNe(n){return K(n.addEventListener)&&K(n.removeEventListener)}(n)?hNe.map(s=>a=>n[s](t,a,e)):function fNe(n){return K(n.addListener)&&K(n.removeListener)}(n)?dNe.map(CG(n,t)):function mNe(n){return K(n.on)&&K(n.off)}(n)?pNe.map(CG(n,t)):[];if(!i&&Tp(n))return yr(s=>cp(s,t,e))(wi(n));if(!i)throw new TypeError("Invalid event target");return new An(s=>{const a=(...c)=>s.next(1<c.length?c:c[0]);return i(a),()=>o(a)})}function CG(n,t){return e=>r=>n[e](t,r)}class bNe extends le{constructor(t,e){super()}schedule(t,e=0){return this}}const Ex={setInterval(n,t,...e){const{delegate:r}=Ex;return r?.setInterval?r.setInterval(n,t,...e):setInterval(n,t,...e)},clearInterval(n){const{delegate:t}=Ex;return(t?.clearInterval||clearInterval)(n)},delegate:void 0};class sA extends bNe{constructor(t,e){super(t,e),this.scheduler=t,this.work=e,this.pending=!1}schedule(t,e=0){var r;if(this.closed)return this;this.state=t;const i=this.id,o=this.scheduler;return null!=i&&(this.id=this.recycleAsyncId(o,i,e)),this.pending=!0,this.delay=e,this.id=null!==(r=this.id)&&void 0!==r?r:this.requestAsyncId(o,this.id,e),this}requestAsyncId(t,e,r=0){return Ex.setInterval(t.flush.bind(t,this),r)}recycleAsyncId(t,e,r=0){if(null!=r&&this.delay===r&&!1===this.pending)return e;null!=e&&Ex.clearInterval(e)}execute(t,e){if(this.closed)return new Error("executing a cancelled action");this.pending=!1;const r=this._execute(t,e);if(r)return r;!1===this.pending&&null!=this.id&&(this.id=this.recycleAsyncId(this.scheduler,this.id,null))}_execute(t,e){let i,r=!1;try{this.work(t)}catch(o){r=!0,i=o||new Error("Scheduled action threw falsy error")}if(r)return this.unsubscribe(),i}unsubscribe(){if(!this.closed){const{id:t,scheduler:e}=this,{actions:r}=e;this.work=this.state=this.scheduler=null,this.pending=!1,re(r,this),null!=t&&(this.id=this.recycleAsyncId(e,t,null)),this.delay=null,super.unsubscribe()}}}const Yg={schedule(n){let t=requestAnimationFrame,e=cancelAnimationFrame;const{delegate:r}=Yg;r&&(t=r.requestAnimationFrame,e=r.cancelAnimationFrame);const i=t(o=>{e=void 0,n(o)});return new le(()=>e?.(i))},requestAnimationFrame(...n){const{delegate:t}=Yg;return(t?.requestAnimationFrame||requestAnimationFrame)(...n)},cancelAnimationFrame(...n){const{delegate:t}=Yg;return(t?.cancelAnimationFrame||cancelAnimationFrame)(...n)},delegate:void 0},IG={now:()=>(IG.delegate||Date).now(),delegate:void 0};class Zg{constructor(t,e=Zg.now){this.schedulerActionCtor=t,this.now=e}schedule(t,e=0,r){return new this.schedulerActionCtor(this,t).schedule(r,e)}}Zg.now=IG.now;class aA extends Zg{constructor(t,e=Zg.now){super(t,e),this.actions=[],this._active=!1}flush(t){const{actions:e}=this;if(this._active)return void e.push(t);let r;this._active=!0;do{if(r=t.execute(t.state,t.delay))break}while(t=e.shift());if(this._active=!1,r){for(;t=e.shift();)t.unsubscribe();throw r}}}new class _Ne extends aA{flush(t){this._active=!0;const e=this._scheduled;this._scheduled=void 0;const{actions:r}=this;let i;t=t||r.shift();do{if(i=t.execute(t.state,t.delay))break}while((t=r[0])&&t.id===e&&r.shift());if(this._active=!1,i){for(;(t=r[0])&&t.id===e&&r.shift();)t.unsubscribe();throw i}}}(class yNe extends sA{constructor(t,e){super(t,e),this.scheduler=t,this.work=e}requestAsyncId(t,e,r=0){return null!==r&&r>0?super.requestAsyncId(t,e,r):(t.actions.push(this),t._scheduled||(t._scheduled=Yg.requestAnimationFrame(()=>t.flush(void 0))))}recycleAsyncId(t,e,r=0){var i;if(null!=r?r>0:this.delay>0)return super.recycleAsyncId(t,e,r);const{actions:o}=t;null!=e&&(null===(i=o[o.length-1])||void 0===i?void 0:i.id)!==e&&(Yg.cancelAnimationFrame(e),t._scheduled=void 0)}});let lA,xNe=1;const Dx={};function EG(n){return n in Dx&&(delete Dx[n],!0)}const wNe={setImmediate(n){const t=xNe++;return Dx[t]=!0,lA||(lA=Promise.resolve()),lA.then(()=>EG(t)&&n()),t},clearImmediate(n){EG(n)}},{setImmediate:TNe,clearImmediate:SNe}=wNe,kx={setImmediate(...n){const{delegate:t}=kx;return(t?.setImmediate||TNe)(...n)},clearImmediate(n){const{delegate:t}=kx;return(t?.clearImmediate||SNe)(n)},delegate:void 0},cA=(new class INe extends aA{flush(t){this._active=!0;const e=this._scheduled;this._scheduled=void 0;const{actions:r}=this;let i;t=t||r.shift();do{if(i=t.execute(t.state,t.delay))break}while((t=r[0])&&t.id===e&&r.shift());if(this._active=!1,i){for(;(t=r[0])&&t.id===e&&r.shift();)t.unsubscribe();throw i}}}(class CNe extends sA{constructor(t,e){super(t,e),this.scheduler=t,this.work=e}requestAsyncId(t,e,r=0){return null!==r&&r>0?super.requestAsyncId(t,e,r):(t.actions.push(this),t._scheduled||(t._scheduled=kx.setImmediate(t.flush.bind(t,void 0))))}recycleAsyncId(t,e,r=0){var i;if(null!=r?r>0:this.delay>0)return super.recycleAsyncId(t,e,r);const{actions:o}=t;null!=e&&(null===(i=o[o.length-1])||void 0===i?void 0:i.id)!==e&&(kx.clearImmediate(e),t._scheduled===e&&(t._scheduled=void 0))}}),new aA(sA)),DNe=cA;function DG(n=0,t,e=DNe){let r=-1;return null!=t&&(gd(t)?e=t:r=t),new An(i=>{let o=function ANe(n){return n instanceof Date&&!isNaN(n)}(n)?+n-e.now():n;o<0&&(o=0);let s=0;return e.schedule(function(){i.closed||(i.next(s++),0<=r?this.schedule(void 0,r):i.complete())},o)})}function kG(n,t=cA){return function kNe(n){return Rn((t,e)=>{let r=!1,i=null,o=null,s=!1;const a=()=>{if(o?.unsubscribe(),o=null,r){r=!1;const u=i;i=null,e.next(u)}s&&e.complete()},c=()=>{o=null,s&&e.complete()};t.subscribe(Bn(e,u=>{r=!0,i=u,o||wi(n(u)).subscribe(o=Bn(e,a,c))},()=>{s=!0,(!r||!o||o.closed)&&e.complete()}))})}(()=>DG(n,t))}let uA;try{uA=typeof Intl<"u"&&Intl.v8BreakIterator}catch{uA=!1}let up,Wi=(()=>{class n{constructor(e){this._platformId=e,this.isBrowser=this._platformId?function _J(n){return n===p$}(this._platformId):"object"==typeof document&&!!document,this.EDGE=this.isBrowser&&/(edge)/i.test(navigator.userAgent),this.TRIDENT=this.isBrowser&&/(msie|trident)/i.test(navigator.userAgent),this.BLINK=this.isBrowser&&!(!window.chrome&&!uA)&&typeof CSS<"u"&&!this.EDGE&&!this.TRIDENT,this.WEBKIT=this.isBrowser&&/AppleWebKit/i.test(navigator.userAgent)&&!this.BLINK&&!this.EDGE&&!this.TRIDENT,this.IOS=this.isBrowser&&/iPad|iPhone|iPod/.test(navigator.userAgent)&&!("MSStream"in window),this.FIREFOX=this.isBrowser&&/(firefox|minefield)/i.test(navigator.userAgent),this.ANDROID=this.isBrowser&&/android/i.test(navigator.userAgent)&&!this.TRIDENT,this.SAFARI=this.isBrowser&&/safari/i.test(navigator.userAgent)&&this.WEBKIT}}return n.\u0275fac=function(e){return new(e||n)(Fe(Vd))},n.\u0275prov=at({token:n,factory:n.\u0275fac,providedIn:"root"}),n})();const AG=["color","button","checkbox","date","datetime-local","email","file","hidden","image","month","number","password","radio","range","reset","search","submit","tel","text","time","url","week"];function NG(){if(up)return up;if("object"!=typeof document||!document)return up=new Set(AG),up;let n=document.createElement("input");return up=new Set(AG.filter(t=>(n.setAttribute("type",t),n.type===t))),up}let Qg,td,dA;function dp(n){return function NNe(){if(null==Qg&&typeof window<"u")try{window.addEventListener("test",null,Object.defineProperty({},"passive",{get:()=>Qg=!0}))}finally{Qg=Qg||!1}return Qg}()?n:!!n.capture}function ONe(){if(null==td){if("object"!=typeof document||!document||"function"!=typeof Element||!Element)return td=!1,td;if("scrollBehavior"in document.documentElement.style)td=!0;else{const n=Element.prototype.scrollTo;td=!!n&&!/\{\s*\[native code\]\s*\}/.test(n.toString())}}return td}function hA(){let n=typeof document<"u"&&document?document.activeElement:null;for(;n&&n.shadowRoot;){const t=n.shadowRoot.activeElement;if(t===n)break;n=t}return n}function Uc(n){return n.composedPath?n.composedPath()[0]:n.target}function pA(){return typeof __karma__<"u"&&!!__karma__||typeof jasmine<"u"&&!!jasmine||typeof jest<"u"&&!!jest||typeof Mocha<"u"&&!!Mocha}const FNe=new Qe("cdk-dir-doc",{providedIn:"root",factory:function PNe(){return It(Tn)}}),$Ne=/^(ar|ckb|dv|he|iw|fa|nqo|ps|sd|ug|ur|yi|.*[-_](Adlm|Arab|Hebr|Nkoo|Rohg|Thaa))(?!.*[-_](Latn|Cyrl)($|-|_))($|-|_)/i;let Rl=(()=>{class n{constructor(e){this.value="ltr",this.change=new rn,e&&(this.value=function LNe(n){const t=n?.toLowerCase()||"";return"auto"===t&&typeof navigator<"u"&&navigator?.language?$Ne.test(navigator.language)?"rtl":"ltr":"rtl"===t?"rtl":"ltr"}((e.body?e.body.dir:null)||(e.documentElement?e.documentElement.dir:null)||"ltr"))}ngOnDestroy(){this.change.complete()}}return n.\u0275fac=function(e){return new(e||n)(Fe(FNe,8))},n.\u0275prov=at({token:n,factory:n.\u0275fac,providedIn:"root"}),n})(),Jg=(()=>{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275mod=Vn({type:n}),n.\u0275inj=Pn({}),n})(),VNe=(()=>{class n{constructor(e,r,i){this._ngZone=e,this._platform=r,this._scrolled=new Kt,this._globalSubscription=null,this._scrolledCount=0,this.scrollContainers=new Map,this._document=i}register(e){this.scrollContainers.has(e)||this.scrollContainers.set(e,e.elementScrolled().subscribe(()=>this._scrolled.next(e)))}deregister(e){const r=this.scrollContainers.get(e);r&&(r.unsubscribe(),this.scrollContainers.delete(e))}scrolled(e=20){return this._platform.isBrowser?new An(r=>{this._globalSubscription||this._addGlobalListener();const i=e>0?this._scrolled.pipe(kG(e)).subscribe(r):this._scrolled.subscribe(r);return this._scrolledCount++,()=>{i.unsubscribe(),this._scrolledCount--,this._scrolledCount||this._removeGlobalListener()}}):jt()}ngOnDestroy(){this._removeGlobalListener(),this.scrollContainers.forEach((e,r)=>this.deregister(r)),this._scrolled.complete()}ancestorScrolled(e,r){const i=this.getAncestorScrollContainers(e);return this.scrolled(r).pipe(zi(o=>!o||i.indexOf(o)>-1))}getAncestorScrollContainers(e){const r=[];return this.scrollContainers.forEach((i,o)=>{this._scrollableContainsElement(o,e)&&r.push(o)}),r}_getWindow(){return this._document.defaultView||window}_scrollableContainsElement(e,r){let i=Ol(r),o=e.getElementRef().nativeElement;do{if(i==o)return!0}while(i=i.parentElement);return!1}_addGlobalListener(){this._globalSubscription=this._ngZone.runOutsideAngular(()=>cp(this._getWindow().document,"scroll").subscribe(()=>this._scrolled.next()))}_removeGlobalListener(){this._globalSubscription&&(this._globalSubscription.unsubscribe(),this._globalSubscription=null)}}return n.\u0275fac=function(e){return new(e||n)(Fe(Vt),Fe(Wi),Fe(Tn,8))},n.\u0275prov=at({token:n,factory:n.\u0275fac,providedIn:"root"}),n})(),eb=(()=>{class n{constructor(e,r,i){this._platform=e,this._change=new Kt,this._changeListener=o=>{this._change.next(o)},this._document=i,r.runOutsideAngular(()=>{if(e.isBrowser){const o=this._getWindow();o.addEventListener("resize",this._changeListener),o.addEventListener("orientationchange",this._changeListener)}this.change().subscribe(()=>this._viewportSize=null)})}ngOnDestroy(){if(this._platform.isBrowser){const e=this._getWindow();e.removeEventListener("resize",this._changeListener),e.removeEventListener("orientationchange",this._changeListener)}this._change.complete()}getViewportSize(){this._viewportSize||this._updateViewportSize();const e={width:this._viewportSize.width,height:this._viewportSize.height};return this._platform.isBrowser||(this._viewportSize=null),e}getViewportRect(){const e=this.getViewportScrollPosition(),{width:r,height:i}=this.getViewportSize();return{top:e.top,left:e.left,bottom:e.top+i,right:e.left+r,height:i,width:r}}getViewportScrollPosition(){if(!this._platform.isBrowser)return{top:0,left:0};const e=this._document,r=this._getWindow(),i=e.documentElement,o=i.getBoundingClientRect();return{top:-o.top||e.body.scrollTop||r.scrollY||i.scrollTop||0,left:-o.left||e.body.scrollLeft||r.scrollX||i.scrollLeft||0}}change(e=20){return e>0?this._change.pipe(kG(e)):this._change}_getWindow(){return this._document.defaultView||window}_updateViewportSize(){const e=this._getWindow();this._viewportSize=this._platform.isBrowser?{width:e.innerWidth,height:e.innerHeight}:{width:0,height:0}}}return n.\u0275fac=function(e){return new(e||n)(Fe(Wi),Fe(Vt),Fe(Tn,8))},n.\u0275prov=at({token:n,factory:n.\u0275fac,providedIn:"root"}),n})(),OG=(()=>{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275mod=Vn({type:n}),n.\u0275inj=Pn({}),n})(),RG=(()=>{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275mod=Vn({type:n}),n.\u0275inj=Pn({imports:[Jg,OG,Jg,OG]}),n})();function jc(n){return Rn((t,e)=>{wi(n).subscribe(Bn(e,()=>e.complete(),wt)),!e.closed&&t.subscribe(e)})}class fA{attach(t){return this._attachedHost=t,t.attach(this)}detach(){let t=this._attachedHost;null!=t&&(this._attachedHost=null,t.detach())}get isAttached(){return null!=this._attachedHost}setAttachedHost(t){this._attachedHost=t}}class mA extends fA{constructor(t,e,r,i,o){super(),this.component=t,this.viewContainerRef=e,this.injector=r,this.componentFactoryResolver=i,this.projectableNodes=o}}class Nx extends fA{constructor(t,e,r,i){super(),this.templateRef=t,this.viewContainerRef=e,this.context=r,this.injector=i}get origin(){return this.templateRef.elementRef}attach(t,e=this.context){return this.context=e,super.attach(t)}detach(){return this.context=void 0,super.detach()}}class UNe extends fA{constructor(t){super(),this.element=t instanceof yn?t.nativeElement:t}}class gA{constructor(){this._isDisposed=!1,this.attachDomPortal=null}hasAttached(){return!!this._attachedPortal}attach(t){return t instanceof mA?(this._attachedPortal=t,this.attachComponentPortal(t)):t instanceof Nx?(this._attachedPortal=t,this.attachTemplatePortal(t)):this.attachDomPortal&&t instanceof UNe?(this._attachedPortal=t,this.attachDomPortal(t)):void 0}detach(){this._attachedPortal&&(this._attachedPortal.setAttachedHost(null),this._attachedPortal=null),this._invokeDisposeFn()}dispose(){this.hasAttached()&&this.detach(),this._invokeDisposeFn(),this._isDisposed=!0}setDisposeFn(t){this._disposeFn=t}_invokeDisposeFn(){this._disposeFn&&(this._disposeFn(),this._disposeFn=null)}}class jNe extends gA{constructor(t,e,r,i,o){super(),this.outletElement=t,this._componentFactoryResolver=e,this._appRef=r,this._defaultInjector=i,this.attachDomPortal=s=>{const a=s.element,c=this._document.createComment("dom-portal");a.parentNode.insertBefore(c,a),this.outletElement.appendChild(a),this._attachedPortal=s,super.setDisposeFn(()=>{c.parentNode&&c.parentNode.replaceChild(a,c)})},this._document=o}attachComponentPortal(t){const r=(t.componentFactoryResolver||this._componentFactoryResolver).resolveComponentFactory(t.component);let i;return t.viewContainerRef?(i=t.viewContainerRef.createComponent(r,t.viewContainerRef.length,t.injector||t.viewContainerRef.injector,t.projectableNodes||void 0),this.setDisposeFn(()=>i.destroy())):(i=r.create(t.injector||this._defaultInjector||Qi.NULL),this._appRef.attachView(i.hostView),this.setDisposeFn(()=>{this._appRef.viewCount>0&&this._appRef.detachView(i.hostView),i.destroy()})),this.outletElement.appendChild(this._getComponentRootNode(i)),this._attachedPortal=t,i}attachTemplatePortal(t){let e=t.viewContainerRef,r=e.createEmbeddedView(t.templateRef,t.context,{injector:t.injector});return r.rootNodes.forEach(i=>this.outletElement.appendChild(i)),r.detectChanges(),this.setDisposeFn(()=>{let i=e.indexOf(r);-1!==i&&e.remove(i)}),this._attachedPortal=t,r}dispose(){super.dispose(),this.outletElement.remove()}_getComponentRootNode(t){return t.hostView.rootNodes[0]}}let GNe=(()=>{class n extends Nx{constructor(e,r){super(e,r)}}return n.\u0275fac=function(e){return new(e||n)(de(_o),de(eo))},n.\u0275dir=_t({type:n,selectors:[["","cdkPortal",""]],exportAs:["cdkPortal"],features:[$t]}),n})(),hp=(()=>{class n extends gA{constructor(e,r,i){super(),this._componentFactoryResolver=e,this._viewContainerRef=r,this._isInitialized=!1,this.attached=new rn,this.attachDomPortal=o=>{const s=o.element,a=this._document.createComment("dom-portal");o.setAttachedHost(this),s.parentNode.insertBefore(a,s),this._getRootNode().appendChild(s),this._attachedPortal=o,super.setDisposeFn(()=>{a.parentNode&&a.parentNode.replaceChild(s,a)})},this._document=i}get portal(){return this._attachedPortal}set portal(e){this.hasAttached()&&!e&&!this._isInitialized||(this.hasAttached()&&super.detach(),e&&super.attach(e),this._attachedPortal=e||null)}get attachedRef(){return this._attachedRef}ngOnInit(){this._isInitialized=!0}ngOnDestroy(){super.dispose(),this._attachedRef=this._attachedPortal=null}attachComponentPortal(e){e.setAttachedHost(this);const r=null!=e.viewContainerRef?e.viewContainerRef:this._viewContainerRef,o=(e.componentFactoryResolver||this._componentFactoryResolver).resolveComponentFactory(e.component),s=r.createComponent(o,r.length,e.injector||r.injector,e.projectableNodes||void 0);return r!==this._viewContainerRef&&this._getRootNode().appendChild(s.hostView.rootNodes[0]),super.setDisposeFn(()=>s.destroy()),this._attachedPortal=e,this._attachedRef=s,this.attached.emit(s),s}attachTemplatePortal(e){e.setAttachedHost(this);const r=this._viewContainerRef.createEmbeddedView(e.templateRef,e.context,{injector:e.injector});return super.setDisposeFn(()=>this._viewContainerRef.clear()),this._attachedPortal=e,this._attachedRef=r,this.attached.emit(r),r}_getRootNode(){const e=this._viewContainerRef.element.nativeElement;return e.nodeType===e.ELEMENT_NODE?e:e.parentNode}}return n.\u0275fac=function(e){return new(e||n)(de(du),de(eo),de(Tn))},n.\u0275dir=_t({type:n,selectors:[["","cdkPortalOutlet",""]],inputs:{portal:["cdkPortalOutlet","portal"]},outputs:{attached:"attached"},exportAs:["cdkPortalOutlet"],features:[$t]}),n})(),tb=(()=>{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275mod=Vn({type:n}),n.\u0275inj=Pn({}),n})();const MG=ONe();class HNe{constructor(t,e){this._viewportRuler=t,this._previousHTMLStyles={top:"",left:""},this._isEnabled=!1,this._document=e}attach(){}enable(){if(this._canBeEnabled()){const t=this._document.documentElement;this._previousScrollPosition=this._viewportRuler.getViewportScrollPosition(),this._previousHTMLStyles.left=t.style.left||"",this._previousHTMLStyles.top=t.style.top||"",t.style.left=li(-this._previousScrollPosition.left),t.style.top=li(-this._previousScrollPosition.top),t.classList.add("cdk-global-scrollblock"),this._isEnabled=!0}}disable(){if(this._isEnabled){const t=this._document.documentElement,r=t.style,i=this._document.body.style,o=r.scrollBehavior||"",s=i.scrollBehavior||"";this._isEnabled=!1,r.left=this._previousHTMLStyles.left,r.top=this._previousHTMLStyles.top,t.classList.remove("cdk-global-scrollblock"),MG&&(r.scrollBehavior=i.scrollBehavior="auto"),window.scroll(this._previousScrollPosition.left,this._previousScrollPosition.top),MG&&(r.scrollBehavior=o,i.scrollBehavior=s)}}_canBeEnabled(){if(this._document.documentElement.classList.contains("cdk-global-scrollblock")||this._isEnabled)return!1;const e=this._document.body,r=this._viewportRuler.getViewportSize();return e.scrollHeight>r.height||e.scrollWidth>r.width}}class WNe{constructor(t,e,r,i){this._scrollDispatcher=t,this._ngZone=e,this._viewportRuler=r,this._config=i,this._scrollSubscription=null,this._detach=()=>{this.disable(),this._overlayRef.hasAttached()&&this._ngZone.run(()=>this._overlayRef.detach())}}attach(t){this._overlayRef=t}enable(){if(this._scrollSubscription)return;const t=this._scrollDispatcher.scrolled(0).pipe(zi(e=>!e||!this._overlayRef.overlayElement.contains(e.getElementRef().nativeElement)));this._config&&this._config.threshold&&this._config.threshold>1?(this._initialScrollPosition=this._viewportRuler.getViewportScrollPosition().top,this._scrollSubscription=t.subscribe(()=>{const e=this._viewportRuler.getViewportScrollPosition().top;Math.abs(e-this._initialScrollPosition)>this._config.threshold?this._detach():this._overlayRef.updatePosition()})):this._scrollSubscription=t.subscribe(this._detach)}disable(){this._scrollSubscription&&(this._scrollSubscription.unsubscribe(),this._scrollSubscription=null)}detach(){this.disable(),this._overlayRef=null}}class FG{enable(){}disable(){}attach(){}}function bA(n,t){return t.some(e=>n.bottom<e.top||n.top>e.bottom||n.right<e.left||n.left>e.right)}function PG(n,t){return t.some(e=>n.top<e.top||n.bottom>e.bottom||n.left<e.left||n.right>e.right)}class qNe{constructor(t,e,r,i){this._scrollDispatcher=t,this._viewportRuler=e,this._ngZone=r,this._config=i,this._scrollSubscription=null}attach(t){this._overlayRef=t}enable(){this._scrollSubscription||(this._scrollSubscription=this._scrollDispatcher.scrolled(this._config?this._config.scrollThrottle:0).subscribe(()=>{if(this._overlayRef.updatePosition(),this._config&&this._config.autoClose){const e=this._overlayRef.overlayElement.getBoundingClientRect(),{width:r,height:i}=this._viewportRuler.getViewportSize();bA(e,[{width:r,height:i,bottom:i,right:r,top:0,left:0}])&&(this.disable(),this._ngZone.run(()=>this._overlayRef.detach()))}}))}disable(){this._scrollSubscription&&(this._scrollSubscription.unsubscribe(),this._scrollSubscription=null)}detach(){this.disable(),this._overlayRef=null}}let KNe=(()=>{class n{constructor(e,r,i,o){this._scrollDispatcher=e,this._viewportRuler=r,this._ngZone=i,this.noop=()=>new FG,this.close=s=>new WNe(this._scrollDispatcher,this._ngZone,this._viewportRuler,s),this.block=()=>new HNe(this._viewportRuler,this._document),this.reposition=s=>new qNe(this._scrollDispatcher,this._viewportRuler,this._ngZone,s),this._document=o}}return n.\u0275fac=function(e){return new(e||n)(Fe(VNe),Fe(eb),Fe(Vt),Fe(Tn))},n.\u0275prov=at({token:n,factory:n.\u0275fac,providedIn:"root"}),n})();class $G{constructor(t){if(this.scrollStrategy=new FG,this.panelClass="",this.hasBackdrop=!1,this.backdropClass="cdk-overlay-dark-backdrop",this.disposeOnNavigation=!1,t){const e=Object.keys(t);for(const r of e)void 0!==t[r]&&(this[r]=t[r])}}}class XNe{constructor(t,e){this.connectionPair=t,this.scrollableViewProperties=e}}let LG=(()=>{class n{constructor(e){this._attachedOverlays=[],this._document=e}ngOnDestroy(){this.detach()}add(e){this.remove(e),this._attachedOverlays.push(e)}remove(e){const r=this._attachedOverlays.indexOf(e);r>-1&&this._attachedOverlays.splice(r,1),0===this._attachedOverlays.length&&this.detach()}}return n.\u0275fac=function(e){return new(e||n)(Fe(Tn))},n.\u0275prov=at({token:n,factory:n.\u0275fac,providedIn:"root"}),n})(),YNe=(()=>{class n extends LG{constructor(e,r){super(e),this._ngZone=r,this._keydownListener=i=>{const o=this._attachedOverlays;for(let s=o.length-1;s>-1;s--)if(o[s]._keydownEvents.observers.length>0){const a=o[s]._keydownEvents;this._ngZone?this._ngZone.run(()=>a.next(i)):a.next(i);break}}}add(e){super.add(e),this._isAttached||(this._ngZone?this._ngZone.runOutsideAngular(()=>this._document.body.addEventListener("keydown",this._keydownListener)):this._document.body.addEventListener("keydown",this._keydownListener),this._isAttached=!0)}detach(){this._isAttached&&(this._document.body.removeEventListener("keydown",this._keydownListener),this._isAttached=!1)}}return n.\u0275fac=function(e){return new(e||n)(Fe(Tn),Fe(Vt,8))},n.\u0275prov=at({token:n,factory:n.\u0275fac,providedIn:"root"}),n})(),ZNe=(()=>{class n extends LG{constructor(e,r,i){super(e),this._platform=r,this._ngZone=i,this._cursorStyleIsSet=!1,this._pointerDownListener=o=>{this._pointerDownEventTarget=Uc(o)},this._clickListener=o=>{const s=Uc(o),a="click"===o.type&&this._pointerDownEventTarget?this._pointerDownEventTarget:s;this._pointerDownEventTarget=null;const c=this._attachedOverlays.slice();for(let u=c.length-1;u>-1;u--){const p=c[u];if(p._outsidePointerEvents.observers.length<1||!p.hasAttached())continue;if(p.overlayElement.contains(s)||p.overlayElement.contains(a))break;const m=p._outsidePointerEvents;this._ngZone?this._ngZone.run(()=>m.next(o)):m.next(o)}}}add(e){if(super.add(e),!this._isAttached){const r=this._document.body;this._ngZone?this._ngZone.runOutsideAngular(()=>this._addEventListeners(r)):this._addEventListeners(r),this._platform.IOS&&!this._cursorStyleIsSet&&(this._cursorOriginalValue=r.style.cursor,r.style.cursor="pointer",this._cursorStyleIsSet=!0),this._isAttached=!0}}detach(){if(this._isAttached){const e=this._document.body;e.removeEventListener("pointerdown",this._pointerDownListener,!0),e.removeEventListener("click",this._clickListener,!0),e.removeEventListener("auxclick",this._clickListener,!0),e.removeEventListener("contextmenu",this._clickListener,!0),this._platform.IOS&&this._cursorStyleIsSet&&(e.style.cursor=this._cursorOriginalValue,this._cursorStyleIsSet=!1),this._isAttached=!1}}_addEventListeners(e){e.addEventListener("pointerdown",this._pointerDownListener,!0),e.addEventListener("click",this._clickListener,!0),e.addEventListener("auxclick",this._clickListener,!0),e.addEventListener("contextmenu",this._clickListener,!0)}}return n.\u0275fac=function(e){return new(e||n)(Fe(Tn),Fe(Wi),Fe(Vt,8))},n.\u0275prov=at({token:n,factory:n.\u0275fac,providedIn:"root"}),n})(),Ox=(()=>{class n{constructor(e,r){this._platform=r,this._document=e}ngOnDestroy(){this._containerElement?.remove()}getContainerElement(){return this._containerElement||this._createContainer(),this._containerElement}_createContainer(){const e="cdk-overlay-container";if(this._platform.isBrowser||pA()){const i=this._document.querySelectorAll(`.${e}[platform="server"], .${e}[platform="test"]`);for(let o=0;o<i.length;o++)i[o].remove()}const r=this._document.createElement("div");r.classList.add(e),pA()?r.setAttribute("platform","test"):this._platform.isBrowser||r.setAttribute("platform","server"),this._document.body.appendChild(r),this._containerElement=r}}return n.\u0275fac=function(e){return new(e||n)(Fe(Tn),Fe(Wi))},n.\u0275prov=at({token:n,factory:n.\u0275fac,providedIn:"root"}),n})();class nb{constructor(t,e,r,i,o,s,a,c,u,p=!1){this._portalOutlet=t,this._host=e,this._pane=r,this._config=i,this._ngZone=o,this._keyboardDispatcher=s,this._document=a,this._location=c,this._outsideClickDispatcher=u,this._animationsDisabled=p,this._backdropElement=null,this._backdropClick=new Kt,this._attachments=new Kt,this._detachments=new Kt,this._locationChanges=le.EMPTY,this._backdropClickHandler=m=>this._backdropClick.next(m),this._backdropTransitionendHandler=m=>{this._disposeBackdrop(m.target)},this._keydownEvents=new Kt,this._outsidePointerEvents=new Kt,i.scrollStrategy&&(this._scrollStrategy=i.scrollStrategy,this._scrollStrategy.attach(this)),this._positionStrategy=i.positionStrategy}get overlayElement(){return this._pane}get backdropElement(){return this._backdropElement}get hostElement(){return this._host}attach(t){!this._host.parentElement&&this._previousHostParent&&this._previousHostParent.appendChild(this._host);const e=this._portalOutlet.attach(t);return this._positionStrategy&&this._positionStrategy.attach(this),this._updateStackingOrder(),this._updateElementSize(),this._updateElementDirection(),this._scrollStrategy&&this._scrollStrategy.enable(),this._ngZone.onStable.pipe(is(1)).subscribe(()=>{this.hasAttached()&&this.updatePosition()}),this._togglePointerEvents(!0),this._config.hasBackdrop&&this._attachBackdrop(),this._config.panelClass&&this._toggleClasses(this._pane,this._config.panelClass,!0),this._attachments.next(),this._keyboardDispatcher.add(this),this._config.disposeOnNavigation&&(this._locationChanges=this._location.subscribe(()=>this.dispose())),this._outsideClickDispatcher.add(this),"function"==typeof e?.onDestroy&&e.onDestroy(()=>{this.hasAttached()&&this._ngZone.runOutsideAngular(()=>Promise.resolve().then(()=>this.detach()))}),e}detach(){if(!this.hasAttached())return;this.detachBackdrop(),this._togglePointerEvents(!1),this._positionStrategy&&this._positionStrategy.detach&&this._positionStrategy.detach(),this._scrollStrategy&&this._scrollStrategy.disable();const t=this._portalOutlet.detach();return this._detachments.next(),this._keyboardDispatcher.remove(this),this._detachContentWhenStable(),this._locationChanges.unsubscribe(),this._outsideClickDispatcher.remove(this),t}dispose(){const t=this.hasAttached();this._positionStrategy&&this._positionStrategy.dispose(),this._disposeScrollStrategy(),this._disposeBackdrop(this._backdropElement),this._locationChanges.unsubscribe(),this._keyboardDispatcher.remove(this),this._portalOutlet.dispose(),this._attachments.complete(),this._backdropClick.complete(),this._keydownEvents.complete(),this._outsidePointerEvents.complete(),this._outsideClickDispatcher.remove(this),this._host?.remove(),this._previousHostParent=this._pane=this._host=null,t&&this._detachments.next(),this._detachments.complete()}hasAttached(){return this._portalOutlet.hasAttached()}backdropClick(){return this._backdropClick}attachments(){return this._attachments}detachments(){return this._detachments}keydownEvents(){return this._keydownEvents}outsidePointerEvents(){return this._outsidePointerEvents}getConfig(){return this._config}updatePosition(){this._positionStrategy&&this._positionStrategy.apply()}updatePositionStrategy(t){t!==this._positionStrategy&&(this._positionStrategy&&this._positionStrategy.dispose(),this._positionStrategy=t,this.hasAttached()&&(t.attach(this),this.updatePosition()))}updateSize(t){this._config={...this._config,...t},this._updateElementSize()}setDirection(t){this._config={...this._config,direction:t},this._updateElementDirection()}addPanelClass(t){this._pane&&this._toggleClasses(this._pane,t,!0)}removePanelClass(t){this._pane&&this._toggleClasses(this._pane,t,!1)}getDirection(){const t=this._config.direction;return t?"string"==typeof t?t:t.value:"ltr"}updateScrollStrategy(t){t!==this._scrollStrategy&&(this._disposeScrollStrategy(),this._scrollStrategy=t,this.hasAttached()&&(t.attach(this),t.enable()))}_updateElementDirection(){this._host.setAttribute("dir",this.getDirection())}_updateElementSize(){if(!this._pane)return;const t=this._pane.style;t.width=li(this._config.width),t.height=li(this._config.height),t.minWidth=li(this._config.minWidth),t.minHeight=li(this._config.minHeight),t.maxWidth=li(this._config.maxWidth),t.maxHeight=li(this._config.maxHeight)}_togglePointerEvents(t){this._pane.style.pointerEvents=t?"":"none"}_attachBackdrop(){const t="cdk-overlay-backdrop-showing";this._backdropElement=this._document.createElement("div"),this._backdropElement.classList.add("cdk-overlay-backdrop"),this._animationsDisabled&&this._backdropElement.classList.add("cdk-overlay-backdrop-noop-animation"),this._config.backdropClass&&this._toggleClasses(this._backdropElement,this._config.backdropClass,!0),this._host.parentElement.insertBefore(this._backdropElement,this._host),this._backdropElement.addEventListener("click",this._backdropClickHandler),!this._animationsDisabled&&typeof requestAnimationFrame<"u"?this._ngZone.runOutsideAngular(()=>{requestAnimationFrame(()=>{this._backdropElement&&this._backdropElement.classList.add(t)})}):this._backdropElement.classList.add(t)}_updateStackingOrder(){this._host.nextSibling&&this._host.parentNode.appendChild(this._host)}detachBackdrop(){const t=this._backdropElement;if(t){if(this._animationsDisabled)return void this._disposeBackdrop(t);t.classList.remove("cdk-overlay-backdrop-showing"),this._ngZone.runOutsideAngular(()=>{t.addEventListener("transitionend",this._backdropTransitionendHandler)}),t.style.pointerEvents="none",this._backdropTimeout=this._ngZone.runOutsideAngular(()=>setTimeout(()=>{this._disposeBackdrop(t)},500))}}_toggleClasses(t,e,r){const i=Ix(e||[]).filter(o=>!!o);i.length&&(r?t.classList.add(...i):t.classList.remove(...i))}_detachContentWhenStable(){this._ngZone.runOutsideAngular(()=>{const t=this._ngZone.onStable.pipe(jc(Et(this._attachments,this._detachments))).subscribe(()=>{(!this._pane||!this._host||0===this._pane.children.length)&&(this._pane&&this._config.panelClass&&this._toggleClasses(this._pane,this._config.panelClass,!1),this._host&&this._host.parentElement&&(this._previousHostParent=this._host.parentElement,this._host.remove()),t.unsubscribe())})})}_disposeScrollStrategy(){const t=this._scrollStrategy;t&&(t.disable(),t.detach&&t.detach())}_disposeBackdrop(t){t&&(t.removeEventListener("click",this._backdropClickHandler),t.removeEventListener("transitionend",this._backdropTransitionendHandler),t.remove(),this._backdropElement===t&&(this._backdropElement=null)),this._backdropTimeout&&(clearTimeout(this._backdropTimeout),this._backdropTimeout=void 0)}}const BG="cdk-overlay-connected-position-bounding-box",QNe=/([A-Za-z%]+)$/;class JNe{get positions(){return this._preferredPositions}constructor(t,e,r,i,o){this._viewportRuler=e,this._document=r,this._platform=i,this._overlayContainer=o,this._lastBoundingBoxSize={width:0,height:0},this._isPushed=!1,this._canPush=!0,this._growAfterOpen=!1,this._hasFlexibleDimensions=!0,this._positionLocked=!1,this._viewportMargin=0,this._scrollables=[],this._preferredPositions=[],this._positionChanges=new Kt,this._resizeSubscription=le.EMPTY,this._offsetX=0,this._offsetY=0,this._appliedPanelClasses=[],this.positionChanges=this._positionChanges,this.setOrigin(t)}attach(t){this._validatePositions(),t.hostElement.classList.add(BG),this._overlayRef=t,this._boundingBox=t.hostElement,this._pane=t.overlayElement,this._isDisposed=!1,this._isInitialRender=!0,this._lastPosition=null,this._resizeSubscription.unsubscribe(),this._resizeSubscription=this._viewportRuler.change().subscribe(()=>{this._isInitialRender=!0,this.apply()})}apply(){if(this._isDisposed||!this._platform.isBrowser)return;if(!this._isInitialRender&&this._positionLocked&&this._lastPosition)return void this.reapplyLastPosition();this._clearPanelClasses(),this._resetOverlayElementStyles(),this._resetBoundingBoxStyles(),this._viewportRect=this._getNarrowedViewportRect(),this._originRect=this._getOriginRect(),this._overlayRect=this._pane.getBoundingClientRect(),this._containerRect=this._overlayContainer.getContainerElement().getBoundingClientRect();const t=this._originRect,e=this._overlayRect,r=this._viewportRect,i=this._containerRect,o=[];let s;for(let a of this._preferredPositions){let c=this._getOriginPoint(t,i,a),u=this._getOverlayPoint(c,e,a),p=this._getOverlayFit(u,e,r,a);if(p.isCompletelyWithinViewport)return this._isPushed=!1,void this._applyPosition(a,c);this._canFitWithFlexibleDimensions(p,u,r)?o.push({position:a,origin:c,overlayRect:e,boundingBoxRect:this._calculateBoundingBoxRect(c,a)}):(!s||s.overlayFit.visibleArea<p.visibleArea)&&(s={overlayFit:p,overlayPoint:u,originPoint:c,position:a,overlayRect:e})}if(o.length){let a=null,c=-1;for(const u of o){const p=u.boundingBoxRect.width*u.boundingBoxRect.height*(u.position.weight||1);p>c&&(c=p,a=u)}return this._isPushed=!1,void this._applyPosition(a.position,a.origin)}if(this._canPush)return this._isPushed=!0,void this._applyPosition(s.position,s.originPoint);this._applyPosition(s.position,s.originPoint)}detach(){this._clearPanelClasses(),this._lastPosition=null,this._previousPushAmount=null,this._resizeSubscription.unsubscribe()}dispose(){this._isDisposed||(this._boundingBox&&nd(this._boundingBox.style,{top:"",left:"",right:"",bottom:"",height:"",width:"",alignItems:"",justifyContent:""}),this._pane&&this._resetOverlayElementStyles(),this._overlayRef&&this._overlayRef.hostElement.classList.remove(BG),this.detach(),this._positionChanges.complete(),this._overlayRef=this._boundingBox=null,this._isDisposed=!0)}reapplyLastPosition(){if(this._isDisposed||!this._platform.isBrowser)return;const t=this._lastPosition;if(t){this._originRect=this._getOriginRect(),this._overlayRect=this._pane.getBoundingClientRect(),this._viewportRect=this._getNarrowedViewportRect(),this._containerRect=this._overlayContainer.getContainerElement().getBoundingClientRect();const e=this._getOriginPoint(this._originRect,this._containerRect,t);this._applyPosition(t,e)}else this.apply()}withScrollableContainers(t){return this._scrollables=t,this}withPositions(t){return this._preferredPositions=t,-1===t.indexOf(this._lastPosition)&&(this._lastPosition=null),this._validatePositions(),this}withViewportMargin(t){return this._viewportMargin=t,this}withFlexibleDimensions(t=!0){return this._hasFlexibleDimensions=t,this}withGrowAfterOpen(t=!0){return this._growAfterOpen=t,this}withPush(t=!0){return this._canPush=t,this}withLockedPosition(t=!0){return this._positionLocked=t,this}setOrigin(t){return this._origin=t,this}withDefaultOffsetX(t){return this._offsetX=t,this}withDefaultOffsetY(t){return this._offsetY=t,this}withTransformOriginOn(t){return this._transformOriginSelector=t,this}_getOriginPoint(t,e,r){let i,o;if("center"==r.originX)i=t.left+t.width/2;else{const s=this._isRtl()?t.right:t.left,a=this._isRtl()?t.left:t.right;i="start"==r.originX?s:a}return e.left<0&&(i-=e.left),o="center"==r.originY?t.top+t.height/2:"top"==r.originY?t.top:t.bottom,e.top<0&&(o-=e.top),{x:i,y:o}}_getOverlayPoint(t,e,r){let i,o;return i="center"==r.overlayX?-e.width/2:"start"===r.overlayX?this._isRtl()?-e.width:0:this._isRtl()?0:-e.width,o="center"==r.overlayY?-e.height/2:"top"==r.overlayY?0:-e.height,{x:t.x+i,y:t.y+o}}_getOverlayFit(t,e,r,i){const o=zG(e);let{x:s,y:a}=t,c=this._getOffset(i,"x"),u=this._getOffset(i,"y");c&&(s+=c),u&&(a+=u);let g=0-a,_=a+o.height-r.height,x=this._subtractOverflows(o.width,0-s,s+o.width-r.width),T=this._subtractOverflows(o.height,g,_),I=x*T;return{visibleArea:I,isCompletelyWithinViewport:o.width*o.height===I,fitsInViewportVertically:T===o.height,fitsInViewportHorizontally:x==o.width}}_canFitWithFlexibleDimensions(t,e,r){if(this._hasFlexibleDimensions){const i=r.bottom-e.y,o=r.right-e.x,s=VG(this._overlayRef.getConfig().minHeight),a=VG(this._overlayRef.getConfig().minWidth);return(t.fitsInViewportVertically||null!=s&&s<=i)&&(t.fitsInViewportHorizontally||null!=a&&a<=o)}return!1}_pushOverlayOnScreen(t,e,r){if(this._previousPushAmount&&this._positionLocked)return{x:t.x+this._previousPushAmount.x,y:t.y+this._previousPushAmount.y};const i=zG(e),o=this._viewportRect,s=Math.max(t.x+i.width-o.width,0),a=Math.max(t.y+i.height-o.height,0),c=Math.max(o.top-r.top-t.y,0),u=Math.max(o.left-r.left-t.x,0);let p=0,m=0;return p=i.width<=o.width?u||-s:t.x<this._viewportMargin?o.left-r.left-t.x:0,m=i.height<=o.height?c||-a:t.y<this._viewportMargin?o.top-r.top-t.y:0,this._previousPushAmount={x:p,y:m},{x:t.x+p,y:t.y+m}}_applyPosition(t,e){if(this._setTransformOrigin(t),this._setOverlayElementStyles(e,t),this._setBoundingBoxStyles(e,t),t.panelClass&&this._addPanelClasses(t.panelClass),this._lastPosition=t,this._positionChanges.observers.length){const r=this._getScrollVisibility(),i=new XNe(t,r);this._positionChanges.next(i)}this._isInitialRender=!1}_setTransformOrigin(t){if(!this._transformOriginSelector)return;const e=this._boundingBox.querySelectorAll(this._transformOriginSelector);let r,i=t.overlayY;r="center"===t.overlayX?"center":this._isRtl()?"start"===t.overlayX?"right":"left":"start"===t.overlayX?"left":"right";for(let o=0;o<e.length;o++)e[o].style.transformOrigin=`${r} ${i}`}_calculateBoundingBoxRect(t,e){const r=this._viewportRect,i=this._isRtl();let o,s,a,p,m,g;if("top"===e.overlayY)s=t.y,o=r.height-s+this._viewportMargin;else if("bottom"===e.overlayY)a=r.height-t.y+2*this._viewportMargin,o=r.height-a+this._viewportMargin;else{const _=Math.min(r.bottom-t.y+r.top,t.y),x=this._lastBoundingBoxSize.height;o=2*_,s=t.y-_,o>x&&!this._isInitialRender&&!this._growAfterOpen&&(s=t.y-x/2)}if("end"===e.overlayX&&!i||"start"===e.overlayX&&i)g=r.width-t.x+this._viewportMargin,p=t.x-this._viewportMargin;else if("start"===e.overlayX&&!i||"end"===e.overlayX&&i)m=t.x,p=r.right-t.x;else{const _=Math.min(r.right-t.x+r.left,t.x),x=this._lastBoundingBoxSize.width;p=2*_,m=t.x-_,p>x&&!this._isInitialRender&&!this._growAfterOpen&&(m=t.x-x/2)}return{top:s,left:m,bottom:a,right:g,width:p,height:o}}_setBoundingBoxStyles(t,e){const r=this._calculateBoundingBoxRect(t,e);!this._isInitialRender&&!this._growAfterOpen&&(r.height=Math.min(r.height,this._lastBoundingBoxSize.height),r.width=Math.min(r.width,this._lastBoundingBoxSize.width));const i={};if(this._hasExactPosition())i.top=i.left="0",i.bottom=i.right=i.maxHeight=i.maxWidth="",i.width=i.height="100%";else{const o=this._overlayRef.getConfig().maxHeight,s=this._overlayRef.getConfig().maxWidth;i.height=li(r.height),i.top=li(r.top),i.bottom=li(r.bottom),i.width=li(r.width),i.left=li(r.left),i.right=li(r.right),i.alignItems="center"===e.overlayX?"center":"end"===e.overlayX?"flex-end":"flex-start",i.justifyContent="center"===e.overlayY?"center":"bottom"===e.overlayY?"flex-end":"flex-start",o&&(i.maxHeight=li(o)),s&&(i.maxWidth=li(s))}this._lastBoundingBoxSize=r,nd(this._boundingBox.style,i)}_resetBoundingBoxStyles(){nd(this._boundingBox.style,{top:"0",left:"0",right:"0",bottom:"0",height:"",width:"",alignItems:"",justifyContent:""})}_resetOverlayElementStyles(){nd(this._pane.style,{top:"",left:"",bottom:"",right:"",position:"",transform:""})}_setOverlayElementStyles(t,e){const r={},i=this._hasExactPosition(),o=this._hasFlexibleDimensions,s=this._overlayRef.getConfig();if(i){const p=this._viewportRuler.getViewportScrollPosition();nd(r,this._getExactOverlayY(e,t,p)),nd(r,this._getExactOverlayX(e,t,p))}else r.position="static";let a="",c=this._getOffset(e,"x"),u=this._getOffset(e,"y");c&&(a+=`translateX(${c}px) `),u&&(a+=`translateY(${u}px)`),r.transform=a.trim(),s.maxHeight&&(i?r.maxHeight=li(s.maxHeight):o&&(r.maxHeight="")),s.maxWidth&&(i?r.maxWidth=li(s.maxWidth):o&&(r.maxWidth="")),nd(this._pane.style,r)}_getExactOverlayY(t,e,r){let i={top:"",bottom:""},o=this._getOverlayPoint(e,this._overlayRect,t);return this._isPushed&&(o=this._pushOverlayOnScreen(o,this._overlayRect,r)),"bottom"===t.overlayY?i.bottom=this._document.documentElement.clientHeight-(o.y+this._overlayRect.height)+"px":i.top=li(o.y),i}_getExactOverlayX(t,e,r){let s,i={left:"",right:""},o=this._getOverlayPoint(e,this._overlayRect,t);return this._isPushed&&(o=this._pushOverlayOnScreen(o,this._overlayRect,r)),s=this._isRtl()?"end"===t.overlayX?"left":"right":"end"===t.overlayX?"right":"left","right"===s?i.right=this._document.documentElement.clientWidth-(o.x+this._overlayRect.width)+"px":i.left=li(o.x),i}_getScrollVisibility(){const t=this._getOriginRect(),e=this._pane.getBoundingClientRect(),r=this._scrollables.map(i=>i.getElementRef().nativeElement.getBoundingClientRect());return{isOriginClipped:PG(t,r),isOriginOutsideView:bA(t,r),isOverlayClipped:PG(e,r),isOverlayOutsideView:bA(e,r)}}_subtractOverflows(t,...e){return e.reduce((r,i)=>r-Math.max(i,0),t)}_getNarrowedViewportRect(){const t=this._document.documentElement.clientWidth,e=this._document.documentElement.clientHeight,r=this._viewportRuler.getViewportScrollPosition();return{top:r.top+this._viewportMargin,left:r.left+this._viewportMargin,right:r.left+t-this._viewportMargin,bottom:r.top+e-this._viewportMargin,width:t-2*this._viewportMargin,height:e-2*this._viewportMargin}}_isRtl(){return"rtl"===this._overlayRef.getDirection()}_hasExactPosition(){return!this._hasFlexibleDimensions||this._isPushed}_getOffset(t,e){return"x"===e?null==t.offsetX?this._offsetX:t.offsetX:null==t.offsetY?this._offsetY:t.offsetY}_validatePositions(){}_addPanelClasses(t){this._pane&&Ix(t).forEach(e=>{""!==e&&-1===this._appliedPanelClasses.indexOf(e)&&(this._appliedPanelClasses.push(e),this._pane.classList.add(e))})}_clearPanelClasses(){this._pane&&(this._appliedPanelClasses.forEach(t=>{this._pane.classList.remove(t)}),this._appliedPanelClasses=[])}_getOriginRect(){const t=this._origin;if(t instanceof yn)return t.nativeElement.getBoundingClientRect();if(t instanceof Element)return t.getBoundingClientRect();const e=t.width||0,r=t.height||0;return{top:t.y,bottom:t.y+r,left:t.x,right:t.x+e,height:r,width:e}}}function nd(n,t){for(let e in t)t.hasOwnProperty(e)&&(n[e]=t[e]);return n}function VG(n){if("number"!=typeof n&&null!=n){const[t,e]=n.split(QNe);return e&&"px"!==e?null:parseFloat(t)}return n||null}function zG(n){return{top:Math.floor(n.top),right:Math.floor(n.right),bottom:Math.floor(n.bottom),left:Math.floor(n.left),width:Math.floor(n.width),height:Math.floor(n.height)}}const UG="cdk-global-overlay-wrapper";class eOe{constructor(){this._cssPosition="static",this._topOffset="",this._bottomOffset="",this._alignItems="",this._xPosition="",this._xOffset="",this._width="",this._height="",this._isDisposed=!1}attach(t){const e=t.getConfig();this._overlayRef=t,this._width&&!e.width&&t.updateSize({width:this._width}),this._height&&!e.height&&t.updateSize({height:this._height}),t.hostElement.classList.add(UG),this._isDisposed=!1}top(t=""){return this._bottomOffset="",this._topOffset=t,this._alignItems="flex-start",this}left(t=""){return this._xOffset=t,this._xPosition="left",this}bottom(t=""){return this._topOffset="",this._bottomOffset=t,this._alignItems="flex-end",this}right(t=""){return this._xOffset=t,this._xPosition="right",this}start(t=""){return this._xOffset=t,this._xPosition="start",this}end(t=""){return this._xOffset=t,this._xPosition="end",this}width(t=""){return this._overlayRef?this._overlayRef.updateSize({width:t}):this._width=t,this}height(t=""){return this._overlayRef?this._overlayRef.updateSize({height:t}):this._height=t,this}centerHorizontally(t=""){return this.left(t),this._xPosition="center",this}centerVertically(t=""){return this.top(t),this._alignItems="center",this}apply(){if(!this._overlayRef||!this._overlayRef.hasAttached())return;const t=this._overlayRef.overlayElement.style,e=this._overlayRef.hostElement.style,r=this._overlayRef.getConfig(),{width:i,height:o,maxWidth:s,maxHeight:a}=r,c=!("100%"!==i&&"100vw"!==i||s&&"100%"!==s&&"100vw"!==s),u=!("100%"!==o&&"100vh"!==o||a&&"100%"!==a&&"100vh"!==a),p=this._xPosition,m=this._xOffset,g="rtl"===this._overlayRef.getConfig().direction;let _="",x="",T="";c?T="flex-start":"center"===p?(T="center",g?x=m:_=m):g?"left"===p||"end"===p?(T="flex-end",_=m):("right"===p||"start"===p)&&(T="flex-start",x=m):"left"===p||"start"===p?(T="flex-start",_=m):("right"===p||"end"===p)&&(T="flex-end",x=m),t.position=this._cssPosition,t.marginLeft=c?"0":_,t.marginTop=u?"0":this._topOffset,t.marginBottom=this._bottomOffset,t.marginRight=c?"0":x,e.justifyContent=T,e.alignItems=u?"flex-start":this._alignItems}dispose(){if(this._isDisposed||!this._overlayRef)return;const t=this._overlayRef.overlayElement.style,e=this._overlayRef.hostElement,r=e.style;e.classList.remove(UG),r.justifyContent=r.alignItems=t.marginTop=t.marginBottom=t.marginLeft=t.marginRight=t.position="",this._overlayRef=null,this._isDisposed=!0}}let tOe=(()=>{class n{constructor(e,r,i,o){this._viewportRuler=e,this._document=r,this._platform=i,this._overlayContainer=o}global(){return new eOe}flexibleConnectedTo(e){return new JNe(e,this._viewportRuler,this._document,this._platform,this._overlayContainer)}}return n.\u0275fac=function(e){return new(e||n)(Fe(eb),Fe(Tn),Fe(Wi),Fe(Ox))},n.\u0275prov=at({token:n,factory:n.\u0275fac,providedIn:"root"}),n})(),nOe=0,pp=(()=>{class n{constructor(e,r,i,o,s,a,c,u,p,m,g,_){this.scrollStrategies=e,this._overlayContainer=r,this._componentFactoryResolver=i,this._positionBuilder=o,this._keyboardDispatcher=s,this._injector=a,this._ngZone=c,this._document=u,this._directionality=p,this._location=m,this._outsideClickDispatcher=g,this._animationsModuleType=_}create(e){const r=this._createHostElement(),i=this._createPaneElement(r),o=this._createPortalOutlet(i),s=new $G(e);return s.direction=s.direction||this._directionality.value,new nb(o,r,i,s,this._ngZone,this._keyboardDispatcher,this._document,this._location,this._outsideClickDispatcher,"NoopAnimations"===this._animationsModuleType)}position(){return this._positionBuilder}_createPaneElement(e){const r=this._document.createElement("div");return r.id="cdk-overlay-"+nOe++,r.classList.add("cdk-overlay-pane"),e.appendChild(r),r}_createHostElement(){const e=this._document.createElement("div");return this._overlayContainer.getContainerElement().appendChild(e),e}_createPortalOutlet(e){return this._appRef||(this._appRef=this._injector.get(ec)),new jNe(e,this._componentFactoryResolver,this._appRef,this._injector,this._document)}}return n.\u0275fac=function(e){return new(e||n)(Fe(KNe),Fe(Ox),Fe(du),Fe(tOe),Fe(YNe),Fe(Qi),Fe(Vt),Fe(Tn),Fe(Rl),Fe($f),Fe(ZNe),Fe(ns,8))},n.\u0275prov=at({token:n,factory:n.\u0275fac,providedIn:"root"}),n})();const oOe={provide:new Qe("cdk-connected-overlay-scroll-strategy"),deps:[pp],useFactory:function iOe(n){return()=>n.scrollStrategies.reposition()}};let jG=(()=>{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275mod=Vn({type:n}),n.\u0275inj=Pn({providers:[pp,oOe],imports:[Jg,tb,RG,RG]}),n})();function Rx(n,...t){return t.length?t.some(e=>n[e]):n.altKey||n.shiftKey||n.ctrlKey||n.metaKey}function yA(n,t=cA){return Rn((e,r)=>{let i=null,o=null,s=null;const a=()=>{if(i){i.unsubscribe(),i=null;const u=o;o=null,r.next(u)}};function c(){const u=s+n,p=t.now();if(p<u)return i=this.schedule(void 0,u-p),void r.add(i);a()}e.subscribe(Bn(r,u=>{o=u,s=t.now(),i||(i=t.schedule(c,n),r.add(i))},()=>{a(),r.complete()},void 0,()=>{o=i=null}))})}function _A(n){return zi((t,e)=>n<=e)}function HG(n,t=Hr){return n=n??IOe,Rn((e,r)=>{let i,o=!0;e.subscribe(Bn(r,s=>{const a=t(s);(o||!n(i,a))&&(o=!1,i=a,r.next(s))}))})}function IOe(n,t){return n===t}let WG=(()=>{class n{create(e){return typeof MutationObserver>"u"?null:new MutationObserver(e)}}return n.\u0275fac=function(e){return new(e||n)},n.\u0275prov=at({token:n,factory:n.\u0275fac,providedIn:"root"}),n})(),EOe=(()=>{class n{constructor(e){this._mutationObserverFactory=e,this._observedElements=new Map}ngOnDestroy(){this._observedElements.forEach((e,r)=>this._cleanupObserver(r))}observe(e){const r=Ol(e);return new An(i=>{const s=this._observeElement(r).subscribe(i);return()=>{s.unsubscribe(),this._unobserveElement(r)}})}_observeElement(e){if(this._observedElements.has(e))this._observedElements.get(e).count++;else{const r=new Kt,i=this._mutationObserverFactory.create(o=>r.next(o));i&&i.observe(e,{characterData:!0,childList:!0,subtree:!0}),this._observedElements.set(e,{observer:i,stream:r,count:1})}return this._observedElements.get(e).stream}_unobserveElement(e){this._observedElements.has(e)&&(this._observedElements.get(e).count--,this._observedElements.get(e).count||this._cleanupObserver(e))}_cleanupObserver(e){if(this._observedElements.has(e)){const{observer:r,stream:i}=this._observedElements.get(e);r&&r.disconnect(),i.complete(),this._observedElements.delete(e)}}}return n.\u0275fac=function(e){return new(e||n)(Fe(WG))},n.\u0275prov=at({token:n,factory:n.\u0275fac,providedIn:"root"}),n})(),DOe=(()=>{class n{get disabled(){return this._disabled}set disabled(e){this._disabled=gr(e),this._disabled?this._unsubscribe():this._subscribe()}get debounce(){return this._debounce}set debounce(e){this._debounce=yi(e),this._subscribe()}constructor(e,r,i){this._contentObserver=e,this._elementRef=r,this._ngZone=i,this.event=new rn,this._disabled=!1,this._currentSubscription=null}ngAfterContentInit(){!this._currentSubscription&&!this.disabled&&this._subscribe()}ngOnDestroy(){this._unsubscribe()}_subscribe(){this._unsubscribe();const e=this._contentObserver.observe(this._elementRef);this._ngZone.runOutsideAngular(()=>{this._currentSubscription=(this.debounce?e.pipe(yA(this.debounce)):e).subscribe(this.event)})}_unsubscribe(){this._currentSubscription?.unsubscribe()}}return n.\u0275fac=function(e){return new(e||n)(de(EOe),de(yn),de(Vt))},n.\u0275dir=_t({type:n,selectors:[["","cdkObserveContent",""]],inputs:{disabled:["cdkObserveContentDisabled","disabled"],debounce:"debounce"},outputs:{event:"cdkObserveContent"},exportAs:["cdkObserveContent"]}),n})(),vA=(()=>{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275mod=Vn({type:n}),n.\u0275inj=Pn({providers:[WG]}),n})();const qG=new Set;let rd,kOe=(()=>{class n{constructor(e,r){this._platform=e,this._nonce=r,this._matchMedia=this._platform.isBrowser&&window.matchMedia?window.matchMedia.bind(window):NOe}matchMedia(e){return(this._platform.WEBKIT||this._platform.BLINK)&&function AOe(n,t){if(!qG.has(n))try{rd||(rd=document.createElement("style"),t&&(rd.nonce=t),rd.setAttribute("type","text/css"),document.head.appendChild(rd)),rd.sheet&&(rd.sheet.insertRule(`@media ${n} {body{ }}`,0),qG.add(n))}catch(e){console.error(e)}}(e,this._nonce),this._matchMedia(e)}}return n.\u0275fac=function(e){return new(e||n)(Fe(Wi),Fe(FT,8))},n.\u0275prov=at({token:n,factory:n.\u0275fac,providedIn:"root"}),n})();function NOe(n){return{matches:"all"===n||""===n,media:n,addListener:()=>{},removeListener:()=>{}}}let OOe=(()=>{class n{constructor(e,r){this._mediaMatcher=e,this._zone=r,this._queries=new Map,this._destroySubject=new Kt}ngOnDestroy(){this._destroySubject.next(),this._destroySubject.complete()}isMatched(e){return KG(Ix(e)).some(i=>this._registerQuery(i).mql.matches)}observe(e){let o=h_(KG(Ix(e)).map(s=>this._registerQuery(s).observable));return o=f_(o.pipe(is(1)),o.pipe(_A(1),yA(0))),o.pipe(ct(s=>{const a={matches:!1,breakpoints:{}};return s.forEach(({matches:c,query:u})=>{a.matches=a.matches||c,a.breakpoints[u]=c}),a}))}_registerQuery(e){if(this._queries.has(e))return this._queries.get(e);const r=this._mediaMatcher.matchMedia(e),o={observable:new An(s=>{const a=c=>this._zone.run(()=>s.next(c));return r.addListener(a),()=>{r.removeListener(a)}}).pipe(_u(r),ct(({matches:s})=>({query:e,matches:s})),jc(this._destroySubject)),mql:r};return this._queries.set(e,o),o}}return n.\u0275fac=function(e){return new(e||n)(Fe(kOe),Fe(Vt))},n.\u0275prov=at({token:n,factory:n.\u0275fac,providedIn:"root"}),n})();function KG(n){return n.map(t=>t.split(",")).reduce((t,e)=>t.concat(e)).map(t=>t.trim())}class FOe{constructor(t){this._items=t,this._activeItemIndex=-1,this._activeItem=null,this._wrap=!1,this._letterKeyStream=new Kt,this._typeaheadSubscription=le.EMPTY,this._vertical=!0,this._allowedModifierKeys=[],this._homeAndEnd=!1,this._pageUpAndDown={enabled:!1,delta:10},this._skipPredicateFn=e=>e.disabled,this._pressedLetters=[],this.tabOut=new Kt,this.change=new Kt,t instanceof ih&&(this._itemChangesSubscription=t.changes.subscribe(e=>{if(this._activeItem){const i=e.toArray().indexOf(this._activeItem);i>-1&&i!==this._activeItemIndex&&(this._activeItemIndex=i)}}))}skipPredicate(t){return this._skipPredicateFn=t,this}withWrap(t=!0){return this._wrap=t,this}withVerticalOrientation(t=!0){return this._vertical=t,this}withHorizontalOrientation(t){return this._horizontal=t,this}withAllowedModifierKeys(t){return this._allowedModifierKeys=t,this}withTypeAhead(t=200){return this._typeaheadSubscription.unsubscribe(),this._typeaheadSubscription=this._letterKeyStream.pipe(to(e=>this._pressedLetters.push(e)),yA(t),zi(()=>this._pressedLetters.length>0),ct(()=>this._pressedLetters.join(""))).subscribe(e=>{const r=this._getItemsArray();for(let i=1;i<r.length+1;i++){const o=(this._activeItemIndex+i)%r.length,s=r[o];if(!this._skipPredicateFn(s)&&0===s.getLabel().toUpperCase().trim().indexOf(e)){this.setActiveItem(o);break}}this._pressedLetters=[]}),this}cancelTypeahead(){return this._pressedLetters=[],this}withHomeAndEnd(t=!0){return this._homeAndEnd=t,this}withPageUpDown(t=!0,e=10){return this._pageUpAndDown={enabled:t,delta:e},this}setActiveItem(t){const e=this._activeItem;this.updateActiveItem(t),this._activeItem!==e&&this.change.next(this._activeItemIndex)}onKeydown(t){const e=t.keyCode,i=["altKey","ctrlKey","metaKey","shiftKey"].every(o=>!t[o]||this._allowedModifierKeys.indexOf(o)>-1);switch(e){case 9:return void this.tabOut.next();case 40:if(this._vertical&&i){this.setNextItemActive();break}return;case 38:if(this._vertical&&i){this.setPreviousItemActive();break}return;case 39:if(this._horizontal&&i){"rtl"===this._horizontal?this.setPreviousItemActive():this.setNextItemActive();break}return;case 37:if(this._horizontal&&i){"rtl"===this._horizontal?this.setNextItemActive():this.setPreviousItemActive();break}return;case 36:if(this._homeAndEnd&&i){this.setFirstItemActive();break}return;case 35:if(this._homeAndEnd&&i){this.setLastItemActive();break}return;case 33:if(this._pageUpAndDown.enabled&&i){const o=this._activeItemIndex-this._pageUpAndDown.delta;this._setActiveItemByIndex(o>0?o:0,1);break}return;case 34:if(this._pageUpAndDown.enabled&&i){const o=this._activeItemIndex+this._pageUpAndDown.delta,s=this._getItemsArray().length;this._setActiveItemByIndex(o<s?o:s-1,-1);break}return;default:return void((i||Rx(t,"shiftKey"))&&(t.key&&1===t.key.length?this._letterKeyStream.next(t.key.toLocaleUpperCase()):(e>=65&&e<=90||e>=48&&e<=57)&&this._letterKeyStream.next(String.fromCharCode(e))))}this._pressedLetters=[],t.preventDefault()}get activeItemIndex(){return this._activeItemIndex}get activeItem(){return this._activeItem}isTyping(){return this._pressedLetters.length>0}setFirstItemActive(){this._setActiveItemByIndex(0,1)}setLastItemActive(){this._setActiveItemByIndex(this._items.length-1,-1)}setNextItemActive(){this._activeItemIndex<0?this.setFirstItemActive():this._setActiveItemByDelta(1)}setPreviousItemActive(){this._activeItemIndex<0&&this._wrap?this.setLastItemActive():this._setActiveItemByDelta(-1)}updateActiveItem(t){const e=this._getItemsArray(),r="number"==typeof t?t:e.indexOf(t);this._activeItem=e[r]??null,this._activeItemIndex=r}destroy(){this._typeaheadSubscription.unsubscribe(),this._itemChangesSubscription?.unsubscribe(),this._letterKeyStream.complete(),this.tabOut.complete(),this.change.complete(),this._pressedLetters=[]}_setActiveItemByDelta(t){this._wrap?this._setActiveInWrapMode(t):this._setActiveInDefaultMode(t)}_setActiveInWrapMode(t){const e=this._getItemsArray();for(let r=1;r<=e.length;r++){const i=(this._activeItemIndex+t*r+e.length)%e.length;if(!this._skipPredicateFn(e[i]))return void this.setActiveItem(i)}}_setActiveInDefaultMode(t){this._setActiveItemByIndex(this._activeItemIndex+t,t)}_setActiveItemByIndex(t,e){const r=this._getItemsArray();if(r[t]){for(;this._skipPredicateFn(r[t]);)if(!r[t+=e])return;this.setActiveItem(t)}}_getItemsArray(){return this._items instanceof ih?this._items.toArray():this._items}}class POe extends FOe{constructor(){super(...arguments),this._origin="program"}setFocusOrigin(t){return this._origin=t,this}setActiveItem(t){super.setActiveItem(t),this.activeItem&&this.activeItem.focus(this._origin)}}let Mx=(()=>{class n{constructor(e){this._platform=e}isDisabled(e){return e.hasAttribute("disabled")}isVisible(e){return function LOe(n){return!!(n.offsetWidth||n.offsetHeight||"function"==typeof n.getClientRects&&n.getClientRects().length)}(e)&&"visible"===getComputedStyle(e).visibility}isTabbable(e){if(!this._platform.isBrowser)return!1;const r=function $Oe(n){try{return n.frameElement}catch{return null}}(function WOe(n){return n.ownerDocument&&n.ownerDocument.defaultView||window}(e));if(r&&(-1===QG(r)||!this.isVisible(r)))return!1;let i=e.nodeName.toLowerCase(),o=QG(e);return e.hasAttribute("contenteditable")?-1!==o:!("iframe"===i||"object"===i||this._platform.WEBKIT&&this._platform.IOS&&!function GOe(n){let t=n.nodeName.toLowerCase(),e="input"===t&&n.type;return"text"===e||"password"===e||"select"===t||"textarea"===t}(e))&&("audio"===i?!!e.hasAttribute("controls")&&-1!==o:"video"===i?-1!==o&&(null!==o||this._platform.FIREFOX||e.hasAttribute("controls")):e.tabIndex>=0)}isFocusable(e,r){return function HOe(n){return!function VOe(n){return function UOe(n){return"input"==n.nodeName.toLowerCase()}(n)&&"hidden"==n.type}(n)&&(function BOe(n){let t=n.nodeName.toLowerCase();return"input"===t||"select"===t||"button"===t||"textarea"===t}(n)||function zOe(n){return function jOe(n){return"a"==n.nodeName.toLowerCase()}(n)&&n.hasAttribute("href")}(n)||n.hasAttribute("contenteditable")||ZG(n))}(e)&&!this.isDisabled(e)&&(r?.ignoreVisibility||this.isVisible(e))}}return n.\u0275fac=function(e){return new(e||n)(Fe(Wi))},n.\u0275prov=at({token:n,factory:n.\u0275fac,providedIn:"root"}),n})();function ZG(n){if(!n.hasAttribute("tabindex")||void 0===n.tabIndex)return!1;let t=n.getAttribute("tabindex");return!(!t||isNaN(parseInt(t,10)))}function QG(n){if(!ZG(n))return null;const t=parseInt(n.getAttribute("tabindex")||"",10);return isNaN(t)?-1:t}class qOe{get enabled(){return this._enabled}set enabled(t){this._enabled=t,this._startAnchor&&this._endAnchor&&(this._toggleAnchorTabIndex(t,this._startAnchor),this._toggleAnchorTabIndex(t,this._endAnchor))}constructor(t,e,r,i,o=!1){this._element=t,this._checker=e,this._ngZone=r,this._document=i,this._hasAttached=!1,this.startAnchorListener=()=>this.focusLastTabbableElement(),this.endAnchorListener=()=>this.focusFirstTabbableElement(),this._enabled=!0,o||this.attachAnchors()}destroy(){const t=this._startAnchor,e=this._endAnchor;t&&(t.removeEventListener("focus",this.startAnchorListener),t.remove()),e&&(e.removeEventListener("focus",this.endAnchorListener),e.remove()),this._startAnchor=this._endAnchor=null,this._hasAttached=!1}attachAnchors(){return!!this._hasAttached||(this._ngZone.runOutsideAngular(()=>{this._startAnchor||(this._startAnchor=this._createAnchor(),this._startAnchor.addEventListener("focus",this.startAnchorListener)),this._endAnchor||(this._endAnchor=this._createAnchor(),this._endAnchor.addEventListener("focus",this.endAnchorListener))}),this._element.parentNode&&(this._element.parentNode.insertBefore(this._startAnchor,this._element),this._element.parentNode.insertBefore(this._endAnchor,this._element.nextSibling),this._hasAttached=!0),this._hasAttached)}focusInitialElementWhenReady(t){return new Promise(e=>{this._executeOnStable(()=>e(this.focusInitialElement(t)))})}focusFirstTabbableElementWhenReady(t){return new Promise(e=>{this._executeOnStable(()=>e(this.focusFirstTabbableElement(t)))})}focusLastTabbableElementWhenReady(t){return new Promise(e=>{this._executeOnStable(()=>e(this.focusLastTabbableElement(t)))})}_getRegionBoundary(t){const e=this._element.querySelectorAll(`[cdk-focus-region-${t}], [cdkFocusRegion${t}], [cdk-focus-${t}]`);return"start"==t?e.length?e[0]:this._getFirstTabbableElement(this._element):e.length?e[e.length-1]:this._getLastTabbableElement(this._element)}focusInitialElement(t){const e=this._element.querySelector("[cdk-focus-initial], [cdkFocusInitial]");if(e){if(!this._checker.isFocusable(e)){const r=this._getFirstTabbableElement(e);return r?.focus(t),!!r}return e.focus(t),!0}return this.focusFirstTabbableElement(t)}focusFirstTabbableElement(t){const e=this._getRegionBoundary("start");return e&&e.focus(t),!!e}focusLastTabbableElement(t){const e=this._getRegionBoundary("end");return e&&e.focus(t),!!e}hasAttached(){return this._hasAttached}_getFirstTabbableElement(t){if(this._checker.isFocusable(t)&&this._checker.isTabbable(t))return t;const e=t.children;for(let r=0;r<e.length;r++){const i=e[r].nodeType===this._document.ELEMENT_NODE?this._getFirstTabbableElement(e[r]):null;if(i)return i}return null}_getLastTabbableElement(t){if(this._checker.isFocusable(t)&&this._checker.isTabbable(t))return t;const e=t.children;for(let r=e.length-1;r>=0;r--){const i=e[r].nodeType===this._document.ELEMENT_NODE?this._getLastTabbableElement(e[r]):null;if(i)return i}return null}_createAnchor(){const t=this._document.createElement("div");return this._toggleAnchorTabIndex(this._enabled,t),t.classList.add("cdk-visually-hidden"),t.classList.add("cdk-focus-trap-anchor"),t.setAttribute("aria-hidden","true"),t}_toggleAnchorTabIndex(t,e){t?e.setAttribute("tabindex","0"):e.removeAttribute("tabindex")}toggleAnchors(t){this._startAnchor&&this._endAnchor&&(this._toggleAnchorTabIndex(t,this._startAnchor),this._toggleAnchorTabIndex(t,this._endAnchor))}_executeOnStable(t){this._ngZone.isStable?t():this._ngZone.onStable.pipe(is(1)).subscribe(t)}}let xA=(()=>{class n{constructor(e,r,i){this._checker=e,this._ngZone=r,this._document=i}create(e,r=!1){return new qOe(e,this._checker,this._ngZone,this._document,r)}}return n.\u0275fac=function(e){return new(e||n)(Fe(Mx),Fe(Vt),Fe(Tn))},n.\u0275prov=at({token:n,factory:n.\u0275fac,providedIn:"root"}),n})();function JG(n){return 0===n.buttons||0===n.offsetX&&0===n.offsetY}function e6(n){const t=n.touches&&n.touches[0]||n.changedTouches&&n.changedTouches[0];return!(!t||-1!==t.identifier||null!=t.radiusX&&1!==t.radiusX||null!=t.radiusY&&1!==t.radiusY)}const KOe=new Qe("cdk-input-modality-detector-options"),XOe={ignoreKeys:[18,17,224,91,16]},fp=dp({passive:!0,capture:!0});let YOe=(()=>{class n{get mostRecentModality(){return this._modality.value}constructor(e,r,i,o){this._platform=e,this._mostRecentTarget=null,this._modality=new Ds(null),this._lastTouchMs=0,this._onKeydown=s=>{this._options?.ignoreKeys?.some(a=>a===s.keyCode)||(this._modality.next("keyboard"),this._mostRecentTarget=Uc(s))},this._onMousedown=s=>{Date.now()-this._lastTouchMs<650||(this._modality.next(JG(s)?"keyboard":"mouse"),this._mostRecentTarget=Uc(s))},this._onTouchstart=s=>{e6(s)?this._modality.next("keyboard"):(this._lastTouchMs=Date.now(),this._modality.next("touch"),this._mostRecentTarget=Uc(s))},this._options={...XOe,...o},this.modalityDetected=this._modality.pipe(_A(1)),this.modalityChanged=this.modalityDetected.pipe(HG()),e.isBrowser&&r.runOutsideAngular(()=>{i.addEventListener("keydown",this._onKeydown,fp),i.addEventListener("mousedown",this._onMousedown,fp),i.addEventListener("touchstart",this._onTouchstart,fp)})}ngOnDestroy(){this._modality.complete(),this._platform.isBrowser&&(document.removeEventListener("keydown",this._onKeydown,fp),document.removeEventListener("mousedown",this._onMousedown,fp),document.removeEventListener("touchstart",this._onTouchstart,fp))}}return n.\u0275fac=function(e){return new(e||n)(Fe(Wi),Fe(Vt),Fe(Tn),Fe(KOe,8))},n.\u0275prov=at({token:n,factory:n.\u0275fac,providedIn:"root"}),n})();const QOe=new Qe("cdk-focus-monitor-default-options"),Fx=dp({passive:!0,capture:!0});let rb=(()=>{class n{constructor(e,r,i,o,s){this._ngZone=e,this._platform=r,this._inputModalityDetector=i,this._origin=null,this._windowFocused=!1,this._originFromTouchInteraction=!1,this._elementInfo=new Map,this._monitoredElementCount=0,this._rootNodeFocusListenerCount=new Map,this._windowFocusListener=()=>{this._windowFocused=!0,this._windowFocusTimeoutId=window.setTimeout(()=>this._windowFocused=!1)},this._stopInputModalityDetector=new Kt,this._rootNodeFocusAndBlurListener=a=>{for(let u=Uc(a);u;u=u.parentElement)"focus"===a.type?this._onFocus(a,u):this._onBlur(a,u)},this._document=o,this._detectionMode=s?.detectionMode||0}monitor(e,r=!1){const i=Ol(e);if(!this._platform.isBrowser||1!==i.nodeType)return jt(null);const o=function MNe(n){if(function RNe(){if(null==dA){const n=typeof document<"u"?document.head:null;dA=!(!n||!n.createShadowRoot&&!n.attachShadow)}return dA}()){const t=n.getRootNode?n.getRootNode():null;if(typeof ShadowRoot<"u"&&ShadowRoot&&t instanceof ShadowRoot)return t}return null}(i)||this._getDocument(),s=this._elementInfo.get(i);if(s)return r&&(s.checkChildren=!0),s.subject;const a={checkChildren:r,subject:new Kt,rootNode:o};return this._elementInfo.set(i,a),this._registerGlobalListeners(a),a.subject}stopMonitoring(e){const r=Ol(e),i=this._elementInfo.get(r);i&&(i.subject.complete(),this._setClasses(r),this._elementInfo.delete(r),this._removeGlobalListeners(i))}focusVia(e,r,i){const o=Ol(e);o===this._getDocument().activeElement?this._getClosestElementsInfo(o).forEach(([a,c])=>this._originChanged(a,r,c)):(this._setOrigin(r),"function"==typeof o.focus&&o.focus(i))}ngOnDestroy(){this._elementInfo.forEach((e,r)=>this.stopMonitoring(r))}_getDocument(){return this._document||document}_getWindow(){return this._getDocument().defaultView||window}_getFocusOrigin(e){return this._origin?this._originFromTouchInteraction?this._shouldBeAttributedToTouch(e)?"touch":"program":this._origin:this._windowFocused&&this._lastFocusOrigin?this._lastFocusOrigin:e&&this._isLastInteractionFromInputLabel(e)?"mouse":"program"}_shouldBeAttributedToTouch(e){return 1===this._detectionMode||!!e?.contains(this._inputModalityDetector._mostRecentTarget)}_setClasses(e,r){e.classList.toggle("cdk-focused",!!r),e.classList.toggle("cdk-touch-focused","touch"===r),e.classList.toggle("cdk-keyboard-focused","keyboard"===r),e.classList.toggle("cdk-mouse-focused","mouse"===r),e.classList.toggle("cdk-program-focused","program"===r)}_setOrigin(e,r=!1){this._ngZone.runOutsideAngular(()=>{this._origin=e,this._originFromTouchInteraction="touch"===e&&r,0===this._detectionMode&&(clearTimeout(this._originTimeoutId),this._originTimeoutId=setTimeout(()=>this._origin=null,this._originFromTouchInteraction?650:1))})}_onFocus(e,r){const i=this._elementInfo.get(r),o=Uc(e);!i||!i.checkChildren&&r!==o||this._originChanged(r,this._getFocusOrigin(o),i)}_onBlur(e,r){const i=this._elementInfo.get(r);!i||i.checkChildren&&e.relatedTarget instanceof Node&&r.contains(e.relatedTarget)||(this._setClasses(r),this._emitOrigin(i,null))}_emitOrigin(e,r){e.subject.observers.length&&this._ngZone.run(()=>e.subject.next(r))}_registerGlobalListeners(e){if(!this._platform.isBrowser)return;const r=e.rootNode,i=this._rootNodeFocusListenerCount.get(r)||0;i||this._ngZone.runOutsideAngular(()=>{r.addEventListener("focus",this._rootNodeFocusAndBlurListener,Fx),r.addEventListener("blur",this._rootNodeFocusAndBlurListener,Fx)}),this._rootNodeFocusListenerCount.set(r,i+1),1==++this._monitoredElementCount&&(this._ngZone.runOutsideAngular(()=>{this._getWindow().addEventListener("focus",this._windowFocusListener)}),this._inputModalityDetector.modalityDetected.pipe(jc(this._stopInputModalityDetector)).subscribe(o=>{this._setOrigin(o,!0)}))}_removeGlobalListeners(e){const r=e.rootNode;if(this._rootNodeFocusListenerCount.has(r)){const i=this._rootNodeFocusListenerCount.get(r);i>1?this._rootNodeFocusListenerCount.set(r,i-1):(r.removeEventListener("focus",this._rootNodeFocusAndBlurListener,Fx),r.removeEventListener("blur",this._rootNodeFocusAndBlurListener,Fx),this._rootNodeFocusListenerCount.delete(r))}--this._monitoredElementCount||(this._getWindow().removeEventListener("focus",this._windowFocusListener),this._stopInputModalityDetector.next(),clearTimeout(this._windowFocusTimeoutId),clearTimeout(this._originTimeoutId))}_originChanged(e,r,i){this._setClasses(e,r),this._emitOrigin(i,r),this._lastFocusOrigin=r}_getClosestElementsInfo(e){const r=[];return this._elementInfo.forEach((i,o)=>{(o===e||i.checkChildren&&o.contains(e))&&r.push([o,i])}),r}_isLastInteractionFromInputLabel(e){const{_mostRecentTarget:r,mostRecentModality:i}=this._inputModalityDetector;if("mouse"!==i||!r||r===e||"INPUT"!==e.nodeName&&"TEXTAREA"!==e.nodeName||e.disabled)return!1;const o=e.labels;if(o)for(let s=0;s<o.length;s++)if(o[s].contains(r))return!0;return!1}}return n.\u0275fac=function(e){return new(e||n)(Fe(Vt),Fe(Wi),Fe(YOe),Fe(Tn,8),Fe(QOe,8))},n.\u0275prov=at({token:n,factory:n.\u0275fac,providedIn:"root"}),n})(),JOe=(()=>{class n{constructor(e,r){this._elementRef=e,this._focusMonitor=r,this._focusOrigin=null,this.cdkFocusChange=new rn}get focusOrigin(){return this._focusOrigin}ngAfterViewInit(){const e=this._elementRef.nativeElement;this._monitorSubscription=this._focusMonitor.monitor(e,1===e.nodeType&&e.hasAttribute("cdkMonitorSubtreeFocus")).subscribe(r=>{this._focusOrigin=r,this.cdkFocusChange.emit(r)})}ngOnDestroy(){this._focusMonitor.stopMonitoring(this._elementRef),this._monitorSubscription&&this._monitorSubscription.unsubscribe()}}return n.\u0275fac=function(e){return new(e||n)(de(yn),de(rb))},n.\u0275dir=_t({type:n,selectors:[["","cdkMonitorElementFocus",""],["","cdkMonitorSubtreeFocus",""]],outputs:{cdkFocusChange:"cdkFocusChange"},exportAs:["cdkMonitorFocus"]}),n})();const n6="cdk-high-contrast-black-on-white",r6="cdk-high-contrast-white-on-black",wA="cdk-high-contrast-active";let i6=(()=>{class n{constructor(e,r){this._platform=e,this._document=r,this._breakpointSubscription=It(OOe).observe("(forced-colors: active)").subscribe(()=>{this._hasCheckedHighContrastMode&&(this._hasCheckedHighContrastMode=!1,this._applyBodyHighContrastModeCssClasses())})}getHighContrastMode(){if(!this._platform.isBrowser)return 0;const e=this._document.createElement("div");e.style.backgroundColor="rgb(1,2,3)",e.style.position="absolute",this._document.body.appendChild(e);const r=this._document.defaultView||window,i=r&&r.getComputedStyle?r.getComputedStyle(e):null,o=(i&&i.backgroundColor||"").replace(/ /g,"");switch(e.remove(),o){case"rgb(0,0,0)":case"rgb(45,50,54)":case"rgb(32,32,32)":return 2;case"rgb(255,255,255)":case"rgb(255,250,239)":return 1}return 0}ngOnDestroy(){this._breakpointSubscription.unsubscribe()}_applyBodyHighContrastModeCssClasses(){if(!this._hasCheckedHighContrastMode&&this._platform.isBrowser&&this._document.body){const e=this._document.body.classList;e.remove(wA,n6,r6),this._hasCheckedHighContrastMode=!0;const r=this.getHighContrastMode();1===r?e.add(wA,n6):2===r&&e.add(wA,r6)}}}return n.\u0275fac=function(e){return new(e||n)(Fe(Wi),Fe(Tn))},n.\u0275prov=at({token:n,factory:n.\u0275fac,providedIn:"root"}),n})(),o6=(()=>{class n{constructor(e){e._applyBodyHighContrastModeCssClasses()}}return n.\u0275fac=function(e){return new(e||n)(Fe(i6))},n.\u0275mod=Vn({type:n}),n.\u0275inj=Pn({imports:[vA]}),n})();function eRe(n,t){}class Px{constructor(){this.role="dialog",this.panelClass="",this.hasBackdrop=!0,this.backdropClass="",this.disableClose=!1,this.width="",this.height="",this.data=null,this.ariaDescribedBy=null,this.ariaLabelledBy=null,this.ariaLabel=null,this.ariaModal=!0,this.autoFocus="first-tabbable",this.restoreFocus=!0,this.closeOnNavigation=!0,this.closeOnDestroy=!0,this.closeOnOverlayDetachments=!0}}let s6=(()=>{class n extends gA{constructor(e,r,i,o,s,a,c,u){super(),this._elementRef=e,this._focusTrapFactory=r,this._config=o,this._interactivityChecker=s,this._ngZone=a,this._overlayRef=c,this._focusMonitor=u,this._elementFocusedBeforeDialogWasOpened=null,this._closeInteractionType=null,this.attachDomPortal=p=>{this._portalOutlet.hasAttached();const m=this._portalOutlet.attachDomPortal(p);return this._contentAttached(),m},this._ariaLabelledBy=this._config.ariaLabelledBy||null,this._document=i}_contentAttached(){this._initializeFocusTrap(),this._handleBackdropClicks(),this._captureInitialFocus()}_captureInitialFocus(){this._trapFocus()}ngOnDestroy(){this._restoreFocus()}attachComponentPortal(e){this._portalOutlet.hasAttached();const r=this._portalOutlet.attachComponentPortal(e);return this._contentAttached(),r}attachTemplatePortal(e){this._portalOutlet.hasAttached();const r=this._portalOutlet.attachTemplatePortal(e);return this._contentAttached(),r}_recaptureFocus(){this._containsFocus()||this._trapFocus()}_forceFocus(e,r){this._interactivityChecker.isFocusable(e)||(e.tabIndex=-1,this._ngZone.runOutsideAngular(()=>{const i=()=>{e.removeEventListener("blur",i),e.removeEventListener("mousedown",i),e.removeAttribute("tabindex")};e.addEventListener("blur",i),e.addEventListener("mousedown",i)})),e.focus(r)}_focusByCssSelector(e,r){let i=this._elementRef.nativeElement.querySelector(e);i&&this._forceFocus(i,r)}_trapFocus(){const e=this._elementRef.nativeElement;switch(this._config.autoFocus){case!1:case"dialog":this._containsFocus()||e.focus();break;case!0:case"first-tabbable":this._focusTrap.focusInitialElementWhenReady().then(r=>{r||this._focusDialogContainer()});break;case"first-heading":this._focusByCssSelector('h1, h2, h3, h4, h5, h6, [role="heading"]');break;default:this._focusByCssSelector(this._config.autoFocus)}}_restoreFocus(){const e=this._config.restoreFocus;let r=null;if("string"==typeof e?r=this._document.querySelector(e):"boolean"==typeof e?r=e?this._elementFocusedBeforeDialogWasOpened:null:e&&(r=e),this._config.restoreFocus&&r&&"function"==typeof r.focus){const i=hA(),o=this._elementRef.nativeElement;(!i||i===this._document.body||i===o||o.contains(i))&&(this._focusMonitor?(this._focusMonitor.focusVia(r,this._closeInteractionType),this._closeInteractionType=null):r.focus())}this._focusTrap&&this._focusTrap.destroy()}_focusDialogContainer(){this._elementRef.nativeElement.focus&&this._elementRef.nativeElement.focus()}_containsFocus(){const e=this._elementRef.nativeElement,r=hA();return e===r||e.contains(r)}_initializeFocusTrap(){this._focusTrap=this._focusTrapFactory.create(this._elementRef.nativeElement),this._document&&(this._elementFocusedBeforeDialogWasOpened=hA())}_handleBackdropClicks(){this._overlayRef.backdropClick().subscribe(()=>{this._config.disableClose&&this._recaptureFocus()})}}return n.\u0275fac=function(e){return new(e||n)(de(yn),de(xA),de(Tn,8),de(Px),de(Mx),de(Vt),de(nb),de(rb))},n.\u0275cmp=Pi({type:n,selectors:[["cdk-dialog-container"]],viewQuery:function(e,r){if(1&e&&Bi(hp,7),2&e){let i;ir(i=or())&&(r._portalOutlet=i.first)}},hostAttrs:["tabindex","-1",1,"cdk-dialog-container"],hostVars:6,hostBindings:function(e,r){2&e&&ui("id",r._config.id||null)("role",r._config.role)("aria-modal",r._config.ariaModal)("aria-labelledby",r._config.ariaLabel?null:r._ariaLabelledBy)("aria-label",r._config.ariaLabel)("aria-describedby",r._config.ariaDescribedBy||null)},features:[$t],decls:1,vars:0,consts:[["cdkPortalOutlet",""]],template:function(e,r){1&e&&Xr(0,eRe,0,0,"ng-template",0)},dependencies:[hp],styles:[".cdk-dialog-container{display:block;width:100%;height:100%;min-height:inherit;max-height:inherit}"],encapsulation:2}),n})();class TA{constructor(t,e){this.overlayRef=t,this.config=e,this.closed=new Kt,this.disableClose=e.disableClose,this.backdropClick=t.backdropClick(),this.keydownEvents=t.keydownEvents(),this.outsidePointerEvents=t.outsidePointerEvents(),this.id=e.id,this.keydownEvents.subscribe(r=>{27===r.keyCode&&!this.disableClose&&!Rx(r)&&(r.preventDefault(),this.close(void 0,{focusOrigin:"keyboard"}))}),this.backdropClick.subscribe(()=>{this.disableClose||this.close(void 0,{focusOrigin:"mouse"})}),this._detachSubscription=t.detachments().subscribe(()=>{!1!==e.closeOnOverlayDetachments&&this.close()})}close(t,e){if(this.containerInstance){const r=this.closed;this.containerInstance._closeInteractionType=e?.focusOrigin||"program",this._detachSubscription.unsubscribe(),this.overlayRef.dispose(),r.next(t),r.complete(),this.componentInstance=this.containerInstance=null}}updatePosition(){return this.overlayRef.updatePosition(),this}updateSize(t="",e=""){return this.overlayRef.updateSize({width:t,height:e}),this}addPanelClass(t){return this.overlayRef.addPanelClass(t),this}removePanelClass(t){return this.overlayRef.removePanelClass(t),this}}const a6=new Qe("DialogScrollStrategy"),tRe=new Qe("DialogData"),nRe=new Qe("DefaultDialogConfig"),iRe={provide:a6,deps:[pp],useFactory:function rRe(n){return()=>n.scrollStrategies.block()}};let oRe=0,l6=(()=>{class n{get openDialogs(){return this._parentDialog?this._parentDialog.openDialogs:this._openDialogsAtThisLevel}get afterOpened(){return this._parentDialog?this._parentDialog.afterOpened:this._afterOpenedAtThisLevel}constructor(e,r,i,o,s,a){this._overlay=e,this._injector=r,this._defaultOptions=i,this._parentDialog=o,this._overlayContainer=s,this._openDialogsAtThisLevel=[],this._afterAllClosedAtThisLevel=new Kt,this._afterOpenedAtThisLevel=new Kt,this._ariaHiddenElements=new Map,this.afterAllClosed=m_(()=>this.openDialogs.length?this._getAfterAllClosed():this._getAfterAllClosed().pipe(_u(void 0))),this._scrollStrategy=a}open(e,r){(r={...this._defaultOptions||new Px,...r}).id=r.id||"cdk-dialog-"+oRe++,r.id&&this.getDialogById(r.id);const o=this._getOverlayConfig(r),s=this._overlay.create(o),a=new TA(s,r),c=this._attachContainer(s,a,r);return a.containerInstance=c,this._attachDialogContent(e,a,c,r),this.openDialogs.length||this._hideNonDialogContentFromAssistiveTechnology(),this.openDialogs.push(a),a.closed.subscribe(()=>this._removeOpenDialog(a,!0)),this.afterOpened.next(a),a}closeAll(){SA(this.openDialogs,e=>e.close())}getDialogById(e){return this.openDialogs.find(r=>r.id===e)}ngOnDestroy(){SA(this._openDialogsAtThisLevel,e=>{!1===e.config.closeOnDestroy&&this._removeOpenDialog(e,!1)}),SA(this._openDialogsAtThisLevel,e=>e.close()),this._afterAllClosedAtThisLevel.complete(),this._afterOpenedAtThisLevel.complete(),this._openDialogsAtThisLevel=[]}_getOverlayConfig(e){const r=new $G({positionStrategy:e.positionStrategy||this._overlay.position().global().centerHorizontally().centerVertically(),scrollStrategy:e.scrollStrategy||this._scrollStrategy(),panelClass:e.panelClass,hasBackdrop:e.hasBackdrop,direction:e.direction,minWidth:e.minWidth,minHeight:e.minHeight,maxWidth:e.maxWidth,maxHeight:e.maxHeight,width:e.width,height:e.height,disposeOnNavigation:e.closeOnNavigation});return e.backdropClass&&(r.backdropClass=e.backdropClass),r}_attachContainer(e,r,i){const o=i.injector||i.viewContainerRef?.injector,s=[{provide:Px,useValue:i},{provide:TA,useValue:r},{provide:nb,useValue:e}];let a;i.container?"function"==typeof i.container?a=i.container:(a=i.container.type,s.push(...i.container.providers(i))):a=s6;const c=new mA(a,i.viewContainerRef,Qi.create({parent:o||this._injector,providers:s}),i.componentFactoryResolver);return e.attach(c).instance}_attachDialogContent(e,r,i,o){if(e instanceof _o){const s=this._createInjector(o,r,i,void 0);let a={$implicit:o.data,dialogRef:r};o.templateContext&&(a={...a,..."function"==typeof o.templateContext?o.templateContext():o.templateContext}),i.attachTemplatePortal(new Nx(e,null,a,s))}else{const s=this._createInjector(o,r,i,this._injector),a=i.attachComponentPortal(new mA(e,o.viewContainerRef,s,o.componentFactoryResolver));r.componentInstance=a.instance}}_createInjector(e,r,i,o){const s=e.injector||e.viewContainerRef?.injector,a=[{provide:tRe,useValue:e.data},{provide:TA,useValue:r}];return e.providers&&("function"==typeof e.providers?a.push(...e.providers(r,e,i)):a.push(...e.providers)),e.direction&&(!s||!s.get(Rl,null,{optional:!0}))&&a.push({provide:Rl,useValue:{value:e.direction,change:jt()}}),Qi.create({parent:s||o,providers:a})}_removeOpenDialog(e,r){const i=this.openDialogs.indexOf(e);i>-1&&(this.openDialogs.splice(i,1),this.openDialogs.length||(this._ariaHiddenElements.forEach((o,s)=>{o?s.setAttribute("aria-hidden",o):s.removeAttribute("aria-hidden")}),this._ariaHiddenElements.clear(),r&&this._getAfterAllClosed().next()))}_hideNonDialogContentFromAssistiveTechnology(){const e=this._overlayContainer.getContainerElement();if(e.parentElement){const r=e.parentElement.children;for(let i=r.length-1;i>-1;i--){const o=r[i];o!==e&&"SCRIPT"!==o.nodeName&&"STYLE"!==o.nodeName&&!o.hasAttribute("aria-live")&&(this._ariaHiddenElements.set(o,o.getAttribute("aria-hidden")),o.setAttribute("aria-hidden","true"))}}}_getAfterAllClosed(){const e=this._parentDialog;return e?e._getAfterAllClosed():this._afterAllClosedAtThisLevel}}return n.\u0275fac=function(e){return new(e||n)(Fe(pp),Fe(Qi),Fe(nRe,8),Fe(n,12),Fe(Ox),Fe(a6))},n.\u0275prov=at({token:n,factory:n.\u0275fac}),n})();function SA(n,t){let e=n.length;for(;e--;)t(n[e])}let sRe=(()=>{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275mod=Vn({type:n}),n.\u0275inj=Pn({providers:[l6,iRe],imports:[jG,tb,o6,tb]}),n})();const lRe=new Qe("mat-sanity-checks",{providedIn:"root",factory:function aRe(){return!0}});let Do=(()=>{class n{constructor(e,r,i){this._sanityChecks=r,this._document=i,this._hasDoneGlobalChecks=!1,e._applyBodyHighContrastModeCssClasses(),this._hasDoneGlobalChecks||(this._hasDoneGlobalChecks=!0)}_checkIsEnabled(e){return!pA()&&("boolean"==typeof this._sanityChecks?this._sanityChecks:!!this._sanityChecks[e])}}return n.\u0275fac=function(e){return new(e||n)(Fe(i6),Fe(lRe,8),Fe(Tn))},n.\u0275mod=Vn({type:n}),n.\u0275inj=Pn({imports:[Jg,Jg]}),n})();function d6(n){return class extends n{get disabled(){return this._disabled}set disabled(t){this._disabled=gr(t)}constructor(...t){super(...t),this._disabled=!1}}}function h6(n,t){return class extends n{get color(){return this._color}set color(e){const r=e||this.defaultColor;r!==this._color&&(this._color&&this._elementRef.nativeElement.classList.remove(`mat-${this._color}`),r&&this._elementRef.nativeElement.classList.add(`mat-${r}`),this._color=r)}constructor(...e){super(...e),this.defaultColor=t,this.color=t}}}function CA(n){return class extends n{get disableRipple(){return this._disableRipple}set disableRipple(t){this._disableRipple=gr(t)}constructor(...t){super(...t),this._disableRipple=!1}}}function uRe(n){return class extends n{updateErrorState(){const t=this.errorState,o=(this.errorStateMatcher||this._defaultErrorStateMatcher).isErrorState(this.ngControl?this.ngControl.control:null,this._parentFormGroup||this._parentForm);o!==t&&(this.errorState=o,this.stateChanges.next())}constructor(...t){super(...t),this.errorState=!1}}}let hRe=(()=>{class n{isErrorState(e,r){return!!(e&&e.invalid&&(e.touched||r&&r.submitted))}}return n.\u0275fac=function(e){return new(e||n)},n.\u0275prov=at({token:n,factory:n.\u0275fac,providedIn:"root"}),n})();class pRe{constructor(t,e,r,i=!1){this._renderer=t,this.element=e,this.config=r,this._animationForciblyDisabledThroughCss=i,this.state=3}fadeOut(){this._renderer.fadeOutRipple(this)}}const p6=dp({passive:!0,capture:!0});class fRe{constructor(){this._events=new Map,this._delegateEventHandler=t=>{const e=Uc(t);e&&this._events.get(t.type)?.forEach((r,i)=>{(i===e||i.contains(e))&&r.forEach(o=>o.handleEvent(t))})}}addHandler(t,e,r,i){const o=this._events.get(e);if(o){const s=o.get(r);s?s.add(i):o.set(r,new Set([i]))}else this._events.set(e,new Map([[r,new Set([i])]])),t.runOutsideAngular(()=>{document.addEventListener(e,this._delegateEventHandler,p6)})}removeHandler(t,e,r){const i=this._events.get(t);if(!i)return;const o=i.get(e);o&&(o.delete(r),0===o.size&&i.delete(e),0===i.size&&(this._events.delete(t),document.removeEventListener(t,this._delegateEventHandler,p6)))}}const f6={enterDuration:225,exitDuration:150},m6=dp({passive:!0,capture:!0}),g6=["mousedown","touchstart"],b6=["mouseup","mouseleave","touchend","touchcancel"];class ob{constructor(t,e,r,i){this._target=t,this._ngZone=e,this._platform=i,this._isPointerDown=!1,this._activeRipples=new Map,this._pointerUpEventsRegistered=!1,i.isBrowser&&(this._containerElement=Ol(r))}fadeInRipple(t,e,r={}){const i=this._containerRect=this._containerRect||this._containerElement.getBoundingClientRect(),o={...f6,...r.animation};r.centered&&(t=i.left+i.width/2,e=i.top+i.height/2);const s=r.radius||function gRe(n,t,e){const r=Math.max(Math.abs(n-e.left),Math.abs(n-e.right)),i=Math.max(Math.abs(t-e.top),Math.abs(t-e.bottom));return Math.sqrt(r*r+i*i)}(t,e,i),a=t-i.left,c=e-i.top,u=o.enterDuration,p=document.createElement("div");p.classList.add("mat-ripple-element"),p.style.left=a-s+"px",p.style.top=c-s+"px",p.style.height=2*s+"px",p.style.width=2*s+"px",null!=r.color&&(p.style.backgroundColor=r.color),p.style.transitionDuration=`${u}ms`,this._containerElement.appendChild(p);const m=window.getComputedStyle(p),_=m.transitionDuration,x="none"===m.transitionProperty||"0s"===_||"0s, 0s"===_||0===i.width&&0===i.height,T=new pRe(this,p,r,x);p.style.transform="scale3d(1, 1, 1)",T.state=0,r.persistent||(this._mostRecentTransientRipple=T);let I=null;return!x&&(u||o.exitDuration)&&this._ngZone.runOutsideAngular(()=>{const N=()=>this._finishRippleTransition(T),R=()=>this._destroyRipple(T);p.addEventListener("transitionend",N),p.addEventListener("transitioncancel",R),I={onTransitionEnd:N,onTransitionCancel:R}}),this._activeRipples.set(T,I),(x||!u)&&this._finishRippleTransition(T),T}fadeOutRipple(t){if(2===t.state||3===t.state)return;const e=t.element,r={...f6,...t.config.animation};e.style.transitionDuration=`${r.exitDuration}ms`,e.style.opacity="0",t.state=2,(t._animationForciblyDisabledThroughCss||!r.exitDuration)&&this._finishRippleTransition(t)}fadeOutAll(){this._getActiveRipples().forEach(t=>t.fadeOut())}fadeOutAllNonPersistent(){this._getActiveRipples().forEach(t=>{t.config.persistent||t.fadeOut()})}setupTriggerEvents(t){const e=Ol(t);!this._platform.isBrowser||!e||e===this._triggerElement||(this._removeTriggerEvents(),this._triggerElement=e,g6.forEach(r=>{ob._eventManager.addHandler(this._ngZone,r,e,this)}))}handleEvent(t){"mousedown"===t.type?this._onMousedown(t):"touchstart"===t.type?this._onTouchStart(t):this._onPointerUp(),this._pointerUpEventsRegistered||(this._ngZone.runOutsideAngular(()=>{b6.forEach(e=>{this._triggerElement.addEventListener(e,this,m6)})}),this._pointerUpEventsRegistered=!0)}_finishRippleTransition(t){0===t.state?this._startFadeOutTransition(t):2===t.state&&this._destroyRipple(t)}_startFadeOutTransition(t){const e=t===this._mostRecentTransientRipple,{persistent:r}=t.config;t.state=1,!r&&(!e||!this._isPointerDown)&&t.fadeOut()}_destroyRipple(t){const e=this._activeRipples.get(t)??null;this._activeRipples.delete(t),this._activeRipples.size||(this._containerRect=null),t===this._mostRecentTransientRipple&&(this._mostRecentTransientRipple=null),t.state=3,null!==e&&(t.element.removeEventListener("transitionend",e.onTransitionEnd),t.element.removeEventListener("transitioncancel",e.onTransitionCancel)),t.element.remove()}_onMousedown(t){const e=JG(t),r=this._lastTouchStartEvent&&Date.now()<this._lastTouchStartEvent+800;!this._target.rippleDisabled&&!e&&!r&&(this._isPointerDown=!0,this.fadeInRipple(t.clientX,t.clientY,this._target.rippleConfig))}_onTouchStart(t){if(!this._target.rippleDisabled&&!e6(t)){this._lastTouchStartEvent=Date.now(),this._isPointerDown=!0;const e=t.changedTouches;for(let r=0;r<e.length;r++)this.fadeInRipple(e[r].clientX,e[r].clientY,this._target.rippleConfig)}}_onPointerUp(){this._isPointerDown&&(this._isPointerDown=!1,this._getActiveRipples().forEach(t=>{!t.config.persistent&&(1===t.state||t.config.terminateOnPointerUp&&0===t.state)&&t.fadeOut()}))}_getActiveRipples(){return Array.from(this._activeRipples.keys())}_removeTriggerEvents(){const t=this._triggerElement;t&&(g6.forEach(e=>ob._eventManager.removeHandler(e,t,this)),this._pointerUpEventsRegistered&&b6.forEach(e=>t.removeEventListener(e,this,m6)))}}ob._eventManager=new fRe;const y6=new Qe("mat-ripple-global-options");let sb=(()=>{class n{get disabled(){return this._disabled}set disabled(e){e&&this.fadeOutAllNonPersistent(),this._disabled=e,this._setupTriggerEventsIfEnabled()}get trigger(){return this._trigger||this._elementRef.nativeElement}set trigger(e){this._trigger=e,this._setupTriggerEventsIfEnabled()}constructor(e,r,i,o,s){this._elementRef=e,this._animationMode=s,this.radius=0,this._disabled=!1,this._isInitialized=!1,this._globalOptions=o||{},this._rippleRenderer=new ob(this,r,e,i)}ngOnInit(){this._isInitialized=!0,this._setupTriggerEventsIfEnabled()}ngOnDestroy(){this._rippleRenderer._removeTriggerEvents()}fadeOutAll(){this._rippleRenderer.fadeOutAll()}fadeOutAllNonPersistent(){this._rippleRenderer.fadeOutAllNonPersistent()}get rippleConfig(){return{centered:this.centered,radius:this.radius,color:this.color,animation:{...this._globalOptions.animation,..."NoopAnimations"===this._animationMode?{enterDuration:0,exitDuration:0}:{},...this.animation},terminateOnPointerUp:this._globalOptions.terminateOnPointerUp}}get rippleDisabled(){return this.disabled||!!this._globalOptions.disabled}_setupTriggerEventsIfEnabled(){!this.disabled&&this._isInitialized&&this._rippleRenderer.setupTriggerEvents(this.trigger)}launch(e,r=0,i){return"number"==typeof e?this._rippleRenderer.fadeInRipple(e,r,{...this.rippleConfig,...i}):this._rippleRenderer.fadeInRipple(0,0,{...this.rippleConfig,...e})}}return n.\u0275fac=function(e){return new(e||n)(de(yn),de(Vt),de(Wi),de(y6,8),de(ns,8))},n.\u0275dir=_t({type:n,selectors:[["","mat-ripple",""],["","matRipple",""]],hostAttrs:[1,"mat-ripple"],hostVars:2,hostBindings:function(e,r){2&e&&Yr("mat-ripple-unbounded",r.unbounded)},inputs:{color:["matRippleColor","color"],unbounded:["matRippleUnbounded","unbounded"],centered:["matRippleCentered","centered"],radius:["matRippleRadius","radius"],animation:["matRippleAnimation","animation"],disabled:["matRippleDisabled","disabled"],trigger:["matRippleTrigger","trigger"]},exportAs:["matRipple"]}),n})(),$x=(()=>{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275mod=Vn({type:n}),n.\u0275inj=Pn({imports:[Do,Do]}),n})();class _6{}class bRe{}const Ml="*";function IA(n,t){return{type:7,name:n,definitions:t,options:{}}}function mp(n,t=null){return{type:4,styles:t,timings:n}}function x6(n,t=null){return{type:2,steps:n,options:t}}function bs(n){return{type:6,styles:n,offset:null}}function gp(n,t,e){return{type:0,name:n,styles:t,options:e}}function bp(n,t,e=null){return{type:1,expr:n,animation:t,options:e}}function S6(n){Promise.resolve().then(n)}class ab{constructor(t=0,e=0){this._onDoneFns=[],this._onStartFns=[],this._onDestroyFns=[],this._originalOnDoneFns=[],this._originalOnStartFns=[],this._started=!1,this._destroyed=!1,this._finished=!1,this._position=0,this.parentPlayer=null,this.totalTime=t+e}_onFinish(){this._finished||(this._finished=!0,this._onDoneFns.forEach(t=>t()),this._onDoneFns=[])}onStart(t){this._originalOnStartFns.push(t),this._onStartFns.push(t)}onDone(t){this._originalOnDoneFns.push(t),this._onDoneFns.push(t)}onDestroy(t){this._onDestroyFns.push(t)}hasStarted(){return this._started}init(){}play(){this.hasStarted()||(this._onStart(),this.triggerMicrotask()),this._started=!0}triggerMicrotask(){S6(()=>this._onFinish())}_onStart(){this._onStartFns.forEach(t=>t()),this._onStartFns=[]}pause(){}restart(){}finish(){this._onFinish()}destroy(){this._destroyed||(this._destroyed=!0,this.hasStarted()||this._onStart(),this.finish(),this._onDestroyFns.forEach(t=>t()),this._onDestroyFns=[])}reset(){this._started=!1,this._finished=!1,this._onStartFns=this._originalOnStartFns,this._onDoneFns=this._originalOnDoneFns}setPosition(t){this._position=this.totalTime?t*this.totalTime:1}getPosition(){return this.totalTime?this._position/this.totalTime:1}triggerCallback(t){const e="start"==t?this._onStartFns:this._onDoneFns;e.forEach(r=>r()),e.length=0}}class C6{constructor(t){this._onDoneFns=[],this._onStartFns=[],this._finished=!1,this._started=!1,this._destroyed=!1,this._onDestroyFns=[],this.parentPlayer=null,this.totalTime=0,this.players=t;let e=0,r=0,i=0;const o=this.players.length;0==o?S6(()=>this._onFinish()):this.players.forEach(s=>{s.onDone(()=>{++e==o&&this._onFinish()}),s.onDestroy(()=>{++r==o&&this._onDestroy()}),s.onStart(()=>{++i==o&&this._onStart()})}),this.totalTime=this.players.reduce((s,a)=>Math.max(s,a.totalTime),0)}_onFinish(){this._finished||(this._finished=!0,this._onDoneFns.forEach(t=>t()),this._onDoneFns=[])}init(){this.players.forEach(t=>t.init())}onStart(t){this._onStartFns.push(t)}_onStart(){this.hasStarted()||(this._started=!0,this._onStartFns.forEach(t=>t()),this._onStartFns=[])}onDone(t){this._onDoneFns.push(t)}onDestroy(t){this._onDestroyFns.push(t)}hasStarted(){return this._started}play(){this.parentPlayer||this.init(),this._onStart(),this.players.forEach(t=>t.play())}pause(){this.players.forEach(t=>t.pause())}restart(){this.players.forEach(t=>t.restart())}finish(){this._onFinish(),this.players.forEach(t=>t.finish())}destroy(){this._onDestroy()}_onDestroy(){this._destroyed||(this._destroyed=!0,this._onFinish(),this.players.forEach(t=>t.destroy()),this._onDestroyFns.forEach(t=>t()),this._onDestroyFns=[])}reset(){this.players.forEach(t=>t.reset()),this._destroyed=!1,this._finished=!1,this._started=!1}setPosition(t){const e=t*this.totalTime;this.players.forEach(r=>{const i=r.totalTime?Math.min(1,e/r.totalTime):1;r.setPosition(i)})}getPosition(){const t=this.players.reduce((e,r)=>null===e||r.totalTime>e.totalTime?r:e,null);return null!=t?t.getPosition():0}beforeDestroy(){this.players.forEach(t=>{t.beforeDestroy&&t.beforeDestroy()})}triggerCallback(t){const e="start"==t?this._onStartFns:this._onDoneFns;e.forEach(r=>r()),e.length=0}}const EA="!";function yRe(n,t){}class Lx{constructor(){this.role="dialog",this.panelClass="",this.hasBackdrop=!0,this.backdropClass="",this.disableClose=!1,this.width="",this.height="",this.maxWidth="80vw",this.data=null,this.ariaDescribedBy=null,this.ariaLabelledBy=null,this.ariaLabel=null,this.ariaModal=!0,this.autoFocus="first-tabbable",this.restoreFocus=!0,this.delayFocusTrap=!0,this.closeOnNavigation=!0}}const DA="mdc-dialog--open",I6="mdc-dialog--opening",E6="mdc-dialog--closing";let xRe=(()=>{class n extends s6{constructor(e,r,i,o,s,a,c,u){super(e,r,i,o,s,a,c,u),this._animationStateChanged=new rn}_captureInitialFocus(){this._config.delayFocusTrap||this._trapFocus()}_openAnimationDone(e){this._config.delayFocusTrap&&this._trapFocus(),this._animationStateChanged.next({state:"opened",totalTime:e})}}return n.\u0275fac=function(e){return new(e||n)(de(yn),de(xA),de(Tn,8),de(Lx),de(Mx),de(Vt),de(nb),de(rb))},n.\u0275cmp=Pi({type:n,selectors:[["ng-component"]],features:[$t],decls:0,vars:0,template:function(e,r){},encapsulation:2}),n})();const D6="--mat-dialog-transition-duration";function k6(n){return null==n?null:"number"==typeof n?n:n.endsWith("ms")?yi(n.substring(0,n.length-2)):n.endsWith("s")?1e3*yi(n.substring(0,n.length-1)):"0"===n?0:null}let wRe=(()=>{class n extends xRe{constructor(e,r,i,o,s,a,c,u,p){super(e,r,i,o,s,a,c,p),this._animationMode=u,this._animationsEnabled="NoopAnimations"!==this._animationMode,this._hostElement=this._elementRef.nativeElement,this._openAnimationDuration=this._animationsEnabled?k6(this._config.enterAnimationDuration)??150:0,this._closeAnimationDuration=this._animationsEnabled?k6(this._config.exitAnimationDuration)??75:0,this._animationTimer=null,this._finishDialogOpen=()=>{this._clearAnimationClasses(),this._openAnimationDone(this._openAnimationDuration)},this._finishDialogClose=()=>{this._clearAnimationClasses(),this._animationStateChanged.emit({state:"closed",totalTime:this._closeAnimationDuration})}}_contentAttached(){super._contentAttached(),this._startOpenAnimation()}ngOnDestroy(){super.ngOnDestroy(),null!==this._animationTimer&&clearTimeout(this._animationTimer)}_startOpenAnimation(){this._animationStateChanged.emit({state:"opening",totalTime:this._openAnimationDuration}),this._animationsEnabled?(this._hostElement.style.setProperty(D6,`${this._openAnimationDuration}ms`),this._requestAnimationFrame(()=>this._hostElement.classList.add(I6,DA)),this._waitForAnimationToComplete(this._openAnimationDuration,this._finishDialogOpen)):(this._hostElement.classList.add(DA),Promise.resolve().then(()=>this._finishDialogOpen()))}_startExitAnimation(){this._animationStateChanged.emit({state:"closing",totalTime:this._closeAnimationDuration}),this._hostElement.classList.remove(DA),this._animationsEnabled?(this._hostElement.style.setProperty(D6,`${this._openAnimationDuration}ms`),this._requestAnimationFrame(()=>this._hostElement.classList.add(E6)),this._waitForAnimationToComplete(this._closeAnimationDuration,this._finishDialogClose)):Promise.resolve().then(()=>this._finishDialogClose())}_clearAnimationClasses(){this._hostElement.classList.remove(I6,E6)}_waitForAnimationToComplete(e,r){null!==this._animationTimer&&clearTimeout(this._animationTimer),this._animationTimer=setTimeout(r,e)}_requestAnimationFrame(e){this._ngZone.runOutsideAngular(()=>{"function"==typeof requestAnimationFrame?requestAnimationFrame(e):e()})}}return n.\u0275fac=function(e){return new(e||n)(de(yn),de(xA),de(Tn,8),de(Lx),de(Mx),de(Vt),de(nb),de(ns,8),de(rb))},n.\u0275cmp=Pi({type:n,selectors:[["mat-dialog-container"]],hostAttrs:["tabindex","-1",1,"mat-mdc-dialog-container","mdc-dialog"],hostVars:8,hostBindings:function(e,r){2&e&&($y("id",r._config.id),ui("aria-modal",r._config.ariaModal)("role",r._config.role)("aria-labelledby",r._config.ariaLabel?null:r._ariaLabelledBy)("aria-label",r._config.ariaLabel)("aria-describedby",r._config.ariaDescribedBy||null),Yr("_mat-animation-noopable",!r._animationsEnabled))},features:[$t],decls:3,vars:0,consts:[[1,"mdc-dialog__container"],[1,"mat-mdc-dialog-surface","mdc-dialog__surface"],["cdkPortalOutlet",""]],template:function(e,r){1&e&&(ut(0,"div",0)(1,"div",1),Xr(2,yRe,0,0,"ng-template",2),ft()())},dependencies:[hp],styles:['.mdc-elevation-overlay{position:absolute;border-radius:inherit;pointer-events:none;opacity:var(--mdc-elevation-overlay-opacity, 0);transition:opacity 280ms cubic-bezier(0.4, 0, 0.2, 1)}.mdc-dialog,.mdc-dialog__scrim{position:fixed;top:0;left:0;align-items:center;justify-content:center;box-sizing:border-box;width:100%;height:100%}.mdc-dialog{display:none;z-index:var(--mdc-dialog-z-index, 7)}.mdc-dialog .mdc-dialog__content{padding:20px 24px 20px 24px}.mdc-dialog .mdc-dialog__surface{min-width:280px}@media(max-width: 592px){.mdc-dialog .mdc-dialog__surface{max-width:calc(100vw - 32px)}}@media(min-width: 592px){.mdc-dialog .mdc-dialog__surface{max-width:560px}}.mdc-dialog .mdc-dialog__surface{max-height:calc(100% - 32px)}.mdc-dialog.mdc-dialog--fullscreen .mdc-dialog__surface{max-width:none}@media(max-width: 960px){.mdc-dialog.mdc-dialog--fullscreen .mdc-dialog__surface{max-height:560px;width:560px}.mdc-dialog.mdc-dialog--fullscreen .mdc-dialog__surface .mdc-dialog__close{right:-12px}}@media(max-width: 720px)and (max-width: 672px){.mdc-dialog.mdc-dialog--fullscreen .mdc-dialog__surface{width:calc(100vw - 112px)}}@media(max-width: 720px)and (min-width: 672px){.mdc-dialog.mdc-dialog--fullscreen .mdc-dialog__surface{width:560px}}@media(max-width: 720px)and (max-height: 720px){.mdc-dialog.mdc-dialog--fullscreen .mdc-dialog__surface{max-height:calc(100vh - 160px)}}@media(max-width: 720px)and (min-height: 720px){.mdc-dialog.mdc-dialog--fullscreen .mdc-dialog__surface{max-height:560px}}@media(max-width: 720px){.mdc-dialog.mdc-dialog--fullscreen .mdc-dialog__surface .mdc-dialog__close{right:-12px}}@media(max-width: 720px)and (max-height: 400px),(max-width: 600px),(min-width: 720px)and (max-height: 400px){.mdc-dialog.mdc-dialog--fullscreen .mdc-dialog__surface{height:100%;max-height:100vh;max-width:100vw;width:100vw;border-radius:0}.mdc-dialog.mdc-dialog--fullscreen .mdc-dialog__surface .mdc-dialog__close{order:-1;left:-12px}.mdc-dialog.mdc-dialog--fullscreen .mdc-dialog__surface .mdc-dialog__header{padding:0 16px 9px;justify-content:flex-start}.mdc-dialog.mdc-dialog--fullscreen .mdc-dialog__surface .mdc-dialog__title{margin-left:calc(16px - 2 * 12px)}}@media(min-width: 960px){.mdc-dialog.mdc-dialog--fullscreen .mdc-dialog__surface{width:calc(100vw - 400px)}.mdc-dialog.mdc-dialog--fullscreen .mdc-dialog__surface .mdc-dialog__close{right:-12px}}.mdc-dialog.mdc-dialog__scrim--hidden .mdc-dialog__scrim{opacity:0}.mdc-dialog__scrim{opacity:0;z-index:-1}.mdc-dialog__container{display:flex;flex-direction:row;align-items:center;justify-content:space-around;box-sizing:border-box;height:100%;transform:scale(0.8);opacity:0;pointer-events:none}.mdc-dialog__surface{position:relative;display:flex;flex-direction:column;flex-grow:0;flex-shrink:0;box-sizing:border-box;max-width:100%;max-height:100%;pointer-events:auto;overflow-y:auto;outline:0}.mdc-dialog__surface .mdc-elevation-overlay{width:100%;height:100%;top:0;left:0}[dir=rtl] .mdc-dialog__surface,.mdc-dialog__surface[dir=rtl]{text-align:right}@media screen and (forced-colors: active),(-ms-high-contrast: active){.mdc-dialog__surface{outline:2px solid windowText}}.mdc-dialog__surface::before{position:absolute;box-sizing:border-box;width:100%;height:100%;top:0;left:0;border:2px solid rgba(0,0,0,0);border-radius:inherit;content:"";pointer-events:none}@media screen and (forced-colors: active){.mdc-dialog__surface::before{border-color:CanvasText}}@media screen and (-ms-high-contrast: active),screen and (-ms-high-contrast: none){.mdc-dialog__surface::before{content:none}}.mdc-dialog__title{display:block;margin-top:0;position:relative;flex-shrink:0;box-sizing:border-box;margin:0 0 1px;padding:0 24px 9px}.mdc-dialog__title::before{display:inline-block;width:0;height:40px;content:"";vertical-align:0}[dir=rtl] .mdc-dialog__title,.mdc-dialog__title[dir=rtl]{text-align:right}.mdc-dialog--scrollable .mdc-dialog__title{margin-bottom:1px;padding-bottom:15px}.mdc-dialog--fullscreen .mdc-dialog__header{align-items:baseline;border-bottom:1px solid rgba(0,0,0,0);display:inline-flex;justify-content:space-between;padding:0 24px 9px;z-index:1}@media screen and (forced-colors: active){.mdc-dialog--fullscreen .mdc-dialog__header{border-bottom-color:CanvasText}}.mdc-dialog--fullscreen .mdc-dialog__header .mdc-dialog__close{right:-12px}.mdc-dialog--fullscreen .mdc-dialog__title{margin-bottom:0;padding:0;border-bottom:0}.mdc-dialog--fullscreen.mdc-dialog--scrollable .mdc-dialog__title{border-bottom:0;margin-bottom:0}.mdc-dialog--fullscreen .mdc-dialog__close{top:5px}.mdc-dialog--fullscreen.mdc-dialog--scrollable .mdc-dialog__actions{border-top:1px solid rgba(0,0,0,0)}@media screen and (forced-colors: active){.mdc-dialog--fullscreen.mdc-dialog--scrollable .mdc-dialog__actions{border-top-color:CanvasText}}.mdc-dialog--fullscreen--titleless .mdc-dialog__close{margin-top:4px}.mdc-dialog--fullscreen--titleless.mdc-dialog--scrollable .mdc-dialog__close{margin-top:0}.mdc-dialog__content{flex-grow:1;box-sizing:border-box;margin:0;overflow:auto}.mdc-dialog__content>:first-child{margin-top:0}.mdc-dialog__content>:last-child{margin-bottom:0}.mdc-dialog__title+.mdc-dialog__content,.mdc-dialog__header+.mdc-dialog__content{padding-top:0}.mdc-dialog--scrollable .mdc-dialog__title+.mdc-dialog__content{padding-top:8px;padding-bottom:8px}.mdc-dialog__content .mdc-deprecated-list:first-child:last-child{padding:6px 0 0}.mdc-dialog--scrollable .mdc-dialog__content .mdc-deprecated-list:first-child:last-child{padding:0}.mdc-dialog__actions{display:flex;position:relative;flex-shrink:0;flex-wrap:wrap;align-items:center;justify-content:flex-end;box-sizing:border-box;min-height:52px;margin:0;padding:8px;border-top:1px solid rgba(0,0,0,0)}@media screen and (forced-colors: active){.mdc-dialog__actions{border-top-color:CanvasText}}.mdc-dialog--stacked .mdc-dialog__actions{flex-direction:column;align-items:flex-end}.mdc-dialog__button{margin-left:8px;margin-right:0;max-width:100%;text-align:right}[dir=rtl] .mdc-dialog__button,.mdc-dialog__button[dir=rtl]{margin-left:0;margin-right:8px}.mdc-dialog__button:first-child{margin-left:0;margin-right:0}[dir=rtl] .mdc-dialog__button:first-child,.mdc-dialog__button:first-child[dir=rtl]{margin-left:0;margin-right:0}[dir=rtl] .mdc-dialog__button,.mdc-dialog__button[dir=rtl]{text-align:left}.mdc-dialog--stacked .mdc-dialog__button:not(:first-child){margin-top:12px}.mdc-dialog--open,.mdc-dialog--opening,.mdc-dialog--closing{display:flex}.mdc-dialog--opening .mdc-dialog__scrim{transition:opacity 150ms linear}.mdc-dialog--opening .mdc-dialog__container{transition:opacity 75ms linear,transform 150ms 0ms cubic-bezier(0, 0, 0.2, 1)}.mdc-dialog--closing .mdc-dialog__scrim,.mdc-dialog--closing .mdc-dialog__container{transition:opacity 75ms linear}.mdc-dialog--closing .mdc-dialog__container{transform:none}.mdc-dialog--open .mdc-dialog__scrim{opacity:1}.mdc-dialog--open .mdc-dialog__container{transform:none;opacity:1}.mdc-dialog--open.mdc-dialog__surface-scrim--shown .mdc-dialog__surface-scrim{opacity:1}.mdc-dialog--open.mdc-dialog__surface-scrim--hiding .mdc-dialog__surface-scrim{transition:opacity 75ms linear}.mdc-dialog--open.mdc-dialog__surface-scrim--showing .mdc-dialog__surface-scrim{transition:opacity 150ms linear}.mdc-dialog__surface-scrim{display:none;opacity:0;position:absolute;width:100%;height:100%;z-index:1}.mdc-dialog__surface-scrim--shown .mdc-dialog__surface-scrim,.mdc-dialog__surface-scrim--showing .mdc-dialog__surface-scrim,.mdc-dialog__surface-scrim--hiding .mdc-dialog__surface-scrim{display:block}.mdc-dialog-scroll-lock{overflow:hidden}.mdc-dialog--no-content-padding .mdc-dialog__content{padding:0}.mdc-dialog--sheet .mdc-dialog__container .mdc-dialog__close{right:12px;top:9px;position:absolute;z-index:1}.mdc-dialog__scrim--removed{pointer-events:none}.mdc-dialog__scrim--removed .mdc-dialog__scrim,.mdc-dialog__scrim--removed .mdc-dialog__surface-scrim{display:none}.mat-mdc-dialog-content{max-height:65vh}.mat-mdc-dialog-container{position:static;display:block}.mat-mdc-dialog-container,.mat-mdc-dialog-container .mdc-dialog__container,.mat-mdc-dialog-container .mdc-dialog__surface{max-height:inherit;min-height:inherit;min-width:inherit;max-width:inherit}.mat-mdc-dialog-container .mdc-dialog__surface{display:block;width:100%;height:100%}.mat-mdc-dialog-container{--mdc-dialog-container-elevation-shadow:0px 11px 15px -7px rgba(0, 0, 0, 0.2), 0px 24px 38px 3px rgba(0, 0, 0, 0.14), 0px 9px 46px 8px rgba(0, 0, 0, 0.12);--mdc-dialog-container-shadow-color:#000;--mdc-dialog-container-shape:4px;--mdc-dialog-container-elevation: var(--mdc-dialog-container-elevation-shadow);outline:0}.mat-mdc-dialog-container .mdc-dialog__surface{background-color:var(--mdc-dialog-container-color, white)}.mat-mdc-dialog-container .mdc-dialog__surface{box-shadow:var(--mdc-dialog-container-elevation, 0px 11px 15px -7px rgba(0, 0, 0, 0.2), 0px 24px 38px 3px rgba(0, 0, 0, 0.14), 0px 9px 46px 8px rgba(0, 0, 0, 0.12))}.mat-mdc-dialog-container .mdc-dialog__surface{border-radius:var(--mdc-dialog-container-shape, 4px)}.mat-mdc-dialog-container .mdc-dialog__title{font-family:var(--mdc-dialog-subhead-font, Roboto, sans-serif);line-height:var(--mdc-dialog-subhead-line-height, 1.5rem);font-size:var(--mdc-dialog-subhead-size, 1rem);font-weight:var(--mdc-dialog-subhead-weight, 400);letter-spacing:var(--mdc-dialog-subhead-tracking, 0.03125em)}.mat-mdc-dialog-container .mdc-dialog__title{color:var(--mdc-dialog-subhead-color, rgba(0, 0, 0, 0.87))}.mat-mdc-dialog-container .mdc-dialog__content{font-family:var(--mdc-dialog-supporting-text-font, Roboto, sans-serif);line-height:var(--mdc-dialog-supporting-text-line-height, 1.5rem);font-size:var(--mdc-dialog-supporting-text-size, 1rem);font-weight:var(--mdc-dialog-supporting-text-weight, 400);letter-spacing:var(--mdc-dialog-supporting-text-tracking, 0.03125em)}.mat-mdc-dialog-container .mdc-dialog__content{color:var(--mdc-dialog-supporting-text-color, rgba(0, 0, 0, 0.6))}.mat-mdc-dialog-container .mdc-dialog__container{transition-duration:var(--mat-dialog-transition-duration, 0ms)}.mat-mdc-dialog-container._mat-animation-noopable .mdc-dialog__container{transition:none}.mat-mdc-dialog-content{display:block}.mat-mdc-dialog-actions{justify-content:start}.mat-mdc-dialog-actions.mat-mdc-dialog-actions-align-center,.mat-mdc-dialog-actions[align=center]{justify-content:center}.mat-mdc-dialog-actions.mat-mdc-dialog-actions-align-end,.mat-mdc-dialog-actions[align=end]{justify-content:flex-end}.mat-mdc-dialog-actions .mat-button-base+.mat-button-base,.mat-mdc-dialog-actions .mat-mdc-button-base+.mat-mdc-button-base{margin-left:8px}[dir=rtl] .mat-mdc-dialog-actions .mat-button-base+.mat-button-base,[dir=rtl] .mat-mdc-dialog-actions .mat-mdc-button-base+.mat-mdc-button-base{margin-left:0;margin-right:8px}'],encapsulation:2}),n})();class kA{constructor(t,e,r){this._ref=t,this._containerInstance=r,this._afterOpened=new Kt,this._beforeClosed=new Kt,this._state=0,this.disableClose=e.disableClose,this.id=t.id,r._animationStateChanged.pipe(zi(i=>"opened"===i.state),is(1)).subscribe(()=>{this._afterOpened.next(),this._afterOpened.complete()}),r._animationStateChanged.pipe(zi(i=>"closed"===i.state),is(1)).subscribe(()=>{clearTimeout(this._closeFallbackTimeout),this._finishDialogClose()}),t.overlayRef.detachments().subscribe(()=>{this._beforeClosed.next(this._result),this._beforeClosed.complete(),this._finishDialogClose()}),Et(this.backdropClick(),this.keydownEvents().pipe(zi(i=>27===i.keyCode&&!this.disableClose&&!Rx(i)))).subscribe(i=>{this.disableClose||(i.preventDefault(),function TRe(n,t,e){n._closeInteractionType=t,n.close(e)}(this,"keydown"===i.type?"keyboard":"mouse"))})}close(t){this._result=t,this._containerInstance._animationStateChanged.pipe(zi(e=>"closing"===e.state),is(1)).subscribe(e=>{this._beforeClosed.next(t),this._beforeClosed.complete(),this._ref.overlayRef.detachBackdrop(),this._closeFallbackTimeout=setTimeout(()=>this._finishDialogClose(),e.totalTime+100)}),this._state=1,this._containerInstance._startExitAnimation()}afterOpened(){return this._afterOpened}afterClosed(){return this._ref.closed}beforeClosed(){return this._beforeClosed}backdropClick(){return this._ref.backdropClick}keydownEvents(){return this._ref.keydownEvents}updatePosition(t){let e=this._ref.config.positionStrategy;return t&&(t.left||t.right)?t.left?e.left(t.left):e.right(t.right):e.centerHorizontally(),t&&(t.top||t.bottom)?t.top?e.top(t.top):e.bottom(t.bottom):e.centerVertically(),this._ref.updatePosition(),this}updateSize(t="",e=""){return this._ref.updateSize(t,e),this}addPanelClass(t){return this._ref.addPanelClass(t),this}removePanelClass(t){return this._ref.removePanelClass(t),this}getState(){return this._state}_finishDialogClose(){this._state=2,this._ref.close(this._result,{focusOrigin:this._closeInteractionType}),this.componentInstance=null}}const AA=new Qe("MatMdcDialogData"),SRe=new Qe("mat-mdc-dialog-default-options"),A6=new Qe("mat-mdc-dialog-scroll-strategy"),IRe={provide:A6,deps:[pp],useFactory:function CRe(n){return()=>n.scrollStrategies.block()}};let ERe=0,DRe=(()=>{class n{get openDialogs(){return this._parentDialog?this._parentDialog.openDialogs:this._openDialogsAtThisLevel}get afterOpened(){return this._parentDialog?this._parentDialog.afterOpened:this._afterOpenedAtThisLevel}_getAfterAllClosed(){const e=this._parentDialog;return e?e._getAfterAllClosed():this._afterAllClosedAtThisLevel}constructor(e,r,i,o,s,a,c,u,p,m){this._overlay=e,this._defaultOptions=i,this._parentDialog=o,this._dialogRefConstructor=c,this._dialogContainerType=u,this._dialogDataToken=p,this._openDialogsAtThisLevel=[],this._afterAllClosedAtThisLevel=new Kt,this._afterOpenedAtThisLevel=new Kt,this._idPrefix="mat-dialog-",this.dialogConfigClass=Lx,this.afterAllClosed=m_(()=>this.openDialogs.length?this._getAfterAllClosed():this._getAfterAllClosed().pipe(_u(void 0))),this._scrollStrategy=a,this._dialog=r.get(l6)}open(e,r){let i;(r={...this._defaultOptions||new Lx,...r}).id=r.id||`${this._idPrefix}${ERe++}`,r.scrollStrategy=r.scrollStrategy||this._scrollStrategy();const o=this._dialog.open(e,{...r,positionStrategy:this._overlay.position().global().centerHorizontally().centerVertically(),disableClose:!0,closeOnDestroy:!1,closeOnOverlayDetachments:!1,container:{type:this._dialogContainerType,providers:()=>[{provide:this.dialogConfigClass,useValue:r},{provide:Px,useValue:r}]},templateContext:()=>({dialogRef:i}),providers:(s,a,c)=>(i=new this._dialogRefConstructor(s,r,c),i.updatePosition(r?.position),[{provide:this._dialogContainerType,useValue:c},{provide:this._dialogDataToken,useValue:a.data},{provide:this._dialogRefConstructor,useValue:i}])});return i.componentInstance=o.componentInstance,this.openDialogs.push(i),this.afterOpened.next(i),i.afterClosed().subscribe(()=>{const s=this.openDialogs.indexOf(i);s>-1&&(this.openDialogs.splice(s,1),this.openDialogs.length||this._getAfterAllClosed().next())}),i}closeAll(){this._closeDialogs(this.openDialogs)}getDialogById(e){return this.openDialogs.find(r=>r.id===e)}ngOnDestroy(){this._closeDialogs(this._openDialogsAtThisLevel),this._afterAllClosedAtThisLevel.complete(),this._afterOpenedAtThisLevel.complete()}_closeDialogs(e){let r=e.length;for(;r--;)e[r].close()}}return n.\u0275fac=function(e){wy()},n.\u0275prov=at({token:n,factory:n.\u0275fac}),n})(),NA=(()=>{class n extends DRe{constructor(e,r,i,o,s,a,c,u){super(e,r,o,a,c,s,kA,wRe,AA,u),this._idPrefix="mat-mdc-dialog-"}}return n.\u0275fac=function(e){return new(e||n)(Fe(pp),Fe(Qi),Fe($f,8),Fe(SRe,8),Fe(A6),Fe(n,12),Fe(Ox),Fe(ns,8))},n.\u0275prov=at({token:n,factory:n.\u0275fac}),n})(),kRe=(()=>{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275mod=Vn({type:n}),n.\u0275inj=Pn({providers:[NA,IRe],imports:[sRe,jG,tb,Do,Do]}),n})(),ARe=(()=>{class n{constructor(e,r){this.dialogRef=e,this.data=r}ngOnInit(){console.log(this.data)}}return n.\u0275fac=function(e){return new(e||n)(de(kA),de(AA))},n.\u0275cmp=Pi({type:n,selectors:[["app-image-dialog"]],decls:4,vars:2,consts:[[1,"text-xl","p-2","font-bold","text-center","text-gray-900"],[3,"src"]],template:function(e,r){1&e&&(ut(0,"div")(1,"h1",0),_n(2),ft(),kr(3,"img",1),ft()),2&e&&(At(2),Ql(" ",r.data.name," "),At(1),nn("src",r.data.image,IT))}}),n})();var Gs=P(895);Gs.env.wasm.wasmPaths={"ort-wasm.wasm":"assets/onnx-wasm/ort-wasm.wasm","ort-wasm-simd.wasm":"assets/onnx-wasm/ort-wasm-simd.wasm","ort-wasm-threaded.wasm":"assets/onnx-wasm/ort-wasm-threaded.wasm"};let NRe=(()=>{class n{constructor(){}predict(e,r,i,o){var s=this;return $e(function*(){s.session=yield Gs.InferenceSession.create("assets/onnx_models/wams-hip-1.onnx");const c=new Gs.Tensor(new Float32Array([e,r,i,o]),[1,4]);return(yield s.session.run({X:c})).variable.data[0]})()}}return n.\u0275fac=function(e){return new(e||n)},n.\u0275prov=at({token:n,factory:n.\u0275fac,providedIn:"root"}),n})();Gs.env.wasm.wasmPaths={"ort-wasm.wasm":"assets/onnx-wasm/ort-wasm.wasm","ort-wasm-simd.wasm":"assets/onnx-wasm/ort-wasm-simd.wasm","ort-wasm-threaded.wasm":"assets/onnx-wasm/ort-wasm-threaded.wasm"};let ORe=(()=>{class n{constructor(){}getConfidenceModelURLs(e){return $e(function*(){return lNe[e]})()}predictConfidence(e,r,i,o,s){var a=this;return $e(function*(){a.session=yield Gs.InferenceSession.create(e);const c=new Gs.Tensor(new Float32Array([i,o,r,s]),[1,4]);return(yield a.session.run({X:c})).variable.data[0]})()}predictBase(e,r,i,o){var s=this;return $e(function*(){s.session=yield Gs.InferenceSession.create("assets/confidence_models/lightgbm_model_1-2-2024_0.5.onnx");const c=new Gs.Tensor(new Float32Array([r,i,e,o]),[1,4]);return(yield s.session.run({X:c})).variable.data[0]})()}predict10PercentQuantile(e,r,i,o){var s=this;return $e(function*(){s.session=yield Gs.InferenceSession.create("assets/confidence_models/lightgbm_model_1-2-2024_0.1.onnx");const c=new Gs.Tensor(new Float32Array([r,i,e,o]),[1,4]);return(yield s.session.run({X:c})).variable.data[0]})()}predict90PercentQuantile(e,r,i,o){var s=this;return $e(function*(){s.session=yield Gs.InferenceSession.create("assets/confidence_models/lightgbm_model_1-2-2024_0.9.onnx");const c=new Gs.Tensor(new Float32Array([r,i,e,o]),[1,4]);return(yield s.session.run({X:c})).variable.data[0]})()}}return n.\u0275fac=function(e){return new(e||n)},n.\u0275prov=at({token:n,factory:n.\u0275fac,providedIn:"root"}),n})(),O6=(()=>{class n{constructor(e,r){this._renderer=e,this._elementRef=r,this.onChange=i=>{},this.onTouched=()=>{}}setProperty(e,r){this._renderer.setProperty(this._elementRef.nativeElement,e,r)}registerOnTouched(e){this.onTouched=e}registerOnChange(e){this.onChange=e}setDisabledState(e){this.setProperty("disabled",e)}}return n.\u0275fac=function(e){return new(e||n)(de(dl),de(yn))},n.\u0275dir=_t({type:n}),n})(),id=(()=>{class n extends O6{}return n.\u0275fac=function(){let t;return function(r){return(t||(t=qr(n)))(r||n)}}(),n.\u0275dir=_t({type:n,features:[$t]}),n})();const ys=new Qe("NgValueAccessor"),FRe={provide:ys,useExisting:Dt(()=>Bx),multi:!0},$Re=new Qe("CompositionEventMode");let Bx=(()=>{class n extends O6{constructor(e,r,i){super(e,r),this._compositionMode=i,this._composing=!1,null==this._compositionMode&&(this._compositionMode=!function PRe(){const n=tc()?tc().getUserAgent():"";return/android (\d+)/.test(n.toLowerCase())}())}writeValue(e){this.setProperty("value",e??"")}_handleInput(e){(!this._compositionMode||this._compositionMode&&!this._composing)&&this.onChange(e)}_compositionStart(){this._composing=!0}_compositionEnd(e){this._composing=!1,this._compositionMode&&this.onChange(e)}}return n.\u0275fac=function(e){return new(e||n)(de(dl),de(yn),de($Re,8))},n.\u0275dir=_t({type:n,selectors:[["input","formControlName","",3,"type","checkbox"],["textarea","formControlName",""],["input","formControl","",3,"type","checkbox"],["textarea","formControl",""],["input","ngModel","",3,"type","checkbox"],["textarea","ngModel",""],["","ngDefaultControl",""]],hostBindings:function(e,r){1&e&&an("input",function(o){return r._handleInput(o.target.value)})("blur",function(){return r.onTouched()})("compositionstart",function(){return r._compositionStart()})("compositionend",function(o){return r._compositionEnd(o.target.value)})},features:[En([FRe]),$t]}),n})();function Gc(n){return null==n||("string"==typeof n||Array.isArray(n))&&0===n.length}function M6(n){return null!=n&&"number"==typeof n.length}const co=new Qe("NgValidators"),Hc=new Qe("NgAsyncValidators"),LRe=/^(?=.{1,254}$)(?=.{1,64}@)[a-zA-Z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-zA-Z0-9!#$%&'*+/=?^_`{|}~-]+)*@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;class BRe{static min(t){return function F6(n){return t=>{if(Gc(t.value)||Gc(n))return null;const e=parseFloat(t.value);return!isNaN(e)&&e<n?{min:{min:n,actual:t.value}}:null}}(t)}static max(t){return function P6(n){return t=>{if(Gc(t.value)||Gc(n))return null;const e=parseFloat(t.value);return!isNaN(e)&&e>n?{max:{max:n,actual:t.value}}:null}}(t)}static required(t){return function $6(n){return Gc(n.value)?{required:!0}:null}(t)}static requiredTrue(t){return function L6(n){return!0===n.value?null:{required:!0}}(t)}static email(t){return function B6(n){return Gc(n.value)||LRe.test(n.value)?null:{email:!0}}(t)}static minLength(t){return function V6(n){return t=>Gc(t.value)||!M6(t.value)?null:t.value.length<n?{minlength:{requiredLength:n,actualLength:t.value.length}}:null}(t)}static maxLength(t){return function z6(n){return t=>M6(t.value)&&t.value.length>n?{maxlength:{requiredLength:n,actualLength:t.value.length}}:null}(t)}static pattern(t){return function U6(n){if(!n)return Vx;let t,e;return"string"==typeof n?(e="","^"!==n.charAt(0)&&(e+="^"),e+=n,"$"!==n.charAt(n.length-1)&&(e+="$"),t=new RegExp(e)):(e=n.toString(),t=n),r=>{if(Gc(r.value))return null;const i=r.value;return t.test(i)?null:{pattern:{requiredPattern:e,actualValue:i}}}}(t)}static nullValidator(t){return null}static compose(t){return K6(t)}static composeAsync(t){return X6(t)}}function Vx(n){return null}function j6(n){return null!=n}function G6(n){return wf(n)?tt(n):n}function H6(n){let t={};return n.forEach(e=>{t=null!=e?{...t,...e}:t}),0===Object.keys(t).length?null:t}function W6(n,t){return t.map(e=>e(n))}function q6(n){return n.map(t=>function VRe(n){return!n.validate}(t)?t:e=>t.validate(e))}function K6(n){if(!n)return null;const t=n.filter(j6);return 0==t.length?null:function(e){return H6(W6(e,t))}}function OA(n){return null!=n?K6(q6(n)):null}function X6(n){if(!n)return null;const t=n.filter(j6);return 0==t.length?null:function(e){return function RRe(...n){const t=Ap(n),{args:e,keys:r}=$$(n),i=new An(o=>{const{length:s}=e;if(!s)return void o.complete();const a=new Array(s);let c=s,u=s;for(let p=0;p<s;p++){let m=!1;wi(e[p]).subscribe(Bn(o,g=>{m||(m=!0,u--),a[p]=g},()=>c--,void 0,()=>{(!c||!m)&&(u||o.next(r?L$(r,a):a),o.complete())}))}});return t?i.pipe(PS(t)):i}(W6(e,t).map(G6)).pipe(ct(H6))}}function RA(n){return null!=n?X6(q6(n)):null}function Y6(n,t){return null===n?[t]:Array.isArray(n)?[...n,t]:[n,t]}function Z6(n){return n._rawValidators}function Q6(n){return n._rawAsyncValidators}function MA(n){return n?Array.isArray(n)?n:[n]:[]}function zx(n,t){return Array.isArray(n)?n.includes(t):n===t}function J6(n,t){const e=MA(t);return MA(n).forEach(i=>{zx(e,i)||e.push(i)}),e}function eH(n,t){return MA(t).filter(e=>!zx(n,e))}class tH{constructor(){this._rawValidators=[],this._rawAsyncValidators=[],this._onDestroyCallbacks=[]}get value(){return this.control?this.control.value:null}get valid(){return this.control?this.control.valid:null}get invalid(){return this.control?this.control.invalid:null}get pending(){return this.control?this.control.pending:null}get disabled(){return this.control?this.control.disabled:null}get enabled(){return this.control?this.control.enabled:null}get errors(){return this.control?this.control.errors:null}get pristine(){return this.control?this.control.pristine:null}get dirty(){return this.control?this.control.dirty:null}get touched(){return this.control?this.control.touched:null}get status(){return this.control?this.control.status:null}get untouched(){return this.control?this.control.untouched:null}get statusChanges(){return this.control?this.control.statusChanges:null}get valueChanges(){return this.control?this.control.valueChanges:null}get path(){return null}_setValidators(t){this._rawValidators=t||[],this._composedValidatorFn=OA(this._rawValidators)}_setAsyncValidators(t){this._rawAsyncValidators=t||[],this._composedAsyncValidatorFn=RA(this._rawAsyncValidators)}get validator(){return this._composedValidatorFn||null}get asyncValidator(){return this._composedAsyncValidatorFn||null}_registerOnDestroy(t){this._onDestroyCallbacks.push(t)}_invokeOnDestroyCallbacks(){this._onDestroyCallbacks.forEach(t=>t()),this._onDestroyCallbacks=[]}reset(t=void 0){this.control&&this.control.reset(t)}hasError(t,e){return!!this.control&&this.control.hasError(t,e)}getError(t,e){return this.control?this.control.getError(t,e):null}}class ko extends tH{get formDirective(){return null}get path(){return null}}class Fl extends tH{constructor(){super(...arguments),this._parent=null,this.name=null,this.valueAccessor=null}}class nH{constructor(t){this._cd=t}get isTouched(){return!!this._cd?.control?.touched}get isUntouched(){return!!this._cd?.control?.untouched}get isPristine(){return!!this._cd?.control?.pristine}get isDirty(){return!!this._cd?.control?.dirty}get isValid(){return!!this._cd?.control?.valid}get isInvalid(){return!!this._cd?.control?.invalid}get isPending(){return!!this._cd?.control?.pending}get isSubmitted(){return!!this._cd?.submitted}}let rH=(()=>{class n extends nH{constructor(e){super(e)}}return n.\u0275fac=function(e){return new(e||n)(de(Fl,2))},n.\u0275dir=_t({type:n,selectors:[["","formControlName",""],["","ngModel",""],["","formControl",""]],hostVars:14,hostBindings:function(e,r){2&e&&Yr("ng-untouched",r.isUntouched)("ng-touched",r.isTouched)("ng-pristine",r.isPristine)("ng-dirty",r.isDirty)("ng-valid",r.isValid)("ng-invalid",r.isInvalid)("ng-pending",r.isPending)},features:[$t]}),n})(),iH=(()=>{class n extends nH{constructor(e){super(e)}}return n.\u0275fac=function(e){return new(e||n)(de(ko,10))},n.\u0275dir=_t({type:n,selectors:[["","formGroupName",""],["","formArrayName",""],["","ngModelGroup",""],["","formGroup",""],["form",3,"ngNoForm",""],["","ngForm",""]],hostVars:16,hostBindings:function(e,r){2&e&&Yr("ng-untouched",r.isUntouched)("ng-touched",r.isTouched)("ng-pristine",r.isPristine)("ng-dirty",r.isDirty)("ng-valid",r.isValid)("ng-invalid",r.isInvalid)("ng-pending",r.isPending)("ng-submitted",r.isSubmitted)},features:[$t]}),n})();const lb="VALID",jx="INVALID",yp="PENDING",cb="DISABLED";function $A(n){return(Gx(n)?n.validators:n)||null}function LA(n,t){return(Gx(t)?t.asyncValidators:n)||null}function Gx(n){return null!=n&&!Array.isArray(n)&&"object"==typeof n}class lH{constructor(t,e){this._pendingDirty=!1,this._hasOwnPendingAsyncValidator=!1,this._pendingTouched=!1,this._onCollectionChange=()=>{},this._parent=null,this.pristine=!0,this.touched=!1,this._onDisabledChange=[],this._assignValidators(t),this._assignAsyncValidators(e)}get validator(){return this._composedValidatorFn}set validator(t){this._rawValidators=this._composedValidatorFn=t}get asyncValidator(){return this._composedAsyncValidatorFn}set asyncValidator(t){this._rawAsyncValidators=this._composedAsyncValidatorFn=t}get parent(){return this._parent}get valid(){return this.status===lb}get invalid(){return this.status===jx}get pending(){return this.status==yp}get disabled(){return this.status===cb}get enabled(){return this.status!==cb}get dirty(){return!this.pristine}get untouched(){return!this.touched}get updateOn(){return this._updateOn?this._updateOn:this.parent?this.parent.updateOn:"change"}setValidators(t){this._assignValidators(t)}setAsyncValidators(t){this._assignAsyncValidators(t)}addValidators(t){this.setValidators(J6(t,this._rawValidators))}addAsyncValidators(t){this.setAsyncValidators(J6(t,this._rawAsyncValidators))}removeValidators(t){this.setValidators(eH(t,this._rawValidators))}removeAsyncValidators(t){this.setAsyncValidators(eH(t,this._rawAsyncValidators))}hasValidator(t){return zx(this._rawValidators,t)}hasAsyncValidator(t){return zx(this._rawAsyncValidators,t)}clearValidators(){this.validator=null}clearAsyncValidators(){this.asyncValidator=null}markAsTouched(t={}){this.touched=!0,this._parent&&!t.onlySelf&&this._parent.markAsTouched(t)}markAllAsTouched(){this.markAsTouched({onlySelf:!0}),this._forEachChild(t=>t.markAllAsTouched())}markAsUntouched(t={}){this.touched=!1,this._pendingTouched=!1,this._forEachChild(e=>{e.markAsUntouched({onlySelf:!0})}),this._parent&&!t.onlySelf&&this._parent._updateTouched(t)}markAsDirty(t={}){this.pristine=!1,this._parent&&!t.onlySelf&&this._parent.markAsDirty(t)}markAsPristine(t={}){this.pristine=!0,this._pendingDirty=!1,this._forEachChild(e=>{e.markAsPristine({onlySelf:!0})}),this._parent&&!t.onlySelf&&this._parent._updatePristine(t)}markAsPending(t={}){this.status=yp,!1!==t.emitEvent&&this.statusChanges.emit(this.status),this._parent&&!t.onlySelf&&this._parent.markAsPending(t)}disable(t={}){const e=this._parentMarkedDirty(t.onlySelf);this.status=cb,this.errors=null,this._forEachChild(r=>{r.disable({...t,onlySelf:!0})}),this._updateValue(),!1!==t.emitEvent&&(this.valueChanges.emit(this.value),this.statusChanges.emit(this.status)),this._updateAncestors({...t,skipPristineCheck:e}),this._onDisabledChange.forEach(r=>r(!0))}enable(t={}){const e=this._parentMarkedDirty(t.onlySelf);this.status=lb,this._forEachChild(r=>{r.enable({...t,onlySelf:!0})}),this.updateValueAndValidity({onlySelf:!0,emitEvent:t.emitEvent}),this._updateAncestors({...t,skipPristineCheck:e}),this._onDisabledChange.forEach(r=>r(!1))}_updateAncestors(t){this._parent&&!t.onlySelf&&(this._parent.updateValueAndValidity(t),t.skipPristineCheck||this._parent._updatePristine(),this._parent._updateTouched())}setParent(t){this._parent=t}getRawValue(){return this.value}updateValueAndValidity(t={}){this._setInitialStatus(),this._updateValue(),this.enabled&&(this._cancelExistingSubscription(),this.errors=this._runValidator(),this.status=this._calculateStatus(),(this.status===lb||this.status===yp)&&this._runAsyncValidator(t.emitEvent)),!1!==t.emitEvent&&(this.valueChanges.emit(this.value),this.statusChanges.emit(this.status)),this._parent&&!t.onlySelf&&this._parent.updateValueAndValidity(t)}_updateTreeValidity(t={emitEvent:!0}){this._forEachChild(e=>e._updateTreeValidity(t)),this.updateValueAndValidity({onlySelf:!0,emitEvent:t.emitEvent})}_setInitialStatus(){this.status=this._allControlsDisabled()?cb:lb}_runValidator(){return this.validator?this.validator(this):null}_runAsyncValidator(t){if(this.asyncValidator){this.status=yp,this._hasOwnPendingAsyncValidator=!0;const e=G6(this.asyncValidator(this));this._asyncValidationSubscription=e.subscribe(r=>{this._hasOwnPendingAsyncValidator=!1,this.setErrors(r,{emitEvent:t})})}}_cancelExistingSubscription(){this._asyncValidationSubscription&&(this._asyncValidationSubscription.unsubscribe(),this._hasOwnPendingAsyncValidator=!1)}setErrors(t,e={}){this.errors=t,this._updateControlsErrors(!1!==e.emitEvent)}get(t){let e=t;return null==e||(Array.isArray(e)||(e=e.split(".")),0===e.length)?null:e.reduce((r,i)=>r&&r._find(i),this)}getError(t,e){const r=e?this.get(e):this;return r&&r.errors?r.errors[t]:null}hasError(t,e){return!!this.getError(t,e)}get root(){let t=this;for(;t._parent;)t=t._parent;return t}_updateControlsErrors(t){this.status=this._calculateStatus(),t&&this.statusChanges.emit(this.status),this._parent&&this._parent._updateControlsErrors(t)}_initObservables(){this.valueChanges=new rn,this.statusChanges=new rn}_calculateStatus(){return this._allControlsDisabled()?cb:this.errors?jx:this._hasOwnPendingAsyncValidator||this._anyControlsHaveStatus(yp)?yp:this._anyControlsHaveStatus(jx)?jx:lb}_anyControlsHaveStatus(t){return this._anyControls(e=>e.status===t)}_anyControlsDirty(){return this._anyControls(t=>t.dirty)}_anyControlsTouched(){return this._anyControls(t=>t.touched)}_updatePristine(t={}){this.pristine=!this._anyControlsDirty(),this._parent&&!t.onlySelf&&this._parent._updatePristine(t)}_updateTouched(t={}){this.touched=this._anyControlsTouched(),this._parent&&!t.onlySelf&&this._parent._updateTouched(t)}_registerOnCollectionChange(t){this._onCollectionChange=t}_setUpdateStrategy(t){Gx(t)&&null!=t.updateOn&&(this._updateOn=t.updateOn)}_parentMarkedDirty(t){return!t&&!(!this._parent||!this._parent.dirty)&&!this._parent._anyControlsDirty()}_find(t){return null}_assignValidators(t){this._rawValidators=Array.isArray(t)?t.slice():t,this._composedValidatorFn=function GRe(n){return Array.isArray(n)?OA(n):n||null}(this._rawValidators)}_assignAsyncValidators(t){this._rawAsyncValidators=Array.isArray(t)?t.slice():t,this._composedAsyncValidatorFn=function HRe(n){return Array.isArray(n)?RA(n):n||null}(this._rawAsyncValidators)}}class BA extends lH{constructor(t,e,r){super($A(e),LA(r,e)),this.controls=t,this._initObservables(),this._setUpdateStrategy(e),this._setUpControls(),this.updateValueAndValidity({onlySelf:!0,emitEvent:!!this.asyncValidator})}registerControl(t,e){return this.controls[t]?this.controls[t]:(this.controls[t]=e,e.setParent(this),e._registerOnCollectionChange(this._onCollectionChange),e)}addControl(t,e,r={}){this.registerControl(t,e),this.updateValueAndValidity({emitEvent:r.emitEvent}),this._onCollectionChange()}removeControl(t,e={}){this.controls[t]&&this.controls[t]._registerOnCollectionChange(()=>{}),delete this.controls[t],this.updateValueAndValidity({emitEvent:e.emitEvent}),this._onCollectionChange()}setControl(t,e,r={}){this.controls[t]&&this.controls[t]._registerOnCollectionChange(()=>{}),delete this.controls[t],e&&this.registerControl(t,e),this.updateValueAndValidity({emitEvent:r.emitEvent}),this._onCollectionChange()}contains(t){return this.controls.hasOwnProperty(t)&&this.controls[t].enabled}setValue(t,e={}){(function aH(n,t,e){n._forEachChild((r,i)=>{if(void 0===e[i])throw new ze(1002,"")})})(this,0,t),Object.keys(t).forEach(r=>{(function sH(n,t,e){const r=n.controls;if(!(t?Object.keys(r):r).length)throw new ze(1e3,"");if(!r[e])throw new ze(1001,"")})(this,!0,r),this.controls[r].setValue(t[r],{onlySelf:!0,emitEvent:e.emitEvent})}),this.updateValueAndValidity(e)}patchValue(t,e={}){null!=t&&(Object.keys(t).forEach(r=>{const i=this.controls[r];i&&i.patchValue(t[r],{onlySelf:!0,emitEvent:e.emitEvent})}),this.updateValueAndValidity(e))}reset(t={},e={}){this._forEachChild((r,i)=>{r.reset(t[i],{onlySelf:!0,emitEvent:e.emitEvent})}),this._updatePristine(e),this._updateTouched(e),this.updateValueAndValidity(e)}getRawValue(){return this._reduceChildren({},(t,e,r)=>(t[r]=e.getRawValue(),t))}_syncPendingControls(){let t=this._reduceChildren(!1,(e,r)=>!!r._syncPendingControls()||e);return t&&this.updateValueAndValidity({onlySelf:!0}),t}_forEachChild(t){Object.keys(this.controls).forEach(e=>{const r=this.controls[e];r&&t(r,e)})}_setUpControls(){this._forEachChild(t=>{t.setParent(this),t._registerOnCollectionChange(this._onCollectionChange)})}_updateValue(){this.value=this._reduceValue()}_anyControls(t){for(const[e,r]of Object.entries(this.controls))if(this.contains(e)&&t(r))return!0;return!1}_reduceValue(){return this._reduceChildren({},(e,r,i)=>((r.enabled||this.disabled)&&(e[i]=r.value),e))}_reduceChildren(t,e){let r=t;return this._forEachChild((i,o)=>{r=e(r,i,o)}),r}_allControlsDisabled(){for(const t of Object.keys(this.controls))if(this.controls[t].enabled)return!1;return Object.keys(this.controls).length>0||this.disabled}_find(t){return this.controls.hasOwnProperty(t)?this.controls[t]:null}}const _p=new Qe("CallSetDisabledState",{providedIn:"root",factory:()=>Hx}),Hx="always";function ub(n,t,e=Hx){VA(n,t),t.valueAccessor.writeValue(n.value),(n.disabled||"always"===e)&&t.valueAccessor.setDisabledState?.(n.disabled),function KRe(n,t){t.valueAccessor.registerOnChange(e=>{n._pendingValue=e,n._pendingChange=!0,n._pendingDirty=!0,"change"===n.updateOn&&cH(n,t)})}(n,t),function YRe(n,t){const e=(r,i)=>{t.valueAccessor.writeValue(r),i&&t.viewToModelUpdate(r)};n.registerOnChange(e),t._registerOnDestroy(()=>{n._unregisterOnChange(e)})}(n,t),function XRe(n,t){t.valueAccessor.registerOnTouched(()=>{n._pendingTouched=!0,"blur"===n.updateOn&&n._pendingChange&&cH(n,t),"submit"!==n.updateOn&&n.markAsTouched()})}(n,t),function qRe(n,t){if(t.valueAccessor.setDisabledState){const e=r=>{t.valueAccessor.setDisabledState(r)};n.registerOnDisabledChange(e),t._registerOnDestroy(()=>{n._unregisterOnDisabledChange(e)})}}(n,t)}function qx(n,t,e=!0){const r=()=>{};t.valueAccessor&&(t.valueAccessor.registerOnChange(r),t.valueAccessor.registerOnTouched(r)),Xx(n,t),n&&(t._invokeOnDestroyCallbacks(),n._registerOnCollectionChange(()=>{}))}function Kx(n,t){n.forEach(e=>{e.registerOnValidatorChange&&e.registerOnValidatorChange(t)})}function VA(n,t){const e=Z6(n);null!==t.validator?n.setValidators(Y6(e,t.validator)):"function"==typeof e&&n.setValidators([e]);const r=Q6(n);null!==t.asyncValidator?n.setAsyncValidators(Y6(r,t.asyncValidator)):"function"==typeof r&&n.setAsyncValidators([r]);const i=()=>n.updateValueAndValidity();Kx(t._rawValidators,i),Kx(t._rawAsyncValidators,i)}function Xx(n,t){let e=!1;if(null!==n){if(null!==t.validator){const i=Z6(n);if(Array.isArray(i)&&i.length>0){const o=i.filter(s=>s!==t.validator);o.length!==i.length&&(e=!0,n.setValidators(o))}}if(null!==t.asyncValidator){const i=Q6(n);if(Array.isArray(i)&&i.length>0){const o=i.filter(s=>s!==t.asyncValidator);o.length!==i.length&&(e=!0,n.setAsyncValidators(o))}}}const r=()=>{};return Kx(t._rawValidators,r),Kx(t._rawAsyncValidators,r),e}function cH(n,t){n._pendingDirty&&n.markAsDirty(),n.setValue(n._pendingValue,{emitModelToViewChange:!1}),t.viewToModelUpdate(n._pendingValue),n._pendingChange=!1}function uH(n,t){VA(n,t)}function dH(n,t){n._syncPendingControls(),t.forEach(e=>{const r=e.control;"submit"===r.updateOn&&r._pendingChange&&(e.viewToModelUpdate(r._pendingValue),r._pendingChange=!1)})}const tMe={provide:ko,useExisting:Dt(()=>hb)},db=(()=>Promise.resolve())();let hb=(()=>{class n extends ko{constructor(e,r,i){super(),this.callSetDisabledState=i,this.submitted=!1,this._directives=new Set,this.ngSubmit=new rn,this.form=new BA({},OA(e),RA(r))}ngAfterViewInit(){this._setUpdateStrategy()}get formDirective(){return this}get control(){return this.form}get path(){return[]}get controls(){return this.form.controls}addControl(e){db.then(()=>{const r=this._findContainer(e.path);e.control=r.registerControl(e.name,e.control),ub(e.control,e,this.callSetDisabledState),e.control.updateValueAndValidity({emitEvent:!1}),this._directives.add(e)})}getControl(e){return this.form.get(e.path)}removeControl(e){db.then(()=>{const r=this._findContainer(e.path);r&&r.removeControl(e.name),this._directives.delete(e)})}addFormGroup(e){db.then(()=>{const r=this._findContainer(e.path),i=new BA({});uH(i,e),r.registerControl(e.name,i),i.updateValueAndValidity({emitEvent:!1})})}removeFormGroup(e){db.then(()=>{const r=this._findContainer(e.path);r&&r.removeControl(e.name)})}getFormGroup(e){return this.form.get(e.path)}updateModel(e,r){db.then(()=>{this.form.get(e.path).setValue(r)})}setValue(e){this.control.setValue(e)}onSubmit(e){return this.submitted=!0,dH(this.form,this._directives),this.ngSubmit.emit(e),"dialog"===e?.target?.method}onReset(){this.resetForm()}resetForm(e=void 0){this.form.reset(e),this.submitted=!1}_setUpdateStrategy(){this.options&&null!=this.options.updateOn&&(this.form._updateOn=this.options.updateOn)}_findContainer(e){return e.pop(),e.length?this.form.get(e):this.form}}return n.\u0275fac=function(e){return new(e||n)(de(co,10),de(Hc,10),de(_p,8))},n.\u0275dir=_t({type:n,selectors:[["form",3,"ngNoForm","",3,"formGroup",""],["ng-form"],["","ngForm",""]],hostBindings:function(e,r){1&e&&an("submit",function(o){return r.onSubmit(o)})("reset",function(){return r.onReset()})},inputs:{options:["ngFormOptions","options"]},outputs:{ngSubmit:"ngSubmit"},exportAs:["ngForm"],features:[En([tMe]),$t]}),n})();function hH(n,t){const e=n.indexOf(t);e>-1&&n.splice(e,1)}function pH(n){return"object"==typeof n&&null!==n&&2===Object.keys(n).length&&"value"in n&&"disabled"in n}const fH=class extends lH{constructor(t=null,e,r){super($A(e),LA(r,e)),this.defaultValue=null,this._onChange=[],this._pendingChange=!1,this._applyFormState(t),this._setUpdateStrategy(e),this._initObservables(),this.updateValueAndValidity({onlySelf:!0,emitEvent:!!this.asyncValidator}),Gx(e)&&(e.nonNullable||e.initialValueIsDefault)&&(this.defaultValue=pH(t)?t.value:t)}setValue(t,e={}){this.value=this._pendingValue=t,this._onChange.length&&!1!==e.emitModelToViewChange&&this._onChange.forEach(r=>r(this.value,!1!==e.emitViewToModelChange)),this.updateValueAndValidity(e)}patchValue(t,e={}){this.setValue(t,e)}reset(t=this.defaultValue,e={}){this._applyFormState(t),this.markAsPristine(e),this.markAsUntouched(e),this.setValue(this.value,e),this._pendingChange=!1}_updateValue(){}_anyControls(t){return!1}_allControlsDisabled(){return this.disabled}registerOnChange(t){this._onChange.push(t)}_unregisterOnChange(t){hH(this._onChange,t)}registerOnDisabledChange(t){this._onDisabledChange.push(t)}_unregisterOnDisabledChange(t){hH(this._onDisabledChange,t)}_forEachChild(t){}_syncPendingControls(){return!("submit"!==this.updateOn||(this._pendingDirty&&this.markAsDirty(),this._pendingTouched&&this.markAsTouched(),!this._pendingChange)||(this.setValue(this._pendingValue,{onlySelf:!0,emitModelToViewChange:!1}),0))}_applyFormState(t){pH(t)?(this.value=this._pendingValue=t.value,t.disabled?this.disable({onlySelf:!0,emitEvent:!1}):this.enable({onlySelf:!0,emitEvent:!1})):this.value=this._pendingValue=t}},iMe={provide:Fl,useExisting:Dt(()=>GA)},bH=(()=>Promise.resolve())();let GA=(()=>{class n extends Fl{constructor(e,r,i,o,s,a){super(),this._changeDetectorRef=s,this.callSetDisabledState=a,this.control=new fH,this._registered=!1,this.name="",this.update=new rn,this._parent=e,this._setValidators(r),this._setAsyncValidators(i),this.valueAccessor=function jA(n,t){if(!t)return null;let e,r,i;return Array.isArray(t),t.forEach(o=>{o.constructor===Bx?e=o:function JRe(n){return Object.getPrototypeOf(n.constructor)===id}(o)?r=o:i=o}),i||r||e||null}(0,o)}ngOnChanges(e){if(this._checkForErrors(),!this._registered||"name"in e){if(this._registered&&(this._checkName(),this.formDirective)){const r=e.name.previousValue;this.formDirective.removeControl({name:r,path:this._getPath(r)})}this._setUpControl()}"isDisabled"in e&&this._updateDisabled(e),function UA(n,t){if(!n.hasOwnProperty("model"))return!1;const e=n.model;return!!e.isFirstChange()||!Object.is(t,e.currentValue)}(e,this.viewModel)&&(this._updateValue(this.model),this.viewModel=this.model)}ngOnDestroy(){this.formDirective&&this.formDirective.removeControl(this)}get path(){return this._getPath(this.name)}get formDirective(){return this._parent?this._parent.formDirective:null}viewToModelUpdate(e){this.viewModel=e,this.update.emit(e)}_setUpControl(){this._setUpdateStrategy(),this._isStandalone()?this._setUpStandalone():this.formDirective.addControl(this),this._registered=!0}_setUpdateStrategy(){this.options&&null!=this.options.updateOn&&(this.control._updateOn=this.options.updateOn)}_isStandalone(){return!this._parent||!(!this.options||!this.options.standalone)}_setUpStandalone(){ub(this.control,this,this.callSetDisabledState),this.control.updateValueAndValidity({emitEvent:!1})}_checkForErrors(){this._isStandalone()||this._checkParentType(),this._checkName()}_checkParentType(){}_checkName(){this.options&&this.options.name&&(this.name=this.options.name),this._isStandalone()}_updateValue(e){bH.then(()=>{this.control.setValue(e,{emitViewToModelChange:!1}),this._changeDetectorRef?.markForCheck()})}_updateDisabled(e){const r=e.isDisabled.currentValue,i=0!==r&&function ah(n){return"boolean"==typeof n?n:null!=n&&"false"!==n}(r);bH.then(()=>{i&&!this.control.disabled?this.control.disable():!i&&this.control.disabled&&this.control.enable(),this._changeDetectorRef?.markForCheck()})}_getPath(e){return this._parent?function Wx(n,t){return[...t.path,n]}(e,this._parent):[e]}}return n.\u0275fac=function(e){return new(e||n)(de(ko,9),de(co,10),de(Hc,10),de(ys,10),de(Vi,8),de(_p,8))},n.\u0275dir=_t({type:n,selectors:[["","ngModel","",3,"formControlName","",3,"formControl",""]],inputs:{name:"name",isDisabled:["disabled","isDisabled"],model:["ngModel","model"],options:["ngModelOptions","options"]},outputs:{update:"ngModelChange"},exportAs:["ngModel"],features:[En([iMe]),$t,po]}),n})(),yH=(()=>{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275dir=_t({type:n,selectors:[["form",3,"ngNoForm","",3,"ngNativeValidate",""]],hostAttrs:["novalidate",""]}),n})(),vH=(()=>{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275mod=Vn({type:n}),n.\u0275inj=Pn({}),n})();const uMe={provide:ko,useExisting:Dt(()=>Yx)};let Yx=(()=>{class n extends ko{constructor(e,r,i){super(),this.callSetDisabledState=i,this.submitted=!1,this._onCollectionChange=()=>this._updateDomValue(),this.directives=[],this.form=null,this.ngSubmit=new rn,this._setValidators(e),this._setAsyncValidators(r)}ngOnChanges(e){this._checkFormPresent(),e.hasOwnProperty("form")&&(this._updateValidators(),this._updateDomValue(),this._updateRegistrations(),this._oldForm=this.form)}ngOnDestroy(){this.form&&(Xx(this.form,this),this.form._onCollectionChange===this._onCollectionChange&&this.form._registerOnCollectionChange(()=>{}))}get formDirective(){return this}get control(){return this.form}get path(){return[]}addControl(e){const r=this.form.get(e.path);return ub(r,e,this.callSetDisabledState),r.updateValueAndValidity({emitEvent:!1}),this.directives.push(e),r}getControl(e){return this.form.get(e.path)}removeControl(e){qx(e.control||null,e,!1),function eMe(n,t){const e=n.indexOf(t);e>-1&&n.splice(e,1)}(this.directives,e)}addFormGroup(e){this._setUpFormContainer(e)}removeFormGroup(e){this._cleanUpFormContainer(e)}getFormGroup(e){return this.form.get(e.path)}addFormArray(e){this._setUpFormContainer(e)}removeFormArray(e){this._cleanUpFormContainer(e)}getFormArray(e){return this.form.get(e.path)}updateModel(e,r){this.form.get(e.path).setValue(r)}onSubmit(e){return this.submitted=!0,dH(this.form,this.directives),this.ngSubmit.emit(e),"dialog"===e?.target?.method}onReset(){this.resetForm()}resetForm(e=void 0){this.form.reset(e),this.submitted=!1}_updateDomValue(){this.directives.forEach(e=>{const r=e.control,i=this.form.get(e.path);r!==i&&(qx(r||null,e),(n=>n instanceof fH)(i)&&(ub(i,e,this.callSetDisabledState),e.control=i))}),this.form._updateTreeValidity({emitEvent:!1})}_setUpFormContainer(e){const r=this.form.get(e.path);uH(r,e),r.updateValueAndValidity({emitEvent:!1})}_cleanUpFormContainer(e){if(this.form){const r=this.form.get(e.path);r&&function ZRe(n,t){return Xx(n,t)}(r,e)&&r.updateValueAndValidity({emitEvent:!1})}}_updateRegistrations(){this.form._registerOnCollectionChange(this._onCollectionChange),this._oldForm&&this._oldForm._registerOnCollectionChange(()=>{})}_updateValidators(){VA(this.form,this),this._oldForm&&Xx(this._oldForm,this)}_checkFormPresent(){}}return n.\u0275fac=function(e){return new(e||n)(de(co,10),de(Hc,10),de(_p,8))},n.\u0275dir=_t({type:n,selectors:[["","formGroup",""]],hostBindings:function(e,r){1&e&&an("submit",function(o){return r.onSubmit(o)})("reset",function(){return r.onReset()})},inputs:{form:["formGroup","form"]},outputs:{ngSubmit:"ngSubmit"},exportAs:["ngForm"],features:[En([uMe]),$t,po]}),n})(),DMe=(()=>{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275mod=Vn({type:n}),n.\u0275inj=Pn({imports:[vH]}),n})(),AMe=(()=>{class n{static withConfig(e){return{ngModule:n,providers:[{provide:_p,useValue:e.callSetDisabledState??Hx}]}}}return n.\u0275fac=function(e){return new(e||n)},n.\u0275mod=Vn({type:n}),n.\u0275inj=Pn({imports:[DMe]}),n})();const NMe=["knob"],OMe=["valueIndicatorContainer"];function RMe(n,t){if(1&n&&(ut(0,"div",4,5)(2,"div",6)(3,"span",7),_n(4),ft()()()),2&n){const e=Ar();At(4),Ii(e.valueIndicatorText)}}const MMe=["trackActive"];function FMe(n,t){if(1&n&&kr(0,"div"),2&n){const e=t.$implicit,r=t.index,i=Ar(3);bM(0===e?"mdc-slider__tick-mark--active":"mdc-slider__tick-mark--inactive"),_1("transform",i._calcTickMarkTransform(r))}}function PMe(n,t){if(1&n&&(Ry(0),Xr(1,FMe,1,4,"div",11),My()),2&n){const e=Ar(2);At(1),nn("ngForOf",e._tickMarks)}}function $Me(n,t){if(1&n&&(ut(0,"div",8,9),Xr(2,PMe,2,1,"ng-container",10),ft()),2&n){const e=Ar();At(2),nn("ngIf",e._cachedWidth)}}function LMe(n,t){if(1&n&&kr(0,"mat-slider-visual-thumb",7),2&n){const e=Ar();nn("discrete",e.discrete)("thumbPosition",1)("valueIndicatorText",e.startValueIndicatorText)}}const BMe=["*"],Zx=new Qe("_MatSlider"),LH=new Qe("_MatSliderThumb"),BH=new Qe("_MatSliderRangeThumb"),VH=new Qe("_MatSliderVisualThumb");let VMe=(()=>{class n{constructor(e,r,i,o){this._cdr=e,this._ngZone=r,this._slider=o,this._isHovered=!1,this._isActive=!1,this._isValueIndicatorVisible=!1,this._onPointerMove=s=>{if(this._sliderInput._isFocused)return;const a=this._hostElement.getBoundingClientRect(),c=this._isSliderThumbHovered(s,a);this._isHovered=c,c?this._showHoverRipple():this._hideRipple(this._hoverRippleRef)},this._onMouseLeave=()=>{this._isHovered=!1,this._hideRipple(this._hoverRippleRef)},this._onFocus=()=>{this._hideRipple(this._hoverRippleRef),this._showFocusRipple(),this._hostElement.classList.add("mdc-slider__thumb--focused")},this._onBlur=()=>{this._isActive||this._hideRipple(this._focusRippleRef),this._isHovered&&this._showHoverRipple(),this._hostElement.classList.remove("mdc-slider__thumb--focused")},this._onDragStart=s=>{0===s.button&&(this._isActive=!0,this._showActiveRipple())},this._onDragEnd=()=>{this._isActive=!1,this._hideRipple(this._activeRippleRef),this._sliderInput._isFocused||this._hideRipple(this._focusRippleRef)},this._hostElement=i.nativeElement}ngAfterViewInit(){this._ripple.radius=24,this._sliderInput=this._slider._getInput(this.thumbPosition),this._sliderInputEl=this._sliderInput._hostElement;const e=this._sliderInputEl;this._ngZone.runOutsideAngular(()=>{e.addEventListener("pointermove",this._onPointerMove),e.addEventListener("pointerdown",this._onDragStart),e.addEventListener("pointerup",this._onDragEnd),e.addEventListener("pointerleave",this._onMouseLeave),e.addEventListener("focus",this._onFocus),e.addEventListener("blur",this._onBlur)})}ngOnDestroy(){const e=this._sliderInputEl;e.removeEventListener("pointermove",this._onPointerMove),e.removeEventListener("pointerdown",this._onDragStart),e.removeEventListener("pointerup",this._onDragEnd),e.removeEventListener("pointerleave",this._onMouseLeave),e.removeEventListener("focus",this._onFocus),e.removeEventListener("blur",this._onBlur)}_showHoverRipple(){this._isShowingRipple(this._hoverRippleRef)||(this._hoverRippleRef=this._showRipple({enterDuration:0,exitDuration:0}),this._hoverRippleRef?.element.classList.add("mat-mdc-slider-hover-ripple"))}_showFocusRipple(){this._isShowingRipple(this._focusRippleRef)||(this._focusRippleRef=this._showRipple({enterDuration:0,exitDuration:0},!0),this._focusRippleRef?.element.classList.add("mat-mdc-slider-focus-ripple"))}_showActiveRipple(){this._isShowingRipple(this._activeRippleRef)||(this._activeRippleRef=this._showRipple({enterDuration:225,exitDuration:400}),this._activeRippleRef?.element.classList.add("mat-mdc-slider-active-ripple"))}_isShowingRipple(e){return 0===e?.state||1===e?.state}_showRipple(e,r){if(!this._slider.disabled&&(this._showValueIndicator(),this._slider._isRange&&this._slider._getThumb(1===this.thumbPosition?2:1)._showValueIndicator(),!this._slider._globalRippleOptions?.disabled||r))return this._ripple.launch({animation:this._slider._noopAnimations?{enterDuration:0,exitDuration:0}:e,centered:!0,persistent:!0})}_hideRipple(e){if(e?.fadeOut(),this._isShowingAnyRipple())return;this._slider._isRange||this._hideValueIndicator();const r=this._getSibling();r._isShowingAnyRipple()||(this._hideValueIndicator(),r._hideValueIndicator())}_showValueIndicator(){this._hostElement.classList.add("mdc-slider__thumb--with-indicator")}_hideValueIndicator(){this._hostElement.classList.remove("mdc-slider__thumb--with-indicator")}_getSibling(){return this._slider._getThumb(1===this.thumbPosition?2:1)}_getValueIndicatorContainer(){return this._valueIndicatorContainer?.nativeElement}_getKnob(){return this._knob.nativeElement}_isShowingAnyRipple(){return this._isShowingRipple(this._hoverRippleRef)||this._isShowingRipple(this._focusRippleRef)||this._isShowingRipple(this._activeRippleRef)}_isSliderThumbHovered(e,r){const i=r.width/2,c=e.clientY-(r.y+i);return Math.pow(e.clientX-(r.x+i),2)+Math.pow(c,2)<Math.pow(i,2)}}return n.\u0275fac=function(e){return new(e||n)(de(Vi),de(Vt),de(yn),de(Zx))},n.\u0275cmp=Pi({type:n,selectors:[["mat-slider-visual-thumb"]],viewQuery:function(e,r){if(1&e&&(Bi(sb,5),Bi(NMe,5),Bi(OMe,5)),2&e){let i;ir(i=or())&&(r._ripple=i.first),ir(i=or())&&(r._knob=i.first),ir(i=or())&&(r._valueIndicatorContainer=i.first)}},hostAttrs:[1,"mdc-slider__thumb","mat-mdc-slider-visual-thumb"],inputs:{discrete:"discrete",thumbPosition:"thumbPosition",valueIndicatorText:"valueIndicatorText"},features:[En([{provide:VH,useExisting:n}])],decls:4,vars:2,consts:[["class","mdc-slider__value-indicator-container",4,"ngIf"],[1,"mdc-slider__thumb-knob"],["knob",""],["matRipple","",1,"mat-mdc-focus-indicator",3,"matRippleDisabled"],[1,"mdc-slider__value-indicator-container"],["valueIndicatorContainer",""],[1,"mdc-slider__value-indicator"],[1,"mdc-slider__value-indicator-text"]],template:function(e,r){1&e&&(Xr(0,RMe,5,1,"div",0),kr(1,"div",1,2)(3,"div",3)),2&e&&(nn("ngIf",r.discrete),At(3),nn("matRippleDisabled",!0))},dependencies:[nc,sb],styles:[".mat-mdc-slider-visual-thumb .mat-ripple{height:100%;width:100%}.mat-mdc-slider .mdc-slider__tick-marks{justify-content:start}.mat-mdc-slider .mdc-slider__tick-marks .mdc-slider__tick-mark--active,.mat-mdc-slider .mdc-slider__tick-marks .mdc-slider__tick-mark--inactive{position:absolute;left:2px}"],encapsulation:2,changeDetection:0}),n})();const zMe=h6(CA(class{constructor(n){this._elementRef=n}}),"primary");let UMe=(()=>{class n extends zMe{get disabled(){return this._disabled}set disabled(e){this._disabled=gr(e);const r=this._getInput(2),i=this._getInput(1);r&&(r.disabled=this._disabled),i&&(i.disabled=this._disabled)}get discrete(){return this._discrete}set discrete(e){this._discrete=gr(e),this._updateValueIndicatorUIs()}get showTickMarks(){return this._showTickMarks}set showTickMarks(e){this._showTickMarks=gr(e)}get min(){return this._min}set min(e){const r=yi(e,this._min);this._min!==r&&this._updateMin(r)}_updateMin(e){const r=this._min;this._min=e,this._isRange?this._updateMinRange({old:r,new:e}):this._updateMinNonRange(e),this._onMinMaxOrStepChange()}_updateMinRange(e){const r=this._getInput(2),i=this._getInput(1),o=r.value,s=i.value;i.min=e.new,r.min=Math.max(e.new,i.value),i.max=Math.min(r.max,r.value),i._updateWidthInactive(),r._updateWidthInactive(),e.new<e.old?this._onTranslateXChangeBySideEffect(r,i):this._onTranslateXChangeBySideEffect(i,r),o!==r.value&&this._onValueChange(r),s!==i.value&&this._onValueChange(i)}_updateMinNonRange(e){const r=this._getInput(2);if(r){const i=r.value;r.min=e,r._updateThumbUIByValue(),this._updateTrackUI(r),i!==r.value&&this._onValueChange(r)}}get max(){return this._max}set max(e){const r=yi(e,this._max);this._max!==r&&this._updateMax(r)}_updateMax(e){const r=this._max;this._max=e,this._isRange?this._updateMaxRange({old:r,new:e}):this._updateMaxNonRange(e),this._onMinMaxOrStepChange()}_updateMaxRange(e){const r=this._getInput(2),i=this._getInput(1),o=r.value,s=i.value;r.max=e.new,i.max=Math.min(e.new,r.value),r.min=i.value,r._updateWidthInactive(),i._updateWidthInactive(),e.new>e.old?this._onTranslateXChangeBySideEffect(i,r):this._onTranslateXChangeBySideEffect(r,i),o!==r.value&&this._onValueChange(r),s!==i.value&&this._onValueChange(i)}_updateMaxNonRange(e){const r=this._getInput(2);if(r){const i=r.value;r.max=e,r._updateThumbUIByValue(),this._updateTrackUI(r),i!==r.value&&this._onValueChange(r)}}get step(){return this._step}set step(e){const r=yi(e,this._step);this._step!==r&&this._updateStep(r)}_updateStep(e){this._step=e,this._isRange?this._updateStepRange():this._updateStepNonRange(),this._onMinMaxOrStepChange()}_updateStepRange(){const e=this._getInput(2),r=this._getInput(1),i=e.value,o=r.value,s=r.value;e.min=this._min,r.max=this._max,e.step=this._step,r.step=this._step,this._platform.SAFARI&&(e.value=e.value,r.value=r.value),e.min=Math.max(this._min,r.value),r.max=Math.min(this._max,e.value),r._updateWidthInactive(),e._updateWidthInactive(),e.value<s?this._onTranslateXChangeBySideEffect(r,e):this._onTranslateXChangeBySideEffect(e,r),i!==e.value&&this._onValueChange(e),o!==r.value&&this._onValueChange(r)}_updateStepNonRange(){const e=this._getInput(2);if(e){const r=e.value;e.step=this._step,this._platform.SAFARI&&(e.value=e.value),e._updateThumbUIByValue(),r!==e.value&&this._onValueChange(e)}}constructor(e,r,i,o,s,a,c){super(o),this._ngZone=e,this._cdr=r,this._platform=i,this._dir=s,this._globalRippleOptions=a,this._disabled=!1,this._discrete=!1,this._showTickMarks=!1,this._min=0,this._max=100,this._step=0,this.displayWith=u=>`${u}`,this._rippleRadius=24,this.startValueIndicatorText="",this.endValueIndicatorText="",this._isRange=!1,this._isRtl=!1,this._hasViewInitialized=!1,this._tickMarkTrackWidth=0,this._hasAnimation=!1,this._resizeTimer=null,this._knobRadius=8,this._thumbsOverlap=!1,this._noopAnimations="NoopAnimations"===c,this._dirChangeSubscription=this._dir.change.subscribe(()=>this._onDirChange()),this._isRtl="rtl"===this._dir.value}ngAfterViewInit(){this._platform.isBrowser&&this._updateDimensions();const e=this._getInput(2),r=this._getInput(1);this._isRange=!!e&&!!r,this._cdr.detectChanges();const i=this._getThumb(2);this._rippleRadius=i._ripple.radius,this._inputPadding=this._rippleRadius-this._knobRadius,this._inputOffset=this._knobRadius,this._isRange?this._initUIRange(e,r):this._initUINonRange(e),this._updateTrackUI(e),this._updateTickMarkUI(),this._updateTickMarkTrackUI(),this._observeHostResize(),this._cdr.detectChanges()}_initUINonRange(e){e.initProps(),e.initUI(),this._updateValueIndicatorUI(e),this._hasViewInitialized=!0,e._updateThumbUIByValue()}_initUIRange(e,r){e.initProps(),e.initUI(),r.initProps(),r.initUI(),e._updateMinMax(),r._updateMinMax(),e._updateStaticStyles(),r._updateStaticStyles(),this._updateValueIndicatorUIs(),this._hasViewInitialized=!0,e._updateThumbUIByValue(),r._updateThumbUIByValue()}ngOnDestroy(){this._dirChangeSubscription.unsubscribe(),this._resizeObserver?.disconnect(),this._resizeObserver=null}_onDirChange(){this._isRtl="rtl"===this._dir.value,this._isRange?this._onDirChangeRange():this._onDirChangeNonRange(),this._updateTickMarkUI()}_onDirChangeRange(){const e=this._getInput(2),r=this._getInput(1);e._setIsLeftThumb(),r._setIsLeftThumb(),e.translateX=e._calcTranslateXByValue(),r.translateX=r._calcTranslateXByValue(),e._updateStaticStyles(),r._updateStaticStyles(),e._updateWidthInactive(),r._updateWidthInactive(),e._updateThumbUIByValue(),r._updateThumbUIByValue()}_onDirChangeNonRange(){this._getInput(2)._updateThumbUIByValue()}_observeHostResize(){typeof ResizeObserver>"u"||!ResizeObserver||this._ngZone.runOutsideAngular(()=>{this._resizeObserver=new ResizeObserver(()=>{this._isActive()||(this._resizeTimer&&clearTimeout(this._resizeTimer),this._onResize())}),this._resizeObserver.observe(this._elementRef.nativeElement)})}_isActive(){return this._getThumb(1)._isActive||this._getThumb(2)._isActive}_getValue(e=2){const r=this._getInput(e);return r?r.value:this.min}_skipUpdate(){return!(!this._getInput(1)?._skipUIUpdate&&!this._getInput(2)?._skipUIUpdate)}_updateDimensions(){this._cachedWidth=this._elementRef.nativeElement.offsetWidth,this._cachedLeft=this._elementRef.nativeElement.getBoundingClientRect().left}_setTrackActiveStyles(e){const r=this._trackActive.nativeElement.style;r.left=e.left,r.right=e.right,r.transformOrigin=e.transformOrigin,r.transform=e.transform}_calcTickMarkTransform(e){return`translateX(${e*(this._tickMarkTrackWidth/(this._tickMarks.length-1))}px`}_onTranslateXChange(e){this._hasViewInitialized&&(this._updateThumbUI(e),this._updateTrackUI(e),this._updateOverlappingThumbUI(e))}_onTranslateXChangeBySideEffect(e,r){this._hasViewInitialized&&(e._updateThumbUIByValue(),r._updateThumbUIByValue())}_onValueChange(e){this._hasViewInitialized&&(this._updateValueIndicatorUI(e),this._updateTickMarkUI(),this._cdr.detectChanges())}_onMinMaxOrStepChange(){this._hasViewInitialized&&(this._updateTickMarkUI(),this._updateTickMarkTrackUI(),this._cdr.markForCheck())}_onResize(){if(this._hasViewInitialized){if(this._updateDimensions(),this._isRange){const e=this._getInput(2),r=this._getInput(1);e._updateThumbUIByValue(),r._updateThumbUIByValue(),e._updateStaticStyles(),r._updateStaticStyles(),e._updateMinMax(),r._updateMinMax(),e._updateWidthInactive(),r._updateWidthInactive()}else{const e=this._getInput(2);e&&e._updateThumbUIByValue()}this._updateTickMarkUI(),this._updateTickMarkTrackUI(),this._cdr.detectChanges()}}_areThumbsOverlapping(){const e=this._getInput(1),r=this._getInput(2);return!(!e||!r)&&r.translateX-e.translateX<20}_updateOverlappingThumbClassNames(e){const r=e.getSibling(),i=this._getThumb(e.thumbPosition);this._getThumb(r.thumbPosition)._hostElement.classList.remove("mdc-slider__thumb--top"),i._hostElement.classList.toggle("mdc-slider__thumb--top",this._thumbsOverlap)}_updateOverlappingThumbUI(e){!this._isRange||this._skipUpdate()||this._thumbsOverlap!==this._areThumbsOverlapping()&&(this._thumbsOverlap=!this._thumbsOverlap,this._updateOverlappingThumbClassNames(e))}_updateThumbUI(e){this._skipUpdate()||(this._getThumb(2===e.thumbPosition?2:1)._hostElement.style.transform=`translateX(${e.translateX}px)`)}_updateValueIndicatorUI(e){if(this._skipUpdate())return;const r=this.displayWith(e.value);if(this._hasViewInitialized?e._valuetext=r:e._hostElement.setAttribute("aria-valuetext",r),this.discrete){1===e.thumbPosition?this.startValueIndicatorText=r:this.endValueIndicatorText=r;const i=this._getThumb(e.thumbPosition);r.length<3?i._hostElement.classList.add("mdc-slider__thumb--short-value"):i._hostElement.classList.remove("mdc-slider__thumb--short-value")}}_updateValueIndicatorUIs(){const e=this._getInput(2),r=this._getInput(1);e&&this._updateValueIndicatorUI(e),r&&this._updateValueIndicatorUI(r)}_updateTickMarkTrackUI(){if(!this.showTickMarks||this._skipUpdate())return;const e=this._step&&this._step>0?this._step:1,i=(Math.floor(this.max/e)*e-this.min)/(this.max-this.min);this._tickMarkTrackWidth=this._cachedWidth*i-6}_updateTrackUI(e){this._skipUpdate()||(this._isRange?this._updateTrackUIRange(e):this._updateTrackUINonRange(e))}_updateTrackUIRange(e){const r=e.getSibling();if(!r||!this._cachedWidth)return;const i=Math.abs(r.translateX-e.translateX)/this._cachedWidth;this._setTrackActiveStyles(e._isLeftThumb&&this._cachedWidth?{left:"auto",right:this._cachedWidth-r.translateX+"px",transformOrigin:"right",transform:`scaleX(${i})`}:{left:`${r.translateX}px`,right:"auto",transformOrigin:"left",transform:`scaleX(${i})`})}_updateTrackUINonRange(e){this._setTrackActiveStyles(this._isRtl?{left:"auto",right:"0px",transformOrigin:"right",transform:`scaleX(${1-e.fillPercentage})`}:{left:"0px",right:"auto",transformOrigin:"left",transform:`scaleX(${e.fillPercentage})`})}_updateTickMarkUI(){if(!this.showTickMarks||void 0===this.step||void 0===this.min||void 0===this.max)return;const e=this.step>0?this.step:1;this._isRange?this._updateTickMarkUIRange(e):this._updateTickMarkUINonRange(e),this._isRtl&&this._tickMarks.reverse()}_updateTickMarkUINonRange(e){const r=this._getValue();let i=Math.max(Math.round((r-this.min)/e),0),o=Math.max(Math.round((this.max-r)/e),0);this._isRtl?i++:o++,this._tickMarks=Array(i).fill(0).concat(Array(o).fill(1))}_updateTickMarkUIRange(e){const r=this._getValue(),i=this._getValue(1),o=Math.max(Math.floor((i-this.min)/e),0),s=Math.max(Math.floor((r-i)/e)+1,0),a=Math.max(Math.floor((this.max-r)/e),0);this._tickMarks=Array(o).fill(1).concat(Array(s).fill(0),Array(a).fill(1))}_getInput(e){return 2===e&&this._input?this._input:this._inputs?.length?1===e?this._inputs.first:this._inputs.last:void 0}_getThumb(e){return 2===e?this._thumbs?.last:this._thumbs?.first}_setTransition(e){this._hasAnimation=e&&!this._noopAnimations,this._elementRef.nativeElement.classList.toggle("mat-mdc-slider-with-animation",this._hasAnimation)}}return n.\u0275fac=function(e){return new(e||n)(de(Vt),de(Vi),de(Wi),de(yn),de(Rl,8),de(y6,8),de(ns,8))},n.\u0275cmp=Pi({type:n,selectors:[["mat-slider"]],contentQueries:function(e,r,i){if(1&e&&(fl(i,LH,5),fl(i,BH,4)),2&e){let o;ir(o=or())&&(r._input=o.first),ir(o=or())&&(r._inputs=o)}},viewQuery:function(e,r){if(1&e&&(Bi(MMe,5),Bi(VH,5)),2&e){let i;ir(i=or())&&(r._trackActive=i.first),ir(i=or())&&(r._thumbs=i)}},hostAttrs:[1,"mat-mdc-slider","mdc-slider"],hostVars:10,hostBindings:function(e,r){2&e&&Yr("mdc-slider--range",r._isRange)("mdc-slider--disabled",r.disabled)("mdc-slider--discrete",r.discrete)("mdc-slider--tick-marks",r.showTickMarks)("_mat-animation-noopable",r._noopAnimations)},inputs:{color:"color",disableRipple:"disableRipple",disabled:"disabled",discrete:"discrete",showTickMarks:"showTickMarks",min:"min",max:"max",step:"step",displayWith:"displayWith"},exportAs:["matSlider"],features:[En([{provide:Zx,useExisting:n}]),$t],ngContentSelectors:BMe,decls:9,vars:5,consts:[[1,"mdc-slider__track"],[1,"mdc-slider__track--inactive"],[1,"mdc-slider__track--active"],[1,"mdc-slider__track--active_fill"],["trackActive",""],["class","mdc-slider__tick-marks",4,"ngIf"],[3,"discrete","thumbPosition","valueIndicatorText",4,"ngIf"],[3,"discrete","thumbPosition","valueIndicatorText"],[1,"mdc-slider__tick-marks"],["tickMarkContainer",""],[4,"ngIf"],[3,"class","transform",4,"ngFor","ngForOf"]],template:function(e,r){1&e&&(Tf(),Sf(0),ut(1,"div",0),kr(2,"div",1),ut(3,"div",2),kr(4,"div",3,4),ft(),Xr(6,$Me,3,1,"div",5),ft(),Xr(7,LMe,1,3,"mat-slider-visual-thumb",6),kr(8,"mat-slider-visual-thumb",7)),2&e&&(At(6),nn("ngIf",r.showTickMarks),At(1),nn("ngIf",r._isRange),At(1),nn("discrete",r.discrete)("thumbPosition",2)("valueIndicatorText",r.endValueIndicatorText))},dependencies:[a_,nc,VMe],styles:['.mdc-slider{cursor:pointer;height:48px;margin:0 24px;position:relative;touch-action:pan-y}.mdc-slider .mdc-slider__track{position:absolute;top:50%;transform:translateY(-50%);width:100%}.mdc-slider .mdc-slider__track--active,.mdc-slider .mdc-slider__track--inactive{display:flex;height:100%;position:absolute;width:100%}.mdc-slider .mdc-slider__track--active{overflow:hidden}.mdc-slider .mdc-slider__track--active_fill{border-top-style:solid;box-sizing:border-box;height:100%;width:100%;position:relative;-webkit-transform-origin:left;transform-origin:left}[dir=rtl] .mdc-slider .mdc-slider__track--active_fill,.mdc-slider .mdc-slider__track--active_fill[dir=rtl]{-webkit-transform-origin:right;transform-origin:right}.mdc-slider .mdc-slider__track--inactive{left:0;top:0}.mdc-slider .mdc-slider__track--inactive::before{position:absolute;box-sizing:border-box;width:100%;height:100%;top:0;left:0;border:1px solid rgba(0,0,0,0);border-radius:inherit;content:"";pointer-events:none}@media screen and (forced-colors: active){.mdc-slider .mdc-slider__track--inactive::before{border-color:CanvasText}}.mdc-slider .mdc-slider__value-indicator-container{bottom:44px;left:var(--slider-value-indicator-container-left, 50%);pointer-events:none;position:absolute;right:var(--slider-value-indicator-container-right);transform:var(--slider-value-indicator-container-transform, translateX(-50%))}.mdc-slider .mdc-slider__value-indicator{transition:transform 100ms 0ms cubic-bezier(0.4, 0, 1, 1);align-items:center;border-radius:4px;display:flex;height:32px;padding:0 12px;transform:scale(0);transform-origin:bottom}.mdc-slider .mdc-slider__value-indicator::before{border-left:6px solid rgba(0,0,0,0);border-right:6px solid rgba(0,0,0,0);border-top:6px solid;bottom:-5px;content:"";height:0;left:var(--slider-value-indicator-caret-left, 50%);position:absolute;right:var(--slider-value-indicator-caret-right);transform:var(--slider-value-indicator-caret-transform, translateX(-50%));width:0}.mdc-slider .mdc-slider__value-indicator::after{position:absolute;box-sizing:border-box;width:100%;height:100%;top:0;left:0;border:1px solid rgba(0,0,0,0);border-radius:inherit;content:"";pointer-events:none}@media screen and (forced-colors: active){.mdc-slider .mdc-slider__value-indicator::after{border-color:CanvasText}}.mdc-slider .mdc-slider__thumb--with-indicator .mdc-slider__value-indicator-container{pointer-events:auto}.mdc-slider .mdc-slider__thumb--with-indicator .mdc-slider__value-indicator{transition:transform 100ms 0ms cubic-bezier(0, 0, 0.2, 1);transform:scale(1)}@media(prefers-reduced-motion){.mdc-slider .mdc-slider__value-indicator,.mdc-slider .mdc-slider__thumb--with-indicator .mdc-slider__value-indicator{transition:none}}.mdc-slider .mdc-slider__thumb{display:flex;left:-24px;outline:none;position:absolute;user-select:none;height:48px;width:48px}.mdc-slider .mdc-slider__thumb--top{z-index:1}.mdc-slider .mdc-slider__thumb--top .mdc-slider__thumb-knob,.mdc-slider .mdc-slider__thumb--top.mdc-slider__thumb:hover .mdc-slider__thumb-knob,.mdc-slider .mdc-slider__thumb--top.mdc-slider__thumb--focused .mdc-slider__thumb-knob{border-style:solid;border-width:1px;box-sizing:content-box}.mdc-slider .mdc-slider__thumb-knob{box-sizing:border-box;left:50%;position:absolute;top:50%;transform:translate(-50%, -50%)}.mdc-slider .mdc-slider__tick-marks{align-items:center;box-sizing:border-box;display:flex;height:100%;justify-content:space-between;padding:0 1px;position:absolute;width:100%}.mdc-slider--discrete .mdc-slider__thumb,.mdc-slider--discrete .mdc-slider__track--active_fill{transition:transform 80ms ease}@media(prefers-reduced-motion){.mdc-slider--discrete .mdc-slider__thumb,.mdc-slider--discrete .mdc-slider__track--active_fill{transition:none}}.mdc-slider--disabled{cursor:auto}.mdc-slider--disabled .mdc-slider__thumb{pointer-events:none}.mdc-slider__input{cursor:pointer;left:2px;margin:0;height:44px;opacity:0;pointer-events:none;position:absolute;top:2px;width:44px}.mat-mdc-slider{display:inline-block;box-sizing:border-box;outline:none;vertical-align:middle;margin-left:8px;margin-right:8px;width:auto;min-width:112px;-webkit-tap-highlight-color:rgba(0,0,0,0)}.mat-mdc-slider .mdc-slider__thumb-knob{background-color:var(--mdc-slider-handle-color, var(--mdc-theme-primary, #6200ee));border-color:var(--mdc-slider-handle-color, var(--mdc-theme-primary, #6200ee))}.mat-mdc-slider .mdc-slider__thumb--top .mdc-slider__thumb-knob,.mat-mdc-slider .mdc-slider__thumb--top.mdc-slider__thumb:hover .mdc-slider__thumb-knob,.mat-mdc-slider .mdc-slider__thumb--top.mdc-slider__thumb--focused .mdc-slider__thumb-knob{border-color:#fff}.mat-mdc-slider.mdc-slider--disabled .mdc-slider__thumb-knob{background-color:var(--mdc-slider-disabled-handle-color, var(--mdc-theme-on-surface, #000));border-color:var(--mdc-slider-disabled-handle-color, var(--mdc-theme-on-surface, #000))}.mat-mdc-slider.mdc-slider--disabled .mdc-slider__thumb--top .mdc-slider__thumb-knob,.mat-mdc-slider.mdc-slider--disabled .mdc-slider__thumb--top.mdc-slider__thumb:hover .mdc-slider__thumb-knob,.mat-mdc-slider.mdc-slider--disabled .mdc-slider__thumb--top.mdc-slider__thumb--focused .mdc-slider__thumb-knob{border-color:#fff}.mat-mdc-slider .mdc-slider__thumb::before,.mat-mdc-slider .mdc-slider__thumb::after{background-color:var(--mdc-slider-handle-color, var(--mdc-theme-primary, #6200ee))}.mat-mdc-slider .mdc-slider__thumb:hover::before,.mat-mdc-slider .mdc-slider__thumb.mdc-ripple-surface--hover::before{opacity:var(--mdc-ripple-hover-opacity, 0.04)}.mat-mdc-slider .mdc-slider__thumb.mdc-ripple-upgraded--background-focused::before,.mat-mdc-slider .mdc-slider__thumb:not(.mdc-ripple-upgraded):focus::before{transition-duration:75ms;opacity:var(--mdc-ripple-focus-opacity, 0.12)}.mat-mdc-slider .mdc-slider__thumb:not(.mdc-ripple-upgraded)::after{transition:opacity 150ms linear}.mat-mdc-slider .mdc-slider__thumb:not(.mdc-ripple-upgraded):active::after{transition-duration:75ms;opacity:var(--mdc-ripple-press-opacity, 0.12)}.mat-mdc-slider .mdc-slider__thumb.mdc-ripple-upgraded{--mdc-ripple-fg-opacity:var(--mdc-ripple-press-opacity, 0.12)}.mat-mdc-slider .mdc-slider__track--active_fill{border-color:var(--mdc-slider-active-track-color, var(--mdc-theme-primary, #6200ee))}.mat-mdc-slider.mdc-slider--disabled .mdc-slider__track--active_fill{border-color:var(--mdc-slider-disabled-active-track-color, var(--mdc-theme-on-surface, #000))}.mat-mdc-slider .mdc-slider__track--inactive{background-color:var(--mdc-slider-inactive-track-color, var(--mdc-theme-primary, #6200ee));opacity:.24}.mat-mdc-slider.mdc-slider--disabled .mdc-slider__track--inactive{background-color:var(--mdc-slider-disabled-inactive-track-color, var(--mdc-theme-on-surface, #000));opacity:.24}.mat-mdc-slider .mdc-slider__tick-mark--active{background-color:var(--mdc-slider-with-tick-marks-active-container-color, var(--mdc-theme-on-primary, #fff));opacity:var(--mdc-slider-with-tick-marks-active-container-opacity, 0.6)}.mat-mdc-slider.mdc-slider--disabled .mdc-slider__tick-mark--active{background-color:var(--mdc-slider-with-tick-marks-active-container-color, var(--mdc-theme-on-primary, #fff));opacity:var(--mdc-slider-with-tick-marks-active-container-opacity, 0.6)}.mat-mdc-slider .mdc-slider__tick-mark--inactive{background-color:var(--mdc-slider-with-tick-marks-inactive-container-color, var(--mdc-theme-primary, #6200ee));opacity:var(--mdc-slider-with-tick-marks-inactive-container-opacity, 0.6)}.mat-mdc-slider.mdc-slider--disabled .mdc-slider__tick-mark--inactive{background-color:var(--mdc-slider-with-tick-marks-disabled-container-color, var(--mdc-theme-on-surface, #000));opacity:var(--mdc-slider-with-tick-marks-inactive-container-opacity, 0.6)}.mat-mdc-slider .mdc-slider__value-indicator{background-color:var(--mdc-slider-label-container-color, #666666);opacity:1}.mat-mdc-slider .mdc-slider__value-indicator::before{border-top-color:var(--mdc-slider-label-container-color, #666666)}.mat-mdc-slider .mdc-slider__value-indicator{color:var(--mdc-slider-label-label-text-color, var(--mdc-theme-on-primary, #fff))}.mat-mdc-slider .mdc-slider__track{height:var(--mdc-slider-inactive-track-height, 4px)}.mat-mdc-slider .mdc-slider__track--active{height:var(--mdc-slider-active-track-height, 6px);top:calc((var(--mdc-slider-inactive-track-height, 4px) - var(--mdc-slider-active-track-height, 6px)) / 2)}.mat-mdc-slider .mdc-slider__track--active_fill{border-top-width:var(--mdc-slider-active-track-height, 6px)}.mat-mdc-slider .mdc-slider__track--inactive{height:var(--mdc-slider-inactive-track-height, 4px)}.mat-mdc-slider .mdc-slider__tick-mark--active,.mat-mdc-slider .mdc-slider__tick-mark--inactive{height:var(--mdc-slider-with-tick-marks-container-size, 2px);width:var(--mdc-slider-with-tick-marks-container-size, 2px)}.mat-mdc-slider.mdc-slider--disabled{opacity:0.38}.mat-mdc-slider .mdc-slider__value-indicator-text{letter-spacing:var(--mdc-slider-label-label-text-tracking, 0.0071428571em);font-size:var(--mdc-slider-label-label-text-size, 0.875rem);font-family:var(--mdc-slider-label-label-text-font, Roboto, sans-serif);font-weight:var(--mdc-slider-label-label-text-weight, 500);line-height:var(--mdc-slider-label-label-text-line-height, 1.375rem)}.mat-mdc-slider .mdc-slider__track--active{border-radius:var(--mdc-slider-active-track-shape, 9999px)}.mat-mdc-slider .mdc-slider__track--inactive{border-radius:var(--mdc-slider-inactive-track-shape, 9999px)}.mat-mdc-slider .mdc-slider__thumb-knob{border-radius:var(--mdc-slider-handle-shape, 50%);width:var(--mdc-slider-handle-width, 20px);height:var(--mdc-slider-handle-height, 20px);border-style:solid;border-width:calc(var(--mdc-slider-handle-height, 20px) / 2) calc(var(--mdc-slider-handle-width, 20px) / 2)}.mat-mdc-slider .mdc-slider__tick-mark--active,.mat-mdc-slider .mdc-slider__tick-mark--inactive{border-radius:var(--mdc-slider-with-tick-marks-container-shape, 50%)}.mat-mdc-slider .mdc-slider__thumb-knob{box-shadow:var(--mdc-slider-handle-elevation, 0px 2px 1px -1px rgba(0, 0, 0, 0.2), 0px 1px 1px 0px rgba(0, 0, 0, 0.14), 0px 1px 3px 0px rgba(0, 0, 0, 0.12))}.mat-mdc-slider .mdc-slider__thumb:hover .mdc-slider__thumb-knob{background-color:var(--mdc-slider-hover-handle-color, var(--mdc-theme-primary, #6200ee));border-color:var(--mdc-slider-hover-handle-color, var(--mdc-theme-primary, #6200ee))}.mat-mdc-slider .mdc-slider__thumb:hover .mdc-slider__thumb--top .mdc-slider__thumb-knob,.mat-mdc-slider .mdc-slider__thumb:hover .mdc-slider__thumb--top.mdc-slider__thumb:hover .mdc-slider__thumb-knob,.mat-mdc-slider .mdc-slider__thumb:hover .mdc-slider__thumb--top.mdc-slider__thumb--focused .mdc-slider__thumb-knob{border-color:#fff}.mat-mdc-slider .mdc-slider__thumb--focused .mdc-slider__thumb-knob{background-color:var(--mdc-slider-focus-handle-color, var(--mdc-theme-primary, #6200ee));border-color:var(--mdc-slider-focus-handle-color, var(--mdc-theme-primary, #6200ee))}.mat-mdc-slider .mdc-slider__thumb--focused .mdc-slider__thumb--top .mdc-slider__thumb-knob,.mat-mdc-slider .mdc-slider__thumb--focused .mdc-slider__thumb--top.mdc-slider__thumb:hover .mdc-slider__thumb-knob,.mat-mdc-slider .mdc-slider__thumb--focused .mdc-slider__thumb--top.mdc-slider__thumb--focused .mdc-slider__thumb-knob{border-color:#fff}.mat-mdc-slider .mdc-slider__thumb:not(:disabled):active .mdc-slider__thumb--top .mdc-slider__thumb-knob,.mat-mdc-slider .mdc-slider__thumb:not(:disabled):active .mdc-slider__thumb--top.mdc-slider__thumb:hover .mdc-slider__thumb-knob,.mat-mdc-slider .mdc-slider__thumb:not(:disabled):active .mdc-slider__thumb--top.mdc-slider__thumb--focused .mdc-slider__thumb-knob{border-color:#fff}.mat-mdc-slider .mdc-slider__thumb--top .mdc-slider__thumb-knob,.mat-mdc-slider .mdc-slider__thumb--top.mdc-slider__thumb:hover .mdc-slider__thumb-knob,.mat-mdc-slider .mdc-slider__thumb--top.mdc-slider__thumb--focused .mdc-slider__thumb-knob{border-color:var(--mdc-slider-with-overlap-handle-outline-color, #fff);border-width:var(--mdc-slider-with-overlap-handle-outline-width, 1px)}.mat-mdc-slider .mdc-slider__input{box-sizing:content-box;pointer-events:auto}.mat-mdc-slider .mdc-slider__input.mat-mdc-slider-input-no-pointer-events{pointer-events:none}.mat-mdc-slider .mdc-slider__input.mat-slider__right-input{left:auto;right:0}.mat-mdc-slider .mdc-slider__thumb,.mat-mdc-slider .mdc-slider__track--active_fill{transition-duration:0ms}.mat-mdc-slider.mat-mdc-slider-with-animation .mdc-slider__thumb,.mat-mdc-slider.mat-mdc-slider-with-animation .mdc-slider__track--active_fill{transition-duration:80ms}.mat-mdc-slider.mdc-slider--discrete .mdc-slider__thumb,.mat-mdc-slider.mdc-slider--discrete .mdc-slider__track--active_fill{transition-duration:0ms}.mat-mdc-slider.mat-mdc-slider-with-animation .mdc-slider__thumb,.mat-mdc-slider.mat-mdc-slider-with-animation .mdc-slider__track--active_fill{transition-duration:80ms}.mat-mdc-slider .mdc-slider__track,.mat-mdc-slider .mdc-slider__thumb{pointer-events:none}.mat-mdc-slider .mdc-slider__value-indicator{opacity:var(--mat-mdc-slider-value-indicator-opacity, 1)}.mat-mdc-slider .mat-ripple .mat-ripple-element{background-color:var(--mat-mdc-slider-ripple-color, transparent)}.mat-mdc-slider .mat-ripple .mat-mdc-slider-hover-ripple{background-color:var(--mat-mdc-slider-hover-ripple-color, transparent)}.mat-mdc-slider .mat-ripple .mat-mdc-slider-focus-ripple,.mat-mdc-slider .mat-ripple .mat-mdc-slider-active-ripple{background-color:var(--mat-mdc-slider-focus-ripple-color, transparent)}.mat-mdc-slider._mat-animation-noopable.mdc-slider--discrete .mdc-slider__thumb,.mat-mdc-slider._mat-animation-noopable.mdc-slider--discrete .mdc-slider__track--active_fill,.mat-mdc-slider._mat-animation-noopable .mdc-slider__value-indicator{transition:none}.mat-mdc-slider .mat-mdc-focus-indicator::before{border-radius:50%}.mdc-slider__thumb--focused .mat-mdc-focus-indicator::before{content:""}'],encapsulation:2,changeDetection:0}),n})();const GMe={provide:ys,useExisting:Dt(()=>YA),multi:!0};let YA=(()=>{class n{get value(){return yi(this._hostElement.value)}set value(e){const r=yi(e).toString();this._hasSetInitialValue?this._isActive||(this._hostElement.value=r,this._updateThumbUIByValue(),this._slider._onValueChange(this),this._cdr.detectChanges()):this._initialValue=r}get translateX(){return this._slider.min>=this._slider.max?(this._translateX=0,this._translateX):(void 0===this._translateX&&(this._translateX=this._calcTranslateXByValue()),this._translateX)}set translateX(e){this._translateX=e}get min(){return yi(this._hostElement.min)}set min(e){this._hostElement.min=yi(e).toString(),this._cdr.detectChanges()}get max(){return yi(this._hostElement.max)}set max(e){this._hostElement.max=yi(e).toString(),this._cdr.detectChanges()}get step(){return yi(this._hostElement.step)}set step(e){this._hostElement.step=yi(e).toString(),this._cdr.detectChanges()}get disabled(){return gr(this._hostElement.disabled)}set disabled(e){this._hostElement.disabled=gr(e),this._cdr.detectChanges(),this._slider.disabled!==this.disabled&&(this._slider.disabled=this.disabled)}get percentage(){return this._slider.min>=this._slider.max?this._slider._isRtl?1:0:(this.value-this._slider.min)/(this._slider.max-this._slider.min)}get fillPercentage(){return this._slider._cachedWidth?0===this._translateX?0:this.translateX/this._slider._cachedWidth:this._slider._isRtl?1:0}_setIsFocused(e){this._isFocused=e}constructor(e,r,i,o){this._ngZone=e,this._elementRef=r,this._cdr=i,this._slider=o,this.valueChange=new rn,this.dragStart=new rn,this.dragEnd=new rn,this.thumbPosition=2,this._knobRadius=8,this._isActive=!1,this._isFocused=!1,this._hasSetInitialValue=!1,this._destroyed=new Kt,this._skipUIUpdate=!1,this._onTouchedFn=()=>{},this._isControlInitialized=!1,this._hostElement=r.nativeElement,this._ngZone.runOutsideAngular(()=>{this._hostElement.addEventListener("pointerdown",this._onPointerDown.bind(this)),this._hostElement.addEventListener("pointermove",this._onPointerMove.bind(this)),this._hostElement.addEventListener("pointerup",this._onPointerUp.bind(this))})}ngOnDestroy(){this._hostElement.removeEventListener("pointerdown",this._onPointerDown),this._hostElement.removeEventListener("pointermove",this._onPointerMove),this._hostElement.removeEventListener("pointerup",this._onPointerUp),this._destroyed.next(),this._destroyed.complete(),this.dragStart.complete(),this.dragEnd.complete()}initProps(){this._updateWidthInactive(),this.disabled!==this._slider.disabled&&(this._slider.disabled=!0),this.step=this._slider.step,this.min=this._slider.min,this.max=this._slider.max,this._initValue()}initUI(){this._updateThumbUIByValue()}_initValue(){this._hasSetInitialValue=!0,void 0===this._initialValue?this.value=this._getDefaultValue():(this._hostElement.value=this._initialValue,this._updateThumbUIByValue(),this._slider._onValueChange(this),this._cdr.detectChanges())}_getDefaultValue(){return this.min}_onBlur(){this._setIsFocused(!1),this._onTouchedFn()}_onFocus(){this._setIsFocused(!0)}_onChange(){this.valueChange.emit(this.value),this._isActive&&this._updateThumbUIByValue({withAnimation:!0})}_onInput(){this._onChangeFn?.(this.value),(this._slider.step||!this._isActive)&&this._updateThumbUIByValue({withAnimation:!0}),this._slider._onValueChange(this)}_onNgControlValueChange(){(!this._isActive||!this._isFocused)&&(this._slider._onValueChange(this),this._updateThumbUIByValue()),this._slider.disabled=this._formControl.disabled}_onPointerDown(e){this.disabled||0!==e.button||(this._isActive=!0,this._setIsFocused(!0),this._updateWidthActive(),this._slider._updateDimensions(),this._slider.step||this._updateThumbUIByPointerEvent(e,{withAnimation:!0}),this.disabled||(this._handleValueCorrection(e),this.dragStart.emit({source:this,parent:this._slider,value:this.value})))}_handleValueCorrection(e){this._skipUIUpdate=!0,setTimeout(()=>{this._skipUIUpdate=!1,this._fixValue(e)},0)}_fixValue(e){const r=e.clientX-this._slider._cachedLeft,i=this._slider._cachedWidth,o=0===this._slider.step?1:this._slider.step,s=Math.floor((this._slider.max-this._slider.min)/o),u=Math.round((this._slider._isRtl?1-r/i:r/i)*s)/s*(this._slider.max-this._slider.min)+this._slider.min,p=Math.round(u/o)*o;if(p===this.value)return this._slider._onValueChange(this),void(this._slider.step>0?this._updateThumbUIByValue():this._updateThumbUIByPointerEvent(e,{withAnimation:this._slider._hasAnimation}));this.value=p,this.valueChange.emit(this.value),this._onChangeFn?.(this.value),this._slider._onValueChange(this),this._slider.step>0?this._updateThumbUIByValue():this._updateThumbUIByPointerEvent(e,{withAnimation:this._slider._hasAnimation})}_onPointerMove(e){!this._slider.step&&this._isActive&&this._updateThumbUIByPointerEvent(e)}_onPointerUp(){this._isActive&&(this._isActive=!1,this.dragEnd.emit({source:this,parent:this._slider,value:this.value}),setTimeout(()=>this._updateWidthInactive()))}_clamp(e){return Math.max(Math.min(e,this._slider._cachedWidth),0)}_calcTranslateXByValue(){return this._slider._isRtl?(1-this.percentage)*this._slider._cachedWidth:this.percentage*this._slider._cachedWidth}_calcTranslateXByPointerEvent(e){return e.clientX-this._slider._cachedLeft}_updateWidthActive(){this._hostElement.style.padding=`0 ${this._slider._inputPadding}px`,this._hostElement.style.width=`calc(100% + ${this._slider._inputPadding}px)`}_updateWidthInactive(){this._hostElement.style.padding="0px",this._hostElement.style.width="calc(100% + 48px)",this._hostElement.style.left="-24px"}_updateThumbUIByValue(e){this.translateX=this._clamp(this._calcTranslateXByValue()),this._updateThumbUI(e)}_updateThumbUIByPointerEvent(e,r){this.translateX=this._clamp(this._calcTranslateXByPointerEvent(e)),this._updateThumbUI(r)}_updateThumbUI(e){this._slider._setTransition(!!e?.withAnimation),this._slider._onTranslateXChange(this)}writeValue(e){(this._isControlInitialized||null!==e)&&(this.value=e)}registerOnChange(e){this._onChangeFn=e,this._isControlInitialized=!0}registerOnTouched(e){this._onTouchedFn=e}setDisabledState(e){this.disabled=e}focus(){this._hostElement.focus()}blur(){this._hostElement.blur()}}return n.\u0275fac=function(e){return new(e||n)(de(Vt),de(yn),de(Vi),de(Zx))},n.\u0275dir=_t({type:n,selectors:[["input","matSliderThumb",""]],hostAttrs:["type","range",1,"mdc-slider__input"],hostVars:1,hostBindings:function(e,r){1&e&&an("change",function(){return r._onChange()})("input",function(){return r._onInput()})("blur",function(){return r._onBlur()})("focus",function(){return r._onFocus()}),2&e&&ui("aria-valuetext",r._valuetext)},inputs:{value:"value"},outputs:{valueChange:"valueChange",dragStart:"dragStart",dragEnd:"dragEnd"},exportAs:["matSliderThumb"],features:[En([GMe,{provide:LH,useExisting:n}])]}),n})(),qMe=(()=>{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275mod=Vn({type:n}),n.\u0275inj=Pn({imports:[Do,Vf,$x]}),n})();const zH=dp({passive:!0});let KMe=(()=>{class n{constructor(e,r){this._platform=e,this._ngZone=r,this._monitoredElements=new Map}monitor(e){if(!this._platform.isBrowser)return ho;const r=Ol(e),i=this._monitoredElements.get(r);if(i)return i.subject;const o=new Kt,s="cdk-text-field-autofilled",a=c=>{"cdk-text-field-autofill-start"!==c.animationName||r.classList.contains(s)?"cdk-text-field-autofill-end"===c.animationName&&r.classList.contains(s)&&(r.classList.remove(s),this._ngZone.run(()=>o.next({target:c.target,isAutofilled:!1}))):(r.classList.add(s),this._ngZone.run(()=>o.next({target:c.target,isAutofilled:!0})))};return this._ngZone.runOutsideAngular(()=>{r.addEventListener("animationstart",a,zH),r.classList.add("cdk-text-field-autofill-monitored")}),this._monitoredElements.set(r,{subject:o,unlisten:()=>{r.removeEventListener("animationstart",a,zH)}}),o}stopMonitoring(e){const r=Ol(e),i=this._monitoredElements.get(r);i&&(i.unlisten(),i.subject.complete(),r.classList.remove("cdk-text-field-autofill-monitored"),r.classList.remove("cdk-text-field-autofilled"),this._monitoredElements.delete(r))}ngOnDestroy(){this._monitoredElements.forEach((e,r)=>this.stopMonitoring(r))}}return n.\u0275fac=function(e){return new(e||n)(Fe(Wi),Fe(Vt))},n.\u0275prov=at({token:n,factory:n.\u0275fac,providedIn:"root"}),n})(),XMe=(()=>{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275mod=Vn({type:n}),n.\u0275inj=Pn({}),n})(),nFe=(()=>{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275dir=_t({type:n}),n})();const rFe=new Qe("MatFormField");let UH=(()=>{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275mod=Vn({type:n}),n.\u0275inj=Pn({imports:[Do,Vf,vA,Do]}),n})();const iFe=new Qe("MAT_INPUT_VALUE_ACCESSOR"),oFe=["button","checkbox","file","hidden","image","radio","range","reset","submit"];let sFe=0;const aFe=uRe(class{constructor(n,t,e,r){this._defaultErrorStateMatcher=n,this._parentForm=t,this._parentFormGroup=e,this.ngControl=r,this.stateChanges=new Kt}});let lFe=(()=>{class n extends aFe{get disabled(){return this._disabled}set disabled(e){this._disabled=gr(e),this.focused&&(this.focused=!1,this.stateChanges.next())}get id(){return this._id}set id(e){this._id=e||this._uid}get required(){return this._required??this.ngControl?.control?.hasValidator(BRe.required)??!1}set required(e){this._required=gr(e)}get type(){return this._type}set type(e){this._type=e||"text",this._validateType(),!this._isTextarea&&NG().has(this._type)&&(this._elementRef.nativeElement.type=this._type)}get value(){return this._inputValueAccessor.value}set value(e){e!==this.value&&(this._inputValueAccessor.value=e,this.stateChanges.next())}get readonly(){return this._readonly}set readonly(e){this._readonly=gr(e)}constructor(e,r,i,o,s,a,c,u,p,m){super(a,o,s,i),this._elementRef=e,this._platform=r,this._autofillMonitor=u,this._formField=m,this._uid="mat-input-"+sFe++,this.focused=!1,this.stateChanges=new Kt,this.controlType="mat-input",this.autofilled=!1,this._disabled=!1,this._type="text",this._readonly=!1,this._neverEmptyInputTypes=["date","datetime","datetime-local","month","time","week"].filter(x=>NG().has(x)),this._iOSKeyupListener=x=>{const T=x.target;!T.value&&0===T.selectionStart&&0===T.selectionEnd&&(T.setSelectionRange(1,1),T.setSelectionRange(0,0))};const g=this._elementRef.nativeElement,_=g.nodeName.toLowerCase();this._inputValueAccessor=c||g,this._previousNativeValue=this.value,this.id=this.id,r.IOS&&p.runOutsideAngular(()=>{e.nativeElement.addEventListener("keyup",this._iOSKeyupListener)}),this._isServer=!this._platform.isBrowser,this._isNativeSelect="select"===_,this._isTextarea="textarea"===_,this._isInFormField=!!m,this._isNativeSelect&&(this.controlType=g.multiple?"mat-native-select-multiple":"mat-native-select")}ngAfterViewInit(){this._platform.isBrowser&&this._autofillMonitor.monitor(this._elementRef.nativeElement).subscribe(e=>{this.autofilled=e.isAutofilled,this.stateChanges.next()})}ngOnChanges(){this.stateChanges.next()}ngOnDestroy(){this.stateChanges.complete(),this._platform.isBrowser&&this._autofillMonitor.stopMonitoring(this._elementRef.nativeElement),this._platform.IOS&&this._elementRef.nativeElement.removeEventListener("keyup",this._iOSKeyupListener)}ngDoCheck(){this.ngControl&&(this.updateErrorState(),null!==this.ngControl.disabled&&this.ngControl.disabled!==this.disabled&&(this.disabled=this.ngControl.disabled,this.stateChanges.next())),this._dirtyCheckNativeValue(),this._dirtyCheckPlaceholder()}focus(e){this._elementRef.nativeElement.focus(e)}_focusChanged(e){e!==this.focused&&(this.focused=e,this.stateChanges.next())}_onInput(){}_dirtyCheckNativeValue(){const e=this._elementRef.nativeElement.value;this._previousNativeValue!==e&&(this._previousNativeValue=e,this.stateChanges.next())}_dirtyCheckPlaceholder(){const e=this._getPlaceholder();if(e!==this._previousPlaceholder){const r=this._elementRef.nativeElement;this._previousPlaceholder=e,e?r.setAttribute("placeholder",e):r.removeAttribute("placeholder")}}_getPlaceholder(){return this.placeholder||null}_validateType(){oFe.indexOf(this._type)}_isNeverEmpty(){return this._neverEmptyInputTypes.indexOf(this._type)>-1}_isBadInput(){let e=this._elementRef.nativeElement.validity;return e&&e.badInput}get empty(){return!(this._isNeverEmpty()||this._elementRef.nativeElement.value||this._isBadInput()||this.autofilled)}get shouldLabelFloat(){if(this._isNativeSelect){const e=this._elementRef.nativeElement,r=e.options[0];return this.focused||e.multiple||!this.empty||!!(e.selectedIndex>-1&&r&&r.label)}return this.focused||!this.empty}setDescribedByIds(e){e.length?this._elementRef.nativeElement.setAttribute("aria-describedby",e.join(" ")):this._elementRef.nativeElement.removeAttribute("aria-describedby")}onContainerClick(){this.focused||this.focus()}_isInlineSelect(){const e=this._elementRef.nativeElement;return this._isNativeSelect&&(e.multiple||e.size>1)}}return n.\u0275fac=function(e){return new(e||n)(de(yn),de(Wi),de(Fl,10),de(hb,8),de(Yx,8),de(hRe),de(iFe,10),de(KMe),de(Vt),de(rFe,8))},n.\u0275dir=_t({type:n,selectors:[["input","matInput",""],["textarea","matInput",""],["select","matNativeControl",""],["input","matNativeControl",""],["textarea","matNativeControl",""]],hostAttrs:[1,"mat-mdc-input-element"],hostVars:18,hostBindings:function(e,r){1&e&&an("focus",function(){return r._focusChanged(!0)})("blur",function(){return r._focusChanged(!1)})("input",function(){return r._onInput()}),2&e&&($y("id",r.id)("disabled",r.disabled)("required",r.required),ui("name",r.name||null)("readonly",r.readonly&&!r._isNativeSelect||null)("aria-invalid",r.empty&&r.required?null:r.errorState)("aria-required",r.required)("id",r.id),Yr("mat-input-server",r._isServer)("mat-mdc-form-field-textarea-control",r._isInFormField&&r._isTextarea)("mat-mdc-form-field-input-control",r._isInFormField)("mdc-text-field__input",r._isInFormField)("mat-mdc-native-select-inline",r._isInlineSelect()))},inputs:{disabled:"disabled",id:"id",placeholder:"placeholder",name:"name",required:"required",type:"type",errorStateMatcher:"errorStateMatcher",userAriaDescribedBy:["aria-describedby","userAriaDescribedBy"],value:"value",readonly:"readonly"},exportAs:["matInput"],features:[En([{provide:nFe,useExisting:n}]),$t,po]}),n})(),cFe=(()=>{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275mod=Vn({type:n}),n.\u0275inj=Pn({imports:[Do,UH,UH,XMe,Do]}),n})();function uFe(n,t){}const dFe=function(n){return{animationDuration:n}},hFe=function(n,t){return{value:n,params:t}};function pFe(n,t){1&n&&Sf(0)}const jH=["*"],fFe=["tabListContainer"],mFe=["tabList"],gFe=["tabListInner"],bFe=["nextPaginator"],yFe=["previousPaginator"],_Fe=["tabBodyWrapper"],vFe=["tabHeader"];function xFe(n,t){}function wFe(n,t){1&n&&Xr(0,xFe,0,0,"ng-template",14),2&n&&nn("cdkPortalOutlet",Ar().$implicit.templateLabel)}function TFe(n,t){1&n&&_n(0),2&n&&Ii(Ar().$implicit.textLabel)}function SFe(n,t){if(1&n){const e=xf();ut(0,"div",6,7),an("click",function(){const i=ol(e),o=i.$implicit,s=i.index,a=Ar(),c=vf(1);return sl(a._handleClick(o,c,s))})("cdkFocusChange",function(i){const s=ol(e).index;return sl(Ar()._tabFocusChanged(i,s))}),kr(2,"span",8)(3,"div",9),ut(4,"span",10)(5,"span",11),Xr(6,wFe,1,1,"ng-template",12),Xr(7,TFe,1,1,"ng-template",null,13,HF),ft()()()}if(2&n){const e=t.$implicit,r=t.index,i=vf(1),o=vf(8),s=Ar();Yr("mdc-tab--active",s.selectedIndex===r),nn("id",s._getTabLabelId(r))("ngClass",e.labelClass)("disabled",e.disabled)("fitInkBarToContent",s.fitInkBarToContent),ui("tabIndex",s._getTabIndex(r))("aria-posinset",r+1)("aria-setsize",s._tabs.length)("aria-controls",s._getTabContentId(r))("aria-selected",s.selectedIndex===r)("aria-label",e.ariaLabel||null)("aria-labelledby",!e.ariaLabel&&e.ariaLabelledby?e.ariaLabelledby:null),At(3),nn("matRippleTrigger",i)("matRippleDisabled",e.disabled||s.disableRipple),At(3),nn("ngIf",e.templateLabel)("ngIfElse",o)}}function CFe(n,t){if(1&n){const e=xf();ut(0,"mat-tab-body",15),an("_onCentered",function(){return ol(e),sl(Ar()._removeTabBodyWrapperHeight())})("_onCentering",function(i){return ol(e),sl(Ar()._setTabBodyWrapperHeight(i))}),ft()}if(2&n){const e=t.$implicit,r=t.index,i=Ar();Yr("mat-mdc-tab-body-active",i.selectedIndex===r),nn("id",i._getTabContentId(r))("ngClass",e.bodyClass)("content",e.content)("position",e.position)("origin",e.origin)("animationDuration",i.animationDuration)("preserveContent",i.preserveContent),ui("tabindex",null!=i.contentTabIndex&&i.selectedIndex===r?i.contentTabIndex:null)("aria-labelledby",i._getTabLabelId(r))}}const IFe={translateTab:IA("translateTab",[gp("center, void, left-origin-center, right-origin-center",bs({transform:"none"})),gp("left",bs({transform:"translate3d(-100%, 0, 0)",minHeight:"1px",visibility:"hidden"})),gp("right",bs({transform:"translate3d(100%, 0, 0)",minHeight:"1px",visibility:"hidden"})),bp("* => left, * => right, left => center, right => center",mp("{{animationDuration}} cubic-bezier(0.35, 0, 0.25, 1)")),bp("void => left-origin-center",[bs({transform:"translate3d(-100%, 0, 0)",visibility:"hidden"}),mp("{{animationDuration}} cubic-bezier(0.35, 0, 0.25, 1)")]),bp("void => right-origin-center",[bs({transform:"translate3d(100%, 0, 0)",visibility:"hidden"}),mp("{{animationDuration}} cubic-bezier(0.35, 0, 0.25, 1)")])])};let EFe=(()=>{class n extends hp{constructor(e,r,i,o){super(e,r,o),this._host=i,this._centeringSub=le.EMPTY,this._leavingSub=le.EMPTY}ngOnInit(){super.ngOnInit(),this._centeringSub=this._host._beforeCentering.pipe(_u(this._host._isCenterPosition(this._host._position))).subscribe(e=>{e&&!this.hasAttached()&&this.attach(this._host._content)}),this._leavingSub=this._host._afterLeavingCenter.subscribe(()=>{this._host.preserveContent||this.detach()})}ngOnDestroy(){super.ngOnDestroy(),this._centeringSub.unsubscribe(),this._leavingSub.unsubscribe()}}return n.\u0275fac=function(e){return new(e||n)(de(du),de(eo),de(Dt(()=>GH)),de(Tn))},n.\u0275dir=_t({type:n,selectors:[["","matTabBodyHost",""]],features:[$t]}),n})(),DFe=(()=>{class n{set position(e){this._positionIndex=e,this._computePositionAnimationState()}constructor(e,r,i){this._elementRef=e,this._dir=r,this._dirChangeSubscription=le.EMPTY,this._translateTabComplete=new Kt,this._onCentering=new rn,this._beforeCentering=new rn,this._afterLeavingCenter=new rn,this._onCentered=new rn(!0),this.animationDuration="500ms",this.preserveContent=!1,r&&(this._dirChangeSubscription=r.change.subscribe(o=>{this._computePositionAnimationState(o),i.markForCheck()})),this._translateTabComplete.pipe(HG((o,s)=>o.fromState===s.fromState&&o.toState===s.toState)).subscribe(o=>{this._isCenterPosition(o.toState)&&this._isCenterPosition(this._position)&&this._onCentered.emit(),this._isCenterPosition(o.fromState)&&!this._isCenterPosition(this._position)&&this._afterLeavingCenter.emit()})}ngOnInit(){"center"==this._position&&null!=this.origin&&(this._position=this._computePositionFromOrigin(this.origin))}ngOnDestroy(){this._dirChangeSubscription.unsubscribe(),this._translateTabComplete.complete()}_onTranslateTabStarted(e){const r=this._isCenterPosition(e.toState);this._beforeCentering.emit(r),r&&this._onCentering.emit(this._elementRef.nativeElement.clientHeight)}_getLayoutDirection(){return this._dir&&"rtl"===this._dir.value?"rtl":"ltr"}_isCenterPosition(e){return"center"==e||"left-origin-center"==e||"right-origin-center"==e}_computePositionAnimationState(e=this._getLayoutDirection()){this._position=this._positionIndex<0?"ltr"==e?"left":"right":this._positionIndex>0?"ltr"==e?"right":"left":"center"}_computePositionFromOrigin(e){const r=this._getLayoutDirection();return"ltr"==r&&e<=0||"rtl"==r&&e>0?"left-origin-center":"right-origin-center"}}return n.\u0275fac=function(e){return new(e||n)(de(yn),de(Rl,8),de(Vi))},n.\u0275dir=_t({type:n,inputs:{_content:["content","_content"],origin:"origin",animationDuration:"animationDuration",preserveContent:"preserveContent",position:"position"},outputs:{_onCentering:"_onCentering",_beforeCentering:"_beforeCentering",_afterLeavingCenter:"_afterLeavingCenter",_onCentered:"_onCentered"}}),n})(),GH=(()=>{class n extends DFe{constructor(e,r,i){super(e,r,i)}}return n.\u0275fac=function(e){return new(e||n)(de(yn),de(Rl,8),de(Vi))},n.\u0275cmp=Pi({type:n,selectors:[["mat-tab-body"]],viewQuery:function(e,r){if(1&e&&Bi(hp,5),2&e){let i;ir(i=or())&&(r._portalHost=i.first)}},hostAttrs:[1,"mat-mdc-tab-body"],features:[$t],decls:3,vars:6,consts:[["cdkScrollable","",1,"mat-mdc-tab-body-content"],["content",""],["matTabBodyHost",""]],template:function(e,r){1&e&&(ut(0,"div",0,1),an("@translateTab.start",function(o){return r._onTranslateTabStarted(o)})("@translateTab.done",function(o){return r._translateTabComplete.next(o)}),Xr(2,uFe,0,0,"ng-template",2),ft()),2&e&&nn("@translateTab",function IF(n,t,e,r,i){return DF(qe(),fo(),n,t,e,r,i)}(3,hFe,r._position,CF(1,dFe,r.animationDuration)))},dependencies:[EFe],styles:['.mat-mdc-tab-body{top:0;left:0;right:0;bottom:0;position:absolute;display:block;overflow:hidden;outline:0;flex-basis:100%}.mat-mdc-tab-body.mat-mdc-tab-body-active{position:relative;overflow-x:hidden;overflow-y:auto;z-index:1;flex-grow:1}.mat-mdc-tab-group.mat-mdc-tab-group-dynamic-height .mat-mdc-tab-body.mat-mdc-tab-body-active{overflow-y:hidden}.mat-mdc-tab-body-content{height:100%;overflow:auto}.mat-mdc-tab-group-dynamic-height .mat-mdc-tab-body-content{overflow:hidden}.mat-mdc-tab-body-content[style*="visibility: hidden"]{display:none}'],encapsulation:2,data:{animation:[IFe.translateTab]}}),n})();const kFe=new Qe("MatTabContent");let AFe=(()=>{class n{constructor(e){this.template=e}}return n.\u0275fac=function(e){return new(e||n)(de(_o))},n.\u0275dir=_t({type:n,selectors:[["","matTabContent",""]],features:[En([{provide:kFe,useExisting:n}])]}),n})();const NFe=new Qe("MatTabLabel"),HH=new Qe("MAT_TAB");let OFe=(()=>{class n extends GNe{constructor(e,r,i){super(e,r),this._closestTab=i}}return n.\u0275fac=function(e){return new(e||n)(de(_o),de(eo),de(HH,8))},n.\u0275dir=_t({type:n,selectors:[["","mat-tab-label",""],["","matTabLabel",""]],features:[En([{provide:NFe,useExisting:n}]),$t]}),n})();const ZA="mdc-tab-indicator--active",WH="mdc-tab-indicator--no-transition";class RFe{constructor(t){this._items=t}hide(){this._items.forEach(t=>t.deactivateInkBar())}alignToElement(t){const e=this._items.find(i=>i.elementRef.nativeElement===t),r=this._currentItem;if(e!==r&&(r?.deactivateInkBar(),e)){const i=r?.elementRef.nativeElement.getBoundingClientRect?.();e.activateInkBar(i),this._currentItem=e}}}function MFe(n){return class extends n{constructor(...t){super(...t),this._fitToContent=!1}get fitInkBarToContent(){return this._fitToContent}set fitInkBarToContent(t){const e=gr(t);this._fitToContent!==e&&(this._fitToContent=e,this._inkBarElement&&this._appendInkBarElement())}activateInkBar(t){const e=this.elementRef.nativeElement;if(!t||!e.getBoundingClientRect||!this._inkBarContentElement)return void e.classList.add(ZA);const r=e.getBoundingClientRect(),i=t.width/r.width,o=t.left-r.left;e.classList.add(WH),this._inkBarContentElement.style.setProperty("transform",`translateX(${o}px) scaleX(${i})`),e.getBoundingClientRect(),e.classList.remove(WH),e.classList.add(ZA),this._inkBarContentElement.style.setProperty("transform","")}deactivateInkBar(){this.elementRef.nativeElement.classList.remove(ZA)}ngOnInit(){this._createInkBarElement()}ngOnDestroy(){this._inkBarElement?.remove(),this._inkBarElement=this._inkBarContentElement=null}_createInkBarElement(){const t=this.elementRef.nativeElement.ownerDocument||document;this._inkBarElement=t.createElement("span"),this._inkBarContentElement=t.createElement("span"),this._inkBarElement.className="mdc-tab-indicator",this._inkBarContentElement.className="mdc-tab-indicator__content mdc-tab-indicator__content--underline",this._inkBarElement.appendChild(this._inkBarContentElement),this._appendInkBarElement()}_appendInkBarElement(){(this._fitToContent?this.elementRef.nativeElement.querySelector(".mdc-tab__content"):this.elementRef.nativeElement).appendChild(this._inkBarElement)}}}const PFe=d6(class{}),$Fe=MFe((()=>{class n extends PFe{constructor(e){super(),this.elementRef=e}focus(){this.elementRef.nativeElement.focus()}getOffsetLeft(){return this.elementRef.nativeElement.offsetLeft}getOffsetWidth(){return this.elementRef.nativeElement.offsetWidth}}return n.\u0275fac=function(e){return new(e||n)(de(yn))},n.\u0275dir=_t({type:n,features:[$t]}),n})());let qH=(()=>{class n extends $Fe{}return n.\u0275fac=function(){let t;return function(r){return(t||(t=qr(n)))(r||n)}}(),n.\u0275dir=_t({type:n,selectors:[["","matTabLabelWrapper",""]],hostVars:3,hostBindings:function(e,r){2&e&&(ui("aria-disabled",!!r.disabled),Yr("mat-mdc-tab-disabled",r.disabled))},inputs:{disabled:"disabled",fitInkBarToContent:"fitInkBarToContent"},features:[$t]}),n})();const LFe=d6(class{}),KH=new Qe("MAT_TAB_GROUP");let BFe=(()=>{class n extends LFe{get content(){return this._contentPortal}constructor(e,r){super(),this._viewContainerRef=e,this._closestTabGroup=r,this.textLabel="",this._contentPortal=null,this._stateChanges=new Kt,this.position=null,this.origin=null,this.isActive=!1}ngOnChanges(e){(e.hasOwnProperty("textLabel")||e.hasOwnProperty("disabled"))&&this._stateChanges.next()}ngOnDestroy(){this._stateChanges.complete()}ngOnInit(){this._contentPortal=new Nx(this._explicitContent||this._implicitContent,this._viewContainerRef)}_setTemplateLabelInput(e){e&&e._closestTab===this&&(this._templateLabel=e)}}return n.\u0275fac=function(e){return new(e||n)(de(eo),de(KH,8))},n.\u0275dir=_t({type:n,viewQuery:function(e,r){if(1&e&&Bi(_o,7),2&e){let i;ir(i=or())&&(r._implicitContent=i.first)}},inputs:{textLabel:["label","textLabel"],ariaLabel:["aria-label","ariaLabel"],ariaLabelledby:["aria-labelledby","ariaLabelledby"],labelClass:"labelClass",bodyClass:"bodyClass"},features:[$t,po]}),n})(),XH=(()=>{class n extends BFe{constructor(){super(...arguments),this._explicitContent=void 0}get templateLabel(){return this._templateLabel}set templateLabel(e){this._setTemplateLabelInput(e)}}return n.\u0275fac=function(){let t;return function(r){return(t||(t=qr(n)))(r||n)}}(),n.\u0275cmp=Pi({type:n,selectors:[["mat-tab"]],contentQueries:function(e,r,i){if(1&e&&(fl(i,AFe,7,_o),fl(i,OFe,5)),2&e){let o;ir(o=or())&&(r._explicitContent=o.first),ir(o=or())&&(r.templateLabel=o.first)}},inputs:{disabled:"disabled"},exportAs:["matTab"],features:[En([{provide:HH,useExisting:n}]),$t],ngContentSelectors:jH,decls:1,vars:0,template:function(e,r){1&e&&(Tf(),Xr(0,pFe,1,0,"ng-template"))},encapsulation:2}),n})();const YH=dp({passive:!0});let UFe=(()=>{class n{get disablePagination(){return this._disablePagination}set disablePagination(e){this._disablePagination=gr(e)}get selectedIndex(){return this._selectedIndex}set selectedIndex(e){e=yi(e),this._selectedIndex!=e&&(this._selectedIndexChanged=!0,this._selectedIndex=e,this._keyManager&&this._keyManager.updateActiveItem(e))}constructor(e,r,i,o,s,a,c){this._elementRef=e,this._changeDetectorRef=r,this._viewportRuler=i,this._dir=o,this._ngZone=s,this._platform=a,this._animationMode=c,this._scrollDistance=0,this._selectedIndexChanged=!1,this._destroyed=new Kt,this._showPaginationControls=!1,this._disableScrollAfter=!0,this._disableScrollBefore=!0,this._stopScrolling=new Kt,this._disablePagination=!1,this._selectedIndex=0,this.selectFocusedIndex=new rn,this.indexFocused=new rn,s.runOutsideAngular(()=>{cp(e.nativeElement,"mouseleave").pipe(jc(this._destroyed)).subscribe(()=>{this._stopInterval()})})}ngAfterViewInit(){cp(this._previousPaginator.nativeElement,"touchstart",YH).pipe(jc(this._destroyed)).subscribe(()=>{this._handlePaginatorPress("before")}),cp(this._nextPaginator.nativeElement,"touchstart",YH).pipe(jc(this._destroyed)).subscribe(()=>{this._handlePaginatorPress("after")})}ngAfterContentInit(){const e=this._dir?this._dir.change:jt("ltr"),r=this._viewportRuler.change(150),i=()=>{this.updatePagination(),this._alignInkBarToSelectedTab()};this._keyManager=new POe(this._items).withHorizontalOrientation(this._getLayoutDirection()).withHomeAndEnd().withWrap().skipPredicate(()=>!1),this._keyManager.updateActiveItem(this._selectedIndex),this._ngZone.onStable.pipe(is(1)).subscribe(i),Et(e,r,this._items.changes,this._itemsResized()).pipe(jc(this._destroyed)).subscribe(()=>{this._ngZone.run(()=>{Promise.resolve().then(()=>{this._scrollDistance=Math.max(0,Math.min(this._getMaxScrollDistance(),this._scrollDistance)),i()})}),this._keyManager.withHorizontalOrientation(this._getLayoutDirection())}),this._keyManager.change.subscribe(o=>{this.indexFocused.emit(o),this._setTabFocus(o)})}_itemsResized(){return"function"!=typeof ResizeObserver?ho:this._items.changes.pipe(_u(this._items),Aa(e=>new An(r=>this._ngZone.runOutsideAngular(()=>{const i=new ResizeObserver(o=>r.next(o));return e.forEach(o=>i.observe(o.elementRef.nativeElement)),()=>{i.disconnect()}}))),_A(1),zi(e=>e.some(r=>r.contentRect.width>0&&r.contentRect.height>0)))}ngAfterContentChecked(){this._tabLabelCount!=this._items.length&&(this.updatePagination(),this._tabLabelCount=this._items.length,this._changeDetectorRef.markForCheck()),this._selectedIndexChanged&&(this._scrollToLabel(this._selectedIndex),this._checkScrollingControls(),this._alignInkBarToSelectedTab(),this._selectedIndexChanged=!1,this._changeDetectorRef.markForCheck()),this._scrollDistanceChanged&&(this._updateTabScrollPosition(),this._scrollDistanceChanged=!1,this._changeDetectorRef.markForCheck())}ngOnDestroy(){this._keyManager?.destroy(),this._destroyed.next(),this._destroyed.complete(),this._stopScrolling.complete()}_handleKeydown(e){if(!Rx(e))switch(e.keyCode){case 13:case 32:if(this.focusIndex!==this.selectedIndex){const r=this._items.get(this.focusIndex);r&&!r.disabled&&(this.selectFocusedIndex.emit(this.focusIndex),this._itemSelected(e))}break;default:this._keyManager.onKeydown(e)}}_onContentChanges(){const e=this._elementRef.nativeElement.textContent;e!==this._currentTextContent&&(this._currentTextContent=e||"",this._ngZone.run(()=>{this.updatePagination(),this._alignInkBarToSelectedTab(),this._changeDetectorRef.markForCheck()}))}updatePagination(){this._checkPaginationEnabled(),this._checkScrollingControls(),this._updateTabScrollPosition()}get focusIndex(){return this._keyManager?this._keyManager.activeItemIndex:0}set focusIndex(e){!this._isValidIndex(e)||this.focusIndex===e||!this._keyManager||this._keyManager.setActiveItem(e)}_isValidIndex(e){return!this._items||!!this._items.toArray()[e]}_setTabFocus(e){if(this._showPaginationControls&&this._scrollToLabel(e),this._items&&this._items.length){this._items.toArray()[e].focus();const r=this._tabListContainer.nativeElement;r.scrollLeft="ltr"==this._getLayoutDirection()?0:r.scrollWidth-r.offsetWidth}}_getLayoutDirection(){return this._dir&&"rtl"===this._dir.value?"rtl":"ltr"}_updateTabScrollPosition(){if(this.disablePagination)return;const e=this.scrollDistance,r="ltr"===this._getLayoutDirection()?-e:e;this._tabList.nativeElement.style.transform=`translateX(${Math.round(r)}px)`,(this._platform.TRIDENT||this._platform.EDGE)&&(this._tabListContainer.nativeElement.scrollLeft=0)}get scrollDistance(){return this._scrollDistance}set scrollDistance(e){this._scrollTo(e)}_scrollHeader(e){return this._scrollTo(this._scrollDistance+("before"==e?-1:1)*this._tabListContainer.nativeElement.offsetWidth/3)}_handlePaginatorClick(e){this._stopInterval(),this._scrollHeader(e)}_scrollToLabel(e){if(this.disablePagination)return;const r=this._items?this._items.toArray()[e]:null;if(!r)return;const i=this._tabListContainer.nativeElement.offsetWidth,{offsetLeft:o,offsetWidth:s}=r.elementRef.nativeElement;let a,c;"ltr"==this._getLayoutDirection()?(a=o,c=a+s):(c=this._tabListInner.nativeElement.offsetWidth-o,a=c-s);const u=this.scrollDistance,p=this.scrollDistance+i;a<u?this.scrollDistance-=u-a:c>p&&(this.scrollDistance+=Math.min(c-p,a-u))}_checkPaginationEnabled(){if(this.disablePagination)this._showPaginationControls=!1;else{const e=this._tabListInner.nativeElement.scrollWidth>this._elementRef.nativeElement.offsetWidth;e||(this.scrollDistance=0),e!==this._showPaginationControls&&this._changeDetectorRef.markForCheck(),this._showPaginationControls=e}}_checkScrollingControls(){this.disablePagination?this._disableScrollAfter=this._disableScrollBefore=!0:(this._disableScrollBefore=0==this.scrollDistance,this._disableScrollAfter=this.scrollDistance==this._getMaxScrollDistance(),this._changeDetectorRef.markForCheck())}_getMaxScrollDistance(){return this._tabListInner.nativeElement.scrollWidth-this._tabListContainer.nativeElement.offsetWidth||0}_alignInkBarToSelectedTab(){const e=this._items&&this._items.length?this._items.toArray()[this.selectedIndex]:null,r=e?e.elementRef.nativeElement:null;r?this._inkBar.alignToElement(r):this._inkBar.hide()}_stopInterval(){this._stopScrolling.next()}_handlePaginatorPress(e,r){r&&null!=r.button&&0!==r.button||(this._stopInterval(),DG(650,100).pipe(jc(Et(this._stopScrolling,this._destroyed))).subscribe(()=>{const{maxScrollDistance:i,distance:o}=this._scrollHeader(e);(0===o||o>=i)&&this._stopInterval()}))}_scrollTo(e){if(this.disablePagination)return{maxScrollDistance:0,distance:0};const r=this._getMaxScrollDistance();return this._scrollDistance=Math.max(0,Math.min(r,e)),this._scrollDistanceChanged=!0,this._checkScrollingControls(),{maxScrollDistance:r,distance:this._scrollDistance}}}return n.\u0275fac=function(e){return new(e||n)(de(yn),de(Vi),de(eb),de(Rl,8),de(Vt),de(Wi),de(ns,8))},n.\u0275dir=_t({type:n,inputs:{disablePagination:"disablePagination"}}),n})(),jFe=(()=>{class n extends UFe{get disableRipple(){return this._disableRipple}set disableRipple(e){this._disableRipple=gr(e)}constructor(e,r,i,o,s,a,c){super(e,r,i,o,s,a,c),this._disableRipple=!1}_itemSelected(e){e.preventDefault()}}return n.\u0275fac=function(e){return new(e||n)(de(yn),de(Vi),de(eb),de(Rl,8),de(Vt),de(Wi),de(ns,8))},n.\u0275dir=_t({type:n,inputs:{disableRipple:"disableRipple"},features:[$t]}),n})(),GFe=(()=>{class n extends jFe{constructor(e,r,i,o,s,a,c){super(e,r,i,o,s,a,c)}ngAfterContentInit(){this._inkBar=new RFe(this._items),super.ngAfterContentInit()}}return n.\u0275fac=function(e){return new(e||n)(de(yn),de(Vi),de(eb),de(Rl,8),de(Vt),de(Wi),de(ns,8))},n.\u0275cmp=Pi({type:n,selectors:[["mat-tab-header"]],contentQueries:function(e,r,i){if(1&e&&fl(i,qH,4),2&e){let o;ir(o=or())&&(r._items=o)}},viewQuery:function(e,r){if(1&e&&(Bi(fFe,7),Bi(mFe,7),Bi(gFe,7),Bi(bFe,5),Bi(yFe,5)),2&e){let i;ir(i=or())&&(r._tabListContainer=i.first),ir(i=or())&&(r._tabList=i.first),ir(i=or())&&(r._tabListInner=i.first),ir(i=or())&&(r._nextPaginator=i.first),ir(i=or())&&(r._previousPaginator=i.first)}},hostAttrs:[1,"mat-mdc-tab-header"],hostVars:4,hostBindings:function(e,r){2&e&&Yr("mat-mdc-tab-header-pagination-controls-enabled",r._showPaginationControls)("mat-mdc-tab-header-rtl","rtl"==r._getLayoutDirection())},inputs:{selectedIndex:"selectedIndex"},outputs:{selectFocusedIndex:"selectFocusedIndex",indexFocused:"indexFocused"},features:[$t],ngContentSelectors:jH,decls:13,vars:10,consts:[["aria-hidden","true","type","button","mat-ripple","","tabindex","-1",1,"mat-mdc-tab-header-pagination","mat-mdc-tab-header-pagination-before",3,"matRippleDisabled","disabled","click","mousedown","touchend"],["previousPaginator",""],[1,"mat-mdc-tab-header-pagination-chevron"],[1,"mat-mdc-tab-label-container",3,"keydown"],["tabListContainer",""],["role","tablist",1,"mat-mdc-tab-list",3,"cdkObserveContent"],["tabList",""],[1,"mat-mdc-tab-labels"],["tabListInner",""],["aria-hidden","true","type","button","mat-ripple","","tabindex","-1",1,"mat-mdc-tab-header-pagination","mat-mdc-tab-header-pagination-after",3,"matRippleDisabled","disabled","mousedown","click","touchend"],["nextPaginator",""]],template:function(e,r){1&e&&(Tf(),ut(0,"button",0,1),an("click",function(){return r._handlePaginatorClick("before")})("mousedown",function(o){return r._handlePaginatorPress("before",o)})("touchend",function(){return r._stopInterval()}),kr(2,"div",2),ft(),ut(3,"div",3,4),an("keydown",function(o){return r._handleKeydown(o)}),ut(5,"div",5,6),an("cdkObserveContent",function(){return r._onContentChanges()}),ut(7,"div",7,8),Sf(9),ft()()(),ut(10,"button",9,10),an("mousedown",function(o){return r._handlePaginatorPress("after",o)})("click",function(){return r._handlePaginatorClick("after")})("touchend",function(){return r._stopInterval()}),kr(12,"div",2),ft()),2&e&&(Yr("mat-mdc-tab-header-pagination-disabled",r._disableScrollBefore),nn("matRippleDisabled",r._disableScrollBefore||r.disableRipple)("disabled",r._disableScrollBefore||null),At(3),Yr("_mat-animation-noopable","NoopAnimations"===r._animationMode),At(7),Yr("mat-mdc-tab-header-pagination-disabled",r._disableScrollAfter),nn("matRippleDisabled",r._disableScrollAfter||r.disableRipple)("disabled",r._disableScrollAfter||null))},dependencies:[sb,DOe],styles:[".mat-mdc-tab-header{display:flex;overflow:hidden;position:relative;flex-shrink:0;--mdc-tab-indicator-active-indicator-height:2px;--mdc-tab-indicator-active-indicator-shape:0;--mdc-secondary-navigation-tab-container-height:48px}.mat-mdc-tab-header-pagination{-webkit-user-select:none;user-select:none;position:relative;display:none;justify-content:center;align-items:center;min-width:32px;cursor:pointer;z-index:2;-webkit-tap-highlight-color:rgba(0,0,0,0);touch-action:none;box-sizing:content-box;background:none;border:none;outline:0;padding:0}.mat-mdc-tab-header-pagination::-moz-focus-inner{border:0}.mat-mdc-tab-header-pagination .mat-ripple-element{opacity:.12;background-color:var(--mat-tab-header-inactive-ripple-color)}.mat-mdc-tab-header-pagination-controls-enabled .mat-mdc-tab-header-pagination{display:flex}.mat-mdc-tab-header-pagination-before,.mat-mdc-tab-header-rtl .mat-mdc-tab-header-pagination-after{padding-left:4px}.mat-mdc-tab-header-pagination-before .mat-mdc-tab-header-pagination-chevron,.mat-mdc-tab-header-rtl .mat-mdc-tab-header-pagination-after .mat-mdc-tab-header-pagination-chevron{transform:rotate(-135deg)}.mat-mdc-tab-header-rtl .mat-mdc-tab-header-pagination-before,.mat-mdc-tab-header-pagination-after{padding-right:4px}.mat-mdc-tab-header-rtl .mat-mdc-tab-header-pagination-before .mat-mdc-tab-header-pagination-chevron,.mat-mdc-tab-header-pagination-after .mat-mdc-tab-header-pagination-chevron{transform:rotate(45deg)}.mat-mdc-tab-header-pagination-chevron{border-style:solid;border-width:2px 2px 0 0;height:8px;width:8px;border-color:var(--mat-tab-header-pagination-icon-color)}.mat-mdc-tab-header-pagination-disabled{box-shadow:none;cursor:default;pointer-events:none}.mat-mdc-tab-header-pagination-disabled .mat-mdc-tab-header-pagination-chevron{opacity:.4}.mat-mdc-tab-list{flex-grow:1;position:relative;transition:transform 500ms cubic-bezier(0.35, 0, 0.25, 1)}._mat-animation-noopable .mat-mdc-tab-list{transition:none}._mat-animation-noopable span.mdc-tab-indicator__content,._mat-animation-noopable span.mdc-tab__text-label{transition:none}.mat-mdc-tab-label-container{display:flex;flex-grow:1;overflow:hidden;z-index:1}.mat-mdc-tab-labels{display:flex;flex:1 0 auto}[mat-align-tabs=center]>.mat-mdc-tab-header .mat-mdc-tab-labels{justify-content:center}[mat-align-tabs=end]>.mat-mdc-tab-header .mat-mdc-tab-labels{justify-content:flex-end}.mat-mdc-tab::before{margin:5px}.cdk-high-contrast-active .mat-mdc-tab[aria-disabled=true]{color:GrayText}"],encapsulation:2}),n})();const ZH=new Qe("MAT_TABS_CONFIG");let HFe=0;const WFe=h6(CA(class{constructor(n){this._elementRef=n}}),"primary");let qFe=(()=>{class n extends WFe{get dynamicHeight(){return this._dynamicHeight}set dynamicHeight(e){this._dynamicHeight=gr(e)}get selectedIndex(){return this._selectedIndex}set selectedIndex(e){this._indexToSelect=yi(e,null)}get animationDuration(){return this._animationDuration}set animationDuration(e){this._animationDuration=/^\d+$/.test(e+"")?e+"ms":e}get contentTabIndex(){return this._contentTabIndex}set contentTabIndex(e){this._contentTabIndex=yi(e,null)}get disablePagination(){return this._disablePagination}set disablePagination(e){this._disablePagination=gr(e)}get preserveContent(){return this._preserveContent}set preserveContent(e){this._preserveContent=gr(e)}get backgroundColor(){return this._backgroundColor}set backgroundColor(e){const r=this._elementRef.nativeElement.classList;r.remove("mat-tabs-with-background",`mat-background-${this.backgroundColor}`),e&&r.add("mat-tabs-with-background",`mat-background-${e}`),this._backgroundColor=e}constructor(e,r,i,o){super(e),this._changeDetectorRef=r,this._animationMode=o,this._tabs=new ih,this._indexToSelect=0,this._lastFocusedTabIndex=null,this._tabBodyWrapperHeight=0,this._tabsSubscription=le.EMPTY,this._tabLabelSubscription=le.EMPTY,this._dynamicHeight=!1,this._selectedIndex=null,this.headerPosition="above",this._disablePagination=!1,this._preserveContent=!1,this.selectedIndexChange=new rn,this.focusChange=new rn,this.animationDone=new rn,this.selectedTabChange=new rn(!0),this._groupId=HFe++,this.animationDuration=i&&i.animationDuration?i.animationDuration:"500ms",this.disablePagination=!(!i||null==i.disablePagination)&&i.disablePagination,this.dynamicHeight=!(!i||null==i.dynamicHeight)&&i.dynamicHeight,this.contentTabIndex=i?.contentTabIndex??null,this.preserveContent=!!i?.preserveContent}ngAfterContentChecked(){const e=this._indexToSelect=this._clampTabIndex(this._indexToSelect);if(this._selectedIndex!=e){const r=null==this._selectedIndex;if(!r){this.selectedTabChange.emit(this._createChangeEvent(e));const i=this._tabBodyWrapper.nativeElement;i.style.minHeight=i.clientHeight+"px"}Promise.resolve().then(()=>{this._tabs.forEach((i,o)=>i.isActive=o===e),r||(this.selectedIndexChange.emit(e),this._tabBodyWrapper.nativeElement.style.minHeight="")})}this._tabs.forEach((r,i)=>{r.position=i-e,null!=this._selectedIndex&&0==r.position&&!r.origin&&(r.origin=e-this._selectedIndex)}),this._selectedIndex!==e&&(this._selectedIndex=e,this._lastFocusedTabIndex=null,this._changeDetectorRef.markForCheck())}ngAfterContentInit(){this._subscribeToAllTabChanges(),this._subscribeToTabLabels(),this._tabsSubscription=this._tabs.changes.subscribe(()=>{const e=this._clampTabIndex(this._indexToSelect);if(e===this._selectedIndex){const r=this._tabs.toArray();let i;for(let o=0;o<r.length;o++)if(r[o].isActive){this._indexToSelect=this._selectedIndex=o,this._lastFocusedTabIndex=null,i=r[o];break}!i&&r[e]&&Promise.resolve().then(()=>{r[e].isActive=!0,this.selectedTabChange.emit(this._createChangeEvent(e))})}this._changeDetectorRef.markForCheck()})}_subscribeToAllTabChanges(){this._allTabs.changes.pipe(_u(this._allTabs)).subscribe(e=>{this._tabs.reset(e.filter(r=>r._closestTabGroup===this||!r._closestTabGroup)),this._tabs.notifyOnChanges()})}ngOnDestroy(){this._tabs.destroy(),this._tabsSubscription.unsubscribe(),this._tabLabelSubscription.unsubscribe()}realignInkBar(){this._tabHeader&&this._tabHeader._alignInkBarToSelectedTab()}updatePagination(){this._tabHeader&&this._tabHeader.updatePagination()}focusTab(e){const r=this._tabHeader;r&&(r.focusIndex=e)}_focusChanged(e){this._lastFocusedTabIndex=e,this.focusChange.emit(this._createChangeEvent(e))}_createChangeEvent(e){const r=new XFe;return r.index=e,this._tabs&&this._tabs.length&&(r.tab=this._tabs.toArray()[e]),r}_subscribeToTabLabels(){this._tabLabelSubscription&&this._tabLabelSubscription.unsubscribe(),this._tabLabelSubscription=Et(...this._tabs.map(e=>e._stateChanges)).subscribe(()=>this._changeDetectorRef.markForCheck())}_clampTabIndex(e){return Math.min(this._tabs.length-1,Math.max(e||0,0))}_getTabLabelId(e){return`mat-tab-label-${this._groupId}-${e}`}_getTabContentId(e){return`mat-tab-content-${this._groupId}-${e}`}_setTabBodyWrapperHeight(e){if(!this._dynamicHeight||!this._tabBodyWrapperHeight)return;const r=this._tabBodyWrapper.nativeElement;r.style.height=this._tabBodyWrapperHeight+"px",this._tabBodyWrapper.nativeElement.offsetHeight&&(r.style.height=e+"px")}_removeTabBodyWrapperHeight(){const e=this._tabBodyWrapper.nativeElement;this._tabBodyWrapperHeight=e.clientHeight,e.style.height="",this.animationDone.emit()}_handleClick(e,r,i){r.focusIndex=i,e.disabled||(this.selectedIndex=i)}_getTabIndex(e){return e===(this._lastFocusedTabIndex??this.selectedIndex)?0:-1}_tabFocusChanged(e,r){e&&"mouse"!==e&&"touch"!==e&&(this._tabHeader.focusIndex=r)}}return n.\u0275fac=function(e){return new(e||n)(de(yn),de(Vi),de(ZH,8),de(ns,8))},n.\u0275dir=_t({type:n,inputs:{dynamicHeight:"dynamicHeight",selectedIndex:"selectedIndex",headerPosition:"headerPosition",animationDuration:"animationDuration",contentTabIndex:"contentTabIndex",disablePagination:"disablePagination",preserveContent:"preserveContent",backgroundColor:"backgroundColor"},outputs:{selectedIndexChange:"selectedIndexChange",focusChange:"focusChange",animationDone:"animationDone",selectedTabChange:"selectedTabChange"},features:[$t]}),n})(),KFe=(()=>{class n extends qFe{get fitInkBarToContent(){return this._fitInkBarToContent}set fitInkBarToContent(e){this._fitInkBarToContent=gr(e),this._changeDetectorRef.markForCheck()}get stretchTabs(){return this._stretchTabs}set stretchTabs(e){this._stretchTabs=gr(e)}constructor(e,r,i,o){super(e,r,i,o),this._fitInkBarToContent=!1,this._stretchTabs=!0,this.fitInkBarToContent=!(!i||null==i.fitInkBarToContent)&&i.fitInkBarToContent,this.stretchTabs=!i||null==i.stretchTabs||i.stretchTabs}}return n.\u0275fac=function(e){return new(e||n)(de(yn),de(Vi),de(ZH,8),de(ns,8))},n.\u0275cmp=Pi({type:n,selectors:[["mat-tab-group"]],contentQueries:function(e,r,i){if(1&e&&fl(i,XH,5),2&e){let o;ir(o=or())&&(r._allTabs=o)}},viewQuery:function(e,r){if(1&e&&(Bi(_Fe,5),Bi(vFe,5)),2&e){let i;ir(i=or())&&(r._tabBodyWrapper=i.first),ir(i=or())&&(r._tabHeader=i.first)}},hostAttrs:["ngSkipHydration","",1,"mat-mdc-tab-group"],hostVars:6,hostBindings:function(e,r){2&e&&Yr("mat-mdc-tab-group-dynamic-height",r.dynamicHeight)("mat-mdc-tab-group-inverted-header","below"===r.headerPosition)("mat-mdc-tab-group-stretch-tabs",r.stretchTabs)},inputs:{color:"color",disableRipple:"disableRipple",fitInkBarToContent:"fitInkBarToContent",stretchTabs:["mat-stretch-tabs","stretchTabs"]},exportAs:["matTabGroup"],features:[En([{provide:KH,useExisting:n}]),$t],decls:6,vars:7,consts:[[3,"selectedIndex","disableRipple","disablePagination","indexFocused","selectFocusedIndex"],["tabHeader",""],["class","mdc-tab mat-mdc-tab mat-mdc-focus-indicator","role","tab","matTabLabelWrapper","","cdkMonitorElementFocus","",3,"id","mdc-tab--active","ngClass","disabled","fitInkBarToContent","click","cdkFocusChange",4,"ngFor","ngForOf"],[1,"mat-mdc-tab-body-wrapper"],["tabBodyWrapper",""],["role","tabpanel",3,"id","mat-mdc-tab-body-active","ngClass","content","position","origin","animationDuration","preserveContent","_onCentered","_onCentering",4,"ngFor","ngForOf"],["role","tab","matTabLabelWrapper","","cdkMonitorElementFocus","",1,"mdc-tab","mat-mdc-tab","mat-mdc-focus-indicator",3,"id","ngClass","disabled","fitInkBarToContent","click","cdkFocusChange"],["tabNode",""],[1,"mdc-tab__ripple"],["mat-ripple","",1,"mat-mdc-tab-ripple",3,"matRippleTrigger","matRippleDisabled"],[1,"mdc-tab__content"],[1,"mdc-tab__text-label"],[3,"ngIf","ngIfElse"],["tabTextLabel",""],[3,"cdkPortalOutlet"],["role","tabpanel",3,"id","ngClass","content","position","origin","animationDuration","preserveContent","_onCentered","_onCentering"]],template:function(e,r){1&e&&(ut(0,"mat-tab-header",0,1),an("indexFocused",function(o){return r._focusChanged(o)})("selectFocusedIndex",function(o){return r.selectedIndex=o}),Xr(2,SFe,9,17,"div",2),ft(),ut(3,"div",3,4),Xr(5,CFe,1,11,"mat-tab-body",5),ft()),2&e&&(nn("selectedIndex",r.selectedIndex||0)("disableRipple",r.disableRipple)("disablePagination",r.disablePagination),At(2),nn("ngForOf",r._tabs),At(1),Yr("_mat-animation-noopable","NoopAnimations"===r._animationMode),At(2),nn("ngForOf",r._tabs))},dependencies:[s_,a_,nc,hp,sb,JOe,GH,qH,GFe],styles:['.mdc-tab{min-width:90px;padding-right:24px;padding-left:24px;display:flex;flex:1 0 auto;justify-content:center;box-sizing:border-box;margin:0;padding-top:0;padding-bottom:0;border:none;outline:none;text-align:center;white-space:nowrap;cursor:pointer;-webkit-appearance:none;z-index:1}.mdc-tab::-moz-focus-inner{padding:0;border:0}.mdc-tab[hidden]{display:none}.mdc-tab--min-width{flex:0 1 auto}.mdc-tab__content{display:flex;align-items:center;justify-content:center;height:inherit;pointer-events:none}.mdc-tab__text-label{transition:150ms color linear;display:inline-block;line-height:1;z-index:2}.mdc-tab__icon{transition:150ms color linear;z-index:2}.mdc-tab--stacked .mdc-tab__content{flex-direction:column;align-items:center;justify-content:center}.mdc-tab--stacked .mdc-tab__text-label{padding-top:6px;padding-bottom:4px}.mdc-tab--active .mdc-tab__text-label,.mdc-tab--active .mdc-tab__icon{transition-delay:100ms}.mdc-tab:not(.mdc-tab--stacked) .mdc-tab__icon+.mdc-tab__text-label{padding-left:8px;padding-right:0}[dir=rtl] .mdc-tab:not(.mdc-tab--stacked) .mdc-tab__icon+.mdc-tab__text-label,.mdc-tab:not(.mdc-tab--stacked) .mdc-tab__icon+.mdc-tab__text-label[dir=rtl]{padding-left:0;padding-right:8px}.mdc-tab-indicator{display:flex;position:absolute;top:0;left:0;justify-content:center;width:100%;height:100%;pointer-events:none;z-index:1}.mdc-tab-indicator__content{transform-origin:left;opacity:0}.mdc-tab-indicator__content--underline{align-self:flex-end;box-sizing:border-box;width:100%;border-top-style:solid}.mdc-tab-indicator__content--icon{align-self:center;margin:0 auto}.mdc-tab-indicator--active .mdc-tab-indicator__content{opacity:1}.mdc-tab-indicator .mdc-tab-indicator__content{transition:250ms transform cubic-bezier(0.4, 0, 0.2, 1)}.mdc-tab-indicator--no-transition .mdc-tab-indicator__content{transition:none}.mdc-tab-indicator--fade .mdc-tab-indicator__content{transition:150ms opacity linear}.mdc-tab-indicator--active.mdc-tab-indicator--fade .mdc-tab-indicator__content{transition-delay:100ms}.mat-mdc-tab-ripple{position:absolute;top:0;left:0;bottom:0;right:0;pointer-events:none}.mat-mdc-tab{-webkit-tap-highlight-color:rgba(0,0,0,0);-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale;text-decoration:none;background:none;font-family:var(--mat-tab-header-label-text-font);font-size:var(--mat-tab-header-label-text-size);letter-spacing:var(--mat-tab-header-label-text-letter-spacing);line-height:var(--mat-tab-header-label-text-line-height);font-weight:var(--mat-tab-header-label-text-weight)}.mat-mdc-tab .mdc-tab-indicator__content--underline{border-color:var(--mdc-tab-indicator-active-indicator-color)}.mat-mdc-tab .mdc-tab-indicator__content--underline{border-top-width:var(--mdc-tab-indicator-active-indicator-height)}.mat-mdc-tab .mdc-tab-indicator__content--underline{border-radius:var(--mdc-tab-indicator-active-indicator-shape)}.mat-mdc-tab:not(.mdc-tab--stacked){height:var(--mdc-secondary-navigation-tab-container-height)}.mat-mdc-tab:not(:disabled).mdc-tab--active .mdc-tab__icon{fill:currentColor}.mat-mdc-tab:not(:disabled):hover.mdc-tab--active .mdc-tab__icon{fill:currentColor}.mat-mdc-tab:not(:disabled):focus.mdc-tab--active .mdc-tab__icon{fill:currentColor}.mat-mdc-tab:not(:disabled):active.mdc-tab--active .mdc-tab__icon{fill:currentColor}.mat-mdc-tab:disabled.mdc-tab--active .mdc-tab__icon{fill:currentColor}.mat-mdc-tab:not(:disabled):not(.mdc-tab--active) .mdc-tab__icon{fill:currentColor}.mat-mdc-tab:not(:disabled):hover:not(.mdc-tab--active) .mdc-tab__icon{fill:currentColor}.mat-mdc-tab:not(:disabled):focus:not(.mdc-tab--active) .mdc-tab__icon{fill:currentColor}.mat-mdc-tab:not(:disabled):active:not(.mdc-tab--active) .mdc-tab__icon{fill:currentColor}.mat-mdc-tab:disabled:not(.mdc-tab--active) .mdc-tab__icon{fill:currentColor}.mat-mdc-tab.mdc-tab{flex-grow:0}.mat-mdc-tab:hover .mdc-tab__text-label{color:var(--mat-tab-header-inactive-hover-label-text-color)}.mat-mdc-tab:focus .mdc-tab__text-label{color:var(--mat-tab-header-inactive-focus-label-text-color)}.mat-mdc-tab.mdc-tab--active .mdc-tab__text-label{color:var(--mat-tab-header-active-label-text-color)}.mat-mdc-tab.mdc-tab--active .mdc-tab__ripple::before,.mat-mdc-tab.mdc-tab--active .mat-ripple-element{background-color:var(--mat-tab-header-active-ripple-color)}.mat-mdc-tab.mdc-tab--active:hover .mdc-tab__text-label{color:var(--mat-tab-header-active-hover-label-text-color)}.mat-mdc-tab.mdc-tab--active:hover .mdc-tab-indicator__content--underline{border-color:var(--mat-tab-header-active-hover-indicator-color)}.mat-mdc-tab.mdc-tab--active:focus .mdc-tab__text-label{color:var(--mat-tab-header-active-focus-label-text-color)}.mat-mdc-tab.mdc-tab--active:focus .mdc-tab-indicator__content--underline{border-color:var(--mat-tab-header-active-focus-indicator-color)}.mat-mdc-tab.mat-mdc-tab-disabled{opacity:.4;pointer-events:none}.mat-mdc-tab.mat-mdc-tab-disabled .mdc-tab__content{pointer-events:none}.mat-mdc-tab.mat-mdc-tab-disabled .mdc-tab__ripple::before,.mat-mdc-tab.mat-mdc-tab-disabled .mat-ripple-element{background-color:var(--mat-tab-header-disabled-ripple-color)}.mat-mdc-tab .mdc-tab__ripple::before{content:"";display:block;position:absolute;top:0;left:0;right:0;bottom:0;opacity:0;pointer-events:none;background-color:var(--mat-tab-header-inactive-ripple-color)}.mat-mdc-tab .mdc-tab__text-label{color:var(--mat-tab-header-inactive-label-text-color);display:inline-flex;align-items:center}.mat-mdc-tab .mdc-tab__content{position:relative;pointer-events:auto}.mat-mdc-tab:hover .mdc-tab__ripple::before{opacity:.04}.mat-mdc-tab.cdk-program-focused .mdc-tab__ripple::before,.mat-mdc-tab.cdk-keyboard-focused .mdc-tab__ripple::before{opacity:.12}.mat-mdc-tab .mat-ripple-element{opacity:.12;background-color:var(--mat-tab-header-inactive-ripple-color)}.mat-mdc-tab-group.mat-mdc-tab-group-stretch-tabs>.mat-mdc-tab-header .mat-mdc-tab{flex-grow:1}.mat-mdc-tab-group{display:flex;flex-direction:column;max-width:100%}.mat-mdc-tab-group.mat-tabs-with-background>.mat-mdc-tab-header,.mat-mdc-tab-group.mat-tabs-with-background>.mat-mdc-tab-header-pagination{background-color:var(--mat-tab-header-with-background-background-color)}.mat-mdc-tab-group.mat-tabs-with-background.mat-primary>.mat-mdc-tab-header .mat-mdc-tab .mdc-tab__text-label{color:var(--mat-tab-header-with-background-foreground-color)}.mat-mdc-tab-group.mat-tabs-with-background.mat-primary>.mat-mdc-tab-header .mdc-tab-indicator__content--underline{border-color:var(--mat-tab-header-with-background-foreground-color)}.mat-mdc-tab-group.mat-tabs-with-background:not(.mat-primary)>.mat-mdc-tab-header .mat-mdc-tab:not(.mdc-tab--active) .mdc-tab__text-label{color:var(--mat-tab-header-with-background-foreground-color)}.mat-mdc-tab-group.mat-tabs-with-background:not(.mat-primary)>.mat-mdc-tab-header .mat-mdc-tab:not(.mdc-tab--active) .mdc-tab-indicator__content--underline{border-color:var(--mat-tab-header-with-background-foreground-color)}.mat-mdc-tab-group.mat-tabs-with-background>.mat-mdc-tab-header .mat-mdc-tab-header-pagination-chevron,.mat-mdc-tab-group.mat-tabs-with-background>.mat-mdc-tab-header .mat-mdc-focus-indicator::before,.mat-mdc-tab-group.mat-tabs-with-background>.mat-mdc-tab-header-pagination .mat-mdc-tab-header-pagination-chevron,.mat-mdc-tab-group.mat-tabs-with-background>.mat-mdc-tab-header-pagination .mat-mdc-focus-indicator::before{border-color:var(--mat-tab-header-with-background-foreground-color)}.mat-mdc-tab-group.mat-tabs-with-background>.mat-mdc-tab-header .mat-ripple-element,.mat-mdc-tab-group.mat-tabs-with-background>.mat-mdc-tab-header .mdc-tab__ripple::before,.mat-mdc-tab-group.mat-tabs-with-background>.mat-mdc-tab-header-pagination .mat-ripple-element,.mat-mdc-tab-group.mat-tabs-with-background>.mat-mdc-tab-header-pagination .mdc-tab__ripple::before{background-color:var(--mat-tab-header-with-background-foreground-color)}.mat-mdc-tab-group.mat-tabs-with-background>.mat-mdc-tab-header .mat-mdc-tab-header-pagination-chevron,.mat-mdc-tab-group.mat-tabs-with-background>.mat-mdc-tab-header-pagination .mat-mdc-tab-header-pagination-chevron{color:var(--mat-tab-header-with-background-foreground-color)}.mat-mdc-tab-group.mat-mdc-tab-group-inverted-header{flex-direction:column-reverse}.mat-mdc-tab-group.mat-mdc-tab-group-inverted-header .mdc-tab-indicator__content--underline{align-self:flex-start}.mat-mdc-tab-body-wrapper{position:relative;overflow:hidden;display:flex;transition:height 500ms cubic-bezier(0.35, 0, 0.25, 1)}.mat-mdc-tab-body-wrapper._mat-animation-noopable{transition:none !important;animation:none !important}'],encapsulation:2}),n})();class XFe{}let YFe=(()=>{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275mod=Vn({type:n}),n.\u0275inj=Pn({imports:[Vf,Do,tb,$x,vA,o6,Do]}),n})();const QH=function(n,t,e){return{boundItemGreen:n,boundItemYellow:t,boundItemRed:e}};function ZFe(n,t){if(1&n&&(ut(0,"div")(1,"div",5)(2,"p",6),_n(3),bo(4,"number"),ft(),ut(5,"p",7),_n(6),bo(7,"number"),ft()(),ut(8,"p",8),_n(9,"confidence span"),ft(),ut(10,"p",8),_n(11),bo(12,"number"),ft()()),2&n){const e=Ar();At(2),nn("ngClass",Of(14,QH,e.confidenceSpan<=2,e.confidenceSpan>2&&e.confidenceSpan<=4,e.confidenceSpan>4)),At(1),Ii(yo(4,5,e.lower10Quantile,"1.2-2")),At(2),nn("ngClass",Of(18,QH,e.confidenceSpan<=2,e.confidenceSpan>2&&e.confidenceSpan<=4,e.confidenceSpan>4)),At(1),Ii(yo(7,8,e.upper90Quantile,"1.2-2")),At(5),Ii(yo(12,11,e.confidenceSpan,"1.2-2"))}}let QFe=(()=>{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275cmp=Pi({type:n,selectors:[["app-prediction"]],inputs:{predictionTitle:"predictionTitle",predictionValue:"predictionValue",lower10Quantile:"lower10Quantile",upper90Quantile:"upper90Quantile",confidenceSpan:"confidenceSpan"},decls:10,vars:6,consts:[[1,"block","border","border-sky-500","justify-center","items-center","mb-3"],[1,"flex","justify-center","items-center","mb-3"],["data-tooltip-target","tooltip-default","id","prediction",1,"text-sm","font-bold","text-center","text-gray-900"],["id","prediction_value",1,"text-xl","p-2","font-bold","text-center","text-gray-900"],[4,"ngIf"],[1,"bound","float-root","justify-center","items-center"],[1,"float-left",3,"ngClass"],[1,"float-right",3,"ngClass"],[1,"font-bold","items-center","text-center"]],template:function(e,r){1&e&&(ut(0,"div",0)(1,"div",1)(2,"h2",2),_n(3),ft(),ut(4,"h1",3),_n(5),bo(6,"number"),ft(),ut(7,"p"),_n(8,"inches"),ft()(),Xr(9,ZFe,13,22,"div",4),ft()),2&e&&(At(3),Ql("",r.predictionTitle,":"),At(2),Ii(yo(6,3,r.predictionValue,"1.2-2")),At(4),nn("ngIf",r.lower10Quantile||r.upper90Quantile))},dependencies:[s_,nc,l_],styles:['p.boundItemRed[_ngcontent-%COMP%]{display:inline-block;border:4px solid red;padding:1em;position:relative}.boundItemRed[_ngcontent-%COMP%]:before, .boundItemRed[_ngcontent-%COMP%]:after{content:"";width:5em;border-bottom:4px solid red;position:absolute;top:50%}.boundItemRed[_ngcontent-%COMP%]:first-of-type:before, .boundItemRed[_ngcontent-%COMP%]:last-of-type:after{display:none}p.boundItemYellow[_ngcontent-%COMP%]{display:inline-block;border:4px solid yellow;padding:1em;position:relative}.boundItemYellow[_ngcontent-%COMP%]:before, .boundItemYellow[_ngcontent-%COMP%]:after{content:"";width:5em;border-bottom:4px solid yellow;position:absolute;top:50%}.boundItemYellow[_ngcontent-%COMP%]:first-of-type:before, .boundItemYellow[_ngcontent-%COMP%]:last-of-type:after{display:none}p.boundItemGreen[_ngcontent-%COMP%]{display:inline-block;border:4px solid green;padding:1em;position:relative}.boundItemGreen[_ngcontent-%COMP%]:before, .boundItemGreen[_ngcontent-%COMP%]:after{content:"";width:5em;border-bottom:4px solid green;position:absolute;top:50%}[_ngcontent-%COMP%]:after{left:100%}[_ngcontent-%COMP%]:before{right:100%}.boundItemGreen[_ngcontent-%COMP%]:first-of-type:before, .boundItemGreen[_ngcontent-%COMP%]:last-of-type:after{display:none}']}),n})();const JH=function(n,t,e){return{boundItemGreen:n,boundItemYellow:t,boundItemRed:e}};function JFe(n,t){if(1&n&&(ut(0,"div")(1,"div",5)(2,"p",6),_n(3),bo(4,"number"),ft(),ut(5,"p",7),_n(6),bo(7,"number"),ft()(),ut(8,"p",8),_n(9,"confidence span"),ft(),ut(10,"p",8),_n(11),bo(12,"number"),ft()()),2&n){const e=Ar();At(2),nn("ngClass",Of(14,JH,e.data.confidenceSpan<=2,e.data.confidenceSpan>2&&e.data.confidenceSpan<=4,e.data.confidenceSpan>4)),At(1),Ii(yo(4,5,e.data.lower10Quantile,"1.2-2")),At(2),nn("ngClass",Of(18,JH,e.data.confidenceSpan<=2,e.data.confidenceSpan>2&&e.data.confidenceSpan<=4,e.data.confidenceSpan>4)),At(1),Ii(yo(7,8,e.data.upper90Quantile,"1.2-2")),At(5),Ii(yo(12,11,e.data.confidenceSpan,"1.2-2"))}}let ePe=(()=>{class n{constructor(e,r){this.dialogRef=e,this.data=r}}return n.\u0275fac=function(e){return new(e||n)(de(kA),de(AA))},n.\u0275cmp=Pi({type:n,selectors:[["app-prediction-dialog"]],decls:10,vars:6,consts:[[1,"block","border","border-sky-500","justify-center","items-center","mb-3"],[1,"flex","justify-center","items-center","mb-3"],["data-tooltip-target","tooltip-default","id","prediction",1,"text-sm","font-bold","text-center","text-gray-900"],["id","prediction_value",1,"text-xl","p-2","font-bold","text-center","text-gray-900"],[4,"ngIf"],[1,"bound","float-root","justify-center","items-center"],[1,"float-left",3,"ngClass"],[1,"float-right",3,"ngClass"],[1,"font-bold","items-center","text-center"]],template:function(e,r){1&e&&(ut(0,"div",0)(1,"div",1)(2,"h2",2),_n(3),ft(),ut(4,"h1",3),_n(5),bo(6,"number"),ft(),ut(7,"p"),_n(8,"inches"),ft()(),Xr(9,JFe,13,22,"div",4),ft()),2&e&&(At(3),Ql("",r.data.predictionTitle,":"),At(2),Ii(yo(6,3,r.data.predictionValue,"1.2-2")),At(4),nn("ngIf",r.data.lower10Quantile||r.data.upper90Quantile))},dependencies:[s_,nc,l_],styles:['p.boundItemRed[_ngcontent-%COMP%]{display:inline-block;border:4px solid red;padding:1em;position:relative}.boundItemRed[_ngcontent-%COMP%]:before, .boundItemRed[_ngcontent-%COMP%]:after{content:"";width:5em;border-bottom:4px solid red;position:absolute;top:50%}.boundItemRed[_ngcontent-%COMP%]:first-of-type:before, .boundItemRed[_ngcontent-%COMP%]:last-of-type:after{display:none}p.boundItemYellow[_ngcontent-%COMP%]{display:inline-block;border:4px solid yellow;padding:1em;position:relative}.boundItemYellow[_ngcontent-%COMP%]:before, .boundItemYellow[_ngcontent-%COMP%]:after{content:"";width:5em;border-bottom:4px solid yellow;position:absolute;top:50%}.boundItemYellow[_ngcontent-%COMP%]:first-of-type:before, .boundItemYellow[_ngcontent-%COMP%]:last-of-type:after{display:none}p.boundItemGreen[_ngcontent-%COMP%]{display:inline-block;border:4px solid green;padding:1em;position:relative}.boundItemGreen[_ngcontent-%COMP%]:before, .boundItemGreen[_ngcontent-%COMP%]:after{content:"";width:5em;border-bottom:4px solid green;position:absolute;top:50%}[_ngcontent-%COMP%]:after{left:100%}[_ngcontent-%COMP%]:before{right:100%}.boundItemGreen[_ngcontent-%COMP%]:first-of-type:before, .boundItemGreen[_ngcontent-%COMP%]:last-of-type:after{display:none}']}),n})();function tPe(n,t){if(1&n){const e=xf();ut(0,"div",2)(1,"div",8),an("click",function(){ol(e);const i=Ar();return sl(i.openConfidenceModal(i.sittingHeightData))}),ut(2,"p"),_n(3),bo(4,"number"),ft()(),ut(5,"div",9),an("click",function(){ol(e);const i=Ar();return sl(i.openConfidenceModal(i.upperLegData))}),ut(6,"p"),_n(7),bo(8,"number"),ft()(),ut(9,"div",10),an("click",function(){ol(e);const i=Ar();return sl(i.openConfidenceModal(i.lowerLegData))}),ut(10,"p"),_n(11),bo(12,"number"),ft()()()}if(2&n){const e=Ar();At(3),Ii(yo(4,3,e.sittingHeightData[.5],"1.2-2")),At(4),Ii(yo(8,6,e.upperLegData[.5],"1.2-2")),At(4),Ii(yo(12,9,e.lowerLegData[.5],"1.2-2"))}}let nPe=(()=>{class n{constructor(e){this.dialog=e,this.data=null,this.hipsData=null,this.shoulderData=null,this.chestData=null,this.sittingHeightData=null,this.shoulderHeightData=null,this.upperLegData=null,this.lowerLegData=null}ngOnInit(){this.changeData()}changeData(){null!==this.data&&(this.hipsData=this.data.find(e=>"hipbreadthsitting"===e.target),this.shoulderData=this.data.find(e=>"bideltoidbreadth"===e.target),this.chestData=this.data.find(e=>"chestbreadth"===e.target),this.sittingHeightData=this.data.find(e=>"sittingheight"===e.target),this.upperLegData=this.data.find(e=>"buttockpopliteallength"===e.target),this.lowerLegData=this.data.find(e=>"poplitealheight"===e.target))}ngOnChanges(e){this.changeData()}openConfidenceModal(e){this.dialog.open(ePe,{width:"500px",height:"150px",data:{predictionTitle:e.target,lower10Quantile:e[.1],upper90Quantile:e[.9],confidenceSpan:e.confidenceSpan,predictionValue:e[.5]}}).afterClosed().subscribe(i=>{})}}return n.\u0275fac=function(e){return new(e||n)(de(NA))},n.\u0275cmp=Pi({type:n,selectors:[["app-body-image"]],inputs:{data:"data"},features:[po],decls:19,vars:13,consts:[[1,"object-center"],["src","assets/images/body1.png","alt","Body Image","width","200","height","300",1,"img-fluid"],[1,"absolute"],[1,"shoulders","text-blue-700",3,"click"],[1,"chest","text-blue-700",3,"click"],[1,"hips","text-blue-700",3,"click"],["src","assets/images/body2.png","alt","Body Image","width","500","height","300",1,"img-fluid"],["class","absolute",4,"ngIf"],[1,"sitting-height","text-blue-700",3,"click"],[1,"upper-leg","text-blue-700",3,"click"],[1,"lower-leg","text-blue-700",3,"click"]],template:function(e,r){1&e&&(ut(0,"div",0),kr(1,"img",1),ut(2,"div",2)(3,"div",3),an("click",function(){return r.openConfidenceModal(r.shoulderData)}),ut(4,"p"),_n(5),bo(6,"number"),ft()(),ut(7,"div",4),an("click",function(){return r.openConfidenceModal(r.chestData)}),ut(8,"p"),_n(9),bo(10,"number"),ft()(),ut(11,"div",5),an("click",function(){return r.openConfidenceModal(r.hipsData)}),ut(12,"p"),_n(13),bo(14,"number"),ft()()()(),kr(15,"br"),ut(16,"div"),kr(17,"img",6),Xr(18,tPe,13,12,"div",7),ft()),2&e&&(At(5),Ii(yo(6,4,r.shoulderData[.5],"1.2-2")),At(4),Ii(yo(10,7,r.chestData[.5],"1.2-2")),At(4),Ii(yo(14,10,r.hipsData[.5],"1.2-2")),At(5),nn("ngIf",r.data))},dependencies:[nc,l_],styles:[".shoulders[_ngcontent-%COMP%]{display:block;position:absolute;top:-375px;left:85px}.chest[_ngcontent-%COMP%]{display:block;position:absolute;top:-320px;left:85px}.hips[_ngcontent-%COMP%]{display:block;position:absolute;top:-255px;left:85px}.sitting-height[_ngcontent-%COMP%]{display:block;position:absolute;top:-395px;left:20px}.shoulder-height[_ngcontent-%COMP%]{display:block;position:absolute;top:-290px;left:45px}.upper-leg[_ngcontent-%COMP%]{display:block;position:absolute;top:-103px;left:168px}.lower-leg[_ngcontent-%COMP%]{display:block;position:absolute;top:-73px;left:223px}"]}),n})();function rPe(n,t){if(1&n&&(ut(0,"div",28),kr(1,"app-body-image",29),ft()),2&n){const e=Ar();At(1),nn("data",e.imageData)}}function iPe(n,t){if(1&n){const e=xf();ut(0,"div")(1,"div",30)(2,"app-prediction",31),an("click",function(){const o=ol(e).$implicit;return sl(Ar().onClickPrediction(o.target))}),ft()()()}if(2&n){const e=t.$implicit;At(2),nn("predictionTitle",e.target)("predictionValue",e[.5])("lower10Quantile",e[.1])("upper90Quantile",e[.9])("confidenceSpan",e.confidenceSpan)}}const QA=function(){return{standalone:!0}};let oPe=(()=>{class n{constructor(e,r,i){this.onnxModel=e,this.onnxConfModel=r,this.dialog=i,this.title="wams-ml-app",this.heightInInches=68,this.heightInFeetAndInches="5'8\"",this.weightInPounds=170,this.age=30,this.gender="male",this.genderInt=1,this.modelButtons=[{name:"Linear Regression",ID:"reg"},{name:"LightGBM Conf",ID:"conf"}],this.targetPredictions=[],this.targetMeasures=["hipbreadthsitting","bideltoidbreadth","chestbreadth","sittingheight","buttockpopliteallength","thighclearance","tibialheight","buttockkneelength","elbowrestheight","kneeheightsitting","poplitealheight"],this.chosenModel="LightGBM Conf",this.imageData=null}ngOnInit(){var e=this;return $e(function*(){yield e.loadHipModel(),yield e.loadUpperLegModel(),yield e.loadLowerLegModel(),e.predict()})()}onChangeHeight(e){this.heightInInches=+e.target.value,this.heightInFeetAndInches=this.convertInchesToFeetAndInches(this.heightInInches),this.predict()}convertInchesToFeetAndInches(e){return`${Math.floor(e/12)}'${e%12}"`}onChangeWeight(e){this.weightInPounds=+e.target.value,this.predict()}onChangeAge(e){this.age=+e.target.value,this.predict()}onChangeGender(e){this.gender=e.target.value,"male"===this.gender?this.genderInt=1:"female"===this.gender&&(this.genderInt=2),this.predict()}onChangeModel(e){this.chosenModel=e.value,"Linear Regression"===this.chosenModel&&(this.upper90Quantile=null,this.lower10Quantile=null,this.confidenceSpan=null),this.predict()}loadHipModel(){var e=this;return $e(function*(){e.hipModel=yield Sk("assets/hip_model/model.json")})()}loadUpperLegModel(){var e=this;return $e(function*(){e.upperLegModel=yield Sk("assets/upper_leg_model/model.json")})()}loadLowerLegModel(){var e=this;return $e(function*(){e.lowerLegModel=yield Sk("assets/lower_leg_model/model.json")})()}formatLabel(e){return Math.floor(e/12),`${e}`}predict(){var e=this;return $e(function*(){const r=Vh([e.age,e.heightInInches,e.weightInPounds,e.genderInt],[1,4]);if("Linear Regression"===e.chosenModel){const i=e.hipModel.predict(r);e.hipPredictionValue=e.roundToNearestQuarterInch(i.dataSync()[0]);const o=e.upperLegModel.predict(r);e.upperLegPredictionValue=e.roundToNearestQuarterInch(o.dataSync()[0]);const s=e.lowerLegModel.predict(r);e.lowerLegPredictionValue=e.roundToNearestQuarterInch(s.dataSync()[0])}else if("LightGBM"===e.chosenModel)yield e.onnxModel.predict(e.age,e.heightInInches,e.weightInPounds,e.genderInt).then(i=>{e.hipPredictionValue=e.roundToNearestQuarterInch(i),e.upperLegPredictionValue=null,e.lowerLegPredictionValue=null});else if("LightGBM Conf"===e.chosenModel){e.targetPredictions=[];for(const i of e.targetMeasures){const o=yield e.predictWithConfidence(i);e.targetPredictions.push(o)}}e.updateImageValues(e.targetPredictions)})()}updateImageValues(e){var r=this;return $e(function*(){console.log(e),r.imageData=e})()}predictWithConfidence(e){var r=this;return $e(function*(){let i=null,o=new cNe;o.target=e,yield r.onnxConfModel.getConfidenceModelURLs(e).then(s=>{i=s});for(const[s,a]of Object.entries(i))yield r.onnxConfModel.predictConfidence(a,r.age,r.heightInInches,r.weightInPounds,r.genderInt).then(c=>{switch(s){case"0.1":o[.1]=c;break;case"0.5":o[.5]=c;break;case"0.9":o[.9]=c}o.confidenceSpan=o[.9]-o[.1]});return o})()}roundToNearestQuarterInch(e){return Math.round(4*e)/4}onClickPrediction(e){this.dialog.open(ARe,{width:"500px",height:"665px",data:{name:e,image:`assets/images/${e}.png`}}).afterClosed().subscribe(i=>{})}}return n.\u0275fac=function(e){return new(e||n)(de(NRe),de(ORe),de(NA))},n.\u0275cmp=Pi({type:n,selectors:[["app-root"]],decls:57,vars:24,consts:[[1,"bg-gradient-to-tr","from-fuchsia-300","to-sky-500"],["id","login",1,"p-4","flex","flex-col","justify-center","min-h-screen","max-w-md","mx-auto"],[1,"p-6","bg-sky-100","rounded"],["src","assets/images/wams_logo.jpeg","alt","WAMS Logo",1,"w-22","h-28","mx-auto"],[1,"flex","items-center","justify-center","font-black","m-3","mb-12"],["id","wams_form","action","api_login","method","POST",1,"flex","flex-col"],[1,"flex","justify-between","items-center","mb-3"],["for","height-range",1,"block","font-extrabold","mb-2","underline","text-sm","text-center","text-slate-700"],["matInput","","type","text",3,"ngModel","value","ngModelOptions","ngModelChange","change"],["for","height-range",1,"block","mb-2","text-sm","font-medium","text-slate-700"],["min","32","max","90","id","height-range","step","1","showTickMarks","","discrete","",3,"displayWith"],["matSliderThumb","",3,"value","change"],["min","90","max","400","id","height-range","step","1","showTickMarks","","discrete","",3,"displayWith"],["min","18","max","120","id","height-range","step","1","showTickMarks","","discrete","",3,"displayWith"],[1,"justify-between","w-full","mb-3","items-center"],["id","male-radio","type","radio","value","male","checked","","name","default-radio",1,"w-4","h-4","text-blue-600","bg-gray-100","border-gray-300","focus:ring-blue-500","dark:focus:ring-blue-600","dark:ring-offset-gray-800","focus:ring-2","dark:bg-gray-700","dark:border-gray-600",3,"change"],["for","default-radio-1",1,"ml-2","pr-5","text-sm","font-medium","text-gray-900"],["id","female-radio","type","radio","value","female","name","default-radio",1,"w-4","h-4","text-blue-600","bg-gray-100","border-gray-300","focus:ring-blue-500","dark:focus:ring-blue-600","dark:ring-offset-gray-800","focus:ring-2","dark:bg-gray-700","dark:border-gray-600",3,"change"],["id","other-radio","type","radio","value","other","name","default-radio",1,"w-4","h-4","text-blue-600","bg-gray-100","border-gray-300","focus:ring-blue-500","dark:focus:ring-blue-600","dark:ring-offset-gray-800","focus:ring-2","dark:bg-gray-700","dark:border-gray-600",3,"change"],["mat-stretch-tabs","false","mat-align-tabs","center"],["label","Image"],["class","object-contain max-w-fit border border-sky-500 justify-center items-center",4,"ngIf"],["label","Prediction"],[4,"ngFor","ngForOf"],["src","assets/images/recover-logo.png","alt","WAMS Logo",1,"w-22","h-28","mx-auto"],[1,"flex","justify-center","items-center","p-4"],[1,"text-gray-700","text-sm"],["href","https://www.openlab.psu.edu/ansur2/","target","_blank",1,"text-gray-700","hover:text-gray-900"],[1,"object-contain","max-w-fit","border","border-sky-500","justify-center","items-center"],[3,"data"],[1,"block","items-center","mb-3","w-full"],[3,"predictionTitle","predictionValue","lower10Quantile","upper90Quantile","confidenceSpan","click"]],template:function(e,r){1&e&&(ut(0,"div",0)(1,"section",1)(2,"div",2)(3,"div")(4,"h3"),_n(5,"Wheelchair Automated Measurement System"),ft(),kr(6,"img",3),ft(),kr(7,"div",4),ut(8,"form",5)(9,"div",6)(10,"label",7),_n(11,"Height:"),ft(),ut(12,"input",8),an("ngModelChange",function(o){return r.heightInInches=o})("change",function(o){return r.onChangeHeight(o)}),ft(),ut(13,"label",9),_n(14),ft()(),ut(15,"mat-slider",10)(16,"input",11),an("change",function(o){return r.onChangeHeight(o)}),ft()(),ut(17,"div",6)(18,"label",7),_n(19,"Weight:"),ft(),ut(20,"input",8),an("ngModelChange",function(o){return r.weightInPounds=o})("change",function(o){return r.onChangeWeight(o)}),ft(),ut(21,"label",9),_n(22),ft()(),ut(23,"mat-slider",12)(24,"input",11),an("change",function(o){return r.onChangeWeight(o)}),ft()(),ut(25,"div",6)(26,"label",7),_n(27,"Age:"),ft(),ut(28,"input",8),an("ngModelChange",function(o){return r.age=o})("change",function(o){return r.onChangeAge(o)}),ft(),ut(29,"label",9),_n(30),ft()(),ut(31,"mat-slider",13)(32,"input",11),an("change",function(o){return r.onChangeAge(o)}),ft()(),ut(33,"div",6)(34,"label",7),_n(35,"Gender:"),ft()(),ut(36,"div",14)(37,"input",15),an("change",function(o){return r.onChangeGender(o)}),ft(),ut(38,"label",16),_n(39,"Male"),ft(),ut(40,"input",17),an("change",function(o){return r.onChangeGender(o)}),ft(),ut(41,"label",16),_n(42,"Female"),ft(),ut(43,"input",18),an("change",function(o){return r.onChangeGender(o)}),ft(),ut(44,"label",16),_n(45,"Other"),ft()()(),ut(46,"mat-tab-group",19)(47,"mat-tab",20),Xr(48,rPe,2,1,"div",21),ft(),ut(49,"mat-tab",22),Xr(50,iPe,3,5,"div",23),ft()(),ut(51,"div"),kr(52,"img",24),ft()()(),ut(53,"footer",25)(54,"p",26)(55,"a",27),_n(56,'Gordon, C.C., Blackwell, C.L., Bradtmiller, B., Parham, J.L., Barrientos, P., Paquette, S.P., Corner, B.D., Carson, J.M., Venezia, J.C., Rockwell, B.M., Mucher, M., Kristensen, S. (2014). "2012 Anthropometric Survey of U.S. Army Personnel: Methods and Summary Statistics." Final Report, U.S. Army Natick Soldier Research, Development and Engineering Center, Natick, Massachusetts. December 2014. Approved for public release; distribution is unlimited.'),ft()()()()),2&e&&(At(12),nn("ngModel",r.heightInInches)("value",r.heightInInches)("ngModelOptions",Uy(21,QA)),At(2),x1("",r.heightInInches," inches (",r.heightInFeetAndInches,")"),At(1),nn("displayWith",r.formatLabel),At(1),Cf("value",r.heightInInches),At(4),nn("ngModel",r.weightInPounds)("value",r.weightInPounds)("ngModelOptions",Uy(22,QA)),At(2),Ql("",r.weightInPounds," lbs"),At(1),nn("displayWith",r.formatLabel),At(1),Cf("value",r.weightInPounds),At(4),nn("ngModel",r.age)("value",r.age)("ngModelOptions",Uy(23,QA)),At(2),Ql("",r.age," y/o"),At(1),nn("displayWith",r.formatLabel),At(1),Cf("value",r.age),At(16),nn("ngIf",r.imageData),At(2),nn("ngForOf",r.targetPredictions))},dependencies:[a_,nc,yH,Bx,rH,iH,GA,hb,UMe,YA,lFe,XH,KFe,QFe,nPe]}),n})();function eW(n){return new ze(3e3,!1)}function Wc(n){switch(n.length){case 0:return new ab;case 1:return n[0];default:return new C6(n)}}function tW(n,t,e,r,i=new Map,o=new Map){const s=[],a=[];let c=-1,u=null;if(r.forEach(p=>{const m=p.get("offset"),g=m==c,_=g&&u||new Map;p.forEach((x,T)=>{let I=T,N=x;if("offset"!==T)switch(I=t.normalizePropertyName(I,s),N){case EA:N=i.get(T);break;case Ml:N=o.get(T);break;default:N=t.normalizeStyleValue(T,I,N,s)}_.set(I,N)}),g||a.push(_),u=_,c=m}),s.length)throw function DPe(n){return new ze(3502,!1)}();return a}function JA(n,t,e,r){switch(t){case"start":n.onStart(()=>r(e&&e2(e,"start",n)));break;case"done":n.onDone(()=>r(e&&e2(e,"done",n)));break;case"destroy":n.onDestroy(()=>r(e&&e2(e,"destroy",n)))}}function e2(n,t,e){const o=t2(n.element,n.triggerName,n.fromState,n.toState,t||n.phaseName,e.totalTime??n.totalTime,!!e.disabled),s=n._data;return null!=s&&(o._data=s),o}function t2(n,t,e,r,i="",o=0,s){return{element:n,triggerName:t,fromState:e,toState:r,phaseName:i,totalTime:o,disabled:!!s}}function _s(n,t,e){let r=n.get(t);return r||n.set(t,r=e),r}function nW(n){const t=n.indexOf(":");return[n.substring(1,t),n.slice(t+1)]}const VPe=(()=>typeof document>"u"?null:document.documentElement)();function n2(n){const t=n.parentNode||n.host||null;return t===VPe?null:t}let sd=null,rW=!1;function iW(n,t){for(;t;){if(t===n)return!0;t=n2(t)}return!1}function oW(n,t,e){if(e)return Array.from(n.querySelectorAll(t));const r=n.querySelector(t);return r?[r]:[]}let sW=(()=>{class n{validateStyleProperty(e){return function UPe(n){sd||(sd=function jPe(){return typeof document<"u"?document.body:null}()||{},rW=!!sd.style&&"WebkitAppearance"in sd.style);let t=!0;return sd.style&&!function zPe(n){return"ebkit"==n.substring(1,6)}(n)&&(t=n in sd.style,!t&&rW&&(t="Webkit"+n.charAt(0).toUpperCase()+n.slice(1)in sd.style)),t}(e)}matchesElement(e,r){return!1}containsElement(e,r){return iW(e,r)}getParentElement(e){return n2(e)}query(e,r,i){return oW(e,r,i)}computeStyle(e,r,i){return i||""}animate(e,r,i,o,s,a=[],c){return new ab(i,o)}}return n.\u0275fac=function(e){return new(e||n)},n.\u0275prov=at({token:n,factory:n.\u0275fac}),n})(),r2=(()=>{class n{}return n.NOOP=new sW,n})();const GPe=1e3,o2="ng-enter",Qx="ng-leave",Jx="ng-trigger",ew=".ng-trigger",lW="ng-animating",s2=".ng-animating";function Pl(n){if("number"==typeof n)return n;const t=n.match(/^(-?[\.\d]+)(m?s)/);return!t||t.length<2?0:a2(parseFloat(t[1]),t[2])}function a2(n,t){return"s"===t?n*GPe:n}function tw(n,t,e){return n.hasOwnProperty("duration")?n:function WPe(n,t,e){let i,o=0,s="";if("string"==typeof n){const a=n.match(/^(-?[\.\d]+)(m?s)(?:\s+(-?[\.\d]+)(m?s))?(?:\s+([-a-z]+(?:\(.+?\))?))?$/i);if(null===a)return t.push(eW()),{duration:0,delay:0,easing:""};i=a2(parseFloat(a[1]),a[2]);const c=a[3];null!=c&&(o=a2(parseFloat(c),a[4]));const u=a[5];u&&(s=u)}else i=n;if(!e){let a=!1,c=t.length;i<0&&(t.push(function sPe(){return new ze(3100,!1)}()),a=!0),o<0&&(t.push(function aPe(){return new ze(3101,!1)}()),a=!0),a&&t.splice(c,0,eW())}return{duration:i,delay:o,easing:s}}(n,t,e)}function pb(n,t={}){return Object.keys(n).forEach(e=>{t[e]=n[e]}),t}function cW(n){const t=new Map;return Object.keys(n).forEach(e=>{t.set(e,n[e])}),t}function qc(n,t=new Map,e){if(e)for(let[r,i]of e)t.set(r,i);for(let[r,i]of n)t.set(r,i);return t}function Za(n,t,e){t.forEach((r,i)=>{const o=c2(i);e&&!e.has(i)&&e.set(i,n.style[o]),n.style[o]=r})}function ad(n,t){t.forEach((e,r)=>{const i=c2(r);n.style[i]=""})}function fb(n){return Array.isArray(n)?1==n.length?n[0]:x6(n):n}const l2=new RegExp("{{\\s*(.+?)\\s*}}","g");function dW(n){let t=[];if("string"==typeof n){let e;for(;e=l2.exec(n);)t.push(e[1]);l2.lastIndex=0}return t}function mb(n,t,e){const r=n.toString(),i=r.replace(l2,(o,s)=>{let a=t[s];return null==a&&(e.push(function cPe(n){return new ze(3003,!1)}()),a=""),a.toString()});return i==r?n:i}function nw(n){const t=[];let e=n.next();for(;!e.done;)t.push(e.value),e=n.next();return t}const XPe=/-+([a-z0-9])/g;function c2(n){return n.replace(XPe,(...t)=>t[1].toUpperCase())}function vs(n,t,e){switch(t.type){case 7:return n.visitTrigger(t,e);case 0:return n.visitState(t,e);case 1:return n.visitTransition(t,e);case 2:return n.visitSequence(t,e);case 3:return n.visitGroup(t,e);case 4:return n.visitAnimate(t,e);case 5:return n.visitKeyframes(t,e);case 6:return n.visitStyle(t,e);case 8:return n.visitReference(t,e);case 9:return n.visitAnimateChild(t,e);case 10:return n.visitAnimateRef(t,e);case 11:return n.visitQuery(t,e);case 12:return n.visitStagger(t,e);default:throw function uPe(n){return new ze(3004,!1)}()}}function hW(n,t){return window.getComputedStyle(n)[t]}const rw="*";function QPe(n,t){const e=[];return"string"==typeof n?n.split(/\s*,\s*/).forEach(r=>function JPe(n,t,e){if(":"==n[0]){const c=function e$e(n,t){switch(n){case":enter":return"void => *";case":leave":return"* => void";case":increment":return(e,r)=>parseFloat(r)>parseFloat(e);case":decrement":return(e,r)=>parseFloat(r)<parseFloat(e);default:return t.push(function SPe(n){return new ze(3016,!1)}()),"* => *"}}(n,e);if("function"==typeof c)return void t.push(c);n=c}const r=n.match(/^(\*|[-\w]+)\s*(<?[=-]>)\s*(\*|[-\w]+)$/);if(null==r||r.length<4)return e.push(function TPe(n){return new ze(3015,!1)}()),t;const i=r[1],o=r[2],s=r[3];t.push(pW(i,s));"<"==o[0]&&!(i==rw&&s==rw)&&t.push(pW(s,i))}(r,e,t)):e.push(n),e}const iw=new Set(["true","1"]),ow=new Set(["false","0"]);function pW(n,t){const e=iw.has(n)||ow.has(n),r=iw.has(t)||ow.has(t);return(i,o)=>{let s=n==rw||n==i,a=t==rw||t==o;return!s&&e&&"boolean"==typeof i&&(s=i?iw.has(n):ow.has(n)),!a&&r&&"boolean"==typeof o&&(a=o?iw.has(t):ow.has(t)),s&&a}}const t$e=new RegExp("s*:selfs*,?","g");function u2(n,t,e,r){return new n$e(n).build(t,e,r)}class n$e{constructor(t){this._driver=t}build(t,e,r){const i=new o$e(e);return this._resetContextStyleTimingState(i),vs(this,fb(t),i)}_resetContextStyleTimingState(t){t.currentQuerySelector="",t.collectedStyles=new Map,t.collectedStyles.set("",new Map),t.currentTime=0}visitTrigger(t,e){let r=e.queryCount=0,i=e.depCount=0;const o=[],s=[];return"@"==t.name.charAt(0)&&e.errors.push(function hPe(){return new ze(3006,!1)}()),t.definitions.forEach(a=>{if(this._resetContextStyleTimingState(e),0==a.type){const c=a,u=c.name;u.toString().split(/\s*,\s*/).forEach(p=>{c.name=p,o.push(this.visitState(c,e))}),c.name=u}else if(1==a.type){const c=this.visitTransition(a,e);r+=c.queryCount,i+=c.depCount,s.push(c)}else e.errors.push(function pPe(){return new ze(3007,!1)}())}),{type:7,name:t.name,states:o,transitions:s,queryCount:r,depCount:i,options:null}}visitState(t,e){const r=this.visitStyle(t.styles,e),i=t.options&&t.options.params||null;if(r.containsDynamicStyles){const o=new Set,s=i||{};r.styles.forEach(a=>{a instanceof Map&&a.forEach(c=>{dW(c).forEach(u=>{s.hasOwnProperty(u)||o.add(u)})})}),o.size&&(nw(o.values()),e.errors.push(function fPe(n,t){return new ze(3008,!1)}()))}return{type:0,name:t.name,style:r,options:i?{params:i}:null}}visitTransition(t,e){e.queryCount=0,e.depCount=0;const r=vs(this,fb(t.animation),e);return{type:1,matchers:QPe(t.expr,e.errors),animation:r,queryCount:e.queryCount,depCount:e.depCount,options:ld(t.options)}}visitSequence(t,e){return{type:2,steps:t.steps.map(r=>vs(this,r,e)),options:ld(t.options)}}visitGroup(t,e){const r=e.currentTime;let i=0;const o=t.steps.map(s=>{e.currentTime=r;const a=vs(this,s,e);return i=Math.max(i,e.currentTime),a});return e.currentTime=i,{type:3,steps:o,options:ld(t.options)}}visitAnimate(t,e){const r=function a$e(n,t){if(n.hasOwnProperty("duration"))return n;if("number"==typeof n)return d2(tw(n,t).duration,0,"");const e=n;if(e.split(/\s+/).some(o=>"{"==o.charAt(0)&&"{"==o.charAt(1))){const o=d2(0,0,"");return o.dynamic=!0,o.strValue=e,o}const i=tw(e,t);return d2(i.duration,i.delay,i.easing)}(t.timings,e.errors);e.currentAnimateTimings=r;let i,o=t.styles?t.styles:bs({});if(5==o.type)i=this.visitKeyframes(o,e);else{let s=t.styles,a=!1;if(!s){a=!0;const u={};r.easing&&(u.easing=r.easing),s=bs(u)}e.currentTime+=r.duration+r.delay;const c=this.visitStyle(s,e);c.isEmptyStep=a,i=c}return e.currentAnimateTimings=null,{type:4,timings:r,style:i,options:null}}visitStyle(t,e){const r=this._makeStyleAst(t,e);return this._validateStyleAst(r,e),r}_makeStyleAst(t,e){const r=[],i=Array.isArray(t.styles)?t.styles:[t.styles];for(let a of i)"string"==typeof a?a===Ml?r.push(a):e.errors.push(new ze(3002,!1)):r.push(cW(a));let o=!1,s=null;return r.forEach(a=>{if(a instanceof Map&&(a.has("easing")&&(s=a.get("easing"),a.delete("easing")),!o))for(let c of a.values())if(c.toString().indexOf("{{")>=0){o=!0;break}}),{type:6,styles:r,easing:s,offset:t.offset,containsDynamicStyles:o,options:null}}_validateStyleAst(t,e){const r=e.currentAnimateTimings;let i=e.currentTime,o=e.currentTime;r&&o>0&&(o-=r.duration+r.delay),t.styles.forEach(s=>{"string"!=typeof s&&s.forEach((a,c)=>{const u=e.collectedStyles.get(e.currentQuerySelector),p=u.get(c);let m=!0;p&&(o!=i&&o>=p.startTime&&i<=p.endTime&&(e.errors.push(function gPe(n,t,e,r,i){return new ze(3010,!1)}()),m=!1),o=p.startTime),m&&u.set(c,{startTime:o,endTime:i}),e.options&&function KPe(n,t,e){const r=t.params||{},i=dW(n);i.length&&i.forEach(o=>{r.hasOwnProperty(o)||e.push(function lPe(n){return new ze(3001,!1)}())})}(a,e.options,e.errors)})})}visitKeyframes(t,e){const r={type:5,styles:[],options:null};if(!e.currentAnimateTimings)return e.errors.push(function bPe(){return new ze(3011,!1)}()),r;let o=0;const s=[];let a=!1,c=!1,u=0;const p=t.steps.map(N=>{const R=this._makeStyleAst(N,e);let L=null!=R.offset?R.offset:function s$e(n){if("string"==typeof n)return null;let t=null;if(Array.isArray(n))n.forEach(e=>{if(e instanceof Map&&e.has("offset")){const r=e;t=parseFloat(r.get("offset")),r.delete("offset")}});else if(n instanceof Map&&n.has("offset")){const e=n;t=parseFloat(e.get("offset")),e.delete("offset")}return t}(R.styles),V=0;return null!=L&&(o++,V=R.offset=L),c=c||V<0||V>1,a=a||V<u,u=V,s.push(V),R});c&&e.errors.push(function yPe(){return new ze(3012,!1)}()),a&&e.errors.push(function _Pe(){return new ze(3200,!1)}());const m=t.steps.length;let g=0;o>0&&o<m?e.errors.push(function vPe(){return new ze(3202,!1)}()):0==o&&(g=1/(m-1));const _=m-1,x=e.currentTime,T=e.currentAnimateTimings,I=T.duration;return p.forEach((N,R)=>{const L=g>0?R==_?1:g*R:s[R],V=L*I;e.currentTime=x+T.delay+V,T.duration=V,this._validateStyleAst(N,e),N.offset=L,r.styles.push(N)}),r}visitReference(t,e){return{type:8,animation:vs(this,fb(t.animation),e),options:ld(t.options)}}visitAnimateChild(t,e){return e.depCount++,{type:9,options:ld(t.options)}}visitAnimateRef(t,e){return{type:10,animation:this.visitReference(t.animation,e),options:ld(t.options)}}visitQuery(t,e){const r=e.currentQuerySelector,i=t.options||{};e.queryCount++,e.currentQuery=t;const[o,s]=function r$e(n){const t=!!n.split(/\s*,\s*/).find(e=>":self"==e);return t&&(n=n.replace(t$e,"")),n=n.replace(/@\*/g,ew).replace(/@\w+/g,e=>ew+"-"+e.slice(1)).replace(/:animating/g,s2),[n,t]}(t.selector);e.currentQuerySelector=r.length?r+" "+o:o,_s(e.collectedStyles,e.currentQuerySelector,new Map);const a=vs(this,fb(t.animation),e);return e.currentQuery=null,e.currentQuerySelector=r,{type:11,selector:o,limit:i.limit||0,optional:!!i.optional,includeSelf:s,animation:a,originalSelector:t.selector,options:ld(t.options)}}visitStagger(t,e){e.currentQuery||e.errors.push(function xPe(){return new ze(3013,!1)}());const r="full"===t.timings?{duration:0,delay:0,easing:"full"}:tw(t.timings,e.errors,!0);return{type:12,animation:vs(this,fb(t.animation),e),timings:r,options:null}}}class o$e{constructor(t){this.errors=t,this.queryCount=0,this.depCount=0,this.currentTransition=null,this.currentQuery=null,this.currentQuerySelector=null,this.currentAnimateTimings=null,this.currentTime=0,this.collectedStyles=new Map,this.options=null,this.unsupportedCSSPropertiesFound=new Set}}function ld(n){return n?(n=pb(n)).params&&(n.params=function i$e(n){return n?pb(n):null}(n.params)):n={},n}function d2(n,t,e){return{duration:n,delay:t,easing:e}}function h2(n,t,e,r,i,o,s=null,a=!1){return{type:1,element:n,keyframes:t,preStyleProps:e,postStyleProps:r,duration:i,delay:o,totalTime:i+o,easing:s,subTimeline:a}}class sw{constructor(){this._map=new Map}get(t){return this._map.get(t)||[]}append(t,e){let r=this._map.get(t);r||this._map.set(t,r=[]),r.push(...e)}has(t){return this._map.has(t)}clear(){this._map.clear()}}const u$e=new RegExp(":enter","g"),h$e=new RegExp(":leave","g");function p2(n,t,e,r,i,o=new Map,s=new Map,a,c,u=[]){return(new p$e).buildKeyframes(n,t,e,r,i,o,s,a,c,u)}class p$e{buildKeyframes(t,e,r,i,o,s,a,c,u,p=[]){u=u||new sw;const m=new f2(t,e,u,i,o,p,[]);m.options=c;const g=c.delay?Pl(c.delay):0;m.currentTimeline.delayNextStep(g),m.currentTimeline.setStyles([s],null,m.errors,c),vs(this,r,m);const _=m.timelines.filter(x=>x.containsAnimation());if(_.length&&a.size){let x;for(let T=_.length-1;T>=0;T--){const I=_[T];if(I.element===e){x=I;break}}x&&!x.allowOnlyTimelineStyles()&&x.setStyles([a],null,m.errors,c)}return _.length?_.map(x=>x.buildKeyframes()):[h2(e,[],[],[],0,g,"",!1)]}visitTrigger(t,e){}visitState(t,e){}visitTransition(t,e){}visitAnimateChild(t,e){const r=e.subInstructions.get(e.element);if(r){const i=e.createSubContext(t.options),o=e.currentTimeline.currentTime,s=this._visitSubInstructions(r,i,i.options);o!=s&&e.transformIntoNewTimeline(s)}e.previousNode=t}visitAnimateRef(t,e){const r=e.createSubContext(t.options);r.transformIntoNewTimeline(),this._applyAnimationRefDelays([t.options,t.animation.options],e,r),this.visitReference(t.animation,r),e.transformIntoNewTimeline(r.currentTimeline.currentTime),e.previousNode=t}_applyAnimationRefDelays(t,e,r){for(const i of t){const o=i?.delay;if(o){const s="number"==typeof o?o:Pl(mb(o,i?.params??{},e.errors));r.delayNextStep(s)}}}_visitSubInstructions(t,e,r){let o=e.currentTimeline.currentTime;const s=null!=r.duration?Pl(r.duration):null,a=null!=r.delay?Pl(r.delay):null;return 0!==s&&t.forEach(c=>{const u=e.appendInstructionToTimeline(c,s,a);o=Math.max(o,u.duration+u.delay)}),o}visitReference(t,e){e.updateOptions(t.options,!0),vs(this,t.animation,e),e.previousNode=t}visitSequence(t,e){const r=e.subContextCount;let i=e;const o=t.options;if(o&&(o.params||o.delay)&&(i=e.createSubContext(o),i.transformIntoNewTimeline(),null!=o.delay)){6==i.previousNode.type&&(i.currentTimeline.snapshotCurrentStyles(),i.previousNode=aw);const s=Pl(o.delay);i.delayNextStep(s)}t.steps.length&&(t.steps.forEach(s=>vs(this,s,i)),i.currentTimeline.applyStylesToKeyframe(),i.subContextCount>r&&i.transformIntoNewTimeline()),e.previousNode=t}visitGroup(t,e){const r=[];let i=e.currentTimeline.currentTime;const o=t.options&&t.options.delay?Pl(t.options.delay):0;t.steps.forEach(s=>{const a=e.createSubContext(t.options);o&&a.delayNextStep(o),vs(this,s,a),i=Math.max(i,a.currentTimeline.currentTime),r.push(a.currentTimeline)}),r.forEach(s=>e.currentTimeline.mergeTimelineCollectedStyles(s)),e.transformIntoNewTimeline(i),e.previousNode=t}_visitTiming(t,e){if(t.dynamic){const r=t.strValue;return tw(e.params?mb(r,e.params,e.errors):r,e.errors)}return{duration:t.duration,delay:t.delay,easing:t.easing}}visitAnimate(t,e){const r=e.currentAnimateTimings=this._visitTiming(t.timings,e),i=e.currentTimeline;r.delay&&(e.incrementTime(r.delay),i.snapshotCurrentStyles());const o=t.style;5==o.type?this.visitKeyframes(o,e):(e.incrementTime(r.duration),this.visitStyle(o,e),i.applyStylesToKeyframe()),e.currentAnimateTimings=null,e.previousNode=t}visitStyle(t,e){const r=e.currentTimeline,i=e.currentAnimateTimings;!i&&r.hasCurrentStyleProperties()&&r.forwardFrame();const o=i&&i.easing||t.easing;t.isEmptyStep?r.applyEmptyStep(o):r.setStyles(t.styles,o,e.errors,e.options),e.previousNode=t}visitKeyframes(t,e){const r=e.currentAnimateTimings,i=e.currentTimeline.duration,o=r.duration,a=e.createSubContext().currentTimeline;a.easing=r.easing,t.styles.forEach(c=>{a.forwardTime((c.offset||0)*o),a.setStyles(c.styles,c.easing,e.errors,e.options),a.applyStylesToKeyframe()}),e.currentTimeline.mergeTimelineCollectedStyles(a),e.transformIntoNewTimeline(i+o),e.previousNode=t}visitQuery(t,e){const r=e.currentTimeline.currentTime,i=t.options||{},o=i.delay?Pl(i.delay):0;o&&(6===e.previousNode.type||0==r&&e.currentTimeline.hasCurrentStyleProperties())&&(e.currentTimeline.snapshotCurrentStyles(),e.previousNode=aw);let s=r;const a=e.invokeQuery(t.selector,t.originalSelector,t.limit,t.includeSelf,!!i.optional,e.errors);e.currentQueryTotal=a.length;let c=null;a.forEach((u,p)=>{e.currentQueryIndex=p;const m=e.createSubContext(t.options,u);o&&m.delayNextStep(o),u===e.element&&(c=m.currentTimeline),vs(this,t.animation,m),m.currentTimeline.applyStylesToKeyframe(),s=Math.max(s,m.currentTimeline.currentTime)}),e.currentQueryIndex=0,e.currentQueryTotal=0,e.transformIntoNewTimeline(s),c&&(e.currentTimeline.mergeTimelineCollectedStyles(c),e.currentTimeline.snapshotCurrentStyles()),e.previousNode=t}visitStagger(t,e){const r=e.parentContext,i=e.currentTimeline,o=t.timings,s=Math.abs(o.duration),a=s*(e.currentQueryTotal-1);let c=s*e.currentQueryIndex;switch(o.duration<0?"reverse":o.easing){case"reverse":c=a-c;break;case"full":c=r.currentStaggerTime}const p=e.currentTimeline;c&&p.delayNextStep(c);const m=p.currentTime;vs(this,t.animation,e),e.previousNode=t,r.currentStaggerTime=i.currentTime-m+(i.startTime-r.currentTimeline.startTime)}}const aw={};class f2{constructor(t,e,r,i,o,s,a,c){this._driver=t,this.element=e,this.subInstructions=r,this._enterClassName=i,this._leaveClassName=o,this.errors=s,this.timelines=a,this.parentContext=null,this.currentAnimateTimings=null,this.previousNode=aw,this.subContextCount=0,this.options={},this.currentQueryIndex=0,this.currentQueryTotal=0,this.currentStaggerTime=0,this.currentTimeline=c||new lw(this._driver,e,0),a.push(this.currentTimeline)}get params(){return this.options.params}updateOptions(t,e){if(!t)return;const r=t;let i=this.options;null!=r.duration&&(i.duration=Pl(r.duration)),null!=r.delay&&(i.delay=Pl(r.delay));const o=r.params;if(o){let s=i.params;s||(s=this.options.params={}),Object.keys(o).forEach(a=>{(!e||!s.hasOwnProperty(a))&&(s[a]=mb(o[a],s,this.errors))})}}_copyOptions(){const t={};if(this.options){const e=this.options.params;if(e){const r=t.params={};Object.keys(e).forEach(i=>{r[i]=e[i]})}}return t}createSubContext(t=null,e,r){const i=e||this.element,o=new f2(this._driver,i,this.subInstructions,this._enterClassName,this._leaveClassName,this.errors,this.timelines,this.currentTimeline.fork(i,r||0));return o.previousNode=this.previousNode,o.currentAnimateTimings=this.currentAnimateTimings,o.options=this._copyOptions(),o.updateOptions(t),o.currentQueryIndex=this.currentQueryIndex,o.currentQueryTotal=this.currentQueryTotal,o.parentContext=this,this.subContextCount++,o}transformIntoNewTimeline(t){return this.previousNode=aw,this.currentTimeline=this.currentTimeline.fork(this.element,t),this.timelines.push(this.currentTimeline),this.currentTimeline}appendInstructionToTimeline(t,e,r){const i={duration:e??t.duration,delay:this.currentTimeline.currentTime+(r??0)+t.delay,easing:""},o=new f$e(this._driver,t.element,t.keyframes,t.preStyleProps,t.postStyleProps,i,t.stretchStartingKeyframe);return this.timelines.push(o),i}incrementTime(t){this.currentTimeline.forwardTime(this.currentTimeline.duration+t)}delayNextStep(t){t>0&&this.currentTimeline.delayNextStep(t)}invokeQuery(t,e,r,i,o,s){let a=[];if(i&&a.push(this.element),t.length>0){t=(t=t.replace(u$e,"."+this._enterClassName)).replace(h$e,"."+this._leaveClassName);let u=this._driver.query(this.element,t,1!=r);0!==r&&(u=r<0?u.slice(u.length+r,u.length):u.slice(0,r)),a.push(...u)}return!o&&0==a.length&&s.push(function wPe(n){return new ze(3014,!1)}()),a}}class lw{constructor(t,e,r,i){this._driver=t,this.element=e,this.startTime=r,this._elementTimelineStylesLookup=i,this.duration=0,this.easing=null,this._previousKeyframe=new Map,this._currentKeyframe=new Map,this._keyframes=new Map,this._styleSummary=new Map,this._localTimelineStyles=new Map,this._pendingStyles=new Map,this._backFill=new Map,this._currentEmptyStepKeyframe=null,this._elementTimelineStylesLookup||(this._elementTimelineStylesLookup=new Map),this._globalTimelineStyles=this._elementTimelineStylesLookup.get(e),this._globalTimelineStyles||(this._globalTimelineStyles=this._localTimelineStyles,this._elementTimelineStylesLookup.set(e,this._localTimelineStyles)),this._loadKeyframe()}containsAnimation(){switch(this._keyframes.size){case 0:return!1;case 1:return this.hasCurrentStyleProperties();default:return!0}}hasCurrentStyleProperties(){return this._currentKeyframe.size>0}get currentTime(){return this.startTime+this.duration}delayNextStep(t){const e=1===this._keyframes.size&&this._pendingStyles.size;this.duration||e?(this.forwardTime(this.currentTime+t),e&&this.snapshotCurrentStyles()):this.startTime+=t}fork(t,e){return this.applyStylesToKeyframe(),new lw(this._driver,t,e||this.currentTime,this._elementTimelineStylesLookup)}_loadKeyframe(){this._currentKeyframe&&(this._previousKeyframe=this._currentKeyframe),this._currentKeyframe=this._keyframes.get(this.duration),this._currentKeyframe||(this._currentKeyframe=new Map,this._keyframes.set(this.duration,this._currentKeyframe))}forwardFrame(){this.duration+=1,this._loadKeyframe()}forwardTime(t){this.applyStylesToKeyframe(),this.duration=t,this._loadKeyframe()}_updateStyle(t,e){this._localTimelineStyles.set(t,e),this._globalTimelineStyles.set(t,e),this._styleSummary.set(t,{time:this.currentTime,value:e})}allowOnlyTimelineStyles(){return this._currentEmptyStepKeyframe!==this._currentKeyframe}applyEmptyStep(t){t&&this._previousKeyframe.set("easing",t);for(let[e,r]of this._globalTimelineStyles)this._backFill.set(e,r||Ml),this._currentKeyframe.set(e,Ml);this._currentEmptyStepKeyframe=this._currentKeyframe}setStyles(t,e,r,i){e&&this._previousKeyframe.set("easing",e);const o=i&&i.params||{},s=function m$e(n,t){const e=new Map;let r;return n.forEach(i=>{if("*"===i){r=r||t.keys();for(let o of r)e.set(o,Ml)}else qc(i,e)}),e}(t,this._globalTimelineStyles);for(let[a,c]of s){const u=mb(c,o,r);this._pendingStyles.set(a,u),this._localTimelineStyles.has(a)||this._backFill.set(a,this._globalTimelineStyles.get(a)??Ml),this._updateStyle(a,u)}}applyStylesToKeyframe(){0!=this._pendingStyles.size&&(this._pendingStyles.forEach((t,e)=>{this._currentKeyframe.set(e,t)}),this._pendingStyles.clear(),this._localTimelineStyles.forEach((t,e)=>{this._currentKeyframe.has(e)||this._currentKeyframe.set(e,t)}))}snapshotCurrentStyles(){for(let[t,e]of this._localTimelineStyles)this._pendingStyles.set(t,e),this._updateStyle(t,e)}getFinalKeyframe(){return this._keyframes.get(this.duration)}get properties(){const t=[];for(let e in this._currentKeyframe)t.push(e);return t}mergeTimelineCollectedStyles(t){t._styleSummary.forEach((e,r)=>{const i=this._styleSummary.get(r);(!i||e.time>i.time)&&this._updateStyle(r,e.value)})}buildKeyframes(){this.applyStylesToKeyframe();const t=new Set,e=new Set,r=1===this._keyframes.size&&0===this.duration;let i=[];this._keyframes.forEach((a,c)=>{const u=qc(a,new Map,this._backFill);u.forEach((p,m)=>{p===EA?t.add(m):p===Ml&&e.add(m)}),r||u.set("offset",c/this.duration),i.push(u)});const o=t.size?nw(t.values()):[],s=e.size?nw(e.values()):[];if(r){const a=i[0],c=new Map(a);a.set("offset",0),c.set("offset",1),i=[a,c]}return h2(this.element,i,o,s,this.duration,this.startTime,this.easing,!1)}}class f$e extends lw{constructor(t,e,r,i,o,s,a=!1){super(t,e,s.delay),this.keyframes=r,this.preStyleProps=i,this.postStyleProps=o,this._stretchStartingKeyframe=a,this.timings={duration:s.duration,delay:s.delay,easing:s.easing}}containsAnimation(){return this.keyframes.length>1}buildKeyframes(){let t=this.keyframes,{delay:e,duration:r,easing:i}=this.timings;if(this._stretchStartingKeyframe&&e){const o=[],s=r+e,a=e/s,c=qc(t[0]);c.set("offset",0),o.push(c);const u=qc(t[0]);u.set("offset",gW(a)),o.push(u);const p=t.length-1;for(let m=1;m<=p;m++){let g=qc(t[m]);const _=g.get("offset");g.set("offset",gW((e+_*r)/s)),o.push(g)}r=s,e=0,i="",t=o}return h2(this.element,t,this.preStyleProps,this.postStyleProps,r,e,i,!0)}}function gW(n,t=3){const e=Math.pow(10,t-1);return Math.round(n*e)/e}class m2{}const g$e=new Set(["width","height","minWidth","minHeight","maxWidth","maxHeight","left","top","bottom","right","fontSize","outlineWidth","outlineOffset","paddingTop","paddingLeft","paddingBottom","paddingRight","marginTop","marginLeft","marginBottom","marginRight","borderRadius","borderWidth","borderTopWidth","borderLeftWidth","borderRightWidth","borderBottomWidth","textIndent","perspective"]);class b$e extends m2{normalizePropertyName(t,e){return c2(t)}normalizeStyleValue(t,e,r,i){let o="";const s=r.toString().trim();if(g$e.has(e)&&0!==r&&"0"!==r)if("number"==typeof r)o="px";else{const a=r.match(/^[+-]?[\d\.]+([a-z]*)$/);a&&0==a[1].length&&i.push(function dPe(n,t){return new ze(3005,!1)}())}return s+o}}function bW(n,t,e,r,i,o,s,a,c,u,p,m,g){return{type:0,element:n,triggerName:t,isRemovalTransition:i,fromState:e,fromStyles:o,toState:r,toStyles:s,timelines:a,queriedElements:c,preStyleProps:u,postStyleProps:p,totalTime:m,errors:g}}const g2={};class yW{constructor(t,e,r){this._triggerName=t,this.ast=e,this._stateStyles=r}match(t,e,r,i){return function y$e(n,t,e,r,i){return n.some(o=>o(t,e,r,i))}(this.ast.matchers,t,e,r,i)}buildStyles(t,e,r){let i=this._stateStyles.get("*");return void 0!==t&&(i=this._stateStyles.get(t?.toString())||i),i?i.buildStyles(e,r):new Map}build(t,e,r,i,o,s,a,c,u,p){const m=[],g=this.ast.options&&this.ast.options.params||g2,x=this.buildStyles(r,a&&a.params||g2,m),T=c&&c.params||g2,I=this.buildStyles(i,T,m),N=new Set,R=new Map,L=new Map,V="void"===i,j={params:_$e(T,g),delay:this.ast.options?.delay},Y=p?[]:p2(t,e,this.ast.animation,o,s,x,I,j,u,m);let ee=0;if(Y.forEach(ce=>{ee=Math.max(ce.duration+ce.delay,ee)}),m.length)return bW(e,this._triggerName,r,i,V,x,I,[],[],R,L,ee,m);Y.forEach(ce=>{const he=ce.element,we=_s(R,he,new Set);ce.preStyleProps.forEach(Ae=>we.add(Ae));const Ee=_s(L,he,new Set);ce.postStyleProps.forEach(Ae=>Ee.add(Ae)),he!==e&&N.add(he)});const ie=nw(N.values());return bW(e,this._triggerName,r,i,V,x,I,Y,ie,R,L,ee)}}function _$e(n,t){const e=pb(t);for(const r in n)n.hasOwnProperty(r)&&null!=n[r]&&(e[r]=n[r]);return e}class v$e{constructor(t,e,r){this.styles=t,this.defaultParams=e,this.normalizer=r}buildStyles(t,e){const r=new Map,i=pb(this.defaultParams);return Object.keys(t).forEach(o=>{const s=t[o];null!==s&&(i[o]=s)}),this.styles.styles.forEach(o=>{"string"!=typeof o&&o.forEach((s,a)=>{s&&(s=mb(s,i,e));const c=this.normalizer.normalizePropertyName(a,e);s=this.normalizer.normalizeStyleValue(a,c,s,e),r.set(a,s)})}),r}}class w$e{constructor(t,e,r){this.name=t,this.ast=e,this._normalizer=r,this.transitionFactories=[],this.states=new Map,e.states.forEach(i=>{this.states.set(i.name,new v$e(i.style,i.options&&i.options.params||{},r))}),_W(this.states,"true","1"),_W(this.states,"false","0"),e.transitions.forEach(i=>{this.transitionFactories.push(new yW(t,i,this.states))}),this.fallbackTransition=function T$e(n,t,e){return new yW(n,{type:1,animation:{type:2,steps:[],options:null},matchers:[(s,a)=>!0],options:null,queryCount:0,depCount:0},t)}(t,this.states)}get containsQueries(){return this.ast.queryCount>0}matchTransition(t,e,r,i){return this.transitionFactories.find(s=>s.match(t,e,r,i))||null}matchStyles(t,e,r){return this.fallbackTransition.buildStyles(t,e,r)}}function _W(n,t,e){n.has(t)?n.has(e)||n.set(e,n.get(t)):n.has(e)&&n.set(t,n.get(e))}const S$e=new sw;class C$e{constructor(t,e,r){this.bodyNode=t,this._driver=e,this._normalizer=r,this._animations=new Map,this._playersById=new Map,this.players=[]}register(t,e){const r=[],o=u2(this._driver,e,r,[]);if(r.length)throw function kPe(n){return new ze(3503,!1)}();this._animations.set(t,o)}_buildPlayer(t,e,r){const i=t.element,o=tW(0,this._normalizer,0,t.keyframes,e,r);return this._driver.animate(i,o,t.duration,t.delay,t.easing,[],!0)}create(t,e,r={}){const i=[],o=this._animations.get(t);let s;const a=new Map;if(o?(s=p2(this._driver,e,o,o2,Qx,new Map,new Map,r,S$e,i),s.forEach(p=>{const m=_s(a,p.element,new Map);p.postStyleProps.forEach(g=>m.set(g,null))})):(i.push(function APe(){return new ze(3300,!1)}()),s=[]),i.length)throw function NPe(n){return new ze(3504,!1)}();a.forEach((p,m)=>{p.forEach((g,_)=>{p.set(_,this._driver.computeStyle(m,_,Ml))})});const u=Wc(s.map(p=>{const m=a.get(p.element);return this._buildPlayer(p,new Map,m)}));return this._playersById.set(t,u),u.onDestroy(()=>this.destroy(t)),this.players.push(u),u}destroy(t){const e=this._getPlayer(t);e.destroy(),this._playersById.delete(t);const r=this.players.indexOf(e);r>=0&&this.players.splice(r,1)}_getPlayer(t){const e=this._playersById.get(t);if(!e)throw function OPe(n){return new ze(3301,!1)}();return e}listen(t,e,r,i){const o=t2(e,"","","");return JA(this._getPlayer(t),r,o,i),()=>{}}command(t,e,r,i){if("register"==r)return void this.register(t,i[0]);if("create"==r)return void this.create(t,e,i[0]||{});const o=this._getPlayer(t);switch(r){case"play":o.play();break;case"pause":o.pause();break;case"reset":o.reset();break;case"restart":o.restart();break;case"finish":o.finish();break;case"init":o.init();break;case"setPosition":o.setPosition(parseFloat(i[0]));break;case"destroy":this.destroy(t)}}}const vW="ng-animate-queued",b2="ng-animate-disabled",A$e=[],xW={namespaceId:"",setForRemoval:!1,setForMove:!1,hasAnimation:!1,removedBeforeQueried:!1},N$e={namespaceId:"",setForMove:!1,setForRemoval:!1,hasAnimation:!1,removedBeforeQueried:!0},Hs="__ng_removed";class y2{get params(){return this.options.params}constructor(t,e=""){this.namespaceId=e;const r=t&&t.hasOwnProperty("value");if(this.value=function F$e(n){return n??null}(r?t.value:t),r){const o=pb(t);delete o.value,this.options=o}else this.options={};this.options.params||(this.options.params={})}absorbOptions(t){const e=t.params;if(e){const r=this.options.params;Object.keys(e).forEach(i=>{null==r[i]&&(r[i]=e[i])})}}}const gb="void",_2=new y2(gb);class O$e{constructor(t,e,r){this.id=t,this.hostElement=e,this._engine=r,this.players=[],this._triggers=new Map,this._queue=[],this._elementListeners=new Map,this._hostClassName="ng-tns-"+t,Ws(e,this._hostClassName)}listen(t,e,r,i){if(!this._triggers.has(e))throw function RPe(n,t){return new ze(3302,!1)}();if(null==r||0==r.length)throw function MPe(n){return new ze(3303,!1)}();if(!function P$e(n){return"start"==n||"done"==n}(r))throw function FPe(n,t){return new ze(3400,!1)}();const o=_s(this._elementListeners,t,[]),s={name:e,phase:r,callback:i};o.push(s);const a=_s(this._engine.statesByElement,t,new Map);return a.has(e)||(Ws(t,Jx),Ws(t,Jx+"-"+e),a.set(e,_2)),()=>{this._engine.afterFlush(()=>{const c=o.indexOf(s);c>=0&&o.splice(c,1),this._triggers.has(e)||a.delete(e)})}}register(t,e){return!this._triggers.has(t)&&(this._triggers.set(t,e),!0)}_getTrigger(t){const e=this._triggers.get(t);if(!e)throw function PPe(n){return new ze(3401,!1)}();return e}trigger(t,e,r,i=!0){const o=this._getTrigger(e),s=new v2(this.id,e,t);let a=this._engine.statesByElement.get(t);a||(Ws(t,Jx),Ws(t,Jx+"-"+e),this._engine.statesByElement.set(t,a=new Map));let c=a.get(e);const u=new y2(r,this.id);if(!(r&&r.hasOwnProperty("value"))&&c&&u.absorbOptions(c.options),a.set(e,u),c||(c=_2),u.value!==gb&&c.value===u.value){if(!function B$e(n,t){const e=Object.keys(n),r=Object.keys(t);if(e.length!=r.length)return!1;for(let i=0;i<e.length;i++){const o=e[i];if(!t.hasOwnProperty(o)||n[o]!==t[o])return!1}return!0}(c.params,u.params)){const T=[],I=o.matchStyles(c.value,c.params,T),N=o.matchStyles(u.value,u.params,T);T.length?this._engine.reportError(T):this._engine.afterFlush(()=>{ad(t,I),Za(t,N)})}return}const g=_s(this._engine.playersByElement,t,[]);g.forEach(T=>{T.namespaceId==this.id&&T.triggerName==e&&T.queued&&T.destroy()});let _=o.matchTransition(c.value,u.value,t,u.params),x=!1;if(!_){if(!i)return;_=o.fallbackTransition,x=!0}return this._engine.totalQueuedPlayers++,this._queue.push({element:t,triggerName:e,transition:_,fromState:c,toState:u,player:s,isFallbackTransition:x}),x||(Ws(t,vW),s.onStart(()=>{vp(t,vW)})),s.onDone(()=>{let T=this.players.indexOf(s);T>=0&&this.players.splice(T,1);const I=this._engine.playersByElement.get(t);if(I){let N=I.indexOf(s);N>=0&&I.splice(N,1)}}),this.players.push(s),g.push(s),s}deregister(t){this._triggers.delete(t),this._engine.statesByElement.forEach(e=>e.delete(t)),this._elementListeners.forEach((e,r)=>{this._elementListeners.set(r,e.filter(i=>i.name!=t))})}clearElementCache(t){this._engine.statesByElement.delete(t),this._elementListeners.delete(t);const e=this._engine.playersByElement.get(t);e&&(e.forEach(r=>r.destroy()),this._engine.playersByElement.delete(t))}_signalRemovalForInnerTriggers(t,e){const r=this._engine.driver.query(t,ew,!0);r.forEach(i=>{if(i[Hs])return;const o=this._engine.fetchNamespacesByElement(i);o.size?o.forEach(s=>s.triggerLeaveAnimation(i,e,!1,!0)):this.clearElementCache(i)}),this._engine.afterFlushAnimationsDone(()=>r.forEach(i=>this.clearElementCache(i)))}triggerLeaveAnimation(t,e,r,i){const o=this._engine.statesByElement.get(t),s=new Map;if(o){const a=[];if(o.forEach((c,u)=>{if(s.set(u,c.value),this._triggers.has(u)){const p=this.trigger(t,u,gb,i);p&&a.push(p)}}),a.length)return this._engine.markElementAsRemoved(this.id,t,!0,e,s),r&&Wc(a).onDone(()=>this._engine.processLeaveNode(t)),!0}return!1}prepareLeaveAnimationListeners(t){const e=this._elementListeners.get(t),r=this._engine.statesByElement.get(t);if(e&&r){const i=new Set;e.forEach(o=>{const s=o.name;if(i.has(s))return;i.add(s);const c=this._triggers.get(s).fallbackTransition,u=r.get(s)||_2,p=new y2(gb),m=new v2(this.id,s,t);this._engine.totalQueuedPlayers++,this._queue.push({element:t,triggerName:s,transition:c,fromState:u,toState:p,player:m,isFallbackTransition:!0})})}}removeNode(t,e){const r=this._engine;if(t.childElementCount&&this._signalRemovalForInnerTriggers(t,e),this.triggerLeaveAnimation(t,e,!0))return;let i=!1;if(r.totalAnimations){const o=r.players.length?r.playersByQueriedElement.get(t):[];if(o&&o.length)i=!0;else{let s=t;for(;s=s.parentNode;)if(r.statesByElement.get(s)){i=!0;break}}}if(this.prepareLeaveAnimationListeners(t),i)r.markElementAsRemoved(this.id,t,!1,e);else{const o=t[Hs];(!o||o===xW)&&(r.afterFlush(()=>this.clearElementCache(t)),r.destroyInnerAnimations(t),r._onRemovalComplete(t,e))}}insertNode(t,e){Ws(t,this._hostClassName)}drainQueuedTransitions(t){const e=[];return this._queue.forEach(r=>{const i=r.player;if(i.destroyed)return;const o=r.element,s=this._elementListeners.get(o);s&&s.forEach(a=>{if(a.name==r.triggerName){const c=t2(o,r.triggerName,r.fromState.value,r.toState.value);c._data=t,JA(r.player,a.phase,c,a.callback)}}),i.markedForDestroy?this._engine.afterFlush(()=>{i.destroy()}):e.push(r)}),this._queue=[],e.sort((r,i)=>{const o=r.transition.ast.depCount,s=i.transition.ast.depCount;return 0==o||0==s?o-s:this._engine.driver.containsElement(r.element,i.element)?1:-1})}destroy(t){this.players.forEach(e=>e.destroy()),this._signalRemovalForInnerTriggers(this.hostElement,t)}elementContainsData(t){let e=!1;return this._elementListeners.has(t)&&(e=!0),e=!!this._queue.find(r=>r.element===t)||e,e}}class R$e{_onRemovalComplete(t,e){this.onRemovalComplete(t,e)}constructor(t,e,r){this.bodyNode=t,this.driver=e,this._normalizer=r,this.players=[],this.newHostElements=new Map,this.playersByElement=new Map,this.playersByQueriedElement=new Map,this.statesByElement=new Map,this.disabledNodes=new Set,this.totalAnimations=0,this.totalQueuedPlayers=0,this._namespaceLookup={},this._namespaceList=[],this._flushFns=[],this._whenQuietFns=[],this.namespacesByHostElement=new Map,this.collectedEnterElements=[],this.collectedLeaveElements=[],this.onRemovalComplete=(i,o)=>{}}get queuedPlayers(){const t=[];return this._namespaceList.forEach(e=>{e.players.forEach(r=>{r.queued&&t.push(r)})}),t}createNamespace(t,e){const r=new O$e(t,e,this);return this.bodyNode&&this.driver.containsElement(this.bodyNode,e)?this._balanceNamespaceList(r,e):(this.newHostElements.set(e,r),this.collectEnterElement(e)),this._namespaceLookup[t]=r}_balanceNamespaceList(t,e){const r=this._namespaceList,i=this.namespacesByHostElement;if(r.length-1>=0){let s=!1,a=this.driver.getParentElement(e);for(;a;){const c=i.get(a);if(c){const u=r.indexOf(c);r.splice(u+1,0,t),s=!0;break}a=this.driver.getParentElement(a)}s||r.unshift(t)}else r.push(t);return i.set(e,t),t}register(t,e){let r=this._namespaceLookup[t];return r||(r=this.createNamespace(t,e)),r}registerTrigger(t,e,r){let i=this._namespaceLookup[t];i&&i.register(e,r)&&this.totalAnimations++}destroy(t,e){if(!t)return;const r=this._fetchNamespace(t);this.afterFlush(()=>{this.namespacesByHostElement.delete(r.hostElement),delete this._namespaceLookup[t];const i=this._namespaceList.indexOf(r);i>=0&&this._namespaceList.splice(i,1)}),this.afterFlushAnimationsDone(()=>r.destroy(e))}_fetchNamespace(t){return this._namespaceLookup[t]}fetchNamespacesByElement(t){const e=new Set,r=this.statesByElement.get(t);if(r)for(let i of r.values())if(i.namespaceId){const o=this._fetchNamespace(i.namespaceId);o&&e.add(o)}return e}trigger(t,e,r,i){if(cw(e)){const o=this._fetchNamespace(t);if(o)return o.trigger(e,r,i),!0}return!1}insertNode(t,e,r,i){if(!cw(e))return;const o=e[Hs];if(o&&o.setForRemoval){o.setForRemoval=!1,o.setForMove=!0;const s=this.collectedLeaveElements.indexOf(e);s>=0&&this.collectedLeaveElements.splice(s,1)}if(t){const s=this._fetchNamespace(t);s&&s.insertNode(e,r)}i&&this.collectEnterElement(e)}collectEnterElement(t){this.collectedEnterElements.push(t)}markElementAsDisabled(t,e){e?this.disabledNodes.has(t)||(this.disabledNodes.add(t),Ws(t,b2)):this.disabledNodes.has(t)&&(this.disabledNodes.delete(t),vp(t,b2))}removeNode(t,e,r,i){if(cw(e)){const o=t?this._fetchNamespace(t):null;if(o?o.removeNode(e,i):this.markElementAsRemoved(t,e,!1,i),r){const s=this.namespacesByHostElement.get(e);s&&s.id!==t&&s.removeNode(e,i)}}else this._onRemovalComplete(e,i)}markElementAsRemoved(t,e,r,i,o){this.collectedLeaveElements.push(e),e[Hs]={namespaceId:t,setForRemoval:i,hasAnimation:r,removedBeforeQueried:!1,previousTriggersValues:o}}listen(t,e,r,i,o){return cw(e)?this._fetchNamespace(t).listen(e,r,i,o):()=>{}}_buildInstruction(t,e,r,i,o){return t.transition.build(this.driver,t.element,t.fromState.value,t.toState.value,r,i,t.fromState.options,t.toState.options,e,o)}destroyInnerAnimations(t){let e=this.driver.query(t,ew,!0);e.forEach(r=>this.destroyActiveAnimationsForElement(r)),0!=this.playersByQueriedElement.size&&(e=this.driver.query(t,s2,!0),e.forEach(r=>this.finishActiveQueriedAnimationOnElement(r)))}destroyActiveAnimationsForElement(t){const e=this.playersByElement.get(t);e&&e.forEach(r=>{r.queued?r.markedForDestroy=!0:r.destroy()})}finishActiveQueriedAnimationOnElement(t){const e=this.playersByQueriedElement.get(t);e&&e.forEach(r=>r.finish())}whenRenderingDone(){return new Promise(t=>{if(this.players.length)return Wc(this.players).onDone(()=>t());t()})}processLeaveNode(t){const e=t[Hs];if(e&&e.setForRemoval){if(t[Hs]=xW,e.namespaceId){this.destroyInnerAnimations(t);const r=this._fetchNamespace(e.namespaceId);r&&r.clearElementCache(t)}this._onRemovalComplete(t,e.setForRemoval)}t.classList?.contains(b2)&&this.markElementAsDisabled(t,!1),this.driver.query(t,".ng-animate-disabled",!0).forEach(r=>{this.markElementAsDisabled(r,!1)})}flush(t=-1){let e=[];if(this.newHostElements.size&&(this.newHostElements.forEach((r,i)=>this._balanceNamespaceList(r,i)),this.newHostElements.clear()),this.totalAnimations&&this.collectedEnterElements.length)for(let r=0;r<this.collectedEnterElements.length;r++)Ws(this.collectedEnterElements[r],"ng-star-inserted");if(this._namespaceList.length&&(this.totalQueuedPlayers||this.collectedLeaveElements.length)){const r=[];try{e=this._flushAnimations(r,t)}finally{for(let i=0;i<r.length;i++)r[i]()}}else for(let r=0;r<this.collectedLeaveElements.length;r++)this.processLeaveNode(this.collectedLeaveElements[r]);if(this.totalQueuedPlayers=0,this.collectedEnterElements.length=0,this.collectedLeaveElements.length=0,this._flushFns.forEach(r=>r()),this._flushFns=[],this._whenQuietFns.length){const r=this._whenQuietFns;this._whenQuietFns=[],e.length?Wc(e).onDone(()=>{r.forEach(i=>i())}):r.forEach(i=>i())}}reportError(t){throw function $Pe(n){return new ze(3402,!1)}()}_flushAnimations(t,e){const r=new sw,i=[],o=new Map,s=[],a=new Map,c=new Map,u=new Map,p=new Set;this.disabledNodes.forEach(_e=>{p.add(_e);const Te=this.driver.query(_e,".ng-animate-queued",!0);for(let xe=0;xe<Te.length;xe++)p.add(Te[xe])});const m=this.bodyNode,g=Array.from(this.statesByElement.keys()),_=SW(g,this.collectedEnterElements),x=new Map;let T=0;_.forEach((_e,Te)=>{const xe=o2+T++;x.set(Te,xe),_e.forEach(De=>Ws(De,xe))});const I=[],N=new Set,R=new Set;for(let _e=0;_e<this.collectedLeaveElements.length;_e++){const Te=this.collectedLeaveElements[_e],xe=Te[Hs];xe&&xe.setForRemoval&&(I.push(Te),N.add(Te),xe.hasAnimation?this.driver.query(Te,".ng-star-inserted",!0).forEach(De=>N.add(De)):R.add(Te))}const L=new Map,V=SW(g,Array.from(N));V.forEach((_e,Te)=>{const xe=Qx+T++;L.set(Te,xe),_e.forEach(De=>Ws(De,xe))}),t.push(()=>{_.forEach((_e,Te)=>{const xe=x.get(Te);_e.forEach(De=>vp(De,xe))}),V.forEach((_e,Te)=>{const xe=L.get(Te);_e.forEach(De=>vp(De,xe))}),I.forEach(_e=>{this.processLeaveNode(_e)})});const j=[],Y=[];for(let _e=this._namespaceList.length-1;_e>=0;_e--)this._namespaceList[_e].drainQueuedTransitions(e).forEach(xe=>{const De=xe.player,je=xe.element;if(j.push(De),this.collectedEnterElements.length){const pt=je[Hs];if(pt&&pt.setForMove){if(pt.previousTriggersValues&&pt.previousTriggersValues.has(xe.triggerName)){const Ot=pt.previousTriggersValues.get(xe.triggerName),Tt=this.statesByElement.get(xe.element);if(Tt&&Tt.has(xe.triggerName)){const Wt=Tt.get(xe.triggerName);Wt.value=Ot,Tt.set(xe.triggerName,Wt)}}return void De.destroy()}}const We=!m||!this.driver.containsElement(m,je),Je=L.get(je),Ze=x.get(je),et=this._buildInstruction(xe,r,Ze,Je,We);if(et.errors&&et.errors.length)return void Y.push(et);if(We)return De.onStart(()=>ad(je,et.fromStyles)),De.onDestroy(()=>Za(je,et.toStyles)),void i.push(De);if(xe.isFallbackTransition)return De.onStart(()=>ad(je,et.fromStyles)),De.onDestroy(()=>Za(je,et.toStyles)),void i.push(De);const rt=[];et.timelines.forEach(pt=>{pt.stretchStartingKeyframe=!0,this.disabledNodes.has(pt.element)||rt.push(pt)}),et.timelines=rt,r.append(je,et.timelines),s.push({instruction:et,player:De,element:je}),et.queriedElements.forEach(pt=>_s(a,pt,[]).push(De)),et.preStyleProps.forEach((pt,Ot)=>{if(pt.size){let Tt=c.get(Ot);Tt||c.set(Ot,Tt=new Set),pt.forEach((Wt,Zt)=>Tt.add(Zt))}}),et.postStyleProps.forEach((pt,Ot)=>{let Tt=u.get(Ot);Tt||u.set(Ot,Tt=new Set),pt.forEach((Wt,Zt)=>Tt.add(Zt))})});if(Y.length){const _e=[];Y.forEach(Te=>{_e.push(function LPe(n,t){return new ze(3505,!1)}())}),j.forEach(Te=>Te.destroy()),this.reportError(_e)}const ee=new Map,ie=new Map;s.forEach(_e=>{const Te=_e.element;r.has(Te)&&(ie.set(Te,Te),this._beforeAnimationBuild(_e.player.namespaceId,_e.instruction,ee))}),i.forEach(_e=>{const Te=_e.element;this._getPreviousPlayers(Te,!1,_e.namespaceId,_e.triggerName,null).forEach(De=>{_s(ee,Te,[]).push(De),De.destroy()})});const ce=I.filter(_e=>IW(_e,c,u)),he=new Map;TW(he,this.driver,R,u,Ml).forEach(_e=>{IW(_e,c,u)&&ce.push(_e)});const Ee=new Map;_.forEach((_e,Te)=>{TW(Ee,this.driver,new Set(_e),c,EA)}),ce.forEach(_e=>{const Te=he.get(_e),xe=Ee.get(_e);he.set(_e,new Map([...Array.from(Te?.entries()??[]),...Array.from(xe?.entries()??[])]))});const Ae=[],Oe=[],Re={};s.forEach(_e=>{const{element:Te,player:xe,instruction:De}=_e;if(r.has(Te)){if(p.has(Te))return xe.onDestroy(()=>Za(Te,De.toStyles)),xe.disabled=!0,xe.overrideTotalTime(De.totalTime),void i.push(xe);let je=Re;if(ie.size>1){let Je=Te;const Ze=[];for(;Je=Je.parentNode;){const et=ie.get(Je);if(et){je=et;break}Ze.push(Je)}Ze.forEach(et=>ie.set(et,je))}const We=this._buildAnimation(xe.namespaceId,De,ee,o,Ee,he);if(xe.setRealPlayer(We),je===Re)Ae.push(xe);else{const Je=this.playersByElement.get(je);Je&&Je.length&&(xe.parentPlayer=Wc(Je)),i.push(xe)}}else ad(Te,De.fromStyles),xe.onDestroy(()=>Za(Te,De.toStyles)),Oe.push(xe),p.has(Te)&&i.push(xe)}),Oe.forEach(_e=>{const Te=o.get(_e.element);if(Te&&Te.length){const xe=Wc(Te);_e.setRealPlayer(xe)}}),i.forEach(_e=>{_e.parentPlayer?_e.syncPlayerEvents(_e.parentPlayer):_e.destroy()});for(let _e=0;_e<I.length;_e++){const Te=I[_e],xe=Te[Hs];if(vp(Te,Qx),xe&&xe.hasAnimation)continue;let De=[];if(a.size){let We=a.get(Te);We&&We.length&&De.push(...We);let Je=this.driver.query(Te,s2,!0);for(let Ze=0;Ze<Je.length;Ze++){let et=a.get(Je[Ze]);et&&et.length&&De.push(...et)}}const je=De.filter(We=>!We.destroyed);je.length?$$e(this,Te,je):this.processLeaveNode(Te)}return I.length=0,Ae.forEach(_e=>{this.players.push(_e),_e.onDone(()=>{_e.destroy();const Te=this.players.indexOf(_e);this.players.splice(Te,1)}),_e.play()}),Ae}elementContainsData(t,e){let r=!1;const i=e[Hs];return i&&i.setForRemoval&&(r=!0),this.playersByElement.has(e)&&(r=!0),this.playersByQueriedElement.has(e)&&(r=!0),this.statesByElement.has(e)&&(r=!0),this._fetchNamespace(t).elementContainsData(e)||r}afterFlush(t){this._flushFns.push(t)}afterFlushAnimationsDone(t){this._whenQuietFns.push(t)}_getPreviousPlayers(t,e,r,i,o){let s=[];if(e){const a=this.playersByQueriedElement.get(t);a&&(s=a)}else{const a=this.playersByElement.get(t);if(a){const c=!o||o==gb;a.forEach(u=>{u.queued||!c&&u.triggerName!=i||s.push(u)})}}return(r||i)&&(s=s.filter(a=>!(r&&r!=a.namespaceId||i&&i!=a.triggerName))),s}_beforeAnimationBuild(t,e,r){const o=e.element,s=e.isRemovalTransition?void 0:t,a=e.isRemovalTransition?void 0:e.triggerName;for(const c of e.timelines){const u=c.element,p=u!==o,m=_s(r,u,[]);this._getPreviousPlayers(u,p,s,a,e.toState).forEach(_=>{const x=_.getRealPlayer();x.beforeDestroy&&x.beforeDestroy(),_.destroy(),m.push(_)})}ad(o,e.fromStyles)}_buildAnimation(t,e,r,i,o,s){const a=e.triggerName,c=e.element,u=[],p=new Set,m=new Set,g=e.timelines.map(x=>{const T=x.element;p.add(T);const I=T[Hs];if(I&&I.removedBeforeQueried)return new ab(x.duration,x.delay);const N=T!==c,R=function L$e(n){const t=[];return CW(n,t),t}((r.get(T)||A$e).map(ee=>ee.getRealPlayer())).filter(ee=>!!ee.element&&ee.element===T),L=o.get(T),V=s.get(T),j=tW(0,this._normalizer,0,x.keyframes,L,V),Y=this._buildPlayer(x,j,R);if(x.subTimeline&&i&&m.add(T),N){const ee=new v2(t,a,T);ee.setRealPlayer(Y),u.push(ee)}return Y});u.forEach(x=>{_s(this.playersByQueriedElement,x.element,[]).push(x),x.onDone(()=>function M$e(n,t,e){let r=n.get(t);if(r){if(r.length){const i=r.indexOf(e);r.splice(i,1)}0==r.length&&n.delete(t)}return r}(this.playersByQueriedElement,x.element,x))}),p.forEach(x=>Ws(x,lW));const _=Wc(g);return _.onDestroy(()=>{p.forEach(x=>vp(x,lW)),Za(c,e.toStyles)}),m.forEach(x=>{_s(i,x,[]).push(_)}),_}_buildPlayer(t,e,r){return e.length>0?this.driver.animate(t.element,e,t.duration,t.delay,t.easing,r):new ab(t.duration,t.delay)}}class v2{constructor(t,e,r){this.namespaceId=t,this.triggerName=e,this.element=r,this._player=new ab,this._containsRealPlayer=!1,this._queuedCallbacks=new Map,this.destroyed=!1,this.parentPlayer=null,this.markedForDestroy=!1,this.disabled=!1,this.queued=!0,this.totalTime=0}setRealPlayer(t){this._containsRealPlayer||(this._player=t,this._queuedCallbacks.forEach((e,r)=>{e.forEach(i=>JA(t,r,void 0,i))}),this._queuedCallbacks.clear(),this._containsRealPlayer=!0,this.overrideTotalTime(t.totalTime),this.queued=!1)}getRealPlayer(){return this._player}overrideTotalTime(t){this.totalTime=t}syncPlayerEvents(t){const e=this._player;e.triggerCallback&&t.onStart(()=>e.triggerCallback("start")),t.onDone(()=>this.finish()),t.onDestroy(()=>this.destroy())}_queueEvent(t,e){_s(this._queuedCallbacks,t,[]).push(e)}onDone(t){this.queued&&this._queueEvent("done",t),this._player.onDone(t)}onStart(t){this.queued&&this._queueEvent("start",t),this._player.onStart(t)}onDestroy(t){this.queued&&this._queueEvent("destroy",t),this._player.onDestroy(t)}init(){this._player.init()}hasStarted(){return!this.queued&&this._player.hasStarted()}play(){!this.queued&&this._player.play()}pause(){!this.queued&&this._player.pause()}restart(){!this.queued&&this._player.restart()}finish(){this._player.finish()}destroy(){this.destroyed=!0,this._player.destroy()}reset(){!this.queued&&this._player.reset()}setPosition(t){this.queued||this._player.setPosition(t)}getPosition(){return this.queued?0:this._player.getPosition()}triggerCallback(t){const e=this._player;e.triggerCallback&&e.triggerCallback(t)}}function cw(n){return n&&1===n.nodeType}function wW(n,t){const e=n.style.display;return n.style.display=t??"none",e}function TW(n,t,e,r,i){const o=[];e.forEach(c=>o.push(wW(c)));const s=[];r.forEach((c,u)=>{const p=new Map;c.forEach(m=>{const g=t.computeStyle(u,m,i);p.set(m,g),(!g||0==g.length)&&(u[Hs]=N$e,s.push(u))}),n.set(u,p)});let a=0;return e.forEach(c=>wW(c,o[a++])),s}function SW(n,t){const e=new Map;if(n.forEach(a=>e.set(a,[])),0==t.length)return e;const r=1,i=new Set(t),o=new Map;function s(a){if(!a)return r;let c=o.get(a);if(c)return c;const u=a.parentNode;return c=e.has(u)?u:i.has(u)?r:s(u),o.set(a,c),c}return t.forEach(a=>{const c=s(a);c!==r&&e.get(c).push(a)}),e}function Ws(n,t){n.classList?.add(t)}function vp(n,t){n.classList?.remove(t)}function $$e(n,t,e){Wc(e).onDone(()=>n.processLeaveNode(t))}function CW(n,t){for(let e=0;e<n.length;e++){const r=n[e];r instanceof C6?CW(r.players,t):t.push(r)}}function IW(n,t,e){const r=e.get(n);if(!r)return!1;let i=t.get(n);return i?r.forEach(o=>i.add(o)):t.set(n,r),e.delete(n),!0}class uw{constructor(t,e,r){this.bodyNode=t,this._driver=e,this._normalizer=r,this._triggerCache={},this.onRemovalComplete=(i,o)=>{},this._transitionEngine=new R$e(t,e,r),this._timelineEngine=new C$e(t,e,r),this._transitionEngine.onRemovalComplete=(i,o)=>this.onRemovalComplete(i,o)}registerTrigger(t,e,r,i,o){const s=t+"-"+i;let a=this._triggerCache[s];if(!a){const c=[],p=u2(this._driver,o,c,[]);if(c.length)throw function EPe(n,t){return new ze(3404,!1)}();a=function x$e(n,t,e){return new w$e(n,t,e)}(i,p,this._normalizer),this._triggerCache[s]=a}this._transitionEngine.registerTrigger(e,i,a)}register(t,e){this._transitionEngine.register(t,e)}destroy(t,e){this._transitionEngine.destroy(t,e)}onInsert(t,e,r,i){this._transitionEngine.insertNode(t,e,r,i)}onRemove(t,e,r,i){this._transitionEngine.removeNode(t,e,i||!1,r)}disableAnimations(t,e){this._transitionEngine.markElementAsDisabled(t,e)}process(t,e,r,i){if("@"==r.charAt(0)){const[o,s]=nW(r);this._timelineEngine.command(o,e,s,i)}else this._transitionEngine.trigger(t,e,r,i)}listen(t,e,r,i,o){if("@"==r.charAt(0)){const[s,a]=nW(r);return this._timelineEngine.listen(s,e,a,o)}return this._transitionEngine.listen(t,e,r,i,o)}flush(t=-1){this._transitionEngine.flush(t)}get players(){return this._transitionEngine.players.concat(this._timelineEngine.players)}whenRenderingDone(){return this._transitionEngine.whenRenderingDone()}}let z$e=(()=>{class n{constructor(e,r,i){this._element=e,this._startStyles=r,this._endStyles=i,this._state=0;let o=n.initialStylesByElement.get(e);o||n.initialStylesByElement.set(e,o=new Map),this._initialStyles=o}start(){this._state<1&&(this._startStyles&&Za(this._element,this._startStyles,this._initialStyles),this._state=1)}finish(){this.start(),this._state<2&&(Za(this._element,this._initialStyles),this._endStyles&&(Za(this._element,this._endStyles),this._endStyles=null),this._state=1)}destroy(){this.finish(),this._state<3&&(n.initialStylesByElement.delete(this._element),this._startStyles&&(ad(this._element,this._startStyles),this._endStyles=null),this._endStyles&&(ad(this._element,this._endStyles),this._endStyles=null),Za(this._element,this._initialStyles),this._state=3)}}return n.initialStylesByElement=new WeakMap,n})();function x2(n){let t=null;return n.forEach((e,r)=>{(function U$e(n){return"display"===n||"position"===n})(r)&&(t=t||new Map,t.set(r,e))}),t}class EW{constructor(t,e,r,i){this.element=t,this.keyframes=e,this.options=r,this._specialStyles=i,this._onDoneFns=[],this._onStartFns=[],this._onDestroyFns=[],this._initialized=!1,this._finished=!1,this._started=!1,this._destroyed=!1,this._originalOnDoneFns=[],this._originalOnStartFns=[],this.time=0,this.parentPlayer=null,this.currentSnapshot=new Map,this._duration=r.duration,this._delay=r.delay||0,this.time=this._duration+this._delay}_onFinish(){this._finished||(this._finished=!0,this._onDoneFns.forEach(t=>t()),this._onDoneFns=[])}init(){this._buildPlayer(),this._preparePlayerBeforeStart()}_buildPlayer(){if(this._initialized)return;this._initialized=!0;const t=this.keyframes;this.domPlayer=this._triggerWebAnimation(this.element,t,this.options),this._finalKeyframe=t.length?t[t.length-1]:new Map,this.domPlayer.addEventListener("finish",()=>this._onFinish())}_preparePlayerBeforeStart(){this._delay?this._resetDomPlayerState():this.domPlayer.pause()}_convertKeyframesToObject(t){const e=[];return t.forEach(r=>{e.push(Object.fromEntries(r))}),e}_triggerWebAnimation(t,e,r){return t.animate(this._convertKeyframesToObject(e),r)}onStart(t){this._originalOnStartFns.push(t),this._onStartFns.push(t)}onDone(t){this._originalOnDoneFns.push(t),this._onDoneFns.push(t)}onDestroy(t){this._onDestroyFns.push(t)}play(){this._buildPlayer(),this.hasStarted()||(this._onStartFns.forEach(t=>t()),this._onStartFns=[],this._started=!0,this._specialStyles&&this._specialStyles.start()),this.domPlayer.play()}pause(){this.init(),this.domPlayer.pause()}finish(){this.init(),this._specialStyles&&this._specialStyles.finish(),this._onFinish(),this.domPlayer.finish()}reset(){this._resetDomPlayerState(),this._destroyed=!1,this._finished=!1,this._started=!1,this._onStartFns=this._originalOnStartFns,this._onDoneFns=this._originalOnDoneFns}_resetDomPlayerState(){this.domPlayer&&this.domPlayer.cancel()}restart(){this.reset(),this.play()}hasStarted(){return this._started}destroy(){this._destroyed||(this._destroyed=!0,this._resetDomPlayerState(),this._onFinish(),this._specialStyles&&this._specialStyles.destroy(),this._onDestroyFns.forEach(t=>t()),this._onDestroyFns=[])}setPosition(t){void 0===this.domPlayer&&this.init(),this.domPlayer.currentTime=t*this.time}getPosition(){return this.domPlayer.currentTime/this.time}get totalTime(){return this._delay+this._duration}beforeDestroy(){const t=new Map;this.hasStarted()&&this._finalKeyframe.forEach((r,i)=>{"offset"!==i&&t.set(i,this._finished?r:hW(this.element,i))}),this.currentSnapshot=t}triggerCallback(t){const e="start"===t?this._onStartFns:this._onDoneFns;e.forEach(r=>r()),e.length=0}}class j$e{validateStyleProperty(t){return!0}validateAnimatableStyleProperty(t){return!0}matchesElement(t,e){return!1}containsElement(t,e){return iW(t,e)}getParentElement(t){return n2(t)}query(t,e,r){return oW(t,e,r)}computeStyle(t,e,r){return window.getComputedStyle(t)[e]}animate(t,e,r,i,o,s=[]){const c={duration:r,delay:i,fill:0==i?"both":"forwards"};o&&(c.easing=o);const u=new Map,p=s.filter(_=>_ instanceof EW);(function YPe(n,t){return 0===n||0===t})(r,i)&&p.forEach(_=>{_.currentSnapshot.forEach((x,T)=>u.set(T,x))});let m=function qPe(n){return n.length?n[0]instanceof Map?n:n.map(t=>cW(t)):[]}(e).map(_=>qc(_));m=function ZPe(n,t,e){if(e.size&&t.length){let r=t[0],i=[];if(e.forEach((o,s)=>{r.has(s)||i.push(s),r.set(s,o)}),i.length)for(let o=1;o<t.length;o++){let s=t[o];i.forEach(a=>s.set(a,hW(n,a)))}}return t}(t,m,u);const g=function V$e(n,t){let e=null,r=null;return Array.isArray(t)&&t.length?(e=x2(t[0]),t.length>1&&(r=x2(t[t.length-1]))):t instanceof Map&&(e=x2(t)),e||r?new z$e(n,e,r):null}(t,m);return new EW(t,m,c,g)}}let G$e=(()=>{class n extends _6{constructor(e,r){super(),this._nextAnimationId=0,this._renderer=e.createRenderer(r.body,{id:"0",encapsulation:No.None,styles:[],data:{animation:[]}})}build(e){const r=this._nextAnimationId.toString();this._nextAnimationId++;const i=Array.isArray(e)?x6(e):e;return DW(this._renderer,null,r,"register",[i]),new H$e(r,this._renderer)}}return n.\u0275fac=function(e){return new(e||n)(Fe(uf),Fe(Tn))},n.\u0275prov=at({token:n,factory:n.\u0275fac}),n})();class H$e extends bRe{constructor(t,e){super(),this._id=t,this._renderer=e}create(t,e){return new W$e(this._id,t,e||{},this._renderer)}}class W$e{constructor(t,e,r,i){this.id=t,this.element=e,this._renderer=i,this.parentPlayer=null,this._started=!1,this.totalTime=0,this._command("create",r)}_listen(t,e){return this._renderer.listen(this.element,`@@${this.id}:${t}`,e)}_command(t,...e){return DW(this._renderer,this.element,this.id,t,e)}onDone(t){this._listen("done",t)}onStart(t){this._listen("start",t)}onDestroy(t){this._listen("destroy",t)}init(){this._command("init")}hasStarted(){return this._started}play(){this._command("play"),this._started=!0}pause(){this._command("pause")}restart(){this._command("restart")}finish(){this._command("finish")}destroy(){this._command("destroy")}reset(){this._command("reset"),this._started=!1}setPosition(t){this._command("setPosition",t)}getPosition(){return this._renderer.engine.players[+this.id]?.getPosition()??0}}function DW(n,t,e,r,i){return n.setProperty(t,`@@${e}:${r}`,i)}const kW="@.disabled";let q$e=(()=>{class n{constructor(e,r,i){this.delegate=e,this.engine=r,this._zone=i,this._currentId=0,this._microtaskId=1,this._animationCallbacksBuffer=[],this._rendererCache=new Map,this._cdRecurDepth=0,this.promise=Promise.resolve(0),r.onRemovalComplete=(o,s)=>{const a=s?.parentNode(o);a&&s.removeChild(a,o)}}createRenderer(e,r){const o=this.delegate.createRenderer(e,r);if(!(e&&r&&r.data&&r.data.animation)){let p=this._rendererCache.get(o);return p||(p=new AW("",o,this.engine,()=>this._rendererCache.delete(o)),this._rendererCache.set(o,p)),p}const s=r.id,a=r.id+"-"+this._currentId;this._currentId++,this.engine.register(a,e);const c=p=>{Array.isArray(p)?p.forEach(c):this.engine.registerTrigger(s,a,e,p.name,p)};return r.data.animation.forEach(c),new K$e(this,a,o,this.engine)}begin(){this._cdRecurDepth++,this.delegate.begin&&this.delegate.begin()}_scheduleCountTask(){this.promise.then(()=>{this._microtaskId++})}scheduleListenerCallback(e,r,i){e>=0&&e<this._microtaskId?this._zone.run(()=>r(i)):(0==this._animationCallbacksBuffer.length&&Promise.resolve(null).then(()=>{this._zone.run(()=>{this._animationCallbacksBuffer.forEach(o=>{const[s,a]=o;s(a)}),this._animationCallbacksBuffer=[]})}),this._animationCallbacksBuffer.push([r,i]))}end(){this._cdRecurDepth--,0==this._cdRecurDepth&&this._zone.runOutsideAngular(()=>{this._scheduleCountTask(),this.engine.flush(this._microtaskId)}),this.delegate.end&&this.delegate.end()}whenRenderingDone(){return this.engine.whenRenderingDone()}}return n.\u0275fac=function(e){return new(e||n)(Fe(uf),Fe(uw),Fe(Vt))},n.\u0275prov=at({token:n,factory:n.\u0275fac}),n})();class AW{constructor(t,e,r,i){this.namespaceId=t,this.delegate=e,this.engine=r,this._onDestroy=i,this.destroyNode=this.delegate.destroyNode?o=>e.destroyNode(o):null}get data(){return this.delegate.data}destroy(){this.engine.destroy(this.namespaceId,this.delegate),this.delegate.destroy(),this._onDestroy?.()}createElement(t,e){return this.delegate.createElement(t,e)}createComment(t){return this.delegate.createComment(t)}createText(t){return this.delegate.createText(t)}appendChild(t,e){this.delegate.appendChild(t,e),this.engine.onInsert(this.namespaceId,e,t,!1)}insertBefore(t,e,r,i=!0){this.delegate.insertBefore(t,e,r),this.engine.onInsert(this.namespaceId,e,t,i)}removeChild(t,e,r){this.engine.onRemove(this.namespaceId,e,this.delegate,r)}selectRootElement(t,e){return this.delegate.selectRootElement(t,e)}parentNode(t){return this.delegate.parentNode(t)}nextSibling(t){return this.delegate.nextSibling(t)}setAttribute(t,e,r,i){this.delegate.setAttribute(t,e,r,i)}removeAttribute(t,e,r){this.delegate.removeAttribute(t,e,r)}addClass(t,e){this.delegate.addClass(t,e)}removeClass(t,e){this.delegate.removeClass(t,e)}setStyle(t,e,r,i){this.delegate.setStyle(t,e,r,i)}removeStyle(t,e,r){this.delegate.removeStyle(t,e,r)}setProperty(t,e,r){"@"==e.charAt(0)&&e==kW?this.disableAnimations(t,!!r):this.delegate.setProperty(t,e,r)}setValue(t,e){this.delegate.setValue(t,e)}listen(t,e,r){return this.delegate.listen(t,e,r)}disableAnimations(t,e){this.engine.disableAnimations(t,e)}}class K$e extends AW{constructor(t,e,r,i,o){super(e,r,i,o),this.factory=t,this.namespaceId=e}setProperty(t,e,r){"@"==e.charAt(0)?"."==e.charAt(1)&&e==kW?this.disableAnimations(t,r=void 0===r||!!r):this.engine.process(this.namespaceId,t,e.slice(1),r):this.delegate.setProperty(t,e,r)}listen(t,e,r){if("@"==e.charAt(0)){const i=function X$e(n){switch(n){case"body":return document.body;case"document":return document;case"window":return window;default:return n}}(t);let o=e.slice(1),s="";return"@"!=o.charAt(0)&&([o,s]=function Y$e(n){const t=n.indexOf(".");return[n.substring(0,t),n.slice(t+1)]}(o)),this.engine.listen(this.namespaceId,i,o,s,a=>{this.factory.scheduleListenerCallback(a._data||-1,r,a)})}return this.delegate.listen(t,e,r)}}const NW=[{provide:_6,useClass:G$e},{provide:m2,useFactory:function Q$e(){return new b$e}},{provide:uw,useClass:(()=>{class n extends uw{constructor(e,r,i,o){super(e.body,r,i)}ngOnDestroy(){this.flush()}}return n.\u0275fac=function(e){return new(e||n)(Fe(Tn),Fe(r2),Fe(m2),Fe(ec))},n.\u0275prov=at({token:n,factory:n.\u0275fac}),n})()},{provide:uf,useFactory:function J$e(n,t,e){return new q$e(n,t,e)},deps:[OS,uw,Vt]}],w2=[{provide:r2,useFactory:()=>new j$e},{provide:ns,useValue:"BrowserAnimations"},...NW],OW=[{provide:r2,useClass:sW},{provide:ns,useValue:"NoopAnimations"},...NW];let eLe=(()=>{class n{static withConfig(e){return{ngModule:n,providers:e.disableAnimations?OW:w2}}}return n.\u0275fac=function(e){return new(e||n)},n.\u0275mod=Vn({type:n}),n.\u0275inj=Pn({providers:w2,imports:[O$]}),n})(),pLe=(()=>{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275mod=Vn({type:n}),n.\u0275inj=Pn({imports:[Do,Vf,$x,Do]}),n})(),gLe=(()=>{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275mod=Vn({type:n}),n.\u0275inj=Pn({imports:[Do,$x,Do]}),n})(),bLe=(()=>{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275mod=Vn({type:n,bootstrap:[oPe]}),n.\u0275inj=Pn({imports:[O$,AMe,ere,eLe,qMe,pLe,kRe,gLe,cFe,YFe]}),n})();gee().bootstrapModule(bLe).catch(n=>console.error(n))},658:me=>{me.exports=P;var E=null;try{E=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch{}function P(ne,X,K){this.low=0|ne,this.high=0|X,this.unsigned=!!K}function F(ne){return!0===(ne&&ne.__isLong__)}Object.defineProperty(P.prototype,"__isLong__",{value:!0}),P.isLong=F;var A={},O={};function k(ne,X){var K,ve,q;return X?(q=0<=(ne>>>=0)&&ne<256)&&(ve=O[ne])?ve:(K=C(ne,(0|ne)<0?-1:0,!0),q&&(O[ne]=K),K):(q=-128<=(ne|=0)&&ne<128)&&(ve=A[ne])?ve:(K=C(ne,ne<0?-1:0,!1),q&&(A[ne]=K),K)}function S(ne,X){if(isNaN(ne))return X?$:M;if(X){if(ne<0)return $;if(ne>=y)return te}else{if(ne<=-w)return ae;if(ne+1>=w)return H}return ne<0?S(-ne,X).neg():C(ne%f|0,ne/f|0,X)}function C(ne,X,K){return new P(ne,X,K)}P.fromInt=k,P.fromNumber=S,P.fromBits=C;var v=Math.pow;function b(ne,X,K){if(0===ne.length)throw Error("empty string");if("NaN"===ne||"Infinity"===ne||"+Infinity"===ne||"-Infinity"===ne)return M;if("number"==typeof X?(K=X,X=!1):X=!!X,(K=K||10)<2||36<K)throw RangeError("radix");var ve;if((ve=ne.indexOf("-"))>0)throw Error("interior hyphen");if(0===ve)return b(ne.substring(1),X,K).neg();for(var q=S(v(K,8)),re=M,le=0;le<ne.length;le+=8){var He=Math.min(8,ne.length-le),Le=parseInt(ne.substring(le,le+He),K);if(He<8){var ot=S(v(K,He));re=re.mul(ot).add(S(Le))}else re=(re=re.mul(q)).add(S(Le))}return re.unsigned=X,re}function h(ne,X){return"number"==typeof ne?S(ne,X):"string"==typeof ne?b(ne,X):C(ne.low,ne.high,"boolean"==typeof X?X:ne.unsigned)}P.fromString=b,P.fromValue=h;var f=4294967296,y=f*f,w=y/2,D=k(1<<24),M=k(0);P.ZERO=M;var $=k(0,!0);P.UZERO=$;var B=k(1);P.ONE=B;var z=k(1,!0);P.UONE=z;var G=k(-1);P.NEG_ONE=G;var H=C(-1,2147483647,!1);P.MAX_VALUE=H;var te=C(-1,-1,!0);P.MAX_UNSIGNED_VALUE=te;var ae=C(0,-2147483648,!1);P.MIN_VALUE=ae;var J=P.prototype;J.toInt=function(){return this.unsigned?this.low>>>0:this.low},J.toNumber=function(){return this.unsigned?(this.high>>>0)*f+(this.low>>>0):this.high*f+(this.low>>>0)},J.toString=function(X){if((X=X||10)<2||36<X)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative()){if(this.eq(ae)){var K=S(X),ve=this.div(K),q=ve.mul(K).sub(this);return ve.toString(X)+q.toInt().toString(X)}return"-"+this.neg().toString(X)}for(var re=S(v(X,6),this.unsigned),le=this,He="";;){var Le=le.div(re),nt=(le.sub(Le.mul(re)).toInt()>>>0).toString(X);if((le=Le).isZero())return nt+He;for(;nt.length<6;)nt="0"+nt;He=""+nt+He}},J.getHighBits=function(){return this.high},J.getHighBitsUnsigned=function(){return this.high>>>0},J.getLowBits=function(){return this.low},J.getLowBitsUnsigned=function(){return this.low>>>0},J.getNumBitsAbs=function(){if(this.isNegative())return this.eq(ae)?64:this.neg().getNumBitsAbs();for(var X=0!=this.high?this.high:this.low,K=31;K>0&&!(X&1<<K);K--);return 0!=this.high?K+33:K+1},J.isZero=function(){return 0===this.high&&0===this.low},J.eqz=J.isZero,J.isNegative=function(){return!this.unsigned&&this.high<0},J.isPositive=function(){return this.unsigned||this.high>=0},J.isOdd=function(){return 1==(1&this.low)},J.isEven=function(){return 0==(1&this.low)},J.equals=function(X){return F(X)||(X=h(X)),(this.unsigned===X.unsigned||this.high>>>31!=1||X.high>>>31!=1)&&this.high===X.high&&this.low===X.low},J.eq=J.equals,J.notEquals=function(X){return!this.eq(X)},J.neq=J.notEquals,J.ne=J.notEquals,J.lessThan=function(X){return this.comp(X)<0},J.lt=J.lessThan,J.lessThanOrEqual=function(X){return this.comp(X)<=0},J.lte=J.lessThanOrEqual,J.le=J.lessThanOrEqual,J.greaterThan=function(X){return this.comp(X)>0},J.gt=J.greaterThan,J.greaterThanOrEqual=function(X){return this.comp(X)>=0},J.gte=J.greaterThanOrEqual,J.ge=J.greaterThanOrEqual,J.compare=function(X){if(F(X)||(X=h(X)),this.eq(X))return 0;var K=this.isNegative(),ve=X.isNegative();return K&&!ve?-1:!K&&ve?1:this.unsigned?X.high>>>0>this.high>>>0||X.high===this.high&&X.low>>>0>this.low>>>0?-1:1:this.sub(X).isNegative()?-1:1},J.comp=J.compare,J.negate=function(){return!this.unsigned&&this.eq(ae)?ae:this.not().add(B)},J.neg=J.negate,J.add=function(X){F(X)||(X=h(X));var nt=0,it=0,yt=0,wt=0;return yt+=(wt+=(65535&this.low)+(65535&X.low))>>>16,it+=(yt+=(this.low>>>16)+(X.low>>>16))>>>16,nt+=(it+=(65535&this.high)+(65535&X.high))>>>16,nt+=(this.high>>>16)+(X.high>>>16),C((yt&=65535)<<16|(wt&=65535),(nt&=65535)<<16|(it&=65535),this.unsigned)},J.subtract=function(X){return F(X)||(X=h(X)),this.add(X.neg())},J.sub=J.subtract,J.multiply=function(X){if(this.isZero())return M;if(F(X)||(X=h(X)),E)return C(E.mul(this.low,this.high,X.low,X.high),E.get_high(),this.unsigned);if(X.isZero())return M;if(this.eq(ae))return X.isOdd()?ae:M;if(X.eq(ae))return this.isOdd()?ae:M;if(this.isNegative())return X.isNegative()?this.neg().mul(X.neg()):this.neg().mul(X).neg();if(X.isNegative())return this.mul(X.neg()).neg();if(this.lt(D)&&X.lt(D))return S(this.toNumber()*X.toNumber(),this.unsigned);var q=65535&this.high,re=this.low>>>16,le=65535&this.low,Le=65535&X.high,ot=X.low>>>16,nt=65535&X.low,it=0,yt=0,wt=0,Pt=0;return wt+=(Pt+=le*nt)>>>16,yt+=(wt+=re*nt)>>>16,wt&=65535,yt+=(wt+=le*ot)>>>16,it+=(yt+=q*nt)>>>16,yt&=65535,it+=(yt+=re*ot)>>>16,yt&=65535,it+=(yt+=le*Le)>>>16,it+=(this.high>>>16)*nt+q*ot+re*Le+le*(X.high>>>16),C((wt&=65535)<<16|(Pt&=65535),(it&=65535)<<16|(yt&=65535),this.unsigned)},J.mul=J.multiply,J.divide=function(X){if(F(X)||(X=h(X)),X.isZero())throw Error("division by zero");var ve,q,re;if(E)return this.unsigned||-2147483648!==this.high||-1!==X.low||-1!==X.high?C((this.unsigned?E.div_u:E.div_s)(this.low,this.high,X.low,X.high),E.get_high(),this.unsigned):this;if(this.isZero())return this.unsigned?$:M;if(this.unsigned){if(X.unsigned||(X=X.toUnsigned()),X.gt(this))return $;if(X.gt(this.shru(1)))return z;re=$}else{if(this.eq(ae))return X.eq(B)||X.eq(G)?ae:X.eq(ae)?B:(ve=this.shr(1).div(X).shl(1)).eq(M)?X.isNegative()?B:G:(q=this.sub(X.mul(ve)),re=ve.add(q.div(X)));if(X.eq(ae))return this.unsigned?$:M;if(this.isNegative())return X.isNegative()?this.neg().div(X.neg()):this.neg().div(X).neg();if(X.isNegative())return this.div(X.neg()).neg();re=M}for(q=this;q.gte(X);){ve=Math.max(1,Math.floor(q.toNumber()/X.toNumber()));for(var He=Math.ceil(Math.log(ve)/Math.LN2),Le=He<=48?1:v(2,He-48),ot=S(ve),nt=ot.mul(X);nt.isNegative()||nt.gt(q);)nt=(ot=S(ve-=Le,this.unsigned)).mul(X);ot.isZero()&&(ot=B),re=re.add(ot),q=q.sub(nt)}return re},J.div=J.divide,J.modulo=function(X){return F(X)||(X=h(X)),E?C((this.unsigned?E.rem_u:E.rem_s)(this.low,this.high,X.low,X.high),E.get_high(),this.unsigned):this.sub(this.div(X).mul(X))},J.mod=J.modulo,J.rem=J.modulo,J.not=function(){return C(~this.low,~this.high,this.unsigned)},J.and=function(X){return F(X)||(X=h(X)),C(this.low&X.low,this.high&X.high,this.unsigned)},J.or=function(X){return F(X)||(X=h(X)),C(this.low|X.low,this.high|X.high,this.unsigned)},J.xor=function(X){return F(X)||(X=h(X)),C(this.low^X.low,this.high^X.high,this.unsigned)},J.shiftLeft=function(X){return F(X)&&(X=X.toInt()),0==(X&=63)?this:X<32?C(this.low<<X,this.high<<X|this.low>>>32-X,this.unsigned):C(0,this.low<<X-32,this.unsigned)},J.shl=J.shiftLeft,J.shiftRight=function(X){return F(X)&&(X=X.toInt()),0==(X&=63)?this:X<32?C(this.low>>>X|this.high<<32-X,this.high>>X,this.unsigned):C(this.high>>X-32,this.high>=0?0:-1,this.unsigned)},J.shr=J.shiftRight,J.shiftRightUnsigned=function(X){if(F(X)&&(X=X.toInt()),0==(X&=63))return this;var K=this.high;return X<32?C(this.low>>>X|K<<32-X,K>>>X,this.unsigned):C(32===X?K:K>>>X-32,0,this.unsigned)},J.shru=J.shiftRightUnsigned,J.shr_u=J.shiftRightUnsigned,J.toSigned=function(){return this.unsigned?C(this.low,this.high,!1):this},J.toUnsigned=function(){return this.unsigned?this:C(this.low,this.high,!0)},J.toBytes=function(X){return X?this.toBytesLE():this.toBytesBE()},J.toBytesLE=function(){var X=this.high,K=this.low;return[255&K,K>>>8&255,K>>>16&255,K>>>24,255&X,X>>>8&255,X>>>16&255,X>>>24]},J.toBytesBE=function(){var X=this.high,K=this.low;return[X>>>24,X>>>16&255,X>>>8&255,255&X,K>>>24,K>>>16&255,K>>>8&255,255&K]},P.fromBytes=function(X,K,ve){return ve?P.fromBytesLE(X,K):P.fromBytesBE(X,K)},P.fromBytesLE=function(X,K){return new P(X[0]|X[1]<<8|X[2]<<16|X[3]<<24,X[4]|X[5]<<8|X[6]<<16|X[7]<<24,K)},P.fromBytesBE=function(X,K){return new P(X[4]<<24|X[5]<<16|X[6]<<8|X[7],X[0]<<24|X[1]<<16|X[2]<<8|X[3],K)}},895:(module,__unused_webpack_exports,__webpack_require__)=>{var _asyncToGenerator=__webpack_require__(156).default,E;self,E=()=>(()=>{var __webpack_modules__={5716:(me,E,P)=>{"use strict";E.R=void 0;const F=P(6027),A=P(1723);E.R=new class{init(){return _asyncToGenerator(function*(){})()}createSessionHandler(O,k){return _asyncToGenerator(function*(){const S=new F.Session(k);return yield S.loadModel(O),new A.OnnxjsSessionHandler(S)})()}}},2818:(me,E,P)=>{"use strict";E.c8=E.rX=void 0;const F=P(2235),A=P(5381),O=P(9544),k=P(6640);E.rX=()=>{if(("number"!=typeof F.env.wasm.initTimeout||F.env.wasm.initTimeout<0)&&(F.env.wasm.initTimeout=0),"boolean"!=typeof F.env.wasm.simd&&(F.env.wasm.simd=!0),"boolean"!=typeof F.env.wasm.proxy&&(F.env.wasm.proxy=!1),"number"!=typeof F.env.wasm.numThreads||!Number.isInteger(F.env.wasm.numThreads)||F.env.wasm.numThreads<=0){const S=typeof navigator>"u"?(0,A.cpus)().length:navigator.hardwareConcurrency;F.env.wasm.numThreads=Math.min(4,Math.ceil((S||1)/2))}},E.c8=new class{init(){return _asyncToGenerator(function*(){(0,E.rX)(),yield(0,O.initializeWebAssemblyInstance)()})()}createSessionHandler(S,C){return _asyncToGenerator(function*(){const v=new k.OnnxruntimeWebAssemblySessionHandler;return yield v.loadModel(S,C),Promise.resolve(v)})()}}},1057:function(me,E,P){"use strict";var F=this&&this.__createBinding||(Object.create?function(S,C,v,b){void 0===b&&(b=v);var h=Object.getOwnPropertyDescriptor(C,v);h&&!("get"in h?!C.__esModule:h.writable||h.configurable)||(h={enumerable:!0,get:function(){return C[v]}}),Object.defineProperty(S,b,h)}:function(S,C,v,b){void 0===b&&(b=v),S[b]=C[v]}),A=this&&this.__exportStar||function(S,C){for(var v in S)"default"===v||Object.prototype.hasOwnProperty.call(C,v)||F(C,S,v)};Object.defineProperty(E,"__esModule",{value:!0}),A(P(2235),E);const O=P(2235),k=P(8408);{const S=P(5716).R;(0,O.registerBackend)("webgl",S,-10)}{const S=P(2818).c8;(0,O.registerBackend)("cpu",S,10),(0,O.registerBackend)("wasm",S,10),(0,O.registerBackend)("xnnpack",S,9),(0,O.registerBackend)("webnn",S,9)}O.env.versions.web=k.version},4910:(me,E)=>{"use strict";Object.defineProperty(E,"__esModule",{value:!0}),E.createAttributeWithCacheKey=void 0;class P{constructor(A){Object.assign(this,A)}get cacheKey(){return this._cacheKey||(this._cacheKey=Object.getOwnPropertyNames(this).sort().map(A=>`${this[A]}`).join(";")),this._cacheKey}}E.createAttributeWithCacheKey=F=>new P(F)},6874:(me,E,P)=>{"use strict";Object.defineProperty(E,"__esModule",{value:!0}),E.Attribute=void 0;const F=P(5127),A=P(2446),O=P(9240),k=P(7273);var S=F.onnxruntime.experimental.fbs;class C{constructor(b){if(this._attributes=new Map,null!=b){for(const h of b)h instanceof A.onnx.AttributeProto?this._attributes.set(h.name,[C.getValue(h),C.getType(h)]):h instanceof S.Attribute&&this._attributes.set(h.name(),[C.getValue(h),C.getType(h)]);if(this._attributes.size<b.length)throw new Error("duplicated attribute names")}}set(b,h,l){this._attributes.set(b,[l,h])}delete(b){this._attributes.delete(b)}getFloat(b,h){return this.get(b,"float",h)}getInt(b,h){return this.get(b,"int",h)}getString(b,h){return this.get(b,"string",h)}getTensor(b,h){return this.get(b,"tensor",h)}getFloats(b,h){return this.get(b,"floats",h)}getInts(b,h){return this.get(b,"ints",h)}getStrings(b,h){return this.get(b,"strings",h)}getTensors(b,h){return this.get(b,"tensors",h)}get(b,h,l){const d=this._attributes.get(b);if(void 0===d){if(void 0!==l)return l;throw new Error(`required attribute not found: ${b}`)}if(d[1]!==h)throw new Error(`type mismatch: expected ${h} but got ${d[1]}`);return d[0]}static getType(b){const h=b instanceof A.onnx.AttributeProto?b.type:b.type();switch(h){case A.onnx.AttributeProto.AttributeType.FLOAT:return"float";case A.onnx.AttributeProto.AttributeType.INT:return"int";case A.onnx.AttributeProto.AttributeType.STRING:return"string";case A.onnx.AttributeProto.AttributeType.TENSOR:return"tensor";case A.onnx.AttributeProto.AttributeType.FLOATS:return"floats";case A.onnx.AttributeProto.AttributeType.INTS:return"ints";case A.onnx.AttributeProto.AttributeType.STRINGS:return"strings";case A.onnx.AttributeProto.AttributeType.TENSORS:return"tensors";default:throw new Error(`attribute type is not supported yet: ${A.onnx.AttributeProto.AttributeType[h]}`)}}static getValue(b){const h=b instanceof A.onnx.AttributeProto?b.type:b.type();if(h===A.onnx.AttributeProto.AttributeType.GRAPH||h===A.onnx.AttributeProto.AttributeType.GRAPHS)throw new Error("graph attribute is not supported yet");const l=this.getValueNoCheck(b);if(h===A.onnx.AttributeProto.AttributeType.INT&&k.LongUtil.isLong(l))return k.LongUtil.longToNumber(l);if(h===A.onnx.AttributeProto.AttributeType.INTS){const d=l,f=new Array(d.length);for(let y=0;y<d.length;y++)f[y]=k.LongUtil.longToNumber(d[y]);return f}if(h===A.onnx.AttributeProto.AttributeType.TENSOR)return b instanceof A.onnx.AttributeProto?O.Tensor.fromProto(l):O.Tensor.fromOrtTensor(l);if(h===A.onnx.AttributeProto.AttributeType.TENSORS){if(b instanceof A.onnx.AttributeProto)return l.map(d=>O.Tensor.fromProto(d));if(b instanceof S.Attribute)return l.map(d=>O.Tensor.fromOrtTensor(d))}return h===A.onnx.AttributeProto.AttributeType.STRING&&b instanceof A.onnx.AttributeProto?(0,k.decodeUtf8String)(l):h===A.onnx.AttributeProto.AttributeType.STRINGS&&b instanceof A.onnx.AttributeProto?l.map(k.decodeUtf8String):l}static getValueNoCheck(b){return b instanceof A.onnx.AttributeProto?this.getValueNoCheckFromOnnxFormat(b):this.getValueNoCheckFromOrtFormat(b)}static getValueNoCheckFromOnnxFormat(b){switch(b.type){case A.onnx.AttributeProto.AttributeType.FLOAT:return b.f;case A.onnx.AttributeProto.AttributeType.INT:return b.i;case A.onnx.AttributeProto.AttributeType.STRING:return b.s;case A.onnx.AttributeProto.AttributeType.TENSOR:return b.t;case A.onnx.AttributeProto.AttributeType.GRAPH:return b.g;case A.onnx.AttributeProto.AttributeType.FLOATS:return b.floats;case A.onnx.AttributeProto.AttributeType.INTS:return b.ints;case A.onnx.AttributeProto.AttributeType.STRINGS:return b.strings;case A.onnx.AttributeProto.AttributeType.TENSORS:return b.tensors;case A.onnx.AttributeProto.AttributeType.GRAPHS:return b.graphs;default:throw new Error(`unsupported attribute type: ${A.onnx.AttributeProto.AttributeType[b.type]}`)}}static getValueNoCheckFromOrtFormat(b){switch(b.type()){case S.AttributeType.FLOAT:return b.f();case S.AttributeType.INT:return b.i();case S.AttributeType.STRING:return b.s();case S.AttributeType.TENSOR:return b.t();case S.AttributeType.GRAPH:return b.g();case S.AttributeType.FLOATS:return b.floatsArray();case S.AttributeType.INTS:{const h=[];for(let l=0;l<b.intsLength();l++)h.push(b.ints(l));return h}case S.AttributeType.STRINGS:{const h=[];for(let l=0;l<b.stringsLength();l++)h.push(b.strings(l));return h}case S.AttributeType.TENSORS:{const h=[];for(let l=0;l<b.tensorsLength();l++)h.push(b.tensors(l));return h}default:throw new Error(`unsupported attribute type: ${S.AttributeType[b.type()]}`)}}}E.Attribute=C},1975:(me,E,P)=>{"use strict";Object.defineProperty(E,"__esModule",{value:!0}),E.resolveBackend=E.backend=void 0;const F=P(4418),A=new Map;function O(S){return k.apply(this,arguments)}function k(){return(k=_asyncToGenerator(function*(S){const C=E.backend;if(void 0!==C[S]&&"initialize"in(v=C[S])&&"function"==typeof v.initialize&&"createSessionHandler"in v&&"function"==typeof v.createSessionHandler&&"dispose"in v&&"function"==typeof v.dispose){const v=C[S];let b=v.initialize();if("object"==typeof b&&"then"in b&&(b=yield b),b)return A.set(S,v),v}var v})).apply(this,arguments)}E.backend={webgl:new F.WebGLBackend},E.resolveBackend=function(){var S=_asyncToGenerator(function*(v){if(!v)return C(["webgl"]);{const b="string"==typeof v?[v]:v;for(const h of b){const l=A.get(h);if(l)return l;const d=yield O(h);if(d)return d}}throw new Error("no available backend to use")});function C(v){return S.apply(this,arguments)}return C}()},4418:(me,E,P)=>{"use strict";Object.defineProperty(E,"__esModule",{value:!0}),E.WebGLBackend=void 0;const F=P(2235),A=P(1315),O=P(2171),k=P(3389);E.WebGLBackend=class{get contextId(){return F.env.webgl.contextId}set contextId(S){F.env.webgl.contextId=S}get matmulMaxBatchSize(){return F.env.webgl.matmulMaxBatchSize}set matmulMaxBatchSize(S){F.env.webgl.matmulMaxBatchSize=S}get textureCacheMode(){return F.env.webgl.textureCacheMode}set textureCacheMode(S){F.env.webgl.textureCacheMode=S}get pack(){return F.env.webgl.pack}set pack(S){F.env.webgl.pack=S}get async(){return F.env.webgl.async}set async(S){F.env.webgl.async=S}initialize(){try{return this.glContext=(0,k.createWebGLContext)(this.contextId),"number"!=typeof this.matmulMaxBatchSize&&(this.matmulMaxBatchSize=16),"string"!=typeof this.textureCacheMode&&(this.textureCacheMode="full"),"boolean"!=typeof this.pack&&(this.pack=!1),"boolean"!=typeof this.async&&(this.async=!1),A.Logger.setWithEnv(F.env),A.Logger.verbose("WebGLBackend",`Created WebGLContext: ${typeof this.glContext} with matmulMaxBatchSize: ${this.matmulMaxBatchSize}; textureCacheMode: ${this.textureCacheMode}; pack: ${this.pack}; async: ${this.async}.`),!0}catch(S){return A.Logger.warning("WebGLBackend",`Unable to initialize WebGLBackend. ${S}`),!1}}createSessionHandler(S){return new O.WebGLSessionHandler(this,S)}dispose(){this.glContext.dispose()}}},6859:(me,E,P)=>{"use strict";Object.defineProperty(E,"__esModule",{value:!0}),E.CoordsGlslLib=void 0;const F=P(7273),A=P(1997),O=P(6757),k=P(7618),S=P(432);E.CoordsGlslLib=class C extends A.GlslLib{constructor(b){super(b)}getFunctions(){return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({},this.offsetToCoords()),this.coordsToOffset()),this.toVec()),this.valueFrom()),this.getCommonUtilFuncs()),this.getInputsSamplingSnippets()),this.getOutputSamplingSnippet())}getCustomTypes(){return{}}offsetToCoords(){return{offsetToCoords:new A.GlslLibRoutine("\n      vec2 offsetToCoords(int offset, int width, int height) {\n        int t = offset / width;\n        int s = offset - t*width;\n        vec2 coords = (vec2(s,t) + vec2(0.5,0.5)) / vec2(width, height);\n        return coords;\n      }\n      ")}}coordsToOffset(){return{coordsToOffset:new A.GlslLibRoutine("\n      int coordsToOffset(vec2 coords, int width, int height) {\n        float s = coords.s * float(width);\n        float t = coords.t * float(height);\n        int offset = int(t) * width + int(s);\n        return offset;\n      }\n      ")}}getOutputSamplingSnippet(){const b=this.context.outputTextureLayout;return b.isPacked?this.getPackedOutputSamplingSnippet(b):this.getUnpackedOutputSamplingSnippet(b)}getPackedOutputSamplingSnippet(b){const h=b.unpackedShape,l=[b.width,b.height],d={},f="getOutputCoords";switch(h.length){case 0:d[f]=this.getOutputScalarCoords();break;case 1:d[f]=this.getOutputPacked1DCoords(h,l);break;case 2:d[f]=this.getOutputPacked2DCoords(h,l);break;case 3:d[f]=this.getOutputPacked3DCoords(h,l);break;default:d[f]=this.getOutputPackedNDCoords(h,l)}const y=`\n      void setOutput(vec4 val) {\n        ${(0,O.getGlsl)(this.context.glContext.version).output} = val;\n      }\n    `;return d.floatTextureSetRGBA=new A.GlslLibRoutine(y),d}getUnpackedOutputSamplingSnippet(b){const h=b.unpackedShape,l=[b.width,b.height],d={},f="getOutputCoords";switch(h.length){case 0:d[f]=this.getOutputScalarCoords();break;case 1:d[f]=this.getOutputUnpacked1DCoords(h,l);break;case 2:d[f]=this.getOutputUnpacked2DCoords(h,l);break;case 3:d[f]=this.getOutputUnpacked3DCoords(h,l);break;case 4:d[f]=this.getOutputUnpacked4DCoords(h,l);break;case 5:d[f]=this.getOutputUnpacked5DCoords(h,l);break;case 6:d[f]=this.getOutputUnpacked6DCoords(h,l);break;default:throw new Error(`Unsupported output dimensionality: ${h.length}`)}const y=`\n        void setOutput(float val) {\n          ${(0,O.getGlsl)(this.context.glContext.version).output} = vec4(val, 0, 0, 0);\n        }\n    `;return d.floatTextureSetR=new A.GlslLibRoutine(y),d}getOutputScalarCoords(){return new A.GlslLibRoutine("\n      int getOutputCoords() {\n        return 0;\n      }\n    ")}getOutputPacked1DCoords(b,h){const l=h;let d="";return 1===l[0]?(d=`\n          int getOutputCoords() {\n            return 2 * int(TexCoords.y * ${l[1]}.0);\n          }\n        `,new A.GlslLibRoutine(d)):1===l[1]?(d=`\n          int getOutputCoords() {\n            return 2 * int(TexCoords.x * ${l[0]}.0);\n          }\n        `,new A.GlslLibRoutine(d)):(d=`\n        int getOutputCoords() {\n          ivec2 resTexRC = ivec2(TexCoords.xy *\n                                 vec2(${l[0]}, ${l[1]}));\n          return 2 * (resTexRC.y * ${l[0]} + resTexRC.x);\n        }\n      `,new A.GlslLibRoutine(d))}getOutputPacked2DCoords(b,h){let l="";if(F.ArrayUtil.arraysEqual(b,h))return l=`\n        ivec2 getOutputCoords() {\n          return 2 * ivec2(TexCoords.xy * vec2(${h[0]}, ${h[1]}));\n        }\n      `,new A.GlslLibRoutine(l);const d=h,f=Math.ceil(b[1]/2);return l=`\n        ivec2 getOutputCoords() {\n          ivec2 resTexRC = ivec2(TexCoords.xy *\n                                vec2(${d[0]}, ${d[1]}));\n\n          int index = resTexRC.y * ${d[0]} + resTexRC.x;\n\n          // reverse r and c order for packed texture\n          int r = imod(index, ${f}) * 2;\n          int c = 2 * (index / ${f});\n\n          return ivec2(r, c);\n        }\n      `,new A.GlslLibRoutine(l)}getOutputPacked3DCoords(b,h){const l=[h[0],h[1]],d=Math.ceil(b[2]/2),f=d*Math.ceil(b[1]/2);return new A.GlslLibRoutine(`\n        ivec3 getOutputCoords() {\n          ivec2 resTexRC = ivec2(TexCoords.xy *\n                                vec2(${l[0]}, ${l[1]}));\n          int index = resTexRC.y * ${l[0]} + resTexRC.x;\n\n          int b = index / ${f};\n          index -= b * ${f};\n\n          // reverse r and c order for packed texture\n          int r = imod(index, ${d}) * 2;\n          int c = 2 * (index / ${d});\n\n          return ivec3(b, r, c);\n        }\n      `)}getOutputPackedNDCoords(b,h){const l=[h[0],h[1]],d=Math.ceil(b[b.length-1]/2),f=d*Math.ceil(b[b.length-2]/2);let y=f,w="",D="b, r, c";for(let $=2;$<b.length-1;$++)y*=b[b.length-$-1],w=`\n      int b${$} = index / ${y};\n      index -= b${$} * ${y};\n    `+w,D=`b${$}, `+D;return new A.GlslLibRoutine(`\n      ivec${b.length} getOutputCoords() {\n        ivec2 resTexRC = ivec2(TexCoords.xy *\n                              vec2(${l[0]}, ${l[1]}));\n        int index = resTexRC.y * ${l[0]} + resTexRC.x;\n\n        ${w}\n\n        int b = index / ${f};\n        index -= b * ${f};\n\n        // reverse r and c order for packed texture\n        int r = imod(index, ${d}) * 2;\n        int c = 2 * (index / ${d});\n\n        return ivec${b.length}(${D});\n      }\n    `)}getOutputUnpacked1DCoords(b,h){return new A.GlslLibRoutine(`\n        int getOutputCoords() {\n          ivec2 resTexRC = ivec2(TexCoords.xy *\n                                vec2(${h[0]}, ${h[1]}));\n          return resTexRC.y * ${h[0]} + resTexRC.x;\n        }\n      `)}getOutputUnpacked2DCoords(b,h){return new A.GlslLibRoutine(`\n        ivec2 getOutputCoords() {\n          ivec2 resTexRC = ivec2(TexCoords.xy *\n                                vec2(${h[0]}, ${h[1]}));\n          int index = resTexRC.y * ${h[0]} + resTexRC.x;\n          int r = index / ${b[1]};\n          int c = index - r * ${b[1]};\n          return ivec2(r, c);\n        }\n      `)}getOutputUnpacked3DCoords(b,h){let l="";const d=b.length;let f=null;d<2&&(f=[]),f=new Array(d-1),f[d-2]=b[d-1];for(let D=d-3;D>=0;--D)f[D]=f[D+1]*b[D+1];const y=["r","c","d"],w=f.map((D,M)=>`int ${y[M]} = index / ${D}; ${M===f.length-1?`int ${y[M+1]} = index - ${y[M]} * ${D}`:`index -= ${y[M]} * ${D}`};`).join("");return l=`\n        ivec3 getOutputCoords() {\n          ivec2 resTexRC = ivec2(TexCoords.xy *\n                                vec2(${h[0]}, ${h[1]}));\n          int index = resTexRC.y * ${h[0]} + resTexRC.x;\n          ${w}\n          return ivec3(r, c, d);\n        }\n      `,new A.GlslLibRoutine(l)}getOutputUnpacked4DCoords(b,h){let l="";const d=b.length;let f=null;d<2&&(f=[]),f=new Array(d-1),f[d-2]=b[d-1];for(let D=d-3;D>=0;--D)f[D]=f[D+1]*b[D+1];const y=["r","c","d","d2"],w=f.map((D,M)=>`int ${y[M]} = index / ${D}; ${M===f.length-1?`int ${y[M+1]} = index - ${y[M]} * ${D}`:`index -= ${y[M]} * ${D}`};`).join("");return l=`\n      ivec4 getOutputCoords() {\n          ivec2 resTexRC = ivec2(TexCoords.xy *\n                                vec2(${h[0]}, ${h[1]}));\n          int index = resTexRC.y * ${h[0]} + resTexRC.x;\n          ${w}\n          return ivec4(r, c, d, d2);\n        }\n      `,new A.GlslLibRoutine(l)}getOutputUnpacked5DCoords(b,h){let l="";const d=b.length;let f=null;d<2&&(f=[]),f=new Array(d-1),f[d-2]=b[d-1];for(let D=d-3;D>=0;--D)f[D]=f[D+1]*b[D+1];const y=["r","c","d","d2","d3"],w=f.map((D,M)=>`int ${y[M]} = index / ${D}; ${M===f.length-1?`int ${y[M+1]} = index - ${y[M]} * ${D}`:`index -= ${y[M]} * ${D}`};`).join("");return l=`\n      ivec5 getOutputCoords() {\n          ivec2 resTexRC = ivec2(TexCoords.xy *\n                                vec2(${h[0]}, ${h[1]}));\n          int index = resTexRC.y * ${h[0]} + resTexRC.x;\n          ${w}\n          return ivec5(r, c, d, d2, d3);\n        }\n      `,new A.GlslLibRoutine(l)}getOutputUnpacked6DCoords(b,h){let l="";const d=b.length;let f=null;d<2&&(f=[]),f=new Array(d-1),f[d-2]=b[d-1];for(let D=d-3;D>=0;--D)f[D]=f[D+1]*b[D+1];const y=["r","c","d","d2","d3","d4"],w=f.map((D,M)=>`int ${y[M]} = index / ${D}; ${M===f.length-1?`int ${y[M+1]} = index - ${y[M]} * ${D}`:`index -= ${y[M]} * ${D}`};`).join("");return l=`\n     ivec6 getOutputCoords() {\n         ivec2 resTexRC = ivec2(TexCoords.xy *\n                               vec2(${h[0]}, ${h[1]}));\n         int index = resTexRC.y * ${h[0]} + resTexRC.x;\n         ${w}\n         return ivec6(r, c, d, d2, d3, d4);\n       }\n     `,new A.GlslLibRoutine(l)}getCommonUtilFuncs(){const b={};let h="uvFromFlat";b[h]=new A.GlslLibRoutine("\n    vec2 uvFromFlat(int texNumR, int texNumC, int index) {\n      int texC = index / texNumR;\n      int texR = index - texC * texNumR;\n      // TODO: swap texR, texC order in following function so row is corresponding to u and column is corresponding to\n      //       v.\n      return (vec2(texR, texC) + halfCR) / vec2(texNumR, texNumC);\n    }\n    "),h="packedUVfrom1D",b[h]=new A.GlslLibRoutine("\n      vec2 packedUVfrom1D(int texNumR, int texNumC, int index) {\n        int texelIndex = index / 2;\n        int texR = texelIndex / texNumC;\n        int texC = texelIndex - texR * texNumC;\n        return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n      }\n      "),h="packedUVfrom2D",b[h]=new A.GlslLibRoutine("\n      vec2 packedUVfrom2D(int texNumR, int texNumC, int texelsInLogicalRow, int row, int col) {\n        int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);\n        int texR = texelIndex / texNumC;\n        int texC = texelIndex - texR * texNumC;\n        return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n      }\n      "),h="packedUVfrom3D",b[h]=new A.GlslLibRoutine("\n      vec2 packedUVfrom3D(int texNumR, int texNumC,\n          int texelsInBatch, int texelsInLogicalRow, int b,\n          int row, int col) {\n        int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);\n        int texR = index / texNumC;\n        int texC = index - texR * texNumC;\n        return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n      }\n      "),h="sampleTexture";const l=(0,O.getGlsl)(this.context.glContext.version);return b[h]=new A.GlslLibRoutine(`\n        float sampleTexture(sampler2D textureSampler, vec2 uv) {\n            return ${l.texture2D}(textureSampler, uv).r;\n        }`),b}getInputsSamplingSnippets(){const b={},h=this.context.outputTextureLayout;return this.context.programInfo.inputNames.forEach((l,d)=>{const f=this.context.inputTextureLayouts[d],y=(0,S.generateShaderFuncNameFromInputSamplerName)(l);b[y]=f.isPacked?this.getPackedSamplerFromInput(y,l,f):this.getUnpackedSamplerFromInput(y,l,f);const w=(0,S.generateShaderFuncNameFromInputSamplerNameAtOutCoords)(l);f.unpackedShape.length<=h.unpackedShape.length&&(b[w]=f.isPacked?this.getPackedSamplerAtOutputCoords(w,f,h,l):this.getUnpackedSamplerAtOutputCoords(w,f,h,l))}),b}getPackedSamplerAtOutputCoords(b,h,l,d){const f=h.unpackedShape,y=l.unpackedShape,D=(0,S.generateShaderFuncNameFromInputSamplerName)(d),M=f.length,$=y.length,B=F.BroadcastUtil.getBroadcastDims(f,y),z=(0,S.getCoordsDataType)($),G=$-M;let H;const te=(0,S.getGlChannels)();H=0===M?"":$<2&&B.length>=1?"coords = 0;":B.map(ve=>`coords.${te[ve+G]} = 0;`).join("\n");let ae="";ae=$<2&&M>0?"coords":f.map((ve,q)=>`coords.${te[q+G]}`).join(", ");let J="return outputValue;";const ne=1===F.ShapeUtil.size(f),X=1===F.ShapeUtil.size(y);if(1!==M||ne||X){if(ne&&!X)J=1===$?"\n          return vec4(outputValue.x, outputValue.x, 0., 0.);\n        ":"\n          return vec4(outputValue.x);\n        ";else if(B.length){const ve=M-2,q=M-1;B.indexOf(ve)>-1&&B.indexOf(q)>-1?J="return vec4(outputValue.x);":B.indexOf(ve)>-1?J="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":B.indexOf(q)>-1&&(J="return vec4(outputValue.xx, outputValue.zz);")}}else J="\n        return vec4(outputValue.xy, outputValue.xy);\n      ";return new A.GlslLibRoutine(`\n      vec4 ${b}() {\n        ${z} coords = getOutputCoords();\n        \n        int lastDim = coords.${te[$-1]};\n        coords.${te[$-1]} = coords.${te[$-2]};\n        coords.${te[$-2]} = lastDim;\n      \n        ${H}\n        vec4 outputValue = ${D}(${ae});\n        ${J}\n      }\n    `,["coordinates.getOutputCoords"])}getUnpackedSamplerAtOutputCoords(b,h,l,d){const f=[l.width,l.height],y=[h.width,h.height],w=h.unpackedShape.length,D=l.unpackedShape.length,M=h.unpackedShape,$=l.unpackedShape,B=(0,S.generateShaderFuncNameFromInputSamplerName)(d);if(w===D&&F.ArrayUtil.arraysEqual(y,f))return new A.GlslLibRoutine(`\n          float ${b}() {\n            return sampleTexture(${d}, TexCoords);\n          }\n        `,["coordinates.sampleTexture"]);const z=(0,S.getCoordsDataType)(D),G=F.BroadcastUtil.getBroadcastDims(M,$),H=D-w;let te;const ae=(0,S.getGlChannels)();te=0===w?"":D<2&&G.length>=1?"coords = 0;":G.map(X=>`coords.${ae[X+H]} = 0;`).join("\n");let J="";return J=D<2&&w>0?"coords":h.unpackedShape.map((X,K)=>`coords.${ae[K+H]}`).join(", "),new A.GlslLibRoutine(`\n        float ${b}() {\n          ${z} coords = getOutputCoords();\n          ${te}\n          return ${B}(${J});\n        }\n      `,["coordinates.getOutputCoords"])}getPackedSamplerFromInput(b,h,l){switch(l.unpackedShape.length){case 0:return this.getPackedSamplerScalar(b,h);case 1:return this.getPackedSampler1D(b,h,l);case 2:return this.getPackedSampler2D(b,h,l);case 3:return this.getPackedSampler3D(b,h,l);default:return this.getPackedSamplerND(b,h,l)}}getUnpackedSamplerFromInput(b,h,l){const d=l.unpackedShape;switch(d.length){case 0:return this.getUnpackedSamplerScalar(b,h,l);case 1:return this.getUnpackedSampler1D(b,h,l);case 2:return this.getUnpackedSampler2D(b,h,l);case 3:return this.getUnpackedSampler3D(b,h,l);case 4:return this.getUnpackedSampler4D(b,h,l);case 5:return this.getUnpackedSampler5D(b,h,l);case 6:return this.getUnpackedSampler6D(b,h,l);default:throw new Error(`Unsupported dimension ${d.length}-D`)}}getPackedSamplerScalar(b,h){const l=`\n          vec4 ${b}() {\n            return ${(0,O.getGlsl)(this.context.glContext.version).texture2D}(${h}, halfCR);\n          }\n        `;return new A.GlslLibRoutine(l)}getPackedSampler1D(b,h,l){const d=[l.width,l.height],f=[d[1],d[0]],y=(0,O.getGlsl)(this.context.glContext.version);return new A.GlslLibRoutine(`vec4 ${b}(int index) {\n      vec2 uv = packedUVfrom1D(\n      ${f[0]}, ${f[1]}, index);\n      return ${y.texture2D}(${h}, uv);\n    }`,["coordinates.packedUVfrom1D"])}getPackedSampler2D(b,h,l){const d=l.unpackedShape,f=[l.width,l.height],y=(0,O.getGlsl)(this.context.glContext.version),w=f[0],D=f[1];if(null!=f&&F.ArrayUtil.arraysEqual(d,f))return new A.GlslLibRoutine(`vec4 ${b}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${D}.0, ${w}.0);\n        return ${y.texture2D}(${h}, uv);\n      }`);const M=f,$=Math.ceil(d[1]/2);return new A.GlslLibRoutine(`vec4 ${b}(int row, int col) {\n      vec2 uv = packedUVfrom2D(${M[1]}, ${M[0]}, ${$}, row, col);\n      return ${y.texture2D}(${h}, uv);\n    }`,["coordinates.packedUVfrom2D"])}getPackedSampler3D(b,h,l){const d=l.unpackedShape,f=[l.width,l.height],y=[f[0],f[1]],w=(0,O.getGlsl)(this.context.glContext.version);if(1===d[0]){const z=d.slice(1),G=[1,2],H=(0,S.squeezeInputShape)(d,z),te=["b","row","col"],ae=JSON.parse(JSON.stringify(l));ae.unpackedShape=H;const J=this.getPackedSamplerFromInput(b,h,ae),ne=`${J.routineBody}\n      vec4 ${b}(int b, int row, int col) {\n        return ${b}(${(0,S.getSqueezedParams)(te,G)});\n      } `;return new A.GlslLibRoutine(ne,J.dependencies)}const D=y[0],M=y[1],$=Math.ceil(d[2]/2),B=`vec4 ${b}(int b, int row, int col) {\n      vec2 uv = packedUVfrom3D(\n        ${M}, ${D}, ${$*Math.ceil(d[1]/2)}, ${$}, b, row, col);\n      return ${w.texture2D}(${h}, uv);}`;return new A.GlslLibRoutine(B,["coordinates.packedUVfrom3D"])}getPackedSamplerND(b,h,l){const d=l.unpackedShape,f=d.length,y=[l.width,l.height],w=(0,O.getGlsl)(this.context.glContext.version),D=[y[0],y[1]],M=D[1],$=D[0],B=Math.ceil(d[f-1]/2);let z=B*Math.ceil(d[f-2]/2),G="int b, int row, int col",H=`b * ${z} + (row / 2) * ${B} + (col / 2)`;for(let ae=2;ae<f-1;ae++)G=`int b${ae}, `+G,z*=d[f-ae-1],H=`b${ae} * ${z} + `+H;return new A.GlslLibRoutine(`vec4 ${b}(${G}) {\n      int index = ${H};\n      int texR = index / ${$};\n      int texC = index - texR * ${$};\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${$}, ${M});\n      return ${w.texture2D}(${h}, uv);\n    }`)}getUnpackedSamplerScalar(b,h,l){const[d,f]=[l.width,l.height];return 1===d&&1===f?new A.GlslLibRoutine(`\n          float ${b}() {\n            return sampleTexture(${h}, halfCR);\n          }\n        `,["coordinates.sampleTexture"]):new A.GlslLibRoutine(`\n        float ${b}() {\n          int offset_${h} = coordsToOffset(TexCoords, ${d}, ${f});\n          vec2 uv = uvFromFlat(${d}, ${f}, offset_${h});\n          return sampleTexture(${h}, uv);\n        }\n      `,["coordinates.uvFromFlat","coordinates.sampleTexture","coordinates.coordsToOffset"])}getUnpackedSampler1D(b,h,l){const d=l.width,f=l.height;return 1===f&&1===d?new A.GlslLibRoutine(`\n        float ${b}(int index) {\n          return sampleTexture(${h}, halfCR);\n        }\n      `,["coordinates.sampleTexture"]):1===f?new A.GlslLibRoutine(`\n          float ${b}(int index) {\n            vec2 uv = vec2((float(index) + 0.5) / ${d}.0, 0.5);\n            return sampleTexture(${h}, uv);\n          }\n        `,["coordinates.sampleTexture"]):1===d?new A.GlslLibRoutine(`\n          float ${b}(int index) {\n            vec2 uv = vec2(0.5, (float(index) + 0.5) / ${f}.0);\n            return sampleTexture(${h}, uv);\n          }\n        `,["coordinates.sampleTexture"]):new A.GlslLibRoutine(`\n        float ${b}(int index) {\n          vec2 uv = uvFromFlat(${d}, ${f}, index);\n          return sampleTexture(${h}, uv);\n        }\n      `,["coordinates.uvFromFlat","coordinates.sampleTexture"])}getUnpackedSampler2D(b,h,l){const d=l.unpackedShape,f=[l.height,l.width];if(null!=f&&F.ArrayUtil.arraysEqual(d,f))return new A.GlslLibRoutine(`\n          float ${b}(int row, int col) {\n            vec2 uv = (vec2(row, col) + halfCR) / vec2(${f[1]}.0, ${f[0]}.0);\n            return sampleTexture(${h}, uv);\n          }\n        `,["coordinates.sampleTexture"]);const{newShape:y,keptDims:w}=(0,k.squeezeShape)(d);if(y.length<d.length){const z=(0,S.squeezeInputShape)(d,y),G=JSON.parse(JSON.stringify(l));G.unpackedShape=z;const H=["col","row"],te=`\n          ${this.getUnpackedSamplerFromInput(b,h,G).routineBody}\n          float ${b}(int row, int col) {\n            return ${b}(${(0,S.getSqueezedParams)(H,w)});\n          }\n        `;return new A.GlslLibRoutine(te,["coordinates.sampleTexture"])}const M=f[1],$=f[0];return 1===$?new A.GlslLibRoutine(`\n          float ${b}(int row, int col) {\n            int offset_${h} = coordsToOffset(TexCoords, ${M}, ${$});\n            float index = dot(vec3(row, col, offset_${h}), vec3(${d[1]}, 1, 1));\n            vec2 uv = vec2(0.5, (index + 0.5) / ${M}.0);\n            return sampleTexture(${h}, uv);\n          }\n        `,["coordinates.sampleTexture","coordinates.coordsToOffset"]):1===M?new A.GlslLibRoutine(`\n          float ${b}(int row, int col) {\n            int offset_${h} = coordsToOffset(TexCoords, ${M}, ${$});\n            float index = dot(vec3(row, col, offset_${h}), vec3(${d[1]}, 1, 1));\n            vec2 uv = vec2((index + 0.5) / ${$}.0, 0.5);\n            return sampleTexture(${h}, uv);\n          }\n        `,["coordinates.sampleTexture","coordinates.coordsToOffset"]):new A.GlslLibRoutine(`\n        float ${b}(int row, int col) {\n          int index = col * ${d[1]} + row;\n          vec2 uv = uvFromFlat(${M}, ${$}, index);\n          return sampleTexture(${h}, uv);\n        }\n      `,["coordinates.uvFromFlat","coordinates.sampleTexture","coordinates.coordsToOffset"])}getUnpackedSampler3D(b,h,l){const d=l.unpackedShape,f=d[1]*d[2],y=d[2],{newShape:w,keptDims:D}=(0,k.squeezeShape)(d);if(w.length<d.length){const B=(0,S.squeezeInputShape)(d,w),z=["batch","col","row"],G=JSON.parse(JSON.stringify(l));G.unpackedShape=B;const H=this.getUnpackedSamplerFromInput(b,h,G),te=D.reverse(),ae=`\n          ${H.routineBody}\n          float ${b}(int batch, int row, int col) {\n            return ${b}(${(0,S.getSqueezedParams)(z,te)});\n          }\n        `;return new A.GlslLibRoutine(ae,H.dependencies)}return new A.GlslLibRoutine(`\n          float ${b}(int depth, int row, int col) {\n            // Explicitly use integer operations as dot() only works on floats.\n            int index = depth * ${f} + col * ${y} + row;\n            vec2 uv = uvFromFlat(${l.width}, ${l.height}, index);\n            return sampleTexture(${h}, uv);\n          }\n      `,["coordinates.uvFromFlat","coordinates.sampleTexture","coordinates.coordsToOffset"])}getUnpackedSampler4D(b,h,l){const d=l.unpackedShape,f=d[3],y=d[2]*f;return new A.GlslLibRoutine(`\n        float ${b}(int row, int col, int depth, int depth2) {\n          int index = row * ${d[1]*y} + col * ${y} +\n              depth2 * ${f} + depth;\n          vec2 uv = uvFromFlat(${l.width}, ${l.height}, index);\n          return sampleTexture(${h}, uv);\n        }\n      `,["coordinates.uvFromFlat","coordinates.sampleTexture"])}getUnpackedSampler5D(b,h,l){const d=l.unpackedShape,f=d[4],y=d[3]*f,w=d[2]*y,D=d[1]*w,{newShape:M,keptDims:$}=(0,k.squeezeShape)(d);if(M.length<d.length){const z=(0,S.squeezeInputShape)(d,M),G=["row","col","depth","depth2","depth3"],H=JSON.parse(JSON.stringify(l));H.unpackedShape=z;const te=`\n          ${this.getUnpackedSamplerFromInput(b,h,H).routineBody}\n          float ${b}(int row, int col, int depth, int depth2, int depth3) {\n            return ${b}(${(0,S.getSqueezedParams)(G,$)});\n          }\n        `;return new A.GlslLibRoutine(te,["coordinates.sampleTexture","coordinates.uvFromFlat"])}return new A.GlslLibRoutine(`\n        float ${b}(int row, int col, int depth, int depth2, int depth3) {\n          int index = row * ${D} + col * ${w} + depth * ${y} +\n          depth3 * ${f} + depth2;\n          vec2 uv = uvFromFlat(${l.width}, ${l.height}, index);\n          return sampleTexture(${h}, uv);\n        }\n      `,["coordinates.sampleTexture","coordinates.uvFromFlat"])}getUnpackedSampler6D(b,h,l){const d=l.unpackedShape,f=d[5],y=d[4]*f,w=d[3]*y,D=d[2]*w,M=d[1]*D,{newShape:$,keptDims:B}=(0,k.squeezeShape)(d);if($.length<d.length){const G=(0,S.squeezeInputShape)(d,$),H=["row","col","depth","depth2","depth3","depth4"],te=JSON.parse(JSON.stringify(l));te.unpackedShape=G;const ae=`\n            ${this.getUnpackedSamplerFromInput(b,h,te).routineBody}\n            float ${b}(int row, int col, int depth,\n              int depth2, int depth3, int depth4) {\n              return ${b}(${(0,S.getSqueezedParams)(H,B)});\n            }\n          `;return new A.GlslLibRoutine(ae,["coordinates.sampleTexture","coordinates.uvFromFlat"])}return new A.GlslLibRoutine(`\n          float ${b}(int row, int col, int depth,\n            int depth2, int depth3, int depth4) {\n            int index = row * ${M} + col * ${D} + depth * ${w} +\n            depth2 * ${y} + depth3 * ${f} + depth4;\n            vec2 uv = uvFromFlat(${l.width}, ${l.height}, index);\n            return sampleTexture(${h}, uv);\n          }\n        `,["coordinates.uvFromFlat","coordinates.sampleTexture","coordinates.coordsToOffset"])}toVec(){const b=this.context.outputTextureLayout,h=b.shape.length,l=b.strides,d=b.width,f=b.height,y=[];for(let D=0;D<h-1;++D)y.push(`\n        c[${D}] = offset / ${l[D]};`),y.push(`\n        offset -= c[${D}] * ${l[D]};`);y.push(`\n        c[${h-1}] = offset;`);const w=`\n      void toVec(vec2 texCoords, out int c[${h}]) {\n        int offset = coordsToOffset(texCoords, ${d}, ${f});\n        ${y.join("")}\n      }\n      void toVec(int offset, out int c[${h}]) {\n        ${y.join("")}\n      }\n    `;return{toVec:new A.GlslLibRoutine(w,["coordinates.coordsToOffset"])}}valueFrom(){const b={};return this.context.programInfo.inputNames.forEach((h,l)=>{const d=this.context.inputTextureLayouts[l],f=(d.unpackedShape.length>0?d.unpackedShape:d.shape).length;let y=`_${h}`;b[y]=new A.GlslLibRoutine(this.getValueFromSingle(h,f,d.width,d.height,!1),[`shapeUtils.indicesToOffset${y}`,"coordinates.offsetToCoords","fragcolor.getColorAsFloat"]),y+="_T",b[y]=new A.GlslLibRoutine(this.getValueFromSingle(h,f,d.width,d.height,!0),[`shapeUtils.indicesToOffset${y}`,"coordinates.offsetToCoords","fragcolor.getColorAsFloat"])}),b}getValueFromSingle(b,h,l,d,f){let y=`_${b}`;return f&&(y+="_T"),`\n        float ${y}(int m[${h}]) {\n          int offset = indicesToOffset${y}(m);\n          vec2 coords = offsetToCoords(offset, ${l}, ${d});\n          float value = getColorAsFloat(${(0,O.getGlsl)(this.context.glContext.version).texture2D}(${b}, coords));\n          return value;\n        }\n        `}getPackedValueFrom(b,h,l,d,f){let y=`_${b}_Pack`;return f&&(y+="_T"),`\n        vec4 ${y}(int m[${h}]) {\n          int offset = indicesToOffset_${b}(m);\n          vec2 coords = offsetToCoords(offset, ${l}, ${d});\n          return ${(0,O.getGlsl)(this.context.glContext.version).texture2D}(${b}, coords);\n        }\n        `}}},1997:(me,E)=>{"use strict";var P;Object.defineProperty(E,"__esModule",{value:!0}),E.TopologicalSortGlslRoutines=E.GlslLibRoutineNode=E.GlslLibRoutine=E.GlslLib=E.GlslContext=E.FunctionType=void 0,(P=E.FunctionType||(E.FunctionType={}))[P.ValueBased=0]="ValueBased",P[P.Positional=1]="Positional",E.GlslContext=class{constructor(F,A,O,k){this.glContext=F,this.programInfo=A,this.inputTextureLayouts=O,this.outputTextureLayout=k}},E.GlslLib=class{constructor(F){this.context=F}},E.GlslLibRoutine=class{constructor(F,A){this.routineBody=F,this.dependencies=A}},E.GlslLibRoutineNode=class{constructor(F,A,O){this.name=F,this.dependencies=O||[],A&&(this.routineBody=A)}addDependency(F){F&&this.dependencies.push(F)}},E.TopologicalSortGlslRoutines=class{static returnOrderedNodes(F){if(!F||0===F.length)return[];if(1===F.length)return F;const A=new Set,O=new Set,k=new Array;return this.createOrderedNodes(F,A,O,k),k}static createOrderedNodes(F,A,O,k){for(let S=0;S<F.length;++S)this.dfsTraverse(F[S],A,O,k)}static dfsTraverse(F,A,O,k){if(!F||O.has(F.name))return;if(A.has(F.name))throw new Error("Cyclic dependency detected. Can't topologically sort routines needed for shader.");A.add(F.name);const S=F.dependencies;if(S&&S.length>0)for(let C=0;C<S.length;++C)this.dfsTraverse(S[C],A,O,k);k.push(F),O.add(F.name),A.delete(F.name)}}},1371:(me,E,P)=>{"use strict";Object.defineProperty(E,"__esModule",{value:!0}),E.EncodingGlslLib=void 0;const F=P(1997);class A extends F.GlslLib{constructor(k){super(k)}getFunctions(){return Object.assign(Object.assign({},this.encodeFloat32()),this.decodeFloat32())}getCustomTypes(){return{}}encodeFloat32(){return{encode:new F.GlslLibRoutine("highp vec4 encode(highp float f) {\n        return vec4(f, 0.0, 0.0, 0.0);\n      }\n        ")}}decodeFloat32(){return{decode:new F.GlslLibRoutine("highp float decode(highp vec4 rgba) {\n        return rgba.r;\n      }\n        ")}}encodeUint8(){const k=A.isLittleEndian()?"rgba.rgba=rgba.abgr;":"";return{encode:new F.GlslLibRoutine(`\n      highp vec4 encode(highp float f) {\n        highp float F = abs(f);\n        highp float Sign = step(0.0,-f);\n        highp float Exponent = floor(log2(F));\n        highp float Mantissa = (exp2(- Exponent) * F);\n        Exponent = floor(log2(F) + 127.0) + floor(log2(Mantissa));\n        highp vec4 rgba;\n        rgba[0] = 128.0 * Sign  + floor(Exponent*exp2(-1.0));\n        rgba[1] = 128.0 * mod(Exponent,2.0) + mod(floor(Mantissa*128.0),128.0);\n        rgba[2] = floor(mod(floor(Mantissa*exp2(23.0 -8.0)),exp2(8.0)));\n        rgba[3] = floor(exp2(23.0)*mod(Mantissa,exp2(-15.0)));\n        ${k}\n        rgba = rgba / 255.0; // values need to be normalized to [0,1]\n        return rgba;\n    }\n        `)}}decodeUint8(){const k=A.isLittleEndian()?"rgba.rgba=rgba.abgr;":"";return{decode:new F.GlslLibRoutine(`\n        highp float decode(highp vec4 rgba) {\n          rgba = rgba * 255.0; // values need to be de-normalized from [0,1] to [0,255]\n          ${k}\n          highp float Sign = 1.0 - step(128.0,rgba[0])*2.0;\n          highp float Exponent = 2.0 * mod(rgba[0],128.0) + step(128.0,rgba[1]) - 127.0;\n          highp float Mantissa = mod(rgba[1],128.0)*65536.0 + rgba[2]*256.0 +rgba[3] + float(0x800000);\n          highp float Result =  Sign * exp2(Exponent) * (Mantissa * exp2(-23.0 ));\n          return Result;\n      }\n        `)}}static isLittleEndian(){const k=new ArrayBuffer(4),S=new Uint32Array(k),C=new Uint8Array(k);if(S[0]=3735928559,239===C[0])return!0;if(222===C[0])return!1;throw new Error("unknown endianness")}}E.EncodingGlslLib=A},2691:(me,E,P)=>{"use strict";Object.defineProperty(E,"__esModule",{value:!0}),E.FragColorGlslLib=void 0;const F=P(1997),A=P(6757);E.FragColorGlslLib=class O extends F.GlslLib{constructor(S){super(S)}getFunctions(){return Object.assign(Object.assign({},this.setFragColor()),this.getColorAsFloat())}getCustomTypes(){return{}}setFragColor(){const S=(0,A.getGlsl)(this.context.glContext.version);return{setFragColor:new F.GlslLibRoutine(`\n        void setFragColor(float value) {\n            ${S.output} = encode(value);\n        }\n        `,["encoding.encode"])}}getColorAsFloat(){return{getColorAsFloat:new F.GlslLibRoutine("\n        float getColorAsFloat(vec4 color) {\n            return decode(color);\n        }\n        ",["encoding.decode"])}}}},3878:(me,E)=>{"use strict";Object.defineProperty(E,"__esModule",{value:!0}),E.replaceInlines=void 0;const P=/@inline[\s\n\r]+(\w+)[\s\n\r]+([0-9a-zA-Z_]+)\s*\(([^)]*)\)\s*{(([^}]|[\n\r])*)}/gm;E.replaceInlines=function(F){const A={};let O;for(;null!==(O=P.exec(F));){const k=O[3].split(",").map(S=>{const C=S.trim().split(" ");return C&&2===C.length?{type:C[0],name:C[1]}:null}).filter(S=>null!==S);A[O[2]]={params:k,body:O[4]}}for(const k in A){const S="(\\w+)?\\s+([_0-9a-zA-Z]+)\\s+=\\s+__FUNC__\\((.*)\\)\\s*;".replace("__FUNC__",k),C=new RegExp(S,"gm");for(;null!==(O=C.exec(F));){const v=O[1],b=O[2],h=O[3].split(","),l=v?`${v} ${b};`:"";let d=A[k].body,f="";A[k].params.forEach((w,D)=>{w&&(f+=`${w.type} ${w.name} = ${h[D]};\n`)}),d=`${f}\n ${d}`,d=d.replace("return",`${b} = `),F=F.replace(O[0],`\n      ${l}\n      {\n        ${d}\n      }\n      `)}}return F.replace(P,"")}},8897:(me,E,P)=>{"use strict";Object.defineProperty(E,"__esModule",{value:!0}),E.GlslPreprocessor=void 0;const F=P(1997),A=P(3878),O=P(1248),k=P(6757);E.GlslPreprocessor=class{constructor(S,C,v,b){this.libs={},this.glslLibRoutineDependencyGraph={},this.context=new F.GlslContext(S,C,v,b),Object.keys(O.glslRegistry).forEach(l=>{const d=new O.glslRegistry[l](this.context);this.libs[l]=d});const h=this.glslLibRoutineDependencyGraph;for(const l in this.libs){const d=this.libs[l].getFunctions();for(const f in d){const y=l+"."+f;let w;h[y]?(w=h[y],w.routineBody=d[f].routineBody):(w=new F.GlslLibRoutineNode(y,d[f].routineBody),h[y]=w);const D=d[f].dependencies;if(D)for(let M=0;M<D.length;++M)if(h[D[M]])w.addDependency(h[D[M]]);else{const $=new F.GlslLibRoutineNode(D[M]);h[D[M]]=$,w.addDependency($)}}}}preprocess(){const S=this.context.programInfo;let C=S.shaderSource;return this.context.programInfo.hasMain||(C=`${C}\n      ${(0,k.getDefaultFragShaderMain)(this.context.glContext.version,this.context.outputTextureLayout.shape.length)}`),C=(0,A.replaceInlines)(C),`${(0,k.getFragShaderPreamble)(this.context.glContext.version)}\n    ${this.getUniforms(S.inputNames,S.variables)}\n    ${this.getImports(C)}\n    ${C}`}getImports(S){const C=this.selectGlslLibRoutinesToBeIncluded(S);if(0===C.length)return"";let v="";for(let b=0;b<C.length;++b){if(!C[b].routineBody)throw new Error(`Missing body for the Glsl Library routine: ${C[b].name}`);v+=C[b].routineBody+"\n"}return v}selectGlslLibRoutinesToBeIncluded(S){const C=[];return Object.keys(this.glslLibRoutineDependencyGraph).forEach(v=>{const b=v.split(".")[1];-1!==S.indexOf(b)&&C.push(this.glslLibRoutineDependencyGraph[v])}),F.TopologicalSortGlslRoutines.returnOrderedNodes(C)}getUniforms(S,C){const v=[];if(S)for(const b of S)v.push(`uniform sampler2D ${b};`);if(C)for(const b of C)v.push(`uniform ${b.type} ${b.name}${b.arrayLength?`[${b.arrayLength}]`:""};`);return v.join("\n")}}},1248:(me,E,P)=>{"use strict";Object.defineProperty(E,"__esModule",{value:!0}),E.glslRegistry=void 0;const F=P(6859),A=P(1371),O=P(2691),k=P(9183),S=P(9314);E.glslRegistry={encoding:A.EncodingGlslLib,fragcolor:O.FragColorGlslLib,vec:S.VecGlslLib,shapeUtils:k.ShapeUtilsGlslLib,coordinates:F.CoordsGlslLib}},9183:(me,E,P)=>{"use strict";Object.defineProperty(E,"__esModule",{value:!0}),E.ShapeUtilsGlslLib=void 0;const F=P(1997);class A extends F.GlslLib{constructor(k){super(k)}getFunctions(){return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({},this.bcastIndex()),this.bcastMatmulIndex()),this.offsetToIndices()),this.indicesToOffset()),this.incrementIndices())}getCustomTypes(){return{}}bcastIndex(){const k=this.context.outputTextureLayout.shape.length,S={};return this.context.programInfo.inputNames.forEach((C,v)=>{const b=this.context.inputTextureLayouts[v].unpackedShape;if(b.length<=k){const h=b.length,l=k-h,d=`bcastIndices_${C}`;let f="";for(let w=0;w<h;++w)f+=`\n          realIndices[${w}] = int( mod(float(bcastedIndices[${l+w}]), ${b[w]}.0) );\n          `;S[d]=new F.GlslLibRoutine(`\n        void ${d} (int bcastedIndices[${k}], out int realIndices[${h}]) {\n          ${f}\n        }\n        `)}}),S}bcastMatmulIndex(){const k=this.context.outputTextureLayout.shape.length,S={};return this.context.programInfo.inputNames.forEach((C,v)=>{const b=this.context.inputTextureLayouts[v].shape;if(!(b.length<2||b.length>k)){const h=b.length,l=k-h,d=`bcastMatmulIndices_${C}`;let f="";for(let w=0;w<h-2;++w)f+=`\n          realIndices[${w}] = int( mod(float(bcastedIndices[${l+w}]), ${b[w]}.0) );\n          `;S[d]=new F.GlslLibRoutine(`\n        void ${d}(int bcastedIndices[${k}], out int realIndices[${h}]) {\n          ${f}\n          realIndices[${h-1}] = bcastedIndices[${k-1}];\n          realIndices[${h-2}] = bcastedIndices[${k-2}];\n        }\n        `)}}),S}indicesToOffset(){const k={};return this.context.programInfo.inputNames.forEach((S,C)=>{const b=this.context.inputTextureLayouts[C].strides,h=this.context.inputTextureLayouts[C].shape.length;let l=`indicesToOffset_${S}`;k[l]=new F.GlslLibRoutine(A.indexToOffsetSingle(l,h,b)),l=`indicesToOffset_${S}_T`,k[l]=new F.GlslLibRoutine(A.indexToOffsetSingle(l,h,b.slice().reverse()))}),k}static indexToOffsetSingle(k,S,C){let v="";for(let b=S-1;b>=0;--b)v+=`\n        offset += indices[${b}] * ${C[b]};\n        `;return`\n      int ${k}(int indices[${S}]) {\n        int offset = 0;\n        ${v}\n        return offset;\n      }\n      `}offsetToIndices(){const k={};return this.context.programInfo.inputNames.forEach((S,C)=>{const b=this.context.inputTextureLayouts[C].strides,h=this.context.inputTextureLayouts[C].shape.length;let l=`offsetToIndices_${S}`;k[l]=new F.GlslLibRoutine(A.offsetToIndicesSingle(l,h,b)),l=`offsetToIndices_${S}_T`,k[l]=new F.GlslLibRoutine(A.offsetToIndicesSingle(l,h,b.slice().reverse()))}),k}static offsetToIndicesSingle(k,S,C){const v=[];for(let b=0;b<S-1;++b)v.push(`\n      indices[${b}] = offset / ${C[b]};`),v.push(`\n        offset -= indices[${b}] * ${C[b]};`);return v.push(`\n      indices[${S-1}] = offset;`),`\n      void ${k}(int offset, out int indices[${S}]) {\n        ${v.join("")}\n      }\n      `}incrementIndices(){const k={};return this.context.programInfo.inputNames.forEach((S,C)=>{const v=this.context.inputTextureLayouts[C].shape,b=v.length,h=`incrementIndices_${S}`;let l="";for(let f=0;f<b;++f)l+=`\n        shape[${f}] = ${v[f]};`;k[h]=new F.GlslLibRoutine(`\n        void ${h}(int axis, out int indices[${b}]) {\n          int shape[${b}];\n          ${l};\n          for(int i = ${b} -1 ; i >= 0; --i) {\n            if(i > axis) continue;\n            indices[i] += 1;\n            if(indices[i] < shape[i]) {\n              break;\n            }\n            indices[i] = 0;\n          }\n        }\n        `)}),k}}E.ShapeUtilsGlslLib=A},6757:(me,E)=>{"use strict";Object.defineProperty(E,"__esModule",{value:!0}),E.getDefaultFragShaderMain=E.getFragShaderPreamble=E.getVertexShaderSource=E.getGlsl=void 0;const P={version:"",attribute:"attribute",varyingVertex:"varying",varyingFrag:"varying",texture2D:"texture2D",output:"gl_FragColor",outputDeclaration:""},F={version:"#version 300 es",attribute:"in",varyingVertex:"out",varyingFrag:"in",texture2D:"texture",output:"outputColor",outputDeclaration:"out vec4 outputColor;"};function A(O){return 1===O?P:F}E.getGlsl=A,E.getVertexShaderSource=function(O){const k=A(O);return`${k.version}\n      precision highp float;\n      ${k.attribute} vec3 position;\n      ${k.attribute} vec2 textureCoord;\n\n      ${k.varyingVertex} vec2 TexCoords;\n\n      void main()\n      {\n          gl_Position = vec4(position, 1.0);\n          TexCoords = textureCoord;\n      }`},E.getFragShaderPreamble=function(O){const k=A(O);return`${k.version}\n    precision highp float;\n    precision highp int;\n    precision highp sampler2D;\n    ${k.varyingFrag} vec2 TexCoords;\n    ${k.outputDeclaration}\n    const vec2 halfCR = vec2(0.5, 0.5);\n\n    // Custom vector types to handle higher dimenalities.\n    struct ivec5\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n    };\n\n    struct ivec6\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n      int v;\n    };\n\n    int imod(int x, int y) {\n      return x - y * (x / y);\n    }\n\n    `},E.getDefaultFragShaderMain=function(O,k){return`\n  void main() {\n    int indices[${k}];\n    toVec(TexCoords, indices);\n    vec4 result = vec4(process(indices));\n    ${A(O).output} = result;\n  }\n  `}},9314:(me,E,P)=>{"use strict";Object.defineProperty(E,"__esModule",{value:!0}),E.VecGlslLib=void 0;const F=P(1997);E.VecGlslLib=class A extends F.GlslLib{constructor(k){super(k)}getCustomTypes(){return{}}getFunctions(){return Object.assign(Object.assign(Object.assign(Object.assign({},this.binaryVecFunctions()),this.copyVec()),this.setVecItem()),this.getVecItem())}binaryVecFunctions(){const k=this.context.outputTextureLayout.shape.length,S={add:"+=",sub:"-=",mul:"*=",div:"/="},C={};for(const v in S){const b=`${v}Vec`;let h="";for(let d=0;d<k;++d)h+=`\n          dest[${d}] ${S[v]} src[${d}];\n          `;C[b]=new F.GlslLibRoutine(`\n        void ${b}(int src[${k}], out int dest[${k}]) {\n          ${h}\n        }\n        `)}return C}copyVec(){const k=this.context.outputTextureLayout.shape.length;let S="";for(let v=0;v<k;++v)S+=`\n        dest[${v}] = src[${v}];\n        `;return{copyVec:new F.GlslLibRoutine(`\n      void copyVec(int src[${k}], out int dest[${k}]) {\n        ${S}\n      }\n      `)}}setVecItem(){const k=this.context.outputTextureLayout.shape.length;let S=`\n        if(index < 0)\n            index =${k} + index;\n        if (index == 0)\n            m[0] = value;\n        `;for(let v=1;v<k-1;++v)S+=`\n        else if (index == ${v})\n            m[${v}] = value;\n            `;return S+=`\n        else\n            m[${k-1}] = value;\n        `,{setVecItem:new F.GlslLibRoutine(`\n      void setVecItem(out int m[${k}], int index, int value) {\n        ${S}\n      }\n        `)}}getVecItem(){const k=this.context.outputTextureLayout.shape.length;let S=`\n        if(index < 0)\n            index = ${k} + index;\n        if (index == 0)\n            return m[0];\n      `;for(let v=1;v<k-1;++v)S+=`\n        else if (index == ${v})\n            return m[${v}];\n      `;return S+=`\n        else\n            return m[${k-1}];\n        `,{getVecItem:new F.GlslLibRoutine(`\n      int getVecItem(int m[${k}], int index) {\n        ${S}\n      }\n    `)}}}},7860:(me,E,P)=>{"use strict";Object.defineProperty(E,"__esModule",{value:!0}),E.WebGLInferenceHandler=void 0;const F=P(1315),A=P(9240),O=P(7273),k=P(9),S=P(7379),C=P(2488),v=P(540),b=P(3314),h=P(5639);E.WebGLInferenceHandler=class{constructor(l){this.session=l,this.packedTextureDataCache=new Map,this.unpackedTextureDataCache=new Map}calculateTextureWidthAndHeight(l,d){return(0,b.calculateTextureWidthAndHeight)(this.session.layoutStrategy,l,d)}executeProgram(l,d){if(d.length<l.inputNames.length)throw new Error(`Input size mustn't be less than ${l.inputNames.length}.`);if(l.inputNames.length!==l.inputTypes.length)throw new Error("input names size does not match input types");const f=[];for(let B=0;B<l.inputNames.length;++B)f[B]=this.getOrCreateTextureData(d[B],l.inputTypes[B]);const y=((B,z)=>{const G=z.map(te=>`${te.unpackedShape.join(",")};${te.width}x${te.height}`).join("_");let H=B.name;return B.cacheHint&&(H+="["+B.cacheHint+"]"),H+=":"+G,H})(l,f);let w=this.session.programManager.getArtifact(y);const D=w?w.programInfo:"function"==typeof l.get?l.get():l,M=(0,b.createTextureLayoutFromTextureType)(this.session.layoutStrategy,D.output.dims,D.output.textureType),$=this.createTextureData(M,D.output.type);return w||(w=this.session.programManager.build(D,f,$),this.session.programManager.setArtifact(y,w)),this.runProgram(w,f,$),$}run(l,d){return this.executeProgram(l,d).tensor}runProgram(l,d,f){for(let y=0;y<d.length;++y)if(!!d[y].isPacked!=(l.programInfo.inputTypes[y]===h.TextureType.packed))throw new Error(`input[${y}] property packed inconsistent`);if(!!f.isPacked!=(l.programInfo.output.textureType===h.TextureType.packed))throw new Error("output property packed inconsistent");this.session.programManager.run(l,d,f)}getOrCreateTextureData(l,d){let f=this.getTextureData(l.dataId,d===h.TextureType.packed);if(!f&&(f=this.getTextureData(l.dataId,d!==h.TextureType.packed),f))return d===h.TextureType.packed?this.pack(f):this.unpack(f);if(!f){const y=(0,b.createTextureLayoutFromTextureType)(this.session.layoutStrategy,l.dims,d);if(d===h.TextureType.packedLastDimension){const M=l.dims;if(4===M.length){const $=[M[0],Math.ceil(M[1]*M[2]*M[3]/4)],B=(0,b.createTextureLayoutFromTextureType)(this.session.layoutStrategy,$,d);let z=l.numberData;if(M[1]*M[2]*M[3]%4!=0){const G=M[0],H=M[1]*M[2]*M[3],te=4*Math.ceil(1*H/4);z=new Float32Array(G*te);for(let ae=0;ae<G;++ae){const J=ae*H,ne=ae*te+ae%1*H;z.set(l.numberData.subarray(J,J+H),ne)}}return this.createTextureData(B,l.type,z,l,1)}}if(d===h.TextureType.packed){const w=(0,b.createTextureLayoutFromShape)(this.session.layoutStrategy,l.dims,1,[],{reverseWH:!0}),D=this.createTextureData(w,l.type,l.numberData,l,1);f=this.pack(D)}else f=this.createTextureData(y,l.type,l.numberData,l,1)}return f}createTextureDataFromLayoutBindTensor(l,d,f,y){return this.createTextureData(l,d,f,y,1)}createTextureData(l,d,f,y,w){F.Logger.verbose("InferenceHandler",`Creating TextureData: layout:[${JSON.stringify(l)}]`);const D=this.session.textureManager.createTextureFromLayout(d,l,f,w);return this.createTextureDataFromTexture(l,d,D,y)}reshapeUnpacked(l,d){const f=this.getOrCreateTextureData(l,h.TextureType.unpacked),y={channels:f.channels,height:f.height,width:f.width,shape:0!==d.length?d:[1],strides:O.ShapeUtil.computeStrides(d),unpackedShape:d};return this.createTextureDataFromTexture(y,l.type,f.texture).tensor}reshapePacked(l,d){const f=this.getOrCreateTextureData(l,h.TextureType.packed);if((0,S.isReshapeCheap)(l.dims,d)){const $={channels:f.channels,height:f.height,width:f.width,shape:0!==d.length?d:[1],strides:O.ShapeUtil.computeStrides(d),unpackedShape:d,isPacked:!0};return this.createTextureDataFromTexture($,l.type,f.texture).tensor}const y=(0,S.processDims3D)(l.dims),w=(0,S.processDims3D)(d),D=this.reshapePacked(l,y),M=this.run((0,S.createPackedReshape3DProgramInfoLoader)(this,D,w),[D]);return this.reshapePacked(M,d)}cast(l,d){const f=this.getOrCreateTextureData(l,h.TextureType.unpacked);return this.createTextureDataFromTexture(f,d,f.texture).tensor}createTextureDataFromTexture(l,d,f,y,w){var D=this;const M=Object.assign(Object.assign({},l),{tensor:y||new A.Tensor(l.unpackedShape,d,$=>this.readTexture(M),function(){var $=_asyncToGenerator(function*(B){return D.readTextureAsync(M)});return function(B){return $.apply(this,arguments)}}(),void 0,w),texture:f});return this.setTextureData(M.tensor.dataId,M,l.isPacked),M}getTextureData(l,d=!1){return this.session.isInitializer(l)?this.session.getTextureData(l,d):d?this.packedTextureDataCache.get(l):this.unpackedTextureDataCache.get(l)}setTextureData(l,d,f=!1){this.session.isInitializer(l)?this.session.setTextureData(l,d,f):(f?this.packedTextureDataCache:this.unpackedTextureDataCache).set(l,d)}isTextureLayoutCached(l,d=!1){return!!this.getTextureData(l.dataId,d)}dispose(){this.session.textureManager.clearActiveTextures(),this.packedTextureDataCache.forEach(l=>this.session.textureManager.releaseTexture(l)),this.packedTextureDataCache=new Map,this.unpackedTextureDataCache.forEach(l=>this.session.textureManager.releaseTexture(l)),this.unpackedTextureDataCache=new Map}readTexture(l){return l.isPacked?this.readTexture(this.unpack(l)):this.session.backend.glContext.isFloat32DownloadSupported?this.session.textureManager.readTexture(l,l.tensor.type,l.channels):this.session.textureManager.readUint8TextureAsFloat((0,C.encodeAsUint8)(this,l))}readTextureAsync(l){var d=this;return _asyncToGenerator(function*(){return l.isPacked?d.readTextureAsync(d.unpack(l)):d.session.backend.glContext.isFloat32DownloadSupported?d.session.textureManager.readTextureAsync(l,l.tensor.type,l.channels):d.session.textureManager.readUint8TextureAsFloat((0,C.encodeAsUint8)(d,l))})()}pack(l){return this.executeProgram((0,k.createPackProgramInfoLoader)(this,l.tensor),[l.tensor])}unpack(l){return this.executeProgram((0,v.createUnpackProgramInfoLoader)(this,l.tensor),[l.tensor])}}},4110:function(me,E,P){"use strict";var F=this&&this.__createBinding||(Object.create?function(ot,nt,it,yt){void 0===yt&&(yt=it);var wt=Object.getOwnPropertyDescriptor(nt,it);wt&&!("get"in wt?!nt.__esModule:wt.writable||wt.configurable)||(wt={enumerable:!0,get:function(){return nt[it]}}),Object.defineProperty(ot,yt,wt)}:function(ot,nt,it,yt){void 0===yt&&(yt=it),ot[yt]=nt[it]}),A=this&&this.__setModuleDefault||(Object.create?function(ot,nt){Object.defineProperty(ot,"default",{enumerable:!0,value:nt})}:function(ot,nt){ot.default=nt}),O=this&&this.__importStar||function(ot){if(ot&&ot.__esModule)return ot;var nt={};if(null!=ot)for(var it in ot)"default"!==it&&Object.prototype.hasOwnProperty.call(ot,it)&&F(nt,ot,it);return A(nt,ot),nt};Object.defineProperty(E,"__esModule",{value:!0}),E.WEBGL_OP_RESOLVE_RULES=void 0;const k=P(8817),S=O(P(5194)),C=P(4752),v=P(6668),b=P(9754),h=P(5042),l=P(6742),d=P(4125),f=P(6149),y=P(5378),w=P(6981),D=P(7413),M=P(7006),$=P(8276),B=P(5565),z=P(2834),G=P(1010),H=P(8126),te=P(2801),ae=P(565),J=P(2444),ne=P(815),X=P(564),K=P(5416),ve=P(1240),q=P(5944),re=P(5707),le=O(P(9087)),He=P(7862),Le=P(3980);E.WEBGL_OP_RESOLVE_RULES=[["Abs","","6+",le.abs],["Acos","","7+",le.acos],["Add","","7+",S.add],["And","","7+",S.and],["Asin","","7+",le.asin],["Atan","","7+",le.atan],["AveragePool","","7+",z.averagePool,z.parseAveragePoolAttributes],["BatchNormalization","","7+",k.batchNormalization,k.parseBatchNormalizationAttributes],["Cast","","6+",C.cast,C.parseCastAttributes],["Ceil","","6+",le.ceil],["Clip","","6-10",le.clip,le.parseClipAttributes],["Clip","","11+",le.clipV11],["Concat","","4+",v.concat,v.parseConcatAttributes],["Conv","","1+",b.conv,b.parseConvAttributes],["ConvTranspose","","1+",h.convTranspose,h.parseConvTransposeAttributes],["Cos","","7+",le.cos],["Div","","7+",S.div],["Dropout","","7+",le.identity],["DepthToSpace","","1+",l.depthToSpace,l.parseDepthToSpaceAttributes],["Equal","","7+",S.equal],["Elu","","6+",le.elu,le.parseEluAttributes],["Exp","","6+",le.exp],["Flatten","","1+",d.flatten,d.parseFlattenAttributes],["Floor","","6+",le.floor],["FusedConv","com.microsoft","1+",b.conv,b.parseConvAttributes],["Gather","","1+",f.gather,f.parseGatherAttributes],["Gemm","","7-10",y.gemm,y.parseGemmAttributesV7],["Gemm","","11+",y.gemm,y.parseGemmAttributesV11],["GlobalAveragePool","","1+",z.globalAveragePool,z.parseGlobalAveragePoolAttributes],["GlobalMaxPool","","1+",z.globalMaxPool],["Greater","","7+",S.greater],["Identity","","1+",le.identity],["ImageScaler","","1+",w.imageScaler,w.parseImageScalerAttributes],["InstanceNormalization","","6+",D.instanceNormalization,D.parseInstanceNormalizationAttributes],["LeakyRelu","","6+",le.leakyRelu,le.parseLeakyReluAttributes],["Less","","7+",S.less],["LRN","","1+",M.lrn,M.parseLrnAttributes],["Log","","6+",le.log],["MatMul","","1+",$.matMul,$.parseMatMulAttributes],["MaxPool","","1+",z.maxPool,z.parseMaxPoolAttributes],["Mul","","7+",S.mul],["Neg","","6+",le.neg],["Not","","1+",le.not],["Or","","7+",S.or],["Pad","","2-10",B.padV2,B.parsePadAttributesV2],["Pad","","11+",B.padV11,B.parsePadAttributesV11],["Pow","","7+",S.pow],["PRelu","","7+",S.pRelu],["ReduceLogSum","","1+",G.reduceLogSum,G.parseReduceAttributes],["ReduceMax","","1+",G.reduceMax,G.parseReduceAttributes],["ReduceMean","","1+",G.reduceMean,G.parseReduceAttributes],["ReduceMin","","1+",G.reduceMin,G.parseReduceAttributes],["ReduceProd","","1+",G.reduceProd,G.parseReduceAttributes],["ReduceSum","","1-12",G.reduceSum,G.parseReduceAttributes],["ReduceSumSquare","","1+",G.reduceLogSumSquare,G.parseReduceAttributes],["Relu","","6+",le.relu],["Reshape","","5+",H.reshape],["Resize","","10",te.resize,te.parseResizeAttributesV10],["Resize","","11+",te.resize,te.parseResizeAttributesV11],["Shape","","1+",ae.shape],["Sigmoid","","6+",le.sigmoid],["Sin","","7+",le.sin],["Slice","","10+",J.sliceV10],["Slice","","1-9",J.slice,J.parseSliceAttributes],["Softmax","","1-12",ne.softmax,ne.parseSoftmaxAttributes],["Softmax","","13+",ne.softmaxV13,ne.parseSoftmaxAttributesV13],["Split","","2-12",X.split,X.parseSplitAttributes],["Sqrt","","6+",le.sqrt],["Squeeze","","1-12",K.squeeze,K.parseSqueezeAttributes],["Squeeze","","13+",K.squeezeV13],["Sub","","7+",S.sub],["Sum","","6+",ve.sum],["Tan","","7+",le.tan],["Tanh","","6+",le.tanh],["Tile","","6+",q.tile],["Transpose","","1+",re.transpose,re.parseTransposeAttributes],["Upsample","","7-8",Le.upsample,Le.parseUpsampleAttributesV7],["Upsample","","9",Le.upsample,Le.parseUpsampleAttributesV9],["Unsqueeze","","1-12",He.unsqueeze,He.parseUnsqueezeAttributes],["Unsqueeze","","13+",He.unsqueezeV13],["Xor","","7+",S.xor]]},8817:(me,E,P)=>{"use strict";Object.defineProperty(E,"__esModule",{value:!0}),E.parseBatchNormalizationAttributes=E.batchNormalization=void 0;const F=P(4910),A=P(6757),O=P(5639),k={name:"BatchNormalization",inputNames:["A","Scale","B","Mean","Variance"],inputTypes:[O.TextureType.unpacked,O.TextureType.unpacked,O.TextureType.unpacked,O.TextureType.unpacked,O.TextureType.unpacked]};E.batchNormalization=(v,b,h)=>(C(b),[v.run(Object.assign(Object.assign({},k),{cacheHint:h.cacheKey,get:()=>S(v,b,h)}),b)]),E.parseBatchNormalizationAttributes=v=>{const b=v.attributes.getFloat("epsilon",1e-5),h=v.attributes.getFloat("momentum",.9),l=v.attributes.getInt("spatial",1);return(0,F.createAttributeWithCacheKey)({epsilon:b,momentum:h,spatial:l})};const S=(v,b,h)=>{const l=(0,A.getGlsl)(v.session.backend.glContext.version),d=b[0].dims.length,[f,y]=v.calculateTextureWidthAndHeight(b[1].dims,O.TextureType.unpacked),w=`\n  float process(int[${d}] indices) {\n    vec2 position = offsetToCoords(indices[1], ${f}, ${y});\n    float scale = getColorAsFloat(${l.texture2D}(Scale, position));\n    float mean = getColorAsFloat(${l.texture2D}(Mean, position));\n    float variance = getColorAsFloat(${l.texture2D}(Variance, position));\n    float b = getColorAsFloat(${l.texture2D}(B, position));\n\n    return scale * ( (_A(indices) - mean) / sqrt(variance + float(${h.epsilon})) ) + b;\n  }`;return Object.assign(Object.assign({},k),{output:{dims:b[0].dims,type:b[0].type,textureType:O.TextureType.unpacked},shaderSource:w})},C=v=>{if(!v||5!==v.length)throw new Error("BatchNormalization requires 5 inputs.");const b=v[0],h=v[1],l=v[2],d=v[3],f=v[4];if(b.dims.length<3||1!==h.dims.length||1!==l.dims.length||1!==d.dims.length||1!==f.dims.length)throw new Error("invalid input shape.");if(h.dims[0]!==b.dims[1]||l.dims[0]!==b.dims[1]||d.dims[0]!==b.dims[1]||f.dims[0]!==b.dims[1])throw new Error("invalid input shape.");if("float32"!==b.type&&"float64"!==b.type||"float32"!==h.type&&"float64"!==h.type||"float32"!==l.type&&"float64"!==l.type||"float32"!==d.type&&"float64"!==d.type||"float32"!==f.type&&"float64"!==f.type)throw new Error("invalid input tensor types.")}},5194:(me,E,P)=>{"use strict";Object.defineProperty(E,"__esModule",{value:!0}),E.xor=E.sub=E.pRelu=E.pow=E.or=E.mul=E.less=E.greater=E.equal=E.div=E.and=E.add=E.glslPRelu=E.glslPow=E.glslXor=E.glslOr=E.glslAnd=E.glslLess=E.glslGreater=E.glslEqual=E.glslSub=E.glslMul=E.glslDiv=E.glslAdd=void 0;const F=P(7273),A=P(1997),O=P(6757),k=P(5639);function S(){const z="add_";return{body:`\n  float ${z}(float a, float b) {\n    return a + b;\n  }\n  vec4 ${z}(vec4 v1, vec4 v2) {\n    return v1 + v2;\n  }\n  `,name:z,type:A.FunctionType.ValueBased}}function C(){const z="div_";return{body:`\n  float ${z}(float a, float b) {\n    return a / b;\n  }\n  vec4 ${z}(vec4 v1, vec4 v2) {\n    return v1 / v2;\n  }\n  `,name:z,type:A.FunctionType.ValueBased}}function v(){const z="mul_";return{body:`\n  float ${z}(float a, float b) {\n    return a * b;\n  }\n  vec4 ${z}(vec4 v1, vec4 v2) {\n    return v1 * v2;\n  }\n  `,name:z,type:A.FunctionType.ValueBased}}function b(){const z="sub_";return{body:`\n  float ${z}(float a, float b) {\n    return a - b;\n  }\n  vec4 ${z}(vec4 v1, vec4 v2) {\n    return v1 - v2;\n  }\n  `,name:z,type:A.FunctionType.ValueBased}}function h(){const z="equal_";return{body:`\n  float ${z}(float a, float b) {\n    return float(a == b);\n  }\n  vec4 ${z}(vec4 v1, vec4 v2) {\n    return vec4(equal(v1, v2));\n  }\n  `,name:z,type:A.FunctionType.ValueBased}}function l(){const z="greater_";return{body:`\n  float ${z}(float a, float b) {\n    return float(a > b);\n  }\n  vec4 ${z}(vec4 v1, vec4 v2) {\n    return vec4( v1.r > v2.r ,\n      v1.g > v2.g,\n      v1.b > v2.b,\n      v1.a > v2.a );\n  }\n  `,name:z,type:A.FunctionType.ValueBased}}function d(){const z="less_";return{body:`\n  float ${z}(float a, float b) {\n    return float(a < b);\n  }\n  vec4 ${z}(vec4 v1, vec4 v2) {\n    return vec4( v1.r < v2.r ,\n                v1.g < v2.g,\n                v1.b < v2.b,\n                v1.a < v2.a );\n  }\n  `,name:z,type:A.FunctionType.ValueBased}}function f(){const z="and_";return{body:`\n  float ${z}(float a, float b) {\n    return float( bool(a) && bool(b) );\n  }\n  vec4 ${z}(vec4 v1, vec4 v2) {\n    bvec4 b1 = bvec4(v1);\n    bvec4 b2 = bvec4(v2);\n    return vec4( b1.r && b2.r ,\n                b1.g && b2.g,\n                b1.b && b2.b,\n                b1.a && b2.a );\n  }\n  `,name:z,type:A.FunctionType.ValueBased}}function y(){const z="or_";return{body:`\n  float ${z}(float a, float b) {\n    return float( bool(a) || bool(b) );\n  }\n  vec4 ${z}(vec4 v1, vec4 v2) {\n    bvec4 b1 = bvec4(v1);\n    bvec4 b2 = bvec4(v2);\n    return vec4( b1.r || b2.r ,\n                b1.g || b2.g,\n                b1.b || b2.b,\n                b1.a || b2.a );\n  }\n  `,name:z,type:A.FunctionType.ValueBased}}function w(){const z="xor_";return{body:`\n  float ${z}(float a, float b) {\n    return float( bool(a) ^^ bool(b) );\n  }\n  vec4 ${z}(vec4 v1, vec4 v2) {\n    bvec4 b1 = bvec4(v1);\n    bvec4 b2 = bvec4(v2);\n    return vec4( b1.r ^^ b2.r ,\n                b1.g ^^ b2.g,\n                b1.b ^^ b2.b,\n                b1.a ^^ b2.a );\n  }\n  `,name:z,type:A.FunctionType.ValueBased}}function D(){return function(z){const G=`${z}_`;return{body:`\n  float ${G}(float a, float b) {\n    return ${z}(a, b);\n  }\n  vec4 ${G}(vec4 v1, vec4 v2) {\n    return ${z}(v1, v2);\n  }\n  `,name:G,type:A.FunctionType.ValueBased}}("pow")}function M(){const z="prelu_";return{body:`\n  float ${z}(float a, float b) {\n    return a < 0.0 ? a * b: a;\n  }\n  vec4 ${z}(vec4 v1, vec4 v2) {\n    return vec4(\n      v1.r < 0.0 ? v1.r * v2.r: v1.r,\n      v1.g < 0.0 ? v1.g * v2.g: v1.g,\n      v1.b < 0.0 ? v1.b * v2.b: v1.b,\n      v1.a < 0.0 ? v1.a * v2.a: v1.a\n      );\n  }\n  `,name:z,type:A.FunctionType.ValueBased}}E.glslAdd=S,E.glslDiv=C,E.glslMul=v,E.glslSub=b,E.glslEqual=h,E.glslGreater=l,E.glslLess=d,E.glslAnd=f,E.glslOr=y,E.glslXor=w,E.glslPow=D,E.glslPRelu=M;const $=(z,G,H,te=G[0].type,ae)=>{const J=z.session.pack?k.TextureType.packed:k.TextureType.unpacked;return{name:H.name,inputNames:["A","B"],inputTypes:[J,J],cacheHint:ae,get:()=>B(z,G,H,te)}},B=(z,G,H,te=G[0].type)=>{const ae=z.session.pack?k.TextureType.packed:k.TextureType.unpacked,J=!F.ShapeUtil.areEqual(G[0].dims,G[1].dims);let ne=G[0].dims;const X=z.session.pack;if(J){const q=F.BroadcastUtil.calcShape(G[0].dims,G[1].dims,!1);if(!q)throw new Error("Can't perform binary op on the given tensors");ne=q;const re=ne.length,le=0!==G[0].dims.length?G[0].dims.length:1,He=0!==G[1].dims.length?G[1].dims.length:1,Le=0!==G[0].dims.length?"bcastIndices_A(indices, aindices);":"aindices[0] = 0;",ot=0!==G[1].dims.length?"bcastIndices_B(indices, bindices);":"bindices[0] = 0;",nt=(0,O.getGlsl)(z.session.backend.glContext.version);return{name:H.name,inputNames:["A","B"],inputTypes:[ae,ae],output:{dims:ne,type:te,textureType:ae},shaderSource:X?`\n      ${H.body}\n      void main() {\n        vec4 a = getAAtOutCoords();\n        vec4 b = getBAtOutCoords();\n        vec4 result = ${H.name}(a, b);\n        ${nt.output} = result;\n      }`:`\n      ${H.body}\n      float process(int indices[${re}]) {\n        int aindices[${le}];\n        int bindices[${He}];\n        ${Le}\n        ${ot}\n        return ${H.name}(_A(aindices), _B(bindices));\n      }`,hasMain:X}}const K=(0,O.getGlsl)(z.session.backend.glContext.version);return{name:H.name,inputNames:["A","B"],inputTypes:[ae,ae],output:{dims:G[0].dims,type:te,textureType:ae},shaderSource:`\n    ${H.body}\n    void main() {\n      vec4 v1 = ${K.texture2D}(A, TexCoords);\n      vec4 v2 = ${K.texture2D}(B, TexCoords);\n      vec4 result = ${H.name}(v1, v2);\n      ${K.output} = result;\n    }\n    `,hasMain:!0}};E.add=(z,G)=>[z.run($(z,G,S()),G)],E.and=(z,G)=>[z.run($(z,G,f(),"bool"),G)],E.div=(z,G)=>[z.run($(z,G,C()),G)],E.equal=(z,G)=>[z.run($(z,G,h(),"bool"),G)],E.greater=(z,G)=>[z.run($(z,G,l(),"bool"),G)],E.less=(z,G)=>[z.run($(z,G,d(),"bool"),G)],E.mul=(z,G)=>[z.run($(z,G,v()),G)],E.or=(z,G)=>[z.run($(z,G,y(),"bool"),G)],E.pow=(z,G)=>[z.run($(z,G,D()),G)],E.pRelu=(z,G)=>[z.run($(z,G,M()),G)],E.sub=(z,G)=>[z.run($(z,G,b()),G)],E.xor=(z,G)=>[z.run($(z,G,w(),"bool"),G)]},4752:(me,E,P)=>{"use strict";Object.defineProperty(E,"__esModule",{value:!0}),E.parseCastAttributes=E.cast=void 0;const F=P(7273);E.cast=(O,k,S)=>(A(k),[O.cast(k[0],S)]),E.parseCastAttributes=O=>F.ProtoUtil.tensorDataTypeFromProto(O.attributes.getInt("to"));const A=O=>{if(!O||1!==O.length)throw new Error("Cast requires 1 input.");if("string"===O[0].type)throw new Error("Invalid input type.")}},4595:(me,E,P)=>{"use strict";Object.defineProperty(E,"__esModule",{value:!0}),E.createPackedConcatProgramInfoLoader=void 0;const F=P(6757),A=P(5639),O=P(432),k=P(5614);E.createPackedConcatProgramInfoLoader=(C,v,b)=>{const h=(l=v.length,d=b.cacheKey,{name:"Concat (packed)",inputNames:Array.from({length:l},(f,y)=>`X${y}`),inputTypes:Array(l).fill(A.TextureType.packed),cacheHint:d});var l,d;return Object.assign(Object.assign({},h),{get:()=>((f,y,w,D)=>{const M=w[0].dims.slice();if(D>=M.length||D<-1*M.length)throw new Error("axis specified for concat doesn't match input dimensionality");D<0&&(D=M.length+D);const $=M.slice(0);for(let Le=1;Le<w.length;Le++){const ot=w[Le].dims.slice();for(let nt=0;nt<M.length;nt++)if(nt===D)$[D]+=ot[nt];else if(M[nt]!==ot[nt])throw new Error("non concat dimensions must match")}const B=$.length,z=(0,k.getChannels)("coords",B),G=(0,O.getCoordsDataType)(B),H=(0,k.unpackFromChannel)(),te=w.map(Le=>Le.dims),ae=(0,O.getGlChannels)(B),J=new Array(te.length-1);J[0]=te[0][D];for(let Le=1;Le<J.length;Le++)J[Le]=J[Le-1]+te[Le][D];const ne=ae[D],X=ae.slice(-2),K=ae.join();let ve=`if (${ne} < ${J[0]}) {\n        return getChannel(\n            getX0(${K}), vec2(${X.join()}));\n        }`;for(let Le=1;Le<J.length;Le++){const ot=J[Le-1];ve+=`\n            if (${ne} < ${J[Le]}  && ${ne} >= ${J[Le-1]}) {\n              return getChannel(\n                getX${Le}(${S(ae,ne,ot)}),\n                vec2(${S(X,ne,ot)}));\n            }`}const re=J[J.length-1];ve+=`\n            return getChannel(\n              getX${J.length}(${S(ae,ne,re)}),\n              vec2(${S(X,ne,re)}));`;const le=(0,F.getGlsl)(f.session.backend.glContext.version),He=`\n          ${H}\n          float getValue(${ae.map(Le=>"int "+Le)}) {\n            ${ve}\n          }\n\n          void main() {\n            ${G} coords = getOutputCoords();\n            int lastDim = coords.${ae[B-1]};\n            coords.${ae[B-1]} = coords.${ae[B-2]};\n            coords.${ae[B-2]} = lastDim;\n\n            vec4 result = vec4(getValue(${z}), 0., 0., 0.);\n\n            ${z[B-1]} = ${z[B-1]} + 1;\n            if (${z[B-1]} < ${$[B-1]}) {\n              result.g = getValue(${z});\n            }\n\n            ${z[B-2]} = ${z[B-2]} + 1;\n            if (${z[B-2]} < ${$[B-2]}) {\n              result.a = getValue(${z});\n            }\n\n            ${z[B-1]} = ${z[B-1]} - 1;\n            if (${z[B-2]} < ${$[B-2]} &&\n                ${z[B-1]} < ${$[B-1]}) {\n              result.b = getValue(${z});\n            }\n            ${le.output} = result;\n          }\n        `;return Object.assign(Object.assign({},y),{output:{dims:$,type:w[0].type,textureType:A.TextureType.packed},shaderSource:He,hasMain:!0})})(C,h,v,b.axis)})};const S=(C,v,b)=>{const h=C.indexOf(v);return C.map((l,d)=>d===h?`${l} - ${b}`:l).join()}},6668:(me,E,P)=>{"use strict";Object.defineProperty(E,"__esModule",{value:!0}),E.parseConcatAttributes=E.concat=void 0;const F=P(4910),A=P(5639),O=P(4595);E.concat=(l,d,f)=>(h(d),l.session.pack&&d[0].dims.length>1?[l.run((0,O.createPackedConcatProgramInfoLoader)(l,d,f),d)]:[l.run(k(l,d,f),d)]);const k=(l,d,f)=>{const y=(w=d.length,D=f.cacheKey,{name:"Concat",inputNames:Array.from({length:w},(M,$)=>`X${$}`),inputTypes:Array(w).fill(A.TextureType.unpacked),cacheHint:D});var w,D;return Object.assign(Object.assign({},y),{get:()=>((M,$,B,z)=>{const G=B[0].dims.slice();if(z>=G.length||z<-1*G.length)throw new Error("axis specified for concat doesn't match input dimensionality");z<0&&(z=G.length+z);const H=G.slice(0);for(let K=1;K<B.length;K++){const ve=B[K].dims.slice();for(let q=0;q<G.length;q++)if(q===z)H[z]+=ve[q];else if(G[q]!==ve[q])throw new Error("non concat dimensions must match")}const te=H.length,ae=new Array(B.length);let J=0;for(let K=0;K<ae.length;++K)J+=B[K].dims[z],ae[K]=J;let ne="";ne=B.length<5?S(ae):C(ae);const X=`\n        ${v(B.length,te)}\n        ${b(ae)}\n        ${ne}\n        float process(int indices[${te}]) {\n          int textureIndex = getTextureWhereDataResides (indices[${z}]);\n\n          if(textureIndex != 0) {\n            indices[${z}] = indices[${z}] - int(getSizeInConcatAxisValueFromIndex(textureIndex-int(1)));\n          }\n\n          return fetchDataFromCorrectTexture(textureIndex, indices);\n        }`;return Object.assign(Object.assign({},$),{output:{dims:H,type:B[0].type,textureType:A.TextureType.unpacked},shaderSource:X})})(0,y,d,f.axis)})},S=l=>`int getTextureWhereDataResides(int index) {\n      ${l.map((d,f)=>`if(index<${d}) {return ${f};}\n`).join("")}\n    }`,C=l=>S(l),v=(l,d)=>{const f=[`float fetchDataFromCorrectTexture(int textureIndex, int indices[${d}]) {`];for(let y=0;y<l;++y)f.push(0===y?`\tif (textureIndex == ${y}) { return _X${y}(indices); }`:y===l-1?`\telse { return _X${y}(indices); }`:`\telse if (textureIndex == ${y}) { return _X${y}(indices); }`);return f.push("\t}"),f.join("\n")},b=l=>{const d=["int getSizeInConcatAxisValueFromIndex(int index) {"];for(let f=0;f<l.length;++f)d.push(0===f?`\tif (index == ${f}) { return ${l[f]}; }`:f===l.length-1?`\telse { return ${l[f]}; }`:`\telse if (index == ${f}) { return ${l[f]}; }`);return d.push("\t}"),d.join("\n")};E.parseConcatAttributes=l=>(0,F.createAttributeWithCacheKey)({axis:l.attributes.getInt("axis")});const h=l=>{if(!l||l.length<1)throw new Error("too few inputs");const d=l[0].type,f=l[0].dims.length;if("string"===d)throw new Error("string tensor is not supported yet");for(const y of l){if(y.type!==d)throw new Error("input tensors should be one type");if(y.dims.length!==f)throw new Error("input tensors should have the same shape")}}},7825:(me,E,P)=>{"use strict";Object.defineProperty(E,"__esModule",{value:!0}),E.createUnpackedGroupedConvProgramInfoLoader=void 0;const F=P(1315),A=P(6757),O=P(5639),k=P(9754),S=P(2150);E.createUnpackedGroupedConvProgramInfoLoader=(C,v,b)=>{const h={name:"GroupedConv",inputNames:(l=v.length>2)?["X","W","Bias"]:["X","W"],inputTypes:l?[O.TextureType.unpacked,O.TextureType.unpacked,O.TextureType.unpacked]:[O.TextureType.unpacked,O.TextureType.unpacked],cacheHint:b.cacheKey};var l;return Object.assign(Object.assign({},h),{get:()=>((f,y,w,D)=>{const M=y.length>2?"value += getBias(output_channel);":"",$=y[0].dims.slice(),B=y[1].dims.slice(),z=B[0]/D.group;F.Logger.verbose("GroupedConv",`autpPad:${D.autoPad}, dilations:${D.dilations}, group:${D.group}, kernelShape:${D.kernelShape}, pads:${D.pads}, strides:${D.strides}`);const G=(0,k.calculateOutputShape)($,B,D.dilations,D.pads,D.strides),H=(0,A.getGlsl)(f.session.backend.glContext.version),{activationFunction:te,applyActivation:ae}=(0,S.getActivationSnippet)(D),J=`\n  const ivec2 strides = ivec2(${D.strides[0]}, ${D.strides[1]});\n  const ivec2 pads = ivec2(${D.pads[0]}, ${D.pads[1]});\n  ${te}\n  void main() {\n    ivec4 coords = getOutputCoords();\n    int batch = coords.x;\n    int output_channel = coords.y;\n    ivec2 xRCCorner = coords.zw * strides - pads;\n    int group_id = output_channel / ${z};\n\n    float value = 0.0;\n    for (int wInChannel = 0; wInChannel < ${B[1]}; wInChannel++) {\n      int input_channel = group_id * ${B[1]} + wInChannel;\n      for (int wHeight = 0; wHeight < ${B[2]}; wHeight++) {\n        int xHeight = xRCCorner.x + wHeight * ${D.dilations[0]};\n\n        if (xHeight < 0 || xHeight >= ${$[2]}) {\n          continue;\n        }\n\n        for (int wWidth = 0; wWidth < ${B[3]}; wWidth++) {\n          int xWidth = xRCCorner.y + wWidth * ${D.dilations[1]};\n          if (xWidth < 0 || xWidth >= ${$[3]}) {\n            continue;\n          }\n\n          float xVal = getX(batch, input_channel, xWidth, xHeight);\n          float wVal = getW(output_channel, wInChannel, wWidth, wHeight);\n          value += xVal*wVal;\n        }\n      }\n    }\n    ${M}\n    ${ae}\n    ${H.output} = vec4(value, .0, .0, .0);\n  }\n`;return Object.assign(Object.assign({},w),{output:{dims:G,type:y[0].type,textureType:O.TextureType.unpacked},shaderSource:J,hasMain:!0})})(C,v,h,b)})}},7708:(me,E,P)=>{"use strict";Object.defineProperty(E,"__esModule",{value:!0}),E.conv2DPacked=E.conv2DPackedPointwise=void 0;const F=P(9754),A=P(5950),O=P(5632);E.conv2DPackedPointwise=(k,S,C)=>{const v=S[0].dims,b=S[1].dims,h=(0,F.calculateOutputShape)(v,b,C.dilations,C.pads,C.strides),l=k.reshapePacked(S[0],[v[1],v[2]*v[3]]),d=k.reshapePacked(S[1],[b[0],b[1]]),f=S.length>2?[d,l,S[2]]:[d,l],y=k.run((0,O.createPackedMatmulProgramInfoLoader)(k,f,C),f);return k.reshapePacked(y,h)},E.conv2DPacked=(k,S,C)=>{const b=S[1].dims,h=(0,F.calculateOutputShape)(S[0].dims,b,C.dilations,C.pads,C.strides),l=k.run((0,A.createPackedIm2ColProgramInfoLoader)(k,S[0],S[1],h,C),[S[0]]),d=k.reshapePacked(S[1],[b[0],b[1]*b[2]*b[3]]),f=3===S.length?[d,l,S[2]]:[d,l],y=k.run((0,O.createPackedMatmulProgramInfoLoader)(k,f,C),f);return k.reshapePacked(y,h)}},5042:(me,E,P)=>{"use strict";Object.defineProperty(E,"__esModule",{value:!0}),E.parseConvTransposeAttributes=E.convTranspose=void 0;const F=P(4910),A=P(6757),O=P(5639),k=P(2150),S=(d,f,y,w,D,M)=>(d-1)*f+y+(w-1)*D+1-M,C=(d,f,y,w,D)=>{const M=Math.floor(d/2);"SAME_UPPER"===f?(y[w]=M,y[D]=d-M):"SAME_LOWER"===f&&(y[w]=d-M,y[D]=M)};E.convTranspose=(d,f,y)=>(l(f,y),v(d,f,y));const v=(d,f,y)=>{const w=h(y,f);return[b(d,f,w)]},b=(d,f,y)=>d.run(((w,D,M)=>{const $={name:"ConvTranspose",inputNames:(B=D.length>2)?["X","W","B"]:["X","W"],inputTypes:B?[O.TextureType.unpacked,O.TextureType.unpacked,O.TextureType.unpacked]:[O.TextureType.unpacked,O.TextureType.unpacked],cacheHint:M.cacheKey};var B;return Object.assign(Object.assign({},$),{get:()=>((G,H,te,ae)=>{const J=H.length>2?"getB(output_channel)":"0.0",ne=H[0].dims,X=H[1].dims,K=X[1],ve=X[0]/ae.group,q=[H[0].dims[0],H[1].dims[1]*ae.group,...ae.outputShape],re=(0,A.getGlsl)(G.session.backend.glContext.version),{activationFunction:le,applyActivation:He}=(0,k.getActivationSnippet)(ae),Le=`\n  const ivec2 strides = ivec2(${ae.strides[0]}, ${ae.strides[1]});\n  const ivec2 pads = ivec2(${ae.pads[0]}, ${ae.pads[1]});\n  ${le}\n  void main() {\n    ivec4 coords = getOutputCoords();\n    int batch = coords.x;\n    int output_channel = coords.y;\n\n    ivec2 loc = coords.zw + pads;\n\n    int group_id = output_channel / ${K};\n    int wOutChannel = output_channel - group_id * ${K};\n\n    float value = ${J};\n    for (int inChannelOffset = 0; inChannelOffset < ${ve}; inChannelOffset++) {\n      int input_channel = group_id * ${ve} + inChannelOffset;\n      for (int wWOff = 0; wWOff < ${X[2]}; wWOff++) {\n        for (int wHOff = 0; wHOff < ${X[3]}; wHOff++) {\n          ivec2 wOff = ivec2(wWOff * ${ae.dilations[0]}, wHOff * ${ae.dilations[1]});\n          ivec2 wLoc = loc - wOff;\n          ivec2 wLocIn = wLoc / strides;\n          if (\n            wLocIn * strides == wLoc &&\n            wLocIn.x >= 0 && wLocIn.x < ${ne[2]} &&\n            wLocIn.y >= 0 && wLocIn.y < ${ne[3]}\n          ) {\n            float xVal = getX(batch, input_channel, wLocIn.y, wLocIn.x);\n            float wVal = getW(input_channel, wOutChannel, wHOff, wWOff);\n            value += xVal * wVal;\n          }\n        }\n      }\n    }\n    ${He}\n    ${re.output} = vec4(value, .0, .0, .0);\n  }\n`;return Object.assign(Object.assign({},te),{output:{dims:q,type:H[0].type,textureType:O.TextureType.unpacked},shaderSource:Le,hasMain:!0})})(w,D,$,M)})})(d,f,y),f),h=(d,f)=>{const y=d.kernelShape.slice();if(0===d.kernelShape.length)for(let $=2;$<f[1].dims.length;++$)y.push(f[1].dims[$]);const w=d.pads.slice(),D=d.outputShape.slice();(($,B,z,G,H,te,ae,J)=>{const ne=$.length-2,X=0===J.length;for(let K=0;K<ne;++K){const q=S($[K+2],te[K],H[K],B[K],z[K],X?$[K+2]*te[K]:J[K]);C(q,G,H,K,K+ne),X&&J.push(te[K]*($[K+2]-1)+ae[K]+(B[K]-1)*z[K]+1-H[K]-H[K+ne])}})(f[0].dims,y,d.dilations,d.autoPad,w,d.strides,d.outputPadding,D);const M=Object.assign({},d);return Object.assign(M,{kernelShape:y,pads:w,outputShape:D,cacheKey:d.cacheKey}),M};E.parseConvTransposeAttributes=d=>{const f=d.attributes,y=(0,k.parseInternalActivationAttributes)(f),w=f.getString("auto_pad","NOTSET"),D=f.getInts("dilations",[1,1]),M=f.getInt("group",1),$=f.getInts("kernel_shape",[]),B=f.getInts("output_padding",[0,0]),z=f.getInts("output_shape",[]),G=f.getInts("pads",[0,0,0,0]),H=f.getInts("strides",[1,1]);return(0,F.createAttributeWithCacheKey)(Object.assign({autoPad:w,dilations:D,group:M,kernelShape:$,outputPadding:B,outputShape:z,pads:G,strides:H},y))};const l=(d,f)=>{if(!d||2!==d.length&&3!==d.length)throw new Error("Conv requires 2 or 3 inputs");if(4!==d[0].dims.length||4!==d[1].dims.length)throw new Error("currently only support 2-dimensional conv");if(d[0].dims[1]!==d[1].dims[0])throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");if(3===d.length&&(1!==d[2].dims.length||d[2].dims[0]!==d[1].dims[1]*f.group))throw new Error("invalid bias");const w=d[0].dims.length-2;if(f.dilations.length!==w)throw new Error(`dilations should be ${w}D`);if(f.strides.length!==w)throw new Error(`strides should be ${w}D`);if(f.pads.length!==2*w)throw new Error(`pads should be ${2*w}D`);if(f.outputPadding.length!==w)throw new Error(`output_padding should be ${w}D`);if(0!==f.kernelShape.length&&f.kernelShape.length!==d[1].dims.length-2)throw new Error("invalid kernel shape");if(0!==f.outputShape.length&&f.outputShape.length!==d[0].dims.length-2)throw new Error("invalid output shape");if("float32"!==d[0].type||"float32"!==d[1].type)throw new Error("ConvTranspose input(X,W) should be float tensor");if(3===d.length&&"float32"!==d[2].type)throw new Error("ConvTranspose input(bias) should be float tensor")}},9754:(me,E,P)=>{"use strict";Object.defineProperty(E,"__esModule",{value:!0}),E.parseConvAttributes=E.conv=E.calculateOutputShape=void 0;const F=P(4910),A=P(7273),O=P(7825),k=P(7708),S=P(3281),C=P(2150),v=P(1625),b=P(8276);E.calculateOutputShape=(w,D,M,$,B)=>{const z=w[0],G=w.slice(2),H=G.length,te=D[0],ae=D.slice(2).map((ne,X)=>ne+(ne-1)*(M[X]-1)),J=G.map((ne,X)=>ne+$[X]+$[X+H]).map((ne,X)=>Math.floor((ne-ae[X]+B[X])/B[X]));return[z,te].concat(...J)},E.conv=(w,D,M)=>(y(D,M),h(w,D,M));const h=(w,D,M)=>{const $=f(M,D),B=w.session.pack,z=1===$.kernelShape[0]&&1===$.kernelShape[1];return $.group>1?[w.run((0,O.createUnpackedGroupedConvProgramInfoLoader)(w,D,$),D)]:z&&B?[l(w,D,$)]:B&&4===D[0].dims.length&&1===D[0].dims[0]&&!z?[(0,k.conv2DPacked)(w,D,$)]:[d(w,D,$)]},l=(w,D,M)=>{const $=D[0].dims,B=D[1].dims,z=(0,E.calculateOutputShape)($,B,M.dilations,M.pads,M.strides),G=w.reshapeUnpacked(D[0],[$[1],$[2]*$[3]]),H=w.reshapeUnpacked(D[1],[B[0],B[1]]),te=D.length>2?[H,G,D[2]]:[H,G],ae=w.run((0,b.createMatmulProgramInfoLoader)(te,M),te);return w.reshapeUnpacked(ae,z)},d=(w,D,M)=>{const z=(0,E.calculateOutputShape)(D[0].dims,D[1].dims,M.dilations,M.pads,M.strides),G=w.run((0,v.createIm2ColProgramInfoLoader)(w,D[0],D[1],z,M),[D[0]]),H=3===D.length?[G,D[1],D[2]]:[G,D[1]];return w.run((0,S.createDotProductProgramInfoLoader)(w,D,z,M),H)},f=(w,D)=>{const M=w.kernelShape.slice();if(0===w.kernelShape.length)for(let z=2;z<D[1].dims.length;++z)M.push(D[1].dims[z]);const $=w.pads.slice();A.PoolConvUtil.adjustPadsBasedOnAutoPad(D[0].dims,w.strides,w.dilations,M,$,w.autoPad);const B=Object.assign({},w);return Object.assign(B,{kernelShape:M,pads:$,cacheKey:w.cacheKey}),B};E.parseConvAttributes=w=>{const D=w.attributes,M=(0,C.parseInternalActivationAttributes)(D),$=D.getString("auto_pad","NOTSET"),B=D.getInts("dilations",[1,1]),z=D.getInt("group",1),G=D.getInts("kernel_shape",[]),H=D.getInts("pads",[0,0,0,0]),te=D.getInts("strides",[1,1]);return(0,F.createAttributeWithCacheKey)(Object.assign({autoPad:$,dilations:B,group:z,kernelShape:G,pads:H,strides:te},M))};const y=(w,D)=>{if(!w||2!==w.length&&3!==w.length)throw new Error("Conv requires 2 or 3 inputs");if(4!==w[0].dims.length||4!==w[1].dims.length)throw new Error("currently only support 2-dimensional conv");if(w[0].dims[1]!==w[1].dims[1]*D.group)throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");if(3===w.length&&(1!==w[2].dims.length||w[1].dims[0]!==w[2].dims[0]))throw new Error("invalid bias");const M=w[0].dims.length-2;if(D.dilations.length!==M)throw new Error(`dilations should be ${M}D`);if(D.strides.length!==M)throw new Error(`strides should be ${M}D`);if(D.pads.length!==2*M)throw new Error(`pads should be ${2*M}D`);if(0!==D.kernelShape.length&&D.kernelShape.length!==w[1].dims.length-2)throw new Error("invalid kernel shape");if("float32"!==w[0].type||"float32"!==w[1].type)throw new Error("Conv input(X,W) should be float tensor");if(3===w.length&&"float32"!==w[2].type)throw new Error("Conv input(bias) should be float tensor")}},6742:(me,E,P)=>{"use strict";Object.defineProperty(E,"__esModule",{value:!0}),E.parseDepthToSpaceAttributes=E.depthToSpace=void 0;const F=P(5707);E.depthToSpace=(O,k,S)=>{A(k);const C=S.blocksize,v=C*C,b="DCR"===S.mode?[0,3,4,1,5,2]:[0,1,4,2,5,3],l=O.reshapeUnpacked(k[0],"DCR"===S.mode?[k[0].dims[0],C,C,k[0].dims[1]/v,k[0].dims[2],k[0].dims[3]]:[k[0].dims[0],k[0].dims[1]/v,C,C,k[0].dims[2],k[0].dims[3]]),d={perm:b,cacheKey:`${b}`},[f]=(0,F.transpose)(O,[l],d);return[O.reshapeUnpacked(f,[k[0].dims[0],k[0].dims[1]/v,k[0].dims[2]*C,k[0].dims[3]*C])]},E.parseDepthToSpaceAttributes=O=>{const k=O.attributes.getInt("blocksize");if(k<1)throw new Error(`blocksize must be >= 1, but got : ${k} for DepthToSpace`);const S=O.attributes.getString("mode","DCR");if("DCR"!==S&&"CRD"!==S)throw new Error(`unrecognized mode: ${S} for DepthToSpace`);return{mode:S,blocksize:k}};const A=O=>{if(1!==O.length)throw new Error(`DepthToSpace expect 1 inputs, but got ${O.length}`);if("string"===O[0].type||4!==O[0].dims.length)throw new TypeError("DepthToSpace input should be a 4-D numeric tensor")}},3281:(me,E,P)=>{"use strict";Object.defineProperty(E,"__esModule",{value:!0}),E.createDotProductProgramInfoLoader=void 0;const F=P(7273),A=P(6757),O=P(5639),k=P(2150),S=P(1625);E.createDotProductProgramInfoLoader=(C,v,b,h)=>{const l={name:"ConvDotProduct",inputNames:(d=v.length>2)?["Im2Col","K","B"]:["Im2Col","K"],inputTypes:d?[O.TextureType.unpacked,O.TextureType.packedLastDimension,O.TextureType.unpacked]:[O.TextureType.unpacked,O.TextureType.packedLastDimension],cacheKey:h.activationCacheKey};var d;return Object.assign(Object.assign({},l),{get:()=>((d,f,y,w,D)=>{const M=y[0].dims,$=y[1].dims,B=[$[0],Math.ceil(M[1]*$[2]*$[3]/4)],z=(0,S.calculateIm2ColDims)(M,$,w),[G,H]=d.calculateTextureWidthAndHeight(B,O.TextureType.packedLastDimension),te=F.ShapeUtil.computeStrides(z),[ae,J]=d.calculateTextureWidthAndHeight(z,O.TextureType.packedLastDimension),ne=w.length,X=y.length<3?"0.0":"_B(b)",K=Math.ceil(M[1]*$[2]*$[3]/4),{activationFunction:ve,applyActivation:q}=(0,k.getActivationSnippet)(D),re=(0,A.getGlsl)(d.session.backend.glContext.version),le=`\n${ve}\nfloat process(int indices[${ne}]) {\n  int b[1];\n  b[0] = indices[1];\n  int im2col[4];\n  im2col[0] = indices[0];\n  im2col[1] = indices[2];\n  im2col[2] = indices[3];\n  int im2colOffset = im2col[0] * ${te[0]} + im2col[1] * ${te[1]} + im2col[2] * ${te[2]};\n  int kernelOffset = indices[1] * ${B[1]};\n  float value = ${X};\n  for (int i = 0; i < ${K}; ++i) {\n    vec2 im2colCoords = offsetToCoords(im2colOffset, ${ae}, ${J});\n    vec2 kernelCoords = offsetToCoords(kernelOffset, ${G}, ${H});\n    value += dot(${re.texture2D}(Im2Col, im2colCoords), ${re.texture2D}(K, kernelCoords));\n    ++im2colOffset;\n    ++kernelOffset;\n  }\n  ${q}\n  return value;\n}`;return Object.assign(Object.assign({},f),{output:{dims:w,type:y[0].type,textureType:O.TextureType.unpacked},shaderSource:le})})(C,l,v,b,h)})}},4125:(me,E,P)=>{"use strict";Object.defineProperty(E,"__esModule",{value:!0}),E.parseFlattenAttributes=E.flatten=void 0;const F=P(7273);E.flatten=(O,k,S)=>{A(k,S);const C=F.ShapeUtil.flattenShape(k[0].dims,S);return[O.reshapeUnpacked(k[0],C)]},E.parseFlattenAttributes=O=>O.attributes.getInt("axis",1);const A=(O,k)=>{if(!O||1!==O.length)throw new Error("Flatten requires 1 input.");const S=O[0].dims.length;if(0===S)throw new Error("scalar tensor is not supported.");if(k<-S||k>S)throw new Error("Invalid axis");if("string"===O[0].type)throw new Error("string tensor is not supported.")}},2150:(me,E,P)=>{"use strict";Object.defineProperty(E,"__esModule",{value:!0}),E.parseInternalActivationAttributes=E.getActivationSnippet=void 0;const F=P(7273),A=P(9087);E.getActivationSnippet=function(O){let k;switch(O.activation){case"Relu":k=(0,A.glslRelu)();break;case"Sigmoid":k=(0,A.glslSigmoid)();break;case"Clip":k=(0,A.glslClip)(O.clipMin,O.clipMax);break;default:return{activationFunction:"",applyActivation:""}}return{activationFunction:k.body,applyActivation:`value = ${k.name}_(value);`}},E.parseInternalActivationAttributes=O=>{const k=O.getString("activation","");if("Clip"===k){const[S,C]=O.getFloats("activation_params",[F.MIN_CLIP,F.MAX_CLIP]);return{activation:k,clipMax:C,clipMin:S,activationCacheKey:`${k}:${S},${C}`}}return{activation:k,activationCacheKey:k}}},6149:(me,E,P)=>{"use strict";Object.defineProperty(E,"__esModule",{value:!0}),E.parseGatherAttributes=E.gather=void 0;const F=P(4910),A=P(6145),O=P(7273),k=P(5639);E.gather=(b,h,l)=>(v(h,l.axis),[b.run(C(b,h,l),h)]),E.parseGatherAttributes=b=>(0,F.createAttributeWithCacheKey)({axis:b.attributes.getInt("axis",0)});const S={name:"Gather",inputNames:["A","B"],inputTypes:[k.TextureType.unpacked,k.TextureType.unpacked]},C=(b,h,l)=>{const d=Object.assign(Object.assign({},S),{cacheHint:l.cacheKey});return Object.assign(Object.assign({},d),{get:()=>((f,y,w,D)=>{const M=w[0].dims.slice(),$=w[1].dims.slice(),B=new Array(M.length+$.length-1);D=O.ShapeUtil.normalizeAxis(D,M.length);const z=[];for(let H=0;H<B.length;H++)H<D?(B[H]=M[H],z.push(`inputIdx[${H}] = outputIdx[${H}];`)):H<D+$.length?(B[H]=$[H-D],z.push(`indexDataIdx[${H-D}] = outputIdx[${H}];`)):(B[H]=M[H-$.length+1],z.push(`inputIdx[${H-$.length+1}] = outputIdx[${H}];`));const G=`\n      float process(int outputIdx[${B.length||1}]) {\n        int inputIdx[${M.length}];\n        int indexDataIdx[${$.length||1}];\n        indexDataIdx[0] = 0;\n        ${z.join("\n        ")}\n        int idx = int(_B(indexDataIdx));\n        inputIdx[${D}] = idx < 0 ? idx + ${M[D]} : idx;\n        return _A(inputIdx);\n      }`;return Object.assign(Object.assign({},y),{output:{dims:B,type:w[0].type,textureType:k.TextureType.unpacked},shaderSource:G})})(0,d,h,l.axis)})},v=(b,h)=>{if(!b||2!==b.length)throw new Error("Gather requires 2 inputs.");const l=b[0].dims.length;if(l<1)throw new Error("Invalid input shape.");if(h<-l||h>l-1)throw new Error("Invalid axis.");if(-1===A.NUMBER_TYPES.indexOf(b[0].type))throw new Error("Invaid input type.");if("int32"!==b[1].type&&"int16"!==b[1].type)throw new Error("Invaid input type.")}},5378:(me,E,P)=>{"use strict";Object.defineProperty(E,"__esModule",{value:!0}),E.parseGemmAttributesV11=E.parseGemmAttributesV7=E.gemm=void 0;const F=P(4910),A=P(7273),O=P(5639);E.gemm=(b,h,l)=>(v(h,l),[b.run(S(h,l),h)]);const k=(b,h)=>{const l=0!==b.attributes.getInt("transA",0),d=0!==b.attributes.getInt("transB",0),f=b.attributes.getFloat("alpha",1),y=b.attributes.getFloat("beta",1);return(0,F.createAttributeWithCacheKey)({transA:l,transB:d,alpha:f,beta:y,isOptionalC:h})};E.parseGemmAttributesV7=b=>k(b,!1),E.parseGemmAttributesV11=b=>k(b,!0);const S=(b,h)=>{const l={name:"Gemm",inputNames:3===b.length?["A","B","C"]:["A","B"],inputTypes:3===b.length?[O.TextureType.unpacked,O.TextureType.unpacked,O.TextureType.unpacked]:[O.TextureType.unpacked,O.TextureType.unpacked],key:h.cacheKey};return Object.assign(Object.assign({},l),{get:()=>C(l,b,h)})},C=(b,h,l)=>{const d=h[0].dims.slice(),f=h[1].dims.slice(),[y,w]=A.GemmUtil.getShapeOfGemmResult(d,l.transA,f,l.transB,3===h.length?h[2].dims:void 0),D=[y,w];if(!D)throw new Error("Can't use gemm on the given tensors");let M=d[d.length-1],$="";l.transA&&(M=d[0]),l.transA&&l.transB?$="value += _A_T(a) * _B_T(b);":l.transA&&!l.transB?$="value += _A_T(a) * _B(b);":!l.transA&&l.transB?$="value += _A(a) * _B_T(b);":l.transA||l.transB||($="value += _A(a) * _B(b);");const B=D.length,z=`\n      float process(int indices[${B}]) {\n          int a[${B}];\n          int b[${B}];\n          ${3===h.length?`int c[${h[2].dims.length}];`:""}\n\n          copyVec(indices, a);\n          copyVec(indices, b);\n          ${3===h.length?"bcastIndices_C(indices, c);":""}\n\n          float value = 0.0;\n          for (int k=0; k<${M}; ++k) {\n              a[${B-1}] = k;\n              b[${B-2}] = k;\n              ${$}\n          }\n\n          value = value * alpha;\n          ${3===h.length?"value += beta * _C(c);":""}\n          return value;\n      }`;return Object.assign(Object.assign({},b),{output:{dims:D,type:h[0].type,textureType:O.TextureType.unpacked},variables:[{name:"alpha",type:"float",data:l.alpha},{name:"beta",type:"float",data:l.beta}],shaderSource:z})},v=(b,h)=>{if(!b)throw new Error("Input is missing");if(h.isOptionalC&&(b.length<2||b.length>3))throw new Error("Invaid input shape.");if(!h.isOptionalC&&3!==b.length)throw new Error("Gemm requires 3 inputs");if(3===b.length&&1!==b[2].dims.length&&2!==b[2].dims.length)throw new Error("Invalid input shape of C");if("float32"!==b[0].type&&"float64"!==b[0].type||"float32"!==b[1].type&&"float64"!==b[1].type||3===b.length&&"float32"!==b[2].type&&"float64"!==b[2].type)throw new Error("Invalid input type.");if(b[0].type!==b[1].type||3===b.length&&b[0].type!==b[2].type)throw new Error("Input types are mismatched")}},5950:(me,E,P)=>{"use strict";Object.defineProperty(E,"__esModule",{value:!0}),E.createPackedIm2ColProgramInfoLoader=void 0;const F=P(6757),A=P(5639),O=P(5614);E.createPackedIm2ColProgramInfoLoader=(k,S,C,v,b)=>{const h={name:"Im2Col (packed)",inputNames:["A"],inputTypes:[A.TextureType.packed],cacheHint:b.cacheKey};return Object.assign(Object.assign({},h),{get:()=>((d,f,y,w,D,M)=>{const $=y.dims,B=w.dims,z=D.length,G=[B[1]*B[2]*B[3],D[2]*D[3]],H=B[2]*B[3],te=(0,O.unpackFromChannel)(),ae=(0,F.getGlsl)(d.session.backend.glContext.version);let J="";for(let X=0;X<=1;X++)for(let K=0;K<=1;K++)J+=`\n            blockIndex = rc.x + ${K};\n            pos = rc.y + ${X};\n\n            if(blockIndex < ${G[1]} && pos < ${G[0]}) {\n              offsetY = int(blockIndex / (${D[z-1]})) * ${M.strides[0]} -\n                ${M.pads[0]};\n              d0 = offsetY + ${M.dilations[0]} * (imod(pos, ${H}) / ${B[2]});\n\n              if(d0 < ${$[2]} && d0 >= 0) {\n                offsetX = imod(blockIndex, ${D[z-1]}) * ${M.strides[1]} -\n                  ${M.pads[1]};\n                d1 = offsetX + ${M.dilations[1]} * imod(imod(pos, ${H}), ${B[2]});\n\n                if(d1 < ${$[3]} && d1 >= 0) {\n\n                  ch = int(float(pos)/ ${H}.);\n                    innerDims = vec2(d0, d1);\n                    result[${2*X+K}] = getChannel(\n                      getA(0, ch, int(innerDims.x),\n                      int(innerDims.y)), innerDims);\n                }\n              }\n            }\n\n          `;const ne=`\n      ${te}\n\n      void main() {\n        ivec2 rc = getOutputCoords();\n          vec4 result = vec4(0.0);\n          int blockIndex, pos, offsetY, d0, offsetX, d1, ch;\n          vec2 innerDims;\n          ${J}\n          ${ae.output} = result;\n      }\n            `;return Object.assign(Object.assign({},f),{output:{dims:G,type:y.type,textureType:A.TextureType.packed},shaderSource:ne,hasMain:!0})})(k,h,S,C,v,b)})}},1625:(me,E,P)=>{"use strict";Object.defineProperty(E,"__esModule",{value:!0}),E.calculateIm2ColDims=E.createIm2ColProgramInfoLoader=void 0;const F=P(5639);E.createIm2ColProgramInfoLoader=(A,O,k,S,C)=>{const v={name:"Im2Col",inputNames:["X"],inputTypes:[F.TextureType.unpacked],cacheHint:C.cacheKey};return Object.assign(Object.assign({},v),{get:()=>((h,l,d,f,y,w)=>{const D=d.dims,$=y.length,B=(0,E.calculateIm2ColDims)(D,f.dims,y,4),z=`\n        const int XC = ${D[1]};\n        const int XH = ${D[2]};\n        const int XW = ${D[3]};\n        const int KH = ${w.kernelShape[0]};\n        const int KW = ${w.kernelShape[1]};\n        const int dilationH = ${w.dilations[0]};\n        const int dilationW = ${w.dilations[1]};\n        const int strideH = ${w.strides[0]};\n        const int strideW = ${w.strides[1]};\n        const int padH = ${w.pads[0]};\n        const int padW = ${w.pads[1]};\n        const int KHKW = KH*KW;\n        const int XCKHKW = XC * KHKW;\n        const int outputChannels = 4;\n        vec4 process(int indices[${$}]) {\n          int b  = indices[0]; // batch size\n          int oh = indices[1] * strideH - padH; //output height\n          int ow = indices[2] * strideW - padW; //output width\n          int p = indices[3] * outputChannels; //patch\n          vec4 value = vec4(0.0);\n          for(int i=0; i < outputChannels; ++i) {\n            if(p < XCKHKW) {\n              int patchC = p / KHKW;\n              int patchH = (p - patchC*KHKW) / KW;\n              int patchW = (p - patchC*KHKW) - patchH * KW;\n              int xh2 = oh + patchH * dilationH;\n              int xw2 = ow + patchW * dilationW;\n              int x[${D.length}];\n              x[0] = b;\n              x[1] = patchC;\n              x[2] = xh2;\n              x[3] = xw2;\n              if(xh2 >= 0 &&\n                  xh2 < XH &&\n                  xw2 >= 0 &&\n                  xw2 < XW) {\n                value[i] = _X(x);\n              }\n            }\n            ++p;\n          }\n          return value;\n        }\n        `;return Object.assign(Object.assign({},l),{output:{dims:B,type:d.type,textureType:F.TextureType.packedLastDimension},shaderSource:z})})(0,v,O,k,S,C)})},E.calculateIm2ColDims=(A,O,k,S=4)=>[k[0],k[2],k[3],Math.ceil(A[1]*O[2]*O[3]/S)]},6981:(me,E,P)=>{"use strict";Object.defineProperty(E,"__esModule",{value:!0}),E.parseImageScalerAttributes=E.imageScaler=void 0;const F=P(4910),A=P(5639);E.imageScaler=(v,b,h)=>(C(b),[v.run(k(v,b,h),b)]),E.parseImageScalerAttributes=v=>{const b=v.attributes.getFloat("scale"),h=v.attributes.getFloats("bias");return(0,F.createAttributeWithCacheKey)({scale:b,bias:h})};const O={name:"ImageScaler",inputNames:["X"],inputTypes:[A.TextureType.unpacked]},k=(v,b,h)=>{const l=Object.assign(Object.assign({},O),{cacheHint:h.cacheKey});return Object.assign(Object.assign({},l),{get:()=>((d,f,y,w)=>{const D=y[0].dims.slice(),M=D.length,$=`\n      ${S(w.bias.length)}\n      float process(int indices[${M}]) {\n        return _X(indices) * scale + getBias(bias, indices[1]);\n      }`;return Object.assign(Object.assign({},f),{output:{dims:D,type:y[0].type,textureType:A.TextureType.unpacked},variables:[{name:"bias",type:"float",arrayLength:w.bias.length,data:w.bias},{name:"scale",type:"float",data:w.scale}],shaderSource:$})})(0,l,b,h)})},S=v=>{const b=[`float getBias(float bias[${v}], int channel) {`];for(let h=0;h<v;++h)b.push(0===h?`\tif (channel == ${h}) { return bias[${h}]; }`:h===v-1?`\telse { return bias[${h}]; }`:`\telse if (channel == ${h}) { return bias[${h}]; }`);return b.push("\t}"),b.join("\n")},C=v=>{if(!v||1!==v.length)throw new Error("ImageScaler requires 1 input.");if(4!==v[0].dims.length)throw new Error("Invalid input shape.");if("float32"!==v[0].type&&"float64"!==v[0].type)throw new Error("Invalid input type.")}},7413:(me,E,P)=>{"use strict";Object.defineProperty(E,"__esModule",{value:!0}),E.parseInstanceNormalizationAttributes=E.instanceNormalization=void 0;const F=P(6757),A=P(5639);E.instanceNormalization=(b,h,l)=>{v(h);const d=b.run(k(h[0]),h);return[b.run(C(b,h[0],l,d.dims),[h[0],d,h[1],h[2]])]},E.parseInstanceNormalizationAttributes=b=>b.attributes.getFloat("epsilon",1e-5);const O={name:"InstanceNormalization_MeanAndVariance",inputNames:["X"],inputTypes:[A.TextureType.unpacked]},k=b=>Object.assign(Object.assign({},O),{get:()=>((h,l)=>{const d=l.dims.slice(),y=d[2]*d[3],w=[d[0],d[1]],D=`\n      vec4 process(int[2] indices) {\n        vec4 v = vec4(0.0);\n        int a[4];\n        a[0] = indices[0];\n        a[1] = indices[1];\n        float temp = 0.0;\n        for(int a2=0; a2<${d[2]}; a2++) {\n          a[2] = a2;\n          for(int a3=0; a3<${d[3]}; a3++) {\n            a[3] = a3;\n            float x = _X(a);\n            temp += x;\n          }\n        }\n        float mean = temp / float(${y});\n        temp = 0.0;\n        for(int a2=0; a2<${d[2]}; a2++) {\n          a[2] = a2;\n          for(int a3=0; a3<${d[3]}; a3++) {\n            a[3] = a3;\n            float x = _X(a);\n            temp += (x - mean) * (x - mean);\n          }\n        }\n        v.r = mean;\n        v.g = temp / float(${y});\n\n        return v;\n      }`;return Object.assign(Object.assign({},h),{output:{dims:w,type:l.type,textureType:A.TextureType.packedLastDimension},shaderSource:D})})(O,b)}),S={name:"InstanceNormalization_ComputeOutput",inputNames:["X","MeanAndVariance","Scale","B"],inputTypes:[A.TextureType.unpacked,A.TextureType.packedLastDimension,A.TextureType.unpacked,A.TextureType.unpacked]},C=(b,h,l,d)=>{const f=Object.assign(Object.assign({},S),{cacheHint:`${l}`});return Object.assign(Object.assign({},f),{get:()=>((y,w,D,M,$)=>{const B=(0,F.getGlsl)(y.session.backend.glContext.version),[z,G]=y.calculateTextureWidthAndHeight($,A.TextureType.packedLastDimension),[H,te]=[z/4,G],ae=`\n      vec4 get_MeanAndVariance(int[2] mv) {\n        int offset = indicesToOffset_MeanAndVariance(mv);\n        vec2 coords = offsetToCoords(offset, ${H}, ${te});\n        return ${B.texture2D}(MeanAndVariance, coords);\n      }\n\n      float process(int[4] indices) {\n        int mv[2];\n        mv[0] = indices[0];\n        mv[1] = indices[1];\n        vec4 mean_and_variance = get_MeanAndVariance(mv);\n        float mean = mean_and_variance.r;\n        float variance = mean_and_variance.g;\n\n        int sb[1];\n        sb[0] = indices[1];\n        float scale = _Scale(sb);\n        float b = _B(sb);\n\n        return scale * (_X(indices) - mean) / sqrt(variance + epsilon) + b;\n      }`;return Object.assign(Object.assign({},w),{output:{dims:D.dims,type:D.type,textureType:A.TextureType.unpacked},variables:[{name:"epsilon",type:"float",data:M}],shaderSource:ae})})(b,f,h,l,d)})},v=b=>{if(!b||3!==b.length)throw new Error("InstanceNormalization requires 3 inputs.");const h=b[0],l=b[1],d=b[2];if(h.dims.length<3||1!==l.dims.length||1!==d.dims.length)throw new Error("Invalid input shape.");if(l.dims[0]!==h.dims[1]||d.dims[0]!==h.dims[1])throw new Error("Input shapes are mismatched.");if("float32"!==h.type&&"float64"!==h.type||"float32"!==l.type&&"float64"!==l.type||"float32"!==d.type&&"float64"!==d.type)throw new Error("Invalid input type.");if(4!==b[0].dims.length)throw new Error("Only support 4-D input shape.")}},7006:(me,E,P)=>{"use strict";Object.defineProperty(E,"__esModule",{value:!0}),E.createLrnProgramInfoLoader=E.parseLrnAttributes=E.lrn=void 0;const F=P(4910),A=P(5639);E.lrn=(C,v,b)=>(S(v),[C.run(k(v,b),v)]),E.parseLrnAttributes=C=>{const v=C.attributes.getFloat("alpha",1e-4),b=C.attributes.getFloat("beta",.75),h=C.attributes.getFloat("bias",1),l=C.attributes.getInt("size");return(0,F.createAttributeWithCacheKey)({alpha:v,beta:b,bias:h,size:l})};const O={name:"LRN",inputNames:["X"],inputTypes:[A.TextureType.unpacked]};function k(C,v){return Object.assign(Object.assign({},O),{cacheHint:v.cacheKey,get:()=>function(b,h){const l=b[0].dims[1],D=`\n    float process(int indices[${b[0].dims.length}]) {\n        int c = indices[1];\n        float x = _X(indices);\n        float square_sum = 0.0;\n\n        for (int i = ${-Math.floor((h.size-1)/2)}; i <= ${Math.ceil((h.size-1)/2)}; i++) {\n          int idx = c + i;\n          if (c >= 0 && c < ${l}) {\n            indices[1] = idx;\n            float j = _X(indices);\n            square_sum += j * j;\n          }\n        }\n        return x / pow(float(${h.bias}) + float(${h.alpha}) / float(${h.size}) * square_sum, float(${h.beta}));\n    }`;return Object.assign(Object.assign({},O),{cacheHint:h.cacheKey,output:{dims:b[0].dims,type:b[0].type,textureType:A.TextureType.unpacked},shaderSource:D})}(C,v)})}E.createLrnProgramInfoLoader=k;const S=C=>{if(!C||1!==C.length)throw new Error("LRN requires 1 input.");if(4!==C[0].dims.length)throw new Error('currently only support LRN for input with "NCHW" format');if("float32"!==C[0].type)throw new Error("input should be float type")}},5632:(me,E,P)=>{"use strict";Object.defineProperty(E,"__esModule",{value:!0}),E.createPackedMatmulProgramInfoLoader=void 0;const F=P(7273),A=P(6757),O=P(5639),k=P(432),S=P(2150),C=P(8276);E.createPackedMatmulProgramInfoLoader=(v,b,h)=>{const l={name:"MatMul (packed)",inputNames:(d=b.length>2)?["A","B","Bias"]:["A","B"],inputTypes:d?[O.TextureType.packed,O.TextureType.packed,O.TextureType.packed]:[O.TextureType.packed,O.TextureType.packed],cacheHint:h.activationCacheKey};var d;return Object.assign(Object.assign({},l),{get:()=>((y,w,D,M)=>{const $=D.length>2,B=$?"value += getBiasForMatmul();":"",z=D[0].dims,G=D[1].dims,H=F.BroadcastUtil.calcShape(z,G,!0),te=!F.ShapeUtil.areEqual(D[0].dims,D[1].dims);if(!H)throw new Error("Can't use matmul on the given tensors");const J=Math.ceil(z[z.length-1]/2),ne=z.length,X=G.length,K=(0,A.getGlsl)(y.session.backend.glContext.version),ve=(0,k.getCoordsDataType)(H.length),q=H.length,re=(0,k.getGlChannels)(),{activationFunction:le,applyActivation:He}=(0,S.getActivationSnippet)(M),Le=$?`${(0,C.getBiasForMatmul)(ve,re,D[2].dims,H,!0)}`:"",ot=te?`${function(wt,Pt,pn,Cn){let ur=[],Ir=[];const Ri=pn[0].dims,Ko=pn[1].dims,jr=Ri.length,Xo=Ko.length,kn=Cn.length,Mi=kn-jr,Lr=kn-Xo;ur=Ri.map((Hr,uo)=>`coords.${Pt[uo+Mi]}`),ur[jr-1]="i*2",ur.join(", "),Ir=Ko.map((Hr,uo)=>`coords.${Pt[uo+Lr]}`),Ir[Xo-2]="i*2",Ir.join(", ");const Gr=F.BroadcastUtil.getBroadcastDims(Ri,Cn),Fi=F.BroadcastUtil.getBroadcastDims(Ko,Cn),Yo=Gr.map(Hr=>`coords.${Pt[Hr+Mi]} = 0;`).join("\n"),qi=Fi.map(Hr=>`coords.${Pt[Hr+Lr]} = 0;`).join("\n"),ws=`int lastDim = coords.${Pt[kn-1]};\n  coords.${Pt[kn-1]} = coords.${Pt[kn-2]};\n  coords.${Pt[kn-2]} = lastDim;`;return`\nvec4 getAAtOutCoordsMatmul(int i) {\n  ${wt} coords = getOutputCoords();\n  ${ws}\n  ${Yo}\n  vec4 outputValue = getA(${ur});\n  return outputValue;\n}\n\nvec4 getBAtOutCoordsMatmul(int i) {\n  ${wt} coords = getOutputCoords();\n  ${ws}\n  ${qi}\n  vec4 outputValue = getB(${Ir});\n  return outputValue;\n}`}(ve,re,D,H)}`:"",nt=te?"getAAtOutCoordsMatmul(i)":`getA(${function(wt,Pt){let pn="";for(let Cn=0;Cn<Pt-2;Cn++)pn+=`rc.${wt[Cn]}, `;return pn+=`rc.${wt[Pt-2]}, i*2`,pn}(re,ne)})`,it=te?"getBAtOutCoordsMatmul(i)":`getB(${function(wt,Pt){let pn="";for(let Cn=0;Cn<Pt-2;Cn++)pn+=`rc.${wt[Cn]}, `;return pn+=`i*2, rc.${wt[Pt-1]}`,pn}(re,X)})`,yt=`\n            ${ot}\n            ${Le}\n            ${le}\n            void main() {\n              ${te?"":`${ve} rc =\n          getOutputCoords(); int lastDim = rc.${re[q-1]}; rc.${re[q-1]} =\n          rc.${re[q-2]}; rc.${re[q-2]} = lastDim;\n      `}\n\n              vec4 value = vec4(0);\n              for (int i = 0; i < ${J}; i++) {\n                vec4 a = ${nt};\n                vec4 b = ${it};\n\n                value += (a.rrbb * b.rgrg);\n                value += (a.ggaa * b.baba);\n              }\n              ${B}\n              ${He}\n              ${K.output} = value;\n            }`;return Object.assign(Object.assign({},w),{output:{dims:H,type:D[0].type,textureType:O.TextureType.packed},shaderSource:yt,hasMain:!0})})(v,l,b,h)})}},8276:(me,E,P)=>{"use strict";Object.defineProperty(E,"__esModule",{value:!0}),E.getBiasForMatmul=E.createMatmulProgramInfoLoader=E.parseMatMulAttributes=E.matMul=void 0;const F=P(7273),A=P(5639),O=P(432),k=P(2150),S=P(5632);E.matMul=(l,d,f)=>(b(d),l.session.pack?[l.run((0,S.createPackedMatmulProgramInfoLoader)(l,d,f),d)]:[l.run(v(d,f),d)]),E.parseMatMulAttributes=l=>(0,k.parseInternalActivationAttributes)(l.attributes);const C=(l,d)=>({name:"MatMul",inputNames:l?["A","B","Bias"]:["A","B"],inputTypes:l?[A.TextureType.unpacked,A.TextureType.unpacked,A.TextureType.unpacked]:[A.TextureType.unpacked,A.TextureType.unpacked],cacheHint:d});function v(l,d){const f=C(l.length>2,d.activationCacheKey);return Object.assign(Object.assign({},f),{get:()=>function(y,w,D){const M=w[0].dims,$=w[1].dims,B=F.BroadcastUtil.calcShape(M,$,!0);if(!B)throw new Error("Can't use matmul on the given tensors");const z=(0,O.getCoordsDataType)(B.length),G=(0,O.getGlChannels)(),{activationFunction:H,applyActivation:te}=(0,k.getActivationSnippet)(D),ae=w.length>2,J=ae?"value += getBiasForMatmul();":"",ne=ae?`${h(z,G,w[2].dims,B,!1)}`:"",K=M.length,ve=$.length,q=`\n    ${H}\n    ${ne}\n    float process(int indices[${B.length}]) {\n        int a[${K}];\n        int b[${ve}];\n        bcastMatmulIndices_A(indices, a);\n        bcastMatmulIndices_B(indices, b);\n\n        float value;\n        for (int k=0; k<${M[M.length-1]}; ++k) {\n            a[${K-1}] = k;\n            b[${ve-2}] = k;\n            value += _A(a) * _B(b);\n        }\n        ${J}\n        ${te}\n        return value;\n    }`;return Object.assign(Object.assign({},y),{output:{dims:B,type:w[0].type,textureType:A.TextureType.unpacked},shaderSource:q})}(f,l,d)})}E.createMatmulProgramInfoLoader=v;const b=l=>{if(!l||2!==l.length)throw new Error("MatMul requires 2 inputs.");if(l[0].dims[l[0].dims.length-1]!==l[1].dims[l[1].dims.length-2])throw new Error("shared dimension does not match.");if("float32"!==l[0].type&&"float64"!==l[0].type||"float32"!==l[1].type&&"float64"!==l[1].type)throw new Error("inputs should be float type");if(l[0].type!==l[1].type)throw new Error("inputs types should match")};function h(l,d,f,y,w){let D="";const M=f.length,$=y.length,B=$-M;D=$<2&&M>0?"coords":f.map((H,te)=>`coords.${d[te+B]}`).join(", ");const z=F.BroadcastUtil.getBroadcastDims(f,y).map(H=>`coords.${d[H+B]} = 0;`).join("\n");let G="vec4(outputValue.xx, outputValue.yy)";return 1===F.ShapeUtil.size(f)&&(G="vec4(outputValue.x)"),w?`\nvec4 getBiasForMatmul() {\n  ${l} coords = getOutputCoords();\n  ${z}\n  vec4 outputValue = getBias(${D});\n  return ${G};\n}`:`\nfloat getBiasForMatmul() {\n  ${l} coords = getOutputCoords();\n  ${z}\n  return getBias(coords.x);\n}`}E.getBiasForMatmul=h},9:(me,E,P)=>{"use strict";Object.defineProperty(E,"__esModule",{value:!0}),E.createPackProgramInfoLoader=void 0;const F=P(6757),A=P(5639),O=P(432),k=P(5614),S={name:"pack",inputNames:["A"],inputTypes:[A.TextureType.unpackedReversed]};E.createPackProgramInfoLoader=(C,v)=>Object.assign(Object.assign({},S),{get:()=>((b,h)=>{const l=(0,F.getGlsl)(b.session.backend.glContext.version),d=h.dims,f=d.length,y=h.dims.length,w=(0,O.getCoordsDataType)(y),D=(0,k.getChannels)("rc",y),M=(B=D,0===($=y)||1===$?"":`\n    int r = ${B[$-2]};\n    int c = ${B[$-1]};\n    int rp1 = ${B[$-2]} + 1;\n    int cp1 = ${B[$-1]} + 1;\n    bool rEdge = rp1 >= ${d[d.length-1]};\n    bool cEdge = cp1 >= ${d[d.length-2]};\n    `);var $,B;let H;H=0===f?[1,1]:1===f?[d[0],1]:[d[y-1],d[y-2]];const te=function(ne,X,K){if(0===ne)return"false";if(1===ne)return`rc > ${X[0]}`;let ve="";for(let q=ne-2;q<ne;q++)ve+=`${K[q]} >= ${X[q-ne+2]}`,q<ne-1&&(ve+="||");return ve}(y,H,D),ae=function(ne,X){const K=ne.length;if(0===K)return"getA(), 0, 0, 0";if(1===K)return`getA(rc),\n            rc + 1 >= ${ne[0]} ? 0. : getA(rc + 1),\n            0, 0`;let ve="";if(K>2)for(let q=0;q<K-2;++q)ve+=`${X[q]},`;return`getA(${ve}r, c),\n          rEdge ? 0. : getA(${ve}rp1, c),\n          cEdge ? 0. : getA(${ve}r, cp1),\n          rEdge || cEdge ? 0. : getA(${ve}rp1, cp1)`}(d,D),J=`\n        void main() {\n          ${w} rc = getOutputCoords();\n\n          if(${te}) {\n            ${l.output} = vec4(0);\n          } else {\n            ${M}\n\n            ${l.output} = vec4(${ae});\n          }\n        }\n      `;return Object.assign(Object.assign({},S),{hasMain:!0,output:{dims:h.dims,type:h.type,textureType:A.TextureType.packed},shaderSource:J})})(C,v)})},5614:(me,E,P)=>{"use strict";Object.defineProperty(E,"__esModule",{value:!0}),E.unpackFromChannel=E.getChannels=E.getVecChannels=void 0;const F=P(432);function A(O,k){return(0,F.getGlChannels)(k).map(S=>`${O}.${S}`)}E.getVecChannels=A,E.getChannels=function(O,k){return 1===k?[O]:A(O,k)},E.unpackFromChannel=function(){return"\n    float getChannel(vec4 frag, int dim) {\n      int modCoord = imod(dim, 2);\n      return modCoord == 0 ? frag.r : frag.g;\n    }\n\n    float getChannel(vec4 frag, vec2 innerDims) {\n      vec2 modCoord = mod(innerDims, 2.);\n      return modCoord.x == 0. ?\n        (modCoord.y == 0. ? frag.r : frag.g) :\n        (modCoord.y == 0. ? frag.b : frag.a);\n    }\n  "}},5565:(me,E,P)=>{"use strict";Object.defineProperty(E,"__esModule",{value:!0}),E.parsePadAttributesV11=E.padV11=E.parsePadAttributesV2=E.padV2=void 0;const F=P(4910),A=P(7273),O=P(6757),k=P(5639),S={name:"Pad",inputNames:["A"],inputTypes:[k.TextureType.unpacked]};E.padV2=(w,D,M)=>(b(D),[w.run(Object.assign(Object.assign({},S),{cacheHint:M.cacheKey,get:()=>v(w,D[0],M)}),D)]),E.parsePadAttributesV2=w=>{const D=w.attributes.getString("mode","constant"),M=w.attributes.getFloat("value",0),$=w.attributes.getInts("pads");return(0,F.createAttributeWithCacheKey)({mode:D,value:M,pads:$})},E.padV11=(w,D,M)=>{h(D);const $=C(w,D,M);return(0,E.padV2)(w,[D[0]],$)},E.parsePadAttributesV11=w=>w.attributes.getString("mode","constant");const C=(w,D,M)=>{if(!w.session.isInitializer(D[1].dataId)||D.length>=3&&!w.session.isInitializer(D[2].dataId))throw new Error("dynamic pad attributes are not allowed");const $=Array.from(D[1].integerData);return(0,F.createAttributeWithCacheKey)({mode:M,pads:$,value:D.length>=3?D[2].floatData[0]:0})},v=(w,D,M)=>{const $=A.ShapeUtil.padShape(D.dims.slice(),M.pads),B=$.length,z=`\n      ${l(w,D,M)}\n      float process(int[${B}] indices) {\n          return padA(indices);\n      }`;return{name:"Pad",inputNames:["A"],inputTypes:[k.TextureType.unpacked],output:{dims:$,type:D.type,textureType:k.TextureType.unpacked},shaderSource:z}},b=w=>{if(!w||1!==w.length)throw new Error("Pad requires 1 input");if("float32"!==w[0].type&&"float64"!==w[0].type)throw new Error("Invalid input type.")},h=w=>{if(!w||2!==w.length&&3!==w.length)throw new Error("Pad requires 2 or 3 inputs");if("int32"!==w[1].type)throw new Error("Invalid input type.");if(w.length>=3&&"string"===w[2].type)throw new Error("Invalid input type.")},l=(w,D,M)=>{const $=(0,O.getGlsl)(w.session.backend.glContext.version),[B,z]=w.calculateTextureWidthAndHeight(D.dims,k.TextureType.unpacked),G=A.ShapeUtil.computeStrides(D.dims);switch(M.mode){case"constant":return d($,D.dims,G,B,z,M.pads,M.value);case"reflect":return f($,D.dims,G,B,z,M.pads);case"edge":return y($,D.dims,G,B,z,M.pads);default:throw new Error("Invalid mode")}},d=(w,D,M,$,B,z,G)=>{const H=D.length;let te="";for(let ae=H-1;ae>=0;--ae)te+=`\n        k = m[${ae}] - ${z[ae]};\n        if (k < 0)  return constant;\n        if (k >= ${D[ae]}) return constant;\n        offset += k * ${M[ae]};\n        `;return`\n      float padA(int m[${H}]) {\n        const float constant = float(${G});\n        int offset = 0;\n        int k = 0;\n        ${te}\n        vec2 coords = offsetToCoords(offset, ${$}, ${B});\n        float value = getColorAsFloat(${w.texture2D}(A, coords));\n        return value;\n      }\n      `},f=(w,D,M,$,B,z)=>{const G=D.length;let H="";for(let te=G-1;te>=0;--te)H+=`\n        k = m[${te}] - ${z[te]};\n        if (k < 0) { k = -k; }\n        {\n          const int _2n_1 = ${2*(D[te]-1)};\n          k = int( mod( float(k), float(_2n_1) ) ) ;\n          if(k >= ${D[te]}) { k = _2n_1 - k; }\n        }\n        offset += k * ${M[te]};\n        `;return`\n      float padA(int m[${G}]) {\n        int offset = 0;\n        int k = 0;\n        ${H}\n        vec2 coords = offsetToCoords(offset, ${$}, ${B});\n        float value = getColorAsFloat(${w.texture2D}(A, coords));\n        return value;\n      }\n      `},y=(w,D,M,$,B,z)=>{const G=D.length;let H="";for(let te=G-1;te>=0;--te)H+=`\n        k = m[${te}] - ${z[te]};\n        if (k < 0)  k = 0;\n        if (k >= ${D[te]}) k = ${D[te]-1};\n        offset += k * ${M[te]};\n      `;return`\n      float padA(int m[${G}]) {\n        int offset = 0;\n        int k = 0;\n        ${H}\n        vec2 coords = offsetToCoords(offset, ${$}, ${B});\n        float value = getColorAsFloat(${w.texture2D}(A, coords));\n        return value;\n      }\n      `}},2834:(me,E,P)=>{"use strict";Object.defineProperty(E,"__esModule",{value:!0}),E.globalMaxPool=E.parseMaxPoolAttributes=E.maxPool=E.parseGlobalAveragePoolAttributes=E.globalAveragePool=E.parseAveragePoolAttributes=E.averagePool=void 0;const F=P(4910),A=P(7273),O=P(5639);E.averagePool=(y,w,D)=>{h(w);const M={name:"AveragePool",inputNames:["X"],inputTypes:[O.TextureType.unpacked],cacheHint:D.cacheKey};return[y.run(Object.assign(Object.assign({},M),{get:()=>k(w,M,!1,D)}),w)]},E.parseAveragePoolAttributes=y=>{const w=y.attributes.getString("auto_pad","NOTSET"),D=y.attributes.getInt("ceil_mode",0),M=0!==y.attributes.getInt("count_include_pad",0),$=y.attributes.getInts("kernel_shape"),B=y.attributes.getInts("strides",[]),z=y.attributes.getInts("pads",[]);if(0!==D)throw new Error("using ceil() in shape computation is not yet supported for AveragePool");return(0,F.createAttributeWithCacheKey)({autoPad:w,ceilMode:D,countIncludePad:M,kernelShape:$,strides:B,pads:z})};const k=(y,w,D,M)=>{const[$,B]=C(y,M,D),z=A.ShapeUtil.size($.kernelShape);let G="";G+=$.countIncludePad?`value /= float(${z});`:`value /= float(${z} - pad);`;const H=`\n        ${l(y[0].dims,$,"value += _X(x);",G,"0.0")}\n      `;return Object.assign(Object.assign({},w),{output:{dims:B,type:y[0].type,textureType:O.TextureType.unpacked},shaderSource:H})};E.globalAveragePool=(y,w,D)=>{h(w);const M={name:"GlobalAveragePool",inputNames:["X"],inputTypes:[O.TextureType.unpacked],cacheHint:`${D.countIncludePad}`};return[y.run(Object.assign(Object.assign({},M),{get:()=>k(w,M,!0,D)}),w)]},E.parseGlobalAveragePoolAttributes=y=>{const w=0!==y.attributes.getInt("count_include_pad",0);return(0,F.createAttributeWithCacheKey)({autoPad:"",ceilMode:0,countIncludePad:w,kernelShape:[],strides:[],pads:[]})},E.maxPool=(y,w,D)=>{h(w);const M={name:"MaxPool",inputNames:["X"],inputTypes:[O.TextureType.unpacked],cacheHint:D.cacheKey};return[y.run(Object.assign(Object.assign({},M),{get:()=>S(w,M,!1,D)}),w)]},E.parseMaxPoolAttributes=y=>{const w=y.attributes.getString("auto_pad","NOTSET"),D=y.attributes.getInt("ceil_mode",0),M=y.attributes.getInts("kernel_shape"),$=y.attributes.getInts("strides",[]),B=y.attributes.getInts("pads",[]),z=y.attributes.getInt("storage_order",0),G=y.attributes.getInts("dilations",[]);if(0!==z)throw new Error("column major storage order is not yet supported for MaxPool");if(0!==D)throw new Error("using ceil() in shape computation is not yet supported for MaxPool");return(0,F.createAttributeWithCacheKey)({autoPad:w,ceilMode:D,countIncludePad:!1,kernelShape:M,strides:$,pads:B,storageOrder:z,dilations:G})};const S=(y,w,D,M)=>{const[$,B]=C(y,M,D),z=`\n      ${l(y[0].dims,$,"\n      value = max(_X(x), value);\n    ","","-1e5")}\n    `;return Object.assign(Object.assign({},w),{output:{dims:B,type:y[0].type,textureType:O.TextureType.unpacked},shaderSource:z})},C=(y,w,D)=>{const M=y[0].dims.slice(),$=Object.hasOwnProperty.call(w,"dilations"),B=w.kernelShape.slice(),z=w.strides.slice(),G=$?w.dilations.slice():[],H=w.pads.slice();A.PoolConvUtil.adjustPoolAttributes(D,M,B,z,G,H);const te=A.PoolConvUtil.computePoolOutputShape(D,M,z,G,B,H,w.autoPad),ae=Object.assign({},w);return Object.assign(ae,$?{kernelShape:B,strides:z,pads:H,dilations:G,cacheKey:w.cacheKey}:{kernelShape:B,strides:z,pads:H,cacheKey:w.cacheKey}),[ae,te]},v={autoPad:"",ceilMode:0,countIncludePad:!1,kernelShape:[],strides:[],pads:[],storageOrder:0,dilations:[],cacheKey:""},b={name:"GlobalMaxPool",inputNames:["X"],inputTypes:[O.TextureType.unpacked]};E.globalMaxPool=(y,w)=>(h(w),[y.run(Object.assign(Object.assign({},b),{get:()=>S(w,b,!0,v)}),w)]);const h=y=>{if(!y||1!==y.length)throw new Error("Pool ops requires 1 input.");if("float32"!==y[0].type&&"float64"!==y[0].type)throw new Error("Invalid input type.")},l=(y,w,D,M,$)=>{const B=y.length;if(w.kernelShape.length<=2){const z=w.kernelShape[w.kernelShape.length-1],G=w.strides[w.strides.length-1],H=w.pads[w.pads.length/2-1];let J="",ne="",X="";if(J=H+w.pads[w.pads.length-1]!==0?`\n          for (int i = 0; i < ${z}; i++) {\n            x[${B} - 1] = indices[${B} - 1] * ${G} - ${H} + i;\n            if (x[${B} - 1] < 0 || x[${B} - 1] >= ${y[B-1]}) {\n              pad++;\n              continue;\n            }\n            ${D}\n          }`:`\n          for (int i = 0; i < ${z}; i++) {\n            x[${B} - 1] = indices[${B} - 1] * ${G} - ${H} + i;\n            ${D}\n          }`,2===w.kernelShape.length){const K=w.kernelShape[w.kernelShape.length-2],ve=w.strides[w.strides.length-2],q=w.pads[w.pads.length/2-2];ne=q+w.pads[w.pads.length-2]!==0?`\n            for (int j = 0; j < ${K}; j++) {\n              x[${B} - 2] = indices[${B} - 2] * ${ve} - ${q} + j;\n              if (x[${B} - 2] < 0 || x[${B} - 2] >= ${y[B-2]}) {\n                pad+= ${z};\n                continue;\n              }\n          `:`\n            for (int j = 0; j < ${K}; j++) {\n              x[${B} - 2] = indices[${B} - 2] * ${ve} - ${q} + j;\n            `,X="\n          }\n        "}return`\n        float process(int indices[${B}]) {\n          int x[${B}];\n          copyVec(indices, x);\n\n          float value = ${$};\n          int pad = 0;\n          ${ne}\n          ${J}\n          ${X}\n          ${M}\n          return value;\n        }\n      `}{const z=A.ShapeUtil.size(w.kernelShape),G=A.ShapeUtil.computeStrides(w.kernelShape),H=G.length,te=w.pads.length,ae=f(H),J=d(y,"inputDims"),ne=d(w.pads,"pads"),X=d(G,"kernelStrides"),K=d(w.strides,"strides");let ve="";return ve=w.pads.reduce((q,re)=>q+re)?`\n            if (x[j] >= inputDims[j] || x[j] < 0) {\n              pad++;\n              isPad = true;\n              break;\n            }\n          }\n          if (!isPad) {\n            ${D}\n          }`:`\n          }\n          ${D}\n        `,`\n        ${ae}\n        float process(int indices[${B}]) {\n          int x[${B}];\n          copyVec(indices, x);\n          int offset[${H}];\n          int pads[${te}];\n          int inputDims[${B}];\n          int kernelStrides[${H}];\n          int strides[${H}];\n          ${ne}\n          ${J}\n          ${K}\n          ${X}\n\n          float value = ${$};\n          int pad = 0;\n          bool isPad = false;\n          for (int i = 0; i < ${z}; i++) {\n            offsetToIndices(i, kernelStrides, offset);\n            isPad = false;\n            for (int j = ${B} - ${H}; j < ${B}; j++) {\n              x[j] = indices[j] * strides[j - ${B} + ${H}]\n                + offset[j - ${B} + ${H}] - pads[j - 2];\n              ${ve}\n          }\n          ${M}\n\n          return value;\n        }\n      `}},d=(y,w)=>{let D="";for(let M=0;M<y.length;M++)D+=`\n      ${w}[${M}] = ${y[M]};\n    `;return D},f=y=>`\n  void offsetToIndices(int offset, int[${y}] strides, out int[${y}] indices) {\n    if (${y} == 0) {\n      return;\n    }\n    for (int i = 0; i < ${y} - 1; ++i) {\n      indices[i] = offset / strides[i];\n      offset -= indices[i] * strides[i];\n    }\n    indices[${y} - 1] = offset;\n  }`},1010:(me,E,P)=>{"use strict";Object.defineProperty(E,"__esModule",{value:!0}),E.reduceLogSumSquare=E.reduceLogSum=E.reduceProd=E.reduceMin=E.reduceMax=E.reduceMean=E.reduceSum=E.parseReduceAttributes=void 0;const F=P(4910),A=P(6145),O=P(7273),k=P(5639),S=(b,h,l,d,f)=>{v(h);const y={name:d,inputNames:["A"],inputTypes:[k.TextureType.unpacked]};return[b.run(Object.assign(Object.assign({},y),{cacheHint:l.cacheKey,get:()=>C(b,h,l,d,f,y)}),h)]};E.parseReduceAttributes=b=>{const h=b.attributes.getInts("axes",[]),l=1===b.attributes.getInt("keepdims",1);return(0,F.createAttributeWithCacheKey)({axes:h,keepDims:l})};const C=(b,h,l,d,f,y)=>{const w=[],D=h[0].dims.length||1,M=[],$=O.ShapeUtil.normalizeAxes(l.axes,h[0].dims.length),B=f(h,$);let z=B[1];for(let H=0;H<h[0].dims.length;H++)$.indexOf(H)>=0||0===$.length?(l.keepDims&&w.push(1),z=`\n          for(int j${H} = 0; j${H} < ${h[0].dims[H]}; j${H}++) {\n            inputIdx[${H}] = j${H};\n            ${z}\n          }`):(M.push(`inputIdx[${H}] = outputIdx[${w.length}];`),w.push(h[0].dims[H]));const G=`\n      float process(int outputIdx[${w.length||1}]) {\n        float value;                 // final result\n        int inputIdx[${D}];      // addressing input data\n        ${M.join("\n")}\n        ${B[0]}       // init ops for reduce max/min\n        ${z}\n        ${B[2]}       // final computation for reduce mean\n        return value;\n      }`;return Object.assign(Object.assign({},y),{output:{dims:w,type:h[0].type,textureType:k.TextureType.unpacked},shaderSource:G})},v=b=>{if(!b||1!==b.length)throw new Error("Reduce op requires 1 input.");if(-1===A.NUMBER_TYPES.indexOf(b[0].type))throw new Error("Invalid input type.")};E.reduceSum=(b,h,l)=>S(b,h,l,"ReduceSum",()=>["value = 0.0;","value += _A(inputIdx);",""]),E.reduceMean=(b,h,l)=>S(b,h,l,"ReduceMean",(d,f)=>{let y=1;for(let w=0;w<d[0].dims.length;w++)(f.indexOf(w)>=0||0===f.length)&&(y*=d[0].dims[w]);return["value = 0.0;","value += _A(inputIdx);",`value /= ${y}.;`]}),E.reduceMax=(b,h,l)=>S(b,h,l,"ReduceMax",(d,f)=>{const y=[];for(let w=0;w<d[0].dims.length;w++)(f.indexOf(w)>=0||0===f.length)&&y.push(`inputIdx[${w}] = 0;`);return[`${y.join("\n")}\nvalue = _A(inputIdx);`,"value = max(value, _A(inputIdx));",""]}),E.reduceMin=(b,h,l)=>S(b,h,l,"ReduceMin",(d,f)=>{const y=[];for(let w=0;w<d[0].dims.length;w++)(f.indexOf(w)>=0||0===f.length)&&y.push(`inputIdx[${w}] = 0;`);return[`${y.join("\n")}\nvalue = _A(inputIdx);`,"value = min(value, _A(inputIdx));",""]}),E.reduceProd=(b,h,l)=>S(b,h,l,"ReduceProd",()=>["value = 1.0;","value *= _A(inputIdx);",""]),E.reduceLogSum=(b,h,l)=>S(b,h,l,"ReduceLogSum",()=>["value = 0.0;","value += _A(inputIdx);","value = log(value);"]),E.reduceLogSumSquare=(b,h,l)=>S(b,h,l,"ReduceLogSumSquare",()=>["float t; value = 0.0;","t = _A(inputIdx); value += t * t;",""])},7379:(me,E,P)=>{"use strict";Object.defineProperty(E,"__esModule",{value:!0}),E.isReshapeCheap=E.processDims3D=E.createPackedReshape3DProgramInfoLoader=void 0;const F=P(7273),A=P(6757),O=P(5639),k=P(5614);E.createPackedReshape3DProgramInfoLoader=(S,C,v)=>{const b={name:"Reshape (packed)",inputTypes:[O.TextureType.packed],inputNames:["A"],cacheHint:`${v}`};return Object.assign(Object.assign({},b),{get:()=>((h,l,d,f)=>{const y=l.dims,w=f;let D="";for(let B=0;B<4;B++){let z="";switch(B){case 0:z="outputCoords = rc;";break;case 1:z="outputCoords = ivec3(rc.x, rc.y+1, rc.z);";break;case 2:z="outputCoords = ivec3(rc.x, rc.y, rc.z+1);";break;case 3:z="outputCoords = ivec3(rc.x, rc.y+1, rc.z+1);";break;default:throw new Error}D+=`\n        ${z}\n        ${B>0?"if(outputCoords.y < rows && outputCoords.z < cols){":""}\n          int flattenedIndex = getFlattenedIndex(outputCoords);\n\n          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flattenedIndex);\n          vec2 innerDims = vec2(float(inputRC.y),float(inputRC.z));\n\n          result[${B}] = getChannel(getA(inputRC.x, inputRC.y, inputRC.z), innerDims);\n\n        ${B>0?"}":""}\n      `}const M=(0,A.getGlsl)(h.session.backend.glContext.version),$=`\n      ${function(B){const z=F.ShapeUtil.computeStrides(B),G=["b","r","c"],H="index";return`\n    ivec3 inputCoordsFromReshapedOutCoords(int index) {\n      ${z.map((te,ae)=>`int ${G[ae]} = ${H} / ${te}; ${ae===z.length-1?`int ${G[ae+1]} = ${H} - ${G[ae]} * ${te}`:`index -= ${G[ae]} * ${te}`};`).join("")}\n      return ivec3(b, r, c);\n    }\n  `}(y)}\n      ${function(B){const z=F.ShapeUtil.computeStrides(B);return`\n  int getFlattenedIndex(ivec3 coords) {\n    // reverse y, z order\n    return coords.x * ${z[0]} + coords.z * ${z[1]} + coords.y;\n  }\n`}(w)}\n      ${(0,k.unpackFromChannel)()}\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0.0);\n\n        ivec3 outputCoords;\n        int rows = ${w[2]};\n        int cols = ${w[1]};\n\n        ${D}\n        ${M.output} = result;\n      }\n    `;return Object.assign(Object.assign({},d),{output:{dims:w,type:l.type,textureType:O.TextureType.packed},shaderSource:$,hasMain:!0})})(S,C,b,v)})},E.processDims3D=function(S){if(0===S.length)return[1,1,1];let C=1;for(let v=0;v<S.length-2;++v)C*=S[v];return[C,S.length>1?S[S.length-2]:1,S[S.length-1]]},E.isReshapeCheap=function(S,C){let v=!1;return v=0===S.length||0===C.length||(S.length<2||C.length<2?S[S.length-1]===C[C.length-1]:S[S.length-1]===C[C.length-1]&&S[S.length-2]===C[C.length-2]),v}},8126:(me,E,P)=>{"use strict";Object.defineProperty(E,"__esModule",{value:!0}),E.reshape=void 0;const F=P(7273);E.reshape=(A,O)=>{const k=F.ShapeUtil.calculateReshapedDims(O[0].dims,O[1].integerData);return A.session.pack?[A.reshapePacked(O[0],k)]:[A.reshapeUnpacked(O[0],k)]}},2801:(me,E,P)=>{"use strict";Object.defineProperty(E,"__esModule",{value:!0}),E.parseResizeAttributesV11=E.parseResizeAttributesV10=E.resize=void 0;const F=P(6757),A=P(5639),O=P(432),k=P(5614),S=P(3980),C={name:"Resize",inputNames:["A"],inputTypes:[A.TextureType.packed]};E.resize=(d,f,y)=>((0,S.validateInputs)(f,y),[d.run(Object.assign(Object.assign({},C),{cacheHint:y.cacheKey,get:()=>v(d,f,y)}),f)]),E.parseResizeAttributesV10=d=>(0,S.parseUpsampleAttributes)(d,10),E.parseResizeAttributesV11=d=>(0,S.parseUpsampleAttributes)(d,11);const v=(d,f,y)=>{const w=(0,F.getGlsl)(d.session.backend.glContext.version),[D,M]=b(f,y);if(D.every(ve=>1===ve)&&"tf_crop_and_resize"!==y.coordinateTransformMode)return Object.assign(Object.assign({},C),{output:{dims:M,type:f[0].type,textureType:A.TextureType.packed},hasMain:!0,shaderSource:`void main() {\n                    vec4 v = ${w.texture2D}(X, TexCoords);\n                    ${w.output} = v;\n                }`});const $=M.length;if($<2)throw new Error(`output dimension should be at least 2, but got ${$}`);const B=M[$-2],z=M[$-1],G=f[0].dims;if($!==G.length)throw new Error(`output dimension should match input ${G.length}, but got ${$}`);const H=G[$-2],te=G[$-1],ae=D[$-2],J=D[$-1];let ne="";if("linear"!==y.mode)throw new Error(`resize (packed) does not support mode: '${y.mode}'`);switch(y.coordinateTransformMode){case"asymmetric":ne="\n                    vec4 getSourceFracIndex(ivec4 coords) {\n                        return vec4(coords) / scaleWHWH;\n                    }\n                ";break;case"half_pixel":ne="\n                    vec4 getSourceFracIndex(ivec4 coords) {\n                        return (vec4(coords) + 0.5) / scaleWHWH - 0.5;\n                    }\n                ";break;case"pytorch_half_pixel":ne=`\n                    vec4 getSourceFracIndex(ivec4 coords) {\n                        vec4 fcoords = vec4(coords);\n                        return vec4(\n                            ${z}.0 > 1.0 ? (fcoords.x + 0.5) / scaleWHWH.x - 0.5 : 0.0,\n                            ${B}.0 > 1.0 ? (fcoords.y + 0.5) / scaleWHWH.y - 0.5 : 0.0,\n                            ${z}.0 > 1.0 ? (fcoords.z + 0.5) / scaleWHWH.z - 0.5 : 0.0,\n                            ${B}.0 > 1.0 ? (fcoords.w + 0.5) / scaleWHWH.w - 0.5 : 0.0\n                          );\n                    }\n                `;break;case"align_corners":ne=`\n                    vec4 getSourceFracIndex(ivec4 coords) {\n                        vec4 resized = vec4(${z}.0 - 1.0, ${B}.0 - 1.0, ${z}.0 - 1.0,\n                            ${B}.0 - 1.0);\n                        vec4 original = vec4(${te}.0 - 1.0, ${H}.0 - 1.0, ${te}.0 - 1.0,\n                            ${H}.0 - 1.0);\n                        vec4 new_scale = original / resized;\n                        return vec4(coords) * new_scale;\n                    }\n                `;break;default:throw new Error(`resize (packed) does not support coordinateTransformMode:                                 '${y.coordinateTransformMode}'`)}const X=(0,O.getCoordsDataType)($),K=`\n            const vec2 inputWH = vec2(${H}.0, ${te}.0);\n            const vec4 scaleWHWH = vec4(float(${ae}), float(${J}), float(${ae}), float(${J}));\n            ${(0,k.unpackFromChannel)()}\n            ${ne}\n            float getAValue(int x10, int r, int c, int d) {\n                return getChannel(getA(x10, r, c, d), vec2(c, d));\n            }\n            void main() {\n                ${X} rc = getOutputCoords();\n\n                int batch = rc[0];\n                int depth = rc[1];\n\n                // retrieve the 4 coordinates that is used in the 4 packed output values.\n                ivec4 coords = ivec4(rc.wz, rc.w + 1, rc.z + 1);\n\n                // calculate the source index in fraction\n                vec4 sourceFrac = getSourceFracIndex(coords);\n\n                // get the lower and upper bound of the 4 values that will be packed into one texel.\n                ivec4 x00 = ivec4(max(sourceFrac.xy, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.xy)));\n                ivec4 x01 = ivec4(max(sourceFrac.xw, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.xw)));\n                ivec4 x10 = ivec4(max(sourceFrac.zy, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.zy)));\n                ivec4 x11 = ivec4(max(sourceFrac.zw, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.zw)));\n\n                bool hasNextRow = rc.w < ${B-1};\n                bool hasNextCol = rc.z < ${z-1};\n\n                // pack x00, x01, x10, x11's top-left corner into one vec4 structure\n                vec4 topLeft = vec4(\n                    getAValue(batch, depth, x00.x, x00.y),\n                    hasNextCol ? getAValue(batch, depth, x01.x, x01.y) : 0.0,\n                    hasNextRow ? getAValue(batch, depth, x10.x, x10.y) : 0.0,\n                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.x, x11.y) : 0.0);\n\n                // pack x00, x01, x10, x11's top-right corner into one vec4 structure\n                vec4 topRight = vec4(\n                    getAValue(batch, depth, x00.x, x00.w),\n                    hasNextCol ? getAValue(batch, depth, x01.x, x01.w) : 0.0,\n                    hasNextRow ? getAValue(batch, depth, x10.x, x10.w) : 0.0,\n                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.x, x11.w) : 0.0);\n\n                // pack x00, x01, x10, x11's bottom-left corner into one vec4 structure\n                vec4 bottomLeft = vec4(\n                    getAValue(batch, depth, x00.z, x00.y),\n                    hasNextCol ? getAValue(batch, depth, x01.z, x01.y) : 0.0,\n                    hasNextRow ? getAValue(batch, depth, x10.z, x10.y) : 0.0,\n                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.z, x11.y) : 0.0);\n\n                // pack x00, x01, x10, x11's bottom-right corner into one vec4 structure\n                vec4 bottomRight = vec4(\n                    getAValue(batch, depth, x00.z, x00.w),\n                    hasNextCol ? getAValue(batch, depth, x01.z, x01.w) : 0.0,\n                    hasNextRow ? getAValue(batch, depth, x10.z, x10.w) : 0.0,\n                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.z, x11.w) : 0.0);\n\n                // calculate the interpolation fraction on u and v direction\n                vec4 frac = vec4(sourceFrac) - floor(sourceFrac);\n                vec4 clampFrac = clamp(frac, vec4(0.0), vec4(1.0));\n\n                vec4 top = mix(topLeft, topRight, clampFrac.ywyw);\n                vec4 bottom = mix(bottomLeft, bottomRight, clampFrac.ywyw);\n                vec4 newValue = mix(top, bottom, clampFrac.xxzz);\n\n                ${w.output} = vec4(newValue);\n            }\n        `;return Object.assign(Object.assign({},C),{output:{dims:M,type:f[0].type,textureType:A.TextureType.packed},hasMain:!0,shaderSource:K})},b=(d,f)=>{const y=d[0].dims;let w,D=f.scales;if(0===D.length){const $=d[f.scalesInputIdx];if($&&0!==$.size){if(d[f.sizesInputIdx])throw new Error("Only one of scales or sizes must be provided as input.");D=h($,f.mode,f.isResize)}else{const B=d[f.sizesInputIdx];if(!B||0===B.size)throw new Error("Either scales or sizes MUST be provided as input.");w=Array.from(B.integerData),D=l(w,y,f.mode,f.isResize)}}else if(d[f.sizesInputIdx])throw new Error("Only one of scales or sizes must be provided as input.");const M=w||y.map(($,B)=>Math.floor($*D[B]));return[D,M]},h=(d,f,y)=>{const w=Array.from(d.floatData);return(0,S.scalesValidation)(w,f,y),w},l=(d,f,y,w)=>{const D=f.length,M=new Array(D);for(let $=0,B=D;$<B;$++)if(0===f[$]){if(0!==d[$])throw new Error("Input dim is zero but required output dim is non-zero.");M[$]=1}else M[$]=d[$]/f[$];return(0,S.scalesValidation)(M,y,w),M}},565:(me,E,P)=>{"use strict";Object.defineProperty(E,"__esModule",{value:!0}),E.shape=void 0;const F=P(9240);E.shape=(O,k)=>(A(k),[new F.Tensor([k[0].dims.length],"int32",void 0,void 0,new Int32Array(k[0].dims))]);const A=O=>{if(!O||1!==O.length)throw new Error("Shape requires 1 input.")}},2444:(me,E,P)=>{"use strict";Object.defineProperty(E,"__esModule",{value:!0}),E.sliceV10=E.parseSliceAttributes=E.slice=void 0;const F=P(4910),A=P(6145),O=P(7273),k=P(5639),S={name:"Slice",inputNames:["A"],inputTypes:[k.TextureType.unpacked]};E.slice=(l,d,f)=>(v(d),[l.run(Object.assign(Object.assign({},S),{cacheHint:f.cacheKey,get:()=>C(l,d[0],f)}),d)]),E.parseSliceAttributes=l=>{const d=l.attributes.getInts("starts"),f=l.attributes.getInts("ends"),y=l.attributes.getInts("axes",[]);return(0,F.createAttributeWithCacheKey)({starts:d,ends:f,axes:y})};const C=(l,d,f)=>{const y=0===f.axes.length?d.dims.slice(0).map((G,H)=>H):f.axes,w=O.ShapeUtil.normalizeAxes(y,d.dims.length),D=f.starts.map((G,H)=>G>d.dims[w[H]]-1?d.dims[w[H]]:O.ShapeUtil.normalizeAxis(G,d.dims[w[H]])),M=f.ends.map((G,H)=>G>d.dims[w[H]]-1?d.dims[w[H]]:O.ShapeUtil.normalizeAxis(G,d.dims[w[H]])),$=d.dims.slice(),B=[];for(let G=0;G<w.length;G++)$[w[G]]=M[G]-D[G],D[G]>0&&B.push(`outputIdx[${w[G]}] += ${D[G]};`);const z=`\n      float process(int outputIdx[${$.length}]) {\n        ${B.join("\n      ")}\n        return _A(outputIdx);\n      }`;return Object.assign(Object.assign({},S),{output:{dims:$,type:d.type,textureType:k.TextureType.unpacked},shaderSource:z})},v=l=>{if(!l||1!==l.length)throw new Error("Slice requires 1 input.");if(-1===A.NUMBER_TYPES.indexOf(l[0].type))throw new Error("Invalid input type.")};E.sliceV10=(l,d)=>{h(d);const f=b(l,d);return[l.run(Object.assign(Object.assign({},S),{cacheHint:f.cacheKey,get:()=>C(l,d[0],f)}),[d[0]])]};const b=(l,d)=>{if(!l.session.isInitializer(d[1].dataId)||!l.session.isInitializer(d[2].dataId)||d.length>=4&&!l.session.isInitializer(d[3].dataId)||d.length>=5&&!l.session.isInitializer(d[4].dataId))throw new Error("dynamic slice attributes are not allowed");if(d.length>=5&&d[4].integerData.some(D=>1!==D))throw new Error("currently non-1 steps is not supported for Slice");const f=Array.from(d[1].integerData),y=Array.from(d[2].integerData),w=d.length>=4?Array.from(d[3].integerData):[];return{starts:f,ends:y,axes:w,cacheKey:`${w};${f};${y}`}},h=l=>{if(!l||l.length<3||l.length>5)throw new Error("Invalid input number.");if("int32"!==l[1].type||1!==l[1].dims.length)throw new Error("Invalid input type.");if("int32"!==l[2].type||1!==l[2].dims.length)throw new Error("Invalid input type.");if(l.length>=4&&("int32"!==l[3].type||1!==l[3].dims.length))throw new Error("Invalid input type.");if(l.length>=5&&("int32"!==l[4].type||1!==l[4].dims.length))throw new Error("Invalid input type.")}},815:(me,E,P)=>{"use strict";Object.defineProperty(E,"__esModule",{value:!0}),E.softmaxV13=E.parseSoftmaxAttributesV13=E.parseSoftmaxAttributes=E.softmax=void 0;const F=P(4910),A=P(7273),O=P(6757),k=P(5639),S=P(5707),C={name:"SoftmaxComputeMax",inputNames:["A"],inputTypes:[k.TextureType.unpacked]},v={name:"SoftmaxComputeScale",inputNames:["A","Max"],inputTypes:[k.TextureType.unpacked,k.TextureType.unpacked]},b={name:"SoftMax",inputNames:["A","Max","Norm"],inputTypes:[k.TextureType.unpacked,k.TextureType.unpacked,k.TextureType.unpacked]};E.softmax=(w,D,M)=>{y(D);const $=D[0].dims.slice(),B=A.ShapeUtil.normalizeAxis(M.axis,$.length),z=A.ShapeUtil.sizeToDimension($,B),G=A.ShapeUtil.sizeFromDimension($,B);return h(w,D,M,z,G)},E.parseSoftmaxAttributes=w=>(0,F.createAttributeWithCacheKey)({axis:w.attributes.getInt("axis",1)}),E.parseSoftmaxAttributesV13=w=>(0,F.createAttributeWithCacheKey)({axis:w.attributes.getInt("axis",-1)}),E.softmaxV13=(w,D,M)=>{y(D);const $=D[0].dims.slice(),B=A.ShapeUtil.normalizeAxis(M.axis,$.length),z=$.length,G=B!==z-1,H=[];let te,ae=[],J=[];G&&(ae=Array.from({length:z}).map((ve,q)=>q),ae[B]=z-1,ae[z-1]=B,ae.map(ve=>H.push($[ve])),te=(0,F.createAttributeWithCacheKey)({perm:ae}),J=(0,S.transpose)(w,D,te));const ne=A.ShapeUtil.sizeToDimension(G?H:$,z-1),X=A.ShapeUtil.sizeFromDimension(G?H:$,z-1),K=h(w,G?J:D,M,ne,X);return G?(0,S.transpose)(w,K,te):K};const h=(w,D,M,$,B)=>{const z=l(w,D[0],$,B,[$]),G=w.run(Object.assign(Object.assign({},C),{cacheHint:M.cacheKey,get:()=>z}),D),H=d(w,D[0],$,B,z.output.dims,[$]),te=w.run(Object.assign(Object.assign({},v),{cacheHint:M.cacheKey,get:()=>H}),[D[0],G]),ae=f(w,D[0],$,B,z.output.dims,H.output.dims);return[w.run(Object.assign(Object.assign({},b),{cacheHint:M.cacheKey,get:()=>ae}),[D[0],G,te])]},l=(w,D,M,$,B)=>{const[z,G]=w.calculateTextureWidthAndHeight(D.dims,k.TextureType.unpacked),H=B.length;if(M<1||$<1)throw new Error("Logical row count N and feature count D must be greater than or equal to 1");if(1!==B.length)throw new Error("Dimensionality of the output should be 1");if(B[0]!==M)throw new Error("Shape of the output should be equal to logical row count");const te=(0,O.getGlsl)(w.session.backend.glContext.version),ae=`\n      float process(int[${H}] indices) {\n        int logical_row_start_offset = indices[0] * ${$};\n\n        float max = getColorAsFloat(${te.texture2D}(A, offsetToCoords(logical_row_start_offset, ${z},\n        ${G} )));\n        for(int i=1; i<${$}; ++i)\n        {\n          float current = getColorAsFloat(${te.texture2D}(A, offsetToCoords(logical_row_start_offset + i,\n            ${z}, ${G})));\n          if(current > max)\n          max = current;\n        }\n\n        return max;\n      }`;return Object.assign(Object.assign({},C),{output:{dims:B,type:D.type,textureType:k.TextureType.unpacked},shaderSource:ae})},d=(w,D,M,$,B,z)=>{const[G,H]=w.calculateTextureWidthAndHeight(D.dims,k.TextureType.unpacked),te=z.length;if(M<1||$<1)throw new Error("Logical row count N and feature count D must be greater than or equal to 1");if(1!==z.length)throw new Error("Dimensionality of the output should be 1");if(z[0]!==M)throw new Error("Shape of the output should be equal to logical row count");if(1!==B.length)throw new Error("Dimensionality of the intermediate results should be 1");if(B[0]!==M)throw new Error("Shape of the intermediate results should be equal to logical row count");const ae=`\n      float process(int[${te}] indices) {\n        int logical_row_start_offset = indices[0] * ${$};\n\n        float norm_factor = 0.0;\n        float max = _Max(indices);\n        for(int i=0; i<${$}; ++i)\n        {\n          norm_factor += exp(getColorAsFloat(${(0,O.getGlsl)(w.session.backend.glContext.version).texture2D}(A, offsetToCoords(logical_row_start_offset + i,\n            ${G}, ${H}))) - max);\n        }\n\n        return norm_factor;\n      }`;return Object.assign(Object.assign({},v),{output:{dims:z,type:D.type,textureType:k.TextureType.unpacked},shaderSource:ae})},f=(w,D,M,$,B,z)=>{const[G,H]=w.calculateTextureWidthAndHeight(D.dims,k.TextureType.unpacked),te=D.dims.length;if(M<1||$<1)throw new Error("Logical row count N and feature count D must be greater than or equal to 1");if(1!==B.length||1!==z.length)throw new Error("Dimensionality of the intermediate results should be 1");if(B[0]!==M||z[0]!==M)throw new Error("Shape of the intermediate results should be equal to logical row count");const ae=`\n      float process(int[${te}] indices) {\n\n      // get offset of current logical tensor index from the 2-D texture coordinates (TexCoords)\n      int offset = coordsToOffset(TexCoords, ${G}, ${H});\n\n      //determine the logical row for this index\n      int logical_row_index[1];\n      logical_row_index[0] = offset / ${$};\n\n      float norm_factor = _Norm(logical_row_index);\n\n      // avoid possible division by 0\n      // if norm_facor is 0, all elements are zero\n      // if so, return 0\n      if(norm_factor == 0.0)\n        return 0.0;\n\n      return exp(_A(indices) - _Max(logical_row_index)) / norm_factor;\n    }`;return Object.assign(Object.assign({},b),{output:{dims:D.dims,type:D.type,textureType:k.TextureType.unpacked},shaderSource:ae})},y=w=>{if(!w||1!==w.length)throw new Error("Softmax requires 1 input.");if("float32"!==w[0].type&&"float64"!==w[0].type)throw new Error("Invalid input type")}},564:(me,E,P)=>{"use strict";Object.defineProperty(E,"__esModule",{value:!0}),E.parseSplitAttributes=E.split=void 0;const F=P(4910),A=P(7273),O=P(5639),k={name:"Split",inputNames:["A"],inputTypes:[O.TextureType.unpacked]};E.split=(b,h,l)=>{v(h);const d=A.ShapeUtil.normalizeAxis(l.axis,h[0].dims.length),f=S(b,h,d,l),y=[];for(let w=0;w<f;++w)y.push(b.run(Object.assign(Object.assign({},k),{cacheHint:`${l.cacheKey};${w}`,get:()=>C(b,h[0],l,d,w)}),h));return y},E.parseSplitAttributes=b=>{const h=b.attributes.getInt("axis",0),l=b.attributes.getInts("split",[]);return(0,F.createAttributeWithCacheKey)({axis:h,split:l,numOutputs:b.outputs.length})};const S=(b,h,l,d)=>{const[,f]=A.SplitUtil.splitShape(h[0].dims,l,d.split,d.numOutputs);return f.length},C=(b,h,l,d,f)=>{const[y,w]=A.SplitUtil.splitShape(h.dims,d,l.split,l.numOutputs),M=y[f],$=`\n      float process(int indices[${M.length}]) {\n        indices[${d}] += ${w[f]};\n        return _A(indices);\n      }\n    `;return Object.assign(Object.assign({},k),{cacheHint:`${l.cacheKey}:${f}`,output:{dims:M,type:h.type,textureType:O.TextureType.unpacked},shaderSource:$})},v=b=>{if(!b||1!==b.length)throw new Error("Split requires one input.");if("int8"!==b[0].type&&"uint8"!==b[0].type&&"int16"!==b[0].type&&"uint16"!==b[0].type&&"int32"!==b[0].type&&"uint32"!==b[0].type&&"float32"!==b[0].type&&"float64"!==b[0].type&&"bool"!==b[0].type)throw new Error("Invalid input type.")}},5416:(me,E,P)=>{"use strict";Object.defineProperty(E,"__esModule",{value:!0}),E.parseSqueezeAttributes=E.squeezeV13=E.squeeze=void 0;const F=P(7273);E.squeeze=(k,S,C)=>{A(S);const v=F.ShapeUtil.squeezeShape(S[0].dims,C);return[k.reshapeUnpacked(S[0],v)]},E.squeezeV13=(k,S)=>(O(S),(0,E.squeeze)(k,[S[0]],Array.from(S[1].integerData))),E.parseSqueezeAttributes=k=>k.attributes.getInts("axes");const A=k=>{if(!k||1!==k.length)throw new Error("Squeeze requires 1 input.");if("string"===k[0].type)throw new Error("invalid input tensor types.")},O=k=>{if(!k||2!==k.length)throw new Error("Squeeze requires 2 inputs.");if("int32"!==k[1].type)throw new Error("Invalid input type.")}},1240:(me,E,P)=>{"use strict";Object.defineProperty(E,"__esModule",{value:!0}),E.sum=void 0;const F=P(6757),A=P(5639);E.sum=(S,C)=>{k(C);const v={name:"Sum",inputNames:C.map((b,h)=>`X${h}`),inputTypes:new Array(C.length).fill(A.TextureType.unpacked)};return[S.run(Object.assign(Object.assign({},v),{get:()=>O(S,C,v)}),C)]};const O=(S,C,v)=>{const b=(0,F.getGlsl)(S.session.backend.glContext.version),h=C[0].dims.slice(),l=`\n      void main() {\n        vec4 result = ${C.map((d,f)=>`${b.texture2D}(X${f},TexCoords)`).join(" + ")};\n        ${b.output} = result;\n      }\n    `;return Object.assign(Object.assign({},v),{output:{dims:h,type:C[0].type,textureType:A.TextureType.unpacked},hasMain:!0,shaderSource:l})},k=S=>{if(!S||0===S.length)throw new Error("Sum requires inputs.");const C=S[0].dims.length;for(let v=1;v<S.length;v++){if(C!==S[v].dims.length)throw new Error("Input shapes are mismatched.");for(let b=0;b<C;b++)if(S[0].dims[b]!==S[v].dims[b])throw new Error("Input shapes are not matched.")}if("float32"!==S[0].type&&"float64"!==S[0].type)throw new Error("Invalid input type.");for(let v=1;v<S.length;v++)if(S[0].type!==S[v].type)throw new Error("Input types are not matched.")}},5944:(me,E,P)=>{"use strict";Object.defineProperty(E,"__esModule",{value:!0}),E.tile=void 0;const F=P(6145),A=P(5639);E.tile=(S,C)=>{k(C);const v={name:"Tile",inputNames:["A"],inputTypes:[A.TextureType.unpacked]};return[S.run(Object.assign(Object.assign({},v),{get:()=>O(S,C,v)}),C)]};const O=(S,C,v)=>{const b=C[0].dims.slice(),h=new Array(b.length),l=[];for(let y=0;y<b.length;y++)h[y]=b[y]*C[1].numberData[y],l.push(`inputIdx[${y}] = int(mod(float(outputIdx[${y}]), ${b[y]}.));`);const d=h.length,f=`\n      float process(int outputIdx[${d}]) {\n        int inputIdx[${d}];\n        ${l.join("\n")}\n        return _A(inputIdx);\n      }\n    `;return Object.assign(Object.assign({},v),{output:{dims:h,type:C[0].type,textureType:A.TextureType.unpacked},shaderSource:f})},k=S=>{if(!S||2!==S.length)throw new Error("Tile requires 2 input.");if(1!==S[1].dims.length)throw new Error("The second input shape must 1 dimension.");if(S[1].dims[0]!==S[0].dims.length)throw new Error("Invalid input shape.");if(-1===F.NUMBER_TYPES.indexOf(S[0].type))throw new Error("Invalid input type.");if("int32"!==S[1].type&&"int16"!==S[1].type)throw new Error("Invalid repeat type.")}},5707:(me,E,P)=>{"use strict";Object.defineProperty(E,"__esModule",{value:!0}),E.parseTransposeAttributes=E.transpose=void 0;const F=P(4910),A=P(7273),O=P(5639),k={name:"Transpose",inputNames:["A"],inputTypes:[O.TextureType.unpacked]};E.transpose=(l,d,f)=>(h(d),[l.run(Object.assign(Object.assign({},k),{cacheHint:f.cacheKey,get:()=>S(l,d[0],f.perm)}),d)]),E.parseTransposeAttributes=l=>(0,F.createAttributeWithCacheKey)({perm:l.attributes.getInts("perm",[])});const S=(l,d,f)=>{const y=d.dims;f=C(y,f);const w=v(y,f),D=y.length,M=`\n      ${b("perm",f,D)}\n      float process(int indices[${D}]) {\n        int a[${D}];\n        perm(a, indices);\n        return _A(a);\n      }`;return Object.assign(Object.assign({},k),{output:{dims:w,type:d.type,textureType:O.TextureType.unpacked},shaderSource:M})},C=(l,d)=>(d&&d.length!==l.length&&(d=[...l.keys()].reverse()),d),v=(l,d)=>(d=C(l,d),A.ShapeUtil.sortBasedOnPerm(l,d)),b=(l,d,f)=>{const y=[];y.push(`void ${l}(out int a[${f}], int src[${f}]) {`);for(let w=0;w<f;++w)y.push(`\ta[${d[w]}]=src[${w}];`);return y.push("\t}"),y.join("\n")},h=l=>{if(!l||1!==l.length)throw new Error("Transpose requires 1 input.");if("float32"!==l[0].type&&"float64"!==l[0].type)throw new Error("input should be float tensor")}},2488:(me,E,P)=>{"use strict";Object.defineProperty(E,"__esModule",{value:!0}),E.encodeAsUint8=void 0;const F=P(6757),A=P(5639);E.encodeAsUint8=(O,k)=>{const S=k.shape,C=(0,F.getGlsl)(O.session.backend.glContext.version);return O.executeProgram({name:"Uint8Encode",inputTypes:[A.TextureType.unpacked],inputNames:["X"],output:{dims:S,type:k.tensor.type,textureType:A.TextureType.downloadUint8AsFloat},shaderSource:`\n    const float FLOAT_MAX = 1.70141184e38;\n    const float FLOAT_MIN = 1.17549435e-38;\n\n    bool isNaN(float val) {\n      return (val < 1.0 || 0.0 < val || val == 0.0) ? false : true;\n    }\n\n    highp vec4 encodeAsUint8(highp float v) {\n      if (isNaN(v)) {\n        return vec4(255, 255, 255, 255);\n      }\n\n      highp float av = abs(v);\n\n      if(av < FLOAT_MIN) {\n        return vec4(0.0, 0.0, 0.0, 0.0);\n      } else if(v > FLOAT_MAX) {\n        return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;\n      } else if(v < -FLOAT_MAX) {\n        return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;\n      }\n\n      highp vec4 c = vec4(0,0,0,0);\n\n      highp float e = floor(log2(av));\n      highp float m = exp2(fract(log2(av))) - 1.0;\n\n      c[2] = floor(128.0 * m);\n      m -= c[2] / 128.0;\n      c[1] = floor(32768.0 * m);\n      m -= c[1] / 32768.0;\n      c[0] = floor(8388608.0 * m);\n\n      highp float ebias = e + 127.0;\n      c[3] = floor(ebias / 2.0);\n      ebias -= c[3] * 2.0;\n      c[2] += floor(ebias) * 128.0;\n\n      c[3] += 128.0 * step(0.0, -v);\n\n      return c / 255.0;\n    }\n\n    void main() {\n      float value = ${C.texture2D}(X,TexCoords).r;\n      ${C.output} = encodeAsUint8(value);\n    }`,hasMain:!0},[k.tensor])}},9087:(me,E,P)=>{"use strict";Object.defineProperty(E,"__esModule",{value:!0}),E.tanh=E.tan=E.sqrt=E.sin=E.sigmoid=E.relu=E.not=E.neg=E.log=E.parseLeakyReluAttributes=E.leakyRelu=E.identity=E.floor=E.exp=E.parseEluAttributes=E.elu=E.cos=E.ceil=E.clipV11=E.parseClipAttributes=E.clip=E.atan=E.asin=E.acos=E.abs=E.glslTanh=E.glslTan=E.glslSqrt=E.glslSigmoid=E.glslRelu=E.glslSin=E.glslNot=E.glslNeg=E.glslLog=E.glslLeakyRelu=E.glslIdentity=E.glslClip=E.glslFloor=E.glslExp=E.glslElu=E.glslCos=E.glslCeil=E.glslAtan=E.glslAsin=E.glslAcos=E.glslAbs=void 0;const F=P(4910),A=P(7273),O=P(1997),k=P(6757),S=P(5639);function C(){return K("abs")}function v(){return K("acos")}function b(){return K("asin")}function h(){return K("atan")}function l(){return K("ceil")}function d(){return K("cos")}function f(re){const le="elu";return{body:`\n  const float alpha = float(${re});\n\n  float ${le}_(float a) {\n    return a >= 0.0 ? a: (exp(a) - 1.0) * alpha;\n  }\n  vec4 ${le}_(vec4 v) {\n    return vec4(${le}_(v.x), ${le}_(v.y), ${le}_(v.z), ${le}_(v.w));\n  }\n  `,name:le,type:O.FunctionType.ValueBased}}function y(){return K("exp")}function w(){return K("floor")}function D(re,le){const He="clip";return{body:`\n  const float min = float(${re});\n  const float max = float(${le});\n\n  float ${He}_(float a) {\n    return clamp(a, min, max);\n  }\n  vec4 ${He}_(vec4 v) {\n    return clamp(v, min, max);\n  }\n  `,name:He,type:O.FunctionType.ValueBased}}function M(){const re="indentity";return{body:`\n  float ${re}_(float a) {\n    return a;\n  }\n  vec4 ${re}_(vec4 v) {\n    return v;\n  }\n  `,name:re,type:O.FunctionType.ValueBased}}function $(re){const le="leakyRelu";return{body:`\n  const float alpha = float(${re});\n\n  float ${le}_(float a) {\n    return a < 0.0 ? a * alpha : a;\n  }\n  vec4 ${le}_(vec4 v) {\n    return vec4(${le}_(v.x), ${le}_(v.y), ${le}_(v.z), ${le}_(v.w));\n  }\n  `,name:le,type:O.FunctionType.ValueBased}}function B(){return K("log")}function z(){return{body:"\n  float neg_(float a) {\n    return -a;\n  }\n  vec4 neg_(vec4 v) {\n    return -v;\n  }\n  ",name:"neg",type:O.FunctionType.ValueBased}}function G(){const re="not";return{body:`\n  float ${re}_(float a) {\n    return float( ! bool(a) );\n  }\n  bool ${re}_(bool a) {\n    return !a;\n  }\n  vec4 ${re}_(vec4 v) {\n    return vec4(!bool(v.x), !bool(v.y), !bool(v.z), !bool(v.w));\n  }\n  bvec4 ${re}_(bvec4 v) {\n    return bvec4(!v.x, !v.y, !v.z, !v.w);\n  }\n  `,name:re,type:O.FunctionType.ValueBased}}function H(){return K("sin")}function te(){const re="relu";return{body:`\n  float ${re}_(float a) {\n    return max( a, 0.0 );\n  }\n  vec4 ${re}_(vec4 v) {\n    return max( v, 0.0 );\n  }\n  `,name:re,type:O.FunctionType.ValueBased}}function ae(){const re="sigmoid";return{body:`\n  float ${re}_(float a) {\n    return 1.0 / (1.0 + exp(-a));\n  }\n  vec4 ${re}_(vec4 v) {\n    return 1.0 / (1.0 + exp(-v));\n  }\n  `,name:re,type:O.FunctionType.ValueBased}}function J(){return K("sqrt")}function ne(){return K("tan")}function X(){const re="tanh";return{body:`\n  float ${re}_(float a) {\n    a = clamp(a, -10., 10.);\n    a = exp(2.*a);\n    return (a - 1.) / (a + 1.);\n  }\n  vec4 ${re}_(vec4 v) {\n    v = clamp(v, -10., 10.);\n    v = exp(2.*v);\n    return (v - 1.) / (v + 1.);\n  }\n  `,name:re,type:O.FunctionType.ValueBased}}function K(re){return{body:`\n  float ${re}_(float a) {\n    return ${re}(a);\n  }\n  vec4 ${re}_(vec4 v) {\n    return ${re}(v);\n  }\n  `,name:re,type:O.FunctionType.ValueBased}}E.glslAbs=C,E.glslAcos=v,E.glslAsin=b,E.glslAtan=h,E.glslCeil=l,E.glslCos=d,E.glslElu=f,E.glslExp=y,E.glslFloor=w,E.glslClip=D,E.glslIdentity=M,E.glslLeakyRelu=$,E.glslLog=B,E.glslNeg=z,E.glslNot=G,E.glslSin=H,E.glslRelu=te,E.glslSigmoid=ae,E.glslSqrt=J,E.glslTan=ne,E.glslTanh=X;const ve=(re,le,He,Le)=>{const nt={name:He.name,inputTypes:[re.session.pack?S.TextureType.packed:S.TextureType.unpacked],inputNames:["A"],cacheHint:Le};return Object.assign(Object.assign({},nt),{get:()=>((it,yt,wt,Pt)=>{const pn=it.session.pack?S.TextureType.packed:S.TextureType.unpacked,Cn=(0,k.getGlsl)(it.session.backend.glContext.version);return Object.assign(Object.assign({},yt),{output:{dims:wt.dims,type:wt.type,textureType:pn},shaderSource:`\n     ${Pt.body}\n     void main() {\n       vec4 v = ${Cn.texture2D}(A, TexCoords);\n       v = ${Pt.name}_(v);\n       ${Cn.output} = v;\n     }\n     `,hasMain:!0})})(re,nt,le,He)})};E.abs=(re,le)=>[re.run(ve(re,le[0],C()),le)],E.acos=(re,le)=>[re.run(ve(re,le[0],v()),le)],E.asin=(re,le)=>[re.run(ve(re,le[0],b()),le)],E.atan=(re,le)=>[re.run(ve(re,le[0],h()),le)],E.clip=(re,le,He)=>[re.run(ve(re,le[0],D(He.min,He.max),He.cacheKey),le)],E.parseClipAttributes=re=>(0,F.createAttributeWithCacheKey)({min:re.attributes.getFloat("min",A.MIN_CLIP),max:re.attributes.getFloat("max",A.MAX_CLIP)}),E.clipV11=(re,le)=>{const He=q(re,le);return(0,E.clip)(re,[le[0]],He)};const q=(re,le)=>{if(le.length>=3&&(!re.session.isInitializer(le[1].dataId)||!re.session.isInitializer(le[2].dataId)))throw new Error("dynamic clip attributes are not allowed");return(0,F.createAttributeWithCacheKey)({min:le.length>=3?le[1].numberData[0]:A.MIN_CLIP,max:le.length>=3?le[2].numberData[0]:A.MAX_CLIP})};E.ceil=(re,le)=>[re.run(ve(re,le[0],l()),le)],E.cos=(re,le)=>[re.run(ve(re,le[0],d()),le)],E.elu=(re,le,He)=>[re.run(ve(re,le[0],f(He.alpha),He.cacheKey),le)],E.parseEluAttributes=re=>(0,F.createAttributeWithCacheKey)({alpha:re.attributes.getFloat("alpha",1)}),E.exp=(re,le)=>[re.run(ve(re,le[0],y()),le)],E.floor=(re,le)=>[re.run(ve(re,le[0],w()),le)],E.identity=(re,le)=>[re.run(ve(re,le[0],M()),le)],E.leakyRelu=(re,le,He)=>[re.run(ve(re,le[0],$(He.alpha),He.cacheKey),le)],E.parseLeakyReluAttributes=re=>(0,F.createAttributeWithCacheKey)({alpha:re.attributes.getFloat("alpha",.01)}),E.log=(re,le)=>[re.run(ve(re,le[0],B()),le)],E.neg=(re,le)=>[re.run(ve(re,le[0],z()),le)],E.not=(re,le)=>[re.run(ve(re,le[0],G()),le)],E.relu=(re,le)=>[re.run(ve(re,le[0],te()),le)],E.sigmoid=(re,le)=>[re.run(ve(re,le[0],ae()),le)],E.sin=(re,le)=>[re.run(ve(re,le[0],H()),le)],E.sqrt=(re,le)=>[re.run(ve(re,le[0],J()),le)],E.tan=(re,le)=>[re.run(ve(re,le[0],ne()),le)],E.tanh=(re,le)=>[re.run(ve(re,le[0],X()),le)]},540:(me,E,P)=>{"use strict";Object.defineProperty(E,"__esModule",{value:!0}),E.createUnpackProgramInfoLoader=E.createUnpackProgramInfo=void 0;const F=P(6757),A=P(5639),O=P(432),k=P(5614),S={name:"unpack",inputNames:["A"],inputTypes:[A.TextureType.packed]};E.createUnpackProgramInfo=(C,v)=>{const b=v.dims.length,h=(0,k.getChannels)("rc",b),l=h.slice(-2),d=(0,O.getCoordsDataType)(b),f=(0,k.unpackFromChannel)(),y=0===v.dims.length?"":function(M,$){if(1===M)return"rc";let B="";for(let z=0;z<M;z++)B+=$[z],z<M-1&&(B+=",");return B}(b,h),w=b<=1?"rc":`vec2(${l.join(",")})`,D=`\n    ${f}\n    void main() {\n      ${d} rc = getOutputCoords();\n\n       // Sample the texture with the coords to get the rgba channel value.\n       vec4 packedInput = getA(${y});\n\n       ${(0,F.getGlsl)(C.session.backend.glContext.version).output} = vec4(getChannel(packedInput, ${w}), 0, 0, 0);\n     }\n   `;return Object.assign(Object.assign({},S),{hasMain:!0,output:{dims:v.dims,type:v.type,textureType:A.TextureType.unpacked},shaderSource:D})},E.createUnpackProgramInfoLoader=(C,v)=>Object.assign(Object.assign({},S),{get:()=>(0,E.createUnpackProgramInfo)(C,v)})},7862:(me,E,P)=>{"use strict";Object.defineProperty(E,"__esModule",{value:!0}),E.parseUnsqueezeAttributes=E.unsqueezeV13=E.unsqueeze=void 0;const F=P(7273);E.unsqueeze=(k,S,C)=>{A(S);const v=F.ShapeUtil.unsqueezeShape(S[0].dims,C);return[k.reshapeUnpacked(S[0],v)]},E.unsqueezeV13=(k,S)=>(O(S),(0,E.unsqueeze)(k,[S[0]],Array.from(S[1].integerData))),E.parseUnsqueezeAttributes=k=>k.attributes.getInts("axes");const A=k=>{if(!k||1!==k.length)throw new Error("Unsqueeze requires 1 input.");if("string"===k[0].type)throw new Error("invalid input tensor types.")},O=k=>{if(!k||2!==k.length)throw new Error("Unsqueeze requires 2 inputs.");if("int32"!==k[1].type)throw new Error("Invalid input type.")}},3980:(me,E,P)=>{"use strict";Object.defineProperty(E,"__esModule",{value:!0}),E.scalesValidation=E.validateInputs=E.parseUpsampleAttributes=E.parseUpsampleAttributesV9=E.parseUpsampleAttributesV7=E.upsample=void 0;const F=P(4910),A=P(6757),O=P(5639),k={name:"Upsample",inputNames:["X"],inputTypes:[O.TextureType.unpacked]};E.upsample=(C,v,b)=>((0,E.validateInputs)(v,b),[C.run(Object.assign(Object.assign({},k),{cacheHint:b.cacheKey,get:()=>S(C,v,b)}),v)]),E.parseUpsampleAttributesV7=C=>(0,E.parseUpsampleAttributes)(C,7),E.parseUpsampleAttributesV9=C=>(0,E.parseUpsampleAttributes)(C,9),E.parseUpsampleAttributes=(C,v)=>{const b=v>=10,h=C.attributes.getString("mode","nearest");if("nearest"!==h&&"linear"!==h&&(v<11||"cubic"!==h))throw new Error(`unrecognized mode: ${h}`);let l=[];v<9&&(l=C.attributes.getFloats("scales"),(0,E.scalesValidation)(l,h,b));const d=C.attributes.getFloat("extrapolation_value",0),f=v>10?C.attributes.getString("coordinate_transformation_mode","half_pixel"):"asymmetric";if(-1===["asymmetric","pytorch_half_pixel","tf_half_pixel_for_nn","align_corners","tf_crop_and_resize","half_pixel"].indexOf(f))throw new Error(`coordinate_transform_mode '${f}' is not supported`);const y="tf_crop_and_resize"===f,w=y,D="nearest"===h&&v>=11?C.attributes.getString("nearest_mode","round_prefer_floor"):"";if(-1===["round_prefer_floor","round_prefer_ceil","floor","ceil",""].indexOf(D))throw new Error(`nearest_mode '${D}' is not supported`);const M=C.attributes.getFloat("cubic_coeff_a",-.75),$=0!==C.attributes.getInt("exclude_outside",0);if($&&"cubic"!==h)throw new Error("exclude_outside can be set to 1 only when mode is CUBIC.");let z=0,G=0,H=0;return v>10?C.inputs.length>2?(z=1,G=2,H=3):(G=1,H=2):9===v&&(G=1),(0,F.createAttributeWithCacheKey)({opset:v,isResize:b,mode:h,scales:l,extrapolationValue:d,coordinateTransformMode:f,useExtrapolation:w,needRoiInput:y,nearestMode:D,cubicCoefficientA:M,excludeOutside:$,useNearest2xOptimization:v<11||"nearest"===h&&"asymmetric"===f&&"floor"===D,roiInputIdx:z,scalesInputIdx:G,sizesInputIdx:H})};const S=(C,v,b)=>{const h=(0,A.getGlsl)(C.session.backend.glContext.version),[l,d]=C.calculateTextureWidthAndHeight(v[0].dims,O.TextureType.unpacked),f=v[0].dims.map((H,te)=>Math.floor(H*b.scales[te])),[y,w]=C.calculateTextureWidthAndHeight(f,O.TextureType.unpacked),D=f.length,M=new Array(D),$=new Array(D);let B=`\n      int output_pitches[${D}];\n      int input_pitches[${D}];\n      `;for(let H=D-1;H>=0;H--)M[H]=H===D-1?1:M[H+1]*f[H+1],$[H]=H===D-1?1:$[H+1]*v[0].dims[H+1],B+=`\n        output_pitches[${H}] = ${M[H]};\n        input_pitches[${H}] = ${$[H]};\n        `;const z=`\n      float getInputFloat(int index) {\n        vec2 coords = offsetToCoords(index, ${l}, ${d});\n        float value = getColorAsFloat(${h.texture2D}(X, coords));\n        return value;\n      }\n      `,G="nearest"===b.mode?`\n    ${z}\n    float process(int indices[${D}]) {\n      int input_index = 0;\n      int output_index = coordsToOffset(TexCoords, ${y}, ${w});\n\n      ${B}\n\n      int d, m;\n      for (int dim = 0; dim < ${D}; ++dim) {\n        d = output_index / output_pitches[dim];\n        m = output_index - d * output_pitches[dim];\n        output_index = m;\n\n        if (scales[dim] != 1 && d > 0) {\n          int d2 = d / scales[dim];\n          m = d - d2 * scales[dim];\n          d = d2;\n        }\n        input_index += input_pitches[dim] * d;\n      }\n\n      return getInputFloat(input_index);\n    }`:4===D?`\n    ${z}\n    float process(int indices[4]) {\n      int input_index = 0;\n      int output_index = coordsToOffset(TexCoords, ${y}, ${w});\n\n      ${B}\n\n      int m;\n      int index_of_dim0, index_of_dim1, index_of_dim2, index_of_dim3;\n      index_of_dim0 = output_index / output_pitches[0];\n      m = output_index - index_of_dim0 * output_pitches[0];\n      index_of_dim1 = m / output_pitches[1];\n      m = m - index_of_dim1 * output_pitches[1];\n      index_of_dim2 = m / output_pitches[2];\n      m = m - index_of_dim2 * output_pitches[2];\n      index_of_dim3 = m;\n\n      int index_of_input_dim2, index_of_input_dim3, x_offset, y_offset;\n      index_of_input_dim2 = index_of_dim2 / scales[2];\n      y_offset = index_of_dim2 - index_of_input_dim2 * scales[2];\n      index_of_input_dim3 = index_of_dim3 / scales[3];\n      x_offset = index_of_dim3 - index_of_input_dim3 * scales[3];\n\n      input_index = index_of_dim0 * input_pitches[0] +\n            index_of_dim1 * input_pitches[1] +\n            index_of_input_dim2 * input_pitches[2] +\n            index_of_input_dim3;\n\n      float x00 = getInputFloat(input_index);\n      float x10, x01, x11;\n\n      bool end_of_dim2 = false;\n      if (index_of_input_dim2 == (${v[0].dims[2]} - 1)) {\n        // It's the end in dimension 2\n        x01 = x00;\n        end_of_dim2 = true;\n      } else {\n        x01 = getInputFloat(input_index + input_pitches[2]);\n      }\n\n      if (index_of_input_dim3 == (input_pitches[2] - 1)) {\n        // It's the end in dimension 3\n        x10 = x00;\n        x11 = x01;\n      }\n      else {\n        x10 = getInputFloat(input_index + 1);\n        x11 = end_of_dim2 ? x10 : getInputFloat(input_index + input_pitches[2] + 1);\n      }\n\n      float y0 = x00 + float(y_offset) * (x01 - x00) / float(scales[2]);\n      float y1 = x10 + float(y_offset) * (x11 - x10) / float(scales[2]);\n      return y0 + float(x_offset) * (y1 - y0) / float(scales[3]);\n    }`:`\n    ${z}\n    float process(int indices[2]) {\n      int input_index = 0;\n      int output_index = coordsToOffset(TexCoords, ${y}, ${w});\n\n      ${B}\n\n      int m;\n      int index_of_dim0, index_of_dim1;\n      index_of_dim0 = output_index / output_pitches[0];\n      m = output_index - index_of_dim0 * output_pitches[0];\n      index_of_dim1 = m;\n\n      int index_of_input_dim0, index_of_input_dim1, x_offset, y_offset;\n      index_of_input_dim0 = index_of_dim0 / scales[0];\n      y_offset = index_of_dim0 - index_of_input_dim0 * scales[0];\n      index_of_input_dim1 = index_of_dim1 / scales[1];\n      x_offset = index_of_dim1 - index_of_input_dim1 * scales[1];\n\n      input_index = index_of_input_dim0 * input_pitches[0] + index_of_input_dim1;\n\n      float x00 = getInputFloat(input_index);\n      float x10, x01, x11;\n\n      bool end_of_dim0 = false;\n      if (index_of_input_dim0 == (${v[0].dims[0]} - 1)) {\n        // It's the end in dimension 0\n        x01 = x00;\n        end_of_dim0 = true;\n      } else {\n        x01 = getInputFloat(input_index + input_pitches[0]);\n      }\n\n      if (index_of_input_dim1 == (input_pitches[0] - 1)) {\n        // It's the end in dimension 1\n        x10 = x00;\n        x11 = x01;\n      }\n      else {\n        x10 = getInputFloat(input_index + 1);\n        x11 = end_of_dim0 ? x10 : getInputFloat(input_index + input_pitches[0] + 1);\n      }\n\n      float y0 = x00 + float(y_offset) * (x01 - x00) / float(scales[0]);\n      float y1 = x10 + float(y_offset) * (x11 - x10) / float(scales[0]);\n      return y0 + float(x_offset) * (y1 - y0) / float(scales[1]);\n    }`;return Object.assign(Object.assign({},k),{output:{dims:f,type:v[0].type,textureType:O.TextureType.unpacked},shaderSource:G,variables:[{name:"scales",type:"int",arrayLength:b.scales.length,data:b.scales.map(H=>Math.ceil(H))}]})};E.validateInputs=(C,v)=>{if(!C||v.opset<9&&1!==C.length||v.opset>=9&&v.opset<11&&2!==C.length||v.opset>=11&&C.length<2)throw new Error("invalid inputs.");if(v.scales.length>0&&C[0].dims.length!==v.scales.length)throw new Error("Invalid input shape.");if("string"===C[0].type)throw new Error("Invalid input tensor types.")},E.scalesValidation=(C,v,b)=>{if(b){for(const h of C)if(h<=0)throw new Error("Scale value should be greater than 0.")}else for(const h of C)if(h<1)throw new Error("Scale value should be greater than or equal to 1.");if(!("linear"!==v&&"cubic"!==v||2===C.length||4===C.length&&1===C[0]&&1===C[1]))throw new Error(`'Linear' mode and 'Cubic' mode only support 2-D inputs ('Bilinear', 'Bicubic')         or 4-D inputs with the corresponding outermost 2 scale values being 1         in the ${b?"Resize":"Upsample"} opeartor.`)}},2757:(me,E,P)=>{"use strict";Object.defineProperty(E,"__esModule",{value:!0}),E.ProgramManager=void 0;const F=P(2235),A=P(1315),O=P(8897),k=P(6757);E.ProgramManager=class{constructor(S,C,v){this.profiler=S,this.glContext=C,this.textureLayoutStrategy=v,this.repo=new Map,this.attributesBound=!1}getArtifact(S){return this.repo.get(S)}setArtifact(S,C){this.repo.set(S,C)}run(S,C,v){var b;this.profiler.event("op",`ProgramManager.run ${null!==(b=S.programInfo.name)&&void 0!==b?b:"unknown kernel"}`,()=>{var h;this.glContext.gl.useProgram(S.program);try{this.bindOutput(v),this.attributesBound||this.bindAttributes(S.attribLocations),this.bindUniforms(S.uniformLocations,null!==(h=S.programInfo.variables)&&void 0!==h?h:[],C)}catch(f){throw A.Logger.error("ProgramManager",S.programInfo.shaderSource),f}this.profiler.event("backend","GlContext.draw()",()=>{this.glContext.draw()})},this.glContext)}dispose(){this.vertexShader&&this.glContext.deleteShader(this.vertexShader),this.repo.forEach(S=>this.glContext.deleteProgram(S.program))}build(S,C,v){return this.profiler.event("backend","ProgramManager.build",()=>{const b=new O.GlslPreprocessor(this.glContext,S,C,v),h=b.preprocess(),l=this.compile(h);return{programInfo:S,program:l,uniformLocations:this.getUniformLocations(l,b.context.programInfo.inputNames,b.context.programInfo.variables),attribLocations:this.getAttribLocations(l)}})}compile(S){if(!this.vertexShader){A.Logger.verbose("ProrgramManager","Compiling and caching Vertex shader for the first time");const b=(0,k.getVertexShaderSource)(this.glContext.version);this.vertexShader=this.glContext.compileShader(b,this.glContext.gl.VERTEX_SHADER)}F.env.debug&&A.Logger.verbose("ProrgramManager",`FragShader:\n${S}\n`);const C=this.glContext.compileShader(S,this.glContext.gl.FRAGMENT_SHADER),v=this.glContext.createProgram(this.vertexShader,C);return this.glContext.deleteShader(C),v}bindOutput(S){const C=S.width,v=S.height;A.Logger.verbose("ProrgramManager",`Binding output texture to Framebuffer: w/h=${C}/${v}, shape=${S.shape}, type=${S.tensor.type}`),this.glContext.attachFramebuffer(S.texture,C,v)}bindAttributes(S){this.glContext.setVertexAttributes(S.position,S.textureCoord),this.attributesBound=!0}bindUniforms(S,C,v){var b;const h=this.glContext.gl;let l=0;for(const{name:d,type:f,location:y,arrayLength:w}of S){const D=null===(b=C.find(M=>M.name===d))||void 0===b?void 0:b.data;if("sampler2D"!==f&&!D)throw new Error(`variable '${d}' does not have data defined in program info`);switch(f){case"sampler2D":this.bindTexture(v[l],y,l),l++;break;case"float":w?h.uniform1fv(y,D):h.uniform1f(y,D);break;case"int":w?h.uniform1iv(y,D):h.uniform1i(y,D);break;default:throw new Error(`Uniform not implemented: ${f}`)}}}bindTexture(S,C,v){this.glContext.bindTextureToUniform(S.texture,v,C)}getAttribLocations(S){return{position:this.getAttribLocation(S,"position"),textureCoord:this.getAttribLocation(S,"textureCoord")}}getUniformLocations(S,C,v){const b=[];if(C)for(const h of C)b.push({name:h,type:"sampler2D",location:this.getUniformLocation(S,h)});if(v)for(const h of v)b.push(Object.assign(Object.assign({},h),{location:this.getUniformLocation(S,h.name)}));return b}getUniformLocation(S,C){const v=this.glContext.gl.getUniformLocation(S,C);if(null===v)throw new Error(`Uniform ${C} not found.`);return v}getAttribLocation(S,C){return this.glContext.gl.getAttribLocation(S,C)}}},2171:(me,E,P)=>{"use strict";Object.defineProperty(E,"__esModule",{value:!0}),E.WebGLSessionHandler=void 0;const F=P(1315),A=P(5881),O=P(7860),k=P(4110),S=P(2757),C=P(7618),v=P(5243);E.WebGLSessionHandler=class{constructor(b,h){this.backend=b,this.context=h,this.layoutStrategy=new C.PreferLogicalStrategy(b.glContext.maxTextureSize),this.programManager=new S.ProgramManager(this.context.profiler,b.glContext,this.layoutStrategy),this.textureManager=new v.TextureManager(b.glContext,this.layoutStrategy,this.context.profiler,{reuseTextures:"full"===b.textureCacheMode}),this.packedTextureDataCache=new Map,this.unpackedTextureDataCache=new Map,this.pack=b.pack,this.pack2unpackMap=new Map,this.unpack2packMap=new Map}createInferenceHandler(){return new O.WebGLInferenceHandler(this)}onGraphInitialized(b){const h=b.getValues().filter(l=>-1===l.from&&l.tensor).map(l=>l.tensor.dataId);this.initializers=new Set(h)}isInitializer(b){return!!this.initializers&&this.initializers.has(b)}addInitializer(b){this.initializers.add(b)}getTextureData(b,h){return h?this.packedTextureDataCache.get(b):this.unpackedTextureDataCache.get(b)}setTextureData(b,h,l=!1){F.Logger.verbose("WebGLSessionHandler","Storing Texture data in cache"),l?this.packedTextureDataCache.set(b,h):this.unpackedTextureDataCache.set(b,h)}dispose(){this.programManager.dispose(),this.textureManager.clearActiveTextures(),this.packedTextureDataCache.forEach(b=>this.textureManager.releaseTexture(b,!0)),this.packedTextureDataCache=new Map,this.unpackedTextureDataCache.forEach(b=>this.textureManager.releaseTexture(b,!0)),this.unpackedTextureDataCache=new Map}resolve(b,h,l){const d=(0,A.resolveOperator)(b,h,k.WEBGL_OP_RESOLVE_RULES);return{impl:d.opImpl,context:d.opInit?d.opInit(b,l):b}}}},9622:(me,E,P)=>{"use strict";Object.defineProperty(E,"__esModule",{value:!0}),E.Uint8DataEncoder=E.RGBAFloatDataEncoder=E.RedFloat32DataEncoder=void 0;const F=P(1315);E.RedFloat32DataEncoder=class{constructor(A,O=1){if(1===O)this.internalFormat=A.R32F,this.format=A.RED,this.textureType=A.FLOAT,this.channelSize=O;else{if(4!==O)throw new Error(`Invalid number of channels: ${O}`);this.internalFormat=A.RGBA32F,this.format=A.RGBA,this.textureType=A.FLOAT,this.channelSize=O}}encode(A,O){let k,S;return A.constructor!==Float32Array&&(F.Logger.warning("Encoder","data was not of type Float32; creating new Float32Array"),S=new Float32Array(A)),O*this.channelSize>A.length?(F.Logger.warning("Encoder","Source data too small. Allocating larger array"),S=A,k=this.allocate(O*this.channelSize),S.forEach((C,v)=>k[v]=C)):(S=A,k=S),k}allocate(A){return new Float32Array(4*A)}decode(A,O){return 1===this.channelSize?A.filter((k,S)=>S%4==0).subarray(0,O):A.subarray(0,O)}},E.RGBAFloatDataEncoder=class{constructor(A,O=1,k){if(1!==O&&4!==O)throw new Error(`Invalid number of channels: ${O}`);this.internalFormat=A.RGBA,this.format=A.RGBA,this.channelSize=O,this.textureType=k||A.FLOAT}encode(A,O){let k=A;return 1===this.channelSize&&(F.Logger.verbose("Encoder","Exploding into a larger array"),k=this.allocate(O),A.forEach((S,C)=>k[4*C]=S)),k}allocate(A){return new Float32Array(4*A)}decode(A,O){return 1===this.channelSize?A.filter((k,S)=>S%4==0).subarray(0,O):A.subarray(0,O)}},E.Uint8DataEncoder=class{constructor(A,O=1){if(this.channelSize=4,1===O)this.internalFormat=A.ALPHA,this.format=A.ALPHA,this.textureType=A.UNSIGNED_BYTE,this.channelSize=O;else{if(4!==O)throw new Error(`Invalid number of channels: ${O}`);this.internalFormat=A.RGBA,this.format=A.RGBA,this.textureType=A.UNSIGNED_BYTE,this.channelSize=O}}encode(A,O){return new Uint8Array(A.buffer,A.byteOffset,A.byteLength)}allocate(A){return new Uint8Array(A*this.channelSize)}decode(A,O){if(A instanceof Uint8Array)return A.subarray(0,O);throw new Error(`Invalid array type: ${A.constructor}`)}}},7618:(me,E,P)=>{"use strict";Object.defineProperty(E,"__esModule",{value:!0}),E.getBatchDim=E.sizeToSquarishShape=E.getRowsCols=E.sizeFromShape=E.isInt=E.parseAxisParam=E.squeezeShape=E.PreferLogicalStrategy=E.AlwaysKeepOriginalSizeStrategy=void 0;const F=P(1315),A=P(7273);function O(b,h){const l=[],d=[],f=null!=h&&Array.isArray(h)&&0===h.length,y=null==h||f?null:k(h,b).sort();let w=0;for(let D=0;D<b.length;++D){if(null!=y){if(y[w]===D&&1!==b[D])throw new Error(`Can't squeeze axis ${D} since its dim '${b[D]}' is not 1`);(null==y[w]||y[w]>D)&&1===b[D]&&(l.push(b[D]),d.push(D)),y[w]<=D&&w++}1!==b[D]&&(l.push(b[D]),d.push(D))}return{newShape:l,keptDims:d}}function k(b,h){const l=h.length;return b=null==b?h.map((d,f)=>f):[].concat(b),(0,A.assert)(b.every(d=>d>=-l&&d<l),()=>`All values in axis param must be in range [-${l}, ${l}) but got axis ${b}`),(0,A.assert)(b.every(S),()=>`All values in axis param must be integers but got axis ${b}`),b.map(d=>d<0?l+d:d)}function S(b){return b%1==0}function C(b){if(0===b.length)return 1;let h=b[0];for(let l=1;l<b.length;l++)h*=b[l];return h}function v(b){const h=Math.ceil(Math.sqrt(b));return[h,Math.ceil(b/h)]}E.AlwaysKeepOriginalSizeStrategy=class{constructor(b){this.maxTextureSize=b}computeTextureWH(b,h){if(0===b.length)return[1,1];const l=this.maxTextureSize;if(h&&void 0!==h.breakAxis){const y=h.breakAxis>=b.length?1:b.slice(h.breakAxis).reduce((D,M)=>D*M),w=h.breakAxis<=0?1:b.slice(0,h.breakAxis).reduce((D,M)=>D*M);if(!(y>l||w>l))return[y,w];F.Logger.verbose("TextureLayout",`Given width/height preferences were unattainable: shape:${b}, breakAxis:${h.breakAxis}`)}const d=b.reduce((y,w)=>y*w);let f=Math.floor(Math.sqrt(d));for(;f<l&&f<d&&d%f!=0;f++);if(f>=l||d%f!=0)throw new Error(`The given dimensions are outside this GPU's boundaries: ${b}`);return[f,d/f]}},E.PreferLogicalStrategy=class{constructor(b){this.maxTextureSize=b}computeTextureWH(b,h){const l=this.computeTexture(b,h);return h&&h.isPacked&&(l[0]/=2,l[1]/=2),h&&h.reverseWH?[l[1],l[0]]:l}computeTexture(b,h){const l=h&&h.isPacked;if(0===b.length)return l?[2,2]:[1,1];let d=this.maxTextureSize;if(h&&void 0!==h.breakAxis){const w=h.breakAxis>=b.length?1:b.slice(h.breakAxis).reduce((M,$)=>M*$),D=h.breakAxis<=0?1:b.slice(0,h.breakAxis).reduce((M,$)=>M*$);if(!(w>d||D>d))return[w,D];F.Logger.verbose("TextureLayout",`Given width/height preferences were unattainable: shape:${b}, breakAxis:${h.breakAxis}`)}let f=b.slice(0);l&&(d*=2,f=f.map((w,D)=>D>=f.length-2?f[D]%2==0?f[D]:f[D]+1:f[D]),1===f.length&&(f=[2,f[0]])),2!==f.length&&(f=O(f).newShape);const y=C(f);return f.length<=1&&y<=d?[1,y]:2===f.length&&f[0]<=d&&f[1]<=d?f:3===f.length&&f[0]*f[1]<=d&&f[2]<=d?[f[0]*f[1],f[2]]:3===f.length&&f[0]<=d&&f[1]*f[2]<=d?[f[0],f[1]*f[2]]:4===f.length&&f[0]*f[1]*f[2]<=d&&f[3]<=d?[f[0]*f[1]*f[2],f[3]]:4===f.length&&f[0]<=d&&f[1]*f[2]*f[3]<=d?[f[0],f[1]*f[2]*f[3]]:l?v(y/4).map(w=>2*w):v(y)}},E.squeezeShape=O,E.parseAxisParam=k,E.isInt=S,E.sizeFromShape=C,E.getRowsCols=function(b){if(0===b.length)throw Error("Cannot get rows and columns of an empty shape array.");return[b.length>1?b[b.length-2]:1,b[b.length-1]]},E.sizeToSquarishShape=v,E.getBatchDim=function(b,h=2){return C(b.slice(0,b.length-h))}},3314:(me,E,P)=>{"use strict";Object.defineProperty(E,"__esModule",{value:!0}),E.createTextureLayoutFromShape=E.calculateTextureWidthAndHeight=E.createTextureLayoutFromTextureType=void 0;const F=P(7273),A=P(5639);E.createTextureLayoutFromTextureType=(O,k,S)=>{const C=S===A.TextureType.unpacked||S===A.TextureType.unpackedReversed?1:4,v=S===A.TextureType.packed,b=S===A.TextureType.unpackedReversed||S===A.TextureType.packed,h=S===A.TextureType.packedLastDimension?k.length-1:void 0,l=S===A.TextureType.packedLastDimension?k.map((d,f)=>f===k.length-1?4*d:d):void 0;return(0,E.createTextureLayoutFromShape)(O,k,C,l,{isPacked:v,reverseWH:b,breakAxis:h})},E.calculateTextureWidthAndHeight=(O,k,S)=>{const C=(0,E.createTextureLayoutFromTextureType)(O,k,S);return[C.width,C.height]},E.createTextureLayoutFromShape=(O,k,S=1,C,v)=>{const b=!(!v||!v.isPacked),[h,l]=O.computeTextureWH(b&&C||k,v),d=k.length;let f=k.slice(0);if(0===d&&(f=[1]),1===S)C=k;else if(b){if(4!==S)throw new Error("a packed texture must be 4-channel");C=k,d>0&&(f[d-1]=Math.ceil(f[d-1]/2)),d>1&&(f[d-2]=Math.ceil(f[d-2]/2))}else if(!C)throw new Error("Unpacked shape is needed when using channels > 1");return{width:h,height:l,channels:S,isPacked:b,shape:f,strides:F.ShapeUtil.computeStrides(f),unpackedShape:C,reversedWH:v&&v.reverseWH}}},5243:(me,E,P)=>{"use strict";Object.defineProperty(E,"__esModule",{value:!0}),E.TextureManager=void 0;const F=P(1315);E.TextureManager=class{constructor(A,O,k,S){this.glContext=A,this.layoutStrategy=O,this.profiler=k,this.config=S,this.pendingRead=new Map,S.reuseTextures&&(this.inUseTextures=new Map,this.idleTextures=new Map,this.textureLookup=new Map)}createTextureFromLayout(A,O,k,S){const C=this.toEncoderType(A),v=this.glContext.getEncoder(C,O.channels||1,S);if(O.isPacked&&1===S)throw new Error("not implemented");const b=O.width,h=O.height;let l,d;if(this.config.reuseTextures){l=`${b}x${h}_${v.format}_${v.internalFormat}_${v.textureType}`,d=this.inUseTextures.get(l),d||(d=[],this.inUseTextures.set(l,d));const y=this.idleTextures.get(l);if(y&&y.length>0){const w=y.pop();return d.push(w),1===S&&this.glContext.updateTexture(w,b,h,v,this.toTextureData(A,k)),w}}F.Logger.verbose("TextureManager",`Creating new texture of size ${O.width}x${O.height}`);const f=this.glContext.allocateTexture(b,h,v,this.toTextureData(A,k));return this.config.reuseTextures&&(d.push(f),this.textureLookup.set(f,l)),f}readTexture(A,O,k){return k||(k=1),this.profiler.event("backend","TextureManager.readTexture",()=>{const S=A.shape.reduce((v,b)=>v*b)*k,C=this.glContext.readTexture(A.texture,A.width,A.height,S,this.toEncoderType(O),k);return this.toTensorData(O,C)})}readTextureAsync(A,O,k){var S=this;return _asyncToGenerator(function*(){const C=A.tensor.dataId;if(k||(k=1),S.pendingRead.has(C)){const v=S.pendingRead.get(C);return new Promise(b=>v?.push(b))}return S.profiler.event("backend","TextureManager.readTextureAsync",_asyncToGenerator(function*(){S.pendingRead.set(C,[]);const v=A.shape.reduce((d,f)=>d*f)*k;yield S.glContext.createAndWaitForFence();const b=S.glContext.readTexture(A.texture,A.width,A.height,v,S.toEncoderType(O),k),h=S.toTensorData(O,b),l=S.pendingRead.get(C);return S.pendingRead.delete(C),l?.forEach(d=>d(h)),h}))})()}readUint8TextureAsFloat(A){return this.profiler.event("backend","TextureManager.readUint8TextureAsFloat",()=>{const O=A.shape.reduce((S,C)=>S*C),k=this.glContext.readTexture(A.texture,A.width,A.height,4*O,"byte",4);return new Float32Array(k.buffer,k.byteOffset,O)})}releaseTexture(A,O){let k;if(this.config.reuseTextures&&(k=this.textureLookup.get(A.texture),k)){O&&this.textureLookup.delete(k);const S=this.inUseTextures.get(k);if(S){const C=S.indexOf(A.texture);if(-1!==C){S.splice(C,1);let v=this.idleTextures.get(k);v||(v=[],this.idleTextures.set(k,v)),v.push(A.texture)}}}k&&!O||(F.Logger.verbose("TextureManager",`Deleting texture of size ${A.width}x${A.height}`),this.glContext.deleteTexture(A.texture))}toTensorData(A,O){switch(A){case"int16":return O instanceof Int16Array?O:Int16Array.from(O);case"int32":return O instanceof Int32Array?O:Int32Array.from(O);case"int8":return O instanceof Int8Array?O:Int8Array.from(O);case"uint16":return O instanceof Uint16Array?O:Uint16Array.from(O);case"uint32":return O instanceof Uint32Array?O:Uint32Array.from(O);case"uint8":case"bool":return O instanceof Uint8Array?O:Uint8Array.from(O);case"float32":return O instanceof Float32Array?O:Float32Array.from(O);case"float64":return O instanceof Float64Array?O:Float64Array.from(O);default:throw new Error(`TensorData type ${A} is not supported`)}}toTextureData(A,O){if(O)return O instanceof Float32Array?O:new Float32Array(O)}toEncoderType(A){return"float"}clearActiveTextures(){this.glContext.clearActiveTextures()}}},5639:(me,E)=>{"use strict";var P;Object.defineProperty(E,"__esModule",{value:!0}),E.TextureType=void 0,(P=E.TextureType||(E.TextureType={}))[P.unpacked=0]="unpacked",P[P.unpackedReversed=1]="unpackedReversed",P[P.packed=2]="packed",P[P.downloadUint8AsFloat=3]="downloadUint8AsFloat",P[P.packedLastDimension=4]="packedLastDimension"},432:(me,E,P)=>{"use strict";Object.defineProperty(E,"__esModule",{value:!0}),E.getGlChannels=E.getCoordsDataType=E.getSqueezedParams=E.squeezeInputShape=E.generateShaderFuncNameFromInputSamplerNameAtOutCoords=E.generateShaderFuncNameFromInputSamplerName=E.repeatedTry=E.getPackedShape=void 0;const F=P(7273);E.getPackedShape=function(A){const O=A.length;return A.slice(0,O-1).concat(A[O-1]/4)},E.repeatedTry=function(){var A=_asyncToGenerator(function*(O,k=(C=>0),S){return new Promise((C,v)=>{let b=0;const h=()=>{if(O())return void C();b++;const l=k(b);null!=S&&b>=S?v():setTimeout(h,l)};h()})});return function(O){return A.apply(this,arguments)}}(),E.generateShaderFuncNameFromInputSamplerName=function(A){return(0,F.assert)(void 0!==A&&0!==A.length,()=>"empty string found for sampler name"),"get"+A.charAt(0).toUpperCase()+A.slice(1)},E.generateShaderFuncNameFromInputSamplerNameAtOutCoords=function(A){return(0,F.assert)(void 0!==A&&0!==A.length,()=>"empty string found for sampler name"),"get"+A.charAt(0).toUpperCase()+A.slice(1)+"AtOutCoords"},E.squeezeInputShape=function(A,O){let k=JSON.parse(JSON.stringify(A));return k=O,k},E.getSqueezedParams=function(A,O){return O.map(k=>A[k]).join(", ")},E.getCoordsDataType=function(A){if(A<=1)return"int";if(2===A)return"ivec2";if(3===A)return"ivec3";if(4===A)return"ivec4";if(5===A)return"ivec5";if(6===A)return"ivec6";throw Error(`GPU for rank ${A} is not yet supported`)},E.getGlChannels=function(A=6){return["x","y","z","w","u","v"].slice(0,A)}},3389:(me,E,P)=>{"use strict";Object.defineProperty(E,"__esModule",{value:!0}),E.createNewWebGLContext=E.createWebGLContext=void 0;const F=P(1315),A=P(3524),O={};function k(S,C){let v;const b={alpha:!1,depth:!1,antialias:!1,stencil:!1,preserveDrawingBuffer:!1,premultipliedAlpha:!1,failIfMajorPerformanceCaveat:!1};if((!C||"webgl2"===C)&&(v=S.getContext("webgl2",b),v))try{return new A.WebGLContext(v,2)}catch(h){F.Logger.warning("GlContextFactory",`failed to create WebGLContext using contextId 'webgl2'. Error: ${h}`)}if((!C||"webgl"===C)&&(v=S.getContext("webgl",b)||S.getContext("experimental-webgl",b),v))try{return new A.WebGLContext(v,1)}catch(h){F.Logger.warning("GlContextFactory",`failed to create WebGLContext using contextId 'webgl' or 'experimental-webgl'. Error: ${h}`)}throw new Error("WebGL is not supported")}E.createWebGLContext=function S(C){let v;if(C&&"webgl2"!==C||!("webgl2"in O)?C&&"webgl"!==C||!("webgl"in O)||(v=O.webgl):v=O.webgl2,!v)try{v=k(function(){if(typeof OffscreenCanvas>"u")throw new TypeError("failed to create offscreen canvas: OffscreenCanvas is not supported");return new OffscreenCanvas(1,1)}(),C)}catch{v=k(function(){if(typeof document>"u")throw new TypeError("failed to create canvas: document is not supported");const l=document.createElement("canvas");return l.width=1,l.height=1,l}(),C)}const b=v.gl;return O[C=C||1===v.version?"webgl":"webgl2"]=v,b.isContextLost()?(delete O[C],S(C)):(b.disable(b.DEPTH_TEST),b.disable(b.STENCIL_TEST),b.disable(b.BLEND),b.disable(b.DITHER),b.disable(b.POLYGON_OFFSET_FILL),b.disable(b.SAMPLE_COVERAGE),b.enable(b.SCISSOR_TEST),b.enable(b.CULL_FACE),b.cullFace(b.BACK),v)},E.createNewWebGLContext=k},3524:function(me,E,P){"use strict";var F=this&&this.__createBinding||(Object.create?function(b,h,l,d){void 0===d&&(d=l);var f=Object.getOwnPropertyDescriptor(h,l);f&&!("get"in f?!h.__esModule:f.writable||f.configurable)||(f={enumerable:!0,get:function(){return h[l]}}),Object.defineProperty(b,d,f)}:function(b,h,l,d){void 0===d&&(d=l),b[d]=h[l]}),A=this&&this.__setModuleDefault||(Object.create?function(b,h){Object.defineProperty(b,"default",{enumerable:!0,value:h})}:function(b,h){b.default=h}),O=this&&this.__importStar||function(b){if(b&&b.__esModule)return b;var h={};if(null!=b)for(var l in b)"default"!==l&&Object.prototype.hasOwnProperty.call(b,l)&&F(h,b,l);return A(h,b),h};Object.defineProperty(E,"__esModule",{value:!0}),E.WebGLContext=E.linearSearchLastTrue=void 0;const k=P(2235),S=O(P(9622)),C=P(432);function v(b){let h=0;for(;h<b.length&&b[h]();++h);return h-1}E.linearSearchLastTrue=v,E.WebGLContext=class{constructor(b,h){this.frameBufferBound=!1,this.itemsToPoll=[],this.gl=b,this.version=h,this.getExtensions(),this.vertexbuffer=this.createVertexbuffer(),this.framebuffer=this.createFramebuffer(),this.queryVitalParameters()}allocateTexture(b,h,l,d){const f=this.gl,y=f.createTexture();f.bindTexture(f.TEXTURE_2D,y),f.texParameteri(f.TEXTURE_2D,f.TEXTURE_MIN_FILTER,f.NEAREST),f.texParameteri(f.TEXTURE_2D,f.TEXTURE_MAG_FILTER,f.NEAREST),f.texParameteri(f.TEXTURE_2D,f.TEXTURE_WRAP_S,f.CLAMP_TO_EDGE),f.texParameteri(f.TEXTURE_2D,f.TEXTURE_WRAP_T,f.CLAMP_TO_EDGE);const w=d?l.encode(d,b*h):null;return f.texImage2D(f.TEXTURE_2D,0,l.internalFormat,b,h,0,l.format,l.textureType,w),this.checkError(),y}updateTexture(b,h,l,d,f){const y=this.gl;y.bindTexture(y.TEXTURE_2D,b);const w=d.encode(f,h*l);y.texSubImage2D(y.TEXTURE_2D,0,0,0,h,l,d.format,d.textureType,w),this.checkError()}attachFramebuffer(b,h,l){const d=this.gl;d.bindTexture(d.TEXTURE_2D,b),d.bindFramebuffer(d.FRAMEBUFFER,this.framebuffer),d.framebufferTexture2D(d.FRAMEBUFFER,d.COLOR_ATTACHMENT0,d.TEXTURE_2D,b,0),this.checkError(),d.viewport(0,0,h,l),d.scissor(0,0,h,l)}readTexture(b,h,l,d,f,y){const w=this.gl;y||(y=1),this.frameBufferBound||this.attachFramebuffer(b,h,l);const D=this.getEncoder(f,y),M=D.allocate(h*l);return w.bindTexture(w.TEXTURE_2D,b),w.framebufferTexture2D(w.FRAMEBUFFER,w.COLOR_ATTACHMENT0,w.TEXTURE_2D,b,0),w.readPixels(0,0,h,l,w.RGBA,D.textureType,M),this.checkError(),D.decode(M,d)}isFramebufferReady(){return!0}getActiveTexture(){const b=this.gl;return"TEXTURE"+(b.getParameter(this.gl.ACTIVE_TEXTURE)-b.TEXTURE0)}getTextureBinding(){return this.gl.getParameter(this.gl.TEXTURE_BINDING_2D)}getFramebufferBinding(){return this.gl.getParameter(this.gl.FRAMEBUFFER_BINDING)}setVertexAttributes(b,h){const l=this.gl;l.vertexAttribPointer(b,3,l.FLOAT,!1,20,0),l.enableVertexAttribArray(b),-1!==h&&(l.vertexAttribPointer(h,2,l.FLOAT,!1,20,12),l.enableVertexAttribArray(h)),this.checkError()}createProgram(b,h){const l=this.gl,d=l.createProgram();return l.attachShader(d,b),l.attachShader(d,h),l.linkProgram(d),d}compileShader(b,h){const l=this.gl,d=l.createShader(h);if(!d)throw new Error(`createShader() returned null with type ${h}`);if(l.shaderSource(d,b),l.compileShader(d),!1===l.getShaderParameter(d,l.COMPILE_STATUS))throw new Error(`Failed to compile shader: ${l.getShaderInfoLog(d)}\nShader source:\n${b}`);return d}deleteShader(b){this.gl.deleteShader(b)}bindTextureToUniform(b,h,l){const d=this.gl;d.activeTexture(d.TEXTURE0+h),this.checkError(),d.bindTexture(d.TEXTURE_2D,b),this.checkError(),d.uniform1i(l,h),this.checkError()}draw(){this.gl.drawArrays(this.gl.TRIANGLE_STRIP,0,4),this.checkError()}checkError(){if(k.env.debug){const b=this.gl,h=b.getError();let l="";switch(h){case b.NO_ERROR:return;case b.INVALID_ENUM:l="INVALID_ENUM";break;case b.INVALID_VALUE:l="INVALID_VALUE";break;case b.INVALID_OPERATION:l="INVALID_OPERATION";break;case b.INVALID_FRAMEBUFFER_OPERATION:l="INVALID_FRAMEBUFFER_OPERATION";break;case b.OUT_OF_MEMORY:l="OUT_OF_MEMORY";break;case b.CONTEXT_LOST_WEBGL:l="CONTEXT_LOST_WEBGL";break;default:l=`Unknown WebGL Error: ${h.toString(16)}`}throw new Error(l)}}deleteTexture(b){this.gl.deleteTexture(b)}deleteProgram(b){this.gl.deleteProgram(b)}getEncoder(b,h,l=0){if(2===this.version)return new S.RedFloat32DataEncoder(this.gl,h);switch(b){case"float":return 1===l||this.isRenderFloat32Supported?new S.RGBAFloatDataEncoder(this.gl,h):new S.RGBAFloatDataEncoder(this.gl,h,this.textureHalfFloatExtension.HALF_FLOAT_OES);case"int":throw new Error("not implemented");case"byte":return new S.Uint8DataEncoder(this.gl,h);default:throw new Error(`Invalid dataType: ${b}`)}}clearActiveTextures(){const b=this.gl;for(let h=0;h<this.maxTextureImageUnits;++h)b.activeTexture(b.TEXTURE0+h),b.bindTexture(b.TEXTURE_2D,null)}dispose(){if(this.disposed)return;const b=this.gl;b.bindFramebuffer(b.FRAMEBUFFER,null),b.deleteFramebuffer(this.framebuffer),b.bindBuffer(b.ARRAY_BUFFER,null),b.deleteBuffer(this.vertexbuffer),b.bindBuffer(b.ELEMENT_ARRAY_BUFFER,null),b.finish(),this.disposed=!0}createDefaultGeometry(){return new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0])}createVertexbuffer(){const b=this.gl,h=b.createBuffer();if(!h)throw new Error("createBuffer() returned null");const l=this.createDefaultGeometry();return b.bindBuffer(b.ARRAY_BUFFER,h),b.bufferData(b.ARRAY_BUFFER,l,b.STATIC_DRAW),this.checkError(),h}createFramebuffer(){const b=this.gl.createFramebuffer();if(!b)throw new Error("createFramebuffer returned null");return b}queryVitalParameters(){const b=this.gl;if(this.isFloatTextureAttachableToFrameBuffer=this.checkFloatTextureAttachableToFrameBuffer(),this.isRenderFloat32Supported=this.checkRenderFloat32(),this.isFloat32DownloadSupported=this.checkFloat32Download(),1===this.version&&!this.textureHalfFloatExtension&&!this.isRenderFloat32Supported)throw new Error("both float32 and float16 TextureType are not supported");this.isBlendSupported=!this.isRenderFloat32Supported||this.checkFloat32Blend(),this.maxTextureSize=b.getParameter(b.MAX_TEXTURE_SIZE),this.maxTextureImageUnits=b.getParameter(b.MAX_TEXTURE_IMAGE_UNITS)}getExtensions(){2===this.version?(this.colorBufferFloatExtension=this.gl.getExtension("EXT_color_buffer_float"),this.disjointTimerQueryWebgl2Extension=this.gl.getExtension("EXT_disjoint_timer_query_webgl2")):(this.textureFloatExtension=this.gl.getExtension("OES_texture_float"),this.textureHalfFloatExtension=this.gl.getExtension("OES_texture_half_float"))}checkFloatTextureAttachableToFrameBuffer(){const b=this.gl,h=b.createTexture();b.bindTexture(b.TEXTURE_2D,h),b.texImage2D(b.TEXTURE_2D,0,2===this.version?b.RGBA32F:b.RGBA,1,1,0,b.RGBA,b.FLOAT,null);const d=b.createFramebuffer();b.bindFramebuffer(b.FRAMEBUFFER,d),b.framebufferTexture2D(b.FRAMEBUFFER,b.COLOR_ATTACHMENT0,b.TEXTURE_2D,h,0);const f=b.checkFramebufferStatus(b.FRAMEBUFFER)===b.FRAMEBUFFER_COMPLETE;return b.bindTexture(b.TEXTURE_2D,null),b.bindFramebuffer(b.FRAMEBUFFER,null),b.deleteTexture(h),b.deleteFramebuffer(d),f}checkRenderFloat32(){if(2===this.version){if(!this.colorBufferFloatExtension)return!1}else if(!this.textureFloatExtension)return!1;return this.isFloatTextureAttachableToFrameBuffer}checkFloat32Download(){if(2===this.version){if(!this.colorBufferFloatExtension)return!1}else if(!this.textureFloatExtension||!this.gl.getExtension("WEBGL_color_buffer_float"))return!1;return this.isFloatTextureAttachableToFrameBuffer}checkFloat32Blend(){const b=this.gl;let h,l,d,f,y;try{return h=b.createTexture(),l=b.createFramebuffer(),b.bindTexture(b.TEXTURE_2D,h),b.texImage2D(b.TEXTURE_2D,0,2===this.version?b.RGBA32F:b.RGBA,1,1,0,b.RGBA,b.FLOAT,null),b.bindFramebuffer(b.FRAMEBUFFER,l),b.framebufferTexture2D(b.FRAMEBUFFER,b.COLOR_ATTACHMENT0,b.TEXTURE_2D,h,0),b.enable(b.BLEND),d=b.createShader(b.VERTEX_SHADER),!!d&&(b.shaderSource(d,"void main(){}"),b.compileShader(d),f=b.createShader(b.FRAGMENT_SHADER),!!f&&(b.shaderSource(f,"precision highp float;void main(){gl_FragColor=vec4(0.5);}"),b.compileShader(f),y=b.createProgram(),!!y&&(b.attachShader(y,d),b.attachShader(y,f),b.linkProgram(y),b.useProgram(y),b.drawArrays(b.POINTS,0,1),b.getError()===b.NO_ERROR)))}finally{b.disable(b.BLEND),y&&b.deleteProgram(y),d&&b.deleteShader(d),f&&b.deleteShader(f),l&&(b.bindFramebuffer(b.FRAMEBUFFER,null),b.deleteFramebuffer(l)),h&&(b.bindTexture(b.TEXTURE_2D,null),b.deleteTexture(h))}}beginTimer(){if(2===this.version&&this.disjointTimerQueryWebgl2Extension){const b=this.gl,h=this.disjointTimerQueryWebgl2Extension,l=b.createQuery();return b.beginQuery(h.TIME_ELAPSED_EXT,l),l}throw new Error("WebGL1 profiling currently not supported.")}endTimer(){if(2!==this.version||!this.disjointTimerQueryWebgl2Extension)throw new Error("WebGL1 profiling currently not supported");this.gl.endQuery(this.disjointTimerQueryWebgl2Extension.TIME_ELAPSED_EXT)}isTimerResultAvailable(b){let h=!1,l=!1;if(2!==this.version||!this.disjointTimerQueryWebgl2Extension)throw new Error("WebGL1 profiling currently not supported");{const d=this.gl,f=this.disjointTimerQueryWebgl2Extension;h=d.getQueryParameter(b,d.QUERY_RESULT_AVAILABLE),l=d.getParameter(f.GPU_DISJOINT_EXT)}return h&&!l}getTimerResult(b){let h=0;if(2!==this.version)throw new Error("WebGL1 profiling currently not supported");{const l=this.gl;h=l.getQueryParameter(b,l.QUERY_RESULT),l.deleteQuery(b)}return h/1e6}waitForQueryAndGetTime(b){var h=this;return _asyncToGenerator(function*(){return yield(0,C.repeatedTry)(()=>h.isTimerResultAvailable(b)),h.getTimerResult(b)})()}createAndWaitForFence(){var b=this;return _asyncToGenerator(function*(){const h=b.createFence(b.gl);return b.pollFence(h)})()}createFence(b){let h;const l=b,d=l.fenceSync(l.SYNC_GPU_COMMANDS_COMPLETE,0);return b.flush(),h=null===d?()=>!0:()=>{const f=l.clientWaitSync(d,0,0);return f===l.ALREADY_SIGNALED||f===l.CONDITION_SATISFIED},{query:d,isFencePassed:h}}pollFence(b){var h=this;return _asyncToGenerator(function*(){return new Promise(l=>{h.addItemToPoll(()=>b.isFencePassed(),()=>l())})})()}pollItems(){const b=v(this.itemsToPoll.map(h=>h.isDoneFn));for(let h=0;h<=b;++h){const{resolveFn:l}=this.itemsToPoll[h];l()}this.itemsToPoll=this.itemsToPoll.slice(b+1)}addItemToPoll(b,h){var l=this;return _asyncToGenerator(function*(){l.itemsToPoll.push({isDoneFn:b,resolveFn:h}),l.itemsToPoll.length>1||(yield(0,C.repeatedTry)(()=>(l.pollItems(),0===l.itemsToPoll.length)))})()}}},6496:(me,E,P)=>{"use strict";Object.defineProperty(E,"__esModule",{value:!0}),E.ExecutionPlan=void 0;const F=P(1315);class A{constructor(k,S){this.op=k,this.node=S}}E.ExecutionPlan=class{constructor(O,k,S){this.graph=O,this.profiler=S,this.initialize(k)}initialize(O){this.profiler.event("session","ExecutionPlan.initialize",()=>{const k=this.graph.getNodes();if(k.length!==O.length)throw new Error("The size of nodes and OPs do not match.");this._ops=O.map((S,C)=>new A(S,k[C])),this.reset(),this._starter=[],this._ops.forEach((S,C)=>{let v=!0;for(const b of S.node.inputs)if(!this._values[b]&&-1===this.graph.getInputIndices().indexOf(b)){v=!1;break}v&&this._starter.push(C)})})}reset(){this._values=this.graph.getValues().map(O=>O.tensor)}execute(O,k){var S=this;return _asyncToGenerator(function*(){return S.profiler.event("session","ExecutionPlan.execute",_asyncToGenerator(function*(){S.reset();const C=O.createInferenceHandler(),v=S.graph.getInputIndices();if(k.length!==v.length)throw new Error(`number of input tensors don't match the number of inputs to the model: actual: ${k.length} expected: ${v.length}`);k.forEach((y,w)=>{S._values[v[w]]=y});const b=S._starter.slice(0),h=S.graph.getValues(),l=S.graph.getNodes();let d=0;for(;d<b.length;){const y=b[d++],w=S._ops[y],D=w.node.inputs.map(z=>S._values[z]);if(-1!==D.indexOf(void 0))throw new Error(`unresolved input detected: op: ${w.node}`);const M=D;F.Logger.verbose("ExecPlan",`Runing op:${w.node.name} (${M.map((z,G)=>`'${w.node.inputs[G]}': ${z.type}[${z.dims.join(",")}]`).join(", ")})`);const $=yield S.profiler.event("node",w.node.name,_asyncToGenerator(function*(){return w.op.impl(C,M,w.op.context)}));if($.length!==w.node.outputs.length)throw new Error("the size of output does not match model definition.");$.forEach((z,G)=>{const H=w.node.outputs[G];if(S._values[H])throw new Error(`output [${H}] already has value: op:${w.node.name}`);S._values[H]=z});const B=new Set;$.forEach((z,G)=>{const H=w.node.outputs[G];for(const te of h[H].to){const ae=l[te];let J=!0;for(const ne of ae.inputs)if(!S._values[ne]){J=!1;break}J&&B.add(te)}}),b.push(...B)}const f=[];for(let y=0;y<S.graph.getOutputIndices().length;y++){const w=S.graph.getOutputIndices()[y],D=S._values[w];if(void 0===D)throw new Error(`required output [${w}] does not have value`);0===w&&(yield D.getData()),f.push(D)}return F.Logger.verbose("ExecPlan","disposing of inferenceHandler"),C.dispose(),f}))})()}}},4662:(me,E,P)=>{"use strict";Object.defineProperty(E,"__esModule",{value:!0}),E.Graph=void 0;const F=P(6874),A=P(5127),O=P(2446),k=P(9240),S=P(7273);var C=A.onnxruntime.experimental.fbs;E.Graph={from:(l,d)=>new h(l,d)};class v{constructor(d){this._from=void 0,this._to=[],this.tensor=void 0,this.type=void 0,d&&(this.type=S.ProtoUtil.tensorValueTypeFromProto(d.type.tensorType))}get from(){return this._from}get to(){return this._to}}class b{constructor(d,f){d instanceof O.onnx.NodeProto?(this.name=d.name,this.opType=d.opType,this.attributes=new F.Attribute(d.attribute)):d instanceof C.Node&&(this.name=f??d.name(),this.opType=d.opType(),this.attributes=new F.Attribute(S.ProtoUtil.tensorAttributesFromORTFormat(d))),this.inputs=[],this.outputs=[],this.executeNode=!0}}class h{constructor(d,f){if(!d)throw new TypeError("graph is empty");this.buildGraph(d),this.transformGraph(f),this.checkIsAcyclic()}getInputIndices(){return this._allInputIndices}getInputNames(){return this._allInputNames}getOutputIndices(){return this._allOutputIndices}getOutputNames(){return this._allOutputNames}getValues(){return this._allData}getNodes(){return this._nodes}buildGraph(d){if(d instanceof O.onnx.GraphProto)this.buildGraphFromOnnxFormat(d);else{if(!(d instanceof C.Graph))throw new TypeError("Graph type is not supported.");this.buildGraphFromOrtFormat(d)}}buildGraphFromOnnxFormat(d){const f=new Map;this._allData=[],this._allInputIndices=[],this._allInputNames=[],this._allOutputIndices=[],this._allOutputNames=[],this._nodes=[];const y=new Map;if(!d.input)throw new Error("missing information in graph: input");const w=[];for(const D of d.input){if(f.has(D.name))throw new Error(`duplicated input name: ${D.name}`);const M=this._allData.push(new v(D))-1;f.set(D.name,M),w.push(D.name)}if(!d.initializer)throw new Error("missing information in graph: initializer");for(const D of d.initializer){let M=f.get(D.name);if(void 0===M){const $=new v;$.type={shape:{dims:S.ProtoUtil.tensorDimsFromProto(D.dims)},tensorType:S.ProtoUtil.tensorDataTypeFromProto(D.dataType)},M=this._allData.push($)-1,f.set(D.name,M)}this._allData[M]._from=-1,this._allData[M].tensor=k.Tensor.fromProto(D)}for(let D=0;D<this._allData.length;D++)this._allData[D].tensor||(this._allInputIndices.push(D),this._allInputNames.push(w[D]));if(!d.output)throw new Error("missing information in graph: output");for(const D of d.output){if(f.has(D.name))throw new Error(`duplicated output name: ${D.name}`);const M=this._allData.push(new v(D))-1;f.set(D.name,M),this._allOutputIndices.push(M),this._allOutputNames.push(D.name)}if(!d.node)throw new Error("missing information in graph: node");for(const D of d.node){if(!D.name)for(let $=0;;$++){const B=`unnamed_${D.opType}_${$}`;if(!y.has(B)){D.name=B;break}}if(y.has(D.name))throw new Error(`duplicated node name: ${D.name}`);const M=this._nodes.push(new b(D))-1;y.set(D.name,M)}for(let D=0;D<this._nodes.length;D++){const M=this._nodes[D],$=d.node[D];if(!$.output)throw new Error(`missing output for node: ${$.name}`);for(const B of $.output){let z=f.get(B);if(void 0===z&&(z=this._allData.push(new v)-1,f.set(B,z)),M.outputs.push(z),void 0!==this._allData[z]._from)throw new Error(`multiple nodes output to one data value: ${z}`);if(this._allData[z]._from=D,"Constant"===$.opType){if(!$.attribute||1!==$.attribute.length||!$.attribute[0].t)throw new Error("missing attributes or missing tensor value in attributes for this Constant operator");if(!$.output||1!==$.output.length)throw new Error("missing output or incorrect number of outputs for this Constant operator");M.outputs.pop(),M.executeNode=!1,this._allData[z]._from=-1,this._allData[z].tensor=k.Tensor.fromProto($.attribute[0].t)}}}for(let D=0;D<this._nodes.length;D++){const M=this._nodes[D],$=d.node[D];if(!$.input)throw new Error(`missing input for node: ${$.name}`);for(const B of $.input){const z=f.get(B);if(void 0===z){if(""===B&&(3===$.input.length||4===$.input.length)&&"Resize"===$.opType)continue;throw new Error(`unrecognized input '${B}' for node: ${$.name}`)}M.inputs.push(z),this._allData[z]._to.push(D)}}return!0}buildGraphFromOrtFormat(d){var f,y,w;const D=new Map;this._allData=[],this._allInputIndices=[],this._allInputNames=[],this._allOutputIndices=[],this._allOutputNames=[],this._nodes=[];const M=new Map,$=[];for(let B=0;B<d.inputsLength();B++){const z=d.inputs(B);if(D.has(z))throw new Error(`duplicated input name: ${z}`);for(let G=0;G<d.nodeArgsLength();G++)if((null===(f=d.nodeArgs(G))||void 0===f?void 0:f.name())===z){const H=new v;if((null===(w=null===(y=d.nodeArgs(G))||void 0===y?void 0:y.type())||void 0===w?void 0:w.valueType())!==C.TypeInfoValue.tensor_type)throw new Error("Unexpected value type for the nodeArg.");const te=d.nodeArgs(G).type().value(new C.TensorTypeAndShape),ae=S.ProtoUtil.tensorDataTypeFromProto(te.elemType()),J=te.shape(),ne=[];for(let K=0;K<J.dimLength();K++)ne.push(S.LongUtil.longToNumber(J.dim(K).value().dimValue()));H.type={shape:{dims:ne},tensorType:ae};const X=this._allData.push(H)-1;D.set(z,X),$.push(z)}}for(let B=0;B<d.initializersLength();B++){const z=d.initializers(B);let G=D.get(z.name());if(void 0===G){const H=new v,te=S.ProtoUtil.tensorDimsFromORTFormat(z),ae=S.ProtoUtil.tensorDataTypeFromProto(z.dataType());H.type={shape:{dims:te},tensorType:ae},G=this._allData.push(H)-1,D.set(z.name(),G)}this._allData[G]._from=-1,this._allData[G].tensor=k.Tensor.fromOrtTensor(z)}for(let B=0;B<this._allData.length;B++)this._allData[B].tensor||(this._allInputIndices.push(B),this._allInputNames.push($[B]));for(let B=0;B<d.outputsLength();B++){const z=d.outputs(B);if(D.has(z))throw new Error(`duplicated output name: ${z}`);const G=this._allData.push(new v)-1;D.set(z,G),this._allOutputIndices.push(G),this._allOutputNames.push(z)}if(!d.nodes)throw new Error("missing information in graph: node");for(let B=0;B<d.nodesLength();B++){const z=d.nodes(B);let G=z.name();if(!G)for(let te=0;G=`unnamed_${z.opType()}_${te}`,M.has(G);te++);if(M.has(G))throw new Error(`duplicated node name: ${G}`);const H=this._nodes.push(new b(z,G))-1;M.set(G,H)}for(let B=0;B<this._nodes.length;B++){const z=this._nodes[B],G=d.nodes(B);if(null==G)throw new Error(`No node exists at index ${B}`);if(0===G?.outputsLength())throw new Error(`missing output for node: ${G.name}`);for(let H=0;H<G?.outputsLength();H++){const te=G?.outputs(H);let ae=D.get(te);if(void 0===ae&&(ae=this._allData.push(new v)-1,D.set(te,ae)),z.outputs.push(ae),void 0!==this._allData[ae]._from)throw new Error(`multiple nodes output to one data value: ${ae}`);if(this._allData[ae]._from=B,"Constant"===G.opType()){if(1!==G.attributesLength()||!G.attributes(0).t())throw new Error("missing attributes or missing tensor value in attributes for this Constant operator");if(1!==G.outputsLength())throw new Error("missing output or incorrect number of outputs for this Constant operator");z.outputs.pop(),z.executeNode=!1,this._allData[ae]._from=-1,this._allData[ae].tensor=k.Tensor.fromOrtTensor(G.attributes(0).t())}}}for(let B=0;B<this._nodes.length;B++){const z=this._nodes[B],G=d.nodes(B);if(0===G.inputsLength())throw new Error(`missing input for node: ${G.name}`);for(let H=0;H<G.inputsLength();H++){const te=G.inputs(H),ae=D.get(te);if(void 0===ae)throw new Error(`unrecognized input '${te}' for node: ${G.name()}`);z.inputs.push(ae),this._allData[ae]._to.push(B)}}}checkIsAcyclic(){const d=new Set;this._allInputIndices.forEach(w=>{this._allData[w]._to.forEach(D=>{d.add(D)})});const f=Array.from(d),y=new Array(this._nodes.length).fill("white");for(;f.length>0;){const w=f.pop();"gray"===y[w]?y[w]="black":(f.push(w),y[w]="gray",this._nodes[w].outputs.forEach(D=>{const M=this._allData[D];if(void 0!==M.tensor)throw new Error("node outputs should not be initialized");if(M._from!==w)throw new Error("from property of the Value object doesn't match index of Node being processed");M._to.forEach($=>{if("gray"===y[$])throw new Error("model graph is cyclic");"white"===y[$]&&f.push($)})}))}}transformGraph(d){this.removeAllIdentityNodes(),this.removeAllDropoutNodes(),this.fuseConvActivationNodes(),d&&d.transformGraph(this),this.finalizeGraph()}finalizeGraph(){let d=0;const f=new Array(this._nodes.length,0);let y=0;for(let w=0;w<this._nodes.length;w++)f[w]=y,this._nodes[w].executeNode?(y!==w&&(this._nodes[y]=this._nodes[w]),y++):this._nodes[w].outputs.forEach(D=>{this._allData[D]._from=-2});this._nodes.splice(y,this._nodes.length-y);for(let w=0;w<this._allData.length;w++){const D=this._allData[w];void 0!==D._from&&-1!==D._from&&-2!==D._from&&(D._from=f[D._from]);for(let M=0;M<D._to.length;M++){if(!(D._to[M]>=0))throw new Error("Trying to update a removed node");D._to[M]=f[D._to[M]]}}d=0;for(let w=0;w<this._allData.length;w++)if(-2!==this._allData[w].from||-1!==this._allOutputIndices.indexOf(w+d)){if(d>0){let D=-1;void 0!==this._allData[w].from&&-1!==this._allData[w].from?(D=this._nodes[this._allData[w].from].outputs.indexOf(w+d),-1!==D&&(this._nodes[this._allData[w].from].outputs[D]=w)):(D=this._allInputIndices.indexOf(w+d),-1!==D&&(this._allInputIndices[D]=w)),this._allData[w].to.forEach(M=>{D=this._nodes[M].inputs.indexOf(w+d),-1!==D&&(this._nodes[M].inputs[D]=w)}),0===this._allData[w].to.length&&(D=this._allOutputIndices.indexOf(w+d),-1!==D&&(this._allOutputIndices[D]=w))}}else d++,this._allData.splice(w,1),w--}deleteNode(d){const f=this._nodes[d];if(f.outputs.length>1)for(let $=1;$<f.outputs.length;$++)if(this._allData[f.outputs[$]].to.length>0)throw new Error("Node deletion with more than one output connected to other nodes is not supported. ");f.executeNode=!1;const y=f.inputs[0],w=f.outputs[0],D=this._allData[w].to;for(let $=0;$<f.inputs.length;$++){const B=this._allData[f.inputs[$]].to.indexOf(d);if(-1===B)throw new Error("The Value object doesn't have the current Node in it's 'to' property ");this._allData[f.inputs[$]].to.splice(B,1)}this._allData[w]._to=[];const M=this._allOutputIndices.indexOf(w);if(-1!==M&&(this._allOutputIndices[M]=y),D&&D.length>0)for(const $ of D){const B=this._nodes[$].inputs.indexOf(w);if(-1===B)throw new Error("The Node object doesn't have the output Value in it's 'inputs' property ");this._nodes[$].inputs[B]=y,this._allData[y].to.push($)}}removeAllDropoutNodes(){let d=0;for(const f of this._nodes){if("Dropout"===f.opType){if(1!==f.inputs.length)throw new Error("Dropout nodes should only contain one input. ");if(1!==f.outputs.length&&2!==f.outputs.length)throw new Error("Dropout nodes should contain either 1 or 2 output(s)");if(2===f.outputs.length&&0!==this._allData[f.outputs[1]]._to.length)throw new Error("Dropout nodes's second output should not be referenced by other nodes");this.deleteNode(d)}d++}}removeAllIdentityNodes(){let d=0;for(const f of this._nodes)"Identity"===f.opType&&this.deleteNode(d),d++}isActivation(d){switch(d.opType){case"Relu":case"Sigmoid":case"Clip":return!0;default:return!1}}fuseConvActivationNodes(){for(const d of this._nodes)if("Conv"===d.opType){const f=this._allData[d.outputs[0]]._to;if(1===f.length&&this.isActivation(this._nodes[f[0]])){const y=this._nodes[f[0]];if("Clip"===y.opType)if(1===y.inputs.length)try{d.attributes.set("activation_params","floats",[y.attributes.getFloat("min"),y.attributes.getFloat("max")])}catch{d.attributes.set("activation_params","floats",[S.MIN_CLIP,S.MAX_CLIP])}else{if(!(y.inputs.length>=3&&void 0!==this._allData[y.inputs[1]].tensor&&void 0!==this._allData[y.inputs[2]].tensor))continue;d.attributes.set("activation_params","floats",[this._allData[y.inputs[1]].tensor.floatData[0],this._allData[y.inputs[2]].tensor.floatData[0]])}d.attributes.set("activation","string",y.opType),this.deleteNode(f[0])}}}}},1315:(me,E)=>{"use strict";Object.defineProperty(E,"__esModule",{value:!0}),E.now=E.Profiler=E.Logger=void 0;const P={verbose:1e3,info:2e3,warning:4e3,error:5e3,fatal:6e3},F={none:new class{log(b,h,l){}},console:new class{log(b,h,l){console.log(`${this.color(b)} ${l?"\x1b[35m"+l+"\x1b[0m ":""}${h}`)}color(b){switch(b){case"verbose":return"\x1b[34;40mv\x1b[0m";case"info":return"\x1b[32mi\x1b[0m";case"warning":return"\x1b[30;43mw\x1b[0m";case"error":return"\x1b[31;40me\x1b[0m";case"fatal":return"\x1b[101mf\x1b[0m";default:throw new Error(`unsupported severity: ${b}`)}}}},A={provider:"console",minimalSeverity:"warning",logDateTime:!0,logSourceLocation:!1};let O={"":A};function k(b,h,l,d){if(void 0===h)return{verbose:k.verbose.bind(null,f=b),info:k.info.bind(null,f),warning:k.warning.bind(null,f),error:k.error.bind(null,f),fatal:k.fatal.bind(null,f)};if(void 0===l)S(b,h);else if("number"==typeof l&&void 0===d)S(b,h);else if("string"==typeof l&&void 0===d)S(b,l,0,h);else{if("string"!=typeof l||"number"!=typeof d)throw new TypeError("input is valid");S(b,l,0,h)}var f}function S(b,h,l,d){const f=O[d||""]||O[""];P[b]<P[f.minimalSeverity]||(f.logDateTime&&(h=`${(new Date).toISOString()}|${h}`),F[f.provider].log(b,h,d))}(function(b){function h(d){O={},l("",d||{})}function l(d,f){if("*"===d)h(f);else{const y=O[d]||A;O[d]={provider:f.provider||y.provider,minimalSeverity:f.minimalSeverity||y.minimalSeverity,logDateTime:void 0===f.logDateTime?y.logDateTime:f.logDateTime,logSourceLocation:void 0===f.logSourceLocation?y.logSourceLocation:f.logSourceLocation}}}b.verbose=function(d,f){b("verbose",d,f)},b.info=function(d,f){b("info",d,f)},b.warning=function(d,f){b("warning",d,f)},b.error=function(d,f){b("error",d,f)},b.fatal=function(d,f){b("fatal",d,f)},b.reset=h,b.set=l,b.setWithEnv=function(d){const f={};d.logLevel&&(f.minimalSeverity=d.logLevel),l("",f)}})(k||(k={})),E.Logger=k;class C{constructor(h,l,d,f,y,w){this.category=h,this.name=l,this.startTime=d,this.endCallback=f,this.timer=y,this.ctx=w}end(){var h=this;return _asyncToGenerator(function*(){return h.endCallback(h)})()}checkTimer(){var h=this;return _asyncToGenerator(function*(){if(void 0===h.ctx||void 0===h.timer)throw new Error("No webgl timer found");return h.ctx.endTimer(),h.ctx.waitForQueryAndGetTime(h.timer)})()}}class v{constructor(h,l,d,f){this.category=h,this.name=l,this.startTime=d,this.endTime=f}}E.Profiler=class{static create(b){return void 0===b?new this:new this(b.maxNumberEvents,b.flushBatchSize,b.flushIntervalInMilliseconds)}constructor(b,h,l){this._started=!1,this._flushPointer=0,this._started=!1,this._maxNumberEvents=void 0===b?1e4:b,this._flushBatchSize=void 0===h?10:h,this._flushIntervalInMilliseconds=void 0===l?5e3:l}start(){this._started=!0,this._timingEvents=[],this._flushTime=(0,E.now)(),this._flushPointer=0}stop(){for(this._started=!1;this._flushPointer<this._timingEvents.length;this._flushPointer++)this.logOneEvent(this._timingEvents[this._flushPointer])}event(b,h,l,d){const f=this._started?this.begin(b,h,d):void 0;let y=!1;const w=l();if(w&&"function"==typeof w.then)return y=!0,new Promise((D,M)=>{w.then(function(){var $=_asyncToGenerator(function*(B){f&&(yield f.end()),D(B)});return function(B){return $.apply(this,arguments)}}(),function(){var $=_asyncToGenerator(function*(B){f&&(yield f.end()),M(B)});return function(B){return $.apply(this,arguments)}}())});if(!y&&f){const D=f.end();if(D&&"function"==typeof D.then)return new Promise((M,$)=>{D.then(()=>{M(w)},B=>{$(B)})})}return w}begin(b,h,l){var d=this;if(!this._started)throw new Error("profiler is not started yet");if(void 0===l){const f=(0,E.now)();return this.flush(f),new C(b,h,f,y=>this.endSync(y))}{const f=l.beginTimer();return new C(b,h,0,function(){var y=_asyncToGenerator(function*(w){return d.end(w)});return function(w){return y.apply(this,arguments)}}(),f,l)}}end(b){var h=this;return _asyncToGenerator(function*(){const l=yield b.checkTimer();h._timingEvents.length<h._maxNumberEvents&&(h._timingEvents.push(new v(b.category,b.name,b.startTime,l)),h.flush(l))})()}endSync(b){const h=(0,E.now)();this._timingEvents.length<this._maxNumberEvents&&(this._timingEvents.push(new v(b.category,b.name,b.startTime,h)),this.flush(h))}logOneEvent(b){E.Logger.verbose(`Profiler.${b.category}`,`${(b.endTime-b.startTime).toFixed(2)}ms on event '${b.name}' at ${b.endTime.toFixed(2)}`)}flush(b){if(this._timingEvents.length-this._flushPointer>=this._flushBatchSize||b-this._flushTime>=this._flushIntervalInMilliseconds){for(const h=this._flushPointer;this._flushPointer<h+this._flushBatchSize&&this._flushPointer<this._timingEvents.length;this._flushPointer++)this.logOneEvent(this._timingEvents[this._flushPointer]);this._flushTime=(0,E.now)()}}get started(){return this._started}},E.now=typeof performance<"u"&&performance.now?()=>performance.now():Date.now},1745:(me,E,P)=>{"use strict";Object.defineProperty(E,"__esModule",{value:!0}),E.Model=void 0;const F=P(5686),A=P(4662),O=P(5127),k=P(2446),S=P(7273);var C=O.onnxruntime.experimental.fbs;E.Model=class{constructor(){}load(v,b,h){if(!h)try{return void this.loadFromOnnxFormat(v,b)}catch(l){if(void 0!==h)throw l}this.loadFromOrtFormat(v,b)}loadFromOnnxFormat(v,b){const h=k.onnx.ModelProto.decode(v);if(S.LongUtil.longToNumber(h.irVersion)<3)throw new Error("only support ONNX model with IR_VERSION>=3");this._opsets=h.opsetImport.map(l=>({domain:l.domain,version:S.LongUtil.longToNumber(l.version)})),this._graph=A.Graph.from(h.graph,b)}loadFromOrtFormat(v,b){const h=new F.flatbuffers.ByteBuffer(v),l=C.InferenceSession.getRootAsInferenceSession(h).model();if(S.LongUtil.longToNumber(l.irVersion())<3)throw new Error("only support ONNX model with IR_VERSION>=3");this._opsets=[];for(let d=0;d<l.opsetImportLength();d++){const f=l.opsetImport(d);this._opsets.push({domain:f?.domain(),version:S.LongUtil.longToNumber(f.version())})}this._graph=A.Graph.from(l.graph(),b)}get graph(){return this._graph}get opsets(){return this._opsets}}},6145:(me,E)=>{"use strict";Object.defineProperty(E,"__esModule",{value:!0}),E.FLOAT_TYPES=E.INT_TYPES=E.NUMBER_TYPES=void 0,E.NUMBER_TYPES=["float32","float64","int32","int16","int8","uint16","uint32","uint8"],E.INT_TYPES=["int32","int16","int8","uint16","uint32","uint8"],E.FLOAT_TYPES=["float32","float64"]},5881:(me,E)=>{"use strict";function P(F,A){if(A.endsWith("+")){const O=Number.parseInt(A.substring(0,A.length-1),10);return!isNaN(O)&&O<=F}if(2===A.split("-").length){const O=A.split("-"),k=Number.parseInt(O[0],10),S=Number.parseInt(O[1],10);return!isNaN(k)&&!isNaN(S)&&k<=F&&F<=S}return Number.parseInt(A,10)===F}Object.defineProperty(E,"__esModule",{value:!0}),E.resolveOperator=void 0,E.resolveOperator=function(F,A,O){for(const k of O){const C=k[1],v=k[2],b=k[3],h=k[4];if(F.opType===k[0])for(const l of A)if((l.domain===C||"ai.onnx"===l.domain&&""===C)&&P(l.version,v))return{opImpl:b,opInit:h}}throw new TypeError(`cannot resolve operator '${F.opType}' with opsets: ${A.map(k=>`${k.domain||"ai.onnx"} v${k.version}`).join(", ")}`)}},5127:(me,E,P)=>{"use strict";Object.defineProperty(E,"__esModule",{value:!0}),E.onnxruntime=void 0;const F=P(5686);var A,O,k,S;(function(k){let S;var C;(C=S=k.AttributeType||(k.AttributeType={}))[C.UNDEFINED=0]="UNDEFINED",C[C.FLOAT=1]="FLOAT",C[C.INT=2]="INT",C[C.STRING=3]="STRING",C[C.TENSOR=4]="TENSOR",C[C.GRAPH=5]="GRAPH",C[C.FLOATS=6]="FLOATS",C[C.INTS=7]="INTS",C[C.STRINGS=8]="STRINGS",C[C.TENSORS=9]="TENSORS",C[C.GRAPHS=10]="GRAPHS",C[C.SPARSE_TENSOR=11]="SPARSE_TENSOR",C[C.SPARSE_TENSORS=12]="SPARSE_TENSORS"})((O=(A=E.onnxruntime||(E.onnxruntime={})).experimental||(A.experimental={})).fbs||(O.fbs={})),function(C){let v;var b;(b=v=C.DimensionValueType||(C.DimensionValueType={}))[b.UNKNOWN=0]="UNKNOWN",b[b.VALUE=1]="VALUE",b[b.PARAM=2]="PARAM"}((S=(k=E.onnxruntime||(E.onnxruntime={})).experimental||(k.experimental={})).fbs||(S.fbs={})),function(k){!function(S){!function(C){let v;var b;(b=v=C.TensorDataType||(C.TensorDataType={}))[b.UNDEFINED=0]="UNDEFINED",b[b.FLOAT=1]="FLOAT",b[b.UINT8=2]="UINT8",b[b.INT8=3]="INT8",b[b.UINT16=4]="UINT16",b[b.INT16=5]="INT16",b[b.INT32=6]="INT32",b[b.INT64=7]="INT64",b[b.STRING=8]="STRING",b[b.BOOL=9]="BOOL",b[b.FLOAT16=10]="FLOAT16",b[b.DOUBLE=11]="DOUBLE",b[b.UINT32=12]="UINT32",b[b.UINT64=13]="UINT64",b[b.COMPLEX64=14]="COMPLEX64",b[b.COMPLEX128=15]="COMPLEX128",b[b.BFLOAT16=16]="BFLOAT16",b[b.FLOAT8E4M3FN=17]="FLOAT8E4M3FN",b[b.FLOAT8E4M3FNUZ=18]="FLOAT8E4M3FNUZ",b[b.FLOAT8E5M2=19]="FLOAT8E5M2",b[b.FLOAT8E5M2FNUZ=20]="FLOAT8E5M2FNUZ"}(S.fbs||(S.fbs={}))}(k.experimental||(k.experimental={}))}(E.onnxruntime||(E.onnxruntime={})),function(k){!function(S){!function(C){let v;var b;(b=v=C.NodeType||(C.NodeType={}))[b.Primitive=0]="Primitive",b[b.Fused=1]="Fused"}(S.fbs||(S.fbs={}))}(k.experimental||(k.experimental={}))}(E.onnxruntime||(E.onnxruntime={})),function(k){!function(S){!function(C){let v;var b;(b=v=C.TypeInfoValue||(C.TypeInfoValue={}))[b.NONE=0]="NONE",b[b.tensor_type=1]="tensor_type",b[b.sequence_type=2]="sequence_type",b[b.map_type=3]="map_type"}(S.fbs||(S.fbs={}))}(k.experimental||(k.experimental={}))}(E.onnxruntime||(E.onnxruntime={})),function(k){!function(S){!function(C){class v{constructor(){this.bb=null,this.bb_pos=0}__init(h,l){return this.bb_pos=h,this.bb=l,this}static getRootAsShape(h,l){return(l||new v).__init(h.readInt32(h.position())+h.position(),h)}static getSizePrefixedRootAsShape(h,l){return h.setPosition(h.position()+F.flatbuffers.SIZE_PREFIX_LENGTH),(l||new v).__init(h.readInt32(h.position())+h.position(),h)}dim(h,l){let d=this.bb.__offset(this.bb_pos,4);return d?(l||new k.experimental.fbs.Dimension).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+d)+4*h),this.bb):null}dimLength(){let h=this.bb.__offset(this.bb_pos,4);return h?this.bb.__vector_len(this.bb_pos+h):0}static startShape(h){h.startObject(1)}static addDim(h,l){h.addFieldOffset(0,l,0)}static createDimVector(h,l){h.startVector(4,l.length,4);for(let d=l.length-1;d>=0;d--)h.addOffset(l[d]);return h.endVector()}static startDimVector(h,l){h.startVector(4,l,4)}static endShape(h){return h.endObject()}static createShape(h,l){return v.startShape(h),v.addDim(h,l),v.endShape(h)}}C.Shape=v}(S.fbs||(S.fbs={}))}(k.experimental||(k.experimental={}))}(E.onnxruntime||(E.onnxruntime={})),function(k){!function(S){!function(C){class v{constructor(){this.bb=null,this.bb_pos=0}__init(h,l){return this.bb_pos=h,this.bb=l,this}static getRootAsDimension(h,l){return(l||new v).__init(h.readInt32(h.position())+h.position(),h)}static getSizePrefixedRootAsDimension(h,l){return h.setPosition(h.position()+F.flatbuffers.SIZE_PREFIX_LENGTH),(l||new v).__init(h.readInt32(h.position())+h.position(),h)}value(h){let l=this.bb.__offset(this.bb_pos,4);return l?(h||new k.experimental.fbs.DimensionValue).__init(this.bb.__indirect(this.bb_pos+l),this.bb):null}denotation(h){let l=this.bb.__offset(this.bb_pos,6);return l?this.bb.__string(this.bb_pos+l,h):null}static startDimension(h){h.startObject(2)}static addValue(h,l){h.addFieldOffset(0,l,0)}static addDenotation(h,l){h.addFieldOffset(1,l,0)}static endDimension(h){return h.endObject()}static createDimension(h,l,d){return v.startDimension(h),v.addValue(h,l),v.addDenotation(h,d),v.endDimension(h)}}C.Dimension=v}(S.fbs||(S.fbs={}))}(k.experimental||(k.experimental={}))}(E.onnxruntime||(E.onnxruntime={})),function(k){!function(S){!function(C){class v{constructor(){this.bb=null,this.bb_pos=0}__init(h,l){return this.bb_pos=h,this.bb=l,this}static getRootAsDimensionValue(h,l){return(l||new v).__init(h.readInt32(h.position())+h.position(),h)}static getSizePrefixedRootAsDimensionValue(h,l){return h.setPosition(h.position()+F.flatbuffers.SIZE_PREFIX_LENGTH),(l||new v).__init(h.readInt32(h.position())+h.position(),h)}dimType(){let h=this.bb.__offset(this.bb_pos,4);return h?this.bb.readInt8(this.bb_pos+h):k.experimental.fbs.DimensionValueType.UNKNOWN}dimValue(){let h=this.bb.__offset(this.bb_pos,6);return h?this.bb.readInt64(this.bb_pos+h):this.bb.createLong(0,0)}dimParam(h){let l=this.bb.__offset(this.bb_pos,8);return l?this.bb.__string(this.bb_pos+l,h):null}static startDimensionValue(h){h.startObject(3)}static addDimType(h,l){h.addFieldInt8(0,l,k.experimental.fbs.DimensionValueType.UNKNOWN)}static addDimValue(h,l){h.addFieldInt64(1,l,h.createLong(0,0))}static addDimParam(h,l){h.addFieldOffset(2,l,0)}static endDimensionValue(h){return h.endObject()}static createDimensionValue(h,l,d,f){return v.startDimensionValue(h),v.addDimType(h,l),v.addDimValue(h,d),v.addDimParam(h,f),v.endDimensionValue(h)}}C.DimensionValue=v}(S.fbs||(S.fbs={}))}(k.experimental||(k.experimental={}))}(E.onnxruntime||(E.onnxruntime={})),function(k){!function(S){!function(C){class v{constructor(){this.bb=null,this.bb_pos=0}__init(h,l){return this.bb_pos=h,this.bb=l,this}static getRootAsTensorTypeAndShape(h,l){return(l||new v).__init(h.readInt32(h.position())+h.position(),h)}static getSizePrefixedRootAsTensorTypeAndShape(h,l){return h.setPosition(h.position()+F.flatbuffers.SIZE_PREFIX_LENGTH),(l||new v).__init(h.readInt32(h.position())+h.position(),h)}elemType(){let h=this.bb.__offset(this.bb_pos,4);return h?this.bb.readInt32(this.bb_pos+h):k.experimental.fbs.TensorDataType.UNDEFINED}shape(h){let l=this.bb.__offset(this.bb_pos,6);return l?(h||new k.experimental.fbs.Shape).__init(this.bb.__indirect(this.bb_pos+l),this.bb):null}static startTensorTypeAndShape(h){h.startObject(2)}static addElemType(h,l){h.addFieldInt32(0,l,k.experimental.fbs.TensorDataType.UNDEFINED)}static addShape(h,l){h.addFieldOffset(1,l,0)}static endTensorTypeAndShape(h){return h.endObject()}static createTensorTypeAndShape(h,l,d){return v.startTensorTypeAndShape(h),v.addElemType(h,l),v.addShape(h,d),v.endTensorTypeAndShape(h)}}C.TensorTypeAndShape=v}(S.fbs||(S.fbs={}))}(k.experimental||(k.experimental={}))}(E.onnxruntime||(E.onnxruntime={})),function(k){!function(S){!function(C){class v{constructor(){this.bb=null,this.bb_pos=0}__init(h,l){return this.bb_pos=h,this.bb=l,this}static getRootAsMapType(h,l){return(l||new v).__init(h.readInt32(h.position())+h.position(),h)}static getSizePrefixedRootAsMapType(h,l){return h.setPosition(h.position()+F.flatbuffers.SIZE_PREFIX_LENGTH),(l||new v).__init(h.readInt32(h.position())+h.position(),h)}keyType(){let h=this.bb.__offset(this.bb_pos,4);return h?this.bb.readInt32(this.bb_pos+h):k.experimental.fbs.TensorDataType.UNDEFINED}valueType(h){let l=this.bb.__offset(this.bb_pos,6);return l?(h||new k.experimental.fbs.TypeInfo).__init(this.bb.__indirect(this.bb_pos+l),this.bb):null}static startMapType(h){h.startObject(2)}static addKeyType(h,l){h.addFieldInt32(0,l,k.experimental.fbs.TensorDataType.UNDEFINED)}static addValueType(h,l){h.addFieldOffset(1,l,0)}static endMapType(h){return h.endObject()}static createMapType(h,l,d){return v.startMapType(h),v.addKeyType(h,l),v.addValueType(h,d),v.endMapType(h)}}C.MapType=v}(S.fbs||(S.fbs={}))}(k.experimental||(k.experimental={}))}(E.onnxruntime||(E.onnxruntime={})),function(k){!function(S){!function(C){class v{constructor(){this.bb=null,this.bb_pos=0}__init(h,l){return this.bb_pos=h,this.bb=l,this}static getRootAsSequenceType(h,l){return(l||new v).__init(h.readInt32(h.position())+h.position(),h)}static getSizePrefixedRootAsSequenceType(h,l){return h.setPosition(h.position()+F.flatbuffers.SIZE_PREFIX_LENGTH),(l||new v).__init(h.readInt32(h.position())+h.position(),h)}elemType(h){let l=this.bb.__offset(this.bb_pos,4);return l?(h||new k.experimental.fbs.TypeInfo).__init(this.bb.__indirect(this.bb_pos+l),this.bb):null}static startSequenceType(h){h.startObject(1)}static addElemType(h,l){h.addFieldOffset(0,l,0)}static endSequenceType(h){return h.endObject()}static createSequenceType(h,l){return v.startSequenceType(h),v.addElemType(h,l),v.endSequenceType(h)}}C.SequenceType=v}(S.fbs||(S.fbs={}))}(k.experimental||(k.experimental={}))}(E.onnxruntime||(E.onnxruntime={})),function(k){!function(S){(S.fbs||(S.fbs={})).EdgeEnd=class{constructor(){this.bb=null,this.bb_pos=0}__init(C,v){return this.bb_pos=C,this.bb=v,this}nodeIndex(){return this.bb.readUint32(this.bb_pos)}srcArgIndex(){return this.bb.readInt32(this.bb_pos+4)}dstArgIndex(){return this.bb.readInt32(this.bb_pos+8)}static createEdgeEnd(C,v,b,h){return C.prep(4,12),C.writeInt32(h),C.writeInt32(b),C.writeInt32(v),C.offset()}}}(k.experimental||(k.experimental={}))}(E.onnxruntime||(E.onnxruntime={})),function(k){!function(S){!function(C){class v{constructor(){this.bb=null,this.bb_pos=0}__init(h,l){return this.bb_pos=h,this.bb=l,this}static getRootAsNodeEdge(h,l){return(l||new v).__init(h.readInt32(h.position())+h.position(),h)}static getSizePrefixedRootAsNodeEdge(h,l){return h.setPosition(h.position()+F.flatbuffers.SIZE_PREFIX_LENGTH),(l||new v).__init(h.readInt32(h.position())+h.position(),h)}nodeIndex(){let h=this.bb.__offset(this.bb_pos,4);return h?this.bb.readUint32(this.bb_pos+h):0}inputEdges(h,l){let d=this.bb.__offset(this.bb_pos,6);return d?(l||new k.experimental.fbs.EdgeEnd).__init(this.bb.__vector(this.bb_pos+d)+12*h,this.bb):null}inputEdgesLength(){let h=this.bb.__offset(this.bb_pos,6);return h?this.bb.__vector_len(this.bb_pos+h):0}outputEdges(h,l){let d=this.bb.__offset(this.bb_pos,8);return d?(l||new k.experimental.fbs.EdgeEnd).__init(this.bb.__vector(this.bb_pos+d)+12*h,this.bb):null}outputEdgesLength(){let h=this.bb.__offset(this.bb_pos,8);return h?this.bb.__vector_len(this.bb_pos+h):0}static startNodeEdge(h){h.startObject(3)}static addNodeIndex(h,l){h.addFieldInt32(0,l,0)}static addInputEdges(h,l){h.addFieldOffset(1,l,0)}static startInputEdgesVector(h,l){h.startVector(12,l,4)}static addOutputEdges(h,l){h.addFieldOffset(2,l,0)}static startOutputEdgesVector(h,l){h.startVector(12,l,4)}static endNodeEdge(h){return h.endObject()}static createNodeEdge(h,l,d,f){return v.startNodeEdge(h),v.addNodeIndex(h,l),v.addInputEdges(h,d),v.addOutputEdges(h,f),v.endNodeEdge(h)}}C.NodeEdge=v}(S.fbs||(S.fbs={}))}(k.experimental||(k.experimental={}))}(E.onnxruntime||(E.onnxruntime={})),function(k){!function(S){!function(C){class v{constructor(){this.bb=null,this.bb_pos=0}__init(h,l){return this.bb_pos=h,this.bb=l,this}static getRootAsNode(h,l){return(l||new v).__init(h.readInt32(h.position())+h.position(),h)}static getSizePrefixedRootAsNode(h,l){return h.setPosition(h.position()+F.flatbuffers.SIZE_PREFIX_LENGTH),(l||new v).__init(h.readInt32(h.position())+h.position(),h)}name(h){let l=this.bb.__offset(this.bb_pos,4);return l?this.bb.__string(this.bb_pos+l,h):null}docString(h){let l=this.bb.__offset(this.bb_pos,6);return l?this.bb.__string(this.bb_pos+l,h):null}domain(h){let l=this.bb.__offset(this.bb_pos,8);return l?this.bb.__string(this.bb_pos+l,h):null}sinceVersion(){let h=this.bb.__offset(this.bb_pos,10);return h?this.bb.readInt32(this.bb_pos+h):0}index(){let h=this.bb.__offset(this.bb_pos,12);return h?this.bb.readUint32(this.bb_pos+h):0}opType(h){let l=this.bb.__offset(this.bb_pos,14);return l?this.bb.__string(this.bb_pos+l,h):null}type(){let h=this.bb.__offset(this.bb_pos,16);return h?this.bb.readInt32(this.bb_pos+h):k.experimental.fbs.NodeType.Primitive}executionProviderType(h){let l=this.bb.__offset(this.bb_pos,18);return l?this.bb.__string(this.bb_pos+l,h):null}inputs(h,l){let d=this.bb.__offset(this.bb_pos,20);return d?this.bb.__string(this.bb.__vector(this.bb_pos+d)+4*h,l):null}inputsLength(){let h=this.bb.__offset(this.bb_pos,20);return h?this.bb.__vector_len(this.bb_pos+h):0}outputs(h,l){let d=this.bb.__offset(this.bb_pos,22);return d?this.bb.__string(this.bb.__vector(this.bb_pos+d)+4*h,l):null}outputsLength(){let h=this.bb.__offset(this.bb_pos,22);return h?this.bb.__vector_len(this.bb_pos+h):0}attributes(h,l){let d=this.bb.__offset(this.bb_pos,24);return d?(l||new k.experimental.fbs.Attribute).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+d)+4*h),this.bb):null}attributesLength(){let h=this.bb.__offset(this.bb_pos,24);return h?this.bb.__vector_len(this.bb_pos+h):0}inputArgCounts(h){let l=this.bb.__offset(this.bb_pos,26);return l?this.bb.readInt32(this.bb.__vector(this.bb_pos+l)+4*h):0}inputArgCountsLength(){let h=this.bb.__offset(this.bb_pos,26);return h?this.bb.__vector_len(this.bb_pos+h):0}inputArgCountsArray(){let h=this.bb.__offset(this.bb_pos,26);return h?new Int32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+h),this.bb.__vector_len(this.bb_pos+h)):null}implicitInputs(h,l){let d=this.bb.__offset(this.bb_pos,28);return d?this.bb.__string(this.bb.__vector(this.bb_pos+d)+4*h,l):null}implicitInputsLength(){let h=this.bb.__offset(this.bb_pos,28);return h?this.bb.__vector_len(this.bb_pos+h):0}static startNode(h){h.startObject(13)}static addName(h,l){h.addFieldOffset(0,l,0)}static addDocString(h,l){h.addFieldOffset(1,l,0)}static addDomain(h,l){h.addFieldOffset(2,l,0)}static addSinceVersion(h,l){h.addFieldInt32(3,l,0)}static addIndex(h,l){h.addFieldInt32(4,l,0)}static addOpType(h,l){h.addFieldOffset(5,l,0)}static addType(h,l){h.addFieldInt32(6,l,k.experimental.fbs.NodeType.Primitive)}static addExecutionProviderType(h,l){h.addFieldOffset(7,l,0)}static addInputs(h,l){h.addFieldOffset(8,l,0)}static createInputsVector(h,l){h.startVector(4,l.length,4);for(let d=l.length-1;d>=0;d--)h.addOffset(l[d]);return h.endVector()}static startInputsVector(h,l){h.startVector(4,l,4)}static addOutputs(h,l){h.addFieldOffset(9,l,0)}static createOutputsVector(h,l){h.startVector(4,l.length,4);for(let d=l.length-1;d>=0;d--)h.addOffset(l[d]);return h.endVector()}static startOutputsVector(h,l){h.startVector(4,l,4)}static addAttributes(h,l){h.addFieldOffset(10,l,0)}static createAttributesVector(h,l){h.startVector(4,l.length,4);for(let d=l.length-1;d>=0;d--)h.addOffset(l[d]);return h.endVector()}static startAttributesVector(h,l){h.startVector(4,l,4)}static addInputArgCounts(h,l){h.addFieldOffset(11,l,0)}static createInputArgCountsVector(h,l){h.startVector(4,l.length,4);for(let d=l.length-1;d>=0;d--)h.addInt32(l[d]);return h.endVector()}static startInputArgCountsVector(h,l){h.startVector(4,l,4)}static addImplicitInputs(h,l){h.addFieldOffset(12,l,0)}static createImplicitInputsVector(h,l){h.startVector(4,l.length,4);for(let d=l.length-1;d>=0;d--)h.addOffset(l[d]);return h.endVector()}static startImplicitInputsVector(h,l){h.startVector(4,l,4)}static endNode(h){return h.endObject()}static createNode(h,l,d,f,y,w,D,M,$,B,z,G,H,te){return v.startNode(h),v.addName(h,l),v.addDocString(h,d),v.addDomain(h,f),v.addSinceVersion(h,y),v.addIndex(h,w),v.addOpType(h,D),v.addType(h,M),v.addExecutionProviderType(h,$),v.addInputs(h,B),v.addOutputs(h,z),v.addAttributes(h,G),v.addInputArgCounts(h,H),v.addImplicitInputs(h,te),v.endNode(h)}}C.Node=v}(S.fbs||(S.fbs={}))}(k.experimental||(k.experimental={}))}(E.onnxruntime||(E.onnxruntime={})),function(k){!function(S){!function(C){class v{constructor(){this.bb=null,this.bb_pos=0}__init(h,l){return this.bb_pos=h,this.bb=l,this}static getRootAsValueInfo(h,l){return(l||new v).__init(h.readInt32(h.position())+h.position(),h)}static getSizePrefixedRootAsValueInfo(h,l){return h.setPosition(h.position()+F.flatbuffers.SIZE_PREFIX_LENGTH),(l||new v).__init(h.readInt32(h.position())+h.position(),h)}name(h){let l=this.bb.__offset(this.bb_pos,4);return l?this.bb.__string(this.bb_pos+l,h):null}docString(h){let l=this.bb.__offset(this.bb_pos,6);return l?this.bb.__string(this.bb_pos+l,h):null}type(h){let l=this.bb.__offset(this.bb_pos,8);return l?(h||new k.experimental.fbs.TypeInfo).__init(this.bb.__indirect(this.bb_pos+l),this.bb):null}static startValueInfo(h){h.startObject(3)}static addName(h,l){h.addFieldOffset(0,l,0)}static addDocString(h,l){h.addFieldOffset(1,l,0)}static addType(h,l){h.addFieldOffset(2,l,0)}static endValueInfo(h){return h.endObject()}static createValueInfo(h,l,d,f){return v.startValueInfo(h),v.addName(h,l),v.addDocString(h,d),v.addType(h,f),v.endValueInfo(h)}}C.ValueInfo=v}(S.fbs||(S.fbs={}))}(k.experimental||(k.experimental={}))}(E.onnxruntime||(E.onnxruntime={})),function(k){!function(S){!function(C){class v{constructor(){this.bb=null,this.bb_pos=0}__init(h,l){return this.bb_pos=h,this.bb=l,this}static getRootAsTypeInfo(h,l){return(l||new v).__init(h.readInt32(h.position())+h.position(),h)}static getSizePrefixedRootAsTypeInfo(h,l){return h.setPosition(h.position()+F.flatbuffers.SIZE_PREFIX_LENGTH),(l||new v).__init(h.readInt32(h.position())+h.position(),h)}denotation(h){let l=this.bb.__offset(this.bb_pos,4);return l?this.bb.__string(this.bb_pos+l,h):null}valueType(){let h=this.bb.__offset(this.bb_pos,6);return h?this.bb.readUint8(this.bb_pos+h):k.experimental.fbs.TypeInfoValue.NONE}value(h){let l=this.bb.__offset(this.bb_pos,8);return l?this.bb.__union(h,this.bb_pos+l):null}static startTypeInfo(h){h.startObject(3)}static addDenotation(h,l){h.addFieldOffset(0,l,0)}static addValueType(h,l){h.addFieldInt8(1,l,k.experimental.fbs.TypeInfoValue.NONE)}static addValue(h,l){h.addFieldOffset(2,l,0)}static endTypeInfo(h){return h.endObject()}static createTypeInfo(h,l,d,f){return v.startTypeInfo(h),v.addDenotation(h,l),v.addValueType(h,d),v.addValue(h,f),v.endTypeInfo(h)}}C.TypeInfo=v}(S.fbs||(S.fbs={}))}(k.experimental||(k.experimental={}))}(E.onnxruntime||(E.onnxruntime={})),function(k){!function(S){!function(C){class v{constructor(){this.bb=null,this.bb_pos=0}__init(h,l){return this.bb_pos=h,this.bb=l,this}static getRootAsOperatorSetId(h,l){return(l||new v).__init(h.readInt32(h.position())+h.position(),h)}static getSizePrefixedRootAsOperatorSetId(h,l){return h.setPosition(h.position()+F.flatbuffers.SIZE_PREFIX_LENGTH),(l||new v).__init(h.readInt32(h.position())+h.position(),h)}domain(h){let l=this.bb.__offset(this.bb_pos,4);return l?this.bb.__string(this.bb_pos+l,h):null}version(){let h=this.bb.__offset(this.bb_pos,6);return h?this.bb.readInt64(this.bb_pos+h):this.bb.createLong(0,0)}static startOperatorSetId(h){h.startObject(2)}static addDomain(h,l){h.addFieldOffset(0,l,0)}static addVersion(h,l){h.addFieldInt64(1,l,h.createLong(0,0))}static endOperatorSetId(h){return h.endObject()}static createOperatorSetId(h,l,d){return v.startOperatorSetId(h),v.addDomain(h,l),v.addVersion(h,d),v.endOperatorSetId(h)}}C.OperatorSetId=v}(S.fbs||(S.fbs={}))}(k.experimental||(k.experimental={}))}(E.onnxruntime||(E.onnxruntime={})),function(k){!function(S){!function(C){class v{constructor(){this.bb=null,this.bb_pos=0}__init(h,l){return this.bb_pos=h,this.bb=l,this}static getRootAsTensor(h,l){return(l||new v).__init(h.readInt32(h.position())+h.position(),h)}static getSizePrefixedRootAsTensor(h,l){return h.setPosition(h.position()+F.flatbuffers.SIZE_PREFIX_LENGTH),(l||new v).__init(h.readInt32(h.position())+h.position(),h)}name(h){let l=this.bb.__offset(this.bb_pos,4);return l?this.bb.__string(this.bb_pos+l,h):null}docString(h){let l=this.bb.__offset(this.bb_pos,6);return l?this.bb.__string(this.bb_pos+l,h):null}dims(h){let l=this.bb.__offset(this.bb_pos,8);return l?this.bb.readInt64(this.bb.__vector(this.bb_pos+l)+8*h):this.bb.createLong(0,0)}dimsLength(){let h=this.bb.__offset(this.bb_pos,8);return h?this.bb.__vector_len(this.bb_pos+h):0}dataType(){let h=this.bb.__offset(this.bb_pos,10);return h?this.bb.readInt32(this.bb_pos+h):k.experimental.fbs.TensorDataType.UNDEFINED}rawData(h){let l=this.bb.__offset(this.bb_pos,12);return l?this.bb.readUint8(this.bb.__vector(this.bb_pos+l)+h):0}rawDataLength(){let h=this.bb.__offset(this.bb_pos,12);return h?this.bb.__vector_len(this.bb_pos+h):0}rawDataArray(){let h=this.bb.__offset(this.bb_pos,12);return h?new Uint8Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+h),this.bb.__vector_len(this.bb_pos+h)):null}stringData(h,l){let d=this.bb.__offset(this.bb_pos,14);return d?this.bb.__string(this.bb.__vector(this.bb_pos+d)+4*h,l):null}stringDataLength(){let h=this.bb.__offset(this.bb_pos,14);return h?this.bb.__vector_len(this.bb_pos+h):0}static startTensor(h){h.startObject(6)}static addName(h,l){h.addFieldOffset(0,l,0)}static addDocString(h,l){h.addFieldOffset(1,l,0)}static addDims(h,l){h.addFieldOffset(2,l,0)}static createDimsVector(h,l){h.startVector(8,l.length,8);for(let d=l.length-1;d>=0;d--)h.addInt64(l[d]);return h.endVector()}static startDimsVector(h,l){h.startVector(8,l,8)}static addDataType(h,l){h.addFieldInt32(3,l,k.experimental.fbs.TensorDataType.UNDEFINED)}static addRawData(h,l){h.addFieldOffset(4,l,0)}static createRawDataVector(h,l){h.startVector(1,l.length,1);for(let d=l.length-1;d>=0;d--)h.addInt8(l[d]);return h.endVector()}static startRawDataVector(h,l){h.startVector(1,l,1)}static addStringData(h,l){h.addFieldOffset(5,l,0)}static createStringDataVector(h,l){h.startVector(4,l.length,4);for(let d=l.length-1;d>=0;d--)h.addOffset(l[d]);return h.endVector()}static startStringDataVector(h,l){h.startVector(4,l,4)}static endTensor(h){return h.endObject()}static createTensor(h,l,d,f,y,w,D){return v.startTensor(h),v.addName(h,l),v.addDocString(h,d),v.addDims(h,f),v.addDataType(h,y),v.addRawData(h,w),v.addStringData(h,D),v.endTensor(h)}}C.Tensor=v}(S.fbs||(S.fbs={}))}(k.experimental||(k.experimental={}))}(E.onnxruntime||(E.onnxruntime={})),function(k){!function(S){!function(C){class v{constructor(){this.bb=null,this.bb_pos=0}__init(h,l){return this.bb_pos=h,this.bb=l,this}static getRootAsSparseTensor(h,l){return(l||new v).__init(h.readInt32(h.position())+h.position(),h)}static getSizePrefixedRootAsSparseTensor(h,l){return h.setPosition(h.position()+F.flatbuffers.SIZE_PREFIX_LENGTH),(l||new v).__init(h.readInt32(h.position())+h.position(),h)}values(h){let l=this.bb.__offset(this.bb_pos,4);return l?(h||new k.experimental.fbs.Tensor).__init(this.bb.__indirect(this.bb_pos+l),this.bb):null}indices(h){let l=this.bb.__offset(this.bb_pos,6);return l?(h||new k.experimental.fbs.Tensor).__init(this.bb.__indirect(this.bb_pos+l),this.bb):null}dims(h){let l=this.bb.__offset(this.bb_pos,8);return l?this.bb.readInt64(this.bb.__vector(this.bb_pos+l)+8*h):this.bb.createLong(0,0)}dimsLength(){let h=this.bb.__offset(this.bb_pos,8);return h?this.bb.__vector_len(this.bb_pos+h):0}static startSparseTensor(h){h.startObject(3)}static addValues(h,l){h.addFieldOffset(0,l,0)}static addIndices(h,l){h.addFieldOffset(1,l,0)}static addDims(h,l){h.addFieldOffset(2,l,0)}static createDimsVector(h,l){h.startVector(8,l.length,8);for(let d=l.length-1;d>=0;d--)h.addInt64(l[d]);return h.endVector()}static startDimsVector(h,l){h.startVector(8,l,8)}static endSparseTensor(h){return h.endObject()}static createSparseTensor(h,l,d,f){return v.startSparseTensor(h),v.addValues(h,l),v.addIndices(h,d),v.addDims(h,f),v.endSparseTensor(h)}}C.SparseTensor=v}(S.fbs||(S.fbs={}))}(k.experimental||(k.experimental={}))}(E.onnxruntime||(E.onnxruntime={})),function(k){!function(S){!function(C){class v{constructor(){this.bb=null,this.bb_pos=0}__init(h,l){return this.bb_pos=h,this.bb=l,this}static getRootAsAttribute(h,l){return(l||new v).__init(h.readInt32(h.position())+h.position(),h)}static getSizePrefixedRootAsAttribute(h,l){return h.setPosition(h.position()+F.flatbuffers.SIZE_PREFIX_LENGTH),(l||new v).__init(h.readInt32(h.position())+h.position(),h)}name(h){let l=this.bb.__offset(this.bb_pos,4);return l?this.bb.__string(this.bb_pos+l,h):null}docString(h){let l=this.bb.__offset(this.bb_pos,6);return l?this.bb.__string(this.bb_pos+l,h):null}type(){let h=this.bb.__offset(this.bb_pos,8);return h?this.bb.readInt32(this.bb_pos+h):k.experimental.fbs.AttributeType.UNDEFINED}f(){let h=this.bb.__offset(this.bb_pos,10);return h?this.bb.readFloat32(this.bb_pos+h):0}i(){let h=this.bb.__offset(this.bb_pos,12);return h?this.bb.readInt64(this.bb_pos+h):this.bb.createLong(0,0)}s(h){let l=this.bb.__offset(this.bb_pos,14);return l?this.bb.__string(this.bb_pos+l,h):null}t(h){let l=this.bb.__offset(this.bb_pos,16);return l?(h||new k.experimental.fbs.Tensor).__init(this.bb.__indirect(this.bb_pos+l),this.bb):null}g(h){let l=this.bb.__offset(this.bb_pos,18);return l?(h||new k.experimental.fbs.Graph).__init(this.bb.__indirect(this.bb_pos+l),this.bb):null}floats(h){let l=this.bb.__offset(this.bb_pos,20);return l?this.bb.readFloat32(this.bb.__vector(this.bb_pos+l)+4*h):0}floatsLength(){let h=this.bb.__offset(this.bb_pos,20);return h?this.bb.__vector_len(this.bb_pos+h):0}floatsArray(){let h=this.bb.__offset(this.bb_pos,20);return h?new Float32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+h),this.bb.__vector_len(this.bb_pos+h)):null}ints(h){let l=this.bb.__offset(this.bb_pos,22);return l?this.bb.readInt64(this.bb.__vector(this.bb_pos+l)+8*h):this.bb.createLong(0,0)}intsLength(){let h=this.bb.__offset(this.bb_pos,22);return h?this.bb.__vector_len(this.bb_pos+h):0}strings(h,l){let d=this.bb.__offset(this.bb_pos,24);return d?this.bb.__string(this.bb.__vector(this.bb_pos+d)+4*h,l):null}stringsLength(){let h=this.bb.__offset(this.bb_pos,24);return h?this.bb.__vector_len(this.bb_pos+h):0}tensors(h,l){let d=this.bb.__offset(this.bb_pos,26);return d?(l||new k.experimental.fbs.Tensor).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+d)+4*h),this.bb):null}tensorsLength(){let h=this.bb.__offset(this.bb_pos,26);return h?this.bb.__vector_len(this.bb_pos+h):0}graphs(h,l){let d=this.bb.__offset(this.bb_pos,28);return d?(l||new k.experimental.fbs.Graph).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+d)+4*h),this.bb):null}graphsLength(){let h=this.bb.__offset(this.bb_pos,28);return h?this.bb.__vector_len(this.bb_pos+h):0}static startAttribute(h){h.startObject(13)}static addName(h,l){h.addFieldOffset(0,l,0)}static addDocString(h,l){h.addFieldOffset(1,l,0)}static addType(h,l){h.addFieldInt32(2,l,k.experimental.fbs.AttributeType.UNDEFINED)}static addF(h,l){h.addFieldFloat32(3,l,0)}static addI(h,l){h.addFieldInt64(4,l,h.createLong(0,0))}static addS(h,l){h.addFieldOffset(5,l,0)}static addT(h,l){h.addFieldOffset(6,l,0)}static addG(h,l){h.addFieldOffset(7,l,0)}static addFloats(h,l){h.addFieldOffset(8,l,0)}static createFloatsVector(h,l){h.startVector(4,l.length,4);for(let d=l.length-1;d>=0;d--)h.addFloat32(l[d]);return h.endVector()}static startFloatsVector(h,l){h.startVector(4,l,4)}static addInts(h,l){h.addFieldOffset(9,l,0)}static createIntsVector(h,l){h.startVector(8,l.length,8);for(let d=l.length-1;d>=0;d--)h.addInt64(l[d]);return h.endVector()}static startIntsVector(h,l){h.startVector(8,l,8)}static addStrings(h,l){h.addFieldOffset(10,l,0)}static createStringsVector(h,l){h.startVector(4,l.length,4);for(let d=l.length-1;d>=0;d--)h.addOffset(l[d]);return h.endVector()}static startStringsVector(h,l){h.startVector(4,l,4)}static addTensors(h,l){h.addFieldOffset(11,l,0)}static createTensorsVector(h,l){h.startVector(4,l.length,4);for(let d=l.length-1;d>=0;d--)h.addOffset(l[d]);return h.endVector()}static startTensorsVector(h,l){h.startVector(4,l,4)}static addGraphs(h,l){h.addFieldOffset(12,l,0)}static createGraphsVector(h,l){h.startVector(4,l.length,4);for(let d=l.length-1;d>=0;d--)h.addOffset(l[d]);return h.endVector()}static startGraphsVector(h,l){h.startVector(4,l,4)}static endAttribute(h){return h.endObject()}static createAttribute(h,l,d,f,y,w,D,M,$,B,z,G,H,te){return v.startAttribute(h),v.addName(h,l),v.addDocString(h,d),v.addType(h,f),v.addF(h,y),v.addI(h,w),v.addS(h,D),v.addT(h,M),v.addG(h,$),v.addFloats(h,B),v.addInts(h,z),v.addStrings(h,G),v.addTensors(h,H),v.addGraphs(h,te),v.endAttribute(h)}}C.Attribute=v}(S.fbs||(S.fbs={}))}(k.experimental||(k.experimental={}))}(E.onnxruntime||(E.onnxruntime={})),function(k){!function(S){!function(C){class v{constructor(){this.bb=null,this.bb_pos=0}__init(h,l){return this.bb_pos=h,this.bb=l,this}static getRootAsGraph(h,l){return(l||new v).__init(h.readInt32(h.position())+h.position(),h)}static getSizePrefixedRootAsGraph(h,l){return h.setPosition(h.position()+F.flatbuffers.SIZE_PREFIX_LENGTH),(l||new v).__init(h.readInt32(h.position())+h.position(),h)}initializers(h,l){let d=this.bb.__offset(this.bb_pos,4);return d?(l||new k.experimental.fbs.Tensor).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+d)+4*h),this.bb):null}initializersLength(){let h=this.bb.__offset(this.bb_pos,4);return h?this.bb.__vector_len(this.bb_pos+h):0}nodeArgs(h,l){let d=this.bb.__offset(this.bb_pos,6);return d?(l||new k.experimental.fbs.ValueInfo).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+d)+4*h),this.bb):null}nodeArgsLength(){let h=this.bb.__offset(this.bb_pos,6);return h?this.bb.__vector_len(this.bb_pos+h):0}nodes(h,l){let d=this.bb.__offset(this.bb_pos,8);return d?(l||new k.experimental.fbs.Node).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+d)+4*h),this.bb):null}nodesLength(){let h=this.bb.__offset(this.bb_pos,8);return h?this.bb.__vector_len(this.bb_pos+h):0}maxNodeIndex(){let h=this.bb.__offset(this.bb_pos,10);return h?this.bb.readUint32(this.bb_pos+h):0}nodeEdges(h,l){let d=this.bb.__offset(this.bb_pos,12);return d?(l||new k.experimental.fbs.NodeEdge).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+d)+4*h),this.bb):null}nodeEdgesLength(){let h=this.bb.__offset(this.bb_pos,12);return h?this.bb.__vector_len(this.bb_pos+h):0}inputs(h,l){let d=this.bb.__offset(this.bb_pos,14);return d?this.bb.__string(this.bb.__vector(this.bb_pos+d)+4*h,l):null}inputsLength(){let h=this.bb.__offset(this.bb_pos,14);return h?this.bb.__vector_len(this.bb_pos+h):0}outputs(h,l){let d=this.bb.__offset(this.bb_pos,16);return d?this.bb.__string(this.bb.__vector(this.bb_pos+d)+4*h,l):null}outputsLength(){let h=this.bb.__offset(this.bb_pos,16);return h?this.bb.__vector_len(this.bb_pos+h):0}sparseInitializers(h,l){let d=this.bb.__offset(this.bb_pos,18);return d?(l||new k.experimental.fbs.SparseTensor).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+d)+4*h),this.bb):null}sparseInitializersLength(){let h=this.bb.__offset(this.bb_pos,18);return h?this.bb.__vector_len(this.bb_pos+h):0}static startGraph(h){h.startObject(8)}static addInitializers(h,l){h.addFieldOffset(0,l,0)}static createInitializersVector(h,l){h.startVector(4,l.length,4);for(let d=l.length-1;d>=0;d--)h.addOffset(l[d]);return h.endVector()}static startInitializersVector(h,l){h.startVector(4,l,4)}static addNodeArgs(h,l){h.addFieldOffset(1,l,0)}static createNodeArgsVector(h,l){h.startVector(4,l.length,4);for(let d=l.length-1;d>=0;d--)h.addOffset(l[d]);return h.endVector()}static startNodeArgsVector(h,l){h.startVector(4,l,4)}static addNodes(h,l){h.addFieldOffset(2,l,0)}static createNodesVector(h,l){h.startVector(4,l.length,4);for(let d=l.length-1;d>=0;d--)h.addOffset(l[d]);return h.endVector()}static startNodesVector(h,l){h.startVector(4,l,4)}static addMaxNodeIndex(h,l){h.addFieldInt32(3,l,0)}static addNodeEdges(h,l){h.addFieldOffset(4,l,0)}static createNodeEdgesVector(h,l){h.startVector(4,l.length,4);for(let d=l.length-1;d>=0;d--)h.addOffset(l[d]);return h.endVector()}static startNodeEdgesVector(h,l){h.startVector(4,l,4)}static addInputs(h,l){h.addFieldOffset(5,l,0)}static createInputsVector(h,l){h.startVector(4,l.length,4);for(let d=l.length-1;d>=0;d--)h.addOffset(l[d]);return h.endVector()}static startInputsVector(h,l){h.startVector(4,l,4)}static addOutputs(h,l){h.addFieldOffset(6,l,0)}static createOutputsVector(h,l){h.startVector(4,l.length,4);for(let d=l.length-1;d>=0;d--)h.addOffset(l[d]);return h.endVector()}static startOutputsVector(h,l){h.startVector(4,l,4)}static addSparseInitializers(h,l){h.addFieldOffset(7,l,0)}static createSparseInitializersVector(h,l){h.startVector(4,l.length,4);for(let d=l.length-1;d>=0;d--)h.addOffset(l[d]);return h.endVector()}static startSparseInitializersVector(h,l){h.startVector(4,l,4)}static endGraph(h){return h.endObject()}static createGraph(h,l,d,f,y,w,D,M,$){return v.startGraph(h),v.addInitializers(h,l),v.addNodeArgs(h,d),v.addNodes(h,f),v.addMaxNodeIndex(h,y),v.addNodeEdges(h,w),v.addInputs(h,D),v.addOutputs(h,M),v.addSparseInitializers(h,$),v.endGraph(h)}}C.Graph=v}(S.fbs||(S.fbs={}))}(k.experimental||(k.experimental={}))}(E.onnxruntime||(E.onnxruntime={})),function(k){!function(S){!function(C){class v{constructor(){this.bb=null,this.bb_pos=0}__init(h,l){return this.bb_pos=h,this.bb=l,this}static getRootAsModel(h,l){return(l||new v).__init(h.readInt32(h.position())+h.position(),h)}static getSizePrefixedRootAsModel(h,l){return h.setPosition(h.position()+F.flatbuffers.SIZE_PREFIX_LENGTH),(l||new v).__init(h.readInt32(h.position())+h.position(),h)}irVersion(){let h=this.bb.__offset(this.bb_pos,4);return h?this.bb.readInt64(this.bb_pos+h):this.bb.createLong(0,0)}opsetImport(h,l){let d=this.bb.__offset(this.bb_pos,6);return d?(l||new k.experimental.fbs.OperatorSetId).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+d)+4*h),this.bb):null}opsetImportLength(){let h=this.bb.__offset(this.bb_pos,6);return h?this.bb.__vector_len(this.bb_pos+h):0}producerName(h){let l=this.bb.__offset(this.bb_pos,8);return l?this.bb.__string(this.bb_pos+l,h):null}producerVersion(h){let l=this.bb.__offset(this.bb_pos,10);return l?this.bb.__string(this.bb_pos+l,h):null}domain(h){let l=this.bb.__offset(this.bb_pos,12);return l?this.bb.__string(this.bb_pos+l,h):null}modelVersion(){let h=this.bb.__offset(this.bb_pos,14);return h?this.bb.readInt64(this.bb_pos+h):this.bb.createLong(0,0)}docString(h){let l=this.bb.__offset(this.bb_pos,16);return l?this.bb.__string(this.bb_pos+l,h):null}graph(h){let l=this.bb.__offset(this.bb_pos,18);return l?(h||new k.experimental.fbs.Graph).__init(this.bb.__indirect(this.bb_pos+l),this.bb):null}graphDocString(h){let l=this.bb.__offset(this.bb_pos,20);return l?this.bb.__string(this.bb_pos+l,h):null}static startModel(h){h.startObject(9)}static addIrVersion(h,l){h.addFieldInt64(0,l,h.createLong(0,0))}static addOpsetImport(h,l){h.addFieldOffset(1,l,0)}static createOpsetImportVector(h,l){h.startVector(4,l.length,4);for(let d=l.length-1;d>=0;d--)h.addOffset(l[d]);return h.endVector()}static startOpsetImportVector(h,l){h.startVector(4,l,4)}static addProducerName(h,l){h.addFieldOffset(2,l,0)}static addProducerVersion(h,l){h.addFieldOffset(3,l,0)}static addDomain(h,l){h.addFieldOffset(4,l,0)}static addModelVersion(h,l){h.addFieldInt64(5,l,h.createLong(0,0))}static addDocString(h,l){h.addFieldOffset(6,l,0)}static addGraph(h,l){h.addFieldOffset(7,l,0)}static addGraphDocString(h,l){h.addFieldOffset(8,l,0)}static endModel(h){return h.endObject()}static createModel(h,l,d,f,y,w,D,M,$,B){return v.startModel(h),v.addIrVersion(h,l),v.addOpsetImport(h,d),v.addProducerName(h,f),v.addProducerVersion(h,y),v.addDomain(h,w),v.addModelVersion(h,D),v.addDocString(h,M),v.addGraph(h,$),v.addGraphDocString(h,B),v.endModel(h)}}C.Model=v}(S.fbs||(S.fbs={}))}(k.experimental||(k.experimental={}))}(E.onnxruntime||(E.onnxruntime={})),function(k){!function(S){!function(C){class v{constructor(){this.bb=null,this.bb_pos=0}__init(h,l){return this.bb_pos=h,this.bb=l,this}static getRootAsKernelCreateInfos(h,l){return(l||new v).__init(h.readInt32(h.position())+h.position(),h)}static getSizePrefixedRootAsKernelCreateInfos(h,l){return h.setPosition(h.position()+F.flatbuffers.SIZE_PREFIX_LENGTH),(l||new v).__init(h.readInt32(h.position())+h.position(),h)}nodeIndices(h){let l=this.bb.__offset(this.bb_pos,4);return l?this.bb.readUint32(this.bb.__vector(this.bb_pos+l)+4*h):0}nodeIndicesLength(){let h=this.bb.__offset(this.bb_pos,4);return h?this.bb.__vector_len(this.bb_pos+h):0}nodeIndicesArray(){let h=this.bb.__offset(this.bb_pos,4);return h?new Uint32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+h),this.bb.__vector_len(this.bb_pos+h)):null}kernelDefHashes(h){let l=this.bb.__offset(this.bb_pos,6);return l?this.bb.readUint64(this.bb.__vector(this.bb_pos+l)+8*h):this.bb.createLong(0,0)}kernelDefHashesLength(){let h=this.bb.__offset(this.bb_pos,6);return h?this.bb.__vector_len(this.bb_pos+h):0}static startKernelCreateInfos(h){h.startObject(2)}static addNodeIndices(h,l){h.addFieldOffset(0,l,0)}static createNodeIndicesVector(h,l){h.startVector(4,l.length,4);for(let d=l.length-1;d>=0;d--)h.addInt32(l[d]);return h.endVector()}static startNodeIndicesVector(h,l){h.startVector(4,l,4)}static addKernelDefHashes(h,l){h.addFieldOffset(1,l,0)}static createKernelDefHashesVector(h,l){h.startVector(8,l.length,8);for(let d=l.length-1;d>=0;d--)h.addInt64(l[d]);return h.endVector()}static startKernelDefHashesVector(h,l){h.startVector(8,l,8)}static endKernelCreateInfos(h){return h.endObject()}static createKernelCreateInfos(h,l,d){return v.startKernelCreateInfos(h),v.addNodeIndices(h,l),v.addKernelDefHashes(h,d),v.endKernelCreateInfos(h)}}C.KernelCreateInfos=v}(S.fbs||(S.fbs={}))}(k.experimental||(k.experimental={}))}(E.onnxruntime||(E.onnxruntime={})),function(k){!function(S){!function(C){class v{constructor(){this.bb=null,this.bb_pos=0}__init(h,l){return this.bb_pos=h,this.bb=l,this}static getRootAsSubGraphSessionState(h,l){return(l||new v).__init(h.readInt32(h.position())+h.position(),h)}static getSizePrefixedRootAsSubGraphSessionState(h,l){return h.setPosition(h.position()+F.flatbuffers.SIZE_PREFIX_LENGTH),(l||new v).__init(h.readInt32(h.position())+h.position(),h)}graphId(h){let l=this.bb.__offset(this.bb_pos,4);return l?this.bb.__string(this.bb_pos+l,h):null}sessionState(h){let l=this.bb.__offset(this.bb_pos,6);return l?(h||new k.experimental.fbs.SessionState).__init(this.bb.__indirect(this.bb_pos+l),this.bb):null}static startSubGraphSessionState(h){h.startObject(2)}static addGraphId(h,l){h.addFieldOffset(0,l,0)}static addSessionState(h,l){h.addFieldOffset(1,l,0)}static endSubGraphSessionState(h){let l=h.endObject();return h.requiredField(l,4),l}static createSubGraphSessionState(h,l,d){return v.startSubGraphSessionState(h),v.addGraphId(h,l),v.addSessionState(h,d),v.endSubGraphSessionState(h)}}C.SubGraphSessionState=v}(S.fbs||(S.fbs={}))}(k.experimental||(k.experimental={}))}(E.onnxruntime||(E.onnxruntime={})),function(k){!function(S){!function(C){class v{constructor(){this.bb=null,this.bb_pos=0}__init(h,l){return this.bb_pos=h,this.bb=l,this}static getRootAsSessionState(h,l){return(l||new v).__init(h.readInt32(h.position())+h.position(),h)}static getSizePrefixedRootAsSessionState(h,l){return h.setPosition(h.position()+F.flatbuffers.SIZE_PREFIX_LENGTH),(l||new v).__init(h.readInt32(h.position())+h.position(),h)}kernels(h){let l=this.bb.__offset(this.bb_pos,4);return l?(h||new k.experimental.fbs.KernelCreateInfos).__init(this.bb.__indirect(this.bb_pos+l),this.bb):null}subGraphSessionStates(h,l){let d=this.bb.__offset(this.bb_pos,6);return d?(l||new k.experimental.fbs.SubGraphSessionState).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+d)+4*h),this.bb):null}subGraphSessionStatesLength(){let h=this.bb.__offset(this.bb_pos,6);return h?this.bb.__vector_len(this.bb_pos+h):0}static startSessionState(h){h.startObject(2)}static addKernels(h,l){h.addFieldOffset(0,l,0)}static addSubGraphSessionStates(h,l){h.addFieldOffset(1,l,0)}static createSubGraphSessionStatesVector(h,l){h.startVector(4,l.length,4);for(let d=l.length-1;d>=0;d--)h.addOffset(l[d]);return h.endVector()}static startSubGraphSessionStatesVector(h,l){h.startVector(4,l,4)}static endSessionState(h){return h.endObject()}static createSessionState(h,l,d){return v.startSessionState(h),v.addKernels(h,l),v.addSubGraphSessionStates(h,d),v.endSessionState(h)}}C.SessionState=v}(S.fbs||(S.fbs={}))}(k.experimental||(k.experimental={}))}(E.onnxruntime||(E.onnxruntime={})),function(k){!function(S){!function(C){class v{constructor(){this.bb=null,this.bb_pos=0}__init(h,l){return this.bb_pos=h,this.bb=l,this}static getRootAsInferenceSession(h,l){return(l||new v).__init(h.readInt32(h.position())+h.position(),h)}static getSizePrefixedRootAsInferenceSession(h,l){return h.setPosition(h.position()+F.flatbuffers.SIZE_PREFIX_LENGTH),(l||new v).__init(h.readInt32(h.position())+h.position(),h)}static bufferHasIdentifier(h){return h.__has_identifier("ORTM")}ortVersion(h){let l=this.bb.__offset(this.bb_pos,4);return l?this.bb.__string(this.bb_pos+l,h):null}model(h){let l=this.bb.__offset(this.bb_pos,6);return l?(h||new k.experimental.fbs.Model).__init(this.bb.__indirect(this.bb_pos+l),this.bb):null}sessionState(h){let l=this.bb.__offset(this.bb_pos,8);return l?(h||new k.experimental.fbs.SessionState).__init(this.bb.__indirect(this.bb_pos+l),this.bb):null}static startInferenceSession(h){h.startObject(3)}static addOrtVersion(h,l){h.addFieldOffset(0,l,0)}static addModel(h,l){h.addFieldOffset(1,l,0)}static addSessionState(h,l){h.addFieldOffset(2,l,0)}static endInferenceSession(h){return h.endObject()}static finishInferenceSessionBuffer(h,l){h.finish(l,"ORTM")}static finishSizePrefixedInferenceSessionBuffer(h,l){h.finish(l,"ORTM",!0)}static createInferenceSession(h,l,d,f){return v.startInferenceSession(h),v.addOrtVersion(h,l),v.addModel(h,d),v.addSessionState(h,f),v.endInferenceSession(h)}}C.InferenceSession=v}(S.fbs||(S.fbs={}))}(k.experimental||(k.experimental={}))}(E.onnxruntime||(E.onnxruntime={}))},1723:(me,E,P)=>{"use strict";Object.defineProperty(E,"__esModule",{value:!0}),E.OnnxjsSessionHandler=void 0;const F=P(2235),A=P(9240);E.OnnxjsSessionHandler=class{constructor(O){this.session=O,this.inputNames=this.session.inputNames,this.outputNames=this.session.outputNames}dispose(){return _asyncToGenerator(function*(){})()}run(O,k,S){var C=this;return _asyncToGenerator(function*(){const v=new Map;for(const l in O)if(Object.hasOwnProperty.call(O,l)){const d=O[l];v.set(l,new A.Tensor(d.dims,d.type,void 0,void 0,d.data))}const b=yield C.session.run(v),h={};return b.forEach((l,d)=>{h[d]=new F.Tensor(l.type,l.data,l.dims)}),h})()}startProfiling(){this.session.startProfiling()}endProfiling(){this.session.endProfiling()}}},6027:(me,E,P)=>{"use strict";Object.defineProperty(E,"__esModule",{value:!0}),E.Session=void 0;const F=P(7067),A=P(1296),O=P(1975),k=P(6496),S=P(1315),C=P(1745);E.Session=class{constructor(v={}){this._initialized=!1,this.backendHint=v.backendHint,this.profiler=S.Profiler.create(v.profiler),this.context={profiler:this.profiler,graphInputTypes:[],graphInputDims:[]}}get inputNames(){return this._model.graph.getInputNames()}get outputNames(){return this._model.graph.getOutputNames()}startProfiling(){this.profiler.start()}endProfiling(){this.profiler.stop()}loadModel(v,b,h){var l=this;return _asyncToGenerator(function*(){yield l.profiler.event("session","Session.loadModel",_asyncToGenerator(function*(){const d=yield(0,O.resolveBackend)(l.backendHint);if(l.sessionHandler=d.createSessionHandler(l.context),l._model=new C.Model,"string"==typeof v){const f=v.endsWith(".ort");if(typeof process<"u"&&process.versions&&process.versions.node){const y=yield(0,A.promisify)(F.readFile)(v);l.initialize(y,f)}else{const y=yield fetch(v),w=yield y.arrayBuffer();l.initialize(new Uint8Array(w),f)}}else if(ArrayBuffer.isView(v))l.initialize(v);else{const f=new Uint8Array(v,b||0,h||v.byteLength);l.initialize(f)}}))})()}initialize(v,b){if(this._initialized)throw new Error("already initialized");this.profiler.event("session","Session.initialize",()=>{this._model.load(v,this.sessionHandler.transformGraph?this.sessionHandler:void 0,b),this.sessionHandler.onGraphInitialized&&this.sessionHandler.onGraphInitialized(this._model.graph),this.initializeOps(this._model.graph),this._executionPlan=new k.ExecutionPlan(this._model.graph,this._ops,this.profiler)}),this._initialized=!0}run(v){var b=this;return _asyncToGenerator(function*(){if(!b._initialized)throw new Error("session not initialized yet");return b.profiler.event("session","Session.run",_asyncToGenerator(function*(){const h=b.normalizeAndValidateInputs(v),l=yield b._executionPlan.execute(b.sessionHandler,h);return b.createOutput(l)}))})()}normalizeAndValidateInputs(v){const b=this._model.graph.getInputNames();if(Array.isArray(v)){if(v.length!==b.length)throw new Error(`incorrect input array length: expected ${b.length} but got ${v.length}`)}else{if(v.size!==b.length)throw new Error(`incorrect input map size: expected ${b.length} but got ${v.size}`);const h=new Array(v.size);let l=0;for(let d=0;d<b.length;++d){const f=v.get(b[d]);if(!f)throw new Error(`missing input tensor for: '${name}'`);h[l++]=f}v=h}if(this.context.graphInputTypes&&0!==this.context.graphInputTypes.length&&this.context.graphInputDims&&0!==this.context.graphInputDims.length)this.validateInputTensorDims(this.context.graphInputDims,v,!1);else{const h=this._model.graph.getInputIndices(),l=this._model.graph.getValues(),d=new Array(h.length);for(let f=0;f<h.length;++f){const y=l[h[f]];d[f]=y.type.shape.dims,this.context.graphInputTypes.push(y.type.tensorType),this.context.graphInputDims.push(v[f].dims)}this.validateInputTensorDims(d,v,!0)}return this.validateInputTensorTypes(this.context.graphInputTypes,v),v}validateInputTensorTypes(v,b){for(let h=0;h<b.length;h++){const l=v[h],d=b[h].type;if(l!==d)throw new Error(`input tensor[${h}] check failed: expected type '${l}' but got ${d}`)}}validateInputTensorDims(v,b,h){for(let l=0;l<b.length;l++){const d=v[l],f=b[l].dims;if(!this.compareTensorDims(d,f,h))throw new Error(`input tensor[${l}] check failed: expected shape '[${d.join(",")}]' but got [${f.join(",")}]`)}}compareTensorDims(v,b,h){if(v.length!==b.length)return!1;for(let l=0;l<v.length;++l)if(v[l]!==b[l]&&(!h||0!==v[l]))return!1;return!0}createOutput(v){const b=this._model.graph.getOutputNames();if(v.length!==b.length)throw new Error("expected number of outputs do not match number of generated outputs");const h=new Map;for(let l=0;l<b.length;++l)h.set(b[l],v[l]);return h}initializeOps(v){const b=v.getNodes();this._ops=new Array(b.length);for(let h=0;h<b.length;h++)this._ops[h]=this.sessionHandler.resolve(b[h],this._model.opsets,v)}}},9240:function(me,E,P){"use strict";var F=this&&this.__importDefault||function(y){return y&&y.__esModule?y:{default:y}};Object.defineProperty(E,"__esModule",{value:!0}),E.Tensor=void 0;const A=P(3442),O=F(P(1583)),k=P(5127),S=P(2446),C=P(7273);var v=k.onnxruntime.experimental.fbs;class b{get data(){if(void 0===this.cache){const w=this.dataProvider(this.dataId);if(w.length!==this.size)throw new Error("Length of data provided by the Data Provider is inconsistent with the dims of this Tensor.");this.cache=w}return this.cache}get stringData(){if("string"!==this.type)throw new TypeError("data type is not string");return this.data}get integerData(){switch(this.type){case"uint8":case"int8":case"uint16":case"int16":case"int32":case"uint32":case"bool":return this.data;default:throw new TypeError("data type is not integer (uint8, int8, uint16, int16, int32, uint32, bool)")}}get floatData(){switch(this.type){case"float32":case"float64":return this.data;default:throw new TypeError("data type is not float (float32, float64)")}}get numberData(){if("string"!==this.type)return this.data;throw new TypeError("type cannot be non-number (string)")}get(w){return this.data[C.ShapeUtil.indicesToOffset(w,this.strides)]}set(w,D){this.data[C.ShapeUtil.indicesToOffset(w,this.strides)]=D}getData(){var w=this;return _asyncToGenerator(function*(){return void 0===w.cache&&(w.cache=yield w.asyncDataProvider(w.dataId)),w.cache})()}get strides(){return this._strides||(this._strides=C.ShapeUtil.computeStrides(this.dims)),this._strides}constructor(w,D,M,$,B,z=A.Guid.create()){this.dims=w,this.type=D,this.dataProvider=M,this.asyncDataProvider=$,this.cache=B,this.dataId=z,this.size=C.ShapeUtil.validateDimsAndCalcSize(w);const G=this.size,H=void 0===M&&void 0===$&&void 0===B;if(void 0!==B&&B.length!==G)throw new RangeError("Input dims doesn't match data length.");if("string"===D){if(!(void 0===B||Array.isArray(B)&&B.every(te=>"string"==typeof te)))throw new TypeError("cache should be a string array");H&&(this.cache=new Array(G))}else{if(void 0!==B){const te=l(D);if(!(B instanceof te))throw new TypeError(`cache should be type ${te.name}`)}if(H){const te=new ArrayBuffer(G*function(ae){switch(ae){case"bool":case"int8":case"uint8":return 1;case"int16":case"uint16":return 2;case"int32":case"uint32":case"float32":return 4;case"float64":return 8;default:throw new Error(`cannot calculate sizeof() on type ${ae}`)}}(D));this.cache=(ae=te,new(l(D))(ae))}}var ae}static fromProto(w){if(!w)throw new Error("cannot construct Value from an empty tensor");const D=C.ProtoUtil.tensorDataTypeFromProto(w.dataType),M=C.ProtoUtil.tensorDimsFromProto(w.dims),$=new b(M,D);if("string"===D)w.stringData.forEach((B,z)=>{$.data[z]=(0,C.decodeUtf8String)(B)});else if(w.rawData&&"number"==typeof w.rawData.byteLength&&w.rawData.byteLength>0){const B=$.data,z=new DataView(w.rawData.buffer,w.rawData.byteOffset,w.rawData.byteLength),G=h(w.dataType),H=w.rawData.byteLength/G;if(w.rawData.byteLength%G!=0)throw new Error("invalid buffer length");if(B.length!==H)throw new Error("buffer length mismatch");for(let te=0;te<H;te++){const ae=f(z,w.dataType,te*G);B[te]=ae}}else{let B;switch(w.dataType){case S.onnx.TensorProto.DataType.FLOAT:B=w.floatData;break;case S.onnx.TensorProto.DataType.INT32:case S.onnx.TensorProto.DataType.INT16:case S.onnx.TensorProto.DataType.UINT16:case S.onnx.TensorProto.DataType.INT8:case S.onnx.TensorProto.DataType.UINT8:case S.onnx.TensorProto.DataType.BOOL:B=w.int32Data;break;case S.onnx.TensorProto.DataType.INT64:B=w.int64Data;break;case S.onnx.TensorProto.DataType.DOUBLE:B=w.doubleData;break;case S.onnx.TensorProto.DataType.UINT32:case S.onnx.TensorProto.DataType.UINT64:B=w.uint64Data;break;default:throw new Error("unspecific error")}if(null==B)throw new Error("failed to populate data from a tensorproto value");const z=$.data;if(z.length!==B.length)throw new Error("array length mismatch");for(let G=0;G<B.length;G++){const H=B[G];z[G]=O.default.isLong(H)?d(H,w.dataType):H}}return $}static fromData(w,D,M){return new b(D,M,void 0,void 0,w)}static fromOrtTensor(w){if(!w)throw new Error("cannot construct Value from an empty tensor");const D=C.ProtoUtil.tensorDimsFromORTFormat(w),M=C.ProtoUtil.tensorDataTypeFromProto(w.dataType()),$=new b(D,M);if("string"===M)for(let B=0;B<w.stringDataLength();B++)$.data[B]=w.stringData(B);else if(w.rawDataArray()&&"number"==typeof w.rawDataLength()&&w.rawDataLength()>0){const B=$.data,z=new DataView(w.rawDataArray().buffer,w.rawDataArray().byteOffset,w.rawDataLength()),G=h(w.dataType()),H=w.rawDataLength()/G;if(w.rawDataLength()%G!=0)throw new Error("invalid buffer length");if(B.length!==H)throw new Error("buffer length mismatch");for(let te=0;te<H;te++){const ae=f(z,w.dataType(),te*G);B[te]=ae}}return $}}function h(y){switch(y){case S.onnx.TensorProto.DataType.UINT8:case S.onnx.TensorProto.DataType.INT8:case S.onnx.TensorProto.DataType.BOOL:return 1;case S.onnx.TensorProto.DataType.UINT16:case S.onnx.TensorProto.DataType.INT16:return 2;case S.onnx.TensorProto.DataType.FLOAT:case S.onnx.TensorProto.DataType.INT32:case S.onnx.TensorProto.DataType.UINT32:return 4;case S.onnx.TensorProto.DataType.INT64:case S.onnx.TensorProto.DataType.DOUBLE:case S.onnx.TensorProto.DataType.UINT64:return 8;default:throw new Error(`cannot calculate sizeof() on type ${S.onnx.TensorProto.DataType[y]}`)}}function l(y){switch(y){case"bool":case"uint8":return Uint8Array;case"int8":return Int8Array;case"int16":return Int16Array;case"uint16":return Uint16Array;case"int32":return Int32Array;case"uint32":return Uint32Array;case"int64":return BigInt64Array;case"float32":return Float32Array;case"float64":return Float64Array;default:throw new Error("unspecified error")}}function d(y,w){if(w===S.onnx.TensorProto.DataType.INT64||w===v.TensorDataType.INT64){if(y.greaterThanOrEqual(2147483648)||y.lessThan(-2147483648))throw new TypeError("int64 is not supported")}else{if(w!==S.onnx.TensorProto.DataType.UINT32&&w!==v.TensorDataType.UINT32&&w!==S.onnx.TensorProto.DataType.UINT64&&w!==v.TensorDataType.UINT64)throw new TypeError(`not a LONG type: ${S.onnx.TensorProto.DataType[w]}`);if(y.greaterThanOrEqual(4294967296)||y.lessThan(0))throw new TypeError("uint64 is not supported")}return y.toNumber()}function f(y,w,D){switch(w){case S.onnx.TensorProto.DataType.BOOL:case S.onnx.TensorProto.DataType.UINT8:return y.getUint8(D);case S.onnx.TensorProto.DataType.INT8:return y.getInt8(D);case S.onnx.TensorProto.DataType.UINT16:return y.getUint16(D,!0);case S.onnx.TensorProto.DataType.INT16:return y.getInt16(D,!0);case S.onnx.TensorProto.DataType.FLOAT:return y.getFloat32(D,!0);case S.onnx.TensorProto.DataType.INT32:return y.getInt32(D,!0);case S.onnx.TensorProto.DataType.UINT32:return y.getUint32(D,!0);case S.onnx.TensorProto.DataType.INT64:return d(O.default.fromBits(y.getUint32(D,!0),y.getUint32(D+4,!0),!1),w);case S.onnx.TensorProto.DataType.DOUBLE:return y.getFloat64(D,!0);case S.onnx.TensorProto.DataType.UINT64:return d(O.default.fromBits(y.getUint32(D,!0),y.getUint32(D+4,!0),!0),w);default:throw new Error(`cannot read from DataView for type ${S.onnx.TensorProto.DataType[w]}`)}}E.Tensor=b},7273:function(me,E,P){"use strict";var F=this&&this.__importDefault||function(w){return w&&w.__esModule?w:{default:w}};Object.defineProperty(E,"__esModule",{value:!0}),E.decodeUtf8String=E.MAX_CLIP=E.MIN_CLIP=E.PoolConvUtil=E.ReduceUtil=E.SplitUtil=E.MathUtil=E.ShapeUtil=E.LongUtil=E.ProtoUtil=E.GemmUtil=E.arrayCopyHelper=E.BroadcastUtil=E.MatMulUtil=E.ArrayUtil=E.assert=E.checkInputsShape=void 0;const A=P(5686),O=F(P(1583)),k=P(2446),S=P(9240);E.checkInputsShape=function(w,...D){if(!w||w.length!==D.length)return!1;for(let M=0;M<w.length;M++)if(!w[M].dims||w[M].dims.length!==D[M])return!1;return!0},E.assert=function(w,D){if(!w)throw new Error("string"==typeof D?D:D())},E.ArrayUtil=class{static arraysEqual(w,D){if(w.length!==D.length)return!1;for(let M=0;M<w.length;M++)if(w[M]!==D[M])return!1;return!0}};class C{static preprocessInputShapes(D,M){return[1===D.length?[1,D[0]]:D,1===M.length?[M[0],1]:M]}static postprocessOutputShape(D,M,$){1===M&&D.splice(D.length-2,1),1===$&&D.pop()}static calcMatMulShape(D,M){return D[1]!==M[0]?void 0:[D[0],M[1]]}}E.MatMulUtil=C;class v{static calcShape(D,M,$=!1){const B=D.length,z=M.length;if(0===B)return M;if(0===z)return D;const G=Math.max(D.length,M.length),H=new Array(G);if($){if(B<2||z<2)return;const te=C.calcMatMulShape([D[B-2],D[B-1]],[M[z-2],M[z-1]]);if(void 0===te)return;[H[G-2],H[G-1]]=te}for(let te=$?3:1;te<=G;te++){const ae=B-te<0?1:D[B-te],J=z-te<0?1:M[z-te];if(ae!==J&&ae>1&&J>1)return;H[G-te]=Math.max(ae,J)}return H}static index(D,M){const $=new Array(M.length);return v.fillIndex(D,M,$),$}static fillIndex(D,M,$){const B=D.length-M.length;for(let z=0;z<M.length;z++)$[z]=D[B+z]%M[z]}static calc(D,M,$,B,z){const G=v.calcShape(D.dims,M.dims);if(G){if(B&&!l.areEqual(G,D.dims))return;const H=l.size(G),te=B?D:new S.Tensor(G,z||D.type);if(0===G.length)te.set([],$(D.get([]),M.get([])));else{const ae=new Array(G.length),J=new Array(D.dims.length),ne=new Array(M.dims.length);let X,K=0,ve=0,q=!1,re=!1;0===D.dims.length&&(K=D.get([]),q=!0),0===M.dims.length&&(ve=M.get([]),re=!0);for(let le=0;le<H;le++){X=le;for(let He=G.length-1;He>=0;He--)ae[He]=X%G[He],X=Math.floor(X/G[He]);q||(v.fillIndex(ae,D.dims,J),K=D.get(J)),re||(v.fillIndex(ae,M.dims,ne),ve=M.get(ne)),te.set(ae,$(K,ve))}}return te}}static isValidBroadcast(D,M){const $=D.length,B=M.length;if($>B)return!1;for(let z=1;z<=$;z++)if(1!==D[$-z]&&D[$-z]!==M[B-z])return!1;return!0}static getBroadcastDims(D,M){const $=D.length,B=[];for(let z=0;z<$;z++){const G=$-1-z;(M[M.length-1-z]||1)>1&&1===(D[G]||1)&&B.unshift(G)}return B}}E.BroadcastUtil=v,E.arrayCopyHelper=function(w,D,M,$,B){if($<0||$>=D.length)throw new Error("sourceIndex out of bounds");if(M<0||M>=w.length)throw new Error("targetIndex out of bounds");if($+B>D.length)throw new Error("source indices to be copied are outside bounds");if(M+B>w.length)throw new Error("target array is too small to hold result");for(let z=0;z<B;z++)w[M+z]=D[$+z]},E.GemmUtil=class{static getShapeOfGemmResult(w,D,M,$,B){if(2!==w.length||2!==M.length)throw new Error("shape need to be of size 2");let z,G,H;D?(z=w[1],G=w[0]):(z=w[0],G=w[1]);let te=-1;if($?(H=M[0],te=1):(H=M[1],te=0),M[te]!==G)throw new Error("dimension mismatch");if(z<=0||H<=0||G<=0)throw new Error("invalid shape specified");if(B&&!v.isValidBroadcast(B,[z,H]))throw new Error("gemm: invalid bias shape for broadcast");return[z,H,G]}};class b{static tensorDataTypeFromProto(D){switch(D){case k.onnx.TensorProto.DataType.INT8:return"int8";case k.onnx.TensorProto.DataType.UINT8:return"uint8";case k.onnx.TensorProto.DataType.BOOL:return"bool";case k.onnx.TensorProto.DataType.INT16:return"int16";case k.onnx.TensorProto.DataType.UINT16:return"uint16";case k.onnx.TensorProto.DataType.INT32:return"int32";case k.onnx.TensorProto.DataType.UINT32:return"uint32";case k.onnx.TensorProto.DataType.FLOAT:return"float32";case k.onnx.TensorProto.DataType.DOUBLE:return"float64";case k.onnx.TensorProto.DataType.STRING:return"string";case k.onnx.TensorProto.DataType.INT64:return"int32";case k.onnx.TensorProto.DataType.UINT64:return"uint32";default:throw new Error(`unsupported data type: ${k.onnx.TensorProto.DataType[D]}`)}}static tensorDataTypeStringToEnum(D){switch(D){case"int8":return k.onnx.TensorProto.DataType.INT8;case"uint8":return k.onnx.TensorProto.DataType.UINT8;case"bool":return k.onnx.TensorProto.DataType.BOOL;case"int16":return k.onnx.TensorProto.DataType.INT16;case"uint16":return k.onnx.TensorProto.DataType.UINT16;case"int32":return k.onnx.TensorProto.DataType.INT32;case"uint32":return k.onnx.TensorProto.DataType.UINT32;case"float32":return k.onnx.TensorProto.DataType.FLOAT;case"float64":return k.onnx.TensorProto.DataType.DOUBLE;case"string":return k.onnx.TensorProto.DataType.STRING;case"int64":return k.onnx.TensorProto.DataType.INT64;case"uint64":return k.onnx.TensorProto.DataType.UINT64;default:throw new Error(`unsupported data type: ${D}`)}}static tensorDimsFromProto(D){return D.map(M=>O.default.isLong(M)?M.toNumber():M)}static tensorValueTypeFromProto(D){return{tensorType:b.tensorDataTypeFromProto(D.elemType),shape:{dims:b.tensorDimsFromProto(D.shape.dim.map(M=>M.dimValue))}}}static tensorDimsFromORTFormat(D){const M=[];for(let $=0;$<D.dimsLength();$++)M.push(h.longToNumber(D.dims($)));return M}static tensorAttributesFromORTFormat(D){const M=[];for(let $=0;$<D.attributesLength();$++)M.push(D.attributes($));return M}}E.ProtoUtil=b;class h{static longToNumber(D,M){return O.default.isLong(D)?D.toNumber():D instanceof A.flatbuffers.Long?O.default.fromValue({low:D.low,high:D.high,unsigned:null!=M&&M}).toNumber():D}static isLong(D){return O.default.isLong(D)||D instanceof A.flatbuffers.Long}}E.LongUtil=h;class l{static size(D){return l.getSizeFromDimensionRange(D,0,D.length)}static sizeFromDimension(D,M){if(M<0||M>D.length)throw new Error(`invalid dimension of ${M} for sizeFromDimension as Tensor has ${D.length} dimensions.`);return l.getSizeFromDimensionRange(D,M,D.length)}static sizeToDimension(D,M){if(M<0||M>D.length)throw new Error(`invalid dimension of ${M} for sizeToDimension as Tensor has ${D.length} dimensions.`);return l.getSizeFromDimensionRange(D,0,M)}static getSizeFromDimensionRange(D,M,$){let B=1;for(let z=M;z<$;z++){if(D[z]<=0)throw new Error("cannot get valid size from specified dimension range. Most likely the range contains 0 or negative values in them.");B*=D[z]}return B}static computeStrides(D){const M=D.length;if(0===M)return[];if(1===M)return[1];const $=new Array(M);$[M-1]=1,$[M-2]=D[M-1];for(let B=M-3;B>=0;--B)$[B]=$[B+1]*D[B+1];return $}static transpose(D){return D.slice().reverse()}static indicesToOffset(D,M,$){void 0===$&&($=D.length);let B=0;for(let z=0;z<$;++z)B+=M[z]*D[z];return B}static offsetToIndices(D,M){const $=M.length;if(0===$)return[];if(1===$)return[D*M[0]];const B=new Array(M.length);for(let z=0;z<B.length-1;++z)B[z]=Math.floor(D/M[z]),D-=B[z]*M[z];return B[B.length-1]=D,B}static normalizeAxis(D,M){if(D<-M&&D>=M)throw new Error("unsupported axis for this operation.");return D<0?D+M:D}static normalizeAxes(D,M){return D.map($=>this.normalizeAxis($,M))}static incrementIndex(D,M,$){if(0===M.length||0===D.length)throw new Error("Index incrementing unsupported for scalar Tensor");if(void 0===$)$=M.length;else if($<=0||$>M.length)throw new Error("Incorrect axis to increment on");for(let B=$-1;B>=0&&(D[B]++,!(D[B]<M[B]));--B)D[B]=0}static calculateReshapedDims(D,M){if(0===M.length){if(0===D.length||1===l.size(D))return[];throw new Error("cannot reshape to a scalar Tensor")}const $=M.length,B=new Array($);let z=-1,G=1;for(let te=0;te<$;te++){if(M[te]<-1)throw new Error("a dimension in shape hints cannot be less than -1");if(-1===M[te]){if(-1!==z)throw new Error("at most one dimension in shape hints can be -1");z=te}else{if(0===M[te]){if(te>=D.length)throw new Error("the dimension with value zero exceeds the dimension size of the input tensor");B[te]=D[te]}else B[te]=M[te];G*=B[te]}}const H=l.size(D);if(-1!==z){if(H%G!=0)throw new Error(`the input tensor cannot be reshaped to the requested shape. Input shape: [${D}] Output shape: [${M}]`);B[z]=H/G}else if(G!==H)throw new Error("reshapedDims and originalDims don't have matching sizes");return B}static sortBasedOnPerm(D,M){return M?M.map($=>D[$]):D.slice().reverse()}static padShape(D,M){const $=D.length;return D.map((B,z)=>B+M[z]+M[z+$])}static areEqual(D,M){return D.length===M.length&&D.every(($,B)=>$===M[B])}static validateDimsAndCalcSize(D){if(D.length>6)throw new TypeError("Only rank 0 to 6 is supported for tensor shape.");let M=1;for(const $ of D){if(!Number.isInteger($))throw new TypeError(`Invalid shape: ${$} is not an integer`);if($<0||$>2147483647)throw new TypeError(`Invalid shape: length ${$} is not allowed`);M*=$}return M}static flattenShape(D,M){M<0&&(M+=D.length);const $=D.reduce((z,G)=>z*G,1),B=D.slice(M).reduce((z,G)=>z*G,1);return[$/B,B]}static squeezeShape(D,M){const $=new Array;M=l.normalizeAxes(M,D.length);for(let B=0;B<D.length;B++){const z=M.indexOf(B)>=0;if(z&&1!==D[B])throw new Error("squeeze an axis of size different than 1");(0===M.length&&D[B]>1||M.length>0&&!z)&&$.push(D[B])}return $}static unsqueezeShape(D,M){const $=new Array(D.length+M.length);$.fill(0);for(let z=0;z<M.length;z++){const G=l.normalizeAxis(M[z],$.length);if(G>=$.length)throw new Error("'axes' has an out of range axis");if(0!==$[G])throw new Error("'axes' has a duplicate axis");$[G]=1}let B=0;for(let z=0;z<$.length;z++)0===$[z]&&($[z]=D[B++]);if(B!==D.length)throw new Error("the unsqueezed dimension could not be established");return $}}E.ShapeUtil=l,E.MathUtil=class{static sqr(w,D,M,$,B){if($<0||$>=D.length)throw new Error("sourceIndex out of bounds");if(M<0||M>=w.length)throw new Error("targetIndex out of bounds");if($+B>D.length)throw new Error("source indices to be copied are outside bounds");if(M+B>w.length)throw new Error("target array is too small to hold result");for(let z=0;z<B;z++)w[M+z]+=Math.pow(D[$+z],2)}static axpy(w,D,M,$,B,z){if($<0||$>=D.length)throw new Error("sourceIndex out of bounds");if(M<0||M>=w.length)throw new Error("targetIndex out of bounds");if($+B>D.length)throw new Error("source indices to be copied are outside bounds");if(M+B>w.length)throw new Error("target array is too small to hold result");for(let G=0;G<B;G++)w[M+G]+=z*D[$+G]}static powx(w,D,M,$,B,z){if($<0||$>=D.length)throw new Error("sourceIndex out of bounds");if(M<0||M>=w.length)throw new Error("targetIndex out of bounds");if($+B>D.length)throw new Error("source indices to be copied are outside bounds");if(M+B>w.length)throw new Error("target array is too small to hold result");for(let G=0;G<B;G++)w[M+G]=Math.pow(D[$+G],z)}static mul(w,D,M,$,B){if($<0||$>=D.length)throw new Error("sourceIndex out of bounds");if(M<0||M>=w.length)throw new Error("targetIndex out of bounds");if($+B>D.length)throw new Error("source indices to be copied are outside bounds");if(M+B>w.length)throw new Error("target array is too small to hold result");for(let z=0;z<B;z++)w[M+z]=D[$+z]*w[M+z]}};class d{static splitShape(D,M,$,B){if(0===$.length){if(!B)throw new Error("need to know number of outputs when the 'split' attribute is not specified");d.determineSplit(D[M],B,$)}const z=[],G=[0];for(let H=0;H<$.length;++H){0!==H&&G.push(G[H-1]+$[H-1]);const te=D.slice();te[M]=$[H],z.push(te)}return[z,G]}static determineSplit(D,M,$){if(D%M!=0)throw new Error("cannot split tensor to equal sized parts");for(let B=0;B<M;++B)$.push(D/M)}}E.SplitUtil=d;class f{static calcReduce(D,M,$,B,z){const G=D.dims.slice(0);0===M.length&&G.forEach((K,ve)=>M.push(ve));const H=f.calcReduceShape(G,M,!0),te=l.size(H),ae=new S.Tensor(H,D.type),J=l.computeStrides(H),ne=l.computeStrides(G),X=new Array(G.length);for(let K=0;K<te;K++){const ve=l.offsetToIndices(K,J);v.fillIndex(ve,G,X),ae.set(ve,f.calcReduceByAxis(D.numberData,M,G,0,l.indicesToOffset(X,ne),B,z))}return $?ae:new S.Tensor(f.calcReduceShape(G,M,$),ae.type,void 0,void 0,ae.data,ae.dataId)}static calcReduceByAxis(D,M,$,B,z,G,H){let te=0;if(B>=M.length)return G(D[z]);const ae=M[B],J=ae>=$.length?1:l.size($.slice(ae+1));for(let ne=0;ne<$[ae];ne++)te=0===ne?f.calcReduceByAxis(D,M,$,B+1,z,G,H):H(te,f.calcReduceByAxis(D,M,$,B+1,z,G,H)),z+=J;return te}static calcReduceShape(D,M,$){const B=D.slice();for(let z=0;z<M.length;z++)B[M[z]]=$?1:0;return B.filter(z=>0!==z)}}E.ReduceUtil=f;class y{static adjustPoolAttributes(D,M,$,B,z,G){if(!D&&$.length!==M.length-2)throw new Error("length of specified kernel shapes should be 2 less than length of input dimensions");if(D)for(let H=0;H<M.length-2;H++)H>=$.length?$.push(M[H+2]):$[H]=M[H+2];for(let H=0;H<$.length;H++)if(H<B.length){if(B[H]<0)throw new Error("strides should be greater than or equal to 1")}else B.push(1);for(let H=0;H<$.length;H++)if(H<z.length){if(z[H]<0)throw new Error("dilations should be greater than or equal to 1")}else z.push(1);for(let H=0;H<2*$.length;H++)if(H<G.length){if(G[H]<0)throw new Error("pad should be greater than or equal to 1")}else G.push(0);for(let H=0;H<$.length;H++){if($[H]<=0)throw new Error("kernel shapes need to be greater than 0");if(G[H]>=$[H]||G[H+$.length]>=$[H])throw new Error("pads should be smaller than kernel")}}static adjustPadsBasedOnAutoPad(D,M,$,B,z,G){if(G){if(z.length!==2*(D.length-2))throw new Error("length of pads should be twice the length of data dimensions");if(M.length!==D.length-2)throw new Error("length of strides should be the length of data dimensions");if(B.length!==D.length-2)throw new Error("length of kernel shapes should be the length of data dimensions");for(let H=0;H<D.length-2;H++)y.adjustPadAndReturnShape(D[H+2],M[H],$[H],B[H],z,H,H+D.length-2,G)}}static computePoolOutputShape(D,M,$,B,z,G,H){if(M.length<=0)throw new Error("input shape must be of size greater than 0");const te=[M[0],M[1]];return y.computeShapeHelper(D,M,te,$,B,z,G,H),te}static computeConvOutputShape(D,M,$,B,z,G,H){if(D.length<=0||M.length<=0)throw new Error("invalid input tensor dims or invalid filter tensor dims");const te=[D[0],M[0]];return y.computeShapeHelper(!1,D,te,$,B,z,G,H),te}static computeShapeHelper(D,M,$,B,z,G,H,te){if(D)for(let ae=0;ae<M.length-2;ae++)$.push(1);else for(let ae=0;ae<M.length-2;ae++)$.push(y.adjustPadAndReturnShape(M[ae+2],B[ae],z[ae],G[ae],H,ae,ae+M.length-2,te))}static adjustPadAndReturnShape(D,M,$,B,z,G,H,te){const ae=$*(B-1)+1;if(!te||"NOTSET"===te)return Math.floor((D+z[G]+z[H]-ae)/M+1);switch(te){case"VALID":return z[G]=0,z[H]=0,Math.floor((D-ae)/M+1);case"SAME_LOWER":case"SAME_UPPER":if(1!==$)throw new Error("Dilation not supported for SAME_UPPER or SAME_LOWER");{const J=((D+M-1)/M-1)*M+B-D;return z[G]=Math.floor("SAME_LOWER"===te?(J+1)/2:J/2),z[H]=J-z[G],Math.floor((D+J-B)/M+1)}default:throw new Error("Unsupported AutoPad type")}}}E.PoolConvUtil=y,E.MIN_CLIP=-34028234663852886e22,E.MAX_CLIP=34028234663852886e22,E.decodeUtf8String=function(w){return(new TextDecoder).decode(w)}},8408:(me,E)=>{"use strict";Object.defineProperty(E,"__esModule",{value:!0}),E.version=void 0,E.version="1.16.3"},9544:function(me,E,P){"use strict";var F,A=this&&this.__createBinding||(Object.create?function(J,ne,X,K){void 0===K&&(K=X);var ve=Object.getOwnPropertyDescriptor(ne,X);ve&&!("get"in ve?!ne.__esModule:ve.writable||ve.configurable)||(ve={enumerable:!0,get:function(){return ne[X]}}),Object.defineProperty(J,K,ve)}:function(J,ne,X,K){void 0===K&&(K=X),J[K]=ne[X]}),O=this&&this.__setModuleDefault||(Object.create?function(J,ne){Object.defineProperty(J,"default",{enumerable:!0,value:ne})}:function(J,ne){J.default=ne}),k=this&&this.__importStar||function(J){if(J&&J.__esModule)return J;var ne={};if(null!=J)for(var X in J)"default"!==X&&Object.prototype.hasOwnProperty.call(J,X)&&A(ne,J,X);return O(ne,J),ne};Object.defineProperty(E,"__esModule",{value:!0}),E.endProfiling=E.run=E.releaseSession=E.createSession=E.createSessionFinalize=E.createSessionAllocate=E.initializeRuntime=E.initializeWebAssemblyInstance=void 0;const S=P(2235),C=k(P(1259)),v=P(263),b=()=>!!S.env.wasm.proxy&&typeof document<"u";let h,l,d,f=!1,y=!1,w=!1;const D=[],M=[],$=[],B=[],z=[],G=[],H=()=>{if(f||!y||w||!h)throw new Error("worker not ready")},te=J=>{switch(J.data.type){case"init-wasm":f=!1,J.data.err?(w=!0,l[1](J.data.err)):(y=!0,l[0]());break;case"init-ort":J.data.err?d[1](J.data.err):d[0]();break;case"create_allocate":J.data.err?D.shift()[1](J.data.err):D.shift()[0](J.data.out);break;case"create_finalize":J.data.err?M.shift()[1](J.data.err):M.shift()[0](J.data.out);break;case"create":J.data.err?$.shift()[1](J.data.err):$.shift()[0](J.data.out);break;case"release":J.data.err?B.shift()[1](J.data.err):B.shift()[0]();break;case"run":J.data.err?z.shift()[1](J.data.err):z.shift()[0](J.data.out);break;case"end-profiling":J.data.err?G.shift()[1](J.data.err):G.shift()[0]()}},ae=typeof document<"u"?null===(F=document?.currentScript)||void 0===F?void 0:F.src:void 0;E.initializeWebAssemblyInstance=_asyncToGenerator(function*(){if(b()){if(y)return;if(f)throw new Error("multiple calls to 'initWasm()' detected.");if(w)throw new Error("previous call to 'initWasm()' failed.");return f=!0,void 0===S.env.wasm.wasmPaths&&ae&&0!==ae.indexOf("blob:")&&(S.env.wasm.wasmPaths=ae.substr(0,+ae.lastIndexOf("/")+1)),new Promise((J,ne)=>{h?.terminate(),h=P(8050).Z(),h.onmessage=te,l=[J,ne],h.postMessage({type:"init-wasm",in:S.env.wasm})})}return(0,v.initializeWebAssembly)(S.env.wasm)}),E.initializeRuntime=function(){var J=_asyncToGenerator(function*(ne){if(b())return H(),new Promise((X,K)=>{d=[X,K],h.postMessage({type:"init-ort",in:ne})});yield C.initRuntime(ne)});return function(ne){return J.apply(this,arguments)}}(),E.createSessionAllocate=function(){var J=_asyncToGenerator(function*(ne){return b()?(H(),new Promise((X,K)=>{D.push([X,K]),h.postMessage({type:"create_allocate",in:{model:ne}},[ne.buffer])})):C.createSessionAllocate(ne)});return function(ne){return J.apply(this,arguments)}}(),E.createSessionFinalize=function(){var J=_asyncToGenerator(function*(ne,X){return b()?(H(),new Promise((K,ve)=>{M.push([K,ve]),h.postMessage({type:"create_finalize",in:{modeldata:ne,options:X}})})):C.createSessionFinalize(ne,X)});return function(ne,X){return J.apply(this,arguments)}}(),E.createSession=function(){var J=_asyncToGenerator(function*(ne,X){return b()?(H(),new Promise((K,ve)=>{$.push([K,ve]),h.postMessage({type:"create",in:{model:ne,options:X}},[ne.buffer])})):C.createSession(ne,X)});return function(ne,X){return J.apply(this,arguments)}}(),E.releaseSession=function(){var J=_asyncToGenerator(function*(ne){if(b())return H(),new Promise((X,K)=>{B.push([X,K]),h.postMessage({type:"release",in:ne})});C.releaseSession(ne)});return function(ne){return J.apply(this,arguments)}}(),E.run=function(){var J=_asyncToGenerator(function*(ne,X,K,ve,q){return b()?(H(),new Promise((re,le)=>{z.push([re,le]),h.postMessage({type:"run",in:{sessionId:ne,inputIndices:X,inputs:K,outputIndices:ve,options:q}},C.extractTransferableBuffers(K))})):C.run(ne,X,K,ve,q)});return function(ne,X,K,ve,q){return J.apply(this,arguments)}}(),E.endProfiling=function(){var J=_asyncToGenerator(function*(ne){if(b())return H(),new Promise((X,K)=>{G.push([X,K]),h.postMessage({type:"end-profiling",in:ne})});C.endProfiling(ne)});return function(ne){return J.apply(this,arguments)}}()},7918:(me,E,P)=>{"use strict";Object.defineProperty(E,"__esModule",{value:!0}),E.setRunOptions=void 0;const F=P(263),A=P(1497);E.setRunOptions=O=>{const k=(0,F.getInstance)();let S=0;const C=[],v=O||{};try{if(void 0===O?.logSeverityLevel)v.logSeverityLevel=2;else if("number"!=typeof O.logSeverityLevel||!Number.isInteger(O.logSeverityLevel)||O.logSeverityLevel<0||O.logSeverityLevel>4)throw new Error(`log serverity level is not valid: ${O.logSeverityLevel}`);if(void 0===O?.logVerbosityLevel)v.logVerbosityLevel=0;else if("number"!=typeof O.logVerbosityLevel||!Number.isInteger(O.logVerbosityLevel))throw new Error(`log verbosity level is not valid: ${O.logVerbosityLevel}`);void 0===O?.terminate&&(v.terminate=!1);let b=0;return void 0!==O?.tag&&(b=(0,A.allocWasmString)(O.tag,C)),S=k._OrtCreateRunOptions(v.logSeverityLevel,v.logVerbosityLevel,!!v.terminate,b),0===S&&(0,A.checkLastError)("Can't create run options."),void 0!==O?.extra&&(0,A.iterateExtraOptions)(O.extra,"",new WeakSet,(h,l)=>{const d=(0,A.allocWasmString)(h,C),f=(0,A.allocWasmString)(l,C);0!==k._OrtAddRunConfigEntry(S,d,f)&&(0,A.checkLastError)(`Can't set a run config entry: ${h} - ${l}.`)}),[S,C]}catch(b){throw 0!==S&&k._OrtReleaseRunOptions(S),C.forEach(h=>k._free(h)),b}}},6640:(me,E,P)=>{"use strict";Object.defineProperty(E,"__esModule",{value:!0}),E.OnnxruntimeWebAssemblySessionHandler=void 0;const F=P(2806),A=P(2235),O=P(2850),k=P(9544);let S;E.OnnxruntimeWebAssemblySessionHandler=class{createSessionAllocate(C){return _asyncToGenerator(function*(){const v=yield fetch(C);if(200!==v.status)throw new Error(`failed to load model: ${C}`);const b=yield v.arrayBuffer();return(0,k.createSessionAllocate)(new Uint8Array(b))})()}loadModel(C,v){var b=this;return _asyncToGenerator(function*(){if(S||(yield(0,k.initializeRuntime)(A.env),S=!0),"string"==typeof C)if(typeof process<"u"&&process.versions&&process.versions.node){const h=yield(0,O.promisify)(F.readFile)(C);[b.sessionId,b.inputNames,b.outputNames]=yield(0,k.createSession)(h,v)}else{const h=yield b.createSessionAllocate(C);[b.sessionId,b.inputNames,b.outputNames]=yield(0,k.createSessionFinalize)(h,v)}else[b.sessionId,b.inputNames,b.outputNames]=yield(0,k.createSession)(C,v)})()}dispose(){var C=this;return _asyncToGenerator(function*(){return(0,k.releaseSession)(C.sessionId)})()}run(C,v,b){var h=this;return _asyncToGenerator(function*(){const l=[],d=[];Object.entries(C).forEach(D=>{const M=D[0],$=D[1],B=h.inputNames.indexOf(M);if(-1===B)throw new Error(`invalid input '${M}'`);l.push($),d.push(B)});const f=[];Object.entries(v).forEach(D=>{const M=D[0],$=h.outputNames.indexOf(M);if(-1===$)throw new Error(`invalid output '${M}'`);f.push($)});const y=yield(0,k.run)(h.sessionId,d,l.map(D=>[D.type,D.dims,D.data]),f,b),w={};for(let D=0;D<y.length;D++)w[h.outputNames[f[D]]]=new A.Tensor(y[D][0],y[D][2],y[D][1]);return w})()}startProfiling(){}endProfiling(){(0,k.endProfiling)(this.sessionId)}}},7622:(me,E,P)=>{"use strict";Object.defineProperty(E,"__esModule",{value:!0}),E.setSessionOptions=void 0;const F=P(263),A=P(1497);E.setSessionOptions=O=>{var k,S,C,v;const b=(0,F.getInstance)();let h=0;const l=[],d=O||{};(f=>{f.extra||(f.extra={}),f.extra.session||(f.extra.session={});const y=f.extra.session;y.use_ort_model_bytes_directly||(y.use_ort_model_bytes_directly="1"),f.executionProviders&&f.executionProviders.some(w=>"webgpu"===("string"==typeof w?w:w.name))&&(f.enableMemPattern=!1)})(d);try{const f=(B=>{switch(B){case"disabled":return 0;case"basic":return 1;case"extended":return 2;case"all":return 99;default:throw new Error(`unsupported graph optimization level: ${B}`)}})(null!==(k=d.graphOptimizationLevel)&&void 0!==k?k:"all"),y=(B=>{switch(B){case"sequential":return 0;case"parallel":return 1;default:throw new Error(`unsupported execution mode: ${B}`)}})(null!==(S=d.executionMode)&&void 0!==S?S:"sequential"),w="string"==typeof d.logId?(0,A.allocWasmString)(d.logId,l):0,D=null!==(C=d.logSeverityLevel)&&void 0!==C?C:2;if(!Number.isInteger(D)||D<0||D>4)throw new Error(`log serverity level is not valid: ${D}`);const M=null!==(v=d.logVerbosityLevel)&&void 0!==v?v:0;if(!Number.isInteger(M)||M<0||M>4)throw new Error(`log verbosity level is not valid: ${M}`);const $="string"==typeof d.optimizedModelFilePath?(0,A.allocWasmString)(d.optimizedModelFilePath,l):0;return h=b._OrtCreateSessionOptions(f,!!d.enableCpuMemArena,!!d.enableMemPattern,y,!!d.enableProfiling,0,w,D,M,$),0===h&&(0,A.checkLastError)("Can't create session options."),d.executionProviders&&((B,z,G)=>{for(const H of z){let te="string"==typeof H?H:H.name;switch(te){case"xnnpack":te="XNNPACK";break;case"webnn":if(te="WEBNN","string"!=typeof H){const J=H;if(J?.deviceType){const ne=(0,A.allocWasmString)("deviceType",G),X=(0,A.allocWasmString)(J.deviceType,G);0!==(0,F.getInstance)()._OrtAddSessionConfigEntry(B,ne,X)&&(0,A.checkLastError)(`Can't set a session config entry: 'deviceType' - ${J.deviceType}.`)}if(J?.powerPreference){const ne=(0,A.allocWasmString)("powerPreference",G),X=(0,A.allocWasmString)(J.powerPreference,G);0!==(0,F.getInstance)()._OrtAddSessionConfigEntry(B,ne,X)&&(0,A.checkLastError)(`Can't set a session config entry: 'powerPreference' - ${J.powerPreference}.`)}}break;case"webgpu":te="JS";break;case"wasm":case"cpu":continue;default:throw new Error(`not supported execution provider: ${te}`)}const ae=(0,A.allocWasmString)(te,G);0!==(0,F.getInstance)()._OrtAppendExecutionProvider(B,ae)&&(0,A.checkLastError)(`Can't append execution provider: ${te}.`)}})(h,d.executionProviders,l),void 0!==d.extra&&(0,A.iterateExtraOptions)(d.extra,"",new WeakSet,(B,z)=>{const G=(0,A.allocWasmString)(B,l),H=(0,A.allocWasmString)(z,l);0!==b._OrtAddSessionConfigEntry(h,G,H)&&(0,A.checkLastError)(`Can't set a session config entry: ${B} - ${z}.`)}),[h,l]}catch(f){throw 0!==h&&b._OrtReleaseSessionOptions(h),l.forEach(y=>b._free(y)),f}}},7917:(me,E)=>{"use strict";Object.defineProperty(E,"__esModule",{value:!0}),E.logLevelStringToEnum=E.tensorTypeToTypedArrayConstructor=E.getTensorElementSize=E.tensorDataTypeEnumToString=E.tensorDataTypeStringToEnum=void 0,E.tensorDataTypeStringToEnum=P=>{switch(P){case"int8":return 3;case"uint8":return 2;case"bool":return 9;case"int16":return 5;case"uint16":return 4;case"int32":return 6;case"uint32":return 12;case"float16":return 10;case"float32":return 1;case"float64":return 11;case"string":return 8;case"int64":return 7;case"uint64":return 13;default:throw new Error(`unsupported data type: ${P}`)}},E.tensorDataTypeEnumToString=P=>{switch(P){case 3:return"int8";case 2:return"uint8";case 9:return"bool";case 5:return"int16";case 4:return"uint16";case 6:return"int32";case 12:return"uint32";case 10:return"float16";case 1:return"float32";case 11:return"float64";case 8:return"string";case 7:return"int64";case 13:return"uint64";default:throw new Error(`unsupported data type: ${P}`)}},E.getTensorElementSize=P=>[void 0,4,1,1,2,2,4,8,void 0,1,2,8,4,8,void 0,void 0,void 0][P],E.tensorTypeToTypedArrayConstructor=P=>{switch(P){case"float16":case"uint16":return Uint16Array;case"float32":return Float32Array;case"uint8":case"bool":return Uint8Array;case"int8":return Int8Array;case"int16":return Int16Array;case"int32":return Int32Array;case"float64":return Float64Array;case"uint32":return Uint32Array;case"int64":return BigInt64Array;case"uint64":return BigUint64Array;default:throw new Error(`unsupported type: ${P}`)}},E.logLevelStringToEnum=P=>{switch(P){case"verbose":return 0;case"info":return 1;case"warning":return 2;case"error":return 3;case"fatal":return 4;default:throw new Error(`unsupported logging level: ${P}`)}}},1259:(me,E,P)=>{"use strict";Object.defineProperty(E,"__esModule",{value:!0}),E.extractTransferableBuffers=E.endProfiling=E.run=E.releaseSession=E.createSession=E.createSessionFinalize=E.createSessionAllocate=E.initRuntime=void 0;const F=P(7918),A=P(7622),O=P(7917),k=P(263),S=P(1497);E.initRuntime=function(){var v=_asyncToGenerator(function*(b){var h,l;h=b.wasm.numThreads,l=(0,O.logLevelStringToEnum)(b.logLevel),0!==(0,k.getInstance)()._OrtInit(h,l)&&(0,S.checkLastError)("Can't initialize onnxruntime.")});return function(b){return v.apply(this,arguments)}}();const C=new Map;E.createSessionAllocate=v=>{const b=(0,k.getInstance)(),h=b._malloc(v.byteLength);if(0===h)throw new Error(`Can't create a session. failed to allocate a buffer of size ${v.byteLength}.`);return b.HEAPU8.set(v,h),[h,v.byteLength]},E.createSessionFinalize=(v,b)=>{const h=(0,k.getInstance)();let l=0,d=0,f=[];const y=[],w=[];try{[d,f]=(0,A.setSessionOptions)(b),l=h._OrtCreateSession(v[0],v[1],d),0===l&&(0,S.checkLastError)("Can't create a session.");const[D,M]=(z=>{const G=(0,k.getInstance)(),H=G.stackSave();try{const te=G.stackAlloc(8);return 0!==G._OrtGetInputOutputCount(z,te,te+4)&&(0,S.checkLastError)("Can't get session input/output count."),[G.HEAP32[te/4],G.HEAP32[te/4+1]]}finally{G.stackRestore(H)}})(l),$=[],B=[];for(let z=0;z<D;z++){const G=h._OrtGetInputName(l,z);0===G&&(0,S.checkLastError)("Can't get an input name."),y.push(G),$.push(h.UTF8ToString(G))}for(let z=0;z<M;z++){const G=h._OrtGetOutputName(l,z);0===G&&(0,S.checkLastError)("Can't get an output name."),w.push(G),B.push(h.UTF8ToString(G))}return C.set(l,[l,y,w]),[l,$,B]}catch(D){throw y.forEach(M=>h._OrtFree(M)),w.forEach(M=>h._OrtFree(M)),0!==l&&h._OrtReleaseSession(l),D}finally{h._free(v[0]),0!==d&&h._OrtReleaseSessionOptions(d),f.forEach(D=>h._free(D))}},E.createSession=(v,b)=>{const h=(0,E.createSessionAllocate)(v);return(0,E.createSessionFinalize)(h,b)},E.releaseSession=v=>{const b=(0,k.getInstance)(),h=C.get(v);if(!h)throw new Error(`cannot release session. invalid session id: ${v}`);const[l,d,f]=h;d.forEach(y=>b._OrtFree(y)),f.forEach(y=>b._OrtFree(y)),b._OrtReleaseSession(l),C.delete(v)},E.run=function(){var v=_asyncToGenerator(function*(b,h,l,d,f){const y=(0,k.getInstance)(),w=C.get(b);if(!w)throw new Error(`cannot run inference. invalid session id: ${b}`);const[D,M,$]=w,B=h.length,z=d.length;let G=0,H=[];const te=[],ae=[];try{[G,H]=(0,F.setRunOptions)(f);for(let q=0;q<B;q++){const re=l[q][0],le=l[q][1],He=l[q][2];let Le,ot;if(Array.isArray(He)){ot=4*He.length,Le=y._malloc(ot),ae.push(Le);let yt=Le/4;for(let wt=0;wt<He.length;wt++){if("string"!=typeof He[wt])throw new TypeError(`tensor data at index ${wt} is not a string`);y.HEAPU32[yt++]=(0,S.allocWasmString)(He[wt],ae)}}else ot=He.byteLength,Le=y._malloc(ot),ae.push(Le),y.HEAPU8.set(new Uint8Array(He.buffer,He.byteOffset,ot),Le);const nt=y.stackSave(),it=y.stackAlloc(4*le.length);try{let yt=it/4;le.forEach(Pt=>y.HEAP32[yt++]=Pt);const wt=y._OrtCreateTensor((0,O.tensorDataTypeStringToEnum)(re),Le,ot,it,le.length);0===wt&&(0,S.checkLastError)(`Can't create tensor for input[${q}].`),te.push(wt)}finally{y.stackRestore(nt)}}const J=y.stackSave(),ne=y.stackAlloc(4*B),X=y.stackAlloc(4*B),K=y.stackAlloc(4*z),ve=y.stackAlloc(4*z);try{let q=ne/4,re=X/4,le=K/4,He=ve/4;for(let it=0;it<B;it++)y.HEAPU32[q++]=te[it],y.HEAPU32[re++]=M[h[it]];for(let it=0;it<z;it++)y.HEAPU32[le++]=0,y.HEAPU32[He++]=$[d[it]];let Le=y._OrtRun(D,X,ne,B,ve,z,K,G);const ot=y.jsepRunPromise;ot&&void 0!==ot.then&&(Le=yield ot);const nt=[];0!==Le&&(0,S.checkLastError)("failed to call OrtRun().");for(let it=0;it<z;it++){const yt=y.HEAPU32[K/4+it],wt=y.stackSave(),Pt=y.stackAlloc(16);let pn,Cn=0;try{Le=y._OrtGetTensorData(yt,Pt,Pt+4,Pt+8,Pt+12),0!==Le&&(0,S.checkLastError)(`Can't access output tensor data on index ${it}.`);let ur=Pt/4;const Ir=y.HEAPU32[ur++];Cn=y.HEAPU32[ur++];const Ri=y.HEAPU32[ur++],Ko=y.HEAPU32[ur++],jr=[];for(let kn=0;kn<Ko;kn++)jr.push(y.HEAPU32[Ri/4+kn]);y._OrtFree(Ri);const Xo=0===jr.length?1:jr.reduce((kn,Mi)=>kn*Mi);if(pn=(0,O.tensorDataTypeEnumToString)(Ir),"string"===pn){const kn=[];let Mi=Cn/4;for(let Lr=0;Lr<Xo;Lr++){const Gr=y.HEAPU32[Mi++];kn.push(y.UTF8ToString(Gr,Lr===Xo-1?void 0:y.HEAPU32[Mi]-Gr))}nt.push([pn,jr,kn])}else{const kn=new((0,O.tensorTypeToTypedArrayConstructor)(pn))(Xo);new Uint8Array(kn.buffer,kn.byteOffset,kn.byteLength).set(y.HEAPU8.subarray(Cn,Cn+kn.byteLength)),nt.push([pn,jr,kn])}}finally{y.stackRestore(wt),"string"===pn&&Cn&&y._free(Cn),y._OrtReleaseTensor(yt)}}return nt}finally{y.stackRestore(J)}}finally{te.forEach(J=>y._OrtReleaseTensor(J)),ae.forEach(J=>y._free(J)),0!==G&&y._OrtReleaseRunOptions(G),H.forEach(J=>y._free(J))}});return function(b,h,l,d,f){return v.apply(this,arguments)}}(),E.endProfiling=v=>{const b=(0,k.getInstance)(),h=C.get(v);if(!h)throw new Error("invalid session id");const d=b._OrtEndProfiling(h[0]);0===d&&(0,S.checkLastError)("Can't get an profile file name."),b._OrtFree(d)},E.extractTransferableBuffers=v=>{const b=[];for(const h of v){const l=h[2];!Array.isArray(l)&&l.buffer&&b.push(l.buffer)}return b}},263:function(me,E,P){"use strict";var F=this&&this.__createBinding||(Object.create?function(d,f,y,w){void 0===w&&(w=y);var D=Object.getOwnPropertyDescriptor(f,y);D&&!("get"in D?!f.__esModule:D.writable||D.configurable)||(D={enumerable:!0,get:function(){return f[y]}}),Object.defineProperty(d,w,D)}:function(d,f,y,w){void 0===w&&(w=y),d[w]=f[y]}),A=this&&this.__setModuleDefault||(Object.create?function(d,f){Object.defineProperty(d,"default",{enumerable:!0,value:f})}:function(d,f){d.default=f}),O=this&&this.__importStar||function(d){if(d&&d.__esModule)return d;var f={};if(null!=d)for(var y in d)"default"!==y&&Object.prototype.hasOwnProperty.call(d,y)&&F(f,d,y);return A(f,d),f};Object.defineProperty(E,"__esModule",{value:!0}),E.dispose=E.getInstance=E.initializeWebAssembly=void 0;const k=O(P(6449)),S=P(932),C=P(3474);let v,b=!1,h=!1,l=!1;E.initializeWebAssembly=function(){var d=_asyncToGenerator(function*(f){if(b)return Promise.resolve();if(h)throw new Error("multiple calls to 'initializeWebAssembly()' detected.");if(l)throw new Error("previous call to 'initializeWebAssembly()' failed.");h=!0;const y=f.initTimeout,D=f.simd,M=f.numThreads>1&&(()=>{try{return typeof SharedArrayBuffer<"u"&&(typeof MessageChannel<"u"&&(new MessageChannel).port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11])))}catch{return!1}})(),$=D&&(()=>{try{return WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,30,1,28,0,65,0,253,15,253,12,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,253,186,1,26,11]))}catch{return!1}})(),B=f.wasmPaths,z="string"==typeof B?B:void 0,G=(J=$,M?J?"ort-wasm-simd-threaded.wasm":"ort-wasm-threaded.wasm":J?"ort-wasm-simd.wasm":"ort-wasm.wasm"),H="object"==typeof B?B[G]:void 0;var J;let te=!1;const ae=[];if(y>0&&ae.push(new Promise(J=>{setTimeout(()=>{te=!0,J()},y)})),ae.push(new Promise((J,ne)=>{const X=M?C:S,K={locateFile:(ve,q)=>M&&ve.endsWith(".worker.js")&&typeof Blob<"u"?URL.createObjectURL(new Blob([P(4154)],{type:"text/javascript"})):ve.endsWith(".wasm")?H||(z??q)+G:q+ve};if(M)if(typeof Blob>"u")K.mainScriptUrlOrBlob=k.join(__dirname,"ort-wasm-threaded.js");else{const ve=`var ortWasmThreaded=(function(){var _scriptDir;return ${X.toString()}})();`;K.mainScriptUrlOrBlob=new Blob([ve],{type:"text/javascript"})}X(K).then(ve=>{h=!1,b=!0,v=ve,J()},ve=>{h=!1,l=!0,ne(ve)})})),yield Promise.race(ae),te)throw new Error(`WebAssembly backend initializing failed due to timeout: ${y}ms`)});return function(f){return d.apply(this,arguments)}}(),E.getInstance=()=>{if(b&&v)return v;throw new Error("WebAssembly is not initialized yet.")},E.dispose=()=>{var d;!b||h||l||(h=!0,null===(d=v.PThread)||void 0===d||d.terminateAllThreads(),v=void 0,h=!1,b=!1,l=!0)}},1497:(me,E,P)=>{"use strict";Object.defineProperty(E,"__esModule",{value:!0}),E.checkLastError=E.iterateExtraOptions=E.allocWasmString=void 0;const F=P(263);E.allocWasmString=(A,O)=>{const k=(0,F.getInstance)(),S=k.lengthBytesUTF8(A)+1,C=k._malloc(S);return k.stringToUTF8(A,C,S),O.push(C),C},E.iterateExtraOptions=(A,O,k,S)=>{if("object"==typeof A&&null!==A){if(k.has(A))throw new Error("Circular reference in options");k.add(A)}Object.entries(A).forEach(([C,v])=>{const b=O?O+C:C;if("object"==typeof v)(0,E.iterateExtraOptions)(v,b+".",k,S);else if("string"==typeof v||"number"==typeof v)S(b,v.toString());else{if("boolean"!=typeof v)throw new Error("Can't handle extra config type: "+typeof v);S(b,v?"1":"0")}})},E.checkLastError=A=>{const O=(0,F.getInstance)(),k=O.stackSave();try{const S=O.stackAlloc(8);O._OrtGetLastError(S,S+4);const C=O.HEAP32[S/4],v=O.HEAPU32[S/4+1],b=v?O.UTF8ToString(v):"";throw new Error(`${A} ERROR_CODE: ${C}, ERROR_MESSAGE: ${b}`)}finally{O.stackRestore(k)}}},8050:(me,E,P)=>{"use strict";P.d(E,{Z:()=>O});var F=P(6614),A=P.n(F);function O(){return A()('/*!\n* ONNX Runtime Web v1.16.3\n* Copyright (c) Microsoft Corporation. All rights reserved.\n* Licensed under the MIT License.\n*/\n(()=>{var e={918:(e,t,r)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.setRunOptions=void 0;const n=r(263),a=r(497);t.setRunOptions=e=>{const t=(0,n.getInstance)();let r=0;const o=[],i=e||{};try{if(void 0===(null==e?void 0:e.logSeverityLevel))i.logSeverityLevel=2;else if("number"!=typeof e.logSeverityLevel||!Number.isInteger(e.logSeverityLevel)||e.logSeverityLevel<0||e.logSeverityLevel>4)throw new Error(`log serverity level is not valid: ${e.logSeverityLevel}`);if(void 0===(null==e?void 0:e.logVerbosityLevel))i.logVerbosityLevel=0;else if("number"!=typeof e.logVerbosityLevel||!Number.isInteger(e.logVerbosityLevel))throw new Error(`log verbosity level is not valid: ${e.logVerbosityLevel}`);void 0===(null==e?void 0:e.terminate)&&(i.terminate=!1);let n=0;return void 0!==(null==e?void 0:e.tag)&&(n=(0,a.allocWasmString)(e.tag,o)),r=t._OrtCreateRunOptions(i.logSeverityLevel,i.logVerbosityLevel,!!i.terminate,n),0===r&&(0,a.checkLastError)("Can\'t create run options."),void 0!==(null==e?void 0:e.extra)&&(0,a.iterateExtraOptions)(e.extra,"",new WeakSet,((e,n)=>{const i=(0,a.allocWasmString)(e,o),s=(0,a.allocWasmString)(n,o);0!==t._OrtAddRunConfigEntry(r,i,s)&&(0,a.checkLastError)(`Can\'t set a run config entry: ${e} - ${n}.`)})),[r,o]}catch(e){throw 0!==r&&t._OrtReleaseRunOptions(r),o.forEach((e=>t._free(e))),e}}},622:(e,t,r)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.setSessionOptions=void 0;const n=r(263),a=r(497);t.setSessionOptions=e=>{var t,r,o,i;const s=(0,n.getInstance)();let u=0;const c=[],l=e||{};(e=>{e.extra||(e.extra={}),e.extra.session||(e.extra.session={});const t=e.extra.session;t.use_ort_model_bytes_directly||(t.use_ort_model_bytes_directly="1"),e.executionProviders&&e.executionProviders.some((e=>"webgpu"===("string"==typeof e?e:e.name)))&&(e.enableMemPattern=!1)})(l);try{const e=(e=>{switch(e){case"disabled":return 0;case"basic":return 1;case"extended":return 2;case"all":return 99;default:throw new Error(`unsupported graph optimization level: ${e}`)}})(null!==(t=l.graphOptimizationLevel)&&void 0!==t?t:"all"),f=(e=>{switch(e){case"sequential":return 0;case"parallel":return 1;default:throw new Error(`unsupported execution mode: ${e}`)}})(null!==(r=l.executionMode)&&void 0!==r?r:"sequential"),d="string"==typeof l.logId?(0,a.allocWasmString)(l.logId,c):0,p=null!==(o=l.logSeverityLevel)&&void 0!==o?o:2;if(!Number.isInteger(p)||p<0||p>4)throw new Error(`log serverity level is not valid: ${p}`);const g=null!==(i=l.logVerbosityLevel)&&void 0!==i?i:0;if(!Number.isInteger(g)||g<0||g>4)throw new Error(`log verbosity level is not valid: ${g}`);const h="string"==typeof l.optimizedModelFilePath?(0,a.allocWasmString)(l.optimizedModelFilePath,c):0;return u=s._OrtCreateSessionOptions(e,!!l.enableCpuMemArena,!!l.enableMemPattern,f,!!l.enableProfiling,0,d,p,g,h),0===u&&(0,a.checkLastError)("Can\'t create session options."),l.executionProviders&&((e,t,r)=>{for(const o of t){let t="string"==typeof o?o:o.name;switch(t){case"xnnpack":t="XNNPACK";break;case"webnn":if(t="WEBNN","string"!=typeof o){const t=o;if(null==t?void 0:t.deviceType){const o=(0,a.allocWasmString)("deviceType",r),i=(0,a.allocWasmString)(t.deviceType,r);0!==(0,n.getInstance)()._OrtAddSessionConfigEntry(e,o,i)&&(0,a.checkLastError)(`Can\'t set a session config entry: \'deviceType\' - ${t.deviceType}.`)}if(null==t?void 0:t.powerPreference){const o=(0,a.allocWasmString)("powerPreference",r),i=(0,a.allocWasmString)(t.powerPreference,r);0!==(0,n.getInstance)()._OrtAddSessionConfigEntry(e,o,i)&&(0,a.checkLastError)(`Can\'t set a session config entry: \'powerPreference\' - ${t.powerPreference}.`)}}break;case"webgpu":t="JS";break;case"wasm":case"cpu":continue;default:throw new Error(`not supported execution provider: ${t}`)}const i=(0,a.allocWasmString)(t,r);0!==(0,n.getInstance)()._OrtAppendExecutionProvider(e,i)&&(0,a.checkLastError)(`Can\'t append execution provider: ${t}.`)}})(u,l.executionProviders,c),void 0!==l.extra&&(0,a.iterateExtraOptions)(l.extra,"",new WeakSet,((e,t)=>{const r=(0,a.allocWasmString)(e,c),n=(0,a.allocWasmString)(t,c);0!==s._OrtAddSessionConfigEntry(u,r,n)&&(0,a.checkLastError)(`Can\'t set a session config entry: ${e} - ${t}.`)})),[u,c]}catch(e){throw 0!==u&&s._OrtReleaseSessionOptions(u),c.forEach((e=>s._free(e))),e}}},917:(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.logLevelStringToEnum=t.tensorTypeToTypedArrayConstructor=t.getTensorElementSize=t.tensorDataTypeEnumToString=t.tensorDataTypeStringToEnum=void 0,t.tensorDataTypeStringToEnum=e=>{switch(e){case"int8":return 3;case"uint8":return 2;case"bool":return 9;case"int16":return 5;case"uint16":return 4;case"int32":return 6;case"uint32":return 12;case"float16":return 10;case"float32":return 1;case"float64":return 11;case"string":return 8;case"int64":return 7;case"uint64":return 13;default:throw new Error(`unsupported data type: ${e}`)}},t.tensorDataTypeEnumToString=e=>{switch(e){case 3:return"int8";case 2:return"uint8";case 9:return"bool";case 5:return"int16";case 4:return"uint16";case 6:return"int32";case 12:return"uint32";case 10:return"float16";case 1:return"float32";case 11:return"float64";case 8:return"string";case 7:return"int64";case 13:return"uint64";default:throw new Error(`unsupported data type: ${e}`)}},t.getTensorElementSize=e=>[void 0,4,1,1,2,2,4,8,void 0,1,2,8,4,8,void 0,void 0,void 0][e],t.tensorTypeToTypedArrayConstructor=e=>{switch(e){case"float16":case"uint16":return Uint16Array;case"float32":return Float32Array;case"uint8":case"bool":return Uint8Array;case"int8":return Int8Array;case"int16":return Int16Array;case"int32":return Int32Array;case"float64":return Float64Array;case"uint32":return Uint32Array;case"int64":return BigInt64Array;case"uint64":return BigUint64Array;default:throw new Error(`unsupported type: ${e}`)}},t.logLevelStringToEnum=e=>{switch(e){case"verbose":return 0;case"info":return 1;case"warning":return 2;case"error":return 3;case"fatal":return 4;default:throw new Error(`unsupported logging level: ${e}`)}}},259:(e,t,r)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.extractTransferableBuffers=t.endProfiling=t.run=t.releaseSession=t.createSession=t.createSessionFinalize=t.createSessionAllocate=t.initRuntime=void 0;const n=r(918),a=r(622),o=r(917),i=r(263),s=r(497);t.initRuntime=async e=>{var t,r;t=e.wasm.numThreads,r=(0,o.logLevelStringToEnum)(e.logLevel),0!==(0,i.getInstance)()._OrtInit(t,r)&&(0,s.checkLastError)("Can\'t initialize onnxruntime.")};const u=new Map;t.createSessionAllocate=e=>{const t=(0,i.getInstance)(),r=t._malloc(e.byteLength);if(0===r)throw new Error(`Can\'t create a session. failed to allocate a buffer of size ${e.byteLength}.`);return t.HEAPU8.set(e,r),[r,e.byteLength]},t.createSessionFinalize=(e,t)=>{const r=(0,i.getInstance)();let n=0,o=0,c=[];const l=[],f=[];try{[o,c]=(0,a.setSessionOptions)(t),n=r._OrtCreateSession(e[0],e[1],o),0===n&&(0,s.checkLastError)("Can\'t create a session.");const[d,p]=(e=>{const t=(0,i.getInstance)(),r=t.stackSave();try{const r=t.stackAlloc(8);return 0!==t._OrtGetInputOutputCount(e,r,r+4)&&(0,s.checkLastError)("Can\'t get session input/output count."),[t.HEAP32[r/4],t.HEAP32[r/4+1]]}finally{t.stackRestore(r)}})(n),g=[],h=[];for(let e=0;e<d;e++){const t=r._OrtGetInputName(n,e);0===t&&(0,s.checkLastError)("Can\'t get an input name."),l.push(t),g.push(r.UTF8ToString(t))}for(let e=0;e<p;e++){const t=r._OrtGetOutputName(n,e);0===t&&(0,s.checkLastError)("Can\'t get an output name."),f.push(t),h.push(r.UTF8ToString(t))}return u.set(n,[n,l,f]),[n,g,h]}catch(e){throw l.forEach((e=>r._OrtFree(e))),f.forEach((e=>r._OrtFree(e))),0!==n&&r._OrtReleaseSession(n),e}finally{r._free(e[0]),0!==o&&r._OrtReleaseSessionOptions(o),c.forEach((e=>r._free(e)))}},t.createSession=(e,r)=>{const n=(0,t.createSessionAllocate)(e);return(0,t.createSessionFinalize)(n,r)},t.releaseSession=e=>{const t=(0,i.getInstance)(),r=u.get(e);if(!r)throw new Error(`cannot release session. invalid session id: ${e}`);const[n,a,o]=r;a.forEach((e=>t._OrtFree(e))),o.forEach((e=>t._OrtFree(e))),t._OrtReleaseSession(n),u.delete(e)},t.run=async(e,t,r,a,c)=>{const l=(0,i.getInstance)(),f=u.get(e);if(!f)throw new Error(`cannot run inference. invalid session id: ${e}`);const[d,p,g]=f,h=t.length,m=a.length;let y=0,v=[];const b=[],w=[];try{[y,v]=(0,n.setRunOptions)(c);for(let e=0;e<h;e++){const t=r[e][0],n=r[e][1],a=r[e][2];let i,u;if(Array.isArray(a)){u=4*a.length,i=l._malloc(u),w.push(i);let e=i/4;for(let t=0;t<a.length;t++){if("string"!=typeof a[t])throw new TypeError(`tensor data at index ${t} is not a string`);l.HEAPU32[e++]=(0,s.allocWasmString)(a[t],w)}}else u=a.byteLength,i=l._malloc(u),w.push(i),l.HEAPU8.set(new Uint8Array(a.buffer,a.byteOffset,u),i);const c=l.stackSave(),f=l.stackAlloc(4*n.length);try{let r=f/4;n.forEach((e=>l.HEAP32[r++]=e));const a=l._OrtCreateTensor((0,o.tensorDataTypeStringToEnum)(t),i,u,f,n.length);0===a&&(0,s.checkLastError)(`Can\'t create tensor for input[${e}].`),b.push(a)}finally{l.stackRestore(c)}}const e=l.stackSave(),i=l.stackAlloc(4*h),u=l.stackAlloc(4*h),f=l.stackAlloc(4*m),_=l.stackAlloc(4*m);try{let e=i/4,r=u/4,n=f/4,c=_/4;for(let n=0;n<h;n++)l.HEAPU32[e++]=b[n],l.HEAPU32[r++]=p[t[n]];for(let e=0;e<m;e++)l.HEAPU32[n++]=0,l.HEAPU32[c++]=g[a[e]];let v=l._OrtRun(d,u,i,h,_,m,f,y);const w=l.jsepRunPromise;w&&void 0!==w.then&&(v=await w);const O=[];0!==v&&(0,s.checkLastError)("failed to call OrtRun().");for(let e=0;e<m;e++){const t=l.HEAPU32[f/4+e],r=l.stackSave(),n=l.stackAlloc(16);let a,i=0;try{v=l._OrtGetTensorData(t,n,n+4,n+8,n+12),0!==v&&(0,s.checkLastError)(`Can\'t access output tensor data on index ${e}.`);let r=n/4;const u=l.HEAPU32[r++];i=l.HEAPU32[r++];const c=l.HEAPU32[r++],f=l.HEAPU32[r++],d=[];for(let e=0;e<f;e++)d.push(l.HEAPU32[c/4+e]);l._OrtFree(c);const p=0===d.length?1:d.reduce(((e,t)=>e*t));if(a=(0,o.tensorDataTypeEnumToString)(u),"string"===a){const e=[];let t=i/4;for(let r=0;r<p;r++){const n=l.HEAPU32[t++],a=r===p-1?void 0:l.HEAPU32[t]-n;e.push(l.UTF8ToString(n,a))}O.push([a,d,e])}else{const e=new((0,o.tensorTypeToTypedArrayConstructor)(a))(p);new Uint8Array(e.buffer,e.byteOffset,e.byteLength).set(l.HEAPU8.subarray(i,i+e.byteLength)),O.push([a,d,e])}}finally{l.stackRestore(r),"string"===a&&i&&l._free(i),l._OrtReleaseTensor(t)}}return O}finally{l.stackRestore(e)}}finally{b.forEach((e=>l._OrtReleaseTensor(e))),w.forEach((e=>l._free(e))),0!==y&&l._OrtReleaseRunOptions(y),v.forEach((e=>l._free(e)))}},t.endProfiling=e=>{const t=(0,i.getInstance)(),r=u.get(e);if(!r)throw new Error("invalid session id");const n=r[0],a=t._OrtEndProfiling(n);0===a&&(0,s.checkLastError)("Can\'t get an profile file name."),t._OrtFree(a)},t.extractTransferableBuffers=e=>{const t=[];for(const r of e){const e=r[2];!Array.isArray(e)&&e.buffer&&t.push(e.buffer)}return t}},263:function(e,t,r){"use strict";var n=this&&this.__createBinding||(Object.create?function(e,t,r,n){void 0===n&&(n=r);var a=Object.getOwnPropertyDescriptor(t,r);a&&!("get"in a?!t.__esModule:a.writable||a.configurable)||(a={enumerable:!0,get:function(){return t[r]}}),Object.defineProperty(e,n,a)}:function(e,t,r,n){void 0===n&&(n=r),e[n]=t[r]}),a=this&&this.__setModuleDefault||(Object.create?function(e,t){Object.defineProperty(e,"default",{enumerable:!0,value:t})}:function(e,t){e.default=t}),o=this&&this.__importStar||function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var r in e)"default"!==r&&Object.prototype.hasOwnProperty.call(e,r)&&n(t,e,r);return a(t,e),t};Object.defineProperty(t,"__esModule",{value:!0}),t.dispose=t.getInstance=t.initializeWebAssembly=void 0;const i=o(r(449)),s=r(932),u=r(474);let c,l=!1,f=!1,d=!1;t.initializeWebAssembly=async e=>{if(l)return Promise.resolve();if(f)throw new Error("multiple calls to \'initializeWebAssembly()\' detected.");if(d)throw new Error("previous call to \'initializeWebAssembly()\' failed.");f=!0;const t=e.initTimeout,n=e.numThreads,a=e.simd,o=n>1&&(()=>{try{return"undefined"!=typeof SharedArrayBuffer&&("undefined"!=typeof MessageChannel&&(new MessageChannel).port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11])))}catch(e){return!1}})(),p=a&&(()=>{try{return WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,30,1,28,0,65,0,253,15,253,12,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,253,186,1,26,11]))}catch(e){return!1}})(),g=e.wasmPaths,h="string"==typeof g?g:void 0,m=((e,t)=>t?e?"ort-wasm-simd-threaded.wasm":"ort-wasm-threaded.wasm":e?"ort-wasm-simd.wasm":"ort-wasm.wasm")(p,o),y="object"==typeof g?g[m]:void 0;let v=!1;const b=[];if(t>0&&b.push(new Promise((e=>{setTimeout((()=>{v=!0,e()}),t)}))),b.push(new Promise(((e,t)=>{const n=o?u:s,a={locateFile:(e,t)=>o&&e.endsWith(".worker.js")&&"undefined"!=typeof Blob?URL.createObjectURL(new Blob([r(154)],{type:"text/javascript"})):e.endsWith(".wasm")?y||(null!=h?h:t)+m:t+e};if(o)if("undefined"==typeof Blob)a.mainScriptUrlOrBlob=i.join(__dirname,"ort-wasm-threaded.js");else{const e=`var ortWasmThreaded=(function(){var _scriptDir;return ${n.toString()}})();`;a.mainScriptUrlOrBlob=new Blob([e],{type:"text/javascript"})}n(a).then((t=>{f=!1,l=!0,c=t,e()}),(e=>{f=!1,d=!0,t(e)}))}))),await Promise.race(b),v)throw new Error(`WebAssembly backend initializing failed due to timeout: ${t}ms`)},t.getInstance=()=>{if(l&&c)return c;throw new Error("WebAssembly is not initialized yet.")},t.dispose=()=>{var e;!l||f||d||(f=!0,null===(e=c.PThread)||void 0===e||e.terminateAllThreads(),c=void 0,f=!1,l=!1,d=!0)}},497:(e,t,r)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.checkLastError=t.iterateExtraOptions=t.allocWasmString=void 0;const n=r(263);t.allocWasmString=(e,t)=>{const r=(0,n.getInstance)(),a=r.lengthBytesUTF8(e)+1,o=r._malloc(a);return r.stringToUTF8(e,o,a),t.push(o),o},t.iterateExtraOptions=(e,r,n,a)=>{if("object"==typeof e&&null!==e){if(n.has(e))throw new Error("Circular reference in options");n.add(e)}Object.entries(e).forEach((([e,o])=>{const i=r?r+e:e;if("object"==typeof o)(0,t.iterateExtraOptions)(o,i+".",n,a);else if("string"==typeof o||"number"==typeof o)a(i,o.toString());else{if("boolean"!=typeof o)throw new Error("Can\'t handle extra config type: "+typeof o);a(i,o?"1":"0")}}))},t.checkLastError=e=>{const t=(0,n.getInstance)(),r=t.stackSave();try{const r=t.stackAlloc(8);t._OrtGetLastError(r,r+4);const n=t.HEAP32[r/4],a=t.HEAPU32[r/4+1],o=a?t.UTF8ToString(a):"";throw new Error(`${e} ERROR_CODE: ${n}, ERROR_MESSAGE: ${o}`)}finally{t.stackRestore(r)}}},474:(e,t,r)=>{var _scriptDir,n=(_scriptDir="undefined"!=typeof document&&document.currentScript?document.currentScript.src:void 0,"undefined"!=typeof __filename&&(_scriptDir=_scriptDir||__filename),function(e={}){function t(){return k.buffer!=x.buffer&&Y(),x}function n(){return k.buffer!=x.buffer&&Y(),I}function a(){return k.buffer!=x.buffer&&Y(),U}function o(){return k.buffer!=x.buffer&&Y(),L}function i(){return k.buffer!=x.buffer&&Y(),W}var s,u,c=e;c.ready=new Promise(((e,t)=>{s=e,u=t}));var l,f,d,p=Object.assign({},c),g="./this.program",h=(e,t)=>{throw t},m="object"==typeof window,y="function"==typeof importScripts,v="object"==typeof process&&"object"==typeof process.versions&&"string"==typeof process.versions.node,b=c.ENVIRONMENT_IS_PTHREAD||!1,w="";function _(e){return c.locateFile?c.locateFile(e,w):w+e}if(v){var O=r(384),S=r(908);let t;w=y?S.dirname(w)+"/":__dirname+"/",l=(e,t)=>(e=e.startsWith("file://")?new URL(e):S.normalize(e),O.readFileSync(e,t?void 0:"utf8")),d=e=>((e=l(e,!0)).buffer||(e=new Uint8Array(e)),e),f=(e,t,r,n=!0)=>{e=e.startsWith("file://")?new URL(e):S.normalize(e),O.readFile(e,n?void 0:"utf8",((e,a)=>{e?r(e):t(n?a.buffer:a)}))},!c.thisProgram&&1<process.argv.length&&(g=process.argv[1].replace(/\\\\/g,"/")),process.argv.slice(2),h=(e,t)=>{throw process.exitCode=e,t},c.inspect=()=>"[Emscripten Module object]";try{t=r(925)}catch(e){throw console.error(\'The "worker_threads" module is not supported in this node.js build - perhaps a newer version is needed?\'),e}global.Worker=t.Worker}else(m||y)&&(y?w=self.location.href:"undefined"!=typeof document&&document.currentScript&&(w=document.currentScript.src),_scriptDir&&(w=_scriptDir),w=0!==w.indexOf("blob:")?w.substr(0,w.replace(/[?#].*/,"").lastIndexOf("/")+1):"",v||(l=e=>{var t=new XMLHttpRequest;return t.open("GET",e,!1),t.send(null),t.responseText},y&&(d=e=>{var t=new XMLHttpRequest;return t.open("GET",e,!1),t.responseType="arraybuffer",t.send(null),new Uint8Array(t.response)}),f=(e,t,r)=>{var n=new XMLHttpRequest;n.open("GET",e,!0),n.responseType="arraybuffer",n.onload=()=>{200==n.status||0==n.status&&n.response?t(n.response):r()},n.onerror=r,n.send(null)}));v&&"undefined"==typeof performance&&(global.performance=r(953).performance);var E=console.log.bind(console),A=console.error.bind(console);v&&(E=(...e)=>O.writeSync(1,e.join(" ")+"\\n"),A=(...e)=>O.writeSync(2,e.join(" ")+"\\n"));var T,M=c.print||E,R=c.printErr||A;Object.assign(c,p),p=null,c.thisProgram&&(g=c.thisProgram),c.quit&&(h=c.quit),c.wasmBinary&&(T=c.wasmBinary);var F=c.noExitRuntime||!0;"object"!=typeof WebAssembly&&te("no native wasm support detected");var k,C,P,D,x,I,U,L,W,H=!1;function Y(){var e=k.buffer;c.HEAP8=x=new Int8Array(e),c.HEAP16=new Int16Array(e),c.HEAP32=U=new Int32Array(e),c.HEAPU8=I=new Uint8Array(e),c.HEAPU16=new Uint16Array(e),c.HEAPU32=L=new Uint32Array(e),c.HEAPF32=new Float32Array(e),c.HEAPF64=W=new Float64Array(e)}var j=c.INITIAL_MEMORY||16777216;if(5242880<=j||te("INITIAL_MEMORY should be larger than STACK_SIZE, was "+j+"! (STACK_SIZE=5242880)"),b)k=c.wasmMemory;else if(c.wasmMemory)k=c.wasmMemory;else if(!((k=new WebAssembly.Memory({initial:j/65536,maximum:65536,shared:!0})).buffer instanceof SharedArrayBuffer))throw R("requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag"),v&&R("(on node you may need: --experimental-wasm-threads --experimental-wasm-bulk-memory and/or recent version)"),Error("bad memory");Y(),j=k.buffer.byteLength;var z,G=[],N=[],B=[],$=0;function q(){return F||0<$}var V,J,X=0,K=null,Z=null;function Q(){X++,c.monitorRunDependencies&&c.monitorRunDependencies(X)}function ee(){if(X--,c.monitorRunDependencies&&c.monitorRunDependencies(X),0==X&&(null!==K&&(clearInterval(K),K=null),Z)){var e=Z;Z=null,e()}}function te(e){throw c.onAbort&&c.onAbort(e),R(e="Aborted("+e+")"),H=!0,D=1,e=new WebAssembly.RuntimeError(e+". Build with -sASSERTIONS for more info."),u(e),e}function re(e){return e.startsWith("data:application/octet-stream;base64,")}function ne(e){if(e==V&&T)return new Uint8Array(T);if(d)return d(e);throw"both async and sync fetching of the wasm failed"}function ae(e,t,r){return function(e){if(!T&&(m||y)){if("function"==typeof fetch&&!e.startsWith("file://"))return fetch(e,{credentials:"same-origin"}).then((t=>{if(!t.ok)throw"failed to load wasm binary file at \'"+e+"\'";return t.arrayBuffer()})).catch((()=>ne(e)));if(f)return new Promise(((t,r)=>{f(e,(e=>t(new Uint8Array(e))),r)}))}return Promise.resolve().then((()=>ne(e)))}(e).then((e=>WebAssembly.instantiate(e,t))).then((e=>e)).then(r,(e=>{R("failed to asynchronously prepare wasm: "+e),te(e)}))}function oe(e){this.name="ExitStatus",this.message=`Program terminated with exit(${e})`,this.status=e}function ie(e){e.terminate(),e.onmessage=()=>{}}function se(e){(e=ge.Fa[e])||te(),ge.fb(e)}function ue(e){var t=ge.Za();if(!t)return 6;ge.Ia.push(t),ge.Fa[e.Ha]=t,t.Ha=e.Ha;var r={cmd:"run",start_routine:e.gb,arg:e.Ya,pthread_ptr:e.Ha};return v&&t.unref(),t.postMessage(r,e.mb),0}re(V="ort-wasm-threaded.wasm")||(V=_(V));var ce="undefined"!=typeof TextDecoder?new TextDecoder("utf8"):void 0,le=(e,t,r)=>{var n=(t>>>=0)+r;for(r=t;e[r]&&!(r>=n);)++r;if(16<r-t&&e.buffer&&ce)return ce.decode(e.buffer instanceof SharedArrayBuffer?e.slice(t,r):e.subarray(t,r));for(n="";t<r;){var a=e[t++];if(128&a){var o=63&e[t++];if(192==(224&a))n+=String.fromCharCode((31&a)<<6|o);else{var i=63&e[t++];65536>(a=224==(240&a)?(15&a)<<12|o<<6|i:(7&a)<<18|o<<12|i<<6|63&e[t++])?n+=String.fromCharCode(a):(a-=65536,n+=String.fromCharCode(55296|a>>10,56320|1023&a))}}else n+=String.fromCharCode(a)}return n},fe=(e,t)=>(e>>>=0)?le(n(),e,t):"";function de(e){if(b)return qe(1,1,e);D=e,q()||(ge.hb(),c.onExit&&c.onExit(e),H=!0),h(e,new oe(e))}var pe=e=>{if(D=e,b)throw me(e),"unwind";de(e)},ge={La:[],Ia:[],Ta:[],Fa:{},Pa:function(){b?ge.ab():ge.$a()},$a:function(){G.unshift((()=>{Q(),ge.bb((()=>ee()))}))},ab:function(){ge.receiveObjectTransfer=ge.eb,ge.threadInitTLS=ge.Sa,ge.setExitStatus=ge.Ra,F=!1},Ra:function(e){D=e},rb:["$terminateWorker"],hb:function(){for(var e of ge.Ia)ie(e);for(e of ge.La)ie(e);ge.La=[],ge.Ia=[],ge.Fa=[]},fb:function(e){var t=e.Ha;delete ge.Fa[t],ge.La.push(e),ge.Ia.splice(ge.Ia.indexOf(e),1),e.Ha=0,yt(t)},eb:function(){},Sa:function(){ge.Ta.forEach((e=>e()))},cb:e=>new Promise((t=>{e.onmessage=r=>{var n=(r=r.data).cmd;if(r.targetThread&&r.targetThread!=dt()){var a=ge.Fa[r.qb];a?a.postMessage(r,r.transferList):R(\'Internal error! Worker sent a message "\'+n+\'" to target pthread \'+r.targetThread+", but that thread no longer exists!")}else"checkMailbox"===n?He():"spawnThread"===n?ue(r):"cleanupThread"===n?se(r.thread):"killThread"===n?(r=r.thread,n=ge.Fa[r],delete ge.Fa[r],ie(n),yt(r),ge.Ia.splice(ge.Ia.indexOf(n),1),n.Ha=0):"cancelThread"===n?ge.Fa[r.thread].postMessage({cmd:"cancel"}):"loaded"===n?(e.loaded=!0,t(e)):"alert"===n?alert("Thread "+r.threadId+": "+r.text):"setimmediate"===r.target?e.postMessage(r):"callHandler"===n?c[r.handler](...r.args):n&&R("worker sent an unknown command "+n)},e.onerror=e=>{throw R("worker sent an error! "+e.filename+":"+e.lineno+": "+e.message),e},v&&(e.on("message",(function(t){e.onmessage({data:t})})),e.on("error",(function(t){e.onerror(t)})));var r,n=[];for(r of["onExit","onAbort","print","printErr"])c.hasOwnProperty(r)&&n.push(r);e.postMessage({cmd:"load",handlers:n,urlOrBlob:c.mainScriptUrlOrBlob||_scriptDir,wasmMemory:k,wasmModule:P})})),bb:function(e){e()},Xa:function(){var e=_("ort-wasm-threaded.worker.js");e=new Worker(e),ge.La.push(e)},Za:function(){return 0==ge.La.length&&(ge.Xa(),ge.cb(ge.La[0])),ge.La.pop()}};c.PThread=ge;var he=e=>{for(;0<e.length;)e.shift()(c)};function me(e){if(b)return qe(2,0,e);pe(e)}c.establishStackSpace=function(){var e=dt(),t=a()[e+52>>2>>>0];e=a()[e+56>>2>>>0],_t(t,t-e),St(t)};var ye=[];function ve(e){this.Oa=e-24,this.Wa=function(e){o()[this.Oa+4>>2>>>0]=e},this.Va=function(e){o()[this.Oa+8>>2>>>0]=e},this.Pa=function(e,t){this.Ua(),this.Wa(e),this.Va(t)},this.Ua=function(){o()[this.Oa+16>>2>>>0]=0}}function be(e,t,r,n){return b?qe(3,1,e,t,r,n):we(e,t,r,n)}function we(e,t,r,n){if(e>>>=0,t>>>=0,r>>>=0,n>>>=0,"undefined"==typeof SharedArrayBuffer)return R("Current environment does not support SharedArrayBuffer, pthreads are not available!"),6;var a=[];return b&&0===a.length?be(e,t,r,n):(e={gb:r,Ha:e,Ya:n,mb:a},b?(e.ob="spawnThread",postMessage(e,a),0):ue(e))}function _e(e,t,r){return b?qe(4,1,e,t,r):0}function Oe(e,t){if(b)return qe(5,1,e,t)}c.invokeEntryPoint=function(e,t){var r=ye[e];r||(e>=ye.length&&(ye.length=e+1),ye[e]=r=z.get(e)),e=r(t),q()?ge.Ra(e):vt(e)};var Se=e=>{for(var t=0,r=0;r<e.length;++r){var n=e.charCodeAt(r);127>=n?t++:2047>=n?t+=2:55296<=n&&57343>=n?(t+=4,++r):t+=3}return t},Ee=(e,t,r,n)=>{if(!(0<n))return 0;var a=r>>>=0;n=r+n-1;for(var o=0;o<e.length;++o){var i=e.charCodeAt(o);if(55296<=i&&57343>=i&&(i=65536+((1023&i)<<10)|1023&e.charCodeAt(++o)),127>=i){if(r>=n)break;t[r++>>>0]=i}else{if(2047>=i){if(r+1>=n)break;t[r++>>>0]=192|i>>6}else{if(65535>=i){if(r+2>=n)break;t[r++>>>0]=224|i>>12}else{if(r+3>=n)break;t[r++>>>0]=240|i>>18,t[r++>>>0]=128|i>>12&63}t[r++>>>0]=128|i>>6&63}t[r++>>>0]=128|63&i}}return t[r>>>0]=0,r-a},Ae=(e,t,r)=>Ee(e,n(),t,r);function Te(e,t){if(b)return qe(6,1,e,t)}function Me(e,t,r){if(b)return qe(7,1,e,t,r)}function Re(e,t,r){return b?qe(8,1,e,t,r):0}function Fe(e,t){if(b)return qe(9,1,e,t)}function ke(e,t,r){if(b)return qe(10,1,e,t,r)}function Ce(e,t,r,n){if(b)return qe(11,1,e,t,r,n)}function Pe(e,t,r,n){if(b)return qe(12,1,e,t,r,n)}function De(e,t,r,n){if(b)return qe(13,1,e,t,r,n)}function xe(e){if(b)return qe(14,1,e)}function Ie(e,t){if(b)return qe(15,1,e,t)}function Ue(e,t,r){if(b)return qe(16,1,e,t,r)}var Le=e=>{if(!H)try{if(e(),!q())try{b?vt(D):pe(D)}catch(e){e instanceof oe||"unwind"==e||h(1,e)}}catch(e){e instanceof oe||"unwind"==e||h(1,e)}};function We(e){e>>>=0,"function"==typeof Atomics.nb&&(Atomics.nb(a(),e>>2,e).value.then(He),e+=128,Atomics.store(a(),e>>2,1))}function He(){var e=dt();e&&(We(e),Le((()=>bt())))}c.__emscripten_thread_mailbox_await=We,c.checkMailbox=He;var Ye=e=>0==e%4&&(0!=e%100||0==e%400),je=[0,31,60,91,121,152,182,213,244,274,305,335],ze=[0,31,59,90,120,151,181,212,243,273,304,334];function Ge(e,t,r,n,a,o,i,s){return b?qe(17,1,e,t,r,n,a,o,i,s):-52}function Ne(e,t,r,n,a,o,i){if(b)return qe(18,1,e,t,r,n,a,o,i)}var Be=e=>{var t=Se(e)+1,r=pt(t);return r&&Ae(e,r,t),r},$e=e=>{var t=Ot();return e=e(),St(t),e};function qe(e,t){var r=arguments.length-2,n=arguments;return $e((()=>{for(var a=Et(8*r),o=a>>3,s=0;s<r;s++){var u=n[2+s];i()[o+s>>>0]=u}return mt(e,r,a,t)}))}var Ve,Je=[],Xe={},Ke=()=>{if(!Ve){var e,t={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:("object"==typeof navigator&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:g||"./this.program"};for(e in Xe)void 0===Xe[e]?delete t[e]:t[e]=Xe[e];var r=[];for(e in t)r.push(`${e}=${t[e]}`);Ve=r}return Ve};function Ze(e,r){if(b)return qe(19,1,e,r);e>>>=0,r>>>=0;var n=0;return Ke().forEach((function(a,i){var s=r+n;for(i=o()[e+4*i>>2>>>0]=s,s=0;s<a.length;++s)t()[i++>>0>>>0]=a.charCodeAt(s);t()[i>>0>>>0]=0,n+=a.length+1})),0}function Qe(e,t){if(b)return qe(20,1,e,t);e>>>=0,t>>>=0;var r=Ke();o()[e>>2>>>0]=r.length;var n=0;return r.forEach((function(e){n+=e.length+1})),o()[t>>2>>>0]=n,0}function et(e){return b?qe(21,1,e):52}function tt(e,t,r,n){return b?qe(22,1,e,t,r,n):52}function rt(e,t,r,n,a){return b?qe(23,1,e,t,r,n,a):70}var nt=[null,[],[]];function at(e,t,r,a){if(b)return qe(24,1,e,t,r,a);t>>>=0,r>>>=0,a>>>=0;for(var i=0,s=0;s<r;s++){var u=o()[t>>2>>>0],c=o()[t+4>>2>>>0];t+=8;for(var l=0;l<c;l++){var f=n()[u+l>>>0],d=nt[e];0===f||10===f?((1===e?M:R)(le(d,0)),d.length=0):d.push(f)}i+=c}return o()[a>>2>>>0]=i,0}var ot=e=>(ot=(()=>{if("object"==typeof crypto&&"function"==typeof crypto.getRandomValues)return e=>(e.set(crypto.getRandomValues(new Uint8Array(e.byteLength))),e);if(v)try{var e=r(760);if(e.randomFillSync)return t=>e.randomFillSync(t);var t=e.randomBytes;return e=>(e.set(t(e.byteLength)),e)}catch(e){}te("initRandomDevice")})())(e),it=[31,29,31,30,31,30,31,31,30,31,30,31],st=[31,28,31,30,31,30,31,31,30,31,30,31],ut=(e,r)=>{t().set(e,r>>>0)};function ct(e,t,r,n){function o(e,t,r){for(e="number"==typeof e?e.toString():e||"";e.length<t;)e=r[0]+e;return e}function i(e,t){return o(e,t,"0")}function s(e,t){function r(e){return 0>e?-1:0<e?1:0}var n;return 0===(n=r(e.getFullYear()-t.getFullYear()))&&0===(n=r(e.getMonth()-t.getMonth()))&&(n=r(e.getDate()-t.getDate())),n}function u(e){switch(e.getDay()){case 0:return new Date(e.getFullYear()-1,11,29);case 1:return e;case 2:return new Date(e.getFullYear(),0,3);case 3:return new Date(e.getFullYear(),0,2);case 4:return new Date(e.getFullYear(),0,1);case 5:return new Date(e.getFullYear()-1,11,31);case 6:return new Date(e.getFullYear()-1,11,30)}}function c(e){var t=e.Ja;for(e=new Date(new Date(e.Ka+1900,0,1).getTime());0<t;){var r=e.getMonth(),n=(Ye(e.getFullYear())?it:st)[r];if(!(t>n-e.getDate())){e.setDate(e.getDate()+t);break}t-=n-e.getDate()+1,e.setDate(1),11>r?e.setMonth(r+1):(e.setMonth(0),e.setFullYear(e.getFullYear()+1))}return r=new Date(e.getFullYear()+1,0,4),t=u(new Date(e.getFullYear(),0,4)),r=u(r),0>=s(t,e)?0>=s(r,e)?e.getFullYear()+1:e.getFullYear():e.getFullYear()-1}e>>>=0,t>>>=0,r>>>=0,n>>>=0;var l=a()[n+40>>2>>>0];for(var f in n={kb:a()[n>>2>>>0],jb:a()[n+4>>2>>>0],Ma:a()[n+8>>2>>>0],Qa:a()[n+12>>2>>>0],Na:a()[n+16>>2>>>0],Ka:a()[n+20>>2>>>0],Ga:a()[n+24>>2>>>0],Ja:a()[n+28>>2>>>0],sb:a()[n+32>>2>>>0],ib:a()[n+36>>2>>>0],lb:l?fe(l):""},r=fe(r),l={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"})r=r.replace(new RegExp(f,"g"),l[f]);var d="Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),p="January February March April May June July August September October November December".split(" ");for(f in l={"%a":e=>d[e.Ga].substring(0,3),"%A":e=>d[e.Ga],"%b":e=>p[e.Na].substring(0,3),"%B":e=>p[e.Na],"%C":e=>i((e.Ka+1900)/100|0,2),"%d":e=>i(e.Qa,2),"%e":e=>o(e.Qa,2," "),"%g":e=>c(e).toString().substring(2),"%G":e=>c(e),"%H":e=>i(e.Ma,2),"%I":e=>(0==(e=e.Ma)?e=12:12<e&&(e-=12),i(e,2)),"%j":e=>{for(var t=0,r=0;r<=e.Na-1;t+=(Ye(e.Ka+1900)?it:st)[r++]);return i(e.Qa+t,3)},"%m":e=>i(e.Na+1,2),"%M":e=>i(e.jb,2),"%n":()=>"\\n","%p":e=>0<=e.Ma&&12>e.Ma?"AM":"PM","%S":e=>i(e.kb,2),"%t":()=>"\\t","%u":e=>e.Ga||7,"%U":e=>i(Math.floor((e.Ja+7-e.Ga)/7),2),"%V":e=>{var t=Math.floor((e.Ja+7-(e.Ga+6)%7)/7);if(2>=(e.Ga+371-e.Ja-2)%7&&t++,t)53==t&&(4==(r=(e.Ga+371-e.Ja)%7)||3==r&&Ye(e.Ka)||(t=1));else{t=52;var r=(e.Ga+7-e.Ja-1)%7;(4==r||5==r&&Ye(e.Ka%400-1))&&t++}return i(t,2)},"%w":e=>e.Ga,"%W":e=>i(Math.floor((e.Ja+7-(e.Ga+6)%7)/7),2),"%y":e=>(e.Ka+1900).toString().substring(2),"%Y":e=>e.Ka+1900,"%z":e=>{var t=0<=(e=e.ib);return e=Math.abs(e)/60,(t?"+":"-")+String("0000"+(e/60*100+e%60)).slice(-4)},"%Z":e=>e.lb,"%%":()=>"%"},r=r.replace(/%%/g,"\\0\\0"),l)r.includes(f)&&(r=r.replace(new RegExp(f,"g"),l[f](n)));return f=function(e){var t=Array(Se(e)+1);return Ee(e,t,0,t.length),t}(r=r.replace(/\\0\\0/g,"%")),f.length>t?0:(ut(f,e),f.length-1)}ge.Pa();var lt=[null,de,me,be,_e,Oe,Te,Me,Re,Fe,ke,Ce,Pe,De,xe,Ie,Ue,Ge,Ne,Ze,Qe,et,tt,rt,at],ft={b:function(e,t,r){throw new ve(e>>>=0).Pa(t>>>0,r>>>0),e},N:function(e){gt(e>>>0,!y,1,!m,131072,!1),ge.Sa()},k:function(e){e>>>=0,b?postMessage({cmd:"cleanupThread",thread:e}):se(e)},I:we,h:_e,T:Oe,E:Te,G:Me,U:Re,R:Fe,J:ke,Q:Ce,o:Pe,F:De,C:xe,S:Ie,D:Ue,q:()=>!0,A:function(e,t){(e>>>=0)==t>>>0?setTimeout((()=>He())):b?postMessage({targetThread:e,cmd:"checkMailbox"}):(e=ge.Fa[e])&&e.postMessage({cmd:"checkMailbox"})},L:function(){return-1},M:We,p:function(e){v&&ge.Fa[e>>>0].ref()},t:function(e,t,r){e=t+2097152>>>0<4194305-!!e?(e>>>0)+4294967296*t:NaN,r>>>=0,e=new Date(1e3*e),a()[r>>2>>>0]=e.getUTCSeconds(),a()[r+4>>2>>>0]=e.getUTCMinutes(),a()[r+8>>2>>>0]=e.getUTCHours(),a()[r+12>>2>>>0]=e.getUTCDate(),a()[r+16>>2>>>0]=e.getUTCMonth(),a()[r+20>>2>>>0]=e.getUTCFullYear()-1900,a()[r+24>>2>>>0]=e.getUTCDay(),e=(e.getTime()-Date.UTC(e.getUTCFullYear(),0,1,0,0,0,0))/864e5|0,a()[r+28>>2>>>0]=e},u:function(e,t,r){e=t+2097152>>>0<4194305-!!e?(e>>>0)+4294967296*t:NaN,r>>>=0,e=new Date(1e3*e),a()[r>>2>>>0]=e.getSeconds(),a()[r+4>>2>>>0]=e.getMinutes(),a()[r+8>>2>>>0]=e.getHours(),a()[r+12>>2>>>0]=e.getDate(),a()[r+16>>2>>>0]=e.getMonth(),a()[r+20>>2>>>0]=e.getFullYear()-1900,a()[r+24>>2>>>0]=e.getDay(),t=(Ye(e.getFullYear())?je:ze)[e.getMonth()]+e.getDate()-1|0,a()[r+28>>2>>>0]=t,a()[r+36>>2>>>0]=-60*e.getTimezoneOffset(),t=new Date(e.getFullYear(),6,1).getTimezoneOffset();var n=new Date(e.getFullYear(),0,1).getTimezoneOffset();e=0|(t!=n&&e.getTimezoneOffset()==Math.min(n,t)),a()[r+32>>2>>>0]=e},v:function(e){e>>>=0;var t=new Date(a()[e+20>>2>>>0]+1900,a()[e+16>>2>>>0],a()[e+12>>2>>>0],a()[e+8>>2>>>0],a()[e+4>>2>>>0],a()[e>>2>>>0],0),r=a()[e+32>>2>>>0],n=t.getTimezoneOffset(),o=new Date(t.getFullYear(),6,1).getTimezoneOffset(),i=new Date(t.getFullYear(),0,1).getTimezoneOffset(),s=Math.min(i,o);return 0>r?a()[e+32>>2>>>0]=Number(o!=i&&s==n):0<r!=(s==n)&&(o=Math.max(i,o),t.setTime(t.getTime()+6e4*((0<r?s:o)-n))),a()[e+24>>2>>>0]=t.getDay(),r=(Ye(t.getFullYear())?je:ze)[t.getMonth()]+t.getDate()-1|0,a()[e+28>>2>>>0]=r,a()[e>>2>>>0]=t.getSeconds(),a()[e+4>>2>>>0]=t.getMinutes(),a()[e+8>>2>>>0]=t.getHours(),a()[e+12>>2>>>0]=t.getDate(),a()[e+16>>2>>>0]=t.getMonth(),a()[e+20>>2>>>0]=t.getYear(),e=t.getTime()/1e3,wt((J=e,1<=+Math.abs(J)?0<J?+Math.floor(J/4294967296)>>>0:~~+Math.ceil((J-+(~~J>>>0))/4294967296)>>>0:0)),e>>>0},r:Ge,s:Ne,z:function(e,t,r){function n(e){return(e=e.toTimeString().match(/\\(([A-Za-z ]+)\\)$/))?e[1]:"GMT"}e>>>=0,t>>>=0,r>>>=0;var i=(new Date).getFullYear(),s=new Date(i,0,1),u=new Date(i,6,1);i=s.getTimezoneOffset();var c=u.getTimezoneOffset(),l=Math.max(i,c);o()[e>>2>>>0]=60*l,a()[t>>2>>>0]=Number(i!=c),e=n(s),t=n(u),e=Be(e),t=Be(t),c<i?(o()[r>>2>>>0]=e,o()[r+4>>2>>>0]=t):(o()[r>>2>>>0]=t,o()[r+4>>2>>>0]=e)},c:()=>{te("")},l:function(){},i:function(){return Date.now()},V:()=>{throw $+=1,"unwind"},B:function(){return 4294901760},e:()=>performance.timeOrigin+performance.now(),f:function(){return v?r(993).cpus().length:navigator.hardwareConcurrency},K:function(e,t,r,n){for(ge.pb=t>>>0,Je.length=r,t=n>>>0>>3,n=0;n<r;n++)Je[n]=i()[t+n>>>0];return lt[e].apply(null,Je)},y:function(e){e>>>=0;var t=n().length;if(e<=t||4294901760<e)return!1;for(var r=1;4>=r;r*=2){var a=t*(1+.2/r);a=Math.min(a,e+100663296);var o=Math;a=Math.max(e,a);e:{o=o.min.call(o,4294901760,a+(65536-a%65536)%65536)-k.buffer.byteLength+65535>>>16;try{k.grow(o),Y();var i=1;break e}catch(e){}i=void 0}if(i)return!0}return!1},O:Ze,P:Qe,j:pe,g:et,n:tt,w:rt,m:at,x:function(e,t){return e>>>=0,t>>>=0,ot(n().subarray(e>>>0,e+t>>>0)),0},a:k||c.wasmMemory,H:ct,d:function(e,t,r,n){return ct(e>>>0,t>>>0,r>>>0,n>>>0)}};!function(){function e(e,t){return e=e.exports,C=e=function(e){var t=e=>()=>e()>>>0,r=e=>t=>e(t)>>>0;return(e=Object.assign({},e)).__errno_location=t(e.__errno_location),e.pthread_self=t(e.pthread_self),e.malloc=r(e.malloc),e.stackSave=t(e.stackSave),e.stackAlloc=r(e.stackAlloc),e}(e),ge.Ta.push(C.sa),z=C.ta,N.unshift(C.W),P=t,ee(),e}var t={a:ft};if(Q(),c.instantiateWasm)try{return c.instantiateWasm(t,e)}catch(e){R("Module.instantiateWasm callback failed with error: "+e),u(e)}(function(e,t){var r=V;return T||"function"!=typeof WebAssembly.instantiateStreaming||re(r)||r.startsWith("file://")||v||"function"!=typeof fetch?ae(r,e,t):fetch(r,{credentials:"same-origin"}).then((n=>WebAssembly.instantiateStreaming(n,e).then(t,(function(n){return R("wasm streaming compile failed: "+n),R("falling back to ArrayBuffer instantiation"),ae(r,e,t)}))))})(t,(function(t){e(t.instance,t.module)})).catch(u)}(),c._OrtInit=(e,t)=>(c._OrtInit=C.X)(e,t),c._OrtGetLastError=(e,t)=>(c._OrtGetLastError=C.Y)(e,t),c._OrtCreateSessionOptions=(e,t,r,n,a,o,i,s,u,l)=>(c._OrtCreateSessionOptions=C.Z)(e,t,r,n,a,o,i,s,u,l),c._OrtAppendExecutionProvider=(e,t)=>(c._OrtAppendExecutionProvider=C._)(e,t),c._OrtAddSessionConfigEntry=(e,t,r)=>(c._OrtAddSessionConfigEntry=C.$)(e,t,r),c._OrtReleaseSessionOptions=e=>(c._OrtReleaseSessionOptions=C.aa)(e),c._OrtCreateSession=(e,t,r)=>(c._OrtCreateSession=C.ba)(e,t,r),c._OrtReleaseSession=e=>(c._OrtReleaseSession=C.ca)(e),c._OrtGetInputOutputCount=(e,t,r)=>(c._OrtGetInputOutputCount=C.da)(e,t,r),c._OrtGetInputName=(e,t)=>(c._OrtGetInputName=C.ea)(e,t),c._OrtGetOutputName=(e,t)=>(c._OrtGetOutputName=C.fa)(e,t),c._OrtFree=e=>(c._OrtFree=C.ga)(e),c._OrtCreateTensor=(e,t,r,n,a)=>(c._OrtCreateTensor=C.ha)(e,t,r,n,a),c._OrtGetTensorData=(e,t,r,n,a)=>(c._OrtGetTensorData=C.ia)(e,t,r,n,a),c._OrtReleaseTensor=e=>(c._OrtReleaseTensor=C.ja)(e),c._OrtCreateRunOptions=(e,t,r,n)=>(c._OrtCreateRunOptions=C.ka)(e,t,r,n),c._OrtAddRunConfigEntry=(e,t,r)=>(c._OrtAddRunConfigEntry=C.la)(e,t,r),c._OrtReleaseRunOptions=e=>(c._OrtReleaseRunOptions=C.ma)(e),c._OrtRun=(e,t,r,n,a,o,i,s)=>(c._OrtRun=C.na)(e,t,r,n,a,o,i,s),c._OrtEndProfiling=e=>(c._OrtEndProfiling=C.oa)(e);var dt=c._pthread_self=()=>(dt=c._pthread_self=C.pa)(),pt=c._malloc=e=>(pt=c._malloc=C.qa)(e);c._free=e=>(c._free=C.ra)(e),c.__emscripten_tls_init=()=>(c.__emscripten_tls_init=C.sa)();var gt=c.__emscripten_thread_init=(e,t,r,n,a,o)=>(gt=c.__emscripten_thread_init=C.ua)(e,t,r,n,a,o);c.__emscripten_thread_crashed=()=>(c.__emscripten_thread_crashed=C.va)();var ht,mt=(e,t,r,n)=>(mt=C.wa)(e,t,r,n),yt=e=>(yt=C.xa)(e),vt=c.__emscripten_thread_exit=e=>(vt=c.__emscripten_thread_exit=C.ya)(e),bt=c.__emscripten_check_mailbox=()=>(bt=c.__emscripten_check_mailbox=C.za)(),wt=e=>(wt=C.Aa)(e),_t=(e,t)=>(_t=C.Ba)(e,t),Ot=()=>(Ot=C.Ca)(),St=e=>(St=C.Da)(e),Et=e=>(Et=C.Ea)(e);function At(){function e(){if(!ht&&(ht=!0,c.calledRun=!0,!H)&&(b||he(N),s(c),c.onRuntimeInitialized&&c.onRuntimeInitialized(),!b)){if(c.postRun)for("function"==typeof c.postRun&&(c.postRun=[c.postRun]);c.postRun.length;){var e=c.postRun.shift();B.unshift(e)}he(B)}}if(!(0<X))if(b)s(c),b||he(N),startWorker(c);else{if(c.preRun)for("function"==typeof c.preRun&&(c.preRun=[c.preRun]);c.preRun.length;)G.unshift(c.preRun.shift());he(G),0<X||(c.setStatus?(c.setStatus("Running..."),setTimeout((function(){setTimeout((function(){c.setStatus("")}),1),e()}),1)):e())}}if(c.keepRuntimeAlive=q,c.wasmMemory=k,c.stackAlloc=Et,c.stackSave=Ot,c.stackRestore=St,c.UTF8ToString=fe,c.stringToUTF8=Ae,c.lengthBytesUTF8=Se,c.ExitStatus=oe,c.PThread=ge,Z=function e(){ht||At(),ht||(Z=e)},c.preInit)for("function"==typeof c.preInit&&(c.preInit=[c.preInit]);0<c.preInit.length;)c.preInit.pop()();return At(),e.ready});e.exports=n},932:(e,t,r)=>{var _scriptDir,n=(_scriptDir="undefined"!=typeof document&&document.currentScript?document.currentScript.src:void 0,"undefined"!=typeof __filename&&(_scriptDir=_scriptDir||__filename),function(e={}){var t,n,a=e;a.ready=new Promise(((e,r)=>{t=e,n=r}));var o,i,s,u=Object.assign({},a),c="./this.program",l=(e,t)=>{throw t},f="object"==typeof window,d="function"==typeof importScripts,p="object"==typeof process&&"object"==typeof process.versions&&"string"==typeof process.versions.node,g="";if(p){var h=r(384),m=r(908);g=d?m.dirname(g)+"/":__dirname+"/",o=(e,t)=>(e=e.startsWith("file://")?new URL(e):m.normalize(e),h.readFileSync(e,t?void 0:"utf8")),s=e=>((e=o(e,!0)).buffer||(e=new Uint8Array(e)),e),i=(e,t,r,n=!0)=>{e=e.startsWith("file://")?new URL(e):m.normalize(e),h.readFile(e,n?void 0:"utf8",((e,a)=>{e?r(e):t(n?a.buffer:a)}))},!a.thisProgram&&1<process.argv.length&&(c=process.argv[1].replace(/\\\\/g,"/")),process.argv.slice(2),l=(e,t)=>{throw process.exitCode=e,t},a.inspect=()=>"[Emscripten Module object]"}else(f||d)&&(d?g=self.location.href:"undefined"!=typeof document&&document.currentScript&&(g=document.currentScript.src),_scriptDir&&(g=_scriptDir),g=0!==g.indexOf("blob:")?g.substr(0,g.replace(/[?#].*/,"").lastIndexOf("/")+1):"",o=e=>{var t=new XMLHttpRequest;return t.open("GET",e,!1),t.send(null),t.responseText},d&&(s=e=>{var t=new XMLHttpRequest;return t.open("GET",e,!1),t.responseType="arraybuffer",t.send(null),new Uint8Array(t.response)}),i=(e,t,r)=>{var n=new XMLHttpRequest;n.open("GET",e,!0),n.responseType="arraybuffer",n.onload=()=>{200==n.status||0==n.status&&n.response?t(n.response):r()},n.onerror=r,n.send(null)});var y,v=a.print||console.log.bind(console),b=a.printErr||console.error.bind(console);Object.assign(a,u),u=null,a.thisProgram&&(c=a.thisProgram),a.quit&&(l=a.quit),a.wasmBinary&&(y=a.wasmBinary);var w=a.noExitRuntime||!0;"object"!=typeof WebAssembly&&W("no native wasm support detected");var _,O,S,E,A,T,M=!1;function R(){var e=_.buffer;a.HEAP8=S=new Int8Array(e),a.HEAP16=new Int16Array(e),a.HEAP32=A=new Int32Array(e),a.HEAPU8=E=new Uint8Array(e),a.HEAPU16=new Uint16Array(e),a.HEAPU32=T=new Uint32Array(e),a.HEAPF32=new Float32Array(e),a.HEAPF64=new Float64Array(e)}var F=[],k=[],C=[];function P(){var e=a.preRun.shift();F.unshift(e)}var D,x,I=0,U=null,L=null;function W(e){throw a.onAbort&&a.onAbort(e),b(e="Aborted("+e+")"),M=!0,e=new WebAssembly.RuntimeError(e+". Build with -sASSERTIONS for more info."),n(e),e}function H(e){return e.startsWith("data:application/octet-stream;base64,")}if(!H(D="ort-wasm.wasm")){var Y=D;D=a.locateFile?a.locateFile(Y,g):g+Y}function j(e){if(e==D&&y)return new Uint8Array(y);if(s)return s(e);throw"both async and sync fetching of the wasm failed"}function z(e,t,r){return function(e){if(!y&&(f||d)){if("function"==typeof fetch&&!e.startsWith("file://"))return fetch(e,{credentials:"same-origin"}).then((t=>{if(!t.ok)throw"failed to load wasm binary file at \'"+e+"\'";return t.arrayBuffer()})).catch((()=>j(e)));if(i)return new Promise(((t,r)=>{i(e,(e=>t(new Uint8Array(e))),r)}))}return Promise.resolve().then((()=>j(e)))}(e).then((e=>WebAssembly.instantiate(e,t))).then((e=>e)).then(r,(e=>{b("failed to asynchronously prepare wasm: "+e),W(e)}))}function G(e){this.name="ExitStatus",this.message=`Program terminated with exit(${e})`,this.status=e}var N=e=>{for(;0<e.length;)e.shift()(a)};function B(e){this.qa=e-24,this.va=function(e){T[this.qa+4>>2>>>0]=e},this.ua=function(e){T[this.qa+8>>2>>>0]=e},this.sa=function(e,t){this.ta(),this.va(e),this.ua(t)},this.ta=function(){T[this.qa+16>>2>>>0]=0}}var $,q="undefined"!=typeof TextDecoder?new TextDecoder("utf8"):void 0,V=(e,t,r)=>{var n=(t>>>=0)+r;for(r=t;e[r]&&!(r>=n);)++r;if(16<r-t&&e.buffer&&q)return q.decode(e.subarray(t,r));for(n="";t<r;){var a=e[t++];if(128&a){var o=63&e[t++];if(192==(224&a))n+=String.fromCharCode((31&a)<<6|o);else{var i=63&e[t++];65536>(a=224==(240&a)?(15&a)<<12|o<<6|i:(7&a)<<18|o<<12|i<<6|63&e[t++])?n+=String.fromCharCode(a):(a-=65536,n+=String.fromCharCode(55296|a>>10,56320|1023&a))}}else n+=String.fromCharCode(a)}return n},J=(e,t)=>(e>>>=0)?V(E,e,t):"",X=e=>{for(var t=0,r=0;r<e.length;++r){var n=e.charCodeAt(r);127>=n?t++:2047>=n?t+=2:55296<=n&&57343>=n?(t+=4,++r):t+=3}return t},K=(e,t,r,n)=>{if(!(0<n))return 0;var a=r>>>=0;n=r+n-1;for(var o=0;o<e.length;++o){var i=e.charCodeAt(o);if(55296<=i&&57343>=i&&(i=65536+((1023&i)<<10)|1023&e.charCodeAt(++o)),127>=i){if(r>=n)break;t[r++>>>0]=i}else{if(2047>=i){if(r+1>=n)break;t[r++>>>0]=192|i>>6}else{if(65535>=i){if(r+2>=n)break;t[r++>>>0]=224|i>>12}else{if(r+3>=n)break;t[r++>>>0]=240|i>>18,t[r++>>>0]=128|i>>12&63}t[r++>>>0]=128|i>>6&63}t[r++>>>0]=128|63&i}}return t[r>>>0]=0,r-a},Z=e=>0==e%4&&(0!=e%100||0==e%400),Q=[0,31,60,91,121,152,182,213,244,274,305,335],ee=[0,31,59,90,120,151,181,212,243,273,304,334],te=e=>{var t=X(e)+1,r=le(t);return r&&K(e,E,r,t),r},re={},ne=()=>{if(!$){var e,t={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:("object"==typeof navigator&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:c||"./this.program"};for(e in re)void 0===re[e]?delete t[e]:t[e]=re[e];var r=[];for(e in t)r.push(`${e}=${t[e]}`);$=r}return $},ae=[null,[],[]],oe=e=>(oe=(()=>{if("object"==typeof crypto&&"function"==typeof crypto.getRandomValues)return e=>crypto.getRandomValues(e);if(p)try{var e=r(760);if(e.randomFillSync)return t=>e.randomFillSync(t);var t=e.randomBytes;return e=>(e.set(t(e.byteLength)),e)}catch(e){}W("initRandomDevice")})())(e),ie=[31,29,31,30,31,30,31,31,30,31,30,31],se=[31,28,31,30,31,30,31,31,30,31,30,31];function ue(e,t,r,n){function a(e,t,r){for(e="number"==typeof e?e.toString():e||"";e.length<t;)e=r[0]+e;return e}function o(e,t){return a(e,t,"0")}function i(e,t){function r(e){return 0>e?-1:0<e?1:0}var n;return 0===(n=r(e.getFullYear()-t.getFullYear()))&&0===(n=r(e.getMonth()-t.getMonth()))&&(n=r(e.getDate()-t.getDate())),n}function s(e){switch(e.getDay()){case 0:return new Date(e.getFullYear()-1,11,29);case 1:return e;case 2:return new Date(e.getFullYear(),0,3);case 3:return new Date(e.getFullYear(),0,2);case 4:return new Date(e.getFullYear(),0,1);case 5:return new Date(e.getFullYear()-1,11,31);case 6:return new Date(e.getFullYear()-1,11,30)}}function u(e){var t=e.ma;for(e=new Date(new Date(e.na+1900,0,1).getTime());0<t;){var r=e.getMonth(),n=(Z(e.getFullYear())?ie:se)[r];if(!(t>n-e.getDate())){e.setDate(e.getDate()+t);break}t-=n-e.getDate()+1,e.setDate(1),11>r?e.setMonth(r+1):(e.setMonth(0),e.setFullYear(e.getFullYear()+1))}return r=new Date(e.getFullYear()+1,0,4),t=s(new Date(e.getFullYear(),0,4)),r=s(r),0>=i(t,e)?0>=i(r,e)?e.getFullYear()+1:e.getFullYear():e.getFullYear()-1}e>>>=0,t>>>=0,r>>>=0;var c=A[40+(n>>>=0)>>2>>>0];for(var l in n={ya:A[n>>2>>>0],xa:A[n+4>>2>>>0],oa:A[n+8>>2>>>0],ra:A[n+12>>2>>>0],pa:A[n+16>>2>>>0],na:A[n+20>>2>>>0],ha:A[n+24>>2>>>0],ma:A[n+28>>2>>>0],Aa:A[n+32>>2>>>0],wa:A[n+36>>2>>>0],za:c?J(c):""},r=J(r),c={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"})r=r.replace(new RegExp(l,"g"),c[l]);var f="Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),d="January February March April May June July August September October November December".split(" ");for(l in c={"%a":e=>f[e.ha].substring(0,3),"%A":e=>f[e.ha],"%b":e=>d[e.pa].substring(0,3),"%B":e=>d[e.pa],"%C":e=>o((e.na+1900)/100|0,2),"%d":e=>o(e.ra,2),"%e":e=>a(e.ra,2," "),"%g":e=>u(e).toString().substring(2),"%G":e=>u(e),"%H":e=>o(e.oa,2),"%I":e=>(0==(e=e.oa)?e=12:12<e&&(e-=12),o(e,2)),"%j":e=>{for(var t=0,r=0;r<=e.pa-1;t+=(Z(e.na+1900)?ie:se)[r++]);return o(e.ra+t,3)},"%m":e=>o(e.pa+1,2),"%M":e=>o(e.xa,2),"%n":()=>"\\n","%p":e=>0<=e.oa&&12>e.oa?"AM":"PM","%S":e=>o(e.ya,2),"%t":()=>"\\t","%u":e=>e.ha||7,"%U":e=>o(Math.floor((e.ma+7-e.ha)/7),2),"%V":e=>{var t=Math.floor((e.ma+7-(e.ha+6)%7)/7);if(2>=(e.ha+371-e.ma-2)%7&&t++,t)53==t&&(4==(r=(e.ha+371-e.ma)%7)||3==r&&Z(e.na)||(t=1));else{t=52;var r=(e.ha+7-e.ma-1)%7;(4==r||5==r&&Z(e.na%400-1))&&t++}return o(t,2)},"%w":e=>e.ha,"%W":e=>o(Math.floor((e.ma+7-(e.ha+6)%7)/7),2),"%y":e=>(e.na+1900).toString().substring(2),"%Y":e=>e.na+1900,"%z":e=>{var t=0<=(e=e.wa);return e=Math.abs(e)/60,(t?"+":"-")+String("0000"+(e/60*100+e%60)).slice(-4)},"%Z":e=>e.za,"%%":()=>"%"},r=r.replace(/%%/g,"\\0\\0"),c)r.includes(l)&&(r=r.replace(new RegExp(l,"g"),c[l](n)));return l=function(e){var t=Array(X(e)+1);return K(e,t,0,t.length),t}(r=r.replace(/\\0\\0/g,"%")),l.length>t?0:(S.set(l,e>>>0),l.length-1)}var ce={a:function(e,t,r){throw new B(e>>>=0).sa(t>>>0,r>>>0),e},e:function(){return 0},I:function(){},y:function(){},A:function(){},K:function(){return 0},G:function(){},B:function(){},F:function(){},g:function(){},z:function(){},w:function(){},H:function(){},x:function(){},k:()=>!0,n:function(e,t,r){e=t+2097152>>>0<4194305-!!e?(e>>>0)+4294967296*t:NaN,r>>>=0,e=new Date(1e3*e),A[r>>2>>>0]=e.getUTCSeconds(),A[r+4>>2>>>0]=e.getUTCMinutes(),A[r+8>>2>>>0]=e.getUTCHours(),A[r+12>>2>>>0]=e.getUTCDate(),A[r+16>>2>>>0]=e.getUTCMonth(),A[r+20>>2>>>0]=e.getUTCFullYear()-1900,A[r+24>>2>>>0]=e.getUTCDay(),A[r+28>>2>>>0]=(e.getTime()-Date.UTC(e.getUTCFullYear(),0,1,0,0,0,0))/864e5|0},o:function(e,t,r){e=t+2097152>>>0<4194305-!!e?(e>>>0)+4294967296*t:NaN,r>>>=0,e=new Date(1e3*e),A[r>>2>>>0]=e.getSeconds(),A[r+4>>2>>>0]=e.getMinutes(),A[r+8>>2>>>0]=e.getHours(),A[r+12>>2>>>0]=e.getDate(),A[r+16>>2>>>0]=e.getMonth(),A[r+20>>2>>>0]=e.getFullYear()-1900,A[r+24>>2>>>0]=e.getDay(),A[r+28>>2>>>0]=(Z(e.getFullYear())?Q:ee)[e.getMonth()]+e.getDate()-1|0,A[r+36>>2>>>0]=-60*e.getTimezoneOffset(),t=new Date(e.getFullYear(),6,1).getTimezoneOffset();var n=new Date(e.getFullYear(),0,1).getTimezoneOffset();A[r+32>>2>>>0]=0|(t!=n&&e.getTimezoneOffset()==Math.min(n,t))},p:function(e){e>>>=0;var t=new Date(A[e+20>>2>>>0]+1900,A[e+16>>2>>>0],A[e+12>>2>>>0],A[e+8>>2>>>0],A[e+4>>2>>>0],A[e>>2>>>0],0),r=A[e+32>>2>>>0],n=t.getTimezoneOffset(),a=new Date(t.getFullYear(),6,1).getTimezoneOffset(),o=new Date(t.getFullYear(),0,1).getTimezoneOffset(),i=Math.min(o,a);return 0>r?A[e+32>>2>>>0]=Number(a!=o&&i==n):0<r!=(i==n)&&(a=Math.max(o,a),t.setTime(t.getTime()+6e4*((0<r?i:a)-n))),A[e+24>>2>>>0]=t.getDay(),A[e+28>>2>>>0]=(Z(t.getFullYear())?Q:ee)[t.getMonth()]+t.getDate()-1|0,A[e>>2>>>0]=t.getSeconds(),A[e+4>>2>>>0]=t.getMinutes(),A[e+8>>2>>>0]=t.getHours(),A[e+12>>2>>>0]=t.getDate(),A[e+16>>2>>>0]=t.getMonth(),A[e+20>>2>>>0]=t.getYear(),e=t.getTime()/1e3,de((x=e,1<=+Math.abs(x)?0<x?+Math.floor(x/4294967296)>>>0:~~+Math.ceil((x-+(~~x>>>0))/4294967296)>>>0:0)),e>>>0},l:function(){return-52},m:function(){},u:function(e,t,r){function n(e){return(e=e.toTimeString().match(/\\(([A-Za-z ]+)\\)$/))?e[1]:"GMT"}r>>>=0;var a=(new Date).getFullYear(),o=new Date(a,0,1),i=new Date(a,6,1);a=o.getTimezoneOffset();var s=i.getTimezoneOffset();T[e>>>0>>2>>>0]=60*Math.max(a,s),A[t>>>0>>2>>>0]=Number(a!=s),e=n(o),t=n(i),e=te(e),t=te(t),s<a?(T[r>>2>>>0]=e,T[r+4>>2>>>0]=t):(T[r>>2>>>0]=t,T[r+4>>2>>>0]=e)},d:()=>{W("")},h:function(){return Date.now()},v:function(){return 4294901760},b:()=>performance.now(),J:function(e,t,r){return t>>>=0,E.copyWithin(e>>>0>>>0,t>>>0,t+(r>>>0)>>>0)},t:function(e){e>>>=0;var t=E.length;if(4294901760<e)return!1;for(var r=1;4>=r;r*=2){var n=t*(1+.2/r);n=Math.min(n,e+100663296);var a=Math;n=Math.max(e,n);e:{a=a.min.call(a,4294901760,n+(65536-n%65536)%65536)-_.buffer.byteLength+65535>>>16;try{_.grow(a),R();var o=1;break e}catch(e){}o=void 0}if(o)return!0}return!1},D:function(e,t){e>>>=0,t>>>=0;var r=0;return ne().forEach((function(n,a){var o=t+r;for(a=T[e+4*a>>2>>>0]=o,o=0;o<n.length;++o)S[a++>>0>>>0]=n.charCodeAt(o);S[a>>0>>>0]=0,r+=n.length+1})),0},E:function(e,t){e>>>=0,t>>>=0;var r=ne();T[e>>2>>>0]=r.length;var n=0;return r.forEach((function(e){n+=e.length+1})),T[t>>2>>>0]=n,0},s:e=>{w||(a.onExit&&a.onExit(e),M=!0),l(e,new G(e))},f:()=>52,j:function(){return 52},q:function(){return 70},i:function(e,t,r,n){t>>>=0,r>>>=0,n>>>=0;for(var a=0,o=0;o<r;o++){var i=T[t>>2>>>0],s=T[t+4>>2>>>0];t+=8;for(var u=0;u<s;u++){var c=E[i+u>>>0],l=ae[e];0===c||10===c?((1===e?v:b)(V(l,0)),l.length=0):l.push(c)}a+=s}return T[n>>2>>>0]=a,0},r:function(e,t){return e>>>=0,oe(E.subarray(e>>>0,e+(t>>>0)>>>0)),0},C:ue,c:function(e,t,r,n){return ue(e>>>0,t>>>0,r>>>0,n>>>0)}};!function(){function e(e){if(e=e.exports,O=e=function(e){var t=e=>()=>e()>>>0,r=e=>t=>e(t)>>>0;return(e=Object.assign({},e)).__errno_location=t(e.__errno_location),e.malloc=r(e.malloc),e.stackSave=t(e.stackSave),e.stackAlloc=r(e.stackAlloc),e}(e),_=O.L,R(),k.unshift(O.M),I--,a.monitorRunDependencies&&a.monitorRunDependencies(I),0==I&&(null!==U&&(clearInterval(U),U=null),L)){var t=L;L=null,t()}return e}var t={a:ce};if(I++,a.monitorRunDependencies&&a.monitorRunDependencies(I),a.instantiateWasm)try{return a.instantiateWasm(t,e)}catch(e){b("Module.instantiateWasm callback failed with error: "+e),n(e)}(function(e,t){var r=D;return y||"function"!=typeof WebAssembly.instantiateStreaming||H(r)||r.startsWith("file://")||p||"function"!=typeof fetch?z(r,e,t):fetch(r,{credentials:"same-origin"}).then((n=>WebAssembly.instantiateStreaming(n,e).then(t,(function(n){return b("wasm streaming compile failed: "+n),b("falling back to ArrayBuffer instantiation"),z(r,e,t)}))))})(t,(function(t){e(t.instance)})).catch(n)}(),a._OrtInit=(e,t)=>(a._OrtInit=O.N)(e,t),a._OrtGetLastError=(e,t)=>(a._OrtGetLastError=O.O)(e,t),a._OrtCreateSessionOptions=(e,t,r,n,o,i,s,u,c,l)=>(a._OrtCreateSessionOptions=O.P)(e,t,r,n,o,i,s,u,c,l),a._OrtAppendExecutionProvider=(e,t)=>(a._OrtAppendExecutionProvider=O.Q)(e,t),a._OrtAddSessionConfigEntry=(e,t,r)=>(a._OrtAddSessionConfigEntry=O.R)(e,t,r),a._OrtReleaseSessionOptions=e=>(a._OrtReleaseSessionOptions=O.S)(e),a._OrtCreateSession=(e,t,r)=>(a._OrtCreateSession=O.T)(e,t,r),a._OrtReleaseSession=e=>(a._OrtReleaseSession=O.U)(e),a._OrtGetInputOutputCount=(e,t,r)=>(a._OrtGetInputOutputCount=O.V)(e,t,r),a._OrtGetInputName=(e,t)=>(a._OrtGetInputName=O.W)(e,t),a._OrtGetOutputName=(e,t)=>(a._OrtGetOutputName=O.X)(e,t),a._OrtFree=e=>(a._OrtFree=O.Y)(e),a._OrtCreateTensor=(e,t,r,n,o)=>(a._OrtCreateTensor=O.Z)(e,t,r,n,o),a._OrtGetTensorData=(e,t,r,n,o)=>(a._OrtGetTensorData=O._)(e,t,r,n,o),a._OrtReleaseTensor=e=>(a._OrtReleaseTensor=O.$)(e),a._OrtCreateRunOptions=(e,t,r,n)=>(a._OrtCreateRunOptions=O.aa)(e,t,r,n),a._OrtAddRunConfigEntry=(e,t,r)=>(a._OrtAddRunConfigEntry=O.ba)(e,t,r),a._OrtReleaseRunOptions=e=>(a._OrtReleaseRunOptions=O.ca)(e),a._OrtRun=(e,t,r,n,o,i,s,u)=>(a._OrtRun=O.da)(e,t,r,n,o,i,s,u),a._OrtEndProfiling=e=>(a._OrtEndProfiling=O.ea)(e);var le=a._malloc=e=>(le=a._malloc=O.fa)(e);a._free=e=>(a._free=O.ga)(e);var fe,de=e=>(de=O.ia)(e),pe=()=>(pe=O.ja)(),ge=e=>(ge=O.ka)(e),he=e=>(he=O.la)(e);function me(){function e(){if(!fe&&(fe=!0,a.calledRun=!0,!M)){if(N(k),t(a),a.onRuntimeInitialized&&a.onRuntimeInitialized(),a.postRun)for("function"==typeof a.postRun&&(a.postRun=[a.postRun]);a.postRun.length;){var e=a.postRun.shift();C.unshift(e)}N(C)}}if(!(0<I)){if(a.preRun)for("function"==typeof a.preRun&&(a.preRun=[a.preRun]);a.preRun.length;)P();N(F),0<I||(a.setStatus?(a.setStatus("Running..."),setTimeout((function(){setTimeout((function(){a.setStatus("")}),1),e()}),1)):e())}}if(a.stackAlloc=he,a.stackSave=pe,a.stackRestore=ge,a.UTF8ToString=J,a.stringToUTF8=(e,t,r)=>K(e,E,t,r),a.lengthBytesUTF8=X,L=function e(){fe||me(),fe||(L=e)},a.preInit)for("function"==typeof a.preInit&&(a.preInit=[a.preInit]);0<a.preInit.length;)a.preInit.pop()();return me(),e.ready});e.exports=n},154:e=>{"use strict";e.exports=\'"use strict";var e={},a="object"==typeof process&&"object"==typeof process.versions&&"string"==typeof process.versions.node;if(a){var r=require("worker_threads"),t=r.parentPort;t.on("message",(e=>onmessage({data:e})));var s=require("fs");Object.assign(global,{self:global,require:require,Module:e,location:{href:__filename},Worker:r.Worker,importScripts:e=>(0,eval)(s.readFileSync(e,"utf8")+"//# sourceURL="+e),postMessage:e=>t.postMessage(e),performance:global.performance||{now:Date.now}})}var o=!1,d=function(){var e=Array.prototype.slice.call(arguments).join(" ");a?s.writeSync(2,e+"\\\\n"):console.error(e)};self.alert=function(){var a=Array.prototype.slice.call(arguments).join(" ");postMessage({cmd:"alert",text:a,threadId:e._pthread_self()})},e.instantiateWasm=(a,r)=>{var t=e.wasmModule;return e.wasmModule=null,r(new WebAssembly.Instance(t,a))},self.onunhandledrejection=e=>{throw e.reason??e},self.onmessage=function a(r){try{if("load"===r.data.cmd){let s=[];self.onmessage=e=>s.push(e),self.startWorker=r=>{e=r,postMessage({cmd:"loaded"});for(let e of s)a(e);self.onmessage=a},e.wasmModule=r.data.wasmModule;for(const a of r.data.handlers)e[a]=(...e)=>{postMessage({cmd:"callHandler",handler:a,args:e})};if(e.wasmMemory=r.data.wasmMemory,e.buffer=e.wasmMemory.buffer,e.ENVIRONMENT_IS_PTHREAD=!0,"string"==typeof r.data.urlOrBlob)importScripts(r.data.urlOrBlob);else{var t=URL.createObjectURL(r.data.urlOrBlob);importScripts(t),URL.revokeObjectURL(t)}ortWasmThreaded(e)}else if("run"===r.data.cmd){e.__emscripten_thread_init(r.data.pthread_ptr,0,0,1),e.__emscripten_thread_mailbox_await(r.data.pthread_ptr),e.establishStackSpace(),e.PThread.receiveObjectTransfer(r.data),e.PThread.threadInitTLS(),o||(o=!0);try{e.invokeEntryPoint(r.data.start_routine,r.data.arg)}catch(e){if("unwind"!=e)throw e}}else"cancel"===r.data.cmd?e._pthread_self()&&e.__emscripten_thread_exit(-1):"setimmediate"===r.data.target||("checkMailbox"===r.data.cmd?o&&e.checkMailbox():r.data.cmd&&(d("worker.js received unknown command "+r.data.cmd),d(r.data)))}catch(a){throw e.__emscripten_thread_crashed&&e.__emscripten_thread_crashed(),a}};\\n\'},760:()=>{},384:()=>{},993:()=>{},908:()=>{},953:()=>{},925:()=>{},449:()=>{}},t={};function r(n){var a=t[n];if(void 0!==a)return a.exports;var o=t[n]={exports:{}};return e[n].call(o.exports,o,o.exports,r),o.exports}(()=>{"use strict";const e=r(259),t=r(263);self.onmessage=r=>{switch(r.data.type){case"init-wasm":try{(0,t.initializeWebAssembly)(r.data.in).then((()=>postMessage({type:"init-wasm"})),(e=>postMessage({type:"init-wasm",err:e})))}catch(e){postMessage({type:"init-wasm",err:e})}break;case"init-ort":try{(0,e.initRuntime)(r.data.in).then((()=>postMessage({type:"init-ort"})),(e=>postMessage({type:"init-ort",err:e}))),postMessage({type:"init-ort"})}catch(e){postMessage({type:"init-ort",err:e})}break;case"create_allocate":try{const{model:t}=r.data.in,n=(0,e.createSessionAllocate)(t);postMessage({type:"create_allocate",out:n})}catch(e){postMessage({type:"create_allocate",err:e})}break;case"create_finalize":try{const{modeldata:t,options:n}=r.data.in,a=(0,e.createSessionFinalize)(t,n);postMessage({type:"create_finalize",out:a})}catch(e){postMessage({type:"create_finalize",err:e})}break;case"create":try{const{model:t,options:n}=r.data.in,a=(0,e.createSession)(t,n);postMessage({type:"create",out:a})}catch(e){postMessage({type:"create",err:e})}break;case"release":try{const t=r.data.in;(0,e.releaseSession)(t),postMessage({type:"release"})}catch(e){postMessage({type:"release",err:e})}break;case"run":try{const{sessionId:t,inputIndices:n,inputs:a,outputIndices:o,options:i}=r.data.in;(0,e.run)(t,n,a,o,i).then((t=>{postMessage({type:"run",out:t},(0,e.extractTransferableBuffers)(t))}),(e=>{postMessage({type:"run",err:e})}))}catch(e){postMessage({type:"run",err:e})}break;case"end-profiling":try{const t=r.data.in;(0,e.endProfiling)(t),postMessage({type:"end-profiling"})}catch(e){postMessage({type:"end-profiling",err:e})}}}})()})();\n',"Worker",void 0,void 0)}},6614:me=>{"use strict";me.exports=function(E,P,F,A){var O=self||window;try{try{var k;try{k=new O.Blob([E])}catch{(k=new(O.BlobBuilder||O.WebKitBlobBuilder||O.MozBlobBuilder||O.MSBlobBuilder)).append(E),k=k.getBlob()}var S=O.URL||O.webkitURL,C=S.createObjectURL(k),v=new O[P](C,F);return S.revokeObjectURL(C),v}catch{return new O[P]("data:application/javascript,".concat(encodeURIComponent(E)),F)}}catch{if(!A)throw Error("Inline worker is not supported");return new O[P](A,F)}}},2446:(me,E,P)=>{"use strict";var F,A,O,h,l,k=P(2100),S=k.Reader,C=k.Writer,v=k.util,b=k.roots.default||(k.roots.default={});b.onnx=((O={}).Version=(F={},(A=Object.create(F))[F[0]="_START_VERSION"]=0,A[F[1]="IR_VERSION_2017_10_10"]=1,A[F[2]="IR_VERSION_2017_10_30"]=2,A[F[3]="IR_VERSION_2017_11_3"]=3,A[F[4]="IR_VERSION_2019_1_22"]=4,A[F[5]="IR_VERSION_2019_3_18"]=5,A[F[6]="IR_VERSION_2019_9_19"]=6,A[F[7]="IR_VERSION_2020_5_8"]=7,A[F[8]="IR_VERSION_2021_7_30"]=8,A[F[9]="IR_VERSION"]=9,A),O.AttributeProto=function(){function h(l){if(this.floats=[],this.ints=[],this.strings=[],this.tensors=[],this.graphs=[],this.sparseTensors=[],this.typeProtos=[],l)for(var d=Object.keys(l),f=0;f<d.length;++f)null!=l[d[f]]&&(this[d[f]]=l[d[f]])}return h.prototype.name="",h.prototype.refAttrName="",h.prototype.docString="",h.prototype.type=0,h.prototype.f=0,h.prototype.i=v.Long?v.Long.fromBits(0,0,!1):0,h.prototype.s=v.newBuffer([]),h.prototype.t=null,h.prototype.g=null,h.prototype.sparseTensor=null,h.prototype.tp=null,h.prototype.floats=v.emptyArray,h.prototype.ints=v.emptyArray,h.prototype.strings=v.emptyArray,h.prototype.tensors=v.emptyArray,h.prototype.graphs=v.emptyArray,h.prototype.sparseTensors=v.emptyArray,h.prototype.typeProtos=v.emptyArray,h.create=function(l){return new h(l)},h.encode=function(l,d){if(d||(d=C.create()),null!=l.name&&Object.hasOwnProperty.call(l,"name")&&d.uint32(10).string(l.name),null!=l.f&&Object.hasOwnProperty.call(l,"f")&&d.uint32(21).float(l.f),null!=l.i&&Object.hasOwnProperty.call(l,"i")&&d.uint32(24).int64(l.i),null!=l.s&&Object.hasOwnProperty.call(l,"s")&&d.uint32(34).bytes(l.s),null!=l.t&&Object.hasOwnProperty.call(l,"t")&&b.onnx.TensorProto.encode(l.t,d.uint32(42).fork()).ldelim(),null!=l.g&&Object.hasOwnProperty.call(l,"g")&&b.onnx.GraphProto.encode(l.g,d.uint32(50).fork()).ldelim(),null!=l.floats&&l.floats.length){d.uint32(58).fork();for(var f=0;f<l.floats.length;++f)d.float(l.floats[f]);d.ldelim()}if(null!=l.ints&&l.ints.length){for(d.uint32(66).fork(),f=0;f<l.ints.length;++f)d.int64(l.ints[f]);d.ldelim()}if(null!=l.strings&&l.strings.length)for(f=0;f<l.strings.length;++f)d.uint32(74).bytes(l.strings[f]);if(null!=l.tensors&&l.tensors.length)for(f=0;f<l.tensors.length;++f)b.onnx.TensorProto.encode(l.tensors[f],d.uint32(82).fork()).ldelim();if(null!=l.graphs&&l.graphs.length)for(f=0;f<l.graphs.length;++f)b.onnx.GraphProto.encode(l.graphs[f],d.uint32(90).fork()).ldelim();if(null!=l.docString&&Object.hasOwnProperty.call(l,"docString")&&d.uint32(106).string(l.docString),null!=l.tp&&Object.hasOwnProperty.call(l,"tp")&&b.onnx.TypeProto.encode(l.tp,d.uint32(114).fork()).ldelim(),null!=l.typeProtos&&l.typeProtos.length)for(f=0;f<l.typeProtos.length;++f)b.onnx.TypeProto.encode(l.typeProtos[f],d.uint32(122).fork()).ldelim();if(null!=l.type&&Object.hasOwnProperty.call(l,"type")&&d.uint32(160).int32(l.type),null!=l.refAttrName&&Object.hasOwnProperty.call(l,"refAttrName")&&d.uint32(170).string(l.refAttrName),null!=l.sparseTensor&&Object.hasOwnProperty.call(l,"sparseTensor")&&b.onnx.SparseTensorProto.encode(l.sparseTensor,d.uint32(178).fork()).ldelim(),null!=l.sparseTensors&&l.sparseTensors.length)for(f=0;f<l.sparseTensors.length;++f)b.onnx.SparseTensorProto.encode(l.sparseTensors[f],d.uint32(186).fork()).ldelim();return d},h.encodeDelimited=function(l,d){return this.encode(l,d).ldelim()},h.decode=function(l,d){l instanceof S||(l=S.create(l));for(var f=void 0===d?l.len:l.pos+d,y=new b.onnx.AttributeProto;l.pos<f;){var w=l.uint32();switch(w>>>3){case 1:y.name=l.string();break;case 21:y.refAttrName=l.string();break;case 13:y.docString=l.string();break;case 20:y.type=l.int32();break;case 2:y.f=l.float();break;case 3:y.i=l.int64();break;case 4:y.s=l.bytes();break;case 5:y.t=b.onnx.TensorProto.decode(l,l.uint32());break;case 6:y.g=b.onnx.GraphProto.decode(l,l.uint32());break;case 22:y.sparseTensor=b.onnx.SparseTensorProto.decode(l,l.uint32());break;case 14:y.tp=b.onnx.TypeProto.decode(l,l.uint32());break;case 7:if(y.floats&&y.floats.length||(y.floats=[]),2==(7&w))for(var D=l.uint32()+l.pos;l.pos<D;)y.floats.push(l.float());else y.floats.push(l.float());break;case 8:if(y.ints&&y.ints.length||(y.ints=[]),2==(7&w))for(D=l.uint32()+l.pos;l.pos<D;)y.ints.push(l.int64());else y.ints.push(l.int64());break;case 9:y.strings&&y.strings.length||(y.strings=[]),y.strings.push(l.bytes());break;case 10:y.tensors&&y.tensors.length||(y.tensors=[]),y.tensors.push(b.onnx.TensorProto.decode(l,l.uint32()));break;case 11:y.graphs&&y.graphs.length||(y.graphs=[]),y.graphs.push(b.onnx.GraphProto.decode(l,l.uint32()));break;case 23:y.sparseTensors&&y.sparseTensors.length||(y.sparseTensors=[]),y.sparseTensors.push(b.onnx.SparseTensorProto.decode(l,l.uint32()));break;case 15:y.typeProtos&&y.typeProtos.length||(y.typeProtos=[]),y.typeProtos.push(b.onnx.TypeProto.decode(l,l.uint32()));break;default:l.skipType(7&w)}}return y},h.decodeDelimited=function(l){return l instanceof S||(l=new S(l)),this.decode(l,l.uint32())},h.verify=function(l){if("object"!=typeof l||null===l)return"object expected";if(null!=l.name&&l.hasOwnProperty("name")&&!v.isString(l.name))return"name: string expected";if(null!=l.refAttrName&&l.hasOwnProperty("refAttrName")&&!v.isString(l.refAttrName))return"refAttrName: string expected";if(null!=l.docString&&l.hasOwnProperty("docString")&&!v.isString(l.docString))return"docString: string expected";if(null!=l.type&&l.hasOwnProperty("type"))switch(l.type){default:return"type: enum value expected";case 0:case 1:case 2:case 3:case 4:case 5:case 11:case 13:case 6:case 7:case 8:case 9:case 10:case 12:case 14:}if(null!=l.f&&l.hasOwnProperty("f")&&"number"!=typeof l.f)return"f: number expected";if(null!=l.i&&l.hasOwnProperty("i")&&!(v.isInteger(l.i)||l.i&&v.isInteger(l.i.low)&&v.isInteger(l.i.high)))return"i: integer|Long expected";if(null!=l.s&&l.hasOwnProperty("s")&&!(l.s&&"number"==typeof l.s.length||v.isString(l.s)))return"s: buffer expected";if(null!=l.t&&l.hasOwnProperty("t")&&(f=b.onnx.TensorProto.verify(l.t)))return"t."+f;if(null!=l.g&&l.hasOwnProperty("g")&&(f=b.onnx.GraphProto.verify(l.g)))return"g."+f;if(null!=l.sparseTensor&&l.hasOwnProperty("sparseTensor")&&(f=b.onnx.SparseTensorProto.verify(l.sparseTensor)))return"sparseTensor."+f;if(null!=l.tp&&l.hasOwnProperty("tp")&&(f=b.onnx.TypeProto.verify(l.tp)))return"tp."+f;if(null!=l.floats&&l.hasOwnProperty("floats")){if(!Array.isArray(l.floats))return"floats: array expected";for(var d=0;d<l.floats.length;++d)if("number"!=typeof l.floats[d])return"floats: number[] expected"}if(null!=l.ints&&l.hasOwnProperty("ints")){if(!Array.isArray(l.ints))return"ints: array expected";for(d=0;d<l.ints.length;++d)if(!(v.isInteger(l.ints[d])||l.ints[d]&&v.isInteger(l.ints[d].low)&&v.isInteger(l.ints[d].high)))return"ints: integer|Long[] expected"}if(null!=l.strings&&l.hasOwnProperty("strings")){if(!Array.isArray(l.strings))return"strings: array expected";for(d=0;d<l.strings.length;++d)if(!(l.strings[d]&&"number"==typeof l.strings[d].length||v.isString(l.strings[d])))return"strings: buffer[] expected"}if(null!=l.tensors&&l.hasOwnProperty("tensors")){if(!Array.isArray(l.tensors))return"tensors: array expected";for(d=0;d<l.tensors.length;++d)if(f=b.onnx.TensorProto.verify(l.tensors[d]))return"tensors."+f}if(null!=l.graphs&&l.hasOwnProperty("graphs")){if(!Array.isArray(l.graphs))return"graphs: array expected";for(d=0;d<l.graphs.length;++d)if(f=b.onnx.GraphProto.verify(l.graphs[d]))return"graphs."+f}if(null!=l.sparseTensors&&l.hasOwnProperty("sparseTensors")){if(!Array.isArray(l.sparseTensors))return"sparseTensors: array expected";for(d=0;d<l.sparseTensors.length;++d)if(f=b.onnx.SparseTensorProto.verify(l.sparseTensors[d]))return"sparseTensors."+f}if(null!=l.typeProtos&&l.hasOwnProperty("typeProtos")){if(!Array.isArray(l.typeProtos))return"typeProtos: array expected";for(d=0;d<l.typeProtos.length;++d){var f;if(f=b.onnx.TypeProto.verify(l.typeProtos[d]))return"typeProtos."+f}}return null},h.fromObject=function(l){if(l instanceof b.onnx.AttributeProto)return l;var d=new b.onnx.AttributeProto;switch(null!=l.name&&(d.name=String(l.name)),null!=l.refAttrName&&(d.refAttrName=String(l.refAttrName)),null!=l.docString&&(d.docString=String(l.docString)),l.type){default:if("number"==typeof l.type){d.type=l.type;break}break;case"UNDEFINED":case 0:d.type=0;break;case"FLOAT":case 1:d.type=1;break;case"INT":case 2:d.type=2;break;case"STRING":case 3:d.type=3;break;case"TENSOR":case 4:d.type=4;break;case"GRAPH":case 5:d.type=5;break;case"SPARSE_TENSOR":case 11:d.type=11;break;case"TYPE_PROTO":case 13:d.type=13;break;case"FLOATS":case 6:d.type=6;break;case"INTS":case 7:d.type=7;break;case"STRINGS":case 8:d.type=8;break;case"TENSORS":case 9:d.type=9;break;case"GRAPHS":case 10:d.type=10;break;case"SPARSE_TENSORS":case 12:d.type=12;break;case"TYPE_PROTOS":case 14:d.type=14}if(null!=l.f&&(d.f=Number(l.f)),null!=l.i&&(v.Long?(d.i=v.Long.fromValue(l.i)).unsigned=!1:"string"==typeof l.i?d.i=parseInt(l.i,10):"number"==typeof l.i?d.i=l.i:"object"==typeof l.i&&(d.i=new v.LongBits(l.i.low>>>0,l.i.high>>>0).toNumber())),null!=l.s&&("string"==typeof l.s?v.base64.decode(l.s,d.s=v.newBuffer(v.base64.length(l.s)),0):l.s.length>=0&&(d.s=l.s)),null!=l.t){if("object"!=typeof l.t)throw TypeError(".onnx.AttributeProto.t: object expected");d.t=b.onnx.TensorProto.fromObject(l.t)}if(null!=l.g){if("object"!=typeof l.g)throw TypeError(".onnx.AttributeProto.g: object expected");d.g=b.onnx.GraphProto.fromObject(l.g)}if(null!=l.sparseTensor){if("object"!=typeof l.sparseTensor)throw TypeError(".onnx.AttributeProto.sparseTensor: object expected");d.sparseTensor=b.onnx.SparseTensorProto.fromObject(l.sparseTensor)}if(null!=l.tp){if("object"!=typeof l.tp)throw TypeError(".onnx.AttributeProto.tp: object expected");d.tp=b.onnx.TypeProto.fromObject(l.tp)}if(l.floats){if(!Array.isArray(l.floats))throw TypeError(".onnx.AttributeProto.floats: array expected");d.floats=[];for(var f=0;f<l.floats.length;++f)d.floats[f]=Number(l.floats[f])}if(l.ints){if(!Array.isArray(l.ints))throw TypeError(".onnx.AttributeProto.ints: array expected");for(d.ints=[],f=0;f<l.ints.length;++f)v.Long?(d.ints[f]=v.Long.fromValue(l.ints[f])).unsigned=!1:"string"==typeof l.ints[f]?d.ints[f]=parseInt(l.ints[f],10):"number"==typeof l.ints[f]?d.ints[f]=l.ints[f]:"object"==typeof l.ints[f]&&(d.ints[f]=new v.LongBits(l.ints[f].low>>>0,l.ints[f].high>>>0).toNumber())}if(l.strings){if(!Array.isArray(l.strings))throw TypeError(".onnx.AttributeProto.strings: array expected");for(d.strings=[],f=0;f<l.strings.length;++f)"string"==typeof l.strings[f]?v.base64.decode(l.strings[f],d.strings[f]=v.newBuffer(v.base64.length(l.strings[f])),0):l.strings[f].length>=0&&(d.strings[f]=l.strings[f])}if(l.tensors){if(!Array.isArray(l.tensors))throw TypeError(".onnx.AttributeProto.tensors: array expected");for(d.tensors=[],f=0;f<l.tensors.length;++f){if("object"!=typeof l.tensors[f])throw TypeError(".onnx.AttributeProto.tensors: object expected");d.tensors[f]=b.onnx.TensorProto.fromObject(l.tensors[f])}}if(l.graphs){if(!Array.isArray(l.graphs))throw TypeError(".onnx.AttributeProto.graphs: array expected");for(d.graphs=[],f=0;f<l.graphs.length;++f){if("object"!=typeof l.graphs[f])throw TypeError(".onnx.AttributeProto.graphs: object expected");d.graphs[f]=b.onnx.GraphProto.fromObject(l.graphs[f])}}if(l.sparseTensors){if(!Array.isArray(l.sparseTensors))throw TypeError(".onnx.AttributeProto.sparseTensors: array expected");for(d.sparseTensors=[],f=0;f<l.sparseTensors.length;++f){if("object"!=typeof l.sparseTensors[f])throw TypeError(".onnx.AttributeProto.sparseTensors: object expected");d.sparseTensors[f]=b.onnx.SparseTensorProto.fromObject(l.sparseTensors[f])}}if(l.typeProtos){if(!Array.isArray(l.typeProtos))throw TypeError(".onnx.AttributeProto.typeProtos: array expected");for(d.typeProtos=[],f=0;f<l.typeProtos.length;++f){if("object"!=typeof l.typeProtos[f])throw TypeError(".onnx.AttributeProto.typeProtos: object expected");d.typeProtos[f]=b.onnx.TypeProto.fromObject(l.typeProtos[f])}}return d},h.toObject=function(l,d){d||(d={});var f={};if((d.arrays||d.defaults)&&(f.floats=[],f.ints=[],f.strings=[],f.tensors=[],f.graphs=[],f.typeProtos=[],f.sparseTensors=[]),d.defaults){if(f.name="",f.f=0,v.Long){var y=new v.Long(0,0,!1);f.i=d.longs===String?y.toString():d.longs===Number?y.toNumber():y}else f.i=d.longs===String?"0":0;d.bytes===String?f.s="":(f.s=[],d.bytes!==Array&&(f.s=v.newBuffer(f.s))),f.t=null,f.g=null,f.docString="",f.tp=null,f.type=d.enums===String?"UNDEFINED":0,f.refAttrName="",f.sparseTensor=null}if(null!=l.name&&l.hasOwnProperty("name")&&(f.name=l.name),null!=l.f&&l.hasOwnProperty("f")&&(f.f=d.json&&!isFinite(l.f)?String(l.f):l.f),null!=l.i&&l.hasOwnProperty("i")&&(f.i="number"==typeof l.i?d.longs===String?String(l.i):l.i:d.longs===String?v.Long.prototype.toString.call(l.i):d.longs===Number?new v.LongBits(l.i.low>>>0,l.i.high>>>0).toNumber():l.i),null!=l.s&&l.hasOwnProperty("s")&&(f.s=d.bytes===String?v.base64.encode(l.s,0,l.s.length):d.bytes===Array?Array.prototype.slice.call(l.s):l.s),null!=l.t&&l.hasOwnProperty("t")&&(f.t=b.onnx.TensorProto.toObject(l.t,d)),null!=l.g&&l.hasOwnProperty("g")&&(f.g=b.onnx.GraphProto.toObject(l.g,d)),l.floats&&l.floats.length){f.floats=[];for(var w=0;w<l.floats.length;++w)f.floats[w]=d.json&&!isFinite(l.floats[w])?String(l.floats[w]):l.floats[w]}if(l.ints&&l.ints.length)for(f.ints=[],w=0;w<l.ints.length;++w)f.ints[w]="number"==typeof l.ints[w]?d.longs===String?String(l.ints[w]):l.ints[w]:d.longs===String?v.Long.prototype.toString.call(l.ints[w]):d.longs===Number?new v.LongBits(l.ints[w].low>>>0,l.ints[w].high>>>0).toNumber():l.ints[w];if(l.strings&&l.strings.length)for(f.strings=[],w=0;w<l.strings.length;++w)f.strings[w]=d.bytes===String?v.base64.encode(l.strings[w],0,l.strings[w].length):d.bytes===Array?Array.prototype.slice.call(l.strings[w]):l.strings[w];if(l.tensors&&l.tensors.length)for(f.tensors=[],w=0;w<l.tensors.length;++w)f.tensors[w]=b.onnx.TensorProto.toObject(l.tensors[w],d);if(l.graphs&&l.graphs.length)for(f.graphs=[],w=0;w<l.graphs.length;++w)f.graphs[w]=b.onnx.GraphProto.toObject(l.graphs[w],d);if(null!=l.docString&&l.hasOwnProperty("docString")&&(f.docString=l.docString),null!=l.tp&&l.hasOwnProperty("tp")&&(f.tp=b.onnx.TypeProto.toObject(l.tp,d)),l.typeProtos&&l.typeProtos.length)for(f.typeProtos=[],w=0;w<l.typeProtos.length;++w)f.typeProtos[w]=b.onnx.TypeProto.toObject(l.typeProtos[w],d);if(null!=l.type&&l.hasOwnProperty("type")&&(f.type=d.enums===String?void 0===b.onnx.AttributeProto.AttributeType[l.type]?l.type:b.onnx.AttributeProto.AttributeType[l.type]:l.type),null!=l.refAttrName&&l.hasOwnProperty("refAttrName")&&(f.refAttrName=l.refAttrName),null!=l.sparseTensor&&l.hasOwnProperty("sparseTensor")&&(f.sparseTensor=b.onnx.SparseTensorProto.toObject(l.sparseTensor,d)),l.sparseTensors&&l.sparseTensors.length)for(f.sparseTensors=[],w=0;w<l.sparseTensors.length;++w)f.sparseTensors[w]=b.onnx.SparseTensorProto.toObject(l.sparseTensors[w],d);return f},h.prototype.toJSON=function(){return this.constructor.toObject(this,k.util.toJSONOptions)},h.getTypeUrl=function(l){return void 0===l&&(l="type.googleapis.com"),l+"/onnx.AttributeProto"},h.AttributeType=(l={},(d=Object.create(l))[l[0]="UNDEFINED"]=0,d[l[1]="FLOAT"]=1,d[l[2]="INT"]=2,d[l[3]="STRING"]=3,d[l[4]="TENSOR"]=4,d[l[5]="GRAPH"]=5,d[l[11]="SPARSE_TENSOR"]=11,d[l[13]="TYPE_PROTO"]=13,d[l[6]="FLOATS"]=6,d[l[7]="INTS"]=7,d[l[8]="STRINGS"]=8,d[l[9]="TENSORS"]=9,d[l[10]="GRAPHS"]=10,d[l[12]="SPARSE_TENSORS"]=12,d[l[14]="TYPE_PROTOS"]=14,d),h;var l,d}(),O.ValueInfoProto=function(){function h(l){if(l)for(var d=Object.keys(l),f=0;f<d.length;++f)null!=l[d[f]]&&(this[d[f]]=l[d[f]])}return h.prototype.name="",h.prototype.type=null,h.prototype.docString="",h.create=function(l){return new h(l)},h.encode=function(l,d){return d||(d=C.create()),null!=l.name&&Object.hasOwnProperty.call(l,"name")&&d.uint32(10).string(l.name),null!=l.type&&Object.hasOwnProperty.call(l,"type")&&b.onnx.TypeProto.encode(l.type,d.uint32(18).fork()).ldelim(),null!=l.docString&&Object.hasOwnProperty.call(l,"docString")&&d.uint32(26).string(l.docString),d},h.encodeDelimited=function(l,d){return this.encode(l,d).ldelim()},h.decode=function(l,d){l instanceof S||(l=S.create(l));for(var f=void 0===d?l.len:l.pos+d,y=new b.onnx.ValueInfoProto;l.pos<f;){var w=l.uint32();switch(w>>>3){case 1:y.name=l.string();break;case 2:y.type=b.onnx.TypeProto.decode(l,l.uint32());break;case 3:y.docString=l.string();break;default:l.skipType(7&w)}}return y},h.decodeDelimited=function(l){return l instanceof S||(l=new S(l)),this.decode(l,l.uint32())},h.verify=function(l){if("object"!=typeof l||null===l)return"object expected";if(null!=l.name&&l.hasOwnProperty("name")&&!v.isString(l.name))return"name: string expected";if(null!=l.type&&l.hasOwnProperty("type")){var d=b.onnx.TypeProto.verify(l.type);if(d)return"type."+d}return null!=l.docString&&l.hasOwnProperty("docString")&&!v.isString(l.docString)?"docString: string expected":null},h.fromObject=function(l){if(l instanceof b.onnx.ValueInfoProto)return l;var d=new b.onnx.ValueInfoProto;if(null!=l.name&&(d.name=String(l.name)),null!=l.type){if("object"!=typeof l.type)throw TypeError(".onnx.ValueInfoProto.type: object expected");d.type=b.onnx.TypeProto.fromObject(l.type)}return null!=l.docString&&(d.docString=String(l.docString)),d},h.toObject=function(l,d){d||(d={});var f={};return d.defaults&&(f.name="",f.type=null,f.docString=""),null!=l.name&&l.hasOwnProperty("name")&&(f.name=l.name),null!=l.type&&l.hasOwnProperty("type")&&(f.type=b.onnx.TypeProto.toObject(l.type,d)),null!=l.docString&&l.hasOwnProperty("docString")&&(f.docString=l.docString),f},h.prototype.toJSON=function(){return this.constructor.toObject(this,k.util.toJSONOptions)},h.getTypeUrl=function(l){return void 0===l&&(l="type.googleapis.com"),l+"/onnx.ValueInfoProto"},h}(),O.NodeProto=function(){function h(l){if(this.input=[],this.output=[],this.attribute=[],l)for(var d=Object.keys(l),f=0;f<d.length;++f)null!=l[d[f]]&&(this[d[f]]=l[d[f]])}return h.prototype.input=v.emptyArray,h.prototype.output=v.emptyArray,h.prototype.name="",h.prototype.opType="",h.prototype.domain="",h.prototype.attribute=v.emptyArray,h.prototype.docString="",h.create=function(l){return new h(l)},h.encode=function(l,d){if(d||(d=C.create()),null!=l.input&&l.input.length)for(var f=0;f<l.input.length;++f)d.uint32(10).string(l.input[f]);if(null!=l.output&&l.output.length)for(f=0;f<l.output.length;++f)d.uint32(18).string(l.output[f]);if(null!=l.name&&Object.hasOwnProperty.call(l,"name")&&d.uint32(26).string(l.name),null!=l.opType&&Object.hasOwnProperty.call(l,"opType")&&d.uint32(34).string(l.opType),null!=l.attribute&&l.attribute.length)for(f=0;f<l.attribute.length;++f)b.onnx.AttributeProto.encode(l.attribute[f],d.uint32(42).fork()).ldelim();return null!=l.docString&&Object.hasOwnProperty.call(l,"docString")&&d.uint32(50).string(l.docString),null!=l.domain&&Object.hasOwnProperty.call(l,"domain")&&d.uint32(58).string(l.domain),d},h.encodeDelimited=function(l,d){return this.encode(l,d).ldelim()},h.decode=function(l,d){l instanceof S||(l=S.create(l));for(var f=void 0===d?l.len:l.pos+d,y=new b.onnx.NodeProto;l.pos<f;){var w=l.uint32();switch(w>>>3){case 1:y.input&&y.input.length||(y.input=[]),y.input.push(l.string());break;case 2:y.output&&y.output.length||(y.output=[]),y.output.push(l.string());break;case 3:y.name=l.string();break;case 4:y.opType=l.string();break;case 7:y.domain=l.string();break;case 5:y.attribute&&y.attribute.length||(y.attribute=[]),y.attribute.push(b.onnx.AttributeProto.decode(l,l.uint32()));break;case 6:y.docString=l.string();break;default:l.skipType(7&w)}}return y},h.decodeDelimited=function(l){return l instanceof S||(l=new S(l)),this.decode(l,l.uint32())},h.verify=function(l){if("object"!=typeof l||null===l)return"object expected";if(null!=l.input&&l.hasOwnProperty("input")){if(!Array.isArray(l.input))return"input: array expected";for(var d=0;d<l.input.length;++d)if(!v.isString(l.input[d]))return"input: string[] expected"}if(null!=l.output&&l.hasOwnProperty("output")){if(!Array.isArray(l.output))return"output: array expected";for(d=0;d<l.output.length;++d)if(!v.isString(l.output[d]))return"output: string[] expected"}if(null!=l.name&&l.hasOwnProperty("name")&&!v.isString(l.name))return"name: string expected";if(null!=l.opType&&l.hasOwnProperty("opType")&&!v.isString(l.opType))return"opType: string expected";if(null!=l.domain&&l.hasOwnProperty("domain")&&!v.isString(l.domain))return"domain: string expected";if(null!=l.attribute&&l.hasOwnProperty("attribute")){if(!Array.isArray(l.attribute))return"attribute: array expected";for(d=0;d<l.attribute.length;++d){var f=b.onnx.AttributeProto.verify(l.attribute[d]);if(f)return"attribute."+f}}return null!=l.docString&&l.hasOwnProperty("docString")&&!v.isString(l.docString)?"docString: string expected":null},h.fromObject=function(l){if(l instanceof b.onnx.NodeProto)return l;var d=new b.onnx.NodeProto;if(l.input){if(!Array.isArray(l.input))throw TypeError(".onnx.NodeProto.input: array expected");d.input=[];for(var f=0;f<l.input.length;++f)d.input[f]=String(l.input[f])}if(l.output){if(!Array.isArray(l.output))throw TypeError(".onnx.NodeProto.output: array expected");for(d.output=[],f=0;f<l.output.length;++f)d.output[f]=String(l.output[f])}if(null!=l.name&&(d.name=String(l.name)),null!=l.opType&&(d.opType=String(l.opType)),null!=l.domain&&(d.domain=String(l.domain)),l.attribute){if(!Array.isArray(l.attribute))throw TypeError(".onnx.NodeProto.attribute: array expected");for(d.attribute=[],f=0;f<l.attribute.length;++f){if("object"!=typeof l.attribute[f])throw TypeError(".onnx.NodeProto.attribute: object expected");d.attribute[f]=b.onnx.AttributeProto.fromObject(l.attribute[f])}}return null!=l.docString&&(d.docString=String(l.docString)),d},h.toObject=function(l,d){d||(d={});var f={};if((d.arrays||d.defaults)&&(f.input=[],f.output=[],f.attribute=[]),d.defaults&&(f.name="",f.opType="",f.docString="",f.domain=""),l.input&&l.input.length){f.input=[];for(var y=0;y<l.input.length;++y)f.input[y]=l.input[y]}if(l.output&&l.output.length)for(f.output=[],y=0;y<l.output.length;++y)f.output[y]=l.output[y];if(null!=l.name&&l.hasOwnProperty("name")&&(f.name=l.name),null!=l.opType&&l.hasOwnProperty("opType")&&(f.opType=l.opType),l.attribute&&l.attribute.length)for(f.attribute=[],y=0;y<l.attribute.length;++y)f.attribute[y]=b.onnx.AttributeProto.toObject(l.attribute[y],d);return null!=l.docString&&l.hasOwnProperty("docString")&&(f.docString=l.docString),null!=l.domain&&l.hasOwnProperty("domain")&&(f.domain=l.domain),f},h.prototype.toJSON=function(){return this.constructor.toObject(this,k.util.toJSONOptions)},h.getTypeUrl=function(l){return void 0===l&&(l="type.googleapis.com"),l+"/onnx.NodeProto"},h}(),O.TrainingInfoProto=function(){function h(l){if(this.initializationBinding=[],this.updateBinding=[],l)for(var d=Object.keys(l),f=0;f<d.length;++f)null!=l[d[f]]&&(this[d[f]]=l[d[f]])}return h.prototype.initialization=null,h.prototype.algorithm=null,h.prototype.initializationBinding=v.emptyArray,h.prototype.updateBinding=v.emptyArray,h.create=function(l){return new h(l)},h.encode=function(l,d){if(d||(d=C.create()),null!=l.initialization&&Object.hasOwnProperty.call(l,"initialization")&&b.onnx.GraphProto.encode(l.initialization,d.uint32(10).fork()).ldelim(),null!=l.algorithm&&Object.hasOwnProperty.call(l,"algorithm")&&b.onnx.GraphProto.encode(l.algorithm,d.uint32(18).fork()).ldelim(),null!=l.initializationBinding&&l.initializationBinding.length)for(var f=0;f<l.initializationBinding.length;++f)b.onnx.StringStringEntryProto.encode(l.initializationBinding[f],d.uint32(26).fork()).ldelim();if(null!=l.updateBinding&&l.updateBinding.length)for(f=0;f<l.updateBinding.length;++f)b.onnx.StringStringEntryProto.encode(l.updateBinding[f],d.uint32(34).fork()).ldelim();return d},h.encodeDelimited=function(l,d){return this.encode(l,d).ldelim()},h.decode=function(l,d){l instanceof S||(l=S.create(l));for(var f=void 0===d?l.len:l.pos+d,y=new b.onnx.TrainingInfoProto;l.pos<f;){var w=l.uint32();switch(w>>>3){case 1:y.initialization=b.onnx.GraphProto.decode(l,l.uint32());break;case 2:y.algorithm=b.onnx.GraphProto.decode(l,l.uint32());break;case 3:y.initializationBinding&&y.initializationBinding.length||(y.initializationBinding=[]),y.initializationBinding.push(b.onnx.StringStringEntryProto.decode(l,l.uint32()));break;case 4:y.updateBinding&&y.updateBinding.length||(y.updateBinding=[]),y.updateBinding.push(b.onnx.StringStringEntryProto.decode(l,l.uint32()));break;default:l.skipType(7&w)}}return y},h.decodeDelimited=function(l){return l instanceof S||(l=new S(l)),this.decode(l,l.uint32())},h.verify=function(l){if("object"!=typeof l||null===l)return"object expected";if(null!=l.initialization&&l.hasOwnProperty("initialization")&&(f=b.onnx.GraphProto.verify(l.initialization)))return"initialization."+f;if(null!=l.algorithm&&l.hasOwnProperty("algorithm")&&(f=b.onnx.GraphProto.verify(l.algorithm)))return"algorithm."+f;if(null!=l.initializationBinding&&l.hasOwnProperty("initializationBinding")){if(!Array.isArray(l.initializationBinding))return"initializationBinding: array expected";for(var d=0;d<l.initializationBinding.length;++d)if(f=b.onnx.StringStringEntryProto.verify(l.initializationBinding[d]))return"initializationBinding."+f}if(null!=l.updateBinding&&l.hasOwnProperty("updateBinding")){if(!Array.isArray(l.updateBinding))return"updateBinding: array expected";for(d=0;d<l.updateBinding.length;++d){var f;if(f=b.onnx.StringStringEntryProto.verify(l.updateBinding[d]))return"updateBinding."+f}}return null},h.fromObject=function(l){if(l instanceof b.onnx.TrainingInfoProto)return l;var d=new b.onnx.TrainingInfoProto;if(null!=l.initialization){if("object"!=typeof l.initialization)throw TypeError(".onnx.TrainingInfoProto.initialization: object expected");d.initialization=b.onnx.GraphProto.fromObject(l.initialization)}if(null!=l.algorithm){if("object"!=typeof l.algorithm)throw TypeError(".onnx.TrainingInfoProto.algorithm: object expected");d.algorithm=b.onnx.GraphProto.fromObject(l.algorithm)}if(l.initializationBinding){if(!Array.isArray(l.initializationBinding))throw TypeError(".onnx.TrainingInfoProto.initializationBinding: array expected");d.initializationBinding=[];for(var f=0;f<l.initializationBinding.length;++f){if("object"!=typeof l.initializationBinding[f])throw TypeError(".onnx.TrainingInfoProto.initializationBinding: object expected");d.initializationBinding[f]=b.onnx.StringStringEntryProto.fromObject(l.initializationBinding[f])}}if(l.updateBinding){if(!Array.isArray(l.updateBinding))throw TypeError(".onnx.TrainingInfoProto.updateBinding: array expected");for(d.updateBinding=[],f=0;f<l.updateBinding.length;++f){if("object"!=typeof l.updateBinding[f])throw TypeError(".onnx.TrainingInfoProto.updateBinding: object expected");d.updateBinding[f]=b.onnx.StringStringEntryProto.fromObject(l.updateBinding[f])}}return d},h.toObject=function(l,d){d||(d={});var f={};if((d.arrays||d.defaults)&&(f.initializationBinding=[],f.updateBinding=[]),d.defaults&&(f.initialization=null,f.algorithm=null),null!=l.initialization&&l.hasOwnProperty("initialization")&&(f.initialization=b.onnx.GraphProto.toObject(l.initialization,d)),null!=l.algorithm&&l.hasOwnProperty("algorithm")&&(f.algorithm=b.onnx.GraphProto.toObject(l.algorithm,d)),l.initializationBinding&&l.initializationBinding.length){f.initializationBinding=[];for(var y=0;y<l.initializationBinding.length;++y)f.initializationBinding[y]=b.onnx.StringStringEntryProto.toObject(l.initializationBinding[y],d)}if(l.updateBinding&&l.updateBinding.length)for(f.updateBinding=[],y=0;y<l.updateBinding.length;++y)f.updateBinding[y]=b.onnx.StringStringEntryProto.toObject(l.updateBinding[y],d);return f},h.prototype.toJSON=function(){return this.constructor.toObject(this,k.util.toJSONOptions)},h.getTypeUrl=function(l){return void 0===l&&(l="type.googleapis.com"),l+"/onnx.TrainingInfoProto"},h}(),O.ModelProto=function(){function h(l){if(this.opsetImport=[],this.metadataProps=[],this.trainingInfo=[],this.functions=[],l)for(var d=Object.keys(l),f=0;f<d.length;++f)null!=l[d[f]]&&(this[d[f]]=l[d[f]])}return h.prototype.irVersion=v.Long?v.Long.fromBits(0,0,!1):0,h.prototype.opsetImport=v.emptyArray,h.prototype.producerName="",h.prototype.producerVersion="",h.prototype.domain="",h.prototype.modelVersion=v.Long?v.Long.fromBits(0,0,!1):0,h.prototype.docString="",h.prototype.graph=null,h.prototype.metadataProps=v.emptyArray,h.prototype.trainingInfo=v.emptyArray,h.prototype.functions=v.emptyArray,h.create=function(l){return new h(l)},h.encode=function(l,d){if(d||(d=C.create()),null!=l.irVersion&&Object.hasOwnProperty.call(l,"irVersion")&&d.uint32(8).int64(l.irVersion),null!=l.producerName&&Object.hasOwnProperty.call(l,"producerName")&&d.uint32(18).string(l.producerName),null!=l.producerVersion&&Object.hasOwnProperty.call(l,"producerVersion")&&d.uint32(26).string(l.producerVersion),null!=l.domain&&Object.hasOwnProperty.call(l,"domain")&&d.uint32(34).string(l.domain),null!=l.modelVersion&&Object.hasOwnProperty.call(l,"modelVersion")&&d.uint32(40).int64(l.modelVersion),null!=l.docString&&Object.hasOwnProperty.call(l,"docString")&&d.uint32(50).string(l.docString),null!=l.graph&&Object.hasOwnProperty.call(l,"graph")&&b.onnx.GraphProto.encode(l.graph,d.uint32(58).fork()).ldelim(),null!=l.opsetImport&&l.opsetImport.length)for(var f=0;f<l.opsetImport.length;++f)b.onnx.OperatorSetIdProto.encode(l.opsetImport[f],d.uint32(66).fork()).ldelim();if(null!=l.metadataProps&&l.metadataProps.length)for(f=0;f<l.metadataProps.length;++f)b.onnx.StringStringEntryProto.encode(l.metadataProps[f],d.uint32(114).fork()).ldelim();if(null!=l.trainingInfo&&l.trainingInfo.length)for(f=0;f<l.trainingInfo.length;++f)b.onnx.TrainingInfoProto.encode(l.trainingInfo[f],d.uint32(162).fork()).ldelim();if(null!=l.functions&&l.functions.length)for(f=0;f<l.functions.length;++f)b.onnx.FunctionProto.encode(l.functions[f],d.uint32(202).fork()).ldelim();return d},h.encodeDelimited=function(l,d){return this.encode(l,d).ldelim()},h.decode=function(l,d){l instanceof S||(l=S.create(l));for(var f=void 0===d?l.len:l.pos+d,y=new b.onnx.ModelProto;l.pos<f;){var w=l.uint32();switch(w>>>3){case 1:y.irVersion=l.int64();break;case 8:y.opsetImport&&y.opsetImport.length||(y.opsetImport=[]),y.opsetImport.push(b.onnx.OperatorSetIdProto.decode(l,l.uint32()));break;case 2:y.producerName=l.string();break;case 3:y.producerVersion=l.string();break;case 4:y.domain=l.string();break;case 5:y.modelVersion=l.int64();break;case 6:y.docString=l.string();break;case 7:y.graph=b.onnx.GraphProto.decode(l,l.uint32());break;case 14:y.metadataProps&&y.metadataProps.length||(y.metadataProps=[]),y.metadataProps.push(b.onnx.StringStringEntryProto.decode(l,l.uint32()));break;case 20:y.trainingInfo&&y.trainingInfo.length||(y.trainingInfo=[]),y.trainingInfo.push(b.onnx.TrainingInfoProto.decode(l,l.uint32()));break;case 25:y.functions&&y.functions.length||(y.functions=[]),y.functions.push(b.onnx.FunctionProto.decode(l,l.uint32()));break;default:l.skipType(7&w)}}return y},h.decodeDelimited=function(l){return l instanceof S||(l=new S(l)),this.decode(l,l.uint32())},h.verify=function(l){if("object"!=typeof l||null===l)return"object expected";if(null!=l.irVersion&&l.hasOwnProperty("irVersion")&&!(v.isInteger(l.irVersion)||l.irVersion&&v.isInteger(l.irVersion.low)&&v.isInteger(l.irVersion.high)))return"irVersion: integer|Long expected";if(null!=l.opsetImport&&l.hasOwnProperty("opsetImport")){if(!Array.isArray(l.opsetImport))return"opsetImport: array expected";for(var d=0;d<l.opsetImport.length;++d)if(f=b.onnx.OperatorSetIdProto.verify(l.opsetImport[d]))return"opsetImport."+f}if(null!=l.producerName&&l.hasOwnProperty("producerName")&&!v.isString(l.producerName))return"producerName: string expected";if(null!=l.producerVersion&&l.hasOwnProperty("producerVersion")&&!v.isString(l.producerVersion))return"producerVersion: string expected";if(null!=l.domain&&l.hasOwnProperty("domain")&&!v.isString(l.domain))return"domain: string expected";if(null!=l.modelVersion&&l.hasOwnProperty("modelVersion")&&!(v.isInteger(l.modelVersion)||l.modelVersion&&v.isInteger(l.modelVersion.low)&&v.isInteger(l.modelVersion.high)))return"modelVersion: integer|Long expected";if(null!=l.docString&&l.hasOwnProperty("docString")&&!v.isString(l.docString))return"docString: string expected";if(null!=l.graph&&l.hasOwnProperty("graph")&&(f=b.onnx.GraphProto.verify(l.graph)))return"graph."+f;if(null!=l.metadataProps&&l.hasOwnProperty("metadataProps")){if(!Array.isArray(l.metadataProps))return"metadataProps: array expected";for(d=0;d<l.metadataProps.length;++d)if(f=b.onnx.StringStringEntryProto.verify(l.metadataProps[d]))return"metadataProps."+f}if(null!=l.trainingInfo&&l.hasOwnProperty("trainingInfo")){if(!Array.isArray(l.trainingInfo))return"trainingInfo: array expected";for(d=0;d<l.trainingInfo.length;++d)if(f=b.onnx.TrainingInfoProto.verify(l.trainingInfo[d]))return"trainingInfo."+f}if(null!=l.functions&&l.hasOwnProperty("functions")){if(!Array.isArray(l.functions))return"functions: array expected";for(d=0;d<l.functions.length;++d){var f;if(f=b.onnx.FunctionProto.verify(l.functions[d]))return"functions."+f}}return null},h.fromObject=function(l){if(l instanceof b.onnx.ModelProto)return l;var d=new b.onnx.ModelProto;if(null!=l.irVersion&&(v.Long?(d.irVersion=v.Long.fromValue(l.irVersion)).unsigned=!1:"string"==typeof l.irVersion?d.irVersion=parseInt(l.irVersion,10):"number"==typeof l.irVersion?d.irVersion=l.irVersion:"object"==typeof l.irVersion&&(d.irVersion=new v.LongBits(l.irVersion.low>>>0,l.irVersion.high>>>0).toNumber())),l.opsetImport){if(!Array.isArray(l.opsetImport))throw TypeError(".onnx.ModelProto.opsetImport: array expected");d.opsetImport=[];for(var f=0;f<l.opsetImport.length;++f){if("object"!=typeof l.opsetImport[f])throw TypeError(".onnx.ModelProto.opsetImport: object expected");d.opsetImport[f]=b.onnx.OperatorSetIdProto.fromObject(l.opsetImport[f])}}if(null!=l.producerName&&(d.producerName=String(l.producerName)),null!=l.producerVersion&&(d.producerVersion=String(l.producerVersion)),null!=l.domain&&(d.domain=String(l.domain)),null!=l.modelVersion&&(v.Long?(d.modelVersion=v.Long.fromValue(l.modelVersion)).unsigned=!1:"string"==typeof l.modelVersion?d.modelVersion=parseInt(l.modelVersion,10):"number"==typeof l.modelVersion?d.modelVersion=l.modelVersion:"object"==typeof l.modelVersion&&(d.modelVersion=new v.LongBits(l.modelVersion.low>>>0,l.modelVersion.high>>>0).toNumber())),null!=l.docString&&(d.docString=String(l.docString)),null!=l.graph){if("object"!=typeof l.graph)throw TypeError(".onnx.ModelProto.graph: object expected");d.graph=b.onnx.GraphProto.fromObject(l.graph)}if(l.metadataProps){if(!Array.isArray(l.metadataProps))throw TypeError(".onnx.ModelProto.metadataProps: array expected");for(d.metadataProps=[],f=0;f<l.metadataProps.length;++f){if("object"!=typeof l.metadataProps[f])throw TypeError(".onnx.ModelProto.metadataProps: object expected");d.metadataProps[f]=b.onnx.StringStringEntryProto.fromObject(l.metadataProps[f])}}if(l.trainingInfo){if(!Array.isArray(l.trainingInfo))throw TypeError(".onnx.ModelProto.trainingInfo: array expected");for(d.trainingInfo=[],f=0;f<l.trainingInfo.length;++f){if("object"!=typeof l.trainingInfo[f])throw TypeError(".onnx.ModelProto.trainingInfo: object expected");d.trainingInfo[f]=b.onnx.TrainingInfoProto.fromObject(l.trainingInfo[f])}}if(l.functions){if(!Array.isArray(l.functions))throw TypeError(".onnx.ModelProto.functions: array expected");for(d.functions=[],f=0;f<l.functions.length;++f){if("object"!=typeof l.functions[f])throw TypeError(".onnx.ModelProto.functions: object expected");d.functions[f]=b.onnx.FunctionProto.fromObject(l.functions[f])}}return d},h.toObject=function(l,d){d||(d={});var f={};if((d.arrays||d.defaults)&&(f.opsetImport=[],f.metadataProps=[],f.trainingInfo=[],f.functions=[]),d.defaults){if(v.Long){var y=new v.Long(0,0,!1);f.irVersion=d.longs===String?y.toString():d.longs===Number?y.toNumber():y}else f.irVersion=d.longs===String?"0":0;f.producerName="",f.producerVersion="",f.domain="",v.Long?(y=new v.Long(0,0,!1),f.modelVersion=d.longs===String?y.toString():d.longs===Number?y.toNumber():y):f.modelVersion=d.longs===String?"0":0,f.docString="",f.graph=null}if(null!=l.irVersion&&l.hasOwnProperty("irVersion")&&(f.irVersion="number"==typeof l.irVersion?d.longs===String?String(l.irVersion):l.irVersion:d.longs===String?v.Long.prototype.toString.call(l.irVersion):d.longs===Number?new v.LongBits(l.irVersion.low>>>0,l.irVersion.high>>>0).toNumber():l.irVersion),null!=l.producerName&&l.hasOwnProperty("producerName")&&(f.producerName=l.producerName),null!=l.producerVersion&&l.hasOwnProperty("producerVersion")&&(f.producerVersion=l.producerVersion),null!=l.domain&&l.hasOwnProperty("domain")&&(f.domain=l.domain),null!=l.modelVersion&&l.hasOwnProperty("modelVersion")&&(f.modelVersion="number"==typeof l.modelVersion?d.longs===String?String(l.modelVersion):l.modelVersion:d.longs===String?v.Long.prototype.toString.call(l.modelVersion):d.longs===Number?new v.LongBits(l.modelVersion.low>>>0,l.modelVersion.high>>>0).toNumber():l.modelVersion),null!=l.docString&&l.hasOwnProperty("docString")&&(f.docString=l.docString),null!=l.graph&&l.hasOwnProperty("graph")&&(f.graph=b.onnx.GraphProto.toObject(l.graph,d)),l.opsetImport&&l.opsetImport.length){f.opsetImport=[];for(var w=0;w<l.opsetImport.length;++w)f.opsetImport[w]=b.onnx.OperatorSetIdProto.toObject(l.opsetImport[w],d)}if(l.metadataProps&&l.metadataProps.length)for(f.metadataProps=[],w=0;w<l.metadataProps.length;++w)f.metadataProps[w]=b.onnx.StringStringEntryProto.toObject(l.metadataProps[w],d);if(l.trainingInfo&&l.trainingInfo.length)for(f.trainingInfo=[],w=0;w<l.trainingInfo.length;++w)f.trainingInfo[w]=b.onnx.TrainingInfoProto.toObject(l.trainingInfo[w],d);if(l.functions&&l.functions.length)for(f.functions=[],w=0;w<l.functions.length;++w)f.functions[w]=b.onnx.FunctionProto.toObject(l.functions[w],d);return f},h.prototype.toJSON=function(){return this.constructor.toObject(this,k.util.toJSONOptions)},h.getTypeUrl=function(l){return void 0===l&&(l="type.googleapis.com"),l+"/onnx.ModelProto"},h}(),O.StringStringEntryProto=function(){function h(l){if(l)for(var d=Object.keys(l),f=0;f<d.length;++f)null!=l[d[f]]&&(this[d[f]]=l[d[f]])}return h.prototype.key="",h.prototype.value="",h.create=function(l){return new h(l)},h.encode=function(l,d){return d||(d=C.create()),null!=l.key&&Object.hasOwnProperty.call(l,"key")&&d.uint32(10).string(l.key),null!=l.value&&Object.hasOwnProperty.call(l,"value")&&d.uint32(18).string(l.value),d},h.encodeDelimited=function(l,d){return this.encode(l,d).ldelim()},h.decode=function(l,d){l instanceof S||(l=S.create(l));for(var f=void 0===d?l.len:l.pos+d,y=new b.onnx.StringStringEntryProto;l.pos<f;){var w=l.uint32();switch(w>>>3){case 1:y.key=l.string();break;case 2:y.value=l.string();break;default:l.skipType(7&w)}}return y},h.decodeDelimited=function(l){return l instanceof S||(l=new S(l)),this.decode(l,l.uint32())},h.verify=function(l){return"object"!=typeof l||null===l?"object expected":null!=l.key&&l.hasOwnProperty("key")&&!v.isString(l.key)?"key: string expected":null!=l.value&&l.hasOwnProperty("value")&&!v.isString(l.value)?"value: string expected":null},h.fromObject=function(l){if(l instanceof b.onnx.StringStringEntryProto)return l;var d=new b.onnx.StringStringEntryProto;return null!=l.key&&(d.key=String(l.key)),null!=l.value&&(d.value=String(l.value)),d},h.toObject=function(l,d){d||(d={});var f={};return d.defaults&&(f.key="",f.value=""),null!=l.key&&l.hasOwnProperty("key")&&(f.key=l.key),null!=l.value&&l.hasOwnProperty("value")&&(f.value=l.value),f},h.prototype.toJSON=function(){return this.constructor.toObject(this,k.util.toJSONOptions)},h.getTypeUrl=function(l){return void 0===l&&(l="type.googleapis.com"),l+"/onnx.StringStringEntryProto"},h}(),O.TensorAnnotation=function(){function h(l){if(this.quantParameterTensorNames=[],l)for(var d=Object.keys(l),f=0;f<d.length;++f)null!=l[d[f]]&&(this[d[f]]=l[d[f]])}return h.prototype.tensorName="",h.prototype.quantParameterTensorNames=v.emptyArray,h.create=function(l){return new h(l)},h.encode=function(l,d){if(d||(d=C.create()),null!=l.tensorName&&Object.hasOwnProperty.call(l,"tensorName")&&d.uint32(10).string(l.tensorName),null!=l.quantParameterTensorNames&&l.quantParameterTensorNames.length)for(var f=0;f<l.quantParameterTensorNames.length;++f)b.onnx.StringStringEntryProto.encode(l.quantParameterTensorNames[f],d.uint32(18).fork()).ldelim();return d},h.encodeDelimited=function(l,d){return this.encode(l,d).ldelim()},h.decode=function(l,d){l instanceof S||(l=S.create(l));for(var f=void 0===d?l.len:l.pos+d,y=new b.onnx.TensorAnnotation;l.pos<f;){var w=l.uint32();switch(w>>>3){case 1:y.tensorName=l.string();break;case 2:y.quantParameterTensorNames&&y.quantParameterTensorNames.length||(y.quantParameterTensorNames=[]),y.quantParameterTensorNames.push(b.onnx.StringStringEntryProto.decode(l,l.uint32()));break;default:l.skipType(7&w)}}return y},h.decodeDelimited=function(l){return l instanceof S||(l=new S(l)),this.decode(l,l.uint32())},h.verify=function(l){if("object"!=typeof l||null===l)return"object expected";if(null!=l.tensorName&&l.hasOwnProperty("tensorName")&&!v.isString(l.tensorName))return"tensorName: string expected";if(null!=l.quantParameterTensorNames&&l.hasOwnProperty("quantParameterTensorNames")){if(!Array.isArray(l.quantParameterTensorNames))return"quantParameterTensorNames: array expected";for(var d=0;d<l.quantParameterTensorNames.length;++d){var f=b.onnx.StringStringEntryProto.verify(l.quantParameterTensorNames[d]);if(f)return"quantParameterTensorNames."+f}}return null},h.fromObject=function(l){if(l instanceof b.onnx.TensorAnnotation)return l;var d=new b.onnx.TensorAnnotation;if(null!=l.tensorName&&(d.tensorName=String(l.tensorName)),l.quantParameterTensorNames){if(!Array.isArray(l.quantParameterTensorNames))throw TypeError(".onnx.TensorAnnotation.quantParameterTensorNames: array expected");d.quantParameterTensorNames=[];for(var f=0;f<l.quantParameterTensorNames.length;++f){if("object"!=typeof l.quantParameterTensorNames[f])throw TypeError(".onnx.TensorAnnotation.quantParameterTensorNames: object expected");d.quantParameterTensorNames[f]=b.onnx.StringStringEntryProto.fromObject(l.quantParameterTensorNames[f])}}return d},h.toObject=function(l,d){d||(d={});var f={};if((d.arrays||d.defaults)&&(f.quantParameterTensorNames=[]),d.defaults&&(f.tensorName=""),null!=l.tensorName&&l.hasOwnProperty("tensorName")&&(f.tensorName=l.tensorName),l.quantParameterTensorNames&&l.quantParameterTensorNames.length){f.quantParameterTensorNames=[];for(var y=0;y<l.quantParameterTensorNames.length;++y)f.quantParameterTensorNames[y]=b.onnx.StringStringEntryProto.toObject(l.quantParameterTensorNames[y],d)}return f},h.prototype.toJSON=function(){return this.constructor.toObject(this,k.util.toJSONOptions)},h.getTypeUrl=function(l){return void 0===l&&(l="type.googleapis.com"),l+"/onnx.TensorAnnotation"},h}(),O.GraphProto=function(){function h(l){if(this.node=[],this.initializer=[],this.sparseInitializer=[],this.input=[],this.output=[],this.valueInfo=[],this.quantizationAnnotation=[],l)for(var d=Object.keys(l),f=0;f<d.length;++f)null!=l[d[f]]&&(this[d[f]]=l[d[f]])}return h.prototype.node=v.emptyArray,h.prototype.name="",h.prototype.initializer=v.emptyArray,h.prototype.sparseInitializer=v.emptyArray,h.prototype.docString="",h.prototype.input=v.emptyArray,h.prototype.output=v.emptyArray,h.prototype.valueInfo=v.emptyArray,h.prototype.quantizationAnnotation=v.emptyArray,h.create=function(l){return new h(l)},h.encode=function(l,d){if(d||(d=C.create()),null!=l.node&&l.node.length)for(var f=0;f<l.node.length;++f)b.onnx.NodeProto.encode(l.node[f],d.uint32(10).fork()).ldelim();if(null!=l.name&&Object.hasOwnProperty.call(l,"name")&&d.uint32(18).string(l.name),null!=l.initializer&&l.initializer.length)for(f=0;f<l.initializer.length;++f)b.onnx.TensorProto.encode(l.initializer[f],d.uint32(42).fork()).ldelim();if(null!=l.docString&&Object.hasOwnProperty.call(l,"docString")&&d.uint32(82).string(l.docString),null!=l.input&&l.input.length)for(f=0;f<l.input.length;++f)b.onnx.ValueInfoProto.encode(l.input[f],d.uint32(90).fork()).ldelim();if(null!=l.output&&l.output.length)for(f=0;f<l.output.length;++f)b.onnx.ValueInfoProto.encode(l.output[f],d.uint32(98).fork()).ldelim();if(null!=l.valueInfo&&l.valueInfo.length)for(f=0;f<l.valueInfo.length;++f)b.onnx.ValueInfoProto.encode(l.valueInfo[f],d.uint32(106).fork()).ldelim();if(null!=l.quantizationAnnotation&&l.quantizationAnnotation.length)for(f=0;f<l.quantizationAnnotation.length;++f)b.onnx.TensorAnnotation.encode(l.quantizationAnnotation[f],d.uint32(114).fork()).ldelim();if(null!=l.sparseInitializer&&l.sparseInitializer.length)for(f=0;f<l.sparseInitializer.length;++f)b.onnx.SparseTensorProto.encode(l.sparseInitializer[f],d.uint32(122).fork()).ldelim();return d},h.encodeDelimited=function(l,d){return this.encode(l,d).ldelim()},h.decode=function(l,d){l instanceof S||(l=S.create(l));for(var f=void 0===d?l.len:l.pos+d,y=new b.onnx.GraphProto;l.pos<f;){var w=l.uint32();switch(w>>>3){case 1:y.node&&y.node.length||(y.node=[]),y.node.push(b.onnx.NodeProto.decode(l,l.uint32()));break;case 2:y.name=l.string();break;case 5:y.initializer&&y.initializer.length||(y.initializer=[]),y.initializer.push(b.onnx.TensorProto.decode(l,l.uint32()));break;case 15:y.sparseInitializer&&y.sparseInitializer.length||(y.sparseInitializer=[]),y.sparseInitializer.push(b.onnx.SparseTensorProto.decode(l,l.uint32()));break;case 10:y.docString=l.string();break;case 11:y.input&&y.input.length||(y.input=[]),y.input.push(b.onnx.ValueInfoProto.decode(l,l.uint32()));break;case 12:y.output&&y.output.length||(y.output=[]),y.output.push(b.onnx.ValueInfoProto.decode(l,l.uint32()));break;case 13:y.valueInfo&&y.valueInfo.length||(y.valueInfo=[]),y.valueInfo.push(b.onnx.ValueInfoProto.decode(l,l.uint32()));break;case 14:y.quantizationAnnotation&&y.quantizationAnnotation.length||(y.quantizationAnnotation=[]),y.quantizationAnnotation.push(b.onnx.TensorAnnotation.decode(l,l.uint32()));break;default:l.skipType(7&w)}}return y},h.decodeDelimited=function(l){return l instanceof S||(l=new S(l)),this.decode(l,l.uint32())},h.verify=function(l){if("object"!=typeof l||null===l)return"object expected";if(null!=l.node&&l.hasOwnProperty("node")){if(!Array.isArray(l.node))return"node: array expected";for(var d=0;d<l.node.length;++d)if(f=b.onnx.NodeProto.verify(l.node[d]))return"node."+f}if(null!=l.name&&l.hasOwnProperty("name")&&!v.isString(l.name))return"name: string expected";if(null!=l.initializer&&l.hasOwnProperty("initializer")){if(!Array.isArray(l.initializer))return"initializer: array expected";for(d=0;d<l.initializer.length;++d)if(f=b.onnx.TensorProto.verify(l.initializer[d]))return"initializer."+f}if(null!=l.sparseInitializer&&l.hasOwnProperty("sparseInitializer")){if(!Array.isArray(l.sparseInitializer))return"sparseInitializer: array expected";for(d=0;d<l.sparseInitializer.length;++d)if(f=b.onnx.SparseTensorProto.verify(l.sparseInitializer[d]))return"sparseInitializer."+f}if(null!=l.docString&&l.hasOwnProperty("docString")&&!v.isString(l.docString))return"docString: string expected";if(null!=l.input&&l.hasOwnProperty("input")){if(!Array.isArray(l.input))return"input: array expected";for(d=0;d<l.input.length;++d)if(f=b.onnx.ValueInfoProto.verify(l.input[d]))return"input."+f}if(null!=l.output&&l.hasOwnProperty("output")){if(!Array.isArray(l.output))return"output: array expected";for(d=0;d<l.output.length;++d)if(f=b.onnx.ValueInfoProto.verify(l.output[d]))return"output."+f}if(null!=l.valueInfo&&l.hasOwnProperty("valueInfo")){if(!Array.isArray(l.valueInfo))return"valueInfo: array expected";for(d=0;d<l.valueInfo.length;++d)if(f=b.onnx.ValueInfoProto.verify(l.valueInfo[d]))return"valueInfo."+f}if(null!=l.quantizationAnnotation&&l.hasOwnProperty("quantizationAnnotation")){if(!Array.isArray(l.quantizationAnnotation))return"quantizationAnnotation: array expected";for(d=0;d<l.quantizationAnnotation.length;++d){var f;if(f=b.onnx.TensorAnnotation.verify(l.quantizationAnnotation[d]))return"quantizationAnnotation."+f}}return null},h.fromObject=function(l){if(l instanceof b.onnx.GraphProto)return l;var d=new b.onnx.GraphProto;if(l.node){if(!Array.isArray(l.node))throw TypeError(".onnx.GraphProto.node: array expected");d.node=[];for(var f=0;f<l.node.length;++f){if("object"!=typeof l.node[f])throw TypeError(".onnx.GraphProto.node: object expected");d.node[f]=b.onnx.NodeProto.fromObject(l.node[f])}}if(null!=l.name&&(d.name=String(l.name)),l.initializer){if(!Array.isArray(l.initializer))throw TypeError(".onnx.GraphProto.initializer: array expected");for(d.initializer=[],f=0;f<l.initializer.length;++f){if("object"!=typeof l.initializer[f])throw TypeError(".onnx.GraphProto.initializer: object expected");d.initializer[f]=b.onnx.TensorProto.fromObject(l.initializer[f])}}if(l.sparseInitializer){if(!Array.isArray(l.sparseInitializer))throw TypeError(".onnx.GraphProto.sparseInitializer: array expected");for(d.sparseInitializer=[],f=0;f<l.sparseInitializer.length;++f){if("object"!=typeof l.sparseInitializer[f])throw TypeError(".onnx.GraphProto.sparseInitializer: object expected");d.sparseInitializer[f]=b.onnx.SparseTensorProto.fromObject(l.sparseInitializer[f])}}if(null!=l.docString&&(d.docString=String(l.docString)),l.input){if(!Array.isArray(l.input))throw TypeError(".onnx.GraphProto.input: array expected");for(d.input=[],f=0;f<l.input.length;++f){if("object"!=typeof l.input[f])throw TypeError(".onnx.GraphProto.input: object expected");d.input[f]=b.onnx.ValueInfoProto.fromObject(l.input[f])}}if(l.output){if(!Array.isArray(l.output))throw TypeError(".onnx.GraphProto.output: array expected");for(d.output=[],f=0;f<l.output.length;++f){if("object"!=typeof l.output[f])throw TypeError(".onnx.GraphProto.output: object expected");d.output[f]=b.onnx.ValueInfoProto.fromObject(l.output[f])}}if(l.valueInfo){if(!Array.isArray(l.valueInfo))throw TypeError(".onnx.GraphProto.valueInfo: array expected");for(d.valueInfo=[],f=0;f<l.valueInfo.length;++f){if("object"!=typeof l.valueInfo[f])throw TypeError(".onnx.GraphProto.valueInfo: object expected");d.valueInfo[f]=b.onnx.ValueInfoProto.fromObject(l.valueInfo[f])}}if(l.quantizationAnnotation){if(!Array.isArray(l.quantizationAnnotation))throw TypeError(".onnx.GraphProto.quantizationAnnotation: array expected");for(d.quantizationAnnotation=[],f=0;f<l.quantizationAnnotation.length;++f){if("object"!=typeof l.quantizationAnnotation[f])throw TypeError(".onnx.GraphProto.quantizationAnnotation: object expected");d.quantizationAnnotation[f]=b.onnx.TensorAnnotation.fromObject(l.quantizationAnnotation[f])}}return d},h.toObject=function(l,d){d||(d={});var f={};if((d.arrays||d.defaults)&&(f.node=[],f.initializer=[],f.input=[],f.output=[],f.valueInfo=[],f.quantizationAnnotation=[],f.sparseInitializer=[]),d.defaults&&(f.name="",f.docString=""),l.node&&l.node.length){f.node=[];for(var y=0;y<l.node.length;++y)f.node[y]=b.onnx.NodeProto.toObject(l.node[y],d)}if(null!=l.name&&l.hasOwnProperty("name")&&(f.name=l.name),l.initializer&&l.initializer.length)for(f.initializer=[],y=0;y<l.initializer.length;++y)f.initializer[y]=b.onnx.TensorProto.toObject(l.initializer[y],d);if(null!=l.docString&&l.hasOwnProperty("docString")&&(f.docString=l.docString),l.input&&l.input.length)for(f.input=[],y=0;y<l.input.length;++y)f.input[y]=b.onnx.ValueInfoProto.toObject(l.input[y],d);if(l.output&&l.output.length)for(f.output=[],y=0;y<l.output.length;++y)f.output[y]=b.onnx.ValueInfoProto.toObject(l.output[y],d);if(l.valueInfo&&l.valueInfo.length)for(f.valueInfo=[],y=0;y<l.valueInfo.length;++y)f.valueInfo[y]=b.onnx.ValueInfoProto.toObject(l.valueInfo[y],d);if(l.quantizationAnnotation&&l.quantizationAnnotation.length)for(f.quantizationAnnotation=[],y=0;y<l.quantizationAnnotation.length;++y)f.quantizationAnnotation[y]=b.onnx.TensorAnnotation.toObject(l.quantizationAnnotation[y],d);if(l.sparseInitializer&&l.sparseInitializer.length)for(f.sparseInitializer=[],y=0;y<l.sparseInitializer.length;++y)f.sparseInitializer[y]=b.onnx.SparseTensorProto.toObject(l.sparseInitializer[y],d);return f},h.prototype.toJSON=function(){return this.constructor.toObject(this,k.util.toJSONOptions)},h.getTypeUrl=function(l){return void 0===l&&(l="type.googleapis.com"),l+"/onnx.GraphProto"},h}(),O.TensorProto=function(){function h(l){if(this.dims=[],this.floatData=[],this.int32Data=[],this.stringData=[],this.int64Data=[],this.externalData=[],this.doubleData=[],this.uint64Data=[],l)for(var d=Object.keys(l),f=0;f<d.length;++f)null!=l[d[f]]&&(this[d[f]]=l[d[f]])}return h.prototype.dims=v.emptyArray,h.prototype.dataType=0,h.prototype.segment=null,h.prototype.floatData=v.emptyArray,h.prototype.int32Data=v.emptyArray,h.prototype.stringData=v.emptyArray,h.prototype.int64Data=v.emptyArray,h.prototype.name="",h.prototype.docString="",h.prototype.rawData=v.newBuffer([]),h.prototype.externalData=v.emptyArray,h.prototype.dataLocation=0,h.prototype.doubleData=v.emptyArray,h.prototype.uint64Data=v.emptyArray,h.create=function(l){return new h(l)},h.encode=function(l,d){if(d||(d=C.create()),null!=l.dims&&l.dims.length){d.uint32(10).fork();for(var f=0;f<l.dims.length;++f)d.int64(l.dims[f]);d.ldelim()}if(null!=l.dataType&&Object.hasOwnProperty.call(l,"dataType")&&d.uint32(16).int32(l.dataType),null!=l.segment&&Object.hasOwnProperty.call(l,"segment")&&b.onnx.TensorProto.Segment.encode(l.segment,d.uint32(26).fork()).ldelim(),null!=l.floatData&&l.floatData.length){for(d.uint32(34).fork(),f=0;f<l.floatData.length;++f)d.float(l.floatData[f]);d.ldelim()}if(null!=l.int32Data&&l.int32Data.length){for(d.uint32(42).fork(),f=0;f<l.int32Data.length;++f)d.int32(l.int32Data[f]);d.ldelim()}if(null!=l.stringData&&l.stringData.length)for(f=0;f<l.stringData.length;++f)d.uint32(50).bytes(l.stringData[f]);if(null!=l.int64Data&&l.int64Data.length){for(d.uint32(58).fork(),f=0;f<l.int64Data.length;++f)d.int64(l.int64Data[f]);d.ldelim()}if(null!=l.name&&Object.hasOwnProperty.call(l,"name")&&d.uint32(66).string(l.name),null!=l.rawData&&Object.hasOwnProperty.call(l,"rawData")&&d.uint32(74).bytes(l.rawData),null!=l.doubleData&&l.doubleData.length){for(d.uint32(82).fork(),f=0;f<l.doubleData.length;++f)d.double(l.doubleData[f]);d.ldelim()}if(null!=l.uint64Data&&l.uint64Data.length){for(d.uint32(90).fork(),f=0;f<l.uint64Data.length;++f)d.uint64(l.uint64Data[f]);d.ldelim()}if(null!=l.docString&&Object.hasOwnProperty.call(l,"docString")&&d.uint32(98).string(l.docString),null!=l.externalData&&l.externalData.length)for(f=0;f<l.externalData.length;++f)b.onnx.StringStringEntryProto.encode(l.externalData[f],d.uint32(106).fork()).ldelim();return null!=l.dataLocation&&Object.hasOwnProperty.call(l,"dataLocation")&&d.uint32(112).int32(l.dataLocation),d},h.encodeDelimited=function(l,d){return this.encode(l,d).ldelim()},h.decode=function(l,d){l instanceof S||(l=S.create(l));for(var f=void 0===d?l.len:l.pos+d,y=new b.onnx.TensorProto;l.pos<f;){var w=l.uint32();switch(w>>>3){case 1:if(y.dims&&y.dims.length||(y.dims=[]),2==(7&w))for(var D=l.uint32()+l.pos;l.pos<D;)y.dims.push(l.int64());else y.dims.push(l.int64());break;case 2:y.dataType=l.int32();break;case 3:y.segment=b.onnx.TensorProto.Segment.decode(l,l.uint32());break;case 4:if(y.floatData&&y.floatData.length||(y.floatData=[]),2==(7&w))for(D=l.uint32()+l.pos;l.pos<D;)y.floatData.push(l.float());else y.floatData.push(l.float());break;case 5:if(y.int32Data&&y.int32Data.length||(y.int32Data=[]),2==(7&w))for(D=l.uint32()+l.pos;l.pos<D;)y.int32Data.push(l.int32());else y.int32Data.push(l.int32());break;case 6:y.stringData&&y.stringData.length||(y.stringData=[]),y.stringData.push(l.bytes());break;case 7:if(y.int64Data&&y.int64Data.length||(y.int64Data=[]),2==(7&w))for(D=l.uint32()+l.pos;l.pos<D;)y.int64Data.push(l.int64());else y.int64Data.push(l.int64());break;case 8:y.name=l.string();break;case 12:y.docString=l.string();break;case 9:y.rawData=l.bytes();break;case 13:y.externalData&&y.externalData.length||(y.externalData=[]),y.externalData.push(b.onnx.StringStringEntryProto.decode(l,l.uint32()));break;case 14:y.dataLocation=l.int32();break;case 10:if(y.doubleData&&y.doubleData.length||(y.doubleData=[]),2==(7&w))for(D=l.uint32()+l.pos;l.pos<D;)y.doubleData.push(l.double());else y.doubleData.push(l.double());break;case 11:if(y.uint64Data&&y.uint64Data.length||(y.uint64Data=[]),2==(7&w))for(D=l.uint32()+l.pos;l.pos<D;)y.uint64Data.push(l.uint64());else y.uint64Data.push(l.uint64());break;default:l.skipType(7&w)}}return y},h.decodeDelimited=function(l){return l instanceof S||(l=new S(l)),this.decode(l,l.uint32())},h.verify=function(l){if("object"!=typeof l||null===l)return"object expected";if(null!=l.dims&&l.hasOwnProperty("dims")){if(!Array.isArray(l.dims))return"dims: array expected";for(var d=0;d<l.dims.length;++d)if(!(v.isInteger(l.dims[d])||l.dims[d]&&v.isInteger(l.dims[d].low)&&v.isInteger(l.dims[d].high)))return"dims: integer|Long[] expected"}if(null!=l.dataType&&l.hasOwnProperty("dataType")&&!v.isInteger(l.dataType))return"dataType: integer expected";if(null!=l.segment&&l.hasOwnProperty("segment")&&(f=b.onnx.TensorProto.Segment.verify(l.segment)))return"segment."+f;if(null!=l.floatData&&l.hasOwnProperty("floatData")){if(!Array.isArray(l.floatData))return"floatData: array expected";for(d=0;d<l.floatData.length;++d)if("number"!=typeof l.floatData[d])return"floatData: number[] expected"}if(null!=l.int32Data&&l.hasOwnProperty("int32Data")){if(!Array.isArray(l.int32Data))return"int32Data: array expected";for(d=0;d<l.int32Data.length;++d)if(!v.isInteger(l.int32Data[d]))return"int32Data: integer[] expected"}if(null!=l.stringData&&l.hasOwnProperty("stringData")){if(!Array.isArray(l.stringData))return"stringData: array expected";for(d=0;d<l.stringData.length;++d)if(!(l.stringData[d]&&"number"==typeof l.stringData[d].length||v.isString(l.stringData[d])))return"stringData: buffer[] expected"}if(null!=l.int64Data&&l.hasOwnProperty("int64Data")){if(!Array.isArray(l.int64Data))return"int64Data: array expected";for(d=0;d<l.int64Data.length;++d)if(!(v.isInteger(l.int64Data[d])||l.int64Data[d]&&v.isInteger(l.int64Data[d].low)&&v.isInteger(l.int64Data[d].high)))return"int64Data: integer|Long[] expected"}if(null!=l.name&&l.hasOwnProperty("name")&&!v.isString(l.name))return"name: string expected";if(null!=l.docString&&l.hasOwnProperty("docString")&&!v.isString(l.docString))return"docString: string expected";if(null!=l.rawData&&l.hasOwnProperty("rawData")&&!(l.rawData&&"number"==typeof l.rawData.length||v.isString(l.rawData)))return"rawData: buffer expected";if(null!=l.externalData&&l.hasOwnProperty("externalData")){if(!Array.isArray(l.externalData))return"externalData: array expected";for(d=0;d<l.externalData.length;++d){var f;if(f=b.onnx.StringStringEntryProto.verify(l.externalData[d]))return"externalData."+f}}if(null!=l.dataLocation&&l.hasOwnProperty("dataLocation"))switch(l.dataLocation){default:return"dataLocation: enum value expected";case 0:case 1:}if(null!=l.doubleData&&l.hasOwnProperty("doubleData")){if(!Array.isArray(l.doubleData))return"doubleData: array expected";for(d=0;d<l.doubleData.length;++d)if("number"!=typeof l.doubleData[d])return"doubleData: number[] expected"}if(null!=l.uint64Data&&l.hasOwnProperty("uint64Data")){if(!Array.isArray(l.uint64Data))return"uint64Data: array expected";for(d=0;d<l.uint64Data.length;++d)if(!(v.isInteger(l.uint64Data[d])||l.uint64Data[d]&&v.isInteger(l.uint64Data[d].low)&&v.isInteger(l.uint64Data[d].high)))return"uint64Data: integer|Long[] expected"}return null},h.fromObject=function(l){if(l instanceof b.onnx.TensorProto)return l;var d=new b.onnx.TensorProto;if(l.dims){if(!Array.isArray(l.dims))throw TypeError(".onnx.TensorProto.dims: array expected");d.dims=[];for(var f=0;f<l.dims.length;++f)v.Long?(d.dims[f]=v.Long.fromValue(l.dims[f])).unsigned=!1:"string"==typeof l.dims[f]?d.dims[f]=parseInt(l.dims[f],10):"number"==typeof l.dims[f]?d.dims[f]=l.dims[f]:"object"==typeof l.dims[f]&&(d.dims[f]=new v.LongBits(l.dims[f].low>>>0,l.dims[f].high>>>0).toNumber())}if(null!=l.dataType&&(d.dataType=0|l.dataType),null!=l.segment){if("object"!=typeof l.segment)throw TypeError(".onnx.TensorProto.segment: object expected");d.segment=b.onnx.TensorProto.Segment.fromObject(l.segment)}if(l.floatData){if(!Array.isArray(l.floatData))throw TypeError(".onnx.TensorProto.floatData: array expected");for(d.floatData=[],f=0;f<l.floatData.length;++f)d.floatData[f]=Number(l.floatData[f])}if(l.int32Data){if(!Array.isArray(l.int32Data))throw TypeError(".onnx.TensorProto.int32Data: array expected");for(d.int32Data=[],f=0;f<l.int32Data.length;++f)d.int32Data[f]=0|l.int32Data[f]}if(l.stringData){if(!Array.isArray(l.stringData))throw TypeError(".onnx.TensorProto.stringData: array expected");for(d.stringData=[],f=0;f<l.stringData.length;++f)"string"==typeof l.stringData[f]?v.base64.decode(l.stringData[f],d.stringData[f]=v.newBuffer(v.base64.length(l.stringData[f])),0):l.stringData[f].length>=0&&(d.stringData[f]=l.stringData[f])}if(l.int64Data){if(!Array.isArray(l.int64Data))throw TypeError(".onnx.TensorProto.int64Data: array expected");for(d.int64Data=[],f=0;f<l.int64Data.length;++f)v.Long?(d.int64Data[f]=v.Long.fromValue(l.int64Data[f])).unsigned=!1:"string"==typeof l.int64Data[f]?d.int64Data[f]=parseInt(l.int64Data[f],10):"number"==typeof l.int64Data[f]?d.int64Data[f]=l.int64Data[f]:"object"==typeof l.int64Data[f]&&(d.int64Data[f]=new v.LongBits(l.int64Data[f].low>>>0,l.int64Data[f].high>>>0).toNumber())}if(null!=l.name&&(d.name=String(l.name)),null!=l.docString&&(d.docString=String(l.docString)),null!=l.rawData&&("string"==typeof l.rawData?v.base64.decode(l.rawData,d.rawData=v.newBuffer(v.base64.length(l.rawData)),0):l.rawData.length>=0&&(d.rawData=l.rawData)),l.externalData){if(!Array.isArray(l.externalData))throw TypeError(".onnx.TensorProto.externalData: array expected");for(d.externalData=[],f=0;f<l.externalData.length;++f){if("object"!=typeof l.externalData[f])throw TypeError(".onnx.TensorProto.externalData: object expected");d.externalData[f]=b.onnx.StringStringEntryProto.fromObject(l.externalData[f])}}switch(l.dataLocation){default:if("number"==typeof l.dataLocation){d.dataLocation=l.dataLocation;break}break;case"DEFAULT":case 0:d.dataLocation=0;break;case"EXTERNAL":case 1:d.dataLocation=1}if(l.doubleData){if(!Array.isArray(l.doubleData))throw TypeError(".onnx.TensorProto.doubleData: array expected");for(d.doubleData=[],f=0;f<l.doubleData.length;++f)d.doubleData[f]=Number(l.doubleData[f])}if(l.uint64Data){if(!Array.isArray(l.uint64Data))throw TypeError(".onnx.TensorProto.uint64Data: array expected");for(d.uint64Data=[],f=0;f<l.uint64Data.length;++f)v.Long?(d.uint64Data[f]=v.Long.fromValue(l.uint64Data[f])).unsigned=!0:"string"==typeof l.uint64Data[f]?d.uint64Data[f]=parseInt(l.uint64Data[f],10):"number"==typeof l.uint64Data[f]?d.uint64Data[f]=l.uint64Data[f]:"object"==typeof l.uint64Data[f]&&(d.uint64Data[f]=new v.LongBits(l.uint64Data[f].low>>>0,l.uint64Data[f].high>>>0).toNumber(!0))}return d},h.toObject=function(l,d){d||(d={});var f={};if((d.arrays||d.defaults)&&(f.dims=[],f.floatData=[],f.int32Data=[],f.stringData=[],f.int64Data=[],f.doubleData=[],f.uint64Data=[],f.externalData=[]),d.defaults&&(f.dataType=0,f.segment=null,f.name="",d.bytes===String?f.rawData="":(f.rawData=[],d.bytes!==Array&&(f.rawData=v.newBuffer(f.rawData))),f.docString="",f.dataLocation=d.enums===String?"DEFAULT":0),l.dims&&l.dims.length){f.dims=[];for(var y=0;y<l.dims.length;++y)f.dims[y]="number"==typeof l.dims[y]?d.longs===String?String(l.dims[y]):l.dims[y]:d.longs===String?v.Long.prototype.toString.call(l.dims[y]):d.longs===Number?new v.LongBits(l.dims[y].low>>>0,l.dims[y].high>>>0).toNumber():l.dims[y]}if(null!=l.dataType&&l.hasOwnProperty("dataType")&&(f.dataType=l.dataType),null!=l.segment&&l.hasOwnProperty("segment")&&(f.segment=b.onnx.TensorProto.Segment.toObject(l.segment,d)),l.floatData&&l.floatData.length)for(f.floatData=[],y=0;y<l.floatData.length;++y)f.floatData[y]=d.json&&!isFinite(l.floatData[y])?String(l.floatData[y]):l.floatData[y];if(l.int32Data&&l.int32Data.length)for(f.int32Data=[],y=0;y<l.int32Data.length;++y)f.int32Data[y]=l.int32Data[y];if(l.stringData&&l.stringData.length)for(f.stringData=[],y=0;y<l.stringData.length;++y)f.stringData[y]=d.bytes===String?v.base64.encode(l.stringData[y],0,l.stringData[y].length):d.bytes===Array?Array.prototype.slice.call(l.stringData[y]):l.stringData[y];if(l.int64Data&&l.int64Data.length)for(f.int64Data=[],y=0;y<l.int64Data.length;++y)f.int64Data[y]="number"==typeof l.int64Data[y]?d.longs===String?String(l.int64Data[y]):l.int64Data[y]:d.longs===String?v.Long.prototype.toString.call(l.int64Data[y]):d.longs===Number?new v.LongBits(l.int64Data[y].low>>>0,l.int64Data[y].high>>>0).toNumber():l.int64Data[y];if(null!=l.name&&l.hasOwnProperty("name")&&(f.name=l.name),null!=l.rawData&&l.hasOwnProperty("rawData")&&(f.rawData=d.bytes===String?v.base64.encode(l.rawData,0,l.rawData.length):d.bytes===Array?Array.prototype.slice.call(l.rawData):l.rawData),l.doubleData&&l.doubleData.length)for(f.doubleData=[],y=0;y<l.doubleData.length;++y)f.doubleData[y]=d.json&&!isFinite(l.doubleData[y])?String(l.doubleData[y]):l.doubleData[y];if(l.uint64Data&&l.uint64Data.length)for(f.uint64Data=[],y=0;y<l.uint64Data.length;++y)f.uint64Data[y]="number"==typeof l.uint64Data[y]?d.longs===String?String(l.uint64Data[y]):l.uint64Data[y]:d.longs===String?v.Long.prototype.toString.call(l.uint64Data[y]):d.longs===Number?new v.LongBits(l.uint64Data[y].low>>>0,l.uint64Data[y].high>>>0).toNumber(!0):l.uint64Data[y];if(null!=l.docString&&l.hasOwnProperty("docString")&&(f.docString=l.docString),l.externalData&&l.externalData.length)for(f.externalData=[],y=0;y<l.externalData.length;++y)f.externalData[y]=b.onnx.StringStringEntryProto.toObject(l.externalData[y],d);return null!=l.dataLocation&&l.hasOwnProperty("dataLocation")&&(f.dataLocation=d.enums===String?void 0===b.onnx.TensorProto.DataLocation[l.dataLocation]?l.dataLocation:b.onnx.TensorProto.DataLocation[l.dataLocation]:l.dataLocation),f},h.prototype.toJSON=function(){return this.constructor.toObject(this,k.util.toJSONOptions)},h.getTypeUrl=function(l){return void 0===l&&(l="type.googleapis.com"),l+"/onnx.TensorProto"},h.DataType=(l={},(d=Object.create(l))[l[0]="UNDEFINED"]=0,d[l[1]="FLOAT"]=1,d[l[2]="UINT8"]=2,d[l[3]="INT8"]=3,d[l[4]="UINT16"]=4,d[l[5]="INT16"]=5,d[l[6]="INT32"]=6,d[l[7]="INT64"]=7,d[l[8]="STRING"]=8,d[l[9]="BOOL"]=9,d[l[10]="FLOAT16"]=10,d[l[11]="DOUBLE"]=11,d[l[12]="UINT32"]=12,d[l[13]="UINT64"]=13,d[l[14]="COMPLEX64"]=14,d[l[15]="COMPLEX128"]=15,d[l[16]="BFLOAT16"]=16,d[l[17]="FLOAT8E4M3FN"]=17,d[l[18]="FLOAT8E4M3FNUZ"]=18,d[l[19]="FLOAT8E5M2"]=19,d[l[20]="FLOAT8E5M2FNUZ"]=20,d),h.Segment=function(){function l(d){if(d)for(var f=Object.keys(d),y=0;y<f.length;++y)null!=d[f[y]]&&(this[f[y]]=d[f[y]])}return l.prototype.begin=v.Long?v.Long.fromBits(0,0,!1):0,l.prototype.end=v.Long?v.Long.fromBits(0,0,!1):0,l.create=function(d){return new l(d)},l.encode=function(d,f){return f||(f=C.create()),null!=d.begin&&Object.hasOwnProperty.call(d,"begin")&&f.uint32(8).int64(d.begin),null!=d.end&&Object.hasOwnProperty.call(d,"end")&&f.uint32(16).int64(d.end),f},l.encodeDelimited=function(d,f){return this.encode(d,f).ldelim()},l.decode=function(d,f){d instanceof S||(d=S.create(d));for(var y=void 0===f?d.len:d.pos+f,w=new b.onnx.TensorProto.Segment;d.pos<y;){var D=d.uint32();switch(D>>>3){case 1:w.begin=d.int64();break;case 2:w.end=d.int64();break;default:d.skipType(7&D)}}return w},l.decodeDelimited=function(d){return d instanceof S||(d=new S(d)),this.decode(d,d.uint32())},l.verify=function(d){return"object"!=typeof d||null===d?"object expected":null!=d.begin&&d.hasOwnProperty("begin")&&!(v.isInteger(d.begin)||d.begin&&v.isInteger(d.begin.low)&&v.isInteger(d.begin.high))?"begin: integer|Long expected":null!=d.end&&d.hasOwnProperty("end")&&!(v.isInteger(d.end)||d.end&&v.isInteger(d.end.low)&&v.isInteger(d.end.high))?"end: integer|Long expected":null},l.fromObject=function(d){if(d instanceof b.onnx.TensorProto.Segment)return d;var f=new b.onnx.TensorProto.Segment;return null!=d.begin&&(v.Long?(f.begin=v.Long.fromValue(d.begin)).unsigned=!1:"string"==typeof d.begin?f.begin=parseInt(d.begin,10):"number"==typeof d.begin?f.begin=d.begin:"object"==typeof d.begin&&(f.begin=new v.LongBits(d.begin.low>>>0,d.begin.high>>>0).toNumber())),null!=d.end&&(v.Long?(f.end=v.Long.fromValue(d.end)).unsigned=!1:"string"==typeof d.end?f.end=parseInt(d.end,10):"number"==typeof d.end?f.end=d.end:"object"==typeof d.end&&(f.end=new v.LongBits(d.end.low>>>0,d.end.high>>>0).toNumber())),f},l.toObject=function(d,f){f||(f={});var y={};if(f.defaults){if(v.Long){var w=new v.Long(0,0,!1);y.begin=f.longs===String?w.toString():f.longs===Number?w.toNumber():w}else y.begin=f.longs===String?"0":0;v.Long?(w=new v.Long(0,0,!1),y.end=f.longs===String?w.toString():f.longs===Number?w.toNumber():w):y.end=f.longs===String?"0":0}return null!=d.begin&&d.hasOwnProperty("begin")&&(y.begin="number"==typeof d.begin?f.longs===String?String(d.begin):d.begin:f.longs===String?v.Long.prototype.toString.call(d.begin):f.longs===Number?new v.LongBits(d.begin.low>>>0,d.begin.high>>>0).toNumber():d.begin),null!=d.end&&d.hasOwnProperty("end")&&(y.end="number"==typeof d.end?f.longs===String?String(d.end):d.end:f.longs===String?v.Long.prototype.toString.call(d.end):f.longs===Number?new v.LongBits(d.end.low>>>0,d.end.high>>>0).toNumber():d.end),y},l.prototype.toJSON=function(){return this.constructor.toObject(this,k.util.toJSONOptions)},l.getTypeUrl=function(d){return void 0===d&&(d="type.googleapis.com"),d+"/onnx.TensorProto.Segment"},l}(),h.DataLocation=function(){var l={},d=Object.create(l);return d[l[0]="DEFAULT"]=0,d[l[1]="EXTERNAL"]=1,d}(),h;var l,d}(),O.SparseTensorProto=function(){function h(l){if(this.dims=[],l)for(var d=Object.keys(l),f=0;f<d.length;++f)null!=l[d[f]]&&(this[d[f]]=l[d[f]])}return h.prototype.values=null,h.prototype.indices=null,h.prototype.dims=v.emptyArray,h.create=function(l){return new h(l)},h.encode=function(l,d){if(d||(d=C.create()),null!=l.values&&Object.hasOwnProperty.call(l,"values")&&b.onnx.TensorProto.encode(l.values,d.uint32(10).fork()).ldelim(),null!=l.indices&&Object.hasOwnProperty.call(l,"indices")&&b.onnx.TensorProto.encode(l.indices,d.uint32(18).fork()).ldelim(),null!=l.dims&&l.dims.length){d.uint32(26).fork();for(var f=0;f<l.dims.length;++f)d.int64(l.dims[f]);d.ldelim()}return d},h.encodeDelimited=function(l,d){return this.encode(l,d).ldelim()},h.decode=function(l,d){l instanceof S||(l=S.create(l));for(var f=void 0===d?l.len:l.pos+d,y=new b.onnx.SparseTensorProto;l.pos<f;){var w=l.uint32();switch(w>>>3){case 1:y.values=b.onnx.TensorProto.decode(l,l.uint32());break;case 2:y.indices=b.onnx.TensorProto.decode(l,l.uint32());break;case 3:if(y.dims&&y.dims.length||(y.dims=[]),2==(7&w))for(var D=l.uint32()+l.pos;l.pos<D;)y.dims.push(l.int64());else y.dims.push(l.int64());break;default:l.skipType(7&w)}}return y},h.decodeDelimited=function(l){return l instanceof S||(l=new S(l)),this.decode(l,l.uint32())},h.verify=function(l){if("object"!=typeof l||null===l)return"object expected";var d;if(null!=l.values&&l.hasOwnProperty("values")&&(d=b.onnx.TensorProto.verify(l.values)))return"values."+d;if(null!=l.indices&&l.hasOwnProperty("indices")&&(d=b.onnx.TensorProto.verify(l.indices)))return"indices."+d;if(null!=l.dims&&l.hasOwnProperty("dims")){if(!Array.isArray(l.dims))return"dims: array expected";for(var f=0;f<l.dims.length;++f)if(!(v.isInteger(l.dims[f])||l.dims[f]&&v.isInteger(l.dims[f].low)&&v.isInteger(l.dims[f].high)))return"dims: integer|Long[] expected"}return null},h.fromObject=function(l){if(l instanceof b.onnx.SparseTensorProto)return l;var d=new b.onnx.SparseTensorProto;if(null!=l.values){if("object"!=typeof l.values)throw TypeError(".onnx.SparseTensorProto.values: object expected");d.values=b.onnx.TensorProto.fromObject(l.values)}if(null!=l.indices){if("object"!=typeof l.indices)throw TypeError(".onnx.SparseTensorProto.indices: object expected");d.indices=b.onnx.TensorProto.fromObject(l.indices)}if(l.dims){if(!Array.isArray(l.dims))throw TypeError(".onnx.SparseTensorProto.dims: array expected");d.dims=[];for(var f=0;f<l.dims.length;++f)v.Long?(d.dims[f]=v.Long.fromValue(l.dims[f])).unsigned=!1:"string"==typeof l.dims[f]?d.dims[f]=parseInt(l.dims[f],10):"number"==typeof l.dims[f]?d.dims[f]=l.dims[f]:"object"==typeof l.dims[f]&&(d.dims[f]=new v.LongBits(l.dims[f].low>>>0,l.dims[f].high>>>0).toNumber())}return d},h.toObject=function(l,d){d||(d={});var f={};if((d.arrays||d.defaults)&&(f.dims=[]),d.defaults&&(f.values=null,f.indices=null),null!=l.values&&l.hasOwnProperty("values")&&(f.values=b.onnx.TensorProto.toObject(l.values,d)),null!=l.indices&&l.hasOwnProperty("indices")&&(f.indices=b.onnx.TensorProto.toObject(l.indices,d)),l.dims&&l.dims.length){f.dims=[];for(var y=0;y<l.dims.length;++y)f.dims[y]="number"==typeof l.dims[y]?d.longs===String?String(l.dims[y]):l.dims[y]:d.longs===String?v.Long.prototype.toString.call(l.dims[y]):d.longs===Number?new v.LongBits(l.dims[y].low>>>0,l.dims[y].high>>>0).toNumber():l.dims[y]}return f},h.prototype.toJSON=function(){return this.constructor.toObject(this,k.util.toJSONOptions)},h.getTypeUrl=function(l){return void 0===l&&(l="type.googleapis.com"),l+"/onnx.SparseTensorProto"},h}(),O.TensorShapeProto=function(){function h(l){if(this.dim=[],l)for(var d=Object.keys(l),f=0;f<d.length;++f)null!=l[d[f]]&&(this[d[f]]=l[d[f]])}return h.prototype.dim=v.emptyArray,h.create=function(l){return new h(l)},h.encode=function(l,d){if(d||(d=C.create()),null!=l.dim&&l.dim.length)for(var f=0;f<l.dim.length;++f)b.onnx.TensorShapeProto.Dimension.encode(l.dim[f],d.uint32(10).fork()).ldelim();return d},h.encodeDelimited=function(l,d){return this.encode(l,d).ldelim()},h.decode=function(l,d){l instanceof S||(l=S.create(l));for(var f=void 0===d?l.len:l.pos+d,y=new b.onnx.TensorShapeProto;l.pos<f;){var w=l.uint32();w>>>3==1?(y.dim&&y.dim.length||(y.dim=[]),y.dim.push(b.onnx.TensorShapeProto.Dimension.decode(l,l.uint32()))):l.skipType(7&w)}return y},h.decodeDelimited=function(l){return l instanceof S||(l=new S(l)),this.decode(l,l.uint32())},h.verify=function(l){if("object"!=typeof l||null===l)return"object expected";if(null!=l.dim&&l.hasOwnProperty("dim")){if(!Array.isArray(l.dim))return"dim: array expected";for(var d=0;d<l.dim.length;++d){var f=b.onnx.TensorShapeProto.Dimension.verify(l.dim[d]);if(f)return"dim."+f}}return null},h.fromObject=function(l){if(l instanceof b.onnx.TensorShapeProto)return l;var d=new b.onnx.TensorShapeProto;if(l.dim){if(!Array.isArray(l.dim))throw TypeError(".onnx.TensorShapeProto.dim: array expected");d.dim=[];for(var f=0;f<l.dim.length;++f){if("object"!=typeof l.dim[f])throw TypeError(".onnx.TensorShapeProto.dim: object expected");d.dim[f]=b.onnx.TensorShapeProto.Dimension.fromObject(l.dim[f])}}return d},h.toObject=function(l,d){d||(d={});var f={};if((d.arrays||d.defaults)&&(f.dim=[]),l.dim&&l.dim.length){f.dim=[];for(var y=0;y<l.dim.length;++y)f.dim[y]=b.onnx.TensorShapeProto.Dimension.toObject(l.dim[y],d)}return f},h.prototype.toJSON=function(){return this.constructor.toObject(this,k.util.toJSONOptions)},h.getTypeUrl=function(l){return void 0===l&&(l="type.googleapis.com"),l+"/onnx.TensorShapeProto"},h.Dimension=function(){function l(f){if(f)for(var y=Object.keys(f),w=0;w<y.length;++w)null!=f[y[w]]&&(this[y[w]]=f[y[w]])}var d;return l.prototype.dimValue=null,l.prototype.dimParam=null,l.prototype.denotation="",Object.defineProperty(l.prototype,"value",{get:v.oneOfGetter(d=["dimValue","dimParam"]),set:v.oneOfSetter(d)}),l.create=function(f){return new l(f)},l.encode=function(f,y){return y||(y=C.create()),null!=f.dimValue&&Object.hasOwnProperty.call(f,"dimValue")&&y.uint32(8).int64(f.dimValue),null!=f.dimParam&&Object.hasOwnProperty.call(f,"dimParam")&&y.uint32(18).string(f.dimParam),null!=f.denotation&&Object.hasOwnProperty.call(f,"denotation")&&y.uint32(26).string(f.denotation),y},l.encodeDelimited=function(f,y){return this.encode(f,y).ldelim()},l.decode=function(f,y){f instanceof S||(f=S.create(f));for(var w=void 0===y?f.len:f.pos+y,D=new b.onnx.TensorShapeProto.Dimension;f.pos<w;){var M=f.uint32();switch(M>>>3){case 1:D.dimValue=f.int64();break;case 2:D.dimParam=f.string();break;case 3:D.denotation=f.string();break;default:f.skipType(7&M)}}return D},l.decodeDelimited=function(f){return f instanceof S||(f=new S(f)),this.decode(f,f.uint32())},l.verify=function(f){if("object"!=typeof f||null===f)return"object expected";var y={};if(null!=f.dimValue&&f.hasOwnProperty("dimValue")&&(y.value=1,!(v.isInteger(f.dimValue)||f.dimValue&&v.isInteger(f.dimValue.low)&&v.isInteger(f.dimValue.high))))return"dimValue: integer|Long expected";if(null!=f.dimParam&&f.hasOwnProperty("dimParam")){if(1===y.value)return"value: multiple values";if(y.value=1,!v.isString(f.dimParam))return"dimParam: string expected"}return null!=f.denotation&&f.hasOwnProperty("denotation")&&!v.isString(f.denotation)?"denotation: string expected":null},l.fromObject=function(f){if(f instanceof b.onnx.TensorShapeProto.Dimension)return f;var y=new b.onnx.TensorShapeProto.Dimension;return null!=f.dimValue&&(v.Long?(y.dimValue=v.Long.fromValue(f.dimValue)).unsigned=!1:"string"==typeof f.dimValue?y.dimValue=parseInt(f.dimValue,10):"number"==typeof f.dimValue?y.dimValue=f.dimValue:"object"==typeof f.dimValue&&(y.dimValue=new v.LongBits(f.dimValue.low>>>0,f.dimValue.high>>>0).toNumber())),null!=f.dimParam&&(y.dimParam=String(f.dimParam)),null!=f.denotation&&(y.denotation=String(f.denotation)),y},l.toObject=function(f,y){y||(y={});var w={};return y.defaults&&(w.denotation=""),null!=f.dimValue&&f.hasOwnProperty("dimValue")&&(w.dimValue="number"==typeof f.dimValue?y.longs===String?String(f.dimValue):f.dimValue:y.longs===String?v.Long.prototype.toString.call(f.dimValue):y.longs===Number?new v.LongBits(f.dimValue.low>>>0,f.dimValue.high>>>0).toNumber():f.dimValue,y.oneofs&&(w.value="dimValue")),null!=f.dimParam&&f.hasOwnProperty("dimParam")&&(w.dimParam=f.dimParam,y.oneofs&&(w.value="dimParam")),null!=f.denotation&&f.hasOwnProperty("denotation")&&(w.denotation=f.denotation),w},l.prototype.toJSON=function(){return this.constructor.toObject(this,k.util.toJSONOptions)},l.getTypeUrl=function(f){return void 0===f&&(f="type.googleapis.com"),f+"/onnx.TensorShapeProto.Dimension"},l}(),h}(),O.TypeProto=function(){function h(d){if(d)for(var f=Object.keys(d),y=0;y<f.length;++y)null!=d[f[y]]&&(this[f[y]]=d[f[y]])}var l;return h.prototype.tensorType=null,h.prototype.sequenceType=null,h.prototype.mapType=null,h.prototype.optionalType=null,h.prototype.sparseTensorType=null,h.prototype.denotation="",Object.defineProperty(h.prototype,"value",{get:v.oneOfGetter(l=["tensorType","sequenceType","mapType","optionalType","sparseTensorType"]),set:v.oneOfSetter(l)}),h.create=function(d){return new h(d)},h.encode=function(d,f){return f||(f=C.create()),null!=d.tensorType&&Object.hasOwnProperty.call(d,"tensorType")&&b.onnx.TypeProto.Tensor.encode(d.tensorType,f.uint32(10).fork()).ldelim(),null!=d.sequenceType&&Object.hasOwnProperty.call(d,"sequenceType")&&b.onnx.TypeProto.Sequence.encode(d.sequenceType,f.uint32(34).fork()).ldelim(),null!=d.mapType&&Object.hasOwnProperty.call(d,"mapType")&&b.onnx.TypeProto.Map.encode(d.mapType,f.uint32(42).fork()).ldelim(),null!=d.denotation&&Object.hasOwnProperty.call(d,"denotation")&&f.uint32(50).string(d.denotation),null!=d.sparseTensorType&&Object.hasOwnProperty.call(d,"sparseTensorType")&&b.onnx.TypeProto.SparseTensor.encode(d.sparseTensorType,f.uint32(66).fork()).ldelim(),null!=d.optionalType&&Object.hasOwnProperty.call(d,"optionalType")&&b.onnx.TypeProto.Optional.encode(d.optionalType,f.uint32(74).fork()).ldelim(),f},h.encodeDelimited=function(d,f){return this.encode(d,f).ldelim()},h.decode=function(d,f){d instanceof S||(d=S.create(d));for(var y=void 0===f?d.len:d.pos+f,w=new b.onnx.TypeProto;d.pos<y;){var D=d.uint32();switch(D>>>3){case 1:w.tensorType=b.onnx.TypeProto.Tensor.decode(d,d.uint32());break;case 4:w.sequenceType=b.onnx.TypeProto.Sequence.decode(d,d.uint32());break;case 5:w.mapType=b.onnx.TypeProto.Map.decode(d,d.uint32());break;case 9:w.optionalType=b.onnx.TypeProto.Optional.decode(d,d.uint32());break;case 8:w.sparseTensorType=b.onnx.TypeProto.SparseTensor.decode(d,d.uint32());break;case 6:w.denotation=d.string();break;default:d.skipType(7&D)}}return w},h.decodeDelimited=function(d){return d instanceof S||(d=new S(d)),this.decode(d,d.uint32())},h.verify=function(d){if("object"!=typeof d||null===d)return"object expected";var f={};if(null!=d.tensorType&&d.hasOwnProperty("tensorType")&&(f.value=1,y=b.onnx.TypeProto.Tensor.verify(d.tensorType)))return"tensorType."+y;if(null!=d.sequenceType&&d.hasOwnProperty("sequenceType")){if(1===f.value)return"value: multiple values";if(f.value=1,y=b.onnx.TypeProto.Sequence.verify(d.sequenceType))return"sequenceType."+y}if(null!=d.mapType&&d.hasOwnProperty("mapType")){if(1===f.value)return"value: multiple values";if(f.value=1,y=b.onnx.TypeProto.Map.verify(d.mapType))return"mapType."+y}if(null!=d.optionalType&&d.hasOwnProperty("optionalType")){if(1===f.value)return"value: multiple values";if(f.value=1,y=b.onnx.TypeProto.Optional.verify(d.optionalType))return"optionalType."+y}if(null!=d.sparseTensorType&&d.hasOwnProperty("sparseTensorType")){if(1===f.value)return"value: multiple values";var y;if(f.value=1,y=b.onnx.TypeProto.SparseTensor.verify(d.sparseTensorType))return"sparseTensorType."+y}return null!=d.denotation&&d.hasOwnProperty("denotation")&&!v.isString(d.denotation)?"denotation: string expected":null},h.fromObject=function(d){if(d instanceof b.onnx.TypeProto)return d;var f=new b.onnx.TypeProto;if(null!=d.tensorType){if("object"!=typeof d.tensorType)throw TypeError(".onnx.TypeProto.tensorType: object expected");f.tensorType=b.onnx.TypeProto.Tensor.fromObject(d.tensorType)}if(null!=d.sequenceType){if("object"!=typeof d.sequenceType)throw TypeError(".onnx.TypeProto.sequenceType: object expected");f.sequenceType=b.onnx.TypeProto.Sequence.fromObject(d.sequenceType)}if(null!=d.mapType){if("object"!=typeof d.mapType)throw TypeError(".onnx.TypeProto.mapType: object expected");f.mapType=b.onnx.TypeProto.Map.fromObject(d.mapType)}if(null!=d.optionalType){if("object"!=typeof d.optionalType)throw TypeError(".onnx.TypeProto.optionalType: object expected");f.optionalType=b.onnx.TypeProto.Optional.fromObject(d.optionalType)}if(null!=d.sparseTensorType){if("object"!=typeof d.sparseTensorType)throw TypeError(".onnx.TypeProto.sparseTensorType: object expected");f.sparseTensorType=b.onnx.TypeProto.SparseTensor.fromObject(d.sparseTensorType)}return null!=d.denotation&&(f.denotation=String(d.denotation)),f},h.toObject=function(d,f){f||(f={});var y={};return f.defaults&&(y.denotation=""),null!=d.tensorType&&d.hasOwnProperty("tensorType")&&(y.tensorType=b.onnx.TypeProto.Tensor.toObject(d.tensorType,f),f.oneofs&&(y.value="tensorType")),null!=d.sequenceType&&d.hasOwnProperty("sequenceType")&&(y.sequenceType=b.onnx.TypeProto.Sequence.toObject(d.sequenceType,f),f.oneofs&&(y.value="sequenceType")),null!=d.mapType&&d.hasOwnProperty("mapType")&&(y.mapType=b.onnx.TypeProto.Map.toObject(d.mapType,f),f.oneofs&&(y.value="mapType")),null!=d.denotation&&d.hasOwnProperty("denotation")&&(y.denotation=d.denotation),null!=d.sparseTensorType&&d.hasOwnProperty("sparseTensorType")&&(y.sparseTensorType=b.onnx.TypeProto.SparseTensor.toObject(d.sparseTensorType,f),f.oneofs&&(y.value="sparseTensorType")),null!=d.optionalType&&d.hasOwnProperty("optionalType")&&(y.optionalType=b.onnx.TypeProto.Optional.toObject(d.optionalType,f),f.oneofs&&(y.value="optionalType")),y},h.prototype.toJSON=function(){return this.constructor.toObject(this,k.util.toJSONOptions)},h.getTypeUrl=function(d){return void 0===d&&(d="type.googleapis.com"),d+"/onnx.TypeProto"},h.Tensor=function(){function d(f){if(f)for(var y=Object.keys(f),w=0;w<y.length;++w)null!=f[y[w]]&&(this[y[w]]=f[y[w]])}return d.prototype.elemType=0,d.prototype.shape=null,d.create=function(f){return new d(f)},d.encode=function(f,y){return y||(y=C.create()),null!=f.elemType&&Object.hasOwnProperty.call(f,"elemType")&&y.uint32(8).int32(f.elemType),null!=f.shape&&Object.hasOwnProperty.call(f,"shape")&&b.onnx.TensorShapeProto.encode(f.shape,y.uint32(18).fork()).ldelim(),y},d.encodeDelimited=function(f,y){return this.encode(f,y).ldelim()},d.decode=function(f,y){f instanceof S||(f=S.create(f));for(var w=void 0===y?f.len:f.pos+y,D=new b.onnx.TypeProto.Tensor;f.pos<w;){var M=f.uint32();switch(M>>>3){case 1:D.elemType=f.int32();break;case 2:D.shape=b.onnx.TensorShapeProto.decode(f,f.uint32());break;default:f.skipType(7&M)}}return D},d.decodeDelimited=function(f){return f instanceof S||(f=new S(f)),this.decode(f,f.uint32())},d.verify=function(f){if("object"!=typeof f||null===f)return"object expected";if(null!=f.elemType&&f.hasOwnProperty("elemType")&&!v.isInteger(f.elemType))return"elemType: integer expected";if(null!=f.shape&&f.hasOwnProperty("shape")){var y=b.onnx.TensorShapeProto.verify(f.shape);if(y)return"shape."+y}return null},d.fromObject=function(f){if(f instanceof b.onnx.TypeProto.Tensor)return f;var y=new b.onnx.TypeProto.Tensor;if(null!=f.elemType&&(y.elemType=0|f.elemType),null!=f.shape){if("object"!=typeof f.shape)throw TypeError(".onnx.TypeProto.Tensor.shape: object expected");y.shape=b.onnx.TensorShapeProto.fromObject(f.shape)}return y},d.toObject=function(f,y){y||(y={});var w={};return y.defaults&&(w.elemType=0,w.shape=null),null!=f.elemType&&f.hasOwnProperty("elemType")&&(w.elemType=f.elemType),null!=f.shape&&f.hasOwnProperty("shape")&&(w.shape=b.onnx.TensorShapeProto.toObject(f.shape,y)),w},d.prototype.toJSON=function(){return this.constructor.toObject(this,k.util.toJSONOptions)},d.getTypeUrl=function(f){return void 0===f&&(f="type.googleapis.com"),f+"/onnx.TypeProto.Tensor"},d}(),h.Sequence=function(){function d(f){if(f)for(var y=Object.keys(f),w=0;w<y.length;++w)null!=f[y[w]]&&(this[y[w]]=f[y[w]])}return d.prototype.elemType=null,d.create=function(f){return new d(f)},d.encode=function(f,y){return y||(y=C.create()),null!=f.elemType&&Object.hasOwnProperty.call(f,"elemType")&&b.onnx.TypeProto.encode(f.elemType,y.uint32(10).fork()).ldelim(),y},d.encodeDelimited=function(f,y){return this.encode(f,y).ldelim()},d.decode=function(f,y){f instanceof S||(f=S.create(f));for(var w=void 0===y?f.len:f.pos+y,D=new b.onnx.TypeProto.Sequence;f.pos<w;){var M=f.uint32();M>>>3==1?D.elemType=b.onnx.TypeProto.decode(f,f.uint32()):f.skipType(7&M)}return D},d.decodeDelimited=function(f){return f instanceof S||(f=new S(f)),this.decode(f,f.uint32())},d.verify=function(f){if("object"!=typeof f||null===f)return"object expected";if(null!=f.elemType&&f.hasOwnProperty("elemType")){var y=b.onnx.TypeProto.verify(f.elemType);if(y)return"elemType."+y}return null},d.fromObject=function(f){if(f instanceof b.onnx.TypeProto.Sequence)return f;var y=new b.onnx.TypeProto.Sequence;if(null!=f.elemType){if("object"!=typeof f.elemType)throw TypeError(".onnx.TypeProto.Sequence.elemType: object expected");y.elemType=b.onnx.TypeProto.fromObject(f.elemType)}return y},d.toObject=function(f,y){y||(y={});var w={};return y.defaults&&(w.elemType=null),null!=f.elemType&&f.hasOwnProperty("elemType")&&(w.elemType=b.onnx.TypeProto.toObject(f.elemType,y)),w},d.prototype.toJSON=function(){return this.constructor.toObject(this,k.util.toJSONOptions)},d.getTypeUrl=function(f){return void 0===f&&(f="type.googleapis.com"),f+"/onnx.TypeProto.Sequence"},d}(),h.Map=function(){function d(f){if(f)for(var y=Object.keys(f),w=0;w<y.length;++w)null!=f[y[w]]&&(this[y[w]]=f[y[w]])}return d.prototype.keyType=0,d.prototype.valueType=null,d.create=function(f){return new d(f)},d.encode=function(f,y){return y||(y=C.create()),null!=f.keyType&&Object.hasOwnProperty.call(f,"keyType")&&y.uint32(8).int32(f.keyType),null!=f.valueType&&Object.hasOwnProperty.call(f,"valueType")&&b.onnx.TypeProto.encode(f.valueType,y.uint32(18).fork()).ldelim(),y},d.encodeDelimited=function(f,y){return this.encode(f,y).ldelim()},d.decode=function(f,y){f instanceof S||(f=S.create(f));for(var w=void 0===y?f.len:f.pos+y,D=new b.onnx.TypeProto.Map;f.pos<w;){var M=f.uint32();switch(M>>>3){case 1:D.keyType=f.int32();break;case 2:D.valueType=b.onnx.TypeProto.decode(f,f.uint32());break;default:f.skipType(7&M)}}return D},d.decodeDelimited=function(f){return f instanceof S||(f=new S(f)),this.decode(f,f.uint32())},d.verify=function(f){if("object"!=typeof f||null===f)return"object expected";if(null!=f.keyType&&f.hasOwnProperty("keyType")&&!v.isInteger(f.keyType))return"keyType: integer expected";if(null!=f.valueType&&f.hasOwnProperty("valueType")){var y=b.onnx.TypeProto.verify(f.valueType);if(y)return"valueType."+y}return null},d.fromObject=function(f){if(f instanceof b.onnx.TypeProto.Map)return f;var y=new b.onnx.TypeProto.Map;if(null!=f.keyType&&(y.keyType=0|f.keyType),null!=f.valueType){if("object"!=typeof f.valueType)throw TypeError(".onnx.TypeProto.Map.valueType: object expected");y.valueType=b.onnx.TypeProto.fromObject(f.valueType)}return y},d.toObject=function(f,y){y||(y={});var w={};return y.defaults&&(w.keyType=0,w.valueType=null),null!=f.keyType&&f.hasOwnProperty("keyType")&&(w.keyType=f.keyType),null!=f.valueType&&f.hasOwnProperty("valueType")&&(w.valueType=b.onnx.TypeProto.toObject(f.valueType,y)),w},d.prototype.toJSON=function(){return this.constructor.toObject(this,k.util.toJSONOptions)},d.getTypeUrl=function(f){return void 0===f&&(f="type.googleapis.com"),f+"/onnx.TypeProto.Map"},d}(),h.Optional=function(){function d(f){if(f)for(var y=Object.keys(f),w=0;w<y.length;++w)null!=f[y[w]]&&(this[y[w]]=f[y[w]])}return d.prototype.elemType=null,d.create=function(f){return new d(f)},d.encode=function(f,y){return y||(y=C.create()),null!=f.elemType&&Object.hasOwnProperty.call(f,"elemType")&&b.onnx.TypeProto.encode(f.elemType,y.uint32(10).fork()).ldelim(),y},d.encodeDelimited=function(f,y){return this.encode(f,y).ldelim()},d.decode=function(f,y){f instanceof S||(f=S.create(f));for(var w=void 0===y?f.len:f.pos+y,D=new b.onnx.TypeProto.Optional;f.pos<w;){var M=f.uint32();M>>>3==1?D.elemType=b.onnx.TypeProto.decode(f,f.uint32()):f.skipType(7&M)}return D},d.decodeDelimited=function(f){return f instanceof S||(f=new S(f)),this.decode(f,f.uint32())},d.verify=function(f){if("object"!=typeof f||null===f)return"object expected";if(null!=f.elemType&&f.hasOwnProperty("elemType")){var y=b.onnx.TypeProto.verify(f.elemType);if(y)return"elemType."+y}return null},d.fromObject=function(f){if(f instanceof b.onnx.TypeProto.Optional)return f;var y=new b.onnx.TypeProto.Optional;if(null!=f.elemType){if("object"!=typeof f.elemType)throw TypeError(".onnx.TypeProto.Optional.elemType: object expected");y.elemType=b.onnx.TypeProto.fromObject(f.elemType)}return y},d.toObject=function(f,y){y||(y={});var w={};return y.defaults&&(w.elemType=null),null!=f.elemType&&f.hasOwnProperty("elemType")&&(w.elemType=b.onnx.TypeProto.toObject(f.elemType,y)),w},d.prototype.toJSON=function(){return this.constructor.toObject(this,k.util.toJSONOptions)},d.getTypeUrl=function(f){return void 0===f&&(f="type.googleapis.com"),f+"/onnx.TypeProto.Optional"},d}(),h.SparseTensor=function(){function d(f){if(f)for(var y=Object.keys(f),w=0;w<y.length;++w)null!=f[y[w]]&&(this[y[w]]=f[y[w]])}return d.prototype.elemType=0,d.prototype.shape=null,d.create=function(f){return new d(f)},d.encode=function(f,y){return y||(y=C.create()),null!=f.elemType&&Object.hasOwnProperty.call(f,"elemType")&&y.uint32(8).int32(f.elemType),null!=f.shape&&Object.hasOwnProperty.call(f,"shape")&&b.onnx.TensorShapeProto.encode(f.shape,y.uint32(18).fork()).ldelim(),y},d.encodeDelimited=function(f,y){return this.encode(f,y).ldelim()},d.decode=function(f,y){f instanceof S||(f=S.create(f));for(var w=void 0===y?f.len:f.pos+y,D=new b.onnx.TypeProto.SparseTensor;f.pos<w;){var M=f.uint32();switch(M>>>3){case 1:D.elemType=f.int32();break;case 2:D.shape=b.onnx.TensorShapeProto.decode(f,f.uint32());break;default:f.skipType(7&M)}}return D},d.decodeDelimited=function(f){return f instanceof S||(f=new S(f)),this.decode(f,f.uint32())},d.verify=function(f){if("object"!=typeof f||null===f)return"object expected";if(null!=f.elemType&&f.hasOwnProperty("elemType")&&!v.isInteger(f.elemType))return"elemType: integer expected";if(null!=f.shape&&f.hasOwnProperty("shape")){var y=b.onnx.TensorShapeProto.verify(f.shape);if(y)return"shape."+y}return null},d.fromObject=function(f){if(f instanceof b.onnx.TypeProto.SparseTensor)return f;var y=new b.onnx.TypeProto.SparseTensor;if(null!=f.elemType&&(y.elemType=0|f.elemType),null!=f.shape){if("object"!=typeof f.shape)throw TypeError(".onnx.TypeProto.SparseTensor.shape: object expected");y.shape=b.onnx.TensorShapeProto.fromObject(f.shape)}return y},d.toObject=function(f,y){y||(y={});var w={};return y.defaults&&(w.elemType=0,w.shape=null),null!=f.elemType&&f.hasOwnProperty("elemType")&&(w.elemType=f.elemType),null!=f.shape&&f.hasOwnProperty("shape")&&(w.shape=b.onnx.TensorShapeProto.toObject(f.shape,y)),w},d.prototype.toJSON=function(){return this.constructor.toObject(this,k.util.toJSONOptions)},d.getTypeUrl=function(f){return void 0===f&&(f="type.googleapis.com"),f+"/onnx.TypeProto.SparseTensor"},d}(),h}(),O.OperatorSetIdProto=function(){function h(l){if(l)for(var d=Object.keys(l),f=0;f<d.length;++f)null!=l[d[f]]&&(this[d[f]]=l[d[f]])}return h.prototype.domain="",h.prototype.version=v.Long?v.Long.fromBits(0,0,!1):0,h.create=function(l){return new h(l)},h.encode=function(l,d){return d||(d=C.create()),null!=l.domain&&Object.hasOwnProperty.call(l,"domain")&&d.uint32(10).string(l.domain),null!=l.version&&Object.hasOwnProperty.call(l,"version")&&d.uint32(16).int64(l.version),d},h.encodeDelimited=function(l,d){return this.encode(l,d).ldelim()},h.decode=function(l,d){l instanceof S||(l=S.create(l));for(var f=void 0===d?l.len:l.pos+d,y=new b.onnx.OperatorSetIdProto;l.pos<f;){var w=l.uint32();switch(w>>>3){case 1:y.domain=l.string();break;case 2:y.version=l.int64();break;default:l.skipType(7&w)}}return y},h.decodeDelimited=function(l){return l instanceof S||(l=new S(l)),this.decode(l,l.uint32())},h.verify=function(l){return"object"!=typeof l||null===l?"object expected":null!=l.domain&&l.hasOwnProperty("domain")&&!v.isString(l.domain)?"domain: string expected":null!=l.version&&l.hasOwnProperty("version")&&!(v.isInteger(l.version)||l.version&&v.isInteger(l.version.low)&&v.isInteger(l.version.high))?"version: integer|Long expected":null},h.fromObject=function(l){if(l instanceof b.onnx.OperatorSetIdProto)return l;var d=new b.onnx.OperatorSetIdProto;return null!=l.domain&&(d.domain=String(l.domain)),null!=l.version&&(v.Long?(d.version=v.Long.fromValue(l.version)).unsigned=!1:"string"==typeof l.version?d.version=parseInt(l.version,10):"number"==typeof l.version?d.version=l.version:"object"==typeof l.version&&(d.version=new v.LongBits(l.version.low>>>0,l.version.high>>>0).toNumber())),d},h.toObject=function(l,d){d||(d={});var f={};if(d.defaults)if(f.domain="",v.Long){var y=new v.Long(0,0,!1);f.version=d.longs===String?y.toString():d.longs===Number?y.toNumber():y}else f.version=d.longs===String?"0":0;return null!=l.domain&&l.hasOwnProperty("domain")&&(f.domain=l.domain),null!=l.version&&l.hasOwnProperty("version")&&(f.version="number"==typeof l.version?d.longs===String?String(l.version):l.version:d.longs===String?v.Long.prototype.toString.call(l.version):d.longs===Number?new v.LongBits(l.version.low>>>0,l.version.high>>>0).toNumber():l.version),f},h.prototype.toJSON=function(){return this.constructor.toObject(this,k.util.toJSONOptions)},h.getTypeUrl=function(l){return void 0===l&&(l="type.googleapis.com"),l+"/onnx.OperatorSetIdProto"},h}(),O.OperatorStatus=(h={},(l=Object.create(h))[h[0]="EXPERIMENTAL"]=0,l[h[1]="STABLE"]=1,l),O.FunctionProto=function(){function h(l){if(this.input=[],this.output=[],this.attribute=[],this.attributeProto=[],this.node=[],this.opsetImport=[],l)for(var d=Object.keys(l),f=0;f<d.length;++f)null!=l[d[f]]&&(this[d[f]]=l[d[f]])}return h.prototype.name="",h.prototype.input=v.emptyArray,h.prototype.output=v.emptyArray,h.prototype.attribute=v.emptyArray,h.prototype.attributeProto=v.emptyArray,h.prototype.node=v.emptyArray,h.prototype.docString="",h.prototype.opsetImport=v.emptyArray,h.prototype.domain="",h.create=function(l){return new h(l)},h.encode=function(l,d){if(d||(d=C.create()),null!=l.name&&Object.hasOwnProperty.call(l,"name")&&d.uint32(10).string(l.name),null!=l.input&&l.input.length)for(var f=0;f<l.input.length;++f)d.uint32(34).string(l.input[f]);if(null!=l.output&&l.output.length)for(f=0;f<l.output.length;++f)d.uint32(42).string(l.output[f]);if(null!=l.attribute&&l.attribute.length)for(f=0;f<l.attribute.length;++f)d.uint32(50).string(l.attribute[f]);if(null!=l.node&&l.node.length)for(f=0;f<l.node.length;++f)b.onnx.NodeProto.encode(l.node[f],d.uint32(58).fork()).ldelim();if(null!=l.docString&&Object.hasOwnProperty.call(l,"docString")&&d.uint32(66).string(l.docString),null!=l.opsetImport&&l.opsetImport.length)for(f=0;f<l.opsetImport.length;++f)b.onnx.OperatorSetIdProto.encode(l.opsetImport[f],d.uint32(74).fork()).ldelim();if(null!=l.domain&&Object.hasOwnProperty.call(l,"domain")&&d.uint32(82).string(l.domain),null!=l.attributeProto&&l.attributeProto.length)for(f=0;f<l.attributeProto.length;++f)b.onnx.AttributeProto.encode(l.attributeProto[f],d.uint32(90).fork()).ldelim();return d},h.encodeDelimited=function(l,d){return this.encode(l,d).ldelim()},h.decode=function(l,d){l instanceof S||(l=S.create(l));for(var f=void 0===d?l.len:l.pos+d,y=new b.onnx.FunctionProto;l.pos<f;){var w=l.uint32();switch(w>>>3){case 1:y.name=l.string();break;case 4:y.input&&y.input.length||(y.input=[]),y.input.push(l.string());break;case 5:y.output&&y.output.length||(y.output=[]),y.output.push(l.string());break;case 6:y.attribute&&y.attribute.length||(y.attribute=[]),y.attribute.push(l.string());break;case 11:y.attributeProto&&y.attributeProto.length||(y.attributeProto=[]),y.attributeProto.push(b.onnx.AttributeProto.decode(l,l.uint32()));break;case 7:y.node&&y.node.length||(y.node=[]),y.node.push(b.onnx.NodeProto.decode(l,l.uint32()));break;case 8:y.docString=l.string();break;case 9:y.opsetImport&&y.opsetImport.length||(y.opsetImport=[]),y.opsetImport.push(b.onnx.OperatorSetIdProto.decode(l,l.uint32()));break;case 10:y.domain=l.string();break;default:l.skipType(7&w)}}return y},h.decodeDelimited=function(l){return l instanceof S||(l=new S(l)),this.decode(l,l.uint32())},h.verify=function(l){if("object"!=typeof l||null===l)return"object expected";if(null!=l.name&&l.hasOwnProperty("name")&&!v.isString(l.name))return"name: string expected";if(null!=l.input&&l.hasOwnProperty("input")){if(!Array.isArray(l.input))return"input: array expected";for(var d=0;d<l.input.length;++d)if(!v.isString(l.input[d]))return"input: string[] expected"}if(null!=l.output&&l.hasOwnProperty("output")){if(!Array.isArray(l.output))return"output: array expected";for(d=0;d<l.output.length;++d)if(!v.isString(l.output[d]))return"output: string[] expected"}if(null!=l.attribute&&l.hasOwnProperty("attribute")){if(!Array.isArray(l.attribute))return"attribute: array expected";for(d=0;d<l.attribute.length;++d)if(!v.isString(l.attribute[d]))return"attribute: string[] expected"}if(null!=l.attributeProto&&l.hasOwnProperty("attributeProto")){if(!Array.isArray(l.attributeProto))return"attributeProto: array expected";for(d=0;d<l.attributeProto.length;++d)if(f=b.onnx.AttributeProto.verify(l.attributeProto[d]))return"attributeProto."+f}if(null!=l.node&&l.hasOwnProperty("node")){if(!Array.isArray(l.node))return"node: array expected";for(d=0;d<l.node.length;++d)if(f=b.onnx.NodeProto.verify(l.node[d]))return"node."+f}if(null!=l.docString&&l.hasOwnProperty("docString")&&!v.isString(l.docString))return"docString: string expected";if(null!=l.opsetImport&&l.hasOwnProperty("opsetImport")){if(!Array.isArray(l.opsetImport))return"opsetImport: array expected";for(d=0;d<l.opsetImport.length;++d){var f;if(f=b.onnx.OperatorSetIdProto.verify(l.opsetImport[d]))return"opsetImport."+f}}return null!=l.domain&&l.hasOwnProperty("domain")&&!v.isString(l.domain)?"domain: string expected":null},h.fromObject=function(l){if(l instanceof b.onnx.FunctionProto)return l;var d=new b.onnx.FunctionProto;if(null!=l.name&&(d.name=String(l.name)),l.input){if(!Array.isArray(l.input))throw TypeError(".onnx.FunctionProto.input: array expected");d.input=[];for(var f=0;f<l.input.length;++f)d.input[f]=String(l.input[f])}if(l.output){if(!Array.isArray(l.output))throw TypeError(".onnx.FunctionProto.output: array expected");for(d.output=[],f=0;f<l.output.length;++f)d.output[f]=String(l.output[f])}if(l.attribute){if(!Array.isArray(l.attribute))throw TypeError(".onnx.FunctionProto.attribute: array expected");for(d.attribute=[],f=0;f<l.attribute.length;++f)d.attribute[f]=String(l.attribute[f])}if(l.attributeProto){if(!Array.isArray(l.attributeProto))throw TypeError(".onnx.FunctionProto.attributeProto: array expected");for(d.attributeProto=[],f=0;f<l.attributeProto.length;++f){if("object"!=typeof l.attributeProto[f])throw TypeError(".onnx.FunctionProto.attributeProto: object expected");d.attributeProto[f]=b.onnx.AttributeProto.fromObject(l.attributeProto[f])}}if(l.node){if(!Array.isArray(l.node))throw TypeError(".onnx.FunctionProto.node: array expected");for(d.node=[],f=0;f<l.node.length;++f){if("object"!=typeof l.node[f])throw TypeError(".onnx.FunctionProto.node: object expected");d.node[f]=b.onnx.NodeProto.fromObject(l.node[f])}}if(null!=l.docString&&(d.docString=String(l.docString)),l.opsetImport){if(!Array.isArray(l.opsetImport))throw TypeError(".onnx.FunctionProto.opsetImport: array expected");for(d.opsetImport=[],f=0;f<l.opsetImport.length;++f){if("object"!=typeof l.opsetImport[f])throw TypeError(".onnx.FunctionProto.opsetImport: object expected");d.opsetImport[f]=b.onnx.OperatorSetIdProto.fromObject(l.opsetImport[f])}}return null!=l.domain&&(d.domain=String(l.domain)),d},h.toObject=function(l,d){d||(d={});var f={};if((d.arrays||d.defaults)&&(f.input=[],f.output=[],f.attribute=[],f.node=[],f.opsetImport=[],f.attributeProto=[]),d.defaults&&(f.name="",f.docString="",f.domain=""),null!=l.name&&l.hasOwnProperty("name")&&(f.name=l.name),l.input&&l.input.length){f.input=[];for(var y=0;y<l.input.length;++y)f.input[y]=l.input[y]}if(l.output&&l.output.length)for(f.output=[],y=0;y<l.output.length;++y)f.output[y]=l.output[y];if(l.attribute&&l.attribute.length)for(f.attribute=[],y=0;y<l.attribute.length;++y)f.attribute[y]=l.attribute[y];if(l.node&&l.node.length)for(f.node=[],y=0;y<l.node.length;++y)f.node[y]=b.onnx.NodeProto.toObject(l.node[y],d);if(null!=l.docString&&l.hasOwnProperty("docString")&&(f.docString=l.docString),l.opsetImport&&l.opsetImport.length)for(f.opsetImport=[],y=0;y<l.opsetImport.length;++y)f.opsetImport[y]=b.onnx.OperatorSetIdProto.toObject(l.opsetImport[y],d);if(null!=l.domain&&l.hasOwnProperty("domain")&&(f.domain=l.domain),l.attributeProto&&l.attributeProto.length)for(f.attributeProto=[],y=0;y<l.attributeProto.length;++y)f.attributeProto[y]=b.onnx.AttributeProto.toObject(l.attributeProto[y],d);return f},h.prototype.toJSON=function(){return this.constructor.toObject(this,k.util.toJSONOptions)},h.getTypeUrl=function(l){return void 0===l&&(l="type.googleapis.com"),l+"/onnx.FunctionProto"},h}(),O),me.exports=b},3474:(me,E,P)=>{var F,A=(F=typeof document<"u"&&document.currentScript?document.currentScript.src:void 0,typeof __filename<"u"&&(F=F||__filename),function(O={}){function k(){return He.buffer!=it.buffer&&ur(),it}function S(){return He.buffer!=it.buffer&&ur(),yt}function C(){return He.buffer!=it.buffer&&ur(),wt}function v(){return He.buffer!=it.buffer&&ur(),Pt}function b(){return He.buffer!=it.buffer&&ur(),pn}var h,l,d=O;d.ready=new Promise((W,oe)=>{h=W,l=oe});var f,y,w,D=Object.assign({},d),M="./this.program",$=(W,oe)=>{throw oe},B="object"==typeof window,z="function"==typeof importScripts,G="object"==typeof process&&"object"==typeof process.versions&&"string"==typeof process.versions.node,H=d.ENVIRONMENT_IS_PTHREAD||!1,te="";function ae(W){return d.locateFile?d.locateFile(W,te):te+W}if(G){var J=P(1384),ne=P(908);let W;te=z?ne.dirname(te)+"/":__dirname+"/",f=(oe,ge)=>(oe=oe.startsWith("file://")?new URL(oe):ne.normalize(oe),J.readFileSync(oe,ge?void 0:"utf8")),w=oe=>((oe=f(oe,!0)).buffer||(oe=new Uint8Array(oe)),oe),y=(oe,ge,ke,Be=!0)=>{oe=oe.startsWith("file://")?new URL(oe):ne.normalize(oe),J.readFile(oe,Be?void 0:"utf8",(tt,Et)=>{tt?ke(tt):ge(Be?Et.buffer:Et)})},!d.thisProgram&&1<process.argv.length&&(M=process.argv[1].replace(/\\/g,"/")),process.argv.slice(2),$=(oe,ge)=>{throw process.exitCode=oe,ge},d.inspect=()=>"[Emscripten Module object]";try{W=P(9925)}catch(oe){throw console.error('The "worker_threads" module is not supported in this node.js build - perhaps a newer version is needed?'),oe}global.Worker=W.Worker}else(B||z)&&(z?te=self.location.href:typeof document<"u"&&document.currentScript&&(te=document.currentScript.src),F&&(te=F),te=0!==te.indexOf("blob:")?te.substr(0,te.replace(/[?#].*/,"").lastIndexOf("/")+1):"",G||(f=W=>{var oe=new XMLHttpRequest;return oe.open("GET",W,!1),oe.send(null),oe.responseText},z&&(w=W=>{var oe=new XMLHttpRequest;return oe.open("GET",W,!1),oe.responseType="arraybuffer",oe.send(null),new Uint8Array(oe.response)}),y=(W,oe,ge)=>{var ke=new XMLHttpRequest;ke.open("GET",W,!0),ke.responseType="arraybuffer",ke.onload=()=>{200==ke.status||0==ke.status&&ke.response?oe(ke.response):ge()},ke.onerror=ge,ke.send(null)}));G&&typeof performance>"u"&&(global.performance=P(6953).performance);var X=console.log.bind(console),K=console.error.bind(console);G&&(X=(...W)=>J.writeSync(1,W.join(" ")+"\n"),K=(...W)=>J.writeSync(2,W.join(" ")+"\n"));var ve,q=d.print||X,re=d.printErr||K;Object.assign(d,D),D=null,d.thisProgram&&(M=d.thisProgram),d.quit&&($=d.quit),d.wasmBinary&&(ve=d.wasmBinary);var le=d.noExitRuntime||!0;"object"!=typeof WebAssembly&&uo("no native wasm support detected");var He,Le,ot,nt,it,yt,wt,Pt,pn,Cn=!1;function ur(){var W=He.buffer;d.HEAP8=it=new Int8Array(W),d.HEAP16=new Int16Array(W),d.HEAP32=wt=new Int32Array(W),d.HEAPU8=yt=new Uint8Array(W),d.HEAPU16=new Uint16Array(W),d.HEAPU32=Pt=new Uint32Array(W),d.HEAPF32=new Float32Array(W),d.HEAPF64=pn=new Float64Array(W)}var Ir=d.INITIAL_MEMORY||16777216;if(5242880<=Ir||uo("INITIAL_MEMORY should be larger than STACK_SIZE, was "+Ir+"! (STACK_SIZE=5242880)"),H)He=d.wasmMemory;else if(d.wasmMemory)He=d.wasmMemory;else if(!((He=new WebAssembly.Memory({initial:Ir/65536,maximum:65536,shared:!0})).buffer instanceof SharedArrayBuffer))throw re("requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag"),G&&re("(on node you may need: --experimental-wasm-threads --experimental-wasm-bulk-memory and/or recent version)"),Error("bad memory");ur(),Ir=He.buffer.byteLength;var Ri,Ko=[],jr=[],Xo=[],kn=0;function Mi(){return le||0<kn}var Lr,Gr,Fi=0,Yo=null,qi=null;function ws(){Fi++,d.monitorRunDependencies&&d.monitorRunDependencies(Fi)}function Hr(){if(Fi--,d.monitorRunDependencies&&d.monitorRunDependencies(Fi),0==Fi&&(null!==Yo&&(clearInterval(Yo),Yo=null),qi)){var W=qi;qi=null,W()}}function uo(W){throw d.onAbort&&d.onAbort(W),re(W="Aborted("+W+")"),Cn=!0,nt=1,W=new WebAssembly.RuntimeError(W+". Build with -sASSERTIONS for more info."),l(W),W}function Qa(W){return W.startsWith("data:application/octet-stream;base64,")}function An(W){if(W==Lr&&ve)return new Uint8Array(ve);if(w)return w(W);throw"both async and sync fetching of the wasm failed"}function Qc(W,oe,ge){return function(ke){if(!ve&&(B||z)){if("function"==typeof fetch&&!ke.startsWith("file://"))return fetch(ke,{credentials:"same-origin"}).then(Be=>{if(!Be.ok)throw"failed to load wasm binary file at '"+ke+"'";return Be.arrayBuffer()}).catch(()=>An(ke));if(y)return new Promise((Be,tt)=>{y(ke,Et=>Be(new Uint8Array(Et)),tt)})}return Promise.resolve().then(()=>An(ke))}(W).then(ke=>WebAssembly.instantiate(ke,oe)).then(ke=>ke).then(ge,ke=>{re("failed to asynchronously prepare wasm: "+ke),uo(ke)})}function Ja(W){this.name="ExitStatus",this.message=`Program terminated with exit(${W})`,this.status=W}function Bl(W){W.terminate(),W.onmessage=()=>{}}function Jc(W){(W=ct.Fa[W])||uo(),ct.fb(W)}function Kt(W){var oe=ct.Za();if(!oe)return 6;ct.Ia.push(oe),ct.Fa[W.Ha]=oe,oe.Ha=W.Ha;var ge={cmd:"run",start_routine:W.gb,arg:W.Ya,pthread_ptr:W.Ha};return G&&oe.unref(),oe.postMessage(ge,W.mb),0}Qa(Lr="ort-wasm-threaded.wasm")||(Lr=ae(Lr));var eu=typeof TextDecoder<"u"?new TextDecoder("utf8"):void 0,Vl=(W,oe,ge)=>{var ke=(oe>>>=0)+ge;for(ge=oe;W[ge]&&!(ge>=ke);)++ge;if(16<ge-oe&&W.buffer&&eu)return eu.decode(W.buffer instanceof SharedArrayBuffer?W.slice(oe,ge):W.subarray(oe,ge));for(ke="";oe<ge;){var Be=W[oe++];if(128&Be){var tt=63&W[oe++];if(192==(224&Be))ke+=String.fromCharCode((31&Be)<<6|tt);else{var Et=63&W[oe++];65536>(Be=224==(240&Be)?(15&Be)<<12|tt<<6|Et:(7&Be)<<18|tt<<12|Et<<6|63&W[oe++])?ke+=String.fromCharCode(Be):(Be-=65536,ke+=String.fromCharCode(55296|Be>>10,56320|1023&Be))}}else ke+=String.fromCharCode(Be)}return ke},Rn=(W,oe)=>(W>>>=0)?Vl(S(),W,oe):"";function Bn(W){if(H)return qn(1,1,W);nt=W,Mi()||(ct.hb(),d.onExit&&d.onExit(W),Cn=!0),$(W,new Ja(W))}var zl=W=>{if(nt=W,H)throw ud(W),"unwind";Bn(W)},ct={La:[],Ia:[],Ta:[],Fa:{},Pa:function(){H?ct.ab():ct.$a()},$a:function(){Ko.unshift(()=>{ws(),ct.bb(()=>Hr())})},ab:function(){ct.receiveObjectTransfer=ct.eb,ct.threadInitTLS=ct.Sa,ct.setExitStatus=ct.Ra,le=!1},Ra:function(W){nt=W},rb:["$terminateWorker"],hb:function(){for(var W of ct.Ia)Bl(W);for(W of ct.La)Bl(W);ct.La=[],ct.Ia=[],ct.Fa=[]},fb:function(W){var oe=W.Ha;delete ct.Fa[oe],ct.La.push(W),ct.Ia.splice(ct.Ia.indexOf(W),1),W.Ha=0,gd(oe)},eb:function(){},Sa:function(){ct.Ta.forEach(W=>W())},cb:W=>new Promise(oe=>{W.onmessage=Be=>{var tt=(Be=Be.data).cmd;if(Be.targetThread&&Be.targetThread!=yr()){var Et=ct.Fa[Be.qb];Et?Et.postMessage(Be,Be.transferList):re('Internal error! Worker sent a message "'+tt+'" to target pthread '+Be.targetThread+", but that thread no longer exists!")}else"checkMailbox"===tt?wp():"spawnThread"===tt?Kt(Be):"cleanupThread"===tt?Jc(Be.thread):"killThread"===tt?(tt=ct.Fa[Be=Be.thread],delete ct.Fa[Be],Bl(tt),gd(Be),ct.Ia.splice(ct.Ia.indexOf(tt),1),tt.Ha=0):"cancelThread"===tt?ct.Fa[Be.thread].postMessage({cmd:"cancel"}):"loaded"===tt?(W.loaded=!0,oe(W)):"alert"===tt?alert("Thread "+Be.threadId+": "+Be.text):"setimmediate"===Be.target?W.postMessage(Be):"callHandler"===tt?d[Be.handler](...Be.args):tt&&re("worker sent an unknown command "+tt)},W.onerror=Be=>{throw re("worker sent an error! "+Be.filename+":"+Be.lineno+": "+Be.message),Be},G&&(W.on("message",function(Be){W.onmessage({data:Be})}),W.on("error",function(Be){W.onerror(Be)}));var ge,ke=[];for(ge of["onExit","onAbort","print","printErr"])d.hasOwnProperty(ge)&&ke.push(ge);W.postMessage({cmd:"load",handlers:ke,urlOrBlob:d.mainScriptUrlOrBlob||F,wasmMemory:He,wasmModule:ot})}),bb:function(W){W()},Xa:function(){var W=ae("ort-wasm-threaded.worker.js");W=new Worker(W),ct.La.push(W)},Za:function(){return 0==ct.La.length&&(ct.Xa(),ct.cb(ct.La[0])),ct.La.pop()}};d.PThread=ct;var qs=W=>{for(;0<W.length;)W.shift()(d)};function ud(W){if(H)return qn(2,0,W);zl(W)}d.establishStackSpace=function(){var W=yr(),oe=C()[W+52>>2>>>0];W=C()[W+56>>2>>>0],Cb(oe,oe-W),nu(oe)};var se=[];function Ce(W){this.Oa=W-24,this.Wa=function(oe){v()[this.Oa+4>>2>>>0]=oe},this.Va=function(oe){v()[this.Oa+8>>2>>>0]=oe},this.Pa=function(oe,ge){this.Ua(),this.Wa(oe),this.Va(ge)},this.Ua=function(){v()[this.Oa+16>>2>>>0]=0}}function Ne(W,oe,ge,ke){return H?qn(3,1,W,oe,ge,ke):Ge(W,oe,ge,ke)}function Ge(W,oe,ge,ke){if(W>>>=0,oe>>>=0,ge>>>=0,ke>>>=0,typeof SharedArrayBuffer>"u")return re("Current environment does not support SharedArrayBuffer, pthreads are not available!"),6;var Be=[];return H&&0===Be.length?Ne(W,oe,ge,ke):(W={gb:ge,Ha:W,Ya:ke,mb:Be},H?(W.ob="spawnThread",postMessage(W,Be),0):Kt(W))}function st(W,oe,ge){return H?qn(4,1,W,oe,ge):0}function Mt(W,oe){if(H)return qn(5,1,W,oe)}d.invokeEntryPoint=function(W,oe){var ge=se[W];ge||(W>=se.length&&(se.length=W+1),se[W]=ge=Ri.get(W)),W=ge(oe),Mi()?ct.Ra(W):tu(W)};var qt=W=>{for(var oe=0,ge=0;ge<W.length;++ge){var ke=W.charCodeAt(ge);127>=ke?oe++:2047>=ke?oe+=2:55296<=ke&&57343>=ke?(oe+=4,++ge):oe+=3}return oe},Br=(W,oe,ge,ke)=>{if(!(0<ke))return 0;var Be=ge>>>=0;ke=ge+ke-1;for(var tt=0;tt<W.length;++tt){var Et=W.charCodeAt(tt);if(55296<=Et&&57343>=Et&&(Et=65536+((1023&Et)<<10)|1023&W.charCodeAt(++tt)),127>=Et){if(ge>=ke)break;oe[ge++>>>0]=Et}else{if(2047>=Et){if(ge+1>=ke)break;oe[ge++>>>0]=192|Et>>6}else{if(65535>=Et){if(ge+2>=ke)break;oe[ge++>>>0]=224|Et>>12}else{if(ge+3>=ke)break;oe[ge++>>>0]=240|Et>>18,oe[ge++>>>0]=128|Et>>12&63}oe[ge++>>>0]=128|Et>>6&63}oe[ge++>>>0]=128|63&Et}}return oe[ge>>>0]=0,ge-Be},_i=(W,oe,ge)=>Br(W,S(),oe,ge);function vi(W,oe){if(H)return qn(6,1,W,oe)}function xi(W,oe,ge){if(H)return qn(7,1,W,oe,ge)}function Ul(W,oe,ge){return H?qn(8,1,W,oe,ge):0}function dd(W,oe){if(H)return qn(9,1,W,oe)}function Ve(W,oe,ge){if(H)return qn(10,1,W,oe,ge)}function gn(W,oe,ge,ke){if(H)return qn(11,1,W,oe,ge,ke)}function nr(W,oe,ge,ke){if(H)return qn(12,1,W,oe,ge,ke)}function Ks(W,oe,ge,ke){if(H)return qn(13,1,W,oe,ge,ke)}function hd(W){if(H)return qn(14,1,W)}function ba(W,oe){if(H)return qn(15,1,W,oe)}function yb(W,oe,ge){if(H)return qn(16,1,W,oe,ge)}var C2=W=>{if(!Cn)try{if(W(),!Mi())try{H?tu(nt):zl(nt)}catch(oe){oe instanceof Ja||"unwind"==oe||$(1,oe)}}catch(oe){oe instanceof Ja||"unwind"==oe||$(1,oe)}};function xp(W){W>>>=0,"function"==typeof Atomics.nb&&(Atomics.nb(C(),W>>2,W).value.then(wp),W+=128,Atomics.store(C(),W>>2,1))}function wp(){var W=yr();W&&(xp(W),C2(()=>Ap()))}d.__emscripten_thread_mailbox_await=xp,d.checkMailbox=wp;var jl=W=>W%4==0&&(W%100!=0||W%400==0),pw=[0,31,60,91,121,152,182,213,244,274,305,335],fw=[0,31,59,90,120,151,181,212,243,273,304,334];function mw(W,oe,ge,ke,Be,tt,Et,_r){return H?qn(17,1,W,oe,ge,ke,Be,tt,Et,_r):-52}function gw(W,oe,ge,ke,Be,tt,Et){if(H)return qn(18,1,W,oe,ge,ke,Be,tt,Et)}var bw=W=>{var oe=qt(W)+1,ge=el(oe);return ge&&_i(W,ge,oe),ge},Tp=W=>{var oe=bd();return W=W(),nu(oe),W};function qn(W,oe){var ge=arguments.length-2,ke=arguments;return Tp(()=>{for(var Be=Np(8*ge),tt=Be>>3,Et=0;Et<ge;Et++){var _r=ke[2+Et];b()[tt+Et>>>0]=_r}return Sb(W,ge,Be,oe)})}var pd,fd=[],md={},_b=()=>{if(!pd){var W,oe={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:("object"==typeof navigator&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:M||"./this.program"};for(W in md)void 0===md[W]?delete oe[W]:oe[W]=md[W];var ge=[];for(W in oe)ge.push(`${W}=${oe[W]}`);pd=ge}return pd};function Sp(W,oe){if(H)return qn(19,1,W,oe);W>>>=0,oe>>>=0;var ge=0;return _b().forEach(function(ke,Be){var tt=oe+ge;for(Be=v()[W+4*Be>>2>>>0]=tt,tt=0;tt<ke.length;++tt)k()[Be++>>0>>>0]=ke.charCodeAt(tt);k()[Be>>0>>>0]=0,ge+=ke.length+1}),0}function Cp(W,oe){if(H)return qn(20,1,W,oe);W>>>=0,oe>>>=0;var ge=_b();v()[W>>2>>>0]=ge.length;var ke=0;return ge.forEach(function(Be){ke+=Be.length+1}),v()[oe>>2>>>0]=ke,0}function Ip(W){return H?qn(21,1,W):52}function Ep(W,oe,ge,ke){return H?qn(22,1,W,oe,ge,ke):52}function wi(W,oe,ge,ke,Be){return H?qn(23,1,W,oe,ge,ke,Be):70}var yw=[null,[],[]];function vb(W,oe,ge,ke){if(H)return qn(24,1,W,oe,ge,ke);oe>>>=0,ge>>>=0,ke>>>=0;for(var Be=0,tt=0;tt<ge;tt++){var Et=v()[oe>>2>>>0],_r=v()[oe+4>>2>>>0];oe+=8;for(var Ki=0;Ki<_r;Ki++){var Ht=S()[Et+Ki>>>0],Ti=yw[W];0===Ht||10===Ht?((1===W?q:re)(Vl(Ti,0)),Ti.length=0):Ti.push(Ht)}Be+=_r}return v()[ke>>2>>>0]=Be,0}var xb=W=>(xb=(()=>{if("object"==typeof crypto&&"function"==typeof crypto.getRandomValues)return ke=>(ke.set(crypto.getRandomValues(new Uint8Array(ke.byteLength))),ke);if(G)try{var oe=P(760);if(oe.randomFillSync)return ke=>oe.randomFillSync(ke);var ge=oe.randomBytes;return ke=>(ke.set(ge(ke.byteLength)),ke)}catch{}uo("initRandomDevice")})())(W),wb=[31,29,31,30,31,30,31,31,30,31,30,31],Dp=[31,28,31,30,31,30,31,31,30,31,30,31];function Tb(W,oe,ge,ke){function Be(Ue,Dt,vt){for(Ue="number"==typeof Ue?Ue.toString():Ue||"";Ue.length<Dt;)Ue=vt[0]+Ue;return Ue}function tt(Ue,Dt){return Be(Ue,Dt,"0")}function Et(Ue,Dt){function vt(_d){return 0>_d?-1:0<_d?1:0}var Ys;return 0===(Ys=vt(Ue.getFullYear()-Dt.getFullYear()))&&0===(Ys=vt(Ue.getMonth()-Dt.getMonth()))&&(Ys=vt(Ue.getDate()-Dt.getDate())),Ys}function _r(Ue){switch(Ue.getDay()){case 0:return new Date(Ue.getFullYear()-1,11,29);case 1:return Ue;case 2:return new Date(Ue.getFullYear(),0,3);case 3:return new Date(Ue.getFullYear(),0,2);case 4:return new Date(Ue.getFullYear(),0,1);case 5:return new Date(Ue.getFullYear()-1,11,31);case 6:return new Date(Ue.getFullYear()-1,11,30)}}function Ki(Ue){var Dt=Ue.Ja;for(Ue=new Date(new Date(Ue.Ka+1900,0,1).getTime());0<Dt;){var vt=Ue.getMonth(),Ys=(jl(Ue.getFullYear())?wb:Dp)[vt];if(!(Dt>Ys-Ue.getDate())){Ue.setDate(Ue.getDate()+Dt);break}Dt-=Ys-Ue.getDate()+1,Ue.setDate(1),11>vt?Ue.setMonth(vt+1):(Ue.setMonth(0),Ue.setFullYear(Ue.getFullYear()+1))}return vt=new Date(Ue.getFullYear()+1,0,4),Dt=_r(new Date(Ue.getFullYear(),0,4)),vt=_r(vt),0>=Et(Dt,Ue)?0>=Et(vt,Ue)?Ue.getFullYear()+1:Ue.getFullYear():Ue.getFullYear()-1}W>>>=0,oe>>>=0,ge>>>=0,ke>>>=0;var Ht=C()[ke+40>>2>>>0];for(var Ti in ke={kb:C()[ke>>2>>>0],jb:C()[ke+4>>2>>>0],Ma:C()[ke+8>>2>>>0],Qa:C()[ke+12>>2>>>0],Na:C()[ke+16>>2>>>0],Ka:C()[ke+20>>2>>>0],Ga:C()[ke+24>>2>>>0],Ja:C()[ke+28>>2>>>0],sb:C()[ke+32>>2>>>0],ib:C()[ke+36>>2>>>0],lb:Ht?Rn(Ht):""},ge=Rn(ge),Ht={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"})ge=ge.replace(new RegExp(Ti,"g"),Ht[Ti]);var Ue,Dt,Er="Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),yd="January February March April May June July August September October November December".split(" ");for(Ti in Ht={"%a":Ue=>Er[Ue.Ga].substring(0,3),"%A":Ue=>Er[Ue.Ga],"%b":Ue=>yd[Ue.Na].substring(0,3),"%B":Ue=>yd[Ue.Na],"%C":Ue=>tt((Ue.Ka+1900)/100|0,2),"%d":Ue=>tt(Ue.Qa,2),"%e":Ue=>Be(Ue.Qa,2," "),"%g":Ue=>Ki(Ue).toString().substring(2),"%G":Ue=>Ki(Ue),"%H":Ue=>tt(Ue.Ma,2),"%I":Ue=>(0==(Ue=Ue.Ma)?Ue=12:12<Ue&&(Ue-=12),tt(Ue,2)),"%j":Ue=>{for(var Dt=0,vt=0;vt<=Ue.Na-1;Dt+=(jl(Ue.Ka+1900)?wb:Dp)[vt++]);return tt(Ue.Qa+Dt,3)},"%m":Ue=>tt(Ue.Na+1,2),"%M":Ue=>tt(Ue.jb,2),"%n":()=>"\n","%p":Ue=>0<=Ue.Ma&&12>Ue.Ma?"AM":"PM","%S":Ue=>tt(Ue.kb,2),"%t":()=>"\t","%u":Ue=>Ue.Ga||7,"%U":Ue=>tt(Math.floor((Ue.Ja+7-Ue.Ga)/7),2),"%V":Ue=>{var Dt=Math.floor((Ue.Ja+7-(Ue.Ga+6)%7)/7);if(2>=(Ue.Ga+371-Ue.Ja-2)%7&&Dt++,Dt)53==Dt&&(4==(vt=(Ue.Ga+371-Ue.Ja)%7)||3==vt&&jl(Ue.Ka)||(Dt=1));else{Dt=52;var vt=(Ue.Ga+7-Ue.Ja-1)%7;(4==vt||5==vt&&jl(Ue.Ka%400-1))&&Dt++}return tt(Dt,2)},"%w":Ue=>Ue.Ga,"%W":Ue=>tt(Math.floor((Ue.Ja+7-(Ue.Ga+6)%7)/7),2),"%y":Ue=>(Ue.Ka+1900).toString().substring(2),"%Y":Ue=>Ue.Ka+1900,"%z":Ue=>(0<=(Ue=Ue.ib)?"+":"-")+("0000"+((Ue=Math.abs(Ue)/60)/60*100+Ue%60)).slice(-4),"%Z":Ue=>Ue.lb,"%%":()=>"%"},ge=ge.replace(/%%/g,"\0\0"),Ht)ge.includes(Ti)&&(ge=ge.replace(new RegExp(Ti,"g"),Ht[Ti](ke)));return Ue=ge=ge.replace(/\0\0/g,"%"),Dt=Array(qt(Ue)+1),Br(Ue,Dt,0,Dt.length),(Ti=Dt).length>oe?0:(((W,oe)=>{k().set(W,oe>>>0)})(Ti,W),Ti.length-1)}ct.Pa();var Xs=[null,Bn,ud,Ne,st,Mt,vi,xi,Ul,dd,Ve,gn,nr,Ks,hd,ba,yb,mw,gw,Sp,Cp,Ip,Ep,wi,vb],vw={b:function(W,oe,ge){throw new Ce(W>>>=0).Pa(oe>>>0,ge>>>0),W},N:function(W){ho(W>>>0,!z,1,!B,131072,!1),ct.Sa()},k:function(W){W>>>=0,H?postMessage({cmd:"cleanupThread",thread:W}):Jc(W)},I:Ge,h:st,T:Mt,E:vi,G:xi,U:Ul,R:dd,J:Ve,Q:gn,o:nr,F:Ks,C:hd,S:ba,D:yb,q:()=>!0,A:function(W,oe){(W>>>=0)==oe>>>0?setTimeout(()=>wp()):H?postMessage({targetThread:W,cmd:"checkMailbox"}):(W=ct.Fa[W])&&W.postMessage({cmd:"checkMailbox"})},L:function(){return-1},M:xp,p:function(W){G&&ct.Fa[W>>>0].ref()},t:function(W,oe,ge){W=oe+2097152>>>0<4194305-!!W?(W>>>0)+4294967296*oe:NaN,ge>>>=0,W=new Date(1e3*W),C()[ge>>2>>>0]=W.getUTCSeconds(),C()[ge+4>>2>>>0]=W.getUTCMinutes(),C()[ge+8>>2>>>0]=W.getUTCHours(),C()[ge+12>>2>>>0]=W.getUTCDate(),C()[ge+16>>2>>>0]=W.getUTCMonth(),C()[ge+20>>2>>>0]=W.getUTCFullYear()-1900,C()[ge+24>>2>>>0]=W.getUTCDay(),W=(W.getTime()-Date.UTC(W.getUTCFullYear(),0,1,0,0,0,0))/864e5|0,C()[ge+28>>2>>>0]=W},u:function(W,oe,ge){W=oe+2097152>>>0<4194305-!!W?(W>>>0)+4294967296*oe:NaN,ge>>>=0,W=new Date(1e3*W),C()[ge>>2>>>0]=W.getSeconds(),C()[ge+4>>2>>>0]=W.getMinutes(),C()[ge+8>>2>>>0]=W.getHours(),C()[ge+12>>2>>>0]=W.getDate(),C()[ge+16>>2>>>0]=W.getMonth(),C()[ge+20>>2>>>0]=W.getFullYear()-1900,C()[ge+24>>2>>>0]=W.getDay(),oe=(jl(W.getFullYear())?pw:fw)[W.getMonth()]+W.getDate()-1|0,C()[ge+28>>2>>>0]=oe,C()[ge+36>>2>>>0]=-60*W.getTimezoneOffset(),oe=new Date(W.getFullYear(),6,1).getTimezoneOffset();var ke=new Date(W.getFullYear(),0,1).getTimezoneOffset();W=0|(oe!=ke&&W.getTimezoneOffset()==Math.min(ke,oe)),C()[ge+32>>2>>>0]=W},v:function(W){W>>>=0;var oe=new Date(C()[W+20>>2>>>0]+1900,C()[W+16>>2>>>0],C()[W+12>>2>>>0],C()[W+8>>2>>>0],C()[W+4>>2>>>0],C()[W>>2>>>0],0),ge=C()[W+32>>2>>>0],ke=oe.getTimezoneOffset(),Be=new Date(oe.getFullYear(),6,1).getTimezoneOffset(),tt=new Date(oe.getFullYear(),0,1).getTimezoneOffset(),Et=Math.min(tt,Be);return 0>ge?C()[W+32>>2>>>0]=+(Be!=tt&&Et==ke):0<ge!=(Et==ke)&&(Be=Math.max(tt,Be),oe.setTime(oe.getTime()+6e4*((0<ge?Et:Be)-ke))),C()[W+24>>2>>>0]=oe.getDay(),ge=(jl(oe.getFullYear())?pw:fw)[oe.getMonth()]+oe.getDate()-1|0,C()[W+28>>2>>>0]=ge,C()[W>>2>>>0]=oe.getSeconds(),C()[W+4>>2>>>0]=oe.getMinutes(),C()[W+8>>2>>>0]=oe.getHours(),C()[W+12>>2>>>0]=oe.getDate(),C()[W+16>>2>>>0]=oe.getMonth(),C()[W+20>>2>>>0]=oe.getYear(),W=oe.getTime()/1e3,Gl((Gr=W,1<=+Math.abs(Gr)?0<Gr?+Math.floor(Gr/4294967296)>>>0:~~+Math.ceil((Gr-+(~~Gr>>>0))/4294967296)>>>0:0)),W>>>0},r:mw,s:gw,z:function(W,oe,ge){function ke(Ht){return(Ht=Ht.toTimeString().match(/\(([A-Za-z ]+)\)$/))?Ht[1]:"GMT"}W>>>=0,oe>>>=0,ge>>>=0;var Be=(new Date).getFullYear(),tt=new Date(Be,0,1),Et=new Date(Be,6,1);Be=tt.getTimezoneOffset();var _r=Et.getTimezoneOffset(),Ki=Math.max(Be,_r);v()[W>>2>>>0]=60*Ki,C()[oe>>2>>>0]=+(Be!=_r),W=ke(tt),oe=ke(Et),W=bw(W),oe=bw(oe),_r<Be?(v()[ge>>2>>>0]=W,v()[ge+4>>2>>>0]=oe):(v()[ge>>2>>>0]=oe,v()[ge+4>>2>>>0]=W)},c:()=>{uo("")},l:function(){},i:function(){return Date.now()},V:()=>{throw kn+=1,"unwind"},B:function(){return 4294901760},e:()=>performance.timeOrigin+performance.now(),f:function(){return G?P(3993).cpus().length:navigator.hardwareConcurrency},K:function(W,oe,ge,ke){for(ct.pb=oe>>>0,fd.length=ge,oe=ke>>>0>>3,ke=0;ke<ge;ke++)fd[ke]=b()[oe+ke>>>0];return Xs[W].apply(null,fd)},y:function(W){W>>>=0;var oe=S().length;if(W<=oe||4294901760<W)return!1;for(var ge=1;4>=ge;ge*=2){var ke=oe*(1+.2/ge);ke=Math.min(ke,W+100663296);var Be=Math;ke=Math.max(W,ke);e:{Be=Be.min.call(Be,4294901760,ke+(65536-ke%65536)%65536)-He.buffer.byteLength+65535>>>16;try{He.grow(Be),ur();var tt=1;break e}catch{}tt=void 0}if(tt)return!0}return!1},O:Sp,P:Cp,j:zl,g:Ip,n:Ep,w:wi,m:vb,x:function(W,oe){return W>>>=0,oe>>>=0,xb(S().subarray(W>>>0,W+oe>>>0)),0},a:He||d.wasmMemory,H:Tb,d:function(W,oe,ge,ke){return Tb(W>>>0,oe>>>0,ge>>>0,ke>>>0)}};(function(){function W(ge,ke){return Be=ge=ge.exports,tt=_r=>()=>_r()>>>0,Et=_r=>Ki=>_r(Ki)>>>0,(Be=Object.assign({},Be)).__errno_location=tt(Be.__errno_location),Be.pthread_self=tt(Be.pthread_self),Be.malloc=Et(Be.malloc),Be.stackSave=tt(Be.stackSave),Be.stackAlloc=Et(Be.stackAlloc),Le=ge=Be,ct.Ta.push(Le.sa),Ri=Le.ta,jr.unshift(Le.W),ot=ke,Hr(),ge;var Be,tt,Et}var ge,ke,Be,oe={a:vw};if(ws(),d.instantiateWasm)try{return d.instantiateWasm(oe,W)}catch(ge){re("Module.instantiateWasm callback failed with error: "+ge),l(ge)}(ge=oe,ke=function(ge){W(ge.instance,ge.module)},Be=Lr,ve||"function"!=typeof WebAssembly.instantiateStreaming||Qa(Be)||Be.startsWith("file://")||G||"function"!=typeof fetch?Qc(Be,ge,ke):fetch(Be,{credentials:"same-origin"}).then(tt=>WebAssembly.instantiateStreaming(tt,ge).then(ke,function(Et){return re("wasm streaming compile failed: "+Et),re("falling back to ArrayBuffer instantiation"),Qc(Be,ge,ke)}))).catch(l)})(),d._OrtInit=(W,oe)=>(d._OrtInit=Le.X)(W,oe),d._OrtGetLastError=(W,oe)=>(d._OrtGetLastError=Le.Y)(W,oe),d._OrtCreateSessionOptions=(W,oe,ge,ke,Be,tt,Et,_r,Ki,Ht)=>(d._OrtCreateSessionOptions=Le.Z)(W,oe,ge,ke,Be,tt,Et,_r,Ki,Ht),d._OrtAppendExecutionProvider=(W,oe)=>(d._OrtAppendExecutionProvider=Le._)(W,oe),d._OrtAddSessionConfigEntry=(W,oe,ge)=>(d._OrtAddSessionConfigEntry=Le.$)(W,oe,ge),d._OrtReleaseSessionOptions=W=>(d._OrtReleaseSessionOptions=Le.aa)(W),d._OrtCreateSession=(W,oe,ge)=>(d._OrtCreateSession=Le.ba)(W,oe,ge),d._OrtReleaseSession=W=>(d._OrtReleaseSession=Le.ca)(W),d._OrtGetInputOutputCount=(W,oe,ge)=>(d._OrtGetInputOutputCount=Le.da)(W,oe,ge),d._OrtGetInputName=(W,oe)=>(d._OrtGetInputName=Le.ea)(W,oe),d._OrtGetOutputName=(W,oe)=>(d._OrtGetOutputName=Le.fa)(W,oe),d._OrtFree=W=>(d._OrtFree=Le.ga)(W),d._OrtCreateTensor=(W,oe,ge,ke,Be)=>(d._OrtCreateTensor=Le.ha)(W,oe,ge,ke,Be),d._OrtGetTensorData=(W,oe,ge,ke,Be)=>(d._OrtGetTensorData=Le.ia)(W,oe,ge,ke,Be),d._OrtReleaseTensor=W=>(d._OrtReleaseTensor=Le.ja)(W),d._OrtCreateRunOptions=(W,oe,ge,ke)=>(d._OrtCreateRunOptions=Le.ka)(W,oe,ge,ke),d._OrtAddRunConfigEntry=(W,oe,ge)=>(d._OrtAddRunConfigEntry=Le.la)(W,oe,ge),d._OrtReleaseRunOptions=W=>(d._OrtReleaseRunOptions=Le.ma)(W),d._OrtRun=(W,oe,ge,ke,Be,tt,Et,_r)=>(d._OrtRun=Le.na)(W,oe,ge,ke,Be,tt,Et,_r),d._OrtEndProfiling=W=>(d._OrtEndProfiling=Le.oa)(W);var yr=d._pthread_self=()=>(yr=d._pthread_self=Le.pa)(),el=d._malloc=W=>(el=d._malloc=Le.qa)(W);d._free=W=>(d._free=Le.ra)(W),d.__emscripten_tls_init=()=>(d.__emscripten_tls_init=Le.sa)();var ho=d.__emscripten_thread_init=(W,oe,ge,ke,Be,tt)=>(ho=d.__emscripten_thread_init=Le.ua)(W,oe,ge,ke,Be,tt);d.__emscripten_thread_crashed=()=>(d.__emscripten_thread_crashed=Le.va)();var kp,Sb=(W,oe,ge,ke)=>(Sb=Le.wa)(W,oe,ge,ke),gd=W=>(gd=Le.xa)(W),tu=d.__emscripten_thread_exit=W=>(tu=d.__emscripten_thread_exit=Le.ya)(W),Ap=d.__emscripten_check_mailbox=()=>(Ap=d.__emscripten_check_mailbox=Le.za)(),Gl=W=>(Gl=Le.Aa)(W),Cb=(W,oe)=>(Cb=Le.Ba)(W,oe),bd=()=>(bd=Le.Ca)(),nu=W=>(nu=Le.Da)(W),Np=W=>(Np=Le.Ea)(W);function Ib(){function W(){if(!kp&&(kp=!0,d.calledRun=!0,!Cn)&&(H||qs(jr),h(d),d.onRuntimeInitialized&&d.onRuntimeInitialized(),!H)){if(d.postRun)for("function"==typeof d.postRun&&(d.postRun=[d.postRun]);d.postRun.length;){var oe=d.postRun.shift();Xo.unshift(oe)}qs(Xo)}}if(!(0<Fi))if(H)h(d),H||qs(jr),startWorker(d);else{if(d.preRun)for("function"==typeof d.preRun&&(d.preRun=[d.preRun]);d.preRun.length;)Ko.unshift(d.preRun.shift());qs(Ko),0<Fi||(d.setStatus?(d.setStatus("Running..."),setTimeout(function(){setTimeout(function(){d.setStatus("")},1),W()},1)):W())}}if(d.keepRuntimeAlive=Mi,d.wasmMemory=He,d.stackAlloc=Np,d.stackSave=bd,d.stackRestore=nu,d.UTF8ToString=Rn,d.stringToUTF8=_i,d.lengthBytesUTF8=qt,d.ExitStatus=Ja,d.PThread=ct,qi=function W(){kp||Ib(),kp||(qi=W)},d.preInit)for("function"==typeof d.preInit&&(d.preInit=[d.preInit]);0<d.preInit.length;)d.preInit.pop()();return Ib(),O.ready});me.exports=A},932:(me,E,P)=>{var F,A=(F=typeof document<"u"&&document.currentScript?document.currentScript.src:void 0,typeof __filename<"u"&&(F=F||__filename),function(O={}){var k,S,C=O;C.ready=new Promise((se,Ce)=>{k=se,S=Ce});var v,b,h,l=Object.assign({},C),d="./this.program",f=(se,Ce)=>{throw Ce},y="object"==typeof window,w="function"==typeof importScripts,D="object"==typeof process&&"object"==typeof process.versions&&"string"==typeof process.versions.node,M="";if(D){var $=P(1384),B=P(908);M=w?B.dirname(M)+"/":__dirname+"/",v=(se,Ce)=>(se=se.startsWith("file://")?new URL(se):B.normalize(se),$.readFileSync(se,Ce?void 0:"utf8")),h=se=>((se=v(se,!0)).buffer||(se=new Uint8Array(se)),se),b=(se,Ce,Ne,Ge=!0)=>{se=se.startsWith("file://")?new URL(se):B.normalize(se),$.readFile(se,Ge?void 0:"utf8",(st,Mt)=>{st?Ne(st):Ce(Ge?Mt.buffer:Mt)})},!C.thisProgram&&1<process.argv.length&&(d=process.argv[1].replace(/\\/g,"/")),process.argv.slice(2),f=(se,Ce)=>{throw process.exitCode=se,Ce},C.inspect=()=>"[Emscripten Module object]"}else(y||w)&&(w?M=self.location.href:typeof document<"u"&&document.currentScript&&(M=document.currentScript.src),F&&(M=F),M=0!==M.indexOf("blob:")?M.substr(0,M.replace(/[?#].*/,"").lastIndexOf("/")+1):"",v=se=>{var Ce=new XMLHttpRequest;return Ce.open("GET",se,!1),Ce.send(null),Ce.responseText},w&&(h=se=>{var Ce=new XMLHttpRequest;return Ce.open("GET",se,!1),Ce.responseType="arraybuffer",Ce.send(null),new Uint8Array(Ce.response)}),b=(se,Ce,Ne)=>{var Ge=new XMLHttpRequest;Ge.open("GET",se,!0),Ge.responseType="arraybuffer",Ge.onload=()=>{200==Ge.status||0==Ge.status&&Ge.response?Ce(Ge.response):Ne()},Ge.onerror=Ne,Ge.send(null)});var z,G=C.print||console.log.bind(console),H=C.printErr||console.error.bind(console);Object.assign(C,l),l=null,C.thisProgram&&(d=C.thisProgram),C.quit&&(f=C.quit),C.wasmBinary&&(z=C.wasmBinary);var te=C.noExitRuntime||!0;"object"!=typeof WebAssembly&&pn("no native wasm support detected");var ae,J,ne,X,K,ve,q=!1;function re(){var se=ae.buffer;C.HEAP8=ne=new Int8Array(se),C.HEAP16=new Int16Array(se),C.HEAP32=K=new Int32Array(se),C.HEAPU8=X=new Uint8Array(se),C.HEAPU16=new Uint16Array(se),C.HEAPU32=ve=new Uint32Array(se),C.HEAPF32=new Float32Array(se),C.HEAPF64=new Float64Array(se)}var le=[],He=[],Le=[];function ot(){var se=C.preRun.shift();le.unshift(se)}var nt,it,yt=0,wt=null,Pt=null;function pn(se){throw C.onAbort&&C.onAbort(se),H(se="Aborted("+se+")"),q=!0,se=new WebAssembly.RuntimeError(se+". Build with -sASSERTIONS for more info."),S(se),se}function Cn(se){return se.startsWith("data:application/octet-stream;base64,")}if(!Cn(nt="ort-wasm.wasm")){var ur=nt;nt=C.locateFile?C.locateFile(ur,M):M+ur}function Ir(se){if(se==nt&&z)return new Uint8Array(z);if(h)return h(se);throw"both async and sync fetching of the wasm failed"}function Ri(se,Ce,Ne){return function(Ge){if(!z&&(y||w)){if("function"==typeof fetch&&!Ge.startsWith("file://"))return fetch(Ge,{credentials:"same-origin"}).then(st=>{if(!st.ok)throw"failed to load wasm binary file at '"+Ge+"'";return st.arrayBuffer()}).catch(()=>Ir(Ge));if(b)return new Promise((st,Mt)=>{b(Ge,qt=>st(new Uint8Array(qt)),Mt)})}return Promise.resolve().then(()=>Ir(Ge))}(se).then(Ge=>WebAssembly.instantiate(Ge,Ce)).then(Ge=>Ge).then(Ne,Ge=>{H("failed to asynchronously prepare wasm: "+Ge),pn(Ge)})}function Ko(se){this.name="ExitStatus",this.message=`Program terminated with exit(${se})`,this.status=se}var jr=se=>{for(;0<se.length;)se.shift()(C)};function Xo(se){this.qa=se-24,this.va=function(Ce){ve[this.qa+4>>2>>>0]=Ce},this.ua=function(Ce){ve[this.qa+8>>2>>>0]=Ce},this.sa=function(Ce,Ne){this.ta(),this.va(Ce),this.ua(Ne)},this.ta=function(){ve[this.qa+16>>2>>>0]=0}}var kn,Mi=typeof TextDecoder<"u"?new TextDecoder("utf8"):void 0,Lr=(se,Ce,Ne)=>{var Ge=(Ce>>>=0)+Ne;for(Ne=Ce;se[Ne]&&!(Ne>=Ge);)++Ne;if(16<Ne-Ce&&se.buffer&&Mi)return Mi.decode(se.subarray(Ce,Ne));for(Ge="";Ce<Ne;){var st=se[Ce++];if(128&st){var Mt=63&se[Ce++];if(192==(224&st))Ge+=String.fromCharCode((31&st)<<6|Mt);else{var qt=63&se[Ce++];65536>(st=224==(240&st)?(15&st)<<12|Mt<<6|qt:(7&st)<<18|Mt<<12|qt<<6|63&se[Ce++])?Ge+=String.fromCharCode(st):(st-=65536,Ge+=String.fromCharCode(55296|st>>10,56320|1023&st))}}else Ge+=String.fromCharCode(st)}return Ge},Gr=(se,Ce)=>(se>>>=0)?Lr(X,se,Ce):"",Fi=se=>{for(var Ce=0,Ne=0;Ne<se.length;++Ne){var Ge=se.charCodeAt(Ne);127>=Ge?Ce++:2047>=Ge?Ce+=2:55296<=Ge&&57343>=Ge?(Ce+=4,++Ne):Ce+=3}return Ce},Yo=(se,Ce,Ne,Ge)=>{if(!(0<Ge))return 0;var st=Ne>>>=0;Ge=Ne+Ge-1;for(var Mt=0;Mt<se.length;++Mt){var qt=se.charCodeAt(Mt);if(55296<=qt&&57343>=qt&&(qt=65536+((1023&qt)<<10)|1023&se.charCodeAt(++Mt)),127>=qt){if(Ne>=Ge)break;Ce[Ne++>>>0]=qt}else{if(2047>=qt){if(Ne+1>=Ge)break;Ce[Ne++>>>0]=192|qt>>6}else{if(65535>=qt){if(Ne+2>=Ge)break;Ce[Ne++>>>0]=224|qt>>12}else{if(Ne+3>=Ge)break;Ce[Ne++>>>0]=240|qt>>18,Ce[Ne++>>>0]=128|qt>>12&63}Ce[Ne++>>>0]=128|qt>>6&63}Ce[Ne++>>>0]=128|63&qt}}return Ce[Ne>>>0]=0,Ne-st},qi=se=>se%4==0&&(se%100!=0||se%400==0),ws=[0,31,60,91,121,152,182,213,244,274,305,335],Hr=[0,31,59,90,120,151,181,212,243,273,304,334],uo=se=>{var Ce=Fi(se)+1,Ne=Vl(Ce);return Ne&&Yo(se,X,Ne,Ce),Ne},Qa={},An=()=>{if(!kn){var se,Ce={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:("object"==typeof navigator&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:d||"./this.program"};for(se in Qa)void 0===Qa[se]?delete Ce[se]:Ce[se]=Qa[se];var Ne=[];for(se in Ce)Ne.push(`${se}=${Ce[se]}`);kn=Ne}return kn},Qc=[null,[],[]],Ja=se=>(Ja=(()=>{if("object"==typeof crypto&&"function"==typeof crypto.getRandomValues)return Ge=>crypto.getRandomValues(Ge);if(D)try{var Ce=P(760);if(Ce.randomFillSync)return Ge=>Ce.randomFillSync(Ge);var Ne=Ce.randomBytes;return Ge=>(Ge.set(Ne(Ge.byteLength)),Ge)}catch{}pn("initRandomDevice")})())(se),Bl=[31,29,31,30,31,30,31,31,30,31,30,31],Jc=[31,28,31,30,31,30,31,31,30,31,30,31];function Kt(se,Ce,Ne,Ge){function st(Ve,gn,nr){for(Ve="number"==typeof Ve?Ve.toString():Ve||"";Ve.length<gn;)Ve=nr[0]+Ve;return Ve}function Mt(Ve,gn){return st(Ve,gn,"0")}function qt(Ve,gn){function nr(hd){return 0>hd?-1:0<hd?1:0}var Ks;return 0===(Ks=nr(Ve.getFullYear()-gn.getFullYear()))&&0===(Ks=nr(Ve.getMonth()-gn.getMonth()))&&(Ks=nr(Ve.getDate()-gn.getDate())),Ks}function Br(Ve){switch(Ve.getDay()){case 0:return new Date(Ve.getFullYear()-1,11,29);case 1:return Ve;case 2:return new Date(Ve.getFullYear(),0,3);case 3:return new Date(Ve.getFullYear(),0,2);case 4:return new Date(Ve.getFullYear(),0,1);case 5:return new Date(Ve.getFullYear()-1,11,31);case 6:return new Date(Ve.getFullYear()-1,11,30)}}function _i(Ve){var gn=Ve.ma;for(Ve=new Date(new Date(Ve.na+1900,0,1).getTime());0<gn;){var nr=Ve.getMonth(),Ks=(qi(Ve.getFullYear())?Bl:Jc)[nr];if(!(gn>Ks-Ve.getDate())){Ve.setDate(Ve.getDate()+gn);break}gn-=Ks-Ve.getDate()+1,Ve.setDate(1),11>nr?Ve.setMonth(nr+1):(Ve.setMonth(0),Ve.setFullYear(Ve.getFullYear()+1))}return nr=new Date(Ve.getFullYear()+1,0,4),gn=Br(new Date(Ve.getFullYear(),0,4)),nr=Br(nr),0>=qt(gn,Ve)?0>=qt(nr,Ve)?Ve.getFullYear()+1:Ve.getFullYear():Ve.getFullYear()-1}se>>>=0,Ce>>>=0,Ne>>>=0;var vi=K[40+(Ge>>>=0)>>2>>>0];for(var xi in Ge={ya:K[Ge>>2>>>0],xa:K[Ge+4>>2>>>0],oa:K[Ge+8>>2>>>0],ra:K[Ge+12>>2>>>0],pa:K[Ge+16>>2>>>0],na:K[Ge+20>>2>>>0],ha:K[Ge+24>>2>>>0],ma:K[Ge+28>>2>>>0],Aa:K[Ge+32>>2>>>0],wa:K[Ge+36>>2>>>0],za:vi?Gr(vi):""},Ne=Gr(Ne),vi={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"})Ne=Ne.replace(new RegExp(xi,"g"),vi[xi]);var Ve,gn,Ul="Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),dd="January February March April May June July August September October November December".split(" ");for(xi in vi={"%a":Ve=>Ul[Ve.ha].substring(0,3),"%A":Ve=>Ul[Ve.ha],"%b":Ve=>dd[Ve.pa].substring(0,3),"%B":Ve=>dd[Ve.pa],"%C":Ve=>Mt((Ve.na+1900)/100|0,2),"%d":Ve=>Mt(Ve.ra,2),"%e":Ve=>st(Ve.ra,2," "),"%g":Ve=>_i(Ve).toString().substring(2),"%G":Ve=>_i(Ve),"%H":Ve=>Mt(Ve.oa,2),"%I":Ve=>(0==(Ve=Ve.oa)?Ve=12:12<Ve&&(Ve-=12),Mt(Ve,2)),"%j":Ve=>{for(var gn=0,nr=0;nr<=Ve.pa-1;gn+=(qi(Ve.na+1900)?Bl:Jc)[nr++]);return Mt(Ve.ra+gn,3)},"%m":Ve=>Mt(Ve.pa+1,2),"%M":Ve=>Mt(Ve.xa,2),"%n":()=>"\n","%p":Ve=>0<=Ve.oa&&12>Ve.oa?"AM":"PM","%S":Ve=>Mt(Ve.ya,2),"%t":()=>"\t","%u":Ve=>Ve.ha||7,"%U":Ve=>Mt(Math.floor((Ve.ma+7-Ve.ha)/7),2),"%V":Ve=>{var gn=Math.floor((Ve.ma+7-(Ve.ha+6)%7)/7);if(2>=(Ve.ha+371-Ve.ma-2)%7&&gn++,gn)53==gn&&(4==(nr=(Ve.ha+371-Ve.ma)%7)||3==nr&&qi(Ve.na)||(gn=1));else{gn=52;var nr=(Ve.ha+7-Ve.ma-1)%7;(4==nr||5==nr&&qi(Ve.na%400-1))&&gn++}return Mt(gn,2)},"%w":Ve=>Ve.ha,"%W":Ve=>Mt(Math.floor((Ve.ma+7-(Ve.ha+6)%7)/7),2),"%y":Ve=>(Ve.na+1900).toString().substring(2),"%Y":Ve=>Ve.na+1900,"%z":Ve=>(0<=(Ve=Ve.wa)?"+":"-")+("0000"+((Ve=Math.abs(Ve)/60)/60*100+Ve%60)).slice(-4),"%Z":Ve=>Ve.za,"%%":()=>"%"},Ne=Ne.replace(/%%/g,"\0\0"),vi)Ne.includes(xi)&&(Ne=Ne.replace(new RegExp(xi,"g"),vi[xi](Ge)));return Ve=Ne=Ne.replace(/\0\0/g,"%"),gn=Array(Fi(Ve)+1),Yo(Ve,gn,0,gn.length),(xi=gn).length>Ce?0:(ne.set(xi,se>>>0),xi.length-1)}var eu={a:function(se,Ce,Ne){throw new Xo(se>>>=0).sa(Ce>>>0,Ne>>>0),se},e:function(){return 0},I:function(){},y:function(){},A:function(){},K:function(){return 0},G:function(){},B:function(){},F:function(){},g:function(){},z:function(){},w:function(){},H:function(){},x:function(){},k:()=>!0,n:function(se,Ce,Ne){se=Ce+2097152>>>0<4194305-!!se?(se>>>0)+4294967296*Ce:NaN,Ne>>>=0,se=new Date(1e3*se),K[Ne>>2>>>0]=se.getUTCSeconds(),K[Ne+4>>2>>>0]=se.getUTCMinutes(),K[Ne+8>>2>>>0]=se.getUTCHours(),K[Ne+12>>2>>>0]=se.getUTCDate(),K[Ne+16>>2>>>0]=se.getUTCMonth(),K[Ne+20>>2>>>0]=se.getUTCFullYear()-1900,K[Ne+24>>2>>>0]=se.getUTCDay(),K[Ne+28>>2>>>0]=(se.getTime()-Date.UTC(se.getUTCFullYear(),0,1,0,0,0,0))/864e5|0},o:function(se,Ce,Ne){se=Ce+2097152>>>0<4194305-!!se?(se>>>0)+4294967296*Ce:NaN,Ne>>>=0,se=new Date(1e3*se),K[Ne>>2>>>0]=se.getSeconds(),K[Ne+4>>2>>>0]=se.getMinutes(),K[Ne+8>>2>>>0]=se.getHours(),K[Ne+12>>2>>>0]=se.getDate(),K[Ne+16>>2>>>0]=se.getMonth(),K[Ne+20>>2>>>0]=se.getFullYear()-1900,K[Ne+24>>2>>>0]=se.getDay(),K[Ne+28>>2>>>0]=(qi(se.getFullYear())?ws:Hr)[se.getMonth()]+se.getDate()-1|0,K[Ne+36>>2>>>0]=-60*se.getTimezoneOffset(),Ce=new Date(se.getFullYear(),6,1).getTimezoneOffset();var Ge=new Date(se.getFullYear(),0,1).getTimezoneOffset();K[Ne+32>>2>>>0]=0|(Ce!=Ge&&se.getTimezoneOffset()==Math.min(Ge,Ce))},p:function(se){se>>>=0;var Ce=new Date(K[se+20>>2>>>0]+1900,K[se+16>>2>>>0],K[se+12>>2>>>0],K[se+8>>2>>>0],K[se+4>>2>>>0],K[se>>2>>>0],0),Ne=K[se+32>>2>>>0],Ge=Ce.getTimezoneOffset(),st=new Date(Ce.getFullYear(),6,1).getTimezoneOffset(),Mt=new Date(Ce.getFullYear(),0,1).getTimezoneOffset(),qt=Math.min(Mt,st);return 0>Ne?K[se+32>>2>>>0]=+(st!=Mt&&qt==Ge):0<Ne!=(qt==Ge)&&(st=Math.max(Mt,st),Ce.setTime(Ce.getTime()+6e4*((0<Ne?qt:st)-Ge))),K[se+24>>2>>>0]=Ce.getDay(),K[se+28>>2>>>0]=(qi(Ce.getFullYear())?ws:Hr)[Ce.getMonth()]+Ce.getDate()-1|0,K[se>>2>>>0]=Ce.getSeconds(),K[se+4>>2>>>0]=Ce.getMinutes(),K[se+8>>2>>>0]=Ce.getHours(),K[se+12>>2>>>0]=Ce.getDate(),K[se+16>>2>>>0]=Ce.getMonth(),K[se+20>>2>>>0]=Ce.getYear(),se=Ce.getTime()/1e3,Bn((it=se,1<=+Math.abs(it)?0<it?+Math.floor(it/4294967296)>>>0:~~+Math.ceil((it-+(~~it>>>0))/4294967296)>>>0:0)),se>>>0},l:function(){return-52},m:function(){},u:function(se,Ce,Ne){function Ge(_i){return(_i=_i.toTimeString().match(/\(([A-Za-z ]+)\)$/))?_i[1]:"GMT"}Ne>>>=0;var st=(new Date).getFullYear(),Mt=new Date(st,0,1),qt=new Date(st,6,1);st=Mt.getTimezoneOffset();var Br=qt.getTimezoneOffset();ve[se>>>0>>2>>>0]=60*Math.max(st,Br),K[Ce>>>0>>2>>>0]=+(st!=Br),se=Ge(Mt),Ce=Ge(qt),se=uo(se),Ce=uo(Ce),Br<st?(ve[Ne>>2>>>0]=se,ve[Ne+4>>2>>>0]=Ce):(ve[Ne>>2>>>0]=Ce,ve[Ne+4>>2>>>0]=se)},d:()=>{pn("")},h:function(){return Date.now()},v:function(){return 4294901760},b:()=>performance.now(),J:function(se,Ce,Ne){return X.copyWithin(se>>>0>>>0,(Ce>>>=0)>>>0,Ce+(Ne>>>0)>>>0)},t:function(se){var Ce=X.length;if(4294901760<(se>>>=0))return!1;for(var Ne=1;4>=Ne;Ne*=2){var Ge=Ce*(1+.2/Ne);Ge=Math.min(Ge,se+100663296);var st=Math;Ge=Math.max(se,Ge);e:{st=st.min.call(st,4294901760,Ge+(65536-Ge%65536)%65536)-ae.buffer.byteLength+65535>>>16;try{ae.grow(st),re();var Mt=1;break e}catch{}Mt=void 0}if(Mt)return!0}return!1},D:function(se,Ce){se>>>=0,Ce>>>=0;var Ne=0;return An().forEach(function(Ge,st){var Mt=Ce+Ne;for(st=ve[se+4*st>>2>>>0]=Mt,Mt=0;Mt<Ge.length;++Mt)ne[st++>>0>>>0]=Ge.charCodeAt(Mt);ne[st>>0>>>0]=0,Ne+=Ge.length+1}),0},E:function(se,Ce){se>>>=0,Ce>>>=0;var Ne=An();ve[se>>2>>>0]=Ne.length;var Ge=0;return Ne.forEach(function(st){Ge+=st.length+1}),ve[Ce>>2>>>0]=Ge,0},s:se=>{te||(C.onExit&&C.onExit(se),q=!0),f(se,new Ko(se))},f:()=>52,j:function(){return 52},q:function(){return 70},i:function(se,Ce,Ne,Ge){Ce>>>=0,Ne>>>=0,Ge>>>=0;for(var st=0,Mt=0;Mt<Ne;Mt++){var qt=ve[Ce>>2>>>0],Br=ve[Ce+4>>2>>>0];Ce+=8;for(var _i=0;_i<Br;_i++){var vi=X[qt+_i>>>0],xi=Qc[se];0===vi||10===vi?((1===se?G:H)(Lr(xi,0)),xi.length=0):xi.push(vi)}st+=Br}return ve[Ge>>2>>>0]=st,0},r:function(se,Ce){return Ja(X.subarray((se>>>=0)>>>0,se+(Ce>>>0)>>>0)),0},C:Kt,c:function(se,Ce,Ne,Ge){return Kt(se>>>0,Ce>>>0,Ne>>>0,Ge>>>0)}};(function(){function se(Ne){if(st=Ne=Ne.exports,Mt=Br=>()=>Br()>>>0,qt=Br=>_i=>Br(_i)>>>0,(st=Object.assign({},st)).__errno_location=Mt(st.__errno_location),st.malloc=qt(st.malloc),st.stackSave=Mt(st.stackSave),st.stackAlloc=qt(st.stackAlloc),J=Ne=st,ae=J.L,re(),He.unshift(J.M),yt--,C.monitorRunDependencies&&C.monitorRunDependencies(yt),0==yt&&(null!==wt&&(clearInterval(wt),wt=null),Pt)){var Ge=Pt;Pt=null,Ge()}var st,Mt,qt;return Ne}var Ne,Ge,st,Ce={a:eu};if(yt++,C.monitorRunDependencies&&C.monitorRunDependencies(yt),C.instantiateWasm)try{return C.instantiateWasm(Ce,se)}catch(Ne){H("Module.instantiateWasm callback failed with error: "+Ne),S(Ne)}(Ne=Ce,Ge=function(Ne){se(Ne.instance)},st=nt,z||"function"!=typeof WebAssembly.instantiateStreaming||Cn(st)||st.startsWith("file://")||D||"function"!=typeof fetch?Ri(st,Ne,Ge):fetch(st,{credentials:"same-origin"}).then(Mt=>WebAssembly.instantiateStreaming(Mt,Ne).then(Ge,function(qt){return H("wasm streaming compile failed: "+qt),H("falling back to ArrayBuffer instantiation"),Ri(st,Ne,Ge)}))).catch(S)})(),C._OrtInit=(se,Ce)=>(C._OrtInit=J.N)(se,Ce),C._OrtGetLastError=(se,Ce)=>(C._OrtGetLastError=J.O)(se,Ce),C._OrtCreateSessionOptions=(se,Ce,Ne,Ge,st,Mt,qt,Br,_i,vi)=>(C._OrtCreateSessionOptions=J.P)(se,Ce,Ne,Ge,st,Mt,qt,Br,_i,vi),C._OrtAppendExecutionProvider=(se,Ce)=>(C._OrtAppendExecutionProvider=J.Q)(se,Ce),C._OrtAddSessionConfigEntry=(se,Ce,Ne)=>(C._OrtAddSessionConfigEntry=J.R)(se,Ce,Ne),C._OrtReleaseSessionOptions=se=>(C._OrtReleaseSessionOptions=J.S)(se),C._OrtCreateSession=(se,Ce,Ne)=>(C._OrtCreateSession=J.T)(se,Ce,Ne),C._OrtReleaseSession=se=>(C._OrtReleaseSession=J.U)(se),C._OrtGetInputOutputCount=(se,Ce,Ne)=>(C._OrtGetInputOutputCount=J.V)(se,Ce,Ne),C._OrtGetInputName=(se,Ce)=>(C._OrtGetInputName=J.W)(se,Ce),C._OrtGetOutputName=(se,Ce)=>(C._OrtGetOutputName=J.X)(se,Ce),C._OrtFree=se=>(C._OrtFree=J.Y)(se),C._OrtCreateTensor=(se,Ce,Ne,Ge,st)=>(C._OrtCreateTensor=J.Z)(se,Ce,Ne,Ge,st),C._OrtGetTensorData=(se,Ce,Ne,Ge,st)=>(C._OrtGetTensorData=J._)(se,Ce,Ne,Ge,st),C._OrtReleaseTensor=se=>(C._OrtReleaseTensor=J.$)(se),C._OrtCreateRunOptions=(se,Ce,Ne,Ge)=>(C._OrtCreateRunOptions=J.aa)(se,Ce,Ne,Ge),C._OrtAddRunConfigEntry=(se,Ce,Ne)=>(C._OrtAddRunConfigEntry=J.ba)(se,Ce,Ne),C._OrtReleaseRunOptions=se=>(C._OrtReleaseRunOptions=J.ca)(se),C._OrtRun=(se,Ce,Ne,Ge,st,Mt,qt,Br)=>(C._OrtRun=J.da)(se,Ce,Ne,Ge,st,Mt,qt,Br),C._OrtEndProfiling=se=>(C._OrtEndProfiling=J.ea)(se);var Vl=C._malloc=se=>(Vl=C._malloc=J.fa)(se);C._free=se=>(C._free=J.ga)(se);var Rn,Bn=se=>(Bn=J.ia)(se),zl=()=>(zl=J.ja)(),ct=se=>(ct=J.ka)(se),qs=se=>(qs=J.la)(se);function ud(){function se(){if(!Rn&&(Rn=!0,C.calledRun=!0,!q)){if(jr(He),k(C),C.onRuntimeInitialized&&C.onRuntimeInitialized(),C.postRun)for("function"==typeof C.postRun&&(C.postRun=[C.postRun]);C.postRun.length;){var Ce=C.postRun.shift();Le.unshift(Ce)}jr(Le)}}if(!(0<yt)){if(C.preRun)for("function"==typeof C.preRun&&(C.preRun=[C.preRun]);C.preRun.length;)ot();jr(le),0<yt||(C.setStatus?(C.setStatus("Running..."),setTimeout(function(){setTimeout(function(){C.setStatus("")},1),se()},1)):se())}}if(C.stackAlloc=qs,C.stackSave=zl,C.stackRestore=ct,C.UTF8ToString=Gr,C.stringToUTF8=(se,Ce,Ne)=>Yo(se,X,Ce,Ne),C.lengthBytesUTF8=Fi,Pt=function se(){Rn||ud(),Rn||(Pt=se)},C.preInit)for("function"==typeof C.preInit&&(C.preInit=[C.preInit]);0<C.preInit.length;)C.preInit.pop()();return ud(),O.ready});me.exports=A},4537:me=>{"use strict";me.exports=function(E,P){for(var F=new Array(arguments.length-1),A=0,O=2,k=!0;O<arguments.length;)F[A++]=arguments[O++];return new Promise(function(S,C){F[A]=function(v){if(k)if(k=!1,v)C(v);else{for(var b=new Array(arguments.length-1),h=0;h<b.length;)b[h++]=arguments[h];S.apply(null,b)}};try{E.apply(P||null,F)}catch(v){k&&(k=!1,C(v))}})}},7419:(me,E)=>{"use strict";var P=E;P.length=function(S){var C=S.length;if(!C)return 0;for(var v=0;--C%4>1&&"="===S.charAt(C);)++v;return Math.ceil(3*S.length)/4-v};for(var F=new Array(64),A=new Array(123),O=0;O<64;)A[F[O]=O<26?O+65:O<52?O+71:O<62?O-4:O-59|43]=O++;P.encode=function(S,C,v){for(var b,h=null,l=[],d=0,f=0;C<v;){var y=S[C++];switch(f){case 0:l[d++]=F[y>>2],b=(3&y)<<4,f=1;break;case 1:l[d++]=F[b|y>>4],b=(15&y)<<2,f=2;break;case 2:l[d++]=F[b|y>>6],l[d++]=F[63&y],f=0}d>8191&&((h||(h=[])).push(String.fromCharCode.apply(String,l)),d=0)}return f&&(l[d++]=F[b],l[d++]=61,1===f&&(l[d++]=61)),h?(d&&h.push(String.fromCharCode.apply(String,l.slice(0,d))),h.join("")):String.fromCharCode.apply(String,l.slice(0,d))};var k="invalid encoding";P.decode=function(S,C,v){for(var b,h=v,l=0,d=0;d<S.length;){var f=S.charCodeAt(d++);if(61===f&&l>1)break;if(void 0===(f=A[f]))throw Error(k);switch(l){case 0:b=f,l=1;break;case 1:C[v++]=b<<2|(48&f)>>4,b=f,l=2;break;case 2:C[v++]=(15&b)<<4|(60&f)>>2,b=f,l=3;break;case 3:C[v++]=(3&b)<<6|f,l=0}}if(1===l)throw Error(k);return v-h},P.test=function(S){return/^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(S)}},9211:me=>{"use strict";function E(){this._listeners={}}me.exports=E,E.prototype.on=function(P,F,A){return(this._listeners[P]||(this._listeners[P]=[])).push({fn:F,ctx:A||this}),this},E.prototype.off=function(P,F){if(void 0===P)this._listeners={};else if(void 0===F)this._listeners[P]=[];else for(var A=this._listeners[P],O=0;O<A.length;)A[O].fn===F?A.splice(O,1):++O;return this},E.prototype.emit=function(P){var F=this._listeners[P];if(F){for(var A=[],O=1;O<arguments.length;)A.push(arguments[O++]);for(O=0;O<F.length;)F[O].fn.apply(F[O++].ctx,A)}return this}},945:me=>{"use strict";function E(k){return typeof Float32Array<"u"?function(){var S=new Float32Array([-0]),C=new Uint8Array(S.buffer),v=128===C[3];function b(f,y,w){S[0]=f,y[w]=C[0],y[w+1]=C[1],y[w+2]=C[2],y[w+3]=C[3]}function h(f,y,w){S[0]=f,y[w]=C[3],y[w+1]=C[2],y[w+2]=C[1],y[w+3]=C[0]}function l(f,y){return C[0]=f[y],C[1]=f[y+1],C[2]=f[y+2],C[3]=f[y+3],S[0]}function d(f,y){return C[3]=f[y],C[2]=f[y+1],C[1]=f[y+2],C[0]=f[y+3],S[0]}k.writeFloatLE=v?b:h,k.writeFloatBE=v?h:b,k.readFloatLE=v?l:d,k.readFloatBE=v?d:l}():function(){function S(v,b,h,l){var d=b<0?1:0;if(d&&(b=-b),0===b)v(1/b>0?0:2147483648,h,l);else if(isNaN(b))v(2143289344,h,l);else if(b>34028234663852886e22)v((d<<31|2139095040)>>>0,h,l);else if(b<11754943508222875e-54)v((d<<31|Math.round(b/1401298464324817e-60))>>>0,h,l);else{var f=Math.floor(Math.log(b)/Math.LN2);v((d<<31|f+127<<23|8388607&Math.round(b*Math.pow(2,-f)*8388608))>>>0,h,l)}}function C(v,b,h){var l=v(b,h),d=2*(l>>31)+1,f=l>>>23&255,y=8388607&l;return 255===f?y?NaN:d*(1/0):0===f?1401298464324817e-60*d*y:d*Math.pow(2,f-150)*(y+8388608)}k.writeFloatLE=S.bind(null,P),k.writeFloatBE=S.bind(null,F),k.readFloatLE=C.bind(null,A),k.readFloatBE=C.bind(null,O)}(),typeof Float64Array<"u"?function(){var S=new Float64Array([-0]),C=new Uint8Array(S.buffer),v=128===C[7];function b(f,y,w){S[0]=f,y[w]=C[0],y[w+1]=C[1],y[w+2]=C[2],y[w+3]=C[3],y[w+4]=C[4],y[w+5]=C[5],y[w+6]=C[6],y[w+7]=C[7]}function h(f,y,w){S[0]=f,y[w]=C[7],y[w+1]=C[6],y[w+2]=C[5],y[w+3]=C[4],y[w+4]=C[3],y[w+5]=C[2],y[w+6]=C[1],y[w+7]=C[0]}function l(f,y){return C[0]=f[y],C[1]=f[y+1],C[2]=f[y+2],C[3]=f[y+3],C[4]=f[y+4],C[5]=f[y+5],C[6]=f[y+6],C[7]=f[y+7],S[0]}function d(f,y){return C[7]=f[y],C[6]=f[y+1],C[5]=f[y+2],C[4]=f[y+3],C[3]=f[y+4],C[2]=f[y+5],C[1]=f[y+6],C[0]=f[y+7],S[0]}k.writeDoubleLE=v?b:h,k.writeDoubleBE=v?h:b,k.readDoubleLE=v?l:d,k.readDoubleBE=v?d:l}():function(){function S(v,b,h,l,d,f){var y=l<0?1:0;if(y&&(l=-l),0===l)v(0,d,f+b),v(1/l>0?0:2147483648,d,f+h);else if(isNaN(l))v(0,d,f+b),v(2146959360,d,f+h);else if(l>17976931348623157e292)v(0,d,f+b),v((y<<31|2146435072)>>>0,d,f+h);else{var w;if(l<22250738585072014e-324)v((w=l/5e-324)>>>0,d,f+b),v((y<<31|w/4294967296)>>>0,d,f+h);else{var D=Math.floor(Math.log(l)/Math.LN2);1024===D&&(D=1023),v(4503599627370496*(w=l*Math.pow(2,-D))>>>0,d,f+b),v((y<<31|D+1023<<20|1048576*w&1048575)>>>0,d,f+h)}}}function C(v,b,h,l,d){var f=v(l,d+b),y=v(l,d+h),w=2*(y>>31)+1,D=y>>>20&2047,M=4294967296*(1048575&y)+f;return 2047===D?M?NaN:w*(1/0):0===D?5e-324*w*M:w*Math.pow(2,D-1075)*(M+4503599627370496)}k.writeDoubleLE=S.bind(null,P,0,4),k.writeDoubleBE=S.bind(null,F,4,0),k.readDoubleLE=C.bind(null,A,0,4),k.readDoubleBE=C.bind(null,O,4,0)}(),k}function P(k,S,C){S[C]=255&k,S[C+1]=k>>>8&255,S[C+2]=k>>>16&255,S[C+3]=k>>>24}function F(k,S,C){S[C]=k>>>24,S[C+1]=k>>>16&255,S[C+2]=k>>>8&255,S[C+3]=255&k}function A(k,S){return(k[S]|k[S+1]<<8|k[S+2]<<16|k[S+3]<<24)>>>0}function O(k,S){return(k[S]<<24|k[S+1]<<16|k[S+2]<<8|k[S+3])>>>0}me.exports=E(E)},7199:module=>{"use strict";function inquire(moduleName){try{var mod=eval("quire".replace(/^/,"re"))(moduleName);if(mod&&(mod.length||Object.keys(mod).length))return mod}catch(me){}return null}module.exports=inquire},6662:me=>{"use strict";me.exports=function(E,P,F){var A=F||8192,O=A>>>1,k=null,S=A;return function(C){if(C<1||C>O)return E(C);S+C>A&&(k=E(A),S=0);var v=P.call(k,S,S+=C);return 7&S&&(S=1+(7|S)),v}}},4997:(me,E)=>{"use strict";var P=E;P.length=function(F){for(var A=0,O=0,k=0;k<F.length;++k)(O=F.charCodeAt(k))<128?A+=1:O<2048?A+=2:55296==(64512&O)&&56320==(64512&F.charCodeAt(k+1))?(++k,A+=4):A+=3;return A},P.read=function(F,A,O){if(O-A<1)return"";for(var k,S=null,C=[],v=0;A<O;)(k=F[A++])<128?C[v++]=k:k>191&&k<224?C[v++]=(31&k)<<6|63&F[A++]:k>239&&k<365?(k=((7&k)<<18|(63&F[A++])<<12|(63&F[A++])<<6|63&F[A++])-65536,C[v++]=55296+(k>>10),C[v++]=56320+(1023&k)):C[v++]=(15&k)<<12|(63&F[A++])<<6|63&F[A++],v>8191&&((S||(S=[])).push(String.fromCharCode.apply(String,C)),v=0);return S?(v&&S.push(String.fromCharCode.apply(String,C.slice(0,v))),S.join("")):String.fromCharCode.apply(String,C.slice(0,v))},P.write=function(F,A,O){for(var k,S,C=O,v=0;v<F.length;++v)(k=F.charCodeAt(v))<128?A[O++]=k:k<2048?(A[O++]=k>>6|192,A[O++]=63&k|128):55296==(64512&k)&&56320==(64512&(S=F.charCodeAt(v+1)))?(++v,A[O++]=(k=65536+((1023&k)<<10)+(1023&S))>>18|240,A[O++]=k>>12&63|128,A[O++]=k>>6&63|128,A[O++]=63&k|128):(A[O++]=k>>12|224,A[O++]=k>>6&63|128,A[O++]=63&k|128);return O-C}},3442:(me,E)=>{"use strict";E.__esModule=!0;var P=function(){function F(A){if(!A)throw new TypeError("Invalid argument; `value` has no value.");this.value=F.EMPTY,A&&F.isGuid(A)&&(this.value=A)}return F.isGuid=function(A){var O=A.toString();return A&&(A instanceof F||F.validator.test(O))},F.create=function(){return new F([F.gen(2),F.gen(1),F.gen(1),F.gen(1),F.gen(3)].join("-"))},F.createEmpty=function(){return new F("emptyguid")},F.parse=function(A){return new F(A)},F.raw=function(){return[F.gen(2),F.gen(1),F.gen(1),F.gen(1),F.gen(3)].join("-")},F.gen=function(A){for(var O="",k=0;k<A;k++)O+=(65536*(1+Math.random())|0).toString(16).substring(1);return O},F.prototype.equals=function(A){return F.isGuid(A)&&this.value===A.toString()},F.prototype.isEmpty=function(){return this.value===F.EMPTY},F.prototype.toString=function(){return this.value},F.prototype.toJSON=function(){return{value:this.value}},F.validator=new RegExp("^[a-z0-9]{8}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{12}$","i"),F.EMPTY="00000000-0000-0000-0000-000000000000",F}();E.Guid=P},2100:(me,E,P)=>{"use strict";me.exports=P(9482)},9482:(me,E,P)=>{"use strict";var F=E;function A(){F.util._configure(),F.Writer._configure(F.BufferWriter),F.Reader._configure(F.BufferReader)}F.build="minimal",F.Writer=P(1173),F.BufferWriter=P(3155),F.Reader=P(1408),F.BufferReader=P(593),F.util=P(9693),F.rpc=P(5994),F.roots=P(5054),F.configure=A,A()},1408:(me,E,P)=>{"use strict";me.exports=C;var F,A=P(9693),O=A.LongBits,k=A.utf8;function S(y,w){return RangeError("index out of range: "+y.pos+" + "+(w||1)+" > "+y.len)}function C(y){this.buf=y,this.pos=0,this.len=y.length}var v,b=typeof Uint8Array<"u"?function(y){if(y instanceof Uint8Array||Array.isArray(y))return new C(y);throw Error("illegal buffer")}:function(y){if(Array.isArray(y))return new C(y);throw Error("illegal buffer")},h=function(){return A.Buffer?function(y){return(C.create=function(w){return A.Buffer.isBuffer(w)?new F(w):b(w)})(y)}:b};function l(){var y=new O(0,0),w=0;if(!(this.len-this.pos>4)){for(;w<3;++w){if(this.pos>=this.len)throw S(this);if(y.lo=(y.lo|(127&this.buf[this.pos])<<7*w)>>>0,this.buf[this.pos++]<128)return y}return y.lo=(y.lo|(127&this.buf[this.pos++])<<7*w)>>>0,y}for(;w<4;++w)if(y.lo=(y.lo|(127&this.buf[this.pos])<<7*w)>>>0,this.buf[this.pos++]<128)return y;if(y.lo=(y.lo|(127&this.buf[this.pos])<<28)>>>0,y.hi=(y.hi|(127&this.buf[this.pos])>>4)>>>0,this.buf[this.pos++]<128)return y;if(w=0,this.len-this.pos>4){for(;w<5;++w)if(y.hi=(y.hi|(127&this.buf[this.pos])<<7*w+3)>>>0,this.buf[this.pos++]<128)return y}else for(;w<5;++w){if(this.pos>=this.len)throw S(this);if(y.hi=(y.hi|(127&this.buf[this.pos])<<7*w+3)>>>0,this.buf[this.pos++]<128)return y}throw Error("invalid varint encoding")}function d(y,w){return(y[w-4]|y[w-3]<<8|y[w-2]<<16|y[w-1]<<24)>>>0}function f(){if(this.pos+8>this.len)throw S(this,8);return new O(d(this.buf,this.pos+=4),d(this.buf,this.pos+=4))}C.create=h(),C.prototype._slice=A.Array.prototype.subarray||A.Array.prototype.slice,C.prototype.uint32=(v=4294967295,function(){if(v=(127&this.buf[this.pos])>>>0,this.buf[this.pos++]<128||(v=(v|(127&this.buf[this.pos])<<7)>>>0,this.buf[this.pos++]<128)||(v=(v|(127&this.buf[this.pos])<<14)>>>0,this.buf[this.pos++]<128)||(v=(v|(127&this.buf[this.pos])<<21)>>>0,this.buf[this.pos++]<128)||(v=(v|(15&this.buf[this.pos])<<28)>>>0,this.buf[this.pos++]<128))return v;if((this.pos+=5)>this.len)throw this.pos=this.len,S(this,10);return v}),C.prototype.int32=function(){return 0|this.uint32()},C.prototype.sint32=function(){var y=this.uint32();return y>>>1^-(1&y)|0},C.prototype.bool=function(){return 0!==this.uint32()},C.prototype.fixed32=function(){if(this.pos+4>this.len)throw S(this,4);return d(this.buf,this.pos+=4)},C.prototype.sfixed32=function(){if(this.pos+4>this.len)throw S(this,4);return 0|d(this.buf,this.pos+=4)},C.prototype.float=function(){if(this.pos+4>this.len)throw S(this,4);var y=A.float.readFloatLE(this.buf,this.pos);return this.pos+=4,y},C.prototype.double=function(){if(this.pos+8>this.len)throw S(this,4);var y=A.float.readDoubleLE(this.buf,this.pos);return this.pos+=8,y},C.prototype.bytes=function(){var y=this.uint32(),w=this.pos,D=this.pos+y;if(D>this.len)throw S(this,y);return this.pos+=y,Array.isArray(this.buf)?this.buf.slice(w,D):w===D?new this.buf.constructor(0):this._slice.call(this.buf,w,D)},C.prototype.string=function(){var y=this.bytes();return k.read(y,0,y.length)},C.prototype.skip=function(y){if("number"==typeof y){if(this.pos+y>this.len)throw S(this,y);this.pos+=y}else do{if(this.pos>=this.len)throw S(this)}while(128&this.buf[this.pos++]);return this},C.prototype.skipType=function(y){switch(y){case 0:this.skip();break;case 1:this.skip(8);break;case 2:this.skip(this.uint32());break;case 3:for(;4!=(y=7&this.uint32());)this.skipType(y);break;case 5:this.skip(4);break;default:throw Error("invalid wire type "+y+" at offset "+this.pos)}return this},C._configure=function(y){F=y,C.create=h(),F._configure();var w=A.Long?"toLong":"toNumber";A.merge(C.prototype,{int64:function(){return l.call(this)[w](!1)},uint64:function(){return l.call(this)[w](!0)},sint64:function(){return l.call(this).zzDecode()[w](!1)},fixed64:function(){return f.call(this)[w](!0)},sfixed64:function(){return f.call(this)[w](!1)}})}},593:(me,E,P)=>{"use strict";me.exports=O;var F=P(1408);(O.prototype=Object.create(F.prototype)).constructor=O;var A=P(9693);function O(k){F.call(this,k)}O._configure=function(){A.Buffer&&(O.prototype._slice=A.Buffer.prototype.slice)},O.prototype.string=function(){var k=this.uint32();return this.buf.utf8Slice?this.buf.utf8Slice(this.pos,this.pos=Math.min(this.pos+k,this.len)):this.buf.toString("utf-8",this.pos,this.pos=Math.min(this.pos+k,this.len))},O._configure()},5054:me=>{"use strict";me.exports={}},5994:(me,E,P)=>{"use strict";E.Service=P(7948)},7948:(me,E,P)=>{"use strict";me.exports=A;var F=P(9693);function A(O,k,S){if("function"!=typeof O)throw TypeError("rpcImpl must be a function");F.EventEmitter.call(this),this.rpcImpl=O,this.requestDelimited=!!k,this.responseDelimited=!!S}(A.prototype=Object.create(F.EventEmitter.prototype)).constructor=A,A.prototype.rpcCall=function O(k,S,C,v,b){if(!v)throw TypeError("request must be specified");var h=this;if(!b)return F.asPromise(O,h,k,S,C,v);if(h.rpcImpl)try{return h.rpcImpl(k,S[h.requestDelimited?"encodeDelimited":"encode"](v).finish(),function(l,d){if(l)return h.emit("error",l,k),b(l);if(null!==d){if(!(d instanceof C))try{d=C[h.responseDelimited?"decodeDelimited":"decode"](d)}catch(f){return h.emit("error",f,k),b(f)}return h.emit("data",d,k),b(null,d)}h.end(!0)})}catch(l){return h.emit("error",l,k),void setTimeout(function(){b(l)},0)}else setTimeout(function(){b(Error("already ended"))},0)},A.prototype.end=function(O){return this.rpcImpl&&(O||this.rpcImpl(null,null,null),this.rpcImpl=null,this.emit("end").off()),this}},1945:(me,E,P)=>{"use strict";me.exports=A;var F=P(9693);function A(C,v){this.lo=C>>>0,this.hi=v>>>0}var O=A.zero=new A(0,0);O.toNumber=function(){return 0},O.zzEncode=O.zzDecode=function(){return this},O.length=function(){return 1};var k=A.zeroHash="\0\0\0\0\0\0\0\0";A.fromNumber=function(C){if(0===C)return O;var v=C<0;v&&(C=-C);var b=C>>>0,h=(C-b)/4294967296>>>0;return v&&(h=~h>>>0,b=~b>>>0,++b>4294967295&&(b=0,++h>4294967295&&(h=0))),new A(b,h)},A.from=function(C){if("number"==typeof C)return A.fromNumber(C);if(F.isString(C)){if(!F.Long)return A.fromNumber(parseInt(C,10));C=F.Long.fromString(C)}return C.low||C.high?new A(C.low>>>0,C.high>>>0):O},A.prototype.toNumber=function(C){if(!C&&this.hi>>>31){var v=1+~this.lo>>>0,b=~this.hi>>>0;return v||(b=b+1>>>0),-(v+4294967296*b)}return this.lo+4294967296*this.hi},A.prototype.toLong=function(C){return F.Long?new F.Long(0|this.lo,0|this.hi,!!C):{low:0|this.lo,high:0|this.hi,unsigned:!!C}};var S=String.prototype.charCodeAt;A.fromHash=function(C){return C===k?O:new A((S.call(C,0)|S.call(C,1)<<8|S.call(C,2)<<16|S.call(C,3)<<24)>>>0,(S.call(C,4)|S.call(C,5)<<8|S.call(C,6)<<16|S.call(C,7)<<24)>>>0)},A.prototype.toHash=function(){return String.fromCharCode(255&this.lo,this.lo>>>8&255,this.lo>>>16&255,this.lo>>>24,255&this.hi,this.hi>>>8&255,this.hi>>>16&255,this.hi>>>24)},A.prototype.zzEncode=function(){var C=this.hi>>31;return this.hi=((this.hi<<1|this.lo>>>31)^C)>>>0,this.lo=(this.lo<<1^C)>>>0,this},A.prototype.zzDecode=function(){var C=-(1&this.lo);return this.lo=((this.lo>>>1|this.hi<<31)^C)>>>0,this.hi=(this.hi>>>1^C)>>>0,this},A.prototype.length=function(){var C=this.lo,v=(this.lo>>>28|this.hi<<4)>>>0,b=this.hi>>>24;return 0===b?0===v?C<16384?C<128?1:2:C<2097152?3:4:v<16384?v<128?5:6:v<2097152?7:8:b<128?9:10}},9693:function(me,E,P){"use strict";var F=E;function A(k,S,C){for(var v=Object.keys(S),b=0;b<v.length;++b)void 0!==k[v[b]]&&C||(k[v[b]]=S[v[b]]);return k}function O(k){function S(C,v){if(!(this instanceof S))return new S(C,v);Object.defineProperty(this,"message",{get:function(){return C}}),Error.captureStackTrace?Error.captureStackTrace(this,S):Object.defineProperty(this,"stack",{value:(new Error).stack||""}),v&&A(this,v)}return S.prototype=Object.create(Error.prototype,{constructor:{value:S,writable:!0,enumerable:!1,configurable:!0},name:{get:function(){return k},set:void 0,enumerable:!1,configurable:!0},toString:{value:function(){return this.name+": "+this.message},writable:!0,enumerable:!1,configurable:!0}}),S}F.asPromise=P(4537),F.base64=P(7419),F.EventEmitter=P(9211),F.float=P(945),F.inquire=P(7199),F.utf8=P(4997),F.pool=P(6662),F.LongBits=P(1945),F.isNode=!!(typeof global<"u"&&global&&global.process&&global.process.versions&&global.process.versions.node),F.global=F.isNode&&global||typeof window<"u"&&window||typeof self<"u"&&self||this,F.emptyArray=Object.freeze?Object.freeze([]):[],F.emptyObject=Object.freeze?Object.freeze({}):{},F.isInteger=Number.isInteger||function(k){return"number"==typeof k&&isFinite(k)&&Math.floor(k)===k},F.isString=function(k){return"string"==typeof k||k instanceof String},F.isObject=function(k){return k&&"object"==typeof k},F.isset=F.isSet=function(k,S){var C=k[S];return!(null==C||!k.hasOwnProperty(S))&&("object"!=typeof C||(Array.isArray(C)?C.length:Object.keys(C).length)>0)},F.Buffer=function(){try{var k=F.inquire("buffer").Buffer;return k.prototype.utf8Write?k:null}catch{return null}}(),F._Buffer_from=null,F._Buffer_allocUnsafe=null,F.newBuffer=function(k){return"number"==typeof k?F.Buffer?F._Buffer_allocUnsafe(k):new F.Array(k):F.Buffer?F._Buffer_from(k):typeof Uint8Array>"u"?k:new Uint8Array(k)},F.Array=typeof Uint8Array<"u"?Uint8Array:Array,F.Long=F.global.dcodeIO&&F.global.dcodeIO.Long||F.global.Long||F.inquire("long"),F.key2Re=/^true|false|0|1$/,F.key32Re=/^-?(?:0|[1-9][0-9]*)$/,F.key64Re=/^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/,F.longToHash=function(k){return k?F.LongBits.from(k).toHash():F.LongBits.zeroHash},F.longFromHash=function(k,S){var C=F.LongBits.fromHash(k);return F.Long?F.Long.fromBits(C.lo,C.hi,S):C.toNumber(!!S)},F.merge=A,F.lcFirst=function(k){return k.charAt(0).toLowerCase()+k.substring(1)},F.newError=O,F.ProtocolError=O("ProtocolError"),F.oneOfGetter=function(k){for(var S={},C=0;C<k.length;++C)S[k[C]]=1;return function(){for(var v=Object.keys(this),b=v.length-1;b>-1;--b)if(1===S[v[b]]&&null!=this[v[b]])return v[b]}},F.oneOfSetter=function(k){return function(S){for(var C=0;C<k.length;++C)k[C]!==S&&delete this[k[C]]}},F.toJSONOptions={longs:String,enums:String,bytes:String,json:!0},F._configure=function(){var k=F.Buffer;k?(F._Buffer_from=k.from!==Uint8Array.from&&k.from||function(S,C){return new k(S,C)},F._Buffer_allocUnsafe=k.allocUnsafe||function(S){return new k(S)}):F._Buffer_from=F._Buffer_allocUnsafe=null}},1173:(me,E,P)=>{"use strict";me.exports=h;var F,A=P(9693),O=A.LongBits,k=A.base64,S=A.utf8;function C(M,$,B){this.fn=M,this.len=$,this.next=void 0,this.val=B}function v(){}function b(M){this.head=M.head,this.tail=M.tail,this.len=M.len,this.next=M.states}function h(){this.len=0,this.head=new C(v,0,0),this.tail=this.head,this.states=null}var l=function(){return A.Buffer?function(){return(h.create=function(){return new F})()}:function(){return new h}};function d(M,$,B){$[B]=255&M}function f(M,$){this.len=M,this.next=void 0,this.val=$}function y(M,$,B){for(;M.hi;)$[B++]=127&M.lo|128,M.lo=(M.lo>>>7|M.hi<<25)>>>0,M.hi>>>=7;for(;M.lo>127;)$[B++]=127&M.lo|128,M.lo=M.lo>>>7;$[B++]=M.lo}function w(M,$,B){$[B]=255&M,$[B+1]=M>>>8&255,$[B+2]=M>>>16&255,$[B+3]=M>>>24}h.create=l(),h.alloc=function(M){return new A.Array(M)},A.Array!==Array&&(h.alloc=A.pool(h.alloc,A.Array.prototype.subarray)),h.prototype._push=function(M,$,B){return this.tail=this.tail.next=new C(M,$,B),this.len+=$,this},(f.prototype=Object.create(C.prototype)).fn=function(M,$,B){for(;M>127;)$[B++]=127&M|128,M>>>=7;$[B]=M},h.prototype.uint32=function(M){return this.len+=(this.tail=this.tail.next=new f((M>>>=0)<128?1:M<16384?2:M<2097152?3:M<268435456?4:5,M)).len,this},h.prototype.int32=function(M){return M<0?this._push(y,10,O.fromNumber(M)):this.uint32(M)},h.prototype.sint32=function(M){return this.uint32((M<<1^M>>31)>>>0)},h.prototype.int64=h.prototype.uint64=function(M){var $=O.from(M);return this._push(y,$.length(),$)},h.prototype.sint64=function(M){var $=O.from(M).zzEncode();return this._push(y,$.length(),$)},h.prototype.bool=function(M){return this._push(d,1,M?1:0)},h.prototype.sfixed32=h.prototype.fixed32=function(M){return this._push(w,4,M>>>0)},h.prototype.sfixed64=h.prototype.fixed64=function(M){var $=O.from(M);return this._push(w,4,$.lo)._push(w,4,$.hi)},h.prototype.float=function(M){return this._push(A.float.writeFloatLE,4,M)},h.prototype.double=function(M){return this._push(A.float.writeDoubleLE,8,M)};var D=A.Array.prototype.set?function(M,$,B){$.set(M,B)}:function(M,$,B){for(var z=0;z<M.length;++z)$[B+z]=M[z]};h.prototype.bytes=function(M){var $=M.length>>>0;if(!$)return this._push(d,1,0);if(A.isString(M)){var B=h.alloc($=k.length(M));k.decode(M,B,0),M=B}return this.uint32($)._push(D,$,M)},h.prototype.string=function(M){var $=S.length(M);return $?this.uint32($)._push(S.write,$,M):this._push(d,1,0)},h.prototype.fork=function(){return this.states=new b(this),this.head=this.tail=new C(v,0,0),this.len=0,this},h.prototype.reset=function(){return this.states?(this.head=this.states.head,this.tail=this.states.tail,this.len=this.states.len,this.states=this.states.next):(this.head=this.tail=new C(v,0,0),this.len=0),this},h.prototype.ldelim=function(){var M=this.head,$=this.tail,B=this.len;return this.reset().uint32(B),B&&(this.tail.next=M.next,this.tail=$,this.len+=B),this},h.prototype.finish=function(){for(var M=this.head.next,$=this.constructor.alloc(this.len),B=0;M;)M.fn(M.val,$,B),B+=M.len,M=M.next;return $},h._configure=function(M){F=M,h.create=l(),F._configure()}},3155:(me,E,P)=>{"use strict";me.exports=O;var F=P(1173);(O.prototype=Object.create(F.prototype)).constructor=O;var A=P(9693);function O(){F.call(this)}function k(S,C,v){S.length<40?A.utf8.write(S,C,v):C.utf8Write?C.utf8Write(S,v):C.write(S,v)}O._configure=function(){O.alloc=A._Buffer_allocUnsafe,O.writeBytesBuffer=A.Buffer&&A.Buffer.prototype instanceof Uint8Array&&"set"===A.Buffer.prototype.set.name?function(S,C,v){C.set(S,v)}:function(S,C,v){if(S.copy)S.copy(C,v,0,S.length);else for(var b=0;b<S.length;)C[v++]=S[b++]}},O.prototype.bytes=function(S){A.isString(S)&&(S=A._Buffer_from(S,"base64"));var C=S.length>>>0;return this.uint32(C),C&&this._push(O.writeBytesBuffer,C,S),this},O.prototype.string=function(S){var C=A.Buffer.byteLength(S);return this.uint32(C),C&&this._push(k,C,S),this},O._configure()},4154:me=>{"use strict";me.exports='"use strict";var e={},a="object"==typeof process&&"object"==typeof process.versions&&"string"==typeof process.versions.node;if(a){var r=require("worker_threads"),t=r.parentPort;t.on("message",(e=>onmessage({data:e})));var s=require("fs");Object.assign(global,{self:global,require:require,Module:e,location:{href:__filename},Worker:r.Worker,importScripts:e=>(0,eval)(s.readFileSync(e,"utf8")+"//# sourceURL="+e),postMessage:e=>t.postMessage(e),performance:global.performance||{now:Date.now}})}var o=!1,d=function(){var e=Array.prototype.slice.call(arguments).join(" ");a?s.writeSync(2,e+"\\n"):console.error(e)};self.alert=function(){var a=Array.prototype.slice.call(arguments).join(" ");postMessage({cmd:"alert",text:a,threadId:e._pthread_self()})},e.instantiateWasm=(a,r)=>{var t=e.wasmModule;return e.wasmModule=null,r(new WebAssembly.Instance(t,a))},self.onunhandledrejection=e=>{throw e.reason??e},self.onmessage=function a(r){try{if("load"===r.data.cmd){let s=[];self.onmessage=e=>s.push(e),self.startWorker=r=>{e=r,postMessage({cmd:"loaded"});for(let e of s)a(e);self.onmessage=a},e.wasmModule=r.data.wasmModule;for(const a of r.data.handlers)e[a]=(...e)=>{postMessage({cmd:"callHandler",handler:a,args:e})};if(e.wasmMemory=r.data.wasmMemory,e.buffer=e.wasmMemory.buffer,e.ENVIRONMENT_IS_PTHREAD=!0,"string"==typeof r.data.urlOrBlob)importScripts(r.data.urlOrBlob);else{var t=URL.createObjectURL(r.data.urlOrBlob);importScripts(t),URL.revokeObjectURL(t)}ortWasmThreaded(e)}else if("run"===r.data.cmd){e.__emscripten_thread_init(r.data.pthread_ptr,0,0,1),e.__emscripten_thread_mailbox_await(r.data.pthread_ptr),e.establishStackSpace(),e.PThread.receiveObjectTransfer(r.data),e.PThread.threadInitTLS(),o||(o=!0);try{e.invokeEntryPoint(r.data.start_routine,r.data.arg)}catch(e){if("unwind"!=e)throw e}}else"cancel"===r.data.cmd?e._pthread_self()&&e.__emscripten_thread_exit(-1):"setimmediate"===r.data.target||("checkMailbox"===r.data.cmd?o&&e.checkMailbox():r.data.cmd&&(d("worker.js received unknown command "+r.data.cmd),d(r.data)))}catch(a){throw e.__emscripten_thread_crashed&&e.__emscripten_thread_crashed(),a}};\n'},7067:()=>{},1296:()=>{},760:()=>{},1384:()=>{},3993:()=>{},908:()=>{},6953:()=>{},9925:()=>{},2806:()=>{},6449:()=>{},2850:()=>{},5381:()=>{},685:(me,E)=>{"use strict";Object.defineProperty(E,"__esModule",{value:!0}),E.resolveBackend=E.registerBackend=void 0;const P={},F=[];E.registerBackend=(A,O,k)=>{if(!O||"function"!=typeof O.init||"function"!=typeof O.createSessionHandler)throw new TypeError("not a valid backend");{const S=P[A];if(void 0===S)P[A]={backend:O,priority:k};else{if(S.priority>k)return;if(S.priority===k&&S.backend!==O)throw new Error(`cannot register backend "${A}" using priority ${k}`)}if(k>=0){const C=F.indexOf(A);-1!==C&&F.splice(C,1);for(let v=0;v<F.length;v++)if(P[F[v]].priority<=k)return void F.splice(v,0,A);F.push(A)}}},E.resolveBackend=function(){var A=_asyncToGenerator(function*(O){const k=0===O.length?F:O,S=[];for(const C of k){const v=P[C];if(v){if(v.initialized)return v.backend;if(v.aborted)continue;const b=!!v.initPromise;try{return b||(v.initPromise=v.backend.init()),yield v.initPromise,v.initialized=!0,v.backend}catch(h){b||S.push({name:C,err:h}),v.aborted=!0}finally{delete v.initPromise}}}throw new Error(`no available backend found. ERR: ${S.map(C=>`[${C.name}] ${C.err}`).join(", ")}`)});return function(O){return A.apply(this,arguments)}}()},4798:(me,E,P)=>{"use strict";Object.defineProperty(E,"__esModule",{value:!0}),E.registerBackend=void 0;var F=P(685);Object.defineProperty(E,"registerBackend",{enumerable:!0,get:function(){return F.registerBackend}})},3121:(me,E,P)=>{"use strict";Object.defineProperty(E,"__esModule",{value:!0}),E.env=void 0;const F=P(9104);let A="warning";E.env={wasm:{},webgl:{},webgpu:{},versions:{common:F.version},set logLevel(O){if(void 0!==O){if("string"!=typeof O||-1===["verbose","info","warning","error","fatal"].indexOf(O))throw new Error(`Unsupported logging level: ${O}`);A=O}},get logLevel(){return A}},Object.defineProperty(E.env,"logLevel",{enumerable:!0})},2457:(me,E,P)=>{"use strict";Object.defineProperty(E,"__esModule",{value:!0}),E.env=void 0;const F=P(3121);E.env=F.env},2235:function(me,E,P){"use strict";var F=this&&this.__createBinding||(Object.create?function(O,k,S,C){void 0===C&&(C=S);var v=Object.getOwnPropertyDescriptor(k,S);v&&!("get"in v?!k.__esModule:v.writable||v.configurable)||(v={enumerable:!0,get:function(){return k[S]}}),Object.defineProperty(O,C,v)}:function(O,k,S,C){void 0===C&&(C=S),O[C]=k[S]}),A=this&&this.__exportStar||function(O,k){for(var S in O)"default"===S||Object.prototype.hasOwnProperty.call(k,S)||F(k,O,S)};Object.defineProperty(E,"__esModule",{value:!0}),A(P(4798),E),A(P(2457),E),A(P(3974),E),A(P(963),E),A(P(7852),E)},8036:(me,E,P)=>{"use strict";Object.defineProperty(E,"__esModule",{value:!0}),E.InferenceSession=void 0;const F=P(685),A=P(963);class O{constructor(S){this.handler=S}run(S,C,v){var b=this;return _asyncToGenerator(function*(){const h={};let l={};if("object"!=typeof S||null===S||S instanceof A.Tensor||Array.isArray(S))throw new TypeError("'feeds' must be an object that use input names as keys and OnnxValue as corresponding values.");let d=!0;if("object"==typeof C){if(null===C)throw new TypeError("Unexpected argument[1]: cannot be null.");if(C instanceof A.Tensor)throw new TypeError("'fetches' cannot be a Tensor");if(Array.isArray(C)){if(0===C.length)throw new TypeError("'fetches' cannot be an empty array.");d=!1;for(const w of C){if("string"!=typeof w)throw new TypeError("'fetches' must be a string array or an object.");if(-1===b.outputNames.indexOf(w))throw new RangeError(`'fetches' contains invalid output name: ${w}.`);h[w]=null}if("object"==typeof v&&null!==v)l=v;else if(void 0!==v)throw new TypeError("'options' must be an object.")}else{let w=!1;const D=Object.getOwnPropertyNames(C);for(const M of b.outputNames)if(-1!==D.indexOf(M)){const $=C[M];(null===$||$ instanceof A.Tensor)&&(w=!0,d=!1,h[M]=$)}if(w){if("object"==typeof v&&null!==v)l=v;else if(void 0!==v)throw new TypeError("'options' must be an object.")}else l=C}}else if(void 0!==C)throw new TypeError("Unexpected argument[1]: must be 'fetches' or 'options'.");for(const w of b.inputNames)if(void 0===S[w])throw new Error(`input '${w}' is missing in 'feeds'.`);if(d)for(const w of b.outputNames)h[w]=null;const f=yield b.handler.run(S,h,l),y={};for(const w in f)Object.hasOwnProperty.call(f,w)&&(y[w]=new A.Tensor(f[w].type,f[w].data,f[w].dims));return y})()}release(){var S=this;return _asyncToGenerator(function*(){return S.handler.dispose()})()}static create(S,C,v,b){return _asyncToGenerator(function*(){let h,l={};if("string"==typeof S){if(h=S,"object"==typeof C&&null!==C)l=C;else if(void 0!==C)throw new TypeError("'options' must be an object.")}else if(S instanceof Uint8Array){if(h=S,"object"==typeof C&&null!==C)l=C;else if(void 0!==C)throw new TypeError("'options' must be an object.")}else{if(!(S instanceof ArrayBuffer||typeof SharedArrayBuffer<"u"&&S instanceof SharedArrayBuffer))throw new TypeError("Unexpected argument[0]: must be 'path' or 'buffer'.");{const w=S;let D=0,M=S.byteLength;if("object"==typeof C&&null!==C)l=C;else if("number"==typeof C){if(D=C,!Number.isSafeInteger(D))throw new RangeError("'byteOffset' must be an integer.");if(D<0||D>=w.byteLength)throw new RangeError(`'byteOffset' is out of range [0, ${w.byteLength}).`);if(M=S.byteLength-D,"number"==typeof v){if(M=v,!Number.isSafeInteger(M))throw new RangeError("'byteLength' must be an integer.");if(M<=0||D+M>w.byteLength)throw new RangeError(`'byteLength' is out of range (0, ${w.byteLength-D}].`);if("object"==typeof b&&null!==b)l=b;else if(void 0!==b)throw new TypeError("'options' must be an object.")}else if(void 0!==v)throw new TypeError("'byteLength' must be a number.")}else if(void 0!==C)throw new TypeError("'options' must be an object.");h=new Uint8Array(w,D,M)}}const d=(l.executionProviders||[]).map(w=>"string"==typeof w?w:w.name),f=yield(0,F.resolveBackend)(d),y=yield f.createSessionHandler(h,l);return new O(y)})()}startProfiling(){this.handler.startProfiling()}endProfiling(){this.handler.endProfiling()}get inputNames(){return this.handler.inputNames}get outputNames(){return this.handler.outputNames}}E.InferenceSession=O},3974:(me,E,P)=>{"use strict";Object.defineProperty(E,"__esModule",{value:!0}),E.InferenceSession=void 0;const F=P(8036);E.InferenceSession=F.InferenceSession},7852:(me,E)=>{"use strict";Object.defineProperty(E,"__esModule",{value:!0})},2350:(me,E)=>{"use strict";Object.defineProperty(E,"__esModule",{value:!0}),E.tensorToImageData=E.tensorToDataURL=void 0,E.tensorToDataURL=(P,F)=>{const A=document.createElement("canvas");A.width=P.dims[3],A.height=P.dims[2];const O=A.getContext("2d");if(null!=O){let k,S;void 0!==F?.tensorLayout&&"NHWC"===F.tensorLayout?(k=P.dims[2],S=P.dims[3]):(k=P.dims[3],S=P.dims[2]);const C=void 0!==F?.format?F.format:"RGB",v=F?.norm;let b,h;void 0===v||void 0===v.mean?b=[255,255,255,255]:"number"==typeof v.mean?b=[v.mean,v.mean,v.mean,v.mean]:(b=[v.mean[0],v.mean[1],v.mean[2],0],void 0!==v.mean[3]&&(b[3]=v.mean[3])),void 0===v||void 0===v.bias?h=[0,0,0,0]:"number"==typeof v.bias?h=[v.bias,v.bias,v.bias,v.bias]:(h=[v.bias[0],v.bias[1],v.bias[2],0],void 0!==v.bias[3]&&(h[3]=v.bias[3]));const l=S*k;let d=0,f=l,y=2*l,w=-1;"RGBA"===C?(d=0,f=l,y=2*l,w=3*l):"RGB"===C?(d=0,f=l,y=2*l):"RBG"===C&&(d=0,y=l,f=2*l);for(let D=0;D<S;D++)for(let M=0;M<k;M++){const $=(P.data[d++]-h[0])*b[0],B=(P.data[f++]-h[1])*b[1],z=(P.data[y++]-h[2])*b[2],G=-1===w?255:(P.data[w++]-h[3])*b[3];O.fillStyle="rgba("+$+","+B+","+z+","+G+")",O.fillRect(M,D,1,1)}return A.toDataURL()}throw new Error("Can not access image data")},E.tensorToImageData=(P,F)=>{const A=document.createElement("canvas").getContext("2d");let O;if(null==A)throw new Error("Can not access image data");{let k,S,C;void 0!==F?.tensorLayout&&"NHWC"===F.tensorLayout?(k=P.dims[2],S=P.dims[1],C=P.dims[3]):(k=P.dims[3],S=P.dims[2],C=P.dims[1]);const v=void 0!==F&&void 0!==F.format?F.format:"RGB",b=F?.norm;let h,l;void 0===b||void 0===b.mean?h=[255,255,255,255]:"number"==typeof b.mean?h=[b.mean,b.mean,b.mean,b.mean]:(h=[b.mean[0],b.mean[1],b.mean[2],255],void 0!==b.mean[3]&&(h[3]=b.mean[3])),void 0===b||void 0===b.bias?l=[0,0,0,0]:"number"==typeof b.bias?l=[b.bias,b.bias,b.bias,b.bias]:(l=[b.bias[0],b.bias[1],b.bias[2],0],void 0!==b.bias[3]&&(l[3]=b.bias[3]));const d=S*k;if(void 0!==F&&(void 0!==F.format&&4===C&&"RGBA"!==F.format||3===C&&"RGB"!==F.format&&"BGR"!==F.format))throw new Error("Tensor format doesn't match input tensor dims");const f=4;let y=0,w=1,D=2,M=3,$=0,B=d,z=2*d,G=-1;"RGBA"===v?($=0,B=d,z=2*d,G=3*d):"RGB"===v?($=0,B=d,z=2*d):"RBG"===v&&($=0,z=d,B=2*d),O=A.createImageData(k,S);for(let H=0;H<S*k;y+=f,w+=f,D+=f,M+=f,H++)O.data[y]=(P.data[$++]-l[0])*h[0],O.data[w]=(P.data[B++]-l[1])*h[1],O.data[D]=(P.data[z++]-l[2])*h[2],O.data[M]=-1===G?255:(P.data[G++]-l[3])*h[3]}return O}},4866:(me,E,P)=>{"use strict";Object.defineProperty(E,"__esModule",{value:!0}),E.tensorFromImage=E.bufferToTensor=void 0;const F=P(963);E.bufferToTensor=(A,O)=>{if(void 0===A)throw new Error("Image buffer must be defined");if(void 0===O.height||void 0===O.width)throw new Error("Image height and width must be defined");if("NHWC"===O.tensorLayout)throw new Error("NHWC Tensor layout is not supported yet");const{height:k,width:S}=O,C=O.norm??{mean:255,bias:0};let v,b;v="number"==typeof C.mean?[C.mean,C.mean,C.mean,C.mean]:[C.mean[0],C.mean[1],C.mean[2],C.mean[3]??255],b="number"==typeof C.bias?[C.bias,C.bias,C.bias,C.bias]:[C.bias[0],C.bias[1],C.bias[2],C.bias[3]??0];const h=void 0!==O.format?O.format:"RGBA",l=void 0!==O.tensorFormat&&void 0!==O.tensorFormat?O.tensorFormat:"RGB",d=k*S,f="RGBA"===l?new Float32Array(4*d):new Float32Array(3*d);let y=4,w=0,D=1,M=2,$=3,B=0,z=d,G=2*d,H=-1;"RGB"===h&&(y=3,w=0,D=1,M=2,$=-1),"RGBA"===l?H=3*d:"RBG"===l?(B=0,G=d,z=2*d):"BGR"===l&&(G=0,z=d,B=2*d);for(let te=0;te<d;te++,w+=y,M+=y,D+=y,$+=y)f[B++]=(A[w]+b[0])/v[0],f[z++]=(A[D]+b[1])/v[1],f[G++]=(A[M]+b[2])/v[2],-1!==H&&-1!==$&&(f[H++]=(A[$]+b[3])/v[3]);return new F.Tensor("float32",f,"RGBA"===l?[1,4,k,S]:[1,3,k,S])},E.tensorFromImage=function(){var A=_asyncToGenerator(function*(O,k){const S=typeof HTMLImageElement<"u"&&O instanceof HTMLImageElement,C=typeof ImageData<"u"&&O instanceof ImageData,v=typeof ImageBitmap<"u"&&O instanceof ImageBitmap,b="string"==typeof O;let h,l=k??{};if(S){const d=document.createElement("canvas");d.width=O.width,d.height=O.height;const f=d.getContext("2d");if(null==f)throw new Error("Can not access image data");{let y=O.height,w=O.width;if(void 0!==k&&void 0!==k.resizedHeight&&void 0!==k.resizedWidth&&(y=k.resizedHeight,w=k.resizedWidth),void 0!==k){if(l=k,void 0!==k.tensorFormat)throw new Error("Image input config format must be RGBA for HTMLImageElement");l.tensorFormat="RGBA",l.height=y,l.width=w}else l.tensorFormat="RGBA",l.height=y,l.width=w;f.drawImage(O,0,0),h=f.getImageData(0,0,w,y).data}}else{if(!C){if(v){if(void 0===k)throw new Error("Please provide image config with format for Imagebitmap");const d=document.createElement("canvas");d.width=O.width,d.height=O.height;const f=d.getContext("2d");if(null!=f){const y=O.height,w=O.width;return f.drawImage(O,0,0,w,y),h=f.getImageData(0,0,w,y).data,l.height=y,l.width=w,(0,E.bufferToTensor)(h,l)}throw new Error("Can not access image data")}if(b)return new Promise((d,f)=>{const y=document.createElement("canvas"),w=y.getContext("2d");if(!O||!w)return f();const D=new Image;D.crossOrigin="Anonymous",D.src=O,D.onload=()=>{y.width=D.width,y.height=D.height,w.drawImage(D,0,0,y.width,y.height);const M=w.getImageData(0,0,y.width,y.height);l.height=y.height,l.width=y.width,d((0,E.bufferToTensor)(M.data,l))}});throw new Error("Input data provided is not supported - aborted tensor creation")}{let d,f;if(void 0!==k&&void 0!==k.resizedWidth&&void 0!==k.resizedHeight?(d=k.resizedHeight,f=k.resizedWidth):(d=O.height,f=O.width),void 0!==k&&(l=k),l.format="RGBA",l.height=d,l.width=f,void 0!==k){const y=document.createElement("canvas");y.width=f,y.height=d;const w=y.getContext("2d");if(null==w)throw new Error("Can not access image data");w.putImageData(O,0,0),h=w.getImageData(0,0,f,d).data}else h=O.data}}if(void 0!==h)return(0,E.bufferToTensor)(h,l);throw new Error("Input data provided is not supported - aborted tensor creation")});return function(O,k){return A.apply(this,arguments)}}()},5957:(me,E,P)=>{"use strict";Object.defineProperty(E,"__esModule",{value:!0}),E.Tensor=void 0;const F=P(2350),A=P(4866),O=P(106),k=new Map([["float32",Float32Array],["uint8",Uint8Array],["int8",Int8Array],["uint16",Uint16Array],["float16",Uint16Array],["int16",Int16Array],["int32",Int32Array],["bool",Uint8Array],["float64",Float64Array],["uint32",Uint32Array]]),S=new Map([[Float32Array,"float32"],[Uint8Array,"uint8"],[Int8Array,"int8"],[Uint16Array,"uint16"],[Int16Array,"int16"],[Int32Array,"int32"],[Float64Array,"float64"],[Uint32Array,"uint32"]]);let C=!1;E.Tensor=class{constructor(v,b,h){let l,d,f;if((()=>{if(!C){C=!0;const w=typeof BigInt64Array<"u"&&"function"==typeof BigInt64Array.from,D=typeof BigUint64Array<"u"&&"function"==typeof BigUint64Array.from;w&&(k.set("int64",BigInt64Array),S.set(BigInt64Array,"int64")),D&&(k.set("uint64",BigUint64Array),S.set(BigUint64Array,"uint64"))}})(),"string"==typeof v)if(l=v,f=h,"string"===v){if(!Array.isArray(b))throw new TypeError("A string tensor's data must be a string array.");d=b}else{const w=k.get(v);if(void 0===w)throw new TypeError(`Unsupported tensor type: ${v}.`);if(Array.isArray(b)){if("float16"===v)throw new TypeError("Creating a float16 tensor from number array is not supported. Please use Uint16Array as data.");d="uint64"===v||"int64"===v?w.from(b,BigInt):w.from(b)}else{if(!(b instanceof w))throw new TypeError(`A ${l} tensor's data must be type of ${w}`);d=b}}else if(f=b,Array.isArray(v)){if(0===v.length)throw new TypeError("Tensor type cannot be inferred from an empty array.");const w=typeof v[0];if("string"===w)l="string",d=v;else{if("boolean"!==w)throw new TypeError(`Invalid element type of data array: ${w}.`);l="bool",d=Uint8Array.from(v)}}else{const w=S.get(v.constructor);if(void 0===w)throw new TypeError(`Unsupported type for tensor data: ${v.constructor}.`);l=w,d=v}if(void 0===f)f=[d.length];else if(!Array.isArray(f))throw new TypeError("A tensor's dims must be a number array");const y=(0,O.calculateSize)(f);if(y!==d.length)throw new Error(`Tensor's size(${y}) does not match data length(${d.length}).`);this.dims=f,this.type=l,this.data=d,this.size=y}static fromImage(v,b){return _asyncToGenerator(function*(){return(0,A.tensorFromImage)(v,b)})()}toDataURL(v){return(0,F.tensorToDataURL)(this,v)}toImageData(v){return(0,F.tensorToImageData)(this,v)}reshape(v){return(0,O.tensorReshape)(this,v)}}},106:(me,E,P)=>{"use strict";Object.defineProperty(E,"__esModule",{value:!0}),E.tensorReshape=E.calculateSize=void 0;const F=P(963);E.calculateSize=A=>{let O=1;for(let k=0;k<A.length;k++){const S=A[k];if("number"!=typeof S||!Number.isSafeInteger(S))throw new TypeError(`dims[${k}] must be an integer, got: ${S}`);if(S<0)throw new RangeError(`dims[${k}] must be a non-negative integer, got: ${S}`);O*=S}return O},E.tensorReshape=(A,O)=>new F.Tensor(A.type,A.data,O)},963:(me,E,P)=>{"use strict";Object.defineProperty(E,"__esModule",{value:!0}),E.Tensor=void 0;const F=P(5957);E.Tensor=F.Tensor},9104:(me,E)=>{"use strict";Object.defineProperty(E,"__esModule",{value:!0}),E.version=void 0,E.version="1.16.3"},1583:(me,E)=>{var P,F=function(A){"use strict";Object.defineProperty(A,"__esModule",{value:!0}),A.default=void 0;var O=null;try{O=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch{}function k(q,re,le){this.low=0|q,this.high=0|re,this.unsigned=!!le}function S(q){return!0===(q&&q.__isLong__)}function C(q){var re=Math.clz32(q&-q);return q?31-re:re}Object.defineProperty(k.prototype,"__isLong__",{value:!0}),k.isLong=S;var v={},b={};function h(q,re){var le,He,Le;return re?(Le=0<=(q>>>=0)&&q<256)&&(He=b[q])?He:(le=d(q,0,!0),Le&&(b[q]=le),le):(Le=-128<=(q|=0)&&q<128)&&(He=v[q])?He:(le=d(q,q<0?-1:0,!1),Le&&(v[q]=le),le)}function l(q,re){if(isNaN(q))return re?G:z;if(re){if(q<0)return G;if(q>=M)return ne}else{if(q<=-$)return X;if(q+1>=$)return J}return q<0?l(-q,re).neg():d(q%D|0,q/D|0,re)}function d(q,re,le){return new k(q,re,le)}k.fromInt=h,k.fromNumber=l,k.fromBits=d;var f=Math.pow;function y(q,re,le){if(0===q.length)throw Error("empty string");if("number"==typeof re?(le=re,re=!1):re=!!re,"NaN"===q||"Infinity"===q||"+Infinity"===q||"-Infinity"===q)return re?G:z;if((le=le||10)<2||36<le)throw RangeError("radix");var He;if((He=q.indexOf("-"))>0)throw Error("interior hyphen");if(0===He)return y(q.substring(1),re,le).neg();for(var Le=l(f(le,8)),ot=z,nt=0;nt<q.length;nt+=8){var it=Math.min(8,q.length-nt),yt=parseInt(q.substring(nt,nt+it),le);if(it<8){var wt=l(f(le,it));ot=ot.mul(wt).add(l(yt))}else ot=(ot=ot.mul(Le)).add(l(yt))}return ot.unsigned=re,ot}function w(q,re){return"number"==typeof q?l(q,re):"string"==typeof q?y(q,re):d(q.low,q.high,"boolean"==typeof re?re:q.unsigned)}k.fromString=y,k.fromValue=w;var D=4294967296,M=D*D,$=M/2,B=h(1<<24),z=h(0);k.ZERO=z;var G=h(0,!0);k.UZERO=G;var H=h(1);k.ONE=H;var te=h(1,!0);k.UONE=te;var ae=h(-1);k.NEG_ONE=ae;var J=d(-1,2147483647,!1);k.MAX_VALUE=J;var ne=d(-1,-1,!0);k.MAX_UNSIGNED_VALUE=ne;var X=d(0,-2147483648,!1);k.MIN_VALUE=X;var K=k.prototype;return K.toInt=function(){return this.unsigned?this.low>>>0:this.low},K.toNumber=function(){return this.unsigned?(this.high>>>0)*D+(this.low>>>0):this.high*D+(this.low>>>0)},K.toString=function(q){if((q=q||10)<2||36<q)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative()){if(this.eq(X)){var re=l(q),le=this.div(re),He=le.mul(re).sub(this);return le.toString(q)+He.toInt().toString(q)}return"-"+this.neg().toString(q)}for(var Le=l(f(q,6),this.unsigned),ot=this,nt="";;){var it=ot.div(Le),yt=(ot.sub(it.mul(Le)).toInt()>>>0).toString(q);if((ot=it).isZero())return yt+nt;for(;yt.length<6;)yt="0"+yt;nt=""+yt+nt}},K.getHighBits=function(){return this.high},K.getHighBitsUnsigned=function(){return this.high>>>0},K.getLowBits=function(){return this.low},K.getLowBitsUnsigned=function(){return this.low>>>0},K.getNumBitsAbs=function(){if(this.isNegative())return this.eq(X)?64:this.neg().getNumBitsAbs();for(var q=0!=this.high?this.high:this.low,re=31;re>0&&!(q&1<<re);re--);return 0!=this.high?re+33:re+1},K.isZero=function(){return 0===this.high&&0===this.low},K.eqz=K.isZero,K.isNegative=function(){return!this.unsigned&&this.high<0},K.isPositive=function(){return this.unsigned||this.high>=0},K.isOdd=function(){return 1==(1&this.low)},K.isEven=function(){return 0==(1&this.low)},K.equals=function(q){return S(q)||(q=w(q)),(this.unsigned===q.unsigned||this.high>>>31!=1||q.high>>>31!=1)&&this.high===q.high&&this.low===q.low},K.eq=K.equals,K.notEquals=function(q){return!this.eq(q)},K.neq=K.notEquals,K.ne=K.notEquals,K.lessThan=function(q){return this.comp(q)<0},K.lt=K.lessThan,K.lessThanOrEqual=function(q){return this.comp(q)<=0},K.lte=K.lessThanOrEqual,K.le=K.lessThanOrEqual,K.greaterThan=function(q){return this.comp(q)>0},K.gt=K.greaterThan,K.greaterThanOrEqual=function(q){return this.comp(q)>=0},K.gte=K.greaterThanOrEqual,K.ge=K.greaterThanOrEqual,K.compare=function(q){if(S(q)||(q=w(q)),this.eq(q))return 0;var re=this.isNegative(),le=q.isNegative();return re&&!le?-1:!re&&le?1:this.unsigned?q.high>>>0>this.high>>>0||q.high===this.high&&q.low>>>0>this.low>>>0?-1:1:this.sub(q).isNegative()?-1:1},K.comp=K.compare,K.negate=function(){return!this.unsigned&&this.eq(X)?X:this.not().add(H)},K.neg=K.negate,K.add=function(q){S(q)||(q=w(q));var yt=0,wt=0,Pt=0,pn=0;return Pt+=(pn+=(65535&this.low)+(65535&q.low))>>>16,wt+=(Pt+=(this.low>>>16)+(q.low>>>16))>>>16,yt+=(wt+=(65535&this.high)+(65535&q.high))>>>16,yt+=(this.high>>>16)+(q.high>>>16),d((Pt&=65535)<<16|(pn&=65535),(yt&=65535)<<16|(wt&=65535),this.unsigned)},K.subtract=function(q){return S(q)||(q=w(q)),this.add(q.neg())},K.sub=K.subtract,K.multiply=function(q){if(this.isZero())return this;if(S(q)||(q=w(q)),O)return d(O.mul(this.low,this.high,q.low,q.high),O.get_high(),this.unsigned);if(q.isZero())return this.unsigned?G:z;if(this.eq(X))return q.isOdd()?X:z;if(q.eq(X))return this.isOdd()?X:z;if(this.isNegative())return q.isNegative()?this.neg().mul(q.neg()):this.neg().mul(q).neg();if(q.isNegative())return this.mul(q.neg()).neg();if(this.lt(B)&&q.lt(B))return l(this.toNumber()*q.toNumber(),this.unsigned);var le=65535&this.high,He=this.low>>>16,Le=65535&this.low,nt=65535&q.high,it=q.low>>>16,yt=65535&q.low,wt=0,Pt=0,pn=0,Cn=0;return pn+=(Cn+=Le*yt)>>>16,Pt+=(pn+=He*yt)>>>16,pn&=65535,Pt+=(pn+=Le*it)>>>16,wt+=(Pt+=le*yt)>>>16,Pt&=65535,wt+=(Pt+=He*it)>>>16,Pt&=65535,wt+=(Pt+=Le*nt)>>>16,wt+=(this.high>>>16)*yt+le*it+He*nt+Le*(q.high>>>16),d((pn&=65535)<<16|(Cn&=65535),(wt&=65535)<<16|(Pt&=65535),this.unsigned)},K.mul=K.multiply,K.divide=function(q){if(S(q)||(q=w(q)),q.isZero())throw Error("division by zero");var re,le,He;if(O)return this.unsigned||-2147483648!==this.high||-1!==q.low||-1!==q.high?d((this.unsigned?O.div_u:O.div_s)(this.low,this.high,q.low,q.high),O.get_high(),this.unsigned):this;if(this.isZero())return this.unsigned?G:z;if(this.unsigned){if(q.unsigned||(q=q.toUnsigned()),q.gt(this))return G;if(q.gt(this.shru(1)))return te;He=G}else{if(this.eq(X))return q.eq(H)||q.eq(ae)?X:q.eq(X)?H:(re=this.shr(1).div(q).shl(1)).eq(z)?q.isNegative()?H:ae:(le=this.sub(q.mul(re)),He=re.add(le.div(q)));if(q.eq(X))return this.unsigned?G:z;if(this.isNegative())return q.isNegative()?this.neg().div(q.neg()):this.neg().div(q).neg();if(q.isNegative())return this.div(q.neg()).neg();He=z}for(le=this;le.gte(q);){re=Math.max(1,Math.floor(le.toNumber()/q.toNumber()));for(var Le=Math.ceil(Math.log(re)/Math.LN2),ot=Le<=48?1:f(2,Le-48),nt=l(re),it=nt.mul(q);it.isNegative()||it.gt(le);)it=(nt=l(re-=ot,this.unsigned)).mul(q);nt.isZero()&&(nt=H),He=He.add(nt),le=le.sub(it)}return He},K.div=K.divide,K.modulo=function(q){return S(q)||(q=w(q)),O?d((this.unsigned?O.rem_u:O.rem_s)(this.low,this.high,q.low,q.high),O.get_high(),this.unsigned):this.sub(this.div(q).mul(q))},K.mod=K.modulo,K.rem=K.modulo,K.not=function(){return d(~this.low,~this.high,this.unsigned)},K.countLeadingZeros=function(){return this.high?Math.clz32(this.high):Math.clz32(this.low)+32},K.clz=K.countLeadingZeros,K.countTrailingZeros=function(){return this.low?C(this.low):C(this.high)+32},K.ctz=K.countTrailingZeros,K.and=function(q){return S(q)||(q=w(q)),d(this.low&q.low,this.high&q.high,this.unsigned)},K.or=function(q){return S(q)||(q=w(q)),d(this.low|q.low,this.high|q.high,this.unsigned)},K.xor=function(q){return S(q)||(q=w(q)),d(this.low^q.low,this.high^q.high,this.unsigned)},K.shiftLeft=function(q){return S(q)&&(q=q.toInt()),0==(q&=63)?this:q<32?d(this.low<<q,this.high<<q|this.low>>>32-q,this.unsigned):d(0,this.low<<q-32,this.unsigned)},K.shl=K.shiftLeft,K.shiftRight=function(q){return S(q)&&(q=q.toInt()),0==(q&=63)?this:q<32?d(this.low>>>q|this.high<<32-q,this.high>>q,this.unsigned):d(this.high>>q-32,this.high>=0?0:-1,this.unsigned)},K.shr=K.shiftRight,K.shiftRightUnsigned=function(q){return S(q)&&(q=q.toInt()),0==(q&=63)?this:q<32?d(this.low>>>q|this.high<<32-q,this.high>>>q,this.unsigned):d(32===q?this.high:this.high>>>q-32,0,this.unsigned)},K.shru=K.shiftRightUnsigned,K.shr_u=K.shiftRightUnsigned,K.rotateLeft=function(q){var re;return S(q)&&(q=q.toInt()),0==(q&=63)?this:32===q?d(this.high,this.low,this.unsigned):q<32?d(this.low<<q|this.high>>>(re=32-q),this.high<<q|this.low>>>re,this.unsigned):(re=32-(q-=32),d(this.high<<q|this.low>>>re,this.low<<q|this.high>>>re,this.unsigned))},K.rotl=K.rotateLeft,K.rotateRight=function(q){var re;return S(q)&&(q=q.toInt()),0==(q&=63)?this:32===q?d(this.high,this.low,this.unsigned):q<32?d(this.high<<(re=32-q)|this.low>>>q,this.low<<re|this.high>>>q,this.unsigned):(re=32-(q-=32),d(this.low<<re|this.high>>>q,this.high<<re|this.low>>>q,this.unsigned))},K.rotr=K.rotateRight,K.toSigned=function(){return this.unsigned?d(this.low,this.high,!1):this},K.toUnsigned=function(){return this.unsigned?this:d(this.low,this.high,!0)},K.toBytes=function(q){return q?this.toBytesLE():this.toBytesBE()},K.toBytesLE=function(){var q=this.high,re=this.low;return[255&re,re>>>8&255,re>>>16&255,re>>>24,255&q,q>>>8&255,q>>>16&255,q>>>24]},K.toBytesBE=function(){var q=this.high,re=this.low;return[q>>>24,q>>>16&255,q>>>8&255,255&q,re>>>24,re>>>16&255,re>>>8&255,255&re]},k.fromBytes=function(q,re,le){return le?k.fromBytesLE(q,re):k.fromBytesBE(q,re)},k.fromBytesLE=function(q,re){return new k(q[0]|q[1]<<8|q[2]<<16|q[3]<<24,q[4]|q[5]<<8|q[6]<<16|q[7]<<24,re)},k.fromBytesBE=function(q,re){return new k(q[4]<<24|q[5]<<16|q[6]<<8|q[7],q[0]<<24|q[1]<<16|q[2]<<8|q[3],re)},A.default=k,"default"in A?A.default:A}({});void 0===(P=function(){return F}.apply(E,[]))||(me.exports=P)},5686:(me,E,P)=>{"use strict";P.r(E),P.d(E,{flatbuffers:()=>F});var F={SIZEOF_SHORT:2,SIZEOF_INT:4,FILE_IDENTIFIER_LENGTH:4,SIZE_PREFIX_LENGTH:4,Encoding:{UTF8_BYTES:1,UTF16_STRING:2}};F.int32=new Int32Array(2),F.float32=new Float32Array(F.int32.buffer),F.float64=new Float64Array(F.int32.buffer),F.isLittleEndian=1===new Uint16Array(new Uint8Array([1,0]).buffer)[0],F.Long=function(A,O){this.low=0|A,this.high=0|O},F.Long.create=function(A,O){return 0==A&&0==O?F.Long.ZERO:new F.Long(A,O)},F.Long.prototype.toFloat64=function(){return(this.low>>>0)+4294967296*this.high},F.Long.prototype.equals=function(A){return this.low==A.low&&this.high==A.high},F.Long.ZERO=new F.Long(0,0),F.Builder=function(A){if(A)O=A;else var O=1024;this.bb=F.ByteBuffer.allocate(O),this.space=O,this.minalign=1,this.vtable=null,this.vtable_in_use=0,this.isNested=!1,this.object_start=0,this.vtables=[],this.vector_num_elems=0,this.force_defaults=!1},F.Builder.prototype.clear=function(){this.bb.clear(),this.space=this.bb.capacity(),this.minalign=1,this.vtable=null,this.vtable_in_use=0,this.isNested=!1,this.object_start=0,this.vtables=[],this.vector_num_elems=0,this.force_defaults=!1},F.Builder.prototype.forceDefaults=function(A){this.force_defaults=A},F.Builder.prototype.dataBuffer=function(){return this.bb},F.Builder.prototype.asUint8Array=function(){return this.bb.bytes().subarray(this.bb.position(),this.bb.position()+this.offset())},F.Builder.prototype.prep=function(A,O){A>this.minalign&&(this.minalign=A);for(var k=1+~(this.bb.capacity()-this.space+O)&A-1;this.space<k+A+O;){var S=this.bb.capacity();this.bb=F.Builder.growByteBuffer(this.bb),this.space+=this.bb.capacity()-S}this.pad(k)},F.Builder.prototype.pad=function(A){for(var O=0;O<A;O++)this.bb.writeInt8(--this.space,0)},F.Builder.prototype.writeInt8=function(A){this.bb.writeInt8(this.space-=1,A)},F.Builder.prototype.writeInt16=function(A){this.bb.writeInt16(this.space-=2,A)},F.Builder.prototype.writeInt32=function(A){this.bb.writeInt32(this.space-=4,A)},F.Builder.prototype.writeInt64=function(A){this.bb.writeInt64(this.space-=8,A)},F.Builder.prototype.writeFloat32=function(A){this.bb.writeFloat32(this.space-=4,A)},F.Builder.prototype.writeFloat64=function(A){this.bb.writeFloat64(this.space-=8,A)},F.Builder.prototype.addInt8=function(A){this.prep(1,0),this.writeInt8(A)},F.Builder.prototype.addInt16=function(A){this.prep(2,0),this.writeInt16(A)},F.Builder.prototype.addInt32=function(A){this.prep(4,0),this.writeInt32(A)},F.Builder.prototype.addInt64=function(A){this.prep(8,0),this.writeInt64(A)},F.Builder.prototype.addFloat32=function(A){this.prep(4,0),this.writeFloat32(A)},F.Builder.prototype.addFloat64=function(A){this.prep(8,0),this.writeFloat64(A)},F.Builder.prototype.addFieldInt8=function(A,O,k){(this.force_defaults||O!=k)&&(this.addInt8(O),this.slot(A))},F.Builder.prototype.addFieldInt16=function(A,O,k){(this.force_defaults||O!=k)&&(this.addInt16(O),this.slot(A))},F.Builder.prototype.addFieldInt32=function(A,O,k){(this.force_defaults||O!=k)&&(this.addInt32(O),this.slot(A))},F.Builder.prototype.addFieldInt64=function(A,O,k){!this.force_defaults&&O.equals(k)||(this.addInt64(O),this.slot(A))},F.Builder.prototype.addFieldFloat32=function(A,O,k){(this.force_defaults||O!=k)&&(this.addFloat32(O),this.slot(A))},F.Builder.prototype.addFieldFloat64=function(A,O,k){(this.force_defaults||O!=k)&&(this.addFloat64(O),this.slot(A))},F.Builder.prototype.addFieldOffset=function(A,O,k){(this.force_defaults||O!=k)&&(this.addOffset(O),this.slot(A))},F.Builder.prototype.addFieldStruct=function(A,O,k){O!=k&&(this.nested(O),this.slot(A))},F.Builder.prototype.nested=function(A){if(A!=this.offset())throw new Error("FlatBuffers: struct must be serialized inline.")},F.Builder.prototype.notNested=function(){if(this.isNested)throw new Error("FlatBuffers: object serialization must not be nested.")},F.Builder.prototype.slot=function(A){this.vtable[A]=this.offset()},F.Builder.prototype.offset=function(){return this.bb.capacity()-this.space},F.Builder.growByteBuffer=function(A){var O=A.capacity();if(3221225472&O)throw new Error("FlatBuffers: cannot grow buffer beyond 2 gigabytes.");var k=O<<1,S=F.ByteBuffer.allocate(k);return S.setPosition(k-O),S.bytes().set(A.bytes(),k-O),S},F.Builder.prototype.addOffset=function(A){this.prep(F.SIZEOF_INT,0),this.writeInt32(this.offset()-A+F.SIZEOF_INT)},F.Builder.prototype.startObject=function(A){this.notNested(),null==this.vtable&&(this.vtable=[]),this.vtable_in_use=A;for(var O=0;O<A;O++)this.vtable[O]=0;this.isNested=!0,this.object_start=this.offset()},F.Builder.prototype.endObject=function(){if(null==this.vtable||!this.isNested)throw new Error("FlatBuffers: endObject called without startObject");this.addInt32(0);for(var A=this.offset(),O=this.vtable_in_use-1;O>=0&&0==this.vtable[O];O--);for(var k=O+1;O>=0;O--)this.addInt16(0!=this.vtable[O]?A-this.vtable[O]:0);this.addInt16(A-this.object_start);var S=(k+2)*F.SIZEOF_SHORT;this.addInt16(S);var C=0,v=this.space;e:for(O=0;O<this.vtables.length;O++){var b=this.bb.capacity()-this.vtables[O];if(S==this.bb.readInt16(b)){for(var h=F.SIZEOF_SHORT;h<S;h+=F.SIZEOF_SHORT)if(this.bb.readInt16(v+h)!=this.bb.readInt16(b+h))continue e;C=this.vtables[O];break}}return C?(this.space=this.bb.capacity()-A,this.bb.writeInt32(this.space,C-A)):(this.vtables.push(this.offset()),this.bb.writeInt32(this.bb.capacity()-A,this.offset()-A)),this.isNested=!1,A},F.Builder.prototype.finish=function(A,O,k){var S=k?F.SIZE_PREFIX_LENGTH:0;if(O){var C=O;if(this.prep(this.minalign,F.SIZEOF_INT+F.FILE_IDENTIFIER_LENGTH+S),C.length!=F.FILE_IDENTIFIER_LENGTH)throw new Error("FlatBuffers: file identifier must be length "+F.FILE_IDENTIFIER_LENGTH);for(var v=F.FILE_IDENTIFIER_LENGTH-1;v>=0;v--)this.writeInt8(C.charCodeAt(v))}this.prep(this.minalign,F.SIZEOF_INT+S),this.addOffset(A),S&&this.addInt32(this.bb.capacity()-this.space),this.bb.setPosition(this.space)},F.Builder.prototype.finishSizePrefixed=function(A,O){this.finish(A,O,!0)},F.Builder.prototype.requiredField=function(A,O){var k=this.bb.capacity()-A,S=k-this.bb.readInt32(k);if(0==this.bb.readInt16(S+O))throw new Error("FlatBuffers: field "+O+" must be set")},F.Builder.prototype.startVector=function(A,O,k){this.notNested(),this.vector_num_elems=O,this.prep(F.SIZEOF_INT,A*O),this.prep(k,A*O)},F.Builder.prototype.endVector=function(){return this.writeInt32(this.vector_num_elems),this.offset()},F.Builder.prototype.createString=function(A){if(A instanceof Uint8Array)var O=A;else{O=[];for(var k=0;k<A.length;){var S,C=A.charCodeAt(k++);(S=C<55296||C>=56320?C:(C<<10)+A.charCodeAt(k++)+-56613888)<128?O.push(S):(S<2048?O.push(S>>6&31|192):(S<65536?O.push(S>>12&15|224):O.push(S>>18&7|240,S>>12&63|128),O.push(S>>6&63|128)),O.push(63&S|128))}}this.addInt8(0),this.startVector(1,O.length,1),this.bb.setPosition(this.space-=O.length),k=0;for(var v=this.space,b=this.bb.bytes();k<O.length;k++)b[v++]=O[k];return this.endVector()},F.Builder.prototype.createLong=function(A,O){return F.Long.create(A,O)},F.ByteBuffer=function(A){this.bytes_=A,this.position_=0},F.ByteBuffer.allocate=function(A){return new F.ByteBuffer(new Uint8Array(A))},F.ByteBuffer.prototype.clear=function(){this.position_=0},F.ByteBuffer.prototype.bytes=function(){return this.bytes_},F.ByteBuffer.prototype.position=function(){return this.position_},F.ByteBuffer.prototype.setPosition=function(A){this.position_=A},F.ByteBuffer.prototype.capacity=function(){return this.bytes_.length},F.ByteBuffer.prototype.readInt8=function(A){return this.readUint8(A)<<24>>24},F.ByteBuffer.prototype.readUint8=function(A){return this.bytes_[A]},F.ByteBuffer.prototype.readInt16=function(A){return this.readUint16(A)<<16>>16},F.ByteBuffer.prototype.readUint16=function(A){return this.bytes_[A]|this.bytes_[A+1]<<8},F.ByteBuffer.prototype.readInt32=function(A){return this.bytes_[A]|this.bytes_[A+1]<<8|this.bytes_[A+2]<<16|this.bytes_[A+3]<<24},F.ByteBuffer.prototype.readUint32=function(A){return this.readInt32(A)>>>0},F.ByteBuffer.prototype.readInt64=function(A){return new F.Long(this.readInt32(A),this.readInt32(A+4))},F.ByteBuffer.prototype.readUint64=function(A){return new F.Long(this.readUint32(A),this.readUint32(A+4))},F.ByteBuffer.prototype.readFloat32=function(A){return F.int32[0]=this.readInt32(A),F.float32[0]},F.ByteBuffer.prototype.readFloat64=function(A){return F.int32[F.isLittleEndian?0:1]=this.readInt32(A),F.int32[F.isLittleEndian?1:0]=this.readInt32(A+4),F.float64[0]},F.ByteBuffer.prototype.writeInt8=function(A,O){this.bytes_[A]=O},F.ByteBuffer.prototype.writeUint8=function(A,O){this.bytes_[A]=O},F.ByteBuffer.prototype.writeInt16=function(A,O){this.bytes_[A]=O,this.bytes_[A+1]=O>>8},F.ByteBuffer.prototype.writeUint16=function(A,O){this.bytes_[A]=O,this.bytes_[A+1]=O>>8},F.ByteBuffer.prototype.writeInt32=function(A,O){this.bytes_[A]=O,this.bytes_[A+1]=O>>8,this.bytes_[A+2]=O>>16,this.bytes_[A+3]=O>>24},F.ByteBuffer.prototype.writeUint32=function(A,O){this.bytes_[A]=O,this.bytes_[A+1]=O>>8,this.bytes_[A+2]=O>>16,this.bytes_[A+3]=O>>24},F.ByteBuffer.prototype.writeInt64=function(A,O){this.writeInt32(A,O.low),this.writeInt32(A+4,O.high)},F.ByteBuffer.prototype.writeUint64=function(A,O){this.writeUint32(A,O.low),this.writeUint32(A+4,O.high)},F.ByteBuffer.prototype.writeFloat32=function(A,O){F.float32[0]=O,this.writeInt32(A,F.int32[0])},F.ByteBuffer.prototype.writeFloat64=function(A,O){F.float64[0]=O,this.writeInt32(A,F.int32[F.isLittleEndian?0:1]),this.writeInt32(A+4,F.int32[F.isLittleEndian?1:0])},F.ByteBuffer.prototype.getBufferIdentifier=function(){if(this.bytes_.length<this.position_+F.SIZEOF_INT+F.FILE_IDENTIFIER_LENGTH)throw new Error("FlatBuffers: ByteBuffer is too short to contain an identifier.");for(var A="",O=0;O<F.FILE_IDENTIFIER_LENGTH;O++)A+=String.fromCharCode(this.readInt8(this.position_+F.SIZEOF_INT+O));return A},F.ByteBuffer.prototype.__offset=function(A,O){var k=A-this.readInt32(A);return O<this.readInt16(k)?this.readInt16(k+O):0},F.ByteBuffer.prototype.__union=function(A,O){return A.bb_pos=O+this.readInt32(O),A.bb=this,A},F.ByteBuffer.prototype.__string=function(A,O){A+=this.readInt32(A);var k=this.readInt32(A),S="",C=0;if(A+=F.SIZEOF_INT,O===F.Encoding.UTF8_BYTES)return this.bytes_.subarray(A,A+k);for(;C<k;){var v,b=this.readUint8(A+C++);if(b<192)v=b;else{var h=this.readUint8(A+C++);if(b<224)v=(31&b)<<6|63&h;else{var l=this.readUint8(A+C++);v=b<240?(15&b)<<12|(63&h)<<6|63&l:(7&b)<<18|(63&h)<<12|(63&l)<<6|63&this.readUint8(A+C++)}}v<65536?S+=String.fromCharCode(v):(v-=65536,S+=String.fromCharCode(55296+(v>>10),56320+(1023&v)))}return S},F.ByteBuffer.prototype.__indirect=function(A){return A+this.readInt32(A)},F.ByteBuffer.prototype.__vector=function(A){return A+this.readInt32(A)+F.SIZEOF_INT},F.ByteBuffer.prototype.__vector_len=function(A){return this.readInt32(A+this.readInt32(A))},F.ByteBuffer.prototype.__has_identifier=function(A){if(A.length!=F.FILE_IDENTIFIER_LENGTH)throw new Error("FlatBuffers: file identifier must be length "+F.FILE_IDENTIFIER_LENGTH);for(var O=0;O<F.FILE_IDENTIFIER_LENGTH;O++)if(A.charCodeAt(O)!=this.readInt8(this.position_+F.SIZEOF_INT+O))return!1;return!0},F.ByteBuffer.prototype.createLong=function(A,O){return F.Long.create(A,O)}}},__webpack_module_cache__={};function __nested_webpack_require_836307__(me){var E=__webpack_module_cache__[me];if(void 0!==E)return E.exports;var P=__webpack_module_cache__[me]={exports:{}};return __webpack_modules__[me].call(P.exports,P,P.exports,__nested_webpack_require_836307__),P.exports}__nested_webpack_require_836307__.n=me=>{var E=me&&me.__esModule?()=>me.default:()=>me;return __nested_webpack_require_836307__.d(E,{a:E}),E},__nested_webpack_require_836307__.d=(me,E)=>{for(var P in E)__nested_webpack_require_836307__.o(E,P)&&!__nested_webpack_require_836307__.o(me,P)&&Object.defineProperty(me,P,{enumerable:!0,get:E[P]})},__nested_webpack_require_836307__.o=(me,E)=>Object.prototype.hasOwnProperty.call(me,E),__nested_webpack_require_836307__.r=me=>{typeof Symbol<"u"&&Symbol.toStringTag&&Object.defineProperty(me,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(me,"__esModule",{value:!0})};var __nested_webpack_exports__=__nested_webpack_require_836307__(1057);return __nested_webpack_exports__})(),module.exports=E()},340:(me,E,P)=>{var F=P(471),A=P(992),O=P(657),k=P(583),S=P(929),C=P(83),v=P(818);v.alea=F,v.xor128=A,v.xorwow=O,v.xorshift7=k,v.xor4096=S,v.tychei=C,me.exports=v},471:function(me,E,P){var F;!function(A,O,k){function S(h){var l=this,d=function b(){var h=4022871197;return function(d){d=String(d);for(var f=0;f<d.length;f++){var y=.02519603282416938*(h+=d.charCodeAt(f));y-=h=y>>>0,h=(y*=h)>>>0,h+=4294967296*(y-=h)}return 2.3283064365386963e-10*(h>>>0)}}();l.next=function(){var f=2091639*l.s0+2.3283064365386963e-10*l.c;return l.s0=l.s1,l.s1=l.s2,l.s2=f-(l.c=0|f)},l.c=1,l.s0=d(" "),l.s1=d(" "),l.s2=d(" "),l.s0-=d(h),l.s0<0&&(l.s0+=1),l.s1-=d(h),l.s1<0&&(l.s1+=1),l.s2-=d(h),l.s2<0&&(l.s2+=1),d=null}function C(h,l){return l.c=h.c,l.s0=h.s0,l.s1=h.s1,l.s2=h.s2,l}function v(h,l){var d=new S(h),f=l&&l.state,y=d.next;return y.int32=function(){return 4294967296*d.next()|0},y.double=function(){return y()+11102230246251565e-32*(2097152*y()|0)},y.quick=y,f&&("object"==typeof f&&C(f,d),y.state=function(){return C(d,{})}),y}O&&O.exports?O.exports=v:P.amdD&&P.amdO?void 0!==(F=function(){return v}.call(E,P,E,O))&&(O.exports=F):this.alea=v}(0,me=P.nmd(me))},83:function(me,E,P){var F;!function(A,O,k){function S(b){var h=this,l="";h.next=function(){var f=h.b,y=h.c,w=h.d,D=h.a;return f=f<<25^f>>>7^y,y=y-w|0,w=w<<24^w>>>8^D,D=D-f|0,h.b=f=f<<20^f>>>12^y,h.c=y=y-w|0,h.d=w<<16^y>>>16^D,h.a=D-f|0},h.a=0,h.b=0,h.c=-1640531527,h.d=1367130551,b===Math.floor(b)?(h.a=b/4294967296|0,h.b=0|b):l+=b;for(var d=0;d<l.length+20;d++)h.b^=0|l.charCodeAt(d),h.next()}function C(b,h){return h.a=b.a,h.b=b.b,h.c=b.c,h.d=b.d,h}function v(b,h){var l=new S(b),d=h&&h.state,f=function(){return(l.next()>>>0)/4294967296};return f.double=function(){do{var D=((l.next()>>>11)+(l.next()>>>0)/4294967296)/(1<<21)}while(0===D);return D},f.int32=l.next,f.quick=f,d&&("object"==typeof d&&C(d,l),f.state=function(){return C(l,{})}),f}O&&O.exports?O.exports=v:P.amdD&&P.amdO?void 0!==(F=function(){return v}.call(E,P,E,O))&&(O.exports=F):this.tychei=v}(0,me=P.nmd(me))},992:function(me,E,P){var F;!function(A,O,k){function S(b){var h=this,l="";h.x=0,h.y=0,h.z=0,h.w=0,h.next=function(){var f=h.x^h.x<<11;return h.x=h.y,h.y=h.z,h.z=h.w,h.w^=h.w>>>19^f^f>>>8},b===(0|b)?h.x=b:l+=b;for(var d=0;d<l.length+64;d++)h.x^=0|l.charCodeAt(d),h.next()}function C(b,h){return h.x=b.x,h.y=b.y,h.z=b.z,h.w=b.w,h}function v(b,h){var l=new S(b),d=h&&h.state,f=function(){return(l.next()>>>0)/4294967296};return f.double=function(){do{var D=((l.next()>>>11)+(l.next()>>>0)/4294967296)/(1<<21)}while(0===D);return D},f.int32=l.next,f.quick=f,d&&("object"==typeof d&&C(d,l),f.state=function(){return C(l,{})}),f}O&&O.exports?O.exports=v:P.amdD&&P.amdO?void 0!==(F=function(){return v}.call(E,P,E,O))&&(O.exports=F):this.xor128=v}(0,me=P.nmd(me))},929:function(me,E,P){var F;!function(A,O,k){function S(b){var h=this;h.next=function(){var w,D,d=h.w,f=h.X,y=h.i;return h.w=d=d+1640531527|0,D=f[y+34&127],w=f[y=y+1&127],D^=D<<13,w^=w<<17,D=f[y]=(D^=D>>>15)^(w^=w>>>12),h.i=y,D+(d^d>>>16)|0},function l(d,f){var y,w,D,M,$,B=[],z=128;for(f===(0|f)?(w=f,f=null):(f+="\0",w=0,z=Math.max(z,f.length)),D=0,M=-32;M<z;++M)f&&(w^=f.charCodeAt((M+32)%f.length)),0===M&&($=w),w^=w<<10,w^=w>>>15,w^=w<<4,w^=w>>>13,M>=0&&(D=0==(y=B[127&M]^=w+($=$+1640531527|0))?D+1:0);for(D>=128&&(B[127&(f&&f.length||0)]=-1),D=127,M=512;M>0;--M)w=B[D+34&127],y=B[D=D+1&127],w^=w<<13,y^=y<<17,B[D]=(w^=w>>>15)^(y^=y>>>12);d.w=$,d.X=B,d.i=D}(h,b)}function C(b,h){return h.i=b.i,h.w=b.w,h.X=b.X.slice(),h}function v(b,h){null==b&&(b=+new Date);var l=new S(b),d=h&&h.state,f=function(){return(l.next()>>>0)/4294967296};return f.double=function(){do{var D=((l.next()>>>11)+(l.next()>>>0)/4294967296)/(1<<21)}while(0===D);return D},f.int32=l.next,f.quick=f,d&&(d.X&&C(d,l),f.state=function(){return C(l,{})}),f}O&&O.exports?O.exports=v:P.amdD&&P.amdO?void 0!==(F=function(){return v}.call(E,P,E,O))&&(O.exports=F):this.xor4096=v}(0,me=P.nmd(me))},583:function(me,E,P){var F;!function(A,O,k){function S(b){var h=this;h.next=function(){var y,w,d=h.x,f=h.i;return y=d[f],w=(y^=y>>>7)^y<<24,w^=(y=d[f+1&7])^y>>>10,w^=(y=d[f+3&7])^y>>>3,w^=(y=d[f+4&7])^y<<7,y=d[f+7&7],d[f]=w^=(y^=y<<13)^y<<9,h.i=f+1&7,w},function l(d,f){var y,D=[];if(f===(0|f))D[0]=f;else for(f=""+f,y=0;y<f.length;++y)D[7&y]=D[7&y]<<15^f.charCodeAt(y)+D[y+1&7]<<13;for(;D.length<8;)D.push(0);for(y=0;y<8&&0===D[y];++y);for(8==y&&(D[7]=-1),d.x=D,d.i=0,y=256;y>0;--y)d.next()}(h,b)}function C(b,h){return h.x=b.x.slice(),h.i=b.i,h}function v(b,h){null==b&&(b=+new Date);var l=new S(b),d=h&&h.state,f=function(){return(l.next()>>>0)/4294967296};return f.double=function(){do{var D=((l.next()>>>11)+(l.next()>>>0)/4294967296)/(1<<21)}while(0===D);return D},f.int32=l.next,f.quick=f,d&&(d.x&&C(d,l),f.state=function(){return C(l,{})}),f}O&&O.exports?O.exports=v:P.amdD&&P.amdO?void 0!==(F=function(){return v}.call(E,P,E,O))&&(O.exports=F):this.xorshift7=v}(0,me=P.nmd(me))},657:function(me,E,P){var F;!function(A,O,k){function S(b){var h=this,l="";h.next=function(){var f=h.x^h.x>>>2;return h.x=h.y,h.y=h.z,h.z=h.w,h.w=h.v,(h.d=h.d+362437|0)+(h.v=h.v^h.v<<4^f^f<<1)|0},h.x=0,h.y=0,h.z=0,h.w=0,h.v=0,b===(0|b)?h.x=b:l+=b;for(var d=0;d<l.length+64;d++)h.x^=0|l.charCodeAt(d),d==l.length&&(h.d=h.x<<10^h.x>>>4),h.next()}function C(b,h){return h.x=b.x,h.y=b.y,h.z=b.z,h.w=b.w,h.v=b.v,h.d=b.d,h}function v(b,h){var l=new S(b),d=h&&h.state,f=function(){return(l.next()>>>0)/4294967296};return f.double=function(){do{var D=((l.next()>>>11)+(l.next()>>>0)/4294967296)/(1<<21)}while(0===D);return D},f.int32=l.next,f.quick=f,d&&("object"==typeof d&&C(d,l),f.state=function(){return C(l,{})}),f}O&&O.exports?O.exports=v:P.amdD&&P.amdO?void 0!==(F=function(){return v}.call(E,P,E,O))&&(O.exports=F):this.xorwow=v}(0,me=P.nmd(me))},818:function(me,E,P){var F;!function(A,O,k){var y,S=256,h=k.pow(S,6),l=k.pow(2,52),d=2*l,f=S-1;function w(H,te,ae){var J=[],ne=B($((te=1==te?{entropy:!0}:te||{}).entropy?[H,G(O)]:H??function z(){try{var H;return y&&(H=y.randomBytes)?H=H(S):(H=new Uint8Array(S),(A.crypto||A.msCrypto).getRandomValues(H)),G(H)}catch{var te=A.navigator,ae=te&&te.plugins;return[+new Date,A,ae,A.screen,G(O)]}}(),3),J),X=new D(J),K=function(){for(var ve=X.g(6),q=h,re=0;ve<l;)ve=(ve+re)*S,q*=S,re=X.g(1);for(;ve>=d;)ve/=2,q/=2,re>>>=1;return(ve+re)/q};return K.int32=function(){return 0|X.g(4)},K.quick=function(){return X.g(4)/4294967296},K.double=K,B(G(X.S),O),(te.pass||ae||function(ve,q,re,le){return le&&(le.S&&M(le,X),ve.state=function(){return M(X,{})}),re?(k.random=ve,q):ve})(K,ne,"global"in te?te.global:this==k,te.state)}function D(H){var te,ae=H.length,J=this,ne=0,X=J.i=J.j=0,K=J.S=[];for(ae||(H=[ae++]);ne<S;)K[ne]=ne++;for(ne=0;ne<S;ne++)K[ne]=K[X=f&X+H[ne%ae]+(te=K[ne])],K[X]=te;(J.g=function(ve){for(var q,re=0,le=J.i,He=J.j,Le=J.S;ve--;)q=Le[le=f&le+1],re=re*S+Le[f&(Le[le]=Le[He=f&He+q])+(Le[He]=q)];return J.i=le,J.j=He,re})(S)}function M(H,te){return te.i=H.i,te.j=H.j,te.S=H.S.slice(),te}function $(H,te){var ne,ae=[],J=typeof H;if(te&&"object"==J)for(ne in H)try{ae.push($(H[ne],te-1))}catch{}return ae.length?ae:"string"==J?H:H+"\0"}function B(H,te){for(var J,ae=H+"",ne=0;ne<ae.length;)te[f&ne]=f&(J^=19*te[f&ne])+ae.charCodeAt(ne++);return G(te)}function G(H){return String.fromCharCode.apply(0,H)}if(B(k.random(),O),me.exports){me.exports=w;try{y=P(42)}catch{}}else void 0!==(F=function(){return w}.call(E,P,E,me))&&(me.exports=F)}(typeof self<"u"?self:this,[],Math)},410:()=>{},628:()=>{},601:()=>{},792:()=>{},977:()=>{},42:()=>{},156:me=>{function E(F,A,O,k,S,C,v){try{var b=F[C](v),h=b.value}catch(l){return void O(l)}b.done?A(h):Promise.resolve(h).then(k,S)}me.exports=function P(F){return function(){var A=this,O=arguments;return new Promise(function(k,S){var C=F.apply(A,O);function v(h){E(C,k,S,v,b,"next",h)}function b(h){E(C,k,S,v,b,"throw",h)}v(void 0)})}},me.exports.__esModule=!0,me.exports.default=me.exports}},me=>{me(me.s=165)}]);